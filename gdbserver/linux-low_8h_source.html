<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDBserver: /home/stan/gdb/src/gdb/gdbserver/linux-low.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDBserver
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/gdbserver/linux-low.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="linux-low_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Internal interfaces for the GNU/Linux specific target code for gdbserver.</span>
<a name="l00002"></a>00002 <span class="comment">   Copyright (C) 2002-2013 Free Software Foundation, Inc.</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">   This file is part of GDB.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00008"></a>00008 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00009"></a>00009 <span class="comment">   (at your option) any later version.</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00012"></a>00012 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00013"></a>00013 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00014"></a>00014 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;<a class="code" href="gdb__thread__db_8h.html">gdb_thread_db.h</a>&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;signal.h&gt;</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="gdbthread_8h.html">gdbthread.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="gdb__proc__service_8h.html">gdb_proc_service.h</a>&quot;</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="comment">/* Included for ptrace type definitions.  */</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="linux-ptrace_8h.html">linux-ptrace.h</a>&quot;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a><a class="code" href="linux-low_8h.html#acb42c2022fb8fb3532fb5beb771b5cb9">00028</a> <span class="preprocessor">#define PTRACE_XFER_TYPE long</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00030"></a>00030 <span class="preprocessor">#ifdef HAVE_LINUX_REGSETS</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="keyword">typedef</span> void (*regset_fill_func) (<span class="keyword">struct </span><a class="code" href="structregcache.html">regcache</a> *, <span class="keywordtype">void</span> *);
<a name="l00032"></a>00032 <span class="keyword">typedef</span> void (*regset_store_func) (<span class="keyword">struct </span><a class="code" href="structregcache.html">regcache</a> *, <span class="keyword">const</span> <span class="keywordtype">void</span> *);
<a name="l00033"></a>00033 <span class="keyword">enum</span> <a class="code" href="nto-low_8h.html#a399fa299a6e4a717fe68b1dcfed5180b">regset_type</a> {
<a name="l00034"></a>00034   GENERAL_REGS,
<a name="l00035"></a>00035   FP_REGS,
<a name="l00036"></a>00036   EXTENDED_REGS,
<a name="l00037"></a>00037 };
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="keyword">struct </span>regset_info
<a name="l00040"></a>00040 {
<a name="l00041"></a>00041   <span class="keywordtype">int</span> get_request, set_request;
<a name="l00042"></a>00042   <span class="comment">/* If NT_TYPE isn&#39;t 0, it will be passed to ptrace as the 3rd</span>
<a name="l00043"></a>00043 <span class="comment">     argument and the 4th argument should be &quot;const struct iovec *&quot;.  */</span>
<a name="l00044"></a>00044   <span class="keywordtype">int</span> nt_type;
<a name="l00045"></a>00045   <span class="keywordtype">int</span> size;
<a name="l00046"></a>00046   <span class="keyword">enum</span> <a class="code" href="nto-low_8h.html#a399fa299a6e4a717fe68b1dcfed5180b">regset_type</a> type;
<a name="l00047"></a>00047   regset_fill_func fill_function;
<a name="l00048"></a>00048   regset_store_func store_function;
<a name="l00049"></a>00049 };
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="comment">/* Aggregation of all the supported regsets of a given</span>
<a name="l00052"></a>00052 <span class="comment">   architecture/mode.  */</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="keyword">struct </span>regsets_info
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056   <span class="comment">/* The regsets array.  */</span>
<a name="l00057"></a>00057   <span class="keyword">struct </span>regset_info *regsets;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059   <span class="comment">/* The number of regsets in the REGSETS array.  */</span>
<a name="l00060"></a>00060   <span class="keywordtype">int</span> num_regsets;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062   <span class="comment">/* If we get EIO on a regset, do not try it again.  Note the set of</span>
<a name="l00063"></a>00063 <span class="comment">     supported regsets may depend on processor mode on biarch</span>
<a name="l00064"></a>00064 <span class="comment">     machines.  This is a (lazily allocated) array holding one boolean</span>
<a name="l00065"></a>00065 <span class="comment">     byte (0/1) per regset, with each element corresponding to the</span>
<a name="l00066"></a>00066 <span class="comment">     regset in the REGSETS array above at the same offset.  */</span>
<a name="l00067"></a>00067   <span class="keywordtype">char</span> *disabled_regsets;
<a name="l00068"></a>00068 };
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="preprocessor">#endif</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>
<a name="l00072"></a>00072 <span class="comment">/* Mapping between the general-purpose registers in `struct user&#39;</span>
<a name="l00073"></a>00073 <span class="comment">   format and GDB&#39;s register array layout.  */</span>
<a name="l00074"></a>00074 
<a name="l00075"></a><a class="code" href="structusrregs__info.html">00075</a> <span class="keyword">struct </span><a class="code" href="structusrregs__info.html">usrregs_info</a>
<a name="l00076"></a>00076 {
<a name="l00077"></a>00077   <span class="comment">/* The number of registers accessible.  */</span>
<a name="l00078"></a><a class="code" href="structusrregs__info.html#a43da3092f0c564c2c262116220c97e27">00078</a>   <span class="keywordtype">int</span> <a class="code" href="structusrregs__info.html#a43da3092f0c564c2c262116220c97e27">num_regs</a>;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   <span class="comment">/* The registers map.  */</span>
<a name="l00081"></a><a class="code" href="structusrregs__info.html#a9ba8431ce69c86e10a91b98f9ebbebea">00081</a>   <span class="keywordtype">int</span> *<a class="code" href="structusrregs__info.html#a9ba8431ce69c86e10a91b98f9ebbebea">regmap</a>;
<a name="l00082"></a>00082 };
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="comment">/* All info needed to access an architecture/mode&#39;s registers.  */</span>
<a name="l00085"></a>00085 
<a name="l00086"></a><a class="code" href="structregs__info.html">00086</a> <span class="keyword">struct </span><a class="code" href="structregs__info.html">regs_info</a>
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088   <span class="comment">/* Regset support bitmap: 1 for registers that are transferred as a part</span>
<a name="l00089"></a>00089 <span class="comment">     of a regset, 0 for ones that need to be handled individually.  This</span>
<a name="l00090"></a>00090 <span class="comment">     can be NULL if all registers are transferred with regsets or regsets</span>
<a name="l00091"></a>00091 <span class="comment">     are not supported.  */</span>
<a name="l00092"></a><a class="code" href="structregs__info.html#a1ea42f6e3375f600d724da8a4cab57c6">00092</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="structregs__info.html#a1ea42f6e3375f600d724da8a4cab57c6">regset_bitmap</a>;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094   <span class="comment">/* Info used when accessing registers with PTRACE_PEEKUSER /</span>
<a name="l00095"></a>00095 <span class="comment">     PTRACE_POKEUSER.  This can be NULL if all registers are</span>
<a name="l00096"></a>00096 <span class="comment">     transferred with regsets  .*/</span>
<a name="l00097"></a><a class="code" href="structregs__info.html#a304e929c4e75c4fbfb0b00d1c37a4903">00097</a>   <span class="keyword">struct </span><a class="code" href="structusrregs__info.html">usrregs_info</a> *<a class="code" href="structregs__info.html#a304e929c4e75c4fbfb0b00d1c37a4903">usrregs</a>;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="preprocessor">#ifdef HAVE_LINUX_REGSETS</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>  <span class="comment">/* Info used when accessing registers with regsets.  */</span>
<a name="l00101"></a>00101   <span class="keyword">struct </span>regsets_info *regsets_info;
<a name="l00102"></a>00102 <span class="preprocessor">#endif</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span>};
<a name="l00104"></a>00104 
<a name="l00105"></a><a class="code" href="structprocess__info__private.html">00105</a> <span class="keyword">struct </span><a class="code" href="structprocess__info__private.html">process_info_private</a>
<a name="l00106"></a>00106 {
<a name="l00107"></a>00107   <span class="comment">/* Arch-specific additions.  */</span>
<a name="l00108"></a><a class="code" href="structprocess__info__private.html#a97f92519ce1446533ab2dcadc5a9e31a">00108</a>   <span class="keyword">struct </span><a class="code" href="structarch__process__info.html">arch_process_info</a> *<a class="code" href="structprocess__info__private.html#a97f92519ce1446533ab2dcadc5a9e31a">arch_private</a>;
<a name="l00109"></a>00109 
<a name="l00110"></a>00110   <span class="comment">/* libthread_db-specific additions.  Not NULL if this process has loaded</span>
<a name="l00111"></a>00111 <span class="comment">     thread_db, and it is active.  */</span>
<a name="l00112"></a><a class="code" href="structprocess__info__private.html#ad68c2719f606d634f07d66b6ed1f3b1f">00112</a>   <span class="keyword">struct </span><a class="code" href="structthread__db.html">thread_db</a> *<a class="code" href="structprocess__info__private.html#ad68c2719f606d634f07d66b6ed1f3b1f">thread_db</a>;
<a name="l00113"></a>00113 
<a name="l00114"></a>00114   <span class="comment">/* &amp;_r_debug.  0 if not yet determined.  -1 if no PT_DYNAMIC in Phdrs.  */</span>
<a name="l00115"></a><a class="code" href="structprocess__info__private.html#a76220fa8ba96fef860dc3e2d5118c08b">00115</a>   <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> <a class="code" href="structprocess__info__private.html#a76220fa8ba96fef860dc3e2d5118c08b">r_debug</a>;
<a name="l00116"></a>00116 
<a name="l00117"></a>00117   <span class="comment">/* This flag is true iff we&#39;ve just created or attached to the first</span>
<a name="l00118"></a>00118 <span class="comment">     LWP of this process but it has not stopped yet.  As soon as it</span>
<a name="l00119"></a>00119 <span class="comment">     does, we need to call the low target&#39;s arch_setup callback.  */</span>
<a name="l00120"></a><a class="code" href="structprocess__info__private.html#aa40ddc94a7b97c50a32e741865d41f27">00120</a>   <span class="keywordtype">int</span> <a class="code" href="structprocess__info__private.html#aa40ddc94a7b97c50a32e741865d41f27">new_inferior</a>;
<a name="l00121"></a>00121 };
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 <span class="keyword">struct </span><a class="code" href="structlwp__info.html">lwp_info</a>;
<a name="l00124"></a>00124 
<a name="l00125"></a><a class="code" href="structlinux__target__ops.html">00125</a> <span class="keyword">struct </span><a class="code" href="structlinux__target__ops.html">linux_target_ops</a>
<a name="l00126"></a>00126 {
<a name="l00127"></a>00127   <span class="comment">/* Architecture-specific setup.  */</span>
<a name="l00128"></a><a class="code" href="structlinux__target__ops.html#a4a42fd4fd1b9f9d6b43ea211b278d18e">00128</a>   void (*<a class="code" href="structlinux__target__ops.html#a4a42fd4fd1b9f9d6b43ea211b278d18e">arch_setup</a>) (void);
<a name="l00129"></a>00129 
<a name="l00130"></a><a class="code" href="structlinux__target__ops.html#a5688afcefa4a40503f0a3e8dbb05cdb3">00130</a>   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structregs__info.html">regs_info</a> *(*regs_info) (void);
<a name="l00131"></a><a class="code" href="structlinux__target__ops.html#aefa76c0c518f36f412487fb983db21eb">00131</a>   int (*<a class="code" href="structlinux__target__ops.html#aefa76c0c518f36f412487fb983db21eb">cannot_fetch_register</a>) (int);
<a name="l00132"></a>00132 
<a name="l00133"></a>00133   <span class="comment">/* Returns 0 if we can store the register, 1 if we can not</span>
<a name="l00134"></a>00134 <span class="comment">     store the register, and 2 if failure to store the register</span>
<a name="l00135"></a>00135 <span class="comment">     is acceptable.  */</span>
<a name="l00136"></a><a class="code" href="structlinux__target__ops.html#ac261e78ca466b256508795d55a77bf29">00136</a>   int (*<a class="code" href="structlinux__target__ops.html#ac261e78ca466b256508795d55a77bf29">cannot_store_register</a>) (int);
<a name="l00137"></a>00137 
<a name="l00138"></a>00138   <span class="comment">/* Hook to fetch a register in some non-standard way.  Used for</span>
<a name="l00139"></a>00139 <span class="comment">     example by backends that have read-only registers with hardcoded</span>
<a name="l00140"></a>00140 <span class="comment">     values (e.g., IA64&#39;s gr0/fr0/fr1).  Returns true if register</span>
<a name="l00141"></a>00141 <span class="comment">     REGNO was supplied, false if not, and we should fallback to the</span>
<a name="l00142"></a>00142 <span class="comment">     standard ptrace methods.  */</span>
<a name="l00143"></a><a class="code" href="structlinux__target__ops.html#a2332bf4eb7669c9700a5ace890ed51a5">00143</a>   int (*<a class="code" href="structlinux__target__ops.html#a2332bf4eb7669c9700a5ace890ed51a5">fetch_register</a>) (<span class="keyword">struct </span><a class="code" href="structregcache.html">regcache</a> *<a class="code" href="structregcache.html">regcache</a>, <span class="keywordtype">int</span> regno);
<a name="l00144"></a>00144 
<a name="l00145"></a><a class="code" href="structlinux__target__ops.html#a86829586875a60d5b55b8b3c283132c7">00145</a>   <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> (*<a class="code" href="structlinux__target__ops.html#a86829586875a60d5b55b8b3c283132c7">get_pc</a>) (<span class="keyword">struct </span><a class="code" href="structregcache.html">regcache</a> *<a class="code" href="structregcache.html">regcache</a>);
<a name="l00146"></a><a class="code" href="structlinux__target__ops.html#a4437f47a5fb6fb64e1ee3e527c8bfe49">00146</a>   void (*<a class="code" href="structlinux__target__ops.html#a4437f47a5fb6fb64e1ee3e527c8bfe49">set_pc</a>) (<span class="keyword">struct </span><a class="code" href="structregcache.html">regcache</a> *<a class="code" href="structregcache.html">regcache</a>, <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> newpc);
<a name="l00147"></a><a class="code" href="structlinux__target__ops.html#a55236bf8e6b460acf70270d2d3a660fa">00147</a>   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="structlinux__target__ops.html#a55236bf8e6b460acf70270d2d3a660fa">breakpoint</a>;
<a name="l00148"></a><a class="code" href="structlinux__target__ops.html#ab1cb93d18dcf0ea6242603046a1d60d2">00148</a>   <span class="keywordtype">int</span> <a class="code" href="structlinux__target__ops.html#ab1cb93d18dcf0ea6242603046a1d60d2">breakpoint_len</a>;
<a name="l00149"></a><a class="code" href="structlinux__target__ops.html#a23a5b1e9b9c6e964db1655c5cee2101a">00149</a>   <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> (*<a class="code" href="structlinux__target__ops.html#a23a5b1e9b9c6e964db1655c5cee2101a">breakpoint_reinsert_addr</a>) (void);
<a name="l00150"></a>00150 
<a name="l00151"></a><a class="code" href="structlinux__target__ops.html#a6a50ce853ab45ac9c5ea9332336dc884">00151</a>   <span class="keywordtype">int</span> <a class="code" href="structlinux__target__ops.html#a6a50ce853ab45ac9c5ea9332336dc884">decr_pc_after_break</a>;
<a name="l00152"></a><a class="code" href="structlinux__target__ops.html#ac81835e9a92fbe3f38a81feef00890f3">00152</a>   int (*<a class="code" href="structlinux__target__ops.html#ac81835e9a92fbe3f38a81feef00890f3">breakpoint_at</a>) (<a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> pc);
<a name="l00153"></a>00153 
<a name="l00154"></a>00154   <span class="comment">/* Breakpoint and watchpoint related functions.  See target.h for</span>
<a name="l00155"></a>00155 <span class="comment">     comments.  */</span>
<a name="l00156"></a><a class="code" href="structlinux__target__ops.html#ada07163130bdaef078a0e1f3506dea65">00156</a>   int (*<a class="code" href="structlinux__target__ops.html#ada07163130bdaef078a0e1f3506dea65">insert_point</a>) (<span class="keywordtype">char</span> type, <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> addr, <span class="keywordtype">int</span> len);
<a name="l00157"></a><a class="code" href="structlinux__target__ops.html#a5f49d317161567560db333c345eee593">00157</a>   int (*<a class="code" href="structlinux__target__ops.html#a5f49d317161567560db333c345eee593">remove_point</a>) (<span class="keywordtype">char</span> type, <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> addr, <span class="keywordtype">int</span> len);
<a name="l00158"></a><a class="code" href="structlinux__target__ops.html#aaec59e3feafe28ef46b54bf5a6017dac">00158</a>   int (*<a class="code" href="structlinux__target__ops.html#aaec59e3feafe28ef46b54bf5a6017dac">stopped_by_watchpoint</a>) (void);
<a name="l00159"></a><a class="code" href="structlinux__target__ops.html#a7f634a5ab419a8ceea20a30ed5a9c9b7">00159</a>   <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> (*<a class="code" href="structlinux__target__ops.html#a7f634a5ab419a8ceea20a30ed5a9c9b7">stopped_data_address</a>) (void);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161   <span class="comment">/* Hooks to reformat register data for PEEKUSR/POKEUSR (in particular</span>
<a name="l00162"></a>00162 <span class="comment">     for registers smaller than an xfer unit).  */</span>
<a name="l00163"></a><a class="code" href="structlinux__target__ops.html#a524daf0478c933a857bd1d2cb780c91a">00163</a>   void (*<a class="code" href="structlinux__target__ops.html#a524daf0478c933a857bd1d2cb780c91a">collect_ptrace_register</a>) (<span class="keyword">struct </span><a class="code" href="structregcache.html">regcache</a> *<a class="code" href="structregcache.html">regcache</a>,
<a name="l00164"></a>00164                                    <span class="keywordtype">int</span> regno, <span class="keywordtype">char</span> *buf);
<a name="l00165"></a><a class="code" href="structlinux__target__ops.html#afacf193bca451d37d04cc996b529441f">00165</a>   void (*<a class="code" href="structlinux__target__ops.html#afacf193bca451d37d04cc996b529441f">supply_ptrace_register</a>) (<span class="keyword">struct </span><a class="code" href="structregcache.html">regcache</a> *<a class="code" href="structregcache.html">regcache</a>,
<a name="l00166"></a>00166                                   <span class="keywordtype">int</span> regno, <span class="keyword">const</span> <span class="keywordtype">char</span> *buf);
<a name="l00167"></a>00167 
<a name="l00168"></a>00168   <span class="comment">/* Hook to convert from target format to ptrace format and back.</span>
<a name="l00169"></a>00169 <span class="comment">     Returns true if any conversion was done; false otherwise.</span>
<a name="l00170"></a>00170 <span class="comment">     If DIRECTION is 1, then copy from INF to NATIVE.</span>
<a name="l00171"></a>00171 <span class="comment">     If DIRECTION is 0, copy from NATIVE to INF.  */</span>
<a name="l00172"></a><a class="code" href="structlinux__target__ops.html#af501c9c0bccee20297e1eb7d3812fcc0">00172</a>   int (*<a class="code" href="structlinux__target__ops.html#af501c9c0bccee20297e1eb7d3812fcc0">siginfo_fixup</a>) (siginfo_t *native, <span class="keywordtype">void</span> *inf, <span class="keywordtype">int</span> direction);
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <span class="comment">/* Hook to call when a new process is created or attached to.</span>
<a name="l00175"></a>00175 <span class="comment">     If extra per-process architecture-specific data is needed,</span>
<a name="l00176"></a>00176 <span class="comment">     allocate it here.  */</span>
<a name="l00177"></a><a class="code" href="structlinux__target__ops.html#ad195b34895ca0335eb982d053a4deb9e">00177</a>   <span class="keyword">struct </span><a class="code" href="structarch__process__info.html">arch_process_info</a> * (*new_process) (void);
<a name="l00178"></a>00178 
<a name="l00179"></a>00179   <span class="comment">/* Hook to call when a new thread is detected.</span>
<a name="l00180"></a>00180 <span class="comment">     If extra per-thread architecture-specific data is needed,</span>
<a name="l00181"></a>00181 <span class="comment">     allocate it here.  */</span>
<a name="l00182"></a><a class="code" href="structlinux__target__ops.html#a6f377050424b11da6dcb76f6bd348113">00182</a>   <span class="keyword">struct </span><a class="code" href="structarch__lwp__info.html">arch_lwp_info</a> * (*new_thread) (void);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184   <span class="comment">/* Hook to call prior to resuming a thread.  */</span>
<a name="l00185"></a><a class="code" href="structlinux__target__ops.html#afb4a5f576a5d7e0e1017e1780884f95e">00185</a>   void (*<a class="code" href="structlinux__target__ops.html#afb4a5f576a5d7e0e1017e1780884f95e">prepare_to_resume</a>) (<span class="keyword">struct </span><a class="code" href="structlwp__info.html">lwp_info</a> *);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   <span class="comment">/* Hook to support target specific qSupported.  */</span>
<a name="l00188"></a><a class="code" href="structlinux__target__ops.html#ad9b4bd86c02b28c0b0713efca226146c">00188</a>   void (*<a class="code" href="structlinux__target__ops.html#ad9b4bd86c02b28c0b0713efca226146c">process_qsupported</a>) (<span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l00189"></a>00189 
<a name="l00190"></a>00190   <span class="comment">/* Returns true if the low target supports tracepoints.  */</span>
<a name="l00191"></a><a class="code" href="structlinux__target__ops.html#a9ea8e6f6e38c8ef063a4241dd52852bc">00191</a>   int (*<a class="code" href="structlinux__target__ops.html#a9ea8e6f6e38c8ef063a4241dd52852bc">supports_tracepoints</a>) (void);
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   <span class="comment">/* Fill ADDRP with the thread area address of LWPID.  Returns 0 on</span>
<a name="l00194"></a>00194 <span class="comment">     success, -1 on failure.  */</span>
<a name="l00195"></a><a class="code" href="structlinux__target__ops.html#a5199bb1d7633cefc5eb8cf97fab9aa76">00195</a>   int (*<a class="code" href="structlinux__target__ops.html#a5199bb1d7633cefc5eb8cf97fab9aa76">get_thread_area</a>) (<span class="keywordtype">int</span> lwpid, <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> *addrp);
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   <span class="comment">/* Install a fast tracepoint jump pad.  See target.h for</span>
<a name="l00198"></a>00198 <span class="comment">     comments.  */</span>
<a name="l00199"></a><a class="code" href="structlinux__target__ops.html#a1ef93fbd8ec40623470df7f13d3d2e9d">00199</a>   int (*<a class="code" href="structlinux__target__ops.html#a1ef93fbd8ec40623470df7f13d3d2e9d">install_fast_tracepoint_jump_pad</a>) (<a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> tpoint, <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> tpaddr,
<a name="l00200"></a>00200                                            <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> collector,
<a name="l00201"></a>00201                                            <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> lockaddr,
<a name="l00202"></a>00202                                            <a class="code" href="server_8h.html#adce30805278e3c87af2f711c18d7507a">ULONGEST</a> orig_size,
<a name="l00203"></a>00203                                            <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> *jump_entry,
<a name="l00204"></a>00204                                            <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> *trampoline,
<a name="l00205"></a>00205                                            <a class="code" href="server_8h.html#adce30805278e3c87af2f711c18d7507a">ULONGEST</a> *trampoline_size,
<a name="l00206"></a>00206                                            <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *jjump_pad_insn,
<a name="l00207"></a>00207                                            <a class="code" href="server_8h.html#adce30805278e3c87af2f711c18d7507a">ULONGEST</a> *jjump_pad_insn_size,
<a name="l00208"></a>00208                                            <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> *adjusted_insn_addr,
<a name="l00209"></a>00209                                            <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> *adjusted_insn_addr_end,
<a name="l00210"></a>00210                                            <span class="keywordtype">char</span> *err);
<a name="l00211"></a>00211 
<a name="l00212"></a>00212   <span class="comment">/* Return the bytecode operations vector for the current inferior.</span>
<a name="l00213"></a>00213 <span class="comment">     Returns NULL if bytecode compilation is not supported.  */</span>
<a name="l00214"></a><a class="code" href="structlinux__target__ops.html#a01f65721b7fb514b39fc20903bf87808">00214</a>   <span class="keyword">struct </span><a class="code" href="structemit__ops.html">emit_ops</a> *(*emit_ops) (void);
<a name="l00215"></a>00215 
<a name="l00216"></a>00216   <span class="comment">/* Return the minimum length of an instruction that can be safely overwritten</span>
<a name="l00217"></a>00217 <span class="comment">     for use as a fast tracepoint.  */</span>
<a name="l00218"></a><a class="code" href="structlinux__target__ops.html#afa41b03c9d90e232cefde4b0258bd0ea">00218</a>   int (*<a class="code" href="structlinux__target__ops.html#afa41b03c9d90e232cefde4b0258bd0ea">get_min_fast_tracepoint_insn_len</a>) (void);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220   <span class="comment">/* Returns true if the low target supports range stepping.  */</span>
<a name="l00221"></a><a class="code" href="structlinux__target__ops.html#add90141e1aa4b2bc54114a0da4519b9d">00221</a>   int (*<a class="code" href="structlinux__target__ops.html#add90141e1aa4b2bc54114a0da4519b9d">supports_range_stepping</a>) (void);
<a name="l00222"></a>00222 };
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structlinux__target__ops.html">linux_target_ops</a> <a class="code" href="linux-aarch64-low_8c.html#a24f25e04392bbb03d79865c0e48f1aba">the_low_target</a>;
<a name="l00225"></a>00225 
<a name="l00226"></a><a class="code" href="linux-low_8h.html#a043f2e690bf157d15b4814e49e54680f">00226</a> <span class="preprocessor">#define ptid_of(proc) ((proc)-&gt;head.id)</span>
<a name="l00227"></a><a class="code" href="linux-low_8h.html#a94bb3d6065aa37bd2c5085003fb0c24a">00227</a> <span class="preprocessor"></span><span class="preprocessor">#define pid_of(proc) ptid_get_pid ((proc)-&gt;head.id)</span>
<a name="l00228"></a><a class="code" href="linux-low_8h.html#a7c9dbce5a1b558c894f646d29b94433c">00228</a> <span class="preprocessor"></span><span class="preprocessor">#define lwpid_of(proc) ptid_get_lwp ((proc)-&gt;head.id)</span>
<a name="l00229"></a>00229 <span class="preprocessor"></span>
<a name="l00230"></a><a class="code" href="linux-low_8h.html#aee529cba03d5cafd29ef3bd37d6f2fc5">00230</a> <span class="preprocessor">#define get_lwp(inf) ((struct lwp_info *)(inf))</span>
<a name="l00231"></a><a class="code" href="linux-low_8h.html#a1639d548371b2563cbcbe25ed8b79770">00231</a> <span class="preprocessor"></span><span class="preprocessor">#define get_thread_lwp(thr) (get_lwp (inferior_target_data (thr)))</span>
<a name="l00232"></a><a class="code" href="linux-low_8h.html#a44594daa7d5f680e681200b2c0c2286e">00232</a> <span class="preprocessor"></span><span class="preprocessor">#define get_lwp_thread(proc) ((struct thread_info *)                    \</span>
<a name="l00233"></a>00233 <span class="preprocessor">                              find_inferior_id (&amp;all_threads,           \</span>
<a name="l00234"></a>00234 <span class="preprocessor">                                                get_lwp (proc)-&gt;head.id))</span>
<a name="l00235"></a>00235 <span class="preprocessor"></span>
<a name="l00236"></a><a class="code" href="structlwp__info.html">00236</a> <span class="keyword">struct </span><a class="code" href="structlwp__info.html">lwp_info</a>
<a name="l00237"></a>00237 {
<a name="l00238"></a><a class="code" href="structlwp__info.html#aa1838491b3a2d5c60dff233fc60c9ace">00238</a>   <span class="keyword">struct </span><a class="code" href="structinferior__list__entry.html">inferior_list_entry</a> <a class="code" href="structlwp__info.html#aa1838491b3a2d5c60dff233fc60c9ace">head</a>;
<a name="l00239"></a>00239 
<a name="l00240"></a>00240   <span class="comment">/* If this flag is set, the next SIGSTOP will be ignored (the</span>
<a name="l00241"></a>00241 <span class="comment">     process will be immediately resumed).  This means that either we</span>
<a name="l00242"></a>00242 <span class="comment">     sent the SIGSTOP to it ourselves and got some other pending event</span>
<a name="l00243"></a>00243 <span class="comment">     (so the SIGSTOP is still pending), or that we stopped the</span>
<a name="l00244"></a>00244 <span class="comment">     inferior implicitly via PTRACE_ATTACH and have not waited for it</span>
<a name="l00245"></a>00245 <span class="comment">     yet.  */</span>
<a name="l00246"></a><a class="code" href="structlwp__info.html#a50c11467a9958321fd5cd9e063d76052">00246</a>   <span class="keywordtype">int</span> <a class="code" href="structlwp__info.html#a50c11467a9958321fd5cd9e063d76052">stop_expected</a>;
<a name="l00247"></a>00247 
<a name="l00248"></a>00248   <span class="comment">/* When this is true, we shall not try to resume this thread, even</span>
<a name="l00249"></a>00249 <span class="comment">     if last_resume_kind isn&#39;t resume_stop.  */</span>
<a name="l00250"></a><a class="code" href="structlwp__info.html#a45c2d4f42164dc95dce5ef65944b1649">00250</a>   <span class="keywordtype">int</span> <a class="code" href="structlwp__info.html#a45c2d4f42164dc95dce5ef65944b1649">suspended</a>;
<a name="l00251"></a>00251 
<a name="l00252"></a>00252   <span class="comment">/* If this flag is set, the lwp is known to be stopped right now (stop</span>
<a name="l00253"></a>00253 <span class="comment">     event already received in a wait()).  */</span>
<a name="l00254"></a><a class="code" href="structlwp__info.html#a8b51de0f6db2790336402296bbda3176">00254</a>   <span class="keywordtype">int</span> <a class="code" href="structlwp__info.html#a8b51de0f6db2790336402296bbda3176">stopped</a>;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256   <span class="comment">/* If this flag is set, the lwp is known to be dead already (exit</span>
<a name="l00257"></a>00257 <span class="comment">     event already received in a wait(), and is cached in</span>
<a name="l00258"></a>00258 <span class="comment">     status_pending).  */</span>
<a name="l00259"></a><a class="code" href="structlwp__info.html#adaa42d973311f086d9d84b2e7e4d790a">00259</a>   <span class="keywordtype">int</span> <a class="code" href="structlwp__info.html#adaa42d973311f086d9d84b2e7e4d790a">dead</a>;
<a name="l00260"></a>00260 
<a name="l00261"></a>00261   <span class="comment">/* When stopped is set, the last wait status recorded for this lwp.  */</span>
<a name="l00262"></a><a class="code" href="structlwp__info.html#a0b647f9f56dba1603180aaa645538463">00262</a>   <span class="keywordtype">int</span> <a class="code" href="structlwp__info.html#a0b647f9f56dba1603180aaa645538463">last_status</a>;
<a name="l00263"></a>00263 
<a name="l00264"></a>00264   <span class="comment">/* When stopped is set, this is where the lwp stopped, with</span>
<a name="l00265"></a>00265 <span class="comment">     decr_pc_after_break already accounted for.  */</span>
<a name="l00266"></a><a class="code" href="structlwp__info.html#a0a35eb9fff9d87ddf3aec9d0be58a74a">00266</a>   <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> <a class="code" href="structlwp__info.html#a0a35eb9fff9d87ddf3aec9d0be58a74a">stop_pc</a>;
<a name="l00267"></a>00267 
<a name="l00268"></a>00268   <span class="comment">/* If this flag is set, STATUS_PENDING is a waitstatus that has not yet</span>
<a name="l00269"></a>00269 <span class="comment">     been reported.  */</span>
<a name="l00270"></a><a class="code" href="structlwp__info.html#a06d72174a98904774838ad065b22dbff">00270</a>   <span class="keywordtype">int</span> <a class="code" href="structlwp__info.html#a06d72174a98904774838ad065b22dbff">status_pending_p</a>;
<a name="l00271"></a><a class="code" href="structlwp__info.html#a9118995c6bc80a31dc55bf592ff8e78c">00271</a>   <span class="keywordtype">int</span> <a class="code" href="structlwp__info.html#a9118995c6bc80a31dc55bf592ff8e78c">status_pending</a>;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273   <span class="comment">/* STOPPED_BY_WATCHPOINT is non-zero if this LWP stopped with a data</span>
<a name="l00274"></a>00274 <span class="comment">     watchpoint trap.  */</span>
<a name="l00275"></a><a class="code" href="structlwp__info.html#a8c614d4fa52a4d8a1093826d421f7735">00275</a>   <span class="keywordtype">int</span> <a class="code" href="structlwp__info.html#a8c614d4fa52a4d8a1093826d421f7735">stopped_by_watchpoint</a>;
<a name="l00276"></a>00276 
<a name="l00277"></a>00277   <span class="comment">/* On architectures where it is possible to know the data address of</span>
<a name="l00278"></a>00278 <span class="comment">     a triggered watchpoint, STOPPED_DATA_ADDRESS is non-zero, and</span>
<a name="l00279"></a>00279 <span class="comment">     contains such data address.  Only valid if STOPPED_BY_WATCHPOINT</span>
<a name="l00280"></a>00280 <span class="comment">     is true.  */</span>
<a name="l00281"></a><a class="code" href="structlwp__info.html#a760920cc629a065c444e10103dff6f06">00281</a>   <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> <a class="code" href="structlwp__info.html#a760920cc629a065c444e10103dff6f06">stopped_data_address</a>;
<a name="l00282"></a>00282 
<a name="l00283"></a>00283   <span class="comment">/* If this is non-zero, it is a breakpoint to be reinserted at our next</span>
<a name="l00284"></a>00284 <span class="comment">     stop (SIGTRAP stops only).  */</span>
<a name="l00285"></a><a class="code" href="structlwp__info.html#af529cdd777b03aa1ff3277a307cc8970">00285</a>   <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> <a class="code" href="structlwp__info.html#af529cdd777b03aa1ff3277a307cc8970">bp_reinsert</a>;
<a name="l00286"></a>00286 
<a name="l00287"></a>00287   <span class="comment">/* If this flag is set, the last continue operation at the ptrace</span>
<a name="l00288"></a>00288 <span class="comment">     level on this process was a single-step.  */</span>
<a name="l00289"></a><a class="code" href="structlwp__info.html#aceb2e5672c59bd6143f7e2a4bfd7de34">00289</a>   <span class="keywordtype">int</span> <a class="code" href="structlwp__info.html#aceb2e5672c59bd6143f7e2a4bfd7de34">stepping</a>;
<a name="l00290"></a>00290 
<a name="l00291"></a>00291   <span class="comment">/* Range to single step within.  This is a copy of the step range</span>
<a name="l00292"></a>00292 <span class="comment">     passed along the last resume request.  See &#39;struct</span>
<a name="l00293"></a>00293 <span class="comment">     thread_resume&#39;.  */</span>
<a name="l00294"></a><a class="code" href="structlwp__info.html#a7419951d035c060630a051aa5a118e05">00294</a>   <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> <a class="code" href="structlwp__info.html#a7419951d035c060630a051aa5a118e05">step_range_start</a>;   <span class="comment">/* Inclusive */</span>
<a name="l00295"></a><a class="code" href="structlwp__info.html#a870a8c641fe6caec8900030106c8348e">00295</a>   <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> <a class="code" href="structlwp__info.html#a870a8c641fe6caec8900030106c8348e">step_range_end</a>;     <span class="comment">/* Exclusive */</span>
<a name="l00296"></a>00296 
<a name="l00297"></a>00297   <span class="comment">/* If this flag is set, we need to set the event request flags the</span>
<a name="l00298"></a>00298 <span class="comment">     next time we see this LWP stop.  */</span>
<a name="l00299"></a><a class="code" href="structlwp__info.html#aadb1d4be828b353d7bd733921c6184ee">00299</a>   <span class="keywordtype">int</span> <a class="code" href="structlwp__info.html#aadb1d4be828b353d7bd733921c6184ee">must_set_ptrace_flags</a>;
<a name="l00300"></a>00300 
<a name="l00301"></a>00301   <span class="comment">/* If this is non-zero, it points to a chain of signals which need to</span>
<a name="l00302"></a>00302 <span class="comment">     be delivered to this process.  */</span>
<a name="l00303"></a><a class="code" href="structlwp__info.html#aa0171514fcb299f092b077076a7aef50">00303</a>   <span class="keyword">struct </span><a class="code" href="structpending__signals.html">pending_signals</a> *<a class="code" href="structlwp__info.html#aa0171514fcb299f092b077076a7aef50">pending_signals</a>;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305   <span class="comment">/* A link used when resuming.  It is initialized from the resume request,</span>
<a name="l00306"></a>00306 <span class="comment">     and then processed and cleared in linux_resume_one_lwp.  */</span>
<a name="l00307"></a><a class="code" href="structlwp__info.html#a09d4250c4a33da3bac16c3d8ccf50678">00307</a>   <span class="keyword">struct </span><a class="code" href="structthread__resume.html">thread_resume</a> *<a class="code" href="structlwp__info.html#a09d4250c4a33da3bac16c3d8ccf50678">resume</a>;
<a name="l00308"></a>00308 
<a name="l00309"></a>00309   <span class="comment">/* True if it is known that this lwp is presently collecting a fast</span>
<a name="l00310"></a>00310 <span class="comment">     tracepoint (it is in the jump pad or in some code that will</span>
<a name="l00311"></a>00311 <span class="comment">     return to the jump pad.  Normally, we won&#39;t care about this, but</span>
<a name="l00312"></a>00312 <span class="comment">     we will if a signal arrives to this lwp while it is</span>
<a name="l00313"></a>00313 <span class="comment">     collecting.  */</span>
<a name="l00314"></a><a class="code" href="structlwp__info.html#a07f63ce54caa2dcb38255c3bd5488b64">00314</a>   <span class="keywordtype">int</span> <a class="code" href="structlwp__info.html#a07f63ce54caa2dcb38255c3bd5488b64">collecting_fast_tracepoint</a>;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   <span class="comment">/* If this is non-zero, it points to a chain of signals which need</span>
<a name="l00317"></a>00317 <span class="comment">     to be reported to GDB.  These were deferred because the thread</span>
<a name="l00318"></a>00318 <span class="comment">     was doing a fast tracepoint collect when they arrived.  */</span>
<a name="l00319"></a><a class="code" href="structlwp__info.html#a0e6b5ba7cb9710d3472ede54d9add571">00319</a>   <span class="keyword">struct </span><a class="code" href="structpending__signals.html">pending_signals</a> *<a class="code" href="structlwp__info.html#a0e6b5ba7cb9710d3472ede54d9add571">pending_signals_to_report</a>;
<a name="l00320"></a>00320 
<a name="l00321"></a>00321   <span class="comment">/* When collecting_fast_tracepoint is first found to be 1, we insert</span>
<a name="l00322"></a>00322 <span class="comment">     a exit-jump-pad-quickly breakpoint.  This is it.  */</span>
<a name="l00323"></a><a class="code" href="structlwp__info.html#a72b795c1e27240eeb0a4886804dec805">00323</a>   <span class="keyword">struct </span><a class="code" href="structbreakpoint.html">breakpoint</a> *<a class="code" href="structlwp__info.html#a72b795c1e27240eeb0a4886804dec805">exit_jump_pad_bkpt</a>;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325   <span class="comment">/* True if the LWP was seen stop at an internal breakpoint and needs</span>
<a name="l00326"></a>00326 <span class="comment">     stepping over later when it is resumed.  */</span>
<a name="l00327"></a><a class="code" href="structlwp__info.html#a5b89f0335930384a723c6bea2088afe9">00327</a>   <span class="keywordtype">int</span> <a class="code" href="structlwp__info.html#a5b89f0335930384a723c6bea2088afe9">need_step_over</a>;
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 <span class="preprocessor">#ifdef USE_THREAD_DB</span>
<a name="l00330"></a>00330 <span class="preprocessor"></span>  <span class="keywordtype">int</span> thread_known;
<a name="l00331"></a>00331   <span class="comment">/* The thread handle, used for e.g. TLS access.  Only valid if</span>
<a name="l00332"></a>00332 <span class="comment">     THREAD_KNOWN is set.  */</span>
<a name="l00333"></a>00333   <a class="code" href="structtd__thrhandle.html">td_thrhandle_t</a> th;
<a name="l00334"></a>00334 <span class="preprocessor">#endif</span>
<a name="l00335"></a>00335 <span class="preprocessor"></span>
<a name="l00336"></a>00336   <span class="comment">/* Arch-specific additions.  */</span>
<a name="l00337"></a><a class="code" href="structlwp__info.html#ad17b082d79a4a4216b38bec2ad2357eb">00337</a>   <span class="keyword">struct </span><a class="code" href="structarch__lwp__info.html">arch_lwp_info</a> *<a class="code" href="structlwp__info.html#ad17b082d79a4a4216b38bec2ad2357eb">arch_private</a>;
<a name="l00338"></a>00338 };
<a name="l00339"></a>00339 
<a name="l00340"></a>00340 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structinferior__list.html">inferior_list</a> <a class="code" href="linux-low_8c.html#a6c6d5b76c55d004515ba0ab562e1be63">all_lwps</a>;
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 <span class="keywordtype">int</span> <a class="code" href="linux-low_8c.html#ae679a322c8f2690148ed315e0fc74cdc">linux_pid_exe_is_elf_64_file</a> (<span class="keywordtype">int</span> pid, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *machine);
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="keywordtype">void</span> <a class="code" href="linux-low_8c.html#a60b64997f687d9c3afb77046b32ea8f3">linux_attach_lwp</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pid);
<a name="l00345"></a>00345 <span class="keyword">struct </span><a class="code" href="structlwp__info.html">lwp_info</a> *<a class="code" href="linux-low_8c.html#a11cad62a09e5da28dd1c9ca8163e9796">find_lwp_pid</a> (<a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a>);
<a name="l00346"></a>00346 <span class="keywordtype">void</span> <a class="code" href="linux-low_8c.html#a0f17fd0559cc3fe74be859a824c5a09a">linux_stop_lwp</a> (<span class="keyword">struct</span> <a class="code" href="structlwp__info.html">lwp_info</a> *lwp);
<a name="l00347"></a>00347 
<a name="l00348"></a>00348 <span class="preprocessor">#ifdef HAVE_LINUX_REGSETS</span>
<a name="l00349"></a>00349 <span class="preprocessor"></span><span class="keywordtype">void</span> initialize_regsets_info (<span class="keyword">struct</span> regsets_info *regsets_info);
<a name="l00350"></a>00350 <span class="preprocessor">#endif</span>
<a name="l00351"></a>00351 <span class="preprocessor"></span>
<a name="l00352"></a>00352 <span class="keywordtype">void</span> <a class="code" href="linux-aarch64-low_8c.html#a2bde0fd4f9e3b5aa339518a3eb0aec24">initialize_low_arch</a> (<span class="keywordtype">void</span>);
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 <span class="comment">/* From thread-db.c  */</span>
<a name="l00355"></a>00355 <span class="keywordtype">int</span> <a class="code" href="linux-low_8h.html#ab66e4c236b01b27b4a935b6a43bd28c4">thread_db_init</a> (<span class="keywordtype">int</span> use_events);
<a name="l00356"></a>00356 <span class="keywordtype">void</span> <a class="code" href="linux-low_8h.html#a7a9c0d39a8e622c90cc535348ac88ae7">thread_db_detach</a> (<span class="keyword">struct</span> <a class="code" href="structprocess__info.html">process_info</a> *);
<a name="l00357"></a>00357 <span class="keywordtype">void</span> <a class="code" href="linux-low_8h.html#a73a3b3cd5eee98602122d262161b1ecd">thread_db_mourn</a> (<span class="keyword">struct</span> <a class="code" href="structprocess__info.html">process_info</a> *);
<a name="l00358"></a>00358 <span class="keywordtype">int</span> <a class="code" href="linux-low_8h.html#a64b434d389ffd83817526d4e4276bf55">thread_db_handle_monitor_command</a> (<span class="keywordtype">char</span> *);
<a name="l00359"></a>00359 <span class="keywordtype">int</span> <a class="code" href="linux-low_8h.html#ab57df5864a91a4d735ff12fbc8a16716">thread_db_get_tls_address</a> (<span class="keyword">struct</span> <a class="code" href="structthread__info.html">thread_info</a> *thread, <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> <a class="code" href="tracepoint_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>,
<a name="l00360"></a>00360                                <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> load_module, <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> *address);
<a name="l00361"></a>00361 <span class="keywordtype">int</span> <a class="code" href="linux-low_8h.html#a57bc3ba5684ca92176c2a298fd5e07bb">thread_db_look_up_one_symbol</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="tracepoint_8c.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>, <a class="code" href="server_8h.html#a68431e89ee8e71cccbf3da059e7b08c4">CORE_ADDR</a> *addrp);
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 10 2013 17:23:18 for GDBserver by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
