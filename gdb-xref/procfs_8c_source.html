<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (xrefs): /home/stan/gdb/src/gdb/procfs.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (xrefs)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/procfs.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="procfs_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Machine independent support for SVR4 /proc (process file system) for GDB.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 1999-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   Written by Michael Snyder at Cygnus Solutions.</span>
<a name="l00006"></a>00006 <span class="comment">   Based on work by Fred Fish, Stu Grossman, Geoff Noer, and others.</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">   This file is part of GDB.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00011"></a>00011 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00012"></a>00012 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00013"></a>00013 <span class="comment">   (at your option) any later version.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00016"></a>00016 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00017"></a>00017 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00018"></a>00018 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00021"></a>00021 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="inferior_8h.html">inferior.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="target_8h.html">target.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="gdbcore_8h.html">gdbcore.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;elf-bfd.h&quot;</span>            <span class="comment">/* for elfcore_write_* */</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="gdbcmd_8h.html">gdbcmd.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="gdbthread_8h.html">gdbthread.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="regcache_8h.html">regcache.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="inf-child_8h.html">inf-child.h</a>&quot;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#if defined (NEW_PROC_API)</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span><span class="preprocessor">#define _STRUCTURED_PROC 1      </span><span class="comment">/* Should be done by configure script.  */</span>
<a name="l00035"></a>00035 <span class="preprocessor">#endif</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;sys/procfs.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#ifdef HAVE_SYS_FAULT_H</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/fault.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#endif</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_SYS_SYSCALL_H</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/syscall.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#endif</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/errno.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="gdb__wait_8h.html">gdb_wait.h</a>&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;signal.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="gdb__bfd_8h.html">gdb_bfd.h</a>&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;<a class="code" href="gdb__string_8h.html">gdb_string.h</a>&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;<a class="code" href="gdb__assert_8h.html">gdb_assert.h</a>&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;<a class="code" href="inflow_8h.html">inflow.h</a>&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;<a class="code" href="auxv_8h.html">auxv.h</a>&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;<a class="code" href="procfs_8h.html">procfs.h</a>&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;<a class="code" href="observer_8h.html">observer.h</a>&quot;</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="comment">/* This module provides the interface between GDB and the</span>
<a name="l00057"></a>00057 <span class="comment">   /proc file system, which is used on many versions of Unix</span>
<a name="l00058"></a>00058 <span class="comment">   as a means for debuggers to control other processes.</span>
<a name="l00059"></a>00059 <span class="comment"></span>
<a name="l00060"></a>00060 <span class="comment">   Examples of the systems that use this interface are:</span>
<a name="l00061"></a>00061 <span class="comment"></span>
<a name="l00062"></a>00062 <span class="comment">     Irix</span>
<a name="l00063"></a>00063 <span class="comment">     Solaris</span>
<a name="l00064"></a>00064 <span class="comment">     OSF</span>
<a name="l00065"></a>00065 <span class="comment">     AIX5</span>
<a name="l00066"></a>00066 <span class="comment"></span>
<a name="l00067"></a>00067 <span class="comment">   /proc works by imitating a file system: you open a simulated file</span>
<a name="l00068"></a>00068 <span class="comment">   that represents the process you wish to interact with, and perform</span>
<a name="l00069"></a>00069 <span class="comment">   operations on that &quot;file&quot; in order to examine or change the state</span>
<a name="l00070"></a>00070 <span class="comment">   of the other process.</span>
<a name="l00071"></a>00071 <span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">   The most important thing to know about /proc and this module is</span>
<a name="l00073"></a>00073 <span class="comment">   that there are two very different interfaces to /proc:</span>
<a name="l00074"></a>00074 <span class="comment"></span>
<a name="l00075"></a>00075 <span class="comment">     One that uses the ioctl system call, and another that uses read</span>
<a name="l00076"></a>00076 <span class="comment">     and write system calls.</span>
<a name="l00077"></a>00077 <span class="comment"></span>
<a name="l00078"></a>00078 <span class="comment">   This module has to support both /proc interfaces.  This means that</span>
<a name="l00079"></a>00079 <span class="comment">   there are two different ways of doing every basic operation.</span>
<a name="l00080"></a>00080 <span class="comment"></span>
<a name="l00081"></a>00081 <span class="comment">   In order to keep most of the code simple and clean, I have defined</span>
<a name="l00082"></a>00082 <span class="comment">   an interface &quot;layer&quot; which hides all these system calls.  An ifdef</span>
<a name="l00083"></a>00083 <span class="comment">   (NEW_PROC_API) determines which interface we are using, and most or</span>
<a name="l00084"></a>00084 <span class="comment">   all occurrances of this ifdef should be confined to this interface</span>
<a name="l00085"></a>00085 <span class="comment">   layer.  */</span>
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="comment">/* Determine which /proc API we are using: The ioctl API defines</span>
<a name="l00088"></a>00088 <span class="comment">   PIOCSTATUS, while the read/write (multiple fd) API never does.  */</span>
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00092"></a>00092 <span class="preprocessor">#include &quot;<a class="code" href="gdb__dirent_8h.html">gdb_dirent.h</a>&quot;</span> <span class="comment">/* opendir/readdir, for listing the LWP&#39;s */</span>
<a name="l00093"></a>00093 <span class="preprocessor">#endif</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span>
<a name="l00095"></a>00095 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>      <span class="comment">/* for O_RDONLY */</span>
<a name="l00096"></a>00096 <span class="preprocessor">#include &lt;unistd.h&gt;</span>     <span class="comment">/* for &quot;X_OK&quot; */</span>
<a name="l00097"></a>00097 <span class="preprocessor">#include &quot;<a class="code" href="gdb__stat_8h.html">gdb_stat.h</a>&quot;</span>   <span class="comment">/* for struct stat */</span>
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="comment">/* Note: procfs-utils.h must be included after the above system header</span>
<a name="l00100"></a>00100 <span class="comment">   files, because it redefines various system calls using macros.</span>
<a name="l00101"></a>00101 <span class="comment">   This may be incompatible with the prototype declarations.  */</span>
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="preprocessor">#include &quot;<a class="code" href="proc-utils_8h.html">proc-utils.h</a>&quot;</span>
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 <span class="comment">/* Prototypes for supply_gregset etc.  */</span>
<a name="l00106"></a>00106 <span class="preprocessor">#include &quot;<a class="code" href="gregset_8h.html">gregset.h</a>&quot;</span>
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="comment">/* =================== TARGET_OPS &quot;MODULE&quot; =================== */</span>
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="comment">/* This module defines the GDB target vector and its methods.  */</span>
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#ad90b52d13ae8d868b4fc3e8e6a7ede28">procfs_attach</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *, <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>);
<a name="l00113"></a>00113 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#aba2a9d7aaf48b661b2007c57749cc2fa">procfs_detach</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *, <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>);
<a name="l00114"></a>00114 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#a172a8e5cc4dbcb8e0ff8a67dbaabe58a">procfs_resume</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *,
<a name="l00115"></a>00115                            <a class="code" href="structptid.html">ptid_t</a>, <span class="keywordtype">int</span>, <span class="keyword">enum</span> gdb_signal);
<a name="l00116"></a>00116 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#a28b2e19292b62274a2ece8025614716e">procfs_stop</a> (<a class="code" href="structptid.html">ptid_t</a>);
<a name="l00117"></a>00117 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#a2f8758826b72fd2021061324c6e047e1">procfs_files_info</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l00118"></a>00118 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#aa018896dbc17e29f83fa7a79f6eba535">procfs_fetch_registers</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *,
<a name="l00119"></a>00119                                     <span class="keyword">struct</span> <a class="code" href="structregcache.html">regcache</a> *, <span class="keywordtype">int</span>);
<a name="l00120"></a>00120 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="nto-procfs_8c.html#a44d7783e99db7311e058e6c32fa701a9">procfs_store_registers</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *,
<a name="l00121"></a>00121                                     <span class="keyword">struct</span> <a class="code" href="structregcache.html">regcache</a> *, <span class="keywordtype">int</span>);
<a name="l00122"></a>00122 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#a92457ed7ea9f9921b2dfe6a0e03e9fe7">procfs_pass_signals</a> (<span class="keywordtype">int</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *);
<a name="l00123"></a>00123 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#a9e0074e6a1c64ae9a12f8bbc7dfabdad">procfs_kill_inferior</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops);
<a name="l00124"></a>00124 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#a147a0734a33ddc5c6f60a741658ef5da">procfs_mourn_inferior</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops);
<a name="l00125"></a>00125 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#a0b1570ab4c815fbae40a320dd7483258">procfs_create_inferior</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *, <span class="keywordtype">char</span> *,
<a name="l00126"></a>00126                                     <span class="keywordtype">char</span> *, <span class="keywordtype">char</span> **, <span class="keywordtype">int</span>);
<a name="l00127"></a>00127 <span class="keyword">static</span> <a class="code" href="structptid.html">ptid_t</a> <a class="code" href="procfs_8c.html#a3d55bc6a9a2a8842d23a3c352d6fc0c2">procfs_wait</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *,
<a name="l00128"></a>00128                            <a class="code" href="structptid.html">ptid_t</a>, <span class="keyword">struct</span> <a class="code" href="structtarget__waitstatus.html">target_waitstatus</a> *, <span class="keywordtype">int</span>);
<a name="l00129"></a>00129 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="procfs_8c.html#a7f53c1daa362f19a41f64509f422fc46">procfs_xfer_memory</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>,
<a name="l00130"></a>00130                                <span class="keyword">struct</span> <a class="code" href="structmem__attrib.html">mem_attrib</a> *attrib,
<a name="l00131"></a>00131                                <span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l00132"></a>00132 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="procfs_8c.html#a002b7fd3f79adc554869931ff15b0c7f">procfs_xfer_partial</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l00133"></a>00133                                     <span class="keyword">enum</span> <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2">target_object</a> <span class="keywordtype">object</span>,
<a name="l00134"></a>00134                                     <span class="keyword">const</span> <span class="keywordtype">char</span> *annex,
<a name="l00135"></a>00135                                     <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *readbuf,
<a name="l00136"></a>00136                                     <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *writebuf,
<a name="l00137"></a>00137                                     <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>);
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="procfs_8c.html#accf520d09111d863ccec709512dd0a88">procfs_thread_alive</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops, <a class="code" href="structptid.html">ptid_t</a>);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#a87845a7f84fc5b0f35b0c05728547bb6">procfs_find_new_threads</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops);
<a name="l00142"></a>00142 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="procfs_8c.html#ae4991ccbc9f5e4ee6355bae8da57c075">procfs_pid_to_str</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *, <a class="code" href="structptid.html">ptid_t</a>);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="procfs_8c.html#a092e007a97789383548b894507d1d427">proc_find_memory_regions</a> (<a class="code" href="defs_8h.html#a9d6528d2f701ee8e47c35c038752ac99">find_memory_region_ftype</a>, <span class="keywordtype">void</span> *);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="keyword">static</span> <span class="keywordtype">char</span> * <a class="code" href="procfs_8c.html#afb51266a729cd7c07438948856cbf72a">procfs_make_note_section</a> (bfd *, <span class="keywordtype">int</span> *);
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="procfs_8c.html#ab5ce316727a6fd139fa218545e095b28">procfs_can_use_hw_breakpoint</a> (<span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#af62e88d644ae20074ae2801e643a0b2f">procfs_info_proc</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *, <span class="keywordtype">char</span> *,
<a name="l00151"></a>00151                               <span class="keyword">enum</span> <a class="code" href="defs_8h.html#a766e85723d7470eb8519ed31b1ef8bf4">info_proc_what</a>);
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="preprocessor">#if defined (PR_MODEL_NATIVE) &amp;&amp; (PR_MODEL_NATIVE == PR_MODEL_LP64)</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span><span class="comment">/* When GDB is built as 64-bit application on Solaris, the auxv data</span>
<a name="l00155"></a>00155 <span class="comment">   is presented in 64-bit format.  We need to provide a custom parser</span>
<a name="l00156"></a>00156 <span class="comment">   to handle that.  */</span>
<a name="l00157"></a>00157 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00158"></a>00158 procfs_auxv_parse (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **readptr,
<a name="l00159"></a>00159                    <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *endptr, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *<a class="code" href="structtype.html">typep</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *valp)
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ());
<a name="l00162"></a>00162   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *ptr = *readptr;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164   <span class="keywordflow">if</span> (endptr == ptr)
<a name="l00165"></a>00165     <span class="keywordflow">return</span> 0;
<a name="l00166"></a>00166 
<a name="l00167"></a>00167   <span class="keywordflow">if</span> (endptr - ptr &lt; 8 * 2)
<a name="l00168"></a>00168     <span class="keywordflow">return</span> -1;
<a name="l00169"></a>00169 
<a name="l00170"></a>00170   *typep = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (ptr, 4, byte_order);
<a name="l00171"></a>00171   ptr += 8;
<a name="l00172"></a>00172   <span class="comment">/* The size of data is always 64-bit.  If the application is 32-bit,</span>
<a name="l00173"></a>00173 <span class="comment">     it will be zero extended, as expected.  */</span>
<a name="l00174"></a>00174   *valp = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (ptr, 8, byte_order);
<a name="l00175"></a>00175   ptr += 8;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177   *readptr = ptr;
<a name="l00178"></a>00178   <span class="keywordflow">return</span> 1;
<a name="l00179"></a>00179 }
<a name="l00180"></a>00180 <span class="preprocessor">#endif</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span>
<a name="l00182"></a>00182 <span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *
<a name="l00183"></a><a class="code" href="procfs_8h.html#ac3a9a4163370fc037ceee25d74ac30e5">00183</a> <a class="code" href="procfs_8c.html#ac3a9a4163370fc037ceee25d74ac30e5">procfs_target</a> (<span class="keywordtype">void</span>)
<a name="l00184"></a>00184 {
<a name="l00185"></a>00185   <span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *t = <a class="code" href="inf-child_8c.html#ace69463c64205acebcb5480bc742125b">inf_child_target</a> ();
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   t-&gt;<a class="code" href="structtarget__ops.html#a9326c3129ee116786b1ca1a95713f125">to_shortname</a> = <span class="stringliteral">&quot;procfs&quot;</span>;
<a name="l00188"></a>00188   t-&gt;<a class="code" href="structtarget__ops.html#a184ee9aa071d32ec535cf7394aba0bd1">to_longname</a> = <span class="stringliteral">&quot;Unix /proc child process&quot;</span>;
<a name="l00189"></a>00189   t-&gt;<a class="code" href="structtarget__ops.html#a1b0c848329708688e3816263b16fe664">to_doc</a> =
<a name="l00190"></a>00190     <span class="stringliteral">&quot;Unix /proc child process (started by the \&quot;run\&quot; command).&quot;</span>;
<a name="l00191"></a>00191   t-&gt;<a class="code" href="structtarget__ops.html#ac137c7edca115afb65715c6aecc093a8">to_create_inferior</a> = <a class="code" href="procfs_8c.html#a0b1570ab4c815fbae40a320dd7483258">procfs_create_inferior</a>;
<a name="l00192"></a>00192   t-&gt;<a class="code" href="structtarget__ops.html#ad7479d77480dfc6097829ae4eb694e97">to_kill</a> = <a class="code" href="procfs_8c.html#a9e0074e6a1c64ae9a12f8bbc7dfabdad">procfs_kill_inferior</a>;
<a name="l00193"></a>00193   t-&gt;<a class="code" href="structtarget__ops.html#aa636723dd143fcd0c3c78af97f7358a5">to_mourn_inferior</a> = <a class="code" href="procfs_8c.html#a147a0734a33ddc5c6f60a741658ef5da">procfs_mourn_inferior</a>;
<a name="l00194"></a>00194   t-&gt;<a class="code" href="structtarget__ops.html#a12f470dd0a49e7b2e57f6876fca97530">to_attach</a> = <a class="code" href="procfs_8c.html#ad90b52d13ae8d868b4fc3e8e6a7ede28">procfs_attach</a>;
<a name="l00195"></a>00195   t-&gt;<a class="code" href="structtarget__ops.html#a2749c09156c21e635d6860af415b7a52">to_detach</a> = <a class="code" href="procfs_8c.html#aba2a9d7aaf48b661b2007c57749cc2fa">procfs_detach</a>;
<a name="l00196"></a>00196   t-&gt;<a class="code" href="structtarget__ops.html#ae8e22dbcc8522f0daac3fc8ed2661ca1">to_wait</a> = <a class="code" href="procfs_8c.html#a3d55bc6a9a2a8842d23a3c352d6fc0c2">procfs_wait</a>;
<a name="l00197"></a>00197   t-&gt;<a class="code" href="structtarget__ops.html#a969e77ba44f2d253e041d3b24dde8c87">to_resume</a> = <a class="code" href="procfs_8c.html#a172a8e5cc4dbcb8e0ff8a67dbaabe58a">procfs_resume</a>;
<a name="l00198"></a>00198   t-&gt;<a class="code" href="structtarget__ops.html#a117d2a74c4c794d5b309b106a413ef10">to_fetch_registers</a> = <a class="code" href="procfs_8c.html#aa018896dbc17e29f83fa7a79f6eba535">procfs_fetch_registers</a>;
<a name="l00199"></a>00199   t-&gt;<a class="code" href="structtarget__ops.html#a755da40b533b1467a0583a5c8e91a400">to_store_registers</a> = <a class="code" href="nto-procfs_8c.html#a44d7783e99db7311e058e6c32fa701a9">procfs_store_registers</a>;
<a name="l00200"></a>00200   t-&gt;<a class="code" href="structtarget__ops.html#a095389eb9862ff7550e8286c54e33ad3">to_xfer_partial</a> = <a class="code" href="procfs_8c.html#a002b7fd3f79adc554869931ff15b0c7f">procfs_xfer_partial</a>;
<a name="l00201"></a>00201   t-&gt;<a class="code" href="structtarget__ops.html#a64b004350c177cdbdde9b311226f397b">deprecated_xfer_memory</a> = <a class="code" href="procfs_8c.html#a7f53c1daa362f19a41f64509f422fc46">procfs_xfer_memory</a>;
<a name="l00202"></a>00202   t-&gt;<a class="code" href="structtarget__ops.html#a6f07fb0af7d393f28540af828500aa61">to_pass_signals</a> = <a class="code" href="procfs_8c.html#a92457ed7ea9f9921b2dfe6a0e03e9fe7">procfs_pass_signals</a>;
<a name="l00203"></a>00203   t-&gt;<a class="code" href="structtarget__ops.html#a2cb65189c2ab4edb8dbe4f18adcaaf78">to_files_info</a> = <a class="code" href="procfs_8c.html#a2f8758826b72fd2021061324c6e047e1">procfs_files_info</a>;
<a name="l00204"></a>00204   t-&gt;<a class="code" href="structtarget__ops.html#a83d943a3006b96ec7821e5d65eed8b5e">to_stop</a> = <a class="code" href="procfs_8c.html#a28b2e19292b62274a2ece8025614716e">procfs_stop</a>;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206   t-&gt;<a class="code" href="structtarget__ops.html#a6af5d37da6d3dd1ef3b2beb4cd9fdd81">to_find_new_threads</a> = <a class="code" href="procfs_8c.html#a87845a7f84fc5b0f35b0c05728547bb6">procfs_find_new_threads</a>;
<a name="l00207"></a>00207   t-&gt;<a class="code" href="structtarget__ops.html#a01589152a8f74d8c236c1fab3c2838e9">to_thread_alive</a> = <a class="code" href="procfs_8c.html#accf520d09111d863ccec709512dd0a88">procfs_thread_alive</a>;
<a name="l00208"></a>00208   t-&gt;<a class="code" href="structtarget__ops.html#a5259fe0b12fd9dd4e269ed44fee00603">to_pid_to_str</a> = <a class="code" href="procfs_8c.html#ae4991ccbc9f5e4ee6355bae8da57c075">procfs_pid_to_str</a>;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210   t-&gt;<a class="code" href="structtarget__ops.html#ab9754d27b0891e21710e712ce572b2f5">to_has_thread_control</a> = <a class="code" href="target_8h.html#ac23f2139b89f6319b6afa125b437bf79a1b420215532dd7eb22a269c35e569d58">tc_schedlock</a>;
<a name="l00211"></a>00211   t-&gt;<a class="code" href="structtarget__ops.html#a4b6372b89b3b2153e3ba3b8061e9bf0a">to_find_memory_regions</a> = <a class="code" href="procfs_8c.html#a092e007a97789383548b894507d1d427">proc_find_memory_regions</a>;
<a name="l00212"></a>00212   t-&gt;<a class="code" href="structtarget__ops.html#ae431748d938974e0518fb9f4defd67a7">to_make_corefile_notes</a> = <a class="code" href="procfs_8c.html#afb51266a729cd7c07438948856cbf72a">procfs_make_note_section</a>;
<a name="l00213"></a>00213   t-&gt;<a class="code" href="structtarget__ops.html#acc93524a70e11a8c06df012657234482">to_info_proc</a> = <a class="code" href="procfs_8c.html#af62e88d644ae20074ae2801e643a0b2f">procfs_info_proc</a>;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 <span class="preprocessor">#if defined(PR_MODEL_NATIVE) &amp;&amp; (PR_MODEL_NATIVE == PR_MODEL_LP64)</span>
<a name="l00216"></a>00216 <span class="preprocessor"></span>  t-&gt;<a class="code" href="structtarget__ops.html#a85f748c93e031195ff943077e63fd1c8">to_auxv_parse</a> = procfs_auxv_parse;
<a name="l00217"></a>00217 <span class="preprocessor">#endif</span>
<a name="l00218"></a>00218 <span class="preprocessor"></span>
<a name="l00219"></a>00219   t-&gt;<a class="code" href="structtarget__ops.html#a97a3b404ed5a64b8f6229fdaf43d30fb">to_magic</a> = <a class="code" href="target_8h.html#a52de2938b46ac35e4a8c50fead44fd4d">OPS_MAGIC</a>;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   <span class="keywordflow">return</span> t;
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="comment">/* =================== END, TARGET_OPS &quot;MODULE&quot; =================== */</span>
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="comment">/* World Unification:</span>
<a name="l00227"></a>00227 <span class="comment"></span>
<a name="l00228"></a>00228 <span class="comment">   Put any typedefs, defines etc. here that are required for the</span>
<a name="l00229"></a>00229 <span class="comment">   unification of code that handles different versions of /proc.  */</span>
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 <span class="preprocessor">#ifdef NEW_PROC_API             </span><span class="comment">/* Solaris 7 &amp;&amp; 8 method for watchpoints */</span>
<a name="l00232"></a>00232 <span class="preprocessor">#ifdef WA_READ</span>
<a name="l00233"></a>00233 <span class="preprocessor"></span>     <span class="keyword">enum</span> { <a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469aa23bbbc5d536c27be78e36d38c5eb6ba">READ_WATCHFLAG</a>  = WA_READ,
<a name="l00234"></a>00234             <a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469a644741ede8604b44c7e617774f7d35cd">WRITE_WATCHFLAG</a> = WA_WRITE,
<a name="l00235"></a>00235             <a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469a034244e5ab93752fad574e7e485e01da">EXEC_WATCHFLAG</a>  = WA_EXEC,
<a name="l00236"></a>00236             <a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469aa78f7fda6eec37396f071af96baca552">AFTER_WATCHFLAG</a> = WA_TRAPAFTER
<a name="l00237"></a>00237      };
<a name="l00238"></a>00238 <span class="preprocessor">#endif</span>
<a name="l00239"></a>00239 <span class="preprocessor"></span><span class="preprocessor">#else                           </span><span class="comment">/* Irix method for watchpoints */</span>
<a name="l00240"></a><a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469aa23bbbc5d536c27be78e36d38c5eb6ba">00240</a>      <span class="keyword">enum</span> { <a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469aa23bbbc5d536c27be78e36d38c5eb6ba">READ_WATCHFLAG</a>  = MA_READ,
<a name="l00241"></a><a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469a644741ede8604b44c7e617774f7d35cd">00241</a>             <a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469a644741ede8604b44c7e617774f7d35cd">WRITE_WATCHFLAG</a> = MA_WRITE,
<a name="l00242"></a><a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469a034244e5ab93752fad574e7e485e01da">00242</a>             <a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469a034244e5ab93752fad574e7e485e01da">EXEC_WATCHFLAG</a>  = MA_EXEC,
<a name="l00243"></a><a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469aa78f7fda6eec37396f071af96baca552">00243</a>             <a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469aa78f7fda6eec37396f071af96baca552">AFTER_WATCHFLAG</a> = 0         <span class="comment">/* trapafter not implemented */</span>
<a name="l00244"></a>00244      };
<a name="l00245"></a>00245 <span class="preprocessor">#endif</span>
<a name="l00246"></a>00246 <span class="preprocessor"></span>
<a name="l00247"></a>00247 <span class="comment">/* gdb_sigset_t */</span>
<a name="l00248"></a>00248 <span class="preprocessor">#ifdef HAVE_PR_SIGSET_T</span>
<a name="l00249"></a>00249 <span class="preprocessor"></span><span class="keyword">typedef</span> pr_sigset_t <a class="code" href="procfs_8c.html#a56b2350f878be186aca0fe5bb960d6d4">gdb_sigset_t</a>;
<a name="l00250"></a>00250 <span class="preprocessor">#else</span>
<a name="l00251"></a><a class="code" href="procfs_8c.html#a56b2350f878be186aca0fe5bb960d6d4">00251</a> <span class="preprocessor"></span><span class="keyword">typedef</span> sigset_t <a class="code" href="procfs_8c.html#a56b2350f878be186aca0fe5bb960d6d4">gdb_sigset_t</a>;
<a name="l00252"></a>00252 <span class="preprocessor">#endif</span>
<a name="l00253"></a>00253 <span class="preprocessor"></span>
<a name="l00254"></a>00254 <span class="comment">/* sigaction */</span>
<a name="l00255"></a>00255 <span class="preprocessor">#ifdef HAVE_PR_SIGACTION64_T</span>
<a name="l00256"></a>00256 <span class="preprocessor"></span><span class="keyword">typedef</span> pr_sigaction64_t <a class="code" href="procfs_8c.html#a0b28ed416d6af12fe159134369513397">gdb_sigaction_t</a>;
<a name="l00257"></a>00257 <span class="preprocessor">#else</span>
<a name="l00258"></a><a class="code" href="procfs_8c.html#a0b28ed416d6af12fe159134369513397">00258</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span>sigaction gdb_sigaction_t;
<a name="l00259"></a>00259 <span class="preprocessor">#endif</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span>
<a name="l00261"></a>00261 <span class="comment">/* siginfo */</span>
<a name="l00262"></a>00262 <span class="preprocessor">#ifdef HAVE_PR_SIGINFO64_T</span>
<a name="l00263"></a>00263 <span class="preprocessor"></span><span class="keyword">typedef</span> pr_siginfo64_t <a class="code" href="procfs_8c.html#acf8fd807272e10a609db9462334e3e26">gdb_siginfo_t</a>;
<a name="l00264"></a>00264 <span class="preprocessor">#else</span>
<a name="l00265"></a><a class="code" href="procfs_8c.html#acf8fd807272e10a609db9462334e3e26">00265</a> <span class="preprocessor"></span><span class="keyword">typedef</span> siginfo_t <a class="code" href="procfs_8c.html#acf8fd807272e10a609db9462334e3e26">gdb_siginfo_t</a>;
<a name="l00266"></a>00266 <span class="preprocessor">#endif</span>
<a name="l00267"></a>00267 <span class="preprocessor"></span>
<a name="l00268"></a>00268 <span class="comment">/* On mips-irix, praddset and prdelset are defined in such a way that</span>
<a name="l00269"></a>00269 <span class="comment">   they return a value, which causes GCC to emit a -Wunused error</span>
<a name="l00270"></a>00270 <span class="comment">   because the returned value is not used.  Prevent this warning</span>
<a name="l00271"></a>00271 <span class="comment">   by casting the return value to void.  On sparc-solaris, this issue</span>
<a name="l00272"></a>00272 <span class="comment">   does not exist because the definition of these macros already include</span>
<a name="l00273"></a>00273 <span class="comment">   that cast to void.  */</span>
<a name="l00274"></a><a class="code" href="procfs_8c.html#a3711def2560f6203585e4a8d4e429bdc">00274</a> <span class="preprocessor">#define gdb_praddset(sp, flag) ((void) praddset (sp, flag))</span>
<a name="l00275"></a><a class="code" href="procfs_8c.html#a15c2ad85ffb214687d7804f6b67ccd30">00275</a> <span class="preprocessor"></span><span class="preprocessor">#define gdb_prdelset(sp, flag) ((void) prdelset (sp, flag))</span>
<a name="l00276"></a>00276 <span class="preprocessor"></span>
<a name="l00277"></a>00277 <span class="comment">/* gdb_premptysysset */</span>
<a name="l00278"></a>00278 <span class="preprocessor">#ifdef premptysysset</span>
<a name="l00279"></a>00279 <span class="preprocessor"></span><span class="preprocessor">#define gdb_premptysysset premptysysset</span>
<a name="l00280"></a>00280 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00281"></a><a class="code" href="procfs_8c.html#a59f0624d8796729e70bea1dda0394b81">00281</a> <span class="preprocessor"></span><span class="preprocessor">#define gdb_premptysysset premptyset</span>
<a name="l00282"></a>00282 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00283"></a>00283 <span class="preprocessor"></span>
<a name="l00284"></a>00284 <span class="comment">/* praddsysset */</span>
<a name="l00285"></a>00285 <span class="preprocessor">#ifdef praddsysset</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span><span class="preprocessor">#define gdb_praddsysset praddsysset</span>
<a name="l00287"></a>00287 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00288"></a><a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">00288</a> <span class="preprocessor"></span><span class="preprocessor">#define gdb_praddsysset gdb_praddset</span>
<a name="l00289"></a>00289 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00290"></a>00290 <span class="preprocessor"></span>
<a name="l00291"></a>00291 <span class="comment">/* prdelsysset */</span>
<a name="l00292"></a>00292 <span class="preprocessor">#ifdef prdelsysset</span>
<a name="l00293"></a>00293 <span class="preprocessor"></span><span class="preprocessor">#define gdb_prdelsysset prdelsysset</span>
<a name="l00294"></a>00294 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00295"></a><a class="code" href="procfs_8c.html#af43f8629f8c66a037cff9ef248521308">00295</a> <span class="preprocessor"></span><span class="preprocessor">#define gdb_prdelsysset gdb_prdelset</span>
<a name="l00296"></a>00296 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span>
<a name="l00298"></a>00298 <span class="comment">/* prissyssetmember */</span>
<a name="l00299"></a>00299 <span class="preprocessor">#ifdef prissyssetmember</span>
<a name="l00300"></a>00300 <span class="preprocessor"></span><span class="preprocessor">#define gdb_pr_issyssetmember prissyssetmember</span>
<a name="l00301"></a>00301 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00302"></a><a class="code" href="procfs_8c.html#a1c1de9947ac823f4bd49e04aa875718c">00302</a> <span class="preprocessor"></span><span class="preprocessor">#define gdb_pr_issyssetmember prismember</span>
<a name="l00303"></a>00303 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00304"></a>00304 <span class="preprocessor"></span>
<a name="l00305"></a>00305 <span class="comment">/* As a feature test, saying ``#if HAVE_PRSYSENT_T&#39;&#39; everywhere isn&#39;t</span>
<a name="l00306"></a>00306 <span class="comment">   as intuitively descriptive as it could be, so we&#39;ll define</span>
<a name="l00307"></a>00307 <span class="comment">   DYNAMIC_SYSCALLS to mean the same thing.  Anyway, at the time of</span>
<a name="l00308"></a>00308 <span class="comment">   this writing, this feature is only found on AIX5 systems and</span>
<a name="l00309"></a>00309 <span class="comment">   basically means that the set of syscalls is not fixed.  I.e,</span>
<a name="l00310"></a>00310 <span class="comment">   there&#39;s no nice table that one can #include to get all of the</span>
<a name="l00311"></a>00311 <span class="comment">   syscall numbers.  Instead, they&#39;re stored in /proc/PID/sysent</span>
<a name="l00312"></a>00312 <span class="comment">   for each process.  We are at least guaranteed that they won&#39;t</span>
<a name="l00313"></a>00313 <span class="comment">   change over the lifetime of the process.  But each process could</span>
<a name="l00314"></a>00314 <span class="comment">   (in theory) have different syscall numbers.  */</span>
<a name="l00315"></a>00315 <span class="preprocessor">#ifdef HAVE_PRSYSENT_T</span>
<a name="l00316"></a>00316 <span class="preprocessor"></span><span class="preprocessor">#define DYNAMIC_SYSCALLS</span>
<a name="l00317"></a>00317 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span>
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 <span class="comment">/* =================== STRUCT PROCINFO &quot;MODULE&quot; =================== */</span>
<a name="l00322"></a>00322 
<a name="l00323"></a>00323      <span class="comment">/* FIXME: this comment will soon be out of date W.R.T. threads.  */</span>
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="comment">/* The procinfo struct is a wrapper to hold all the state information</span>
<a name="l00326"></a>00326 <span class="comment">   concerning a /proc process.  There should be exactly one procinfo</span>
<a name="l00327"></a>00327 <span class="comment">   for each process, and since GDB currently can debug only one</span>
<a name="l00328"></a>00328 <span class="comment">   process at a time, that means there should be only one procinfo.</span>
<a name="l00329"></a>00329 <span class="comment">   All of the LWP&#39;s of a process can be accessed indirectly thru the</span>
<a name="l00330"></a>00330 <span class="comment">   single process procinfo.</span>
<a name="l00331"></a>00331 <span class="comment"></span>
<a name="l00332"></a>00332 <span class="comment">   However, against the day when GDB may debug more than one process,</span>
<a name="l00333"></a>00333 <span class="comment">   this data structure is kept in a list (which for now will hold no</span>
<a name="l00334"></a>00334 <span class="comment">   more than one member), and many functions will have a pointer to a</span>
<a name="l00335"></a>00335 <span class="comment">   procinfo as an argument.</span>
<a name="l00336"></a>00336 <span class="comment"></span>
<a name="l00337"></a>00337 <span class="comment">   There will be a separate procinfo structure for use by the (not yet</span>
<a name="l00338"></a>00338 <span class="comment">   implemented) &quot;info proc&quot; command, so that we can print useful</span>
<a name="l00339"></a>00339 <span class="comment">   information about any random process without interfering with the</span>
<a name="l00340"></a>00340 <span class="comment">   inferior&#39;s procinfo information.  */</span>
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l00343"></a>00343 <span class="preprocessor"></span><span class="comment">/* format strings for /proc paths */</span>
<a name="l00344"></a>00344 <span class="preprocessor"># ifndef CTL_PROC_NAME_FMT</span>
<a name="l00345"></a>00345 <span class="preprocessor"></span><span class="preprocessor">#  define MAIN_PROC_NAME_FMT   &quot;/proc/%d&quot;</span>
<a name="l00346"></a>00346 <span class="preprocessor"></span><span class="preprocessor">#  define CTL_PROC_NAME_FMT    &quot;/proc/%d/ctl&quot;</span>
<a name="l00347"></a>00347 <span class="preprocessor"></span><span class="preprocessor">#  define AS_PROC_NAME_FMT     &quot;/proc/%d/as&quot;</span>
<a name="l00348"></a>00348 <span class="preprocessor"></span><span class="preprocessor">#  define MAP_PROC_NAME_FMT    &quot;/proc/%d/map&quot;</span>
<a name="l00349"></a>00349 <span class="preprocessor"></span><span class="preprocessor">#  define STATUS_PROC_NAME_FMT &quot;/proc/%d/status&quot;</span>
<a name="l00350"></a>00350 <span class="preprocessor"></span><span class="preprocessor">#  define MAX_PROC_NAME_SIZE sizeof(&quot;/proc/99999/lwp/8096/lstatus&quot;)</span>
<a name="l00351"></a>00351 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00352"></a>00352 <span class="preprocessor"></span><span class="comment">/* the name of the proc status struct depends on the implementation */</span>
<a name="l00353"></a>00353 <span class="keyword">typedef</span> pstatus_t   <a class="code" href="procfs_8c.html#ace613f26c881ade2663acd95a538314b">gdb_prstatus_t</a>;
<a name="l00354"></a>00354 <span class="keyword">typedef</span> lwpstatus_t <a class="code" href="procfs_8c.html#a52e43dc5e8e54a5f915b56d6348457e6">gdb_lwpstatus_t</a>;
<a name="l00355"></a>00355 <span class="preprocessor">#else </span><span class="comment">/* ! NEW_PROC_API */</span>
<a name="l00356"></a>00356 <span class="comment">/* format strings for /proc paths */</span>
<a name="l00357"></a>00357 <span class="preprocessor"># ifndef CTL_PROC_NAME_FMT</span>
<a name="l00358"></a><a class="code" href="procfs_8c.html#a4a950932827615e651aba7ed9f169b0d">00358</a> <span class="preprocessor"></span><span class="preprocessor">#  define MAIN_PROC_NAME_FMT   &quot;/proc/%05d&quot;</span>
<a name="l00359"></a><a class="code" href="procfs_8c.html#aced6a089cd0b8dabc3049efb3fa33f7c">00359</a> <span class="preprocessor"></span><span class="preprocessor">#  define CTL_PROC_NAME_FMT    &quot;/proc/%05d&quot;</span>
<a name="l00360"></a><a class="code" href="procfs_8c.html#a0fb64688d2439125303e6f99fc8deefb">00360</a> <span class="preprocessor"></span><span class="preprocessor">#  define AS_PROC_NAME_FMT     &quot;/proc/%05d&quot;</span>
<a name="l00361"></a><a class="code" href="procfs_8c.html#a02f4449ea589d0cfcef6955720243aef">00361</a> <span class="preprocessor"></span><span class="preprocessor">#  define MAP_PROC_NAME_FMT    &quot;/proc/%05d&quot;</span>
<a name="l00362"></a><a class="code" href="procfs_8c.html#a2be7f574d00335b3643d69053a8897f1">00362</a> <span class="preprocessor"></span><span class="preprocessor">#  define STATUS_PROC_NAME_FMT &quot;/proc/%05d&quot;</span>
<a name="l00363"></a><a class="code" href="procfs_8c.html#a516ed8ab3b65b65276525efba4b38d6d">00363</a> <span class="preprocessor"></span><span class="preprocessor">#  define MAX_PROC_NAME_SIZE sizeof(&quot;/proc/ttttppppp&quot;)</span>
<a name="l00364"></a>00364 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00365"></a>00365 <span class="preprocessor"></span><span class="comment">/* The name of the proc status struct depends on the implementation.  */</span>
<a name="l00366"></a><a class="code" href="procfs_8c.html#ace613f26c881ade2663acd95a538314b">00366</a> <span class="keyword">typedef</span> prstatus_t <a class="code" href="procfs_8c.html#ace613f26c881ade2663acd95a538314b">gdb_prstatus_t</a>;
<a name="l00367"></a><a class="code" href="procfs_8c.html#a52e43dc5e8e54a5f915b56d6348457e6">00367</a> <span class="keyword">typedef</span> prstatus_t <a class="code" href="procfs_8c.html#a52e43dc5e8e54a5f915b56d6348457e6">gdb_lwpstatus_t</a>;
<a name="l00368"></a>00368 <span class="preprocessor">#endif </span><span class="comment">/* NEW_PROC_API */</span>
<a name="l00369"></a>00369 
<a name="l00370"></a><a class="code" href="structprocinfo.html">00370</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structprocinfo.html">procinfo</a> {
<a name="l00371"></a><a class="code" href="structprocinfo.html#a423589ec10ab03a958088139858eeb8d">00371</a>   <span class="keyword">struct </span><a class="code" href="structprocinfo.html">procinfo</a> *<a class="code" href="structprocinfo.html#a423589ec10ab03a958088139858eeb8d">next</a>;
<a name="l00372"></a><a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">00372</a>   <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>;                      <span class="comment">/* Process ID    */</span>
<a name="l00373"></a><a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">00373</a>   <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>;                      <span class="comment">/* Thread/LWP id */</span>
<a name="l00374"></a>00374 
<a name="l00375"></a>00375   <span class="comment">/* process state */</span>
<a name="l00376"></a><a class="code" href="structprocinfo.html#a4d5e4bdafb9c9f76174c84a3f1b8ccd8">00376</a>   <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#a4d5e4bdafb9c9f76174c84a3f1b8ccd8">was_stopped</a>;
<a name="l00377"></a><a class="code" href="structprocinfo.html#a06291e3cc0449eb51f149e4d718d0218">00377</a>   <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#a06291e3cc0449eb51f149e4d718d0218">ignore_next_sigstop</a>;
<a name="l00378"></a>00378 
<a name="l00379"></a>00379   <span class="comment">/* The following four fd fields may be identical, or may contain</span>
<a name="l00380"></a>00380 <span class="comment">     several different fd&#39;s, depending on the version of /proc</span>
<a name="l00381"></a>00381 <span class="comment">     (old ioctl or new read/write).  */</span>
<a name="l00382"></a>00382 
<a name="l00383"></a><a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">00383</a>   <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>;                   <span class="comment">/* File descriptor for /proc control file */</span>
<a name="l00384"></a>00384 
<a name="l00385"></a>00385   <span class="comment">/* The next three file descriptors are actually only needed in the</span>
<a name="l00386"></a>00386 <span class="comment">     read/write, multiple-file-descriptor implemenation</span>
<a name="l00387"></a>00387 <span class="comment">     (NEW_PROC_API).  However, to avoid a bunch of #ifdefs in the</span>
<a name="l00388"></a>00388 <span class="comment">     code, we will use them uniformly by (in the case of the ioctl</span>
<a name="l00389"></a>00389 <span class="comment">     single-file-descriptor implementation) filling them with copies</span>
<a name="l00390"></a>00390 <span class="comment">     of the control fd.  */</span>
<a name="l00391"></a><a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">00391</a>   <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a>;                <span class="comment">/* File descriptor for /proc status file */</span>
<a name="l00392"></a><a class="code" href="structprocinfo.html#a74f0f6631babefdb4908262293bb6f2e">00392</a>   <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#a74f0f6631babefdb4908262293bb6f2e">as_fd</a>;                    <span class="comment">/* File descriptor for /proc as file */</span>
<a name="l00393"></a>00393 
<a name="l00394"></a><a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">00394</a>   <span class="keywordtype">char</span> <a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">pathname</a>[<a class="code" href="procfs_8c.html#a516ed8ab3b65b65276525efba4b38d6d">MAX_PROC_NAME_SIZE</a>];    <span class="comment">/* Pathname to /proc entry */</span>
<a name="l00395"></a>00395 
<a name="l00396"></a><a class="code" href="structprocinfo.html#ab6f5d831f0153fcc5441cb9050d62313">00396</a>   fltset_t <a class="code" href="structprocinfo.html#ab6f5d831f0153fcc5441cb9050d62313">saved_fltset</a>;        <span class="comment">/* Saved traced hardware fault set */</span>
<a name="l00397"></a><a class="code" href="structprocinfo.html#ae6922e85e89e6c7b3597a74856307d5c">00397</a>   gdb_sigset_t <a class="code" href="structprocinfo.html#ae6922e85e89e6c7b3597a74856307d5c">saved_sigset</a>;    <span class="comment">/* Saved traced signal set */</span>
<a name="l00398"></a><a class="code" href="structprocinfo.html#a8893f6113351ec1bf61f3610dc140417">00398</a>   gdb_sigset_t <a class="code" href="structprocinfo.html#a8893f6113351ec1bf61f3610dc140417">saved_sighold</a>;   <span class="comment">/* Saved held signal set */</span>
<a name="l00399"></a><a class="code" href="structprocinfo.html#aa7801fdd3d9f15fda54aa8d81b3ccfd8">00399</a>   sysset_t *<a class="code" href="structprocinfo.html#aa7801fdd3d9f15fda54aa8d81b3ccfd8">saved_exitset</a>;      <span class="comment">/* Saved traced system call exit set */</span>
<a name="l00400"></a><a class="code" href="structprocinfo.html#a7df20e8108a16cdf00b4a40039b97164">00400</a>   sysset_t *<a class="code" href="structprocinfo.html#a7df20e8108a16cdf00b4a40039b97164">saved_entryset</a>;     <span class="comment">/* Saved traced system call entry set */</span>
<a name="l00401"></a>00401 
<a name="l00402"></a><a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">00402</a>   gdb_prstatus_t <a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>;      <span class="comment">/* Current process status info */</span>
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 <span class="preprocessor">#ifndef NEW_PROC_API</span>
<a name="l00405"></a><a class="code" href="structprocinfo.html#a4e75ee94e9ea452db34145cb09890827">00405</a> <span class="preprocessor"></span>  <a class="code" href="gregset_8h.html#ac5319835a36948bae33bef8f21542def">gdb_fpregset_t</a> <a class="code" href="structprocinfo.html#a4e75ee94e9ea452db34145cb09890827">fpregset</a>;      <span class="comment">/* Current floating point registers */</span>
<a name="l00406"></a>00406 <span class="preprocessor">#endif</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span>
<a name="l00408"></a>00408 <span class="preprocessor">#ifdef DYNAMIC_SYSCALLS</span>
<a name="l00409"></a>00409 <span class="preprocessor"></span>  <span class="keywordtype">int</span> num_syscalls;             <span class="comment">/* Total number of syscalls */</span>
<a name="l00410"></a>00410   <span class="keywordtype">char</span> **syscall_names;         <span class="comment">/* Syscall number to name map */</span>
<a name="l00411"></a>00411 <span class="preprocessor">#endif</span>
<a name="l00412"></a>00412 <span class="preprocessor"></span>
<a name="l00413"></a><a class="code" href="structprocinfo.html#ac9b6c53503df0c67d97f747b041fa10f">00413</a>   <span class="keyword">struct </span><a class="code" href="structprocinfo.html">procinfo</a> *<a class="code" href="structprocinfo.html#ac9b6c53503df0c67d97f747b041fa10f">thread_list</a>;
<a name="l00414"></a>00414 
<a name="l00415"></a><a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">00415</a>   <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> : 1;
<a name="l00416"></a><a class="code" href="structprocinfo.html#af644c8cc9c6b4f09babb3eaf994fa5fc">00416</a>   <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#af644c8cc9c6b4f09babb3eaf994fa5fc">gregs_valid</a>  : 1;
<a name="l00417"></a><a class="code" href="structprocinfo.html#a687b93500ed96768255ec07735113afb">00417</a>   <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#a687b93500ed96768255ec07735113afb">fpregs_valid</a> : 1;
<a name="l00418"></a><a class="code" href="structprocinfo.html#a29eed4e1916725d4db440b31b010a2a3">00418</a>   <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#a29eed4e1916725d4db440b31b010a2a3">threads_valid</a>: 1;
<a name="l00419"></a>00419 } <a class="code" href="procfs_8c.html#a9682d9066f643f8d18cff58fd3fb09b9">procinfo</a>;
<a name="l00420"></a>00420 
<a name="l00421"></a><a class="code" href="procfs_8c.html#a2141b8541565b9145c450f46c23fdd31">00421</a> <span class="keyword">static</span> <span class="keywordtype">char</span> <a class="code" href="procfs_8c.html#a2141b8541565b9145c450f46c23fdd31">errmsg</a>[128];        <span class="comment">/* shared error msg buffer */</span>
<a name="l00422"></a>00422 
<a name="l00423"></a>00423 <span class="comment">/* Function prototypes for procinfo module: */</span>
<a name="l00424"></a>00424 
<a name="l00425"></a>00425 <span class="keyword">static</span> <a class="code" href="structprocinfo.html">procinfo</a> *<a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>);
<a name="l00426"></a>00426 <span class="keyword">static</span> <a class="code" href="structprocinfo.html">procinfo</a> *<a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (<span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>);
<a name="l00427"></a>00427 <span class="keyword">static</span> <a class="code" href="structprocinfo.html">procinfo</a> *<a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a> (<span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>);
<a name="l00428"></a>00428 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#af0251ed126d7aa5845297cab52db3b68">destroy_procinfo</a> (<a class="code" href="structprocinfo.html">procinfo</a> * p);
<a name="l00429"></a>00429 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#ab2c6317aa8356e2091a2bc12eb69f1c2">do_destroy_procinfo_cleanup</a> (<span class="keywordtype">void</span> *);
<a name="l00430"></a>00430 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#a4a363dfa0e8f3f68a66a7152e0d95913">dead_procinfo</a> (<a class="code" href="structprocinfo.html">procinfo</a> * p, <span class="keywordtype">char</span> *msg, <span class="keywordtype">int</span> killp);
<a name="l00431"></a>00431 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (<a class="code" href="structprocinfo.html">procinfo</a> * p, <span class="keywordtype">int</span> which);
<a name="l00432"></a>00432 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#ad61e7432a6ca3e0653550d2bf7c8be53">close_procinfo_files</a> (<a class="code" href="structprocinfo.html">procinfo</a> * p);
<a name="l00433"></a>00433 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="procfs_8c.html#a1cdd2d8ca6008592b9aeb49b7f6e4f10">sysset_t_size</a> (<a class="code" href="structprocinfo.html">procinfo</a> *p);
<a name="l00434"></a>00434 <span class="keyword">static</span> sysset_t *<a class="code" href="procfs_8c.html#a46e37b7eaec868b43af27d24b556e9c9">sysset_t_alloc</a> (<a class="code" href="structprocinfo.html">procinfo</a> * pi);
<a name="l00435"></a>00435 <span class="preprocessor">#ifdef DYNAMIC_SYSCALLS</span>
<a name="l00436"></a>00436 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> load_syscalls (<a class="code" href="structprocinfo.html">procinfo</a> *pi);
<a name="l00437"></a>00437 <span class="keyword">static</span> <span class="keywordtype">void</span> free_syscalls (<a class="code" href="structprocinfo.html">procinfo</a> *pi);
<a name="l00438"></a>00438 <span class="keyword">static</span> <span class="keywordtype">int</span> find_syscall (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>);
<a name="l00439"></a>00439 <span class="preprocessor">#endif </span><span class="comment">/* DYNAMIC_SYSCALLS */</span>
<a name="l00440"></a>00440 
<a name="l00441"></a>00441 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="procfs_8c.html#a2c2c4e0ad3531aa668e8a6f38b50ba29">iterate_over_mappings</a>
<a name="l00442"></a>00442   (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <a class="code" href="defs_8h.html#a9d6528d2f701ee8e47c35c038752ac99">find_memory_region_ftype</a> child_func, <span class="keywordtype">void</span> *data,
<a name="l00443"></a>00443    <span class="keywordtype">int</span> (*<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>) (<span class="keyword">struct</span> prmap *map, <a class="code" href="defs_8h.html#a9d6528d2f701ee8e47c35c038752ac99">find_memory_region_ftype</a> child_func,
<a name="l00444"></a>00444                 <span class="keywordtype">void</span> *data));
<a name="l00445"></a>00445 
<a name="l00446"></a>00446 <span class="comment">/* The head of the procinfo list: */</span>
<a name="l00447"></a><a class="code" href="procfs_8c.html#a8fb538c8bbea3a9a18523a063ddcec24">00447</a> <span class="keyword">static</span> <a class="code" href="structprocinfo.html">procinfo</a> * <a class="code" href="procfs_8c.html#a8fb538c8bbea3a9a18523a063ddcec24">procinfo_list</a>;
<a name="l00448"></a>00448 
<a name="l00449"></a>00449 <span class="comment">/* Search the procinfo list.  Return a pointer to procinfo, or NULL if</span>
<a name="l00450"></a>00450 <span class="comment">   not found.  */</span>
<a name="l00451"></a>00451 
<a name="l00452"></a>00452 <span class="keyword">static</span> <a class="code" href="structprocinfo.html">procinfo</a> *
<a name="l00453"></a><a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">00453</a> <a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (<span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>)
<a name="l00454"></a>00454 {
<a name="l00455"></a>00455   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l00456"></a>00456 
<a name="l00457"></a>00457   <span class="keywordflow">for</span> (pi = procinfo_list; pi; pi = pi-&gt;<a class="code" href="structprocinfo.html#a423589ec10ab03a958088139858eeb8d">next</a>)
<a name="l00458"></a>00458     <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a> == pid)
<a name="l00459"></a>00459       <span class="keywordflow">break</span>;
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="keywordflow">if</span> (pi)
<a name="l00462"></a>00462     <span class="keywordflow">if</span> (tid)
<a name="l00463"></a>00463       {
<a name="l00464"></a>00464         <span class="comment">/* Don&#39;t check threads_valid.  If we&#39;re updating the</span>
<a name="l00465"></a>00465 <span class="comment">           thread_list, we want to find whatever threads are already</span>
<a name="l00466"></a>00466 <span class="comment">           here.  This means that in general it is the caller&#39;s</span>
<a name="l00467"></a>00467 <span class="comment">           responsibility to check threads_valid and update before</span>
<a name="l00468"></a>00468 <span class="comment">           calling find_procinfo, if the caller wants to find a new</span>
<a name="l00469"></a>00469 <span class="comment">           thread.  */</span>
<a name="l00470"></a>00470 
<a name="l00471"></a>00471         <span class="keywordflow">for</span> (pi = pi-&gt;<a class="code" href="structprocinfo.html#ac9b6c53503df0c67d97f747b041fa10f">thread_list</a>; pi; pi = pi-&gt;<a class="code" href="structprocinfo.html#a423589ec10ab03a958088139858eeb8d">next</a>)
<a name="l00472"></a>00472           <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> == tid)
<a name="l00473"></a>00473             <span class="keywordflow">break</span>;
<a name="l00474"></a>00474       }
<a name="l00475"></a>00475 
<a name="l00476"></a>00476   <span class="keywordflow">return</span> pi;
<a name="l00477"></a>00477 }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 <span class="comment">/* Calls find_procinfo, but errors on failure.  */</span>
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="keyword">static</span> <a class="code" href="structprocinfo.html">procinfo</a> *
<a name="l00482"></a><a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">00482</a> <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>)
<a name="l00483"></a>00483 {
<a name="l00484"></a>00484   <a class="code" href="structprocinfo.html">procinfo</a> *pi = <a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (pid, tid);
<a name="l00485"></a>00485 
<a name="l00486"></a>00486   <span class="keywordflow">if</span> (pi == NULL)
<a name="l00487"></a>00487     {
<a name="l00488"></a>00488       <span class="keywordflow">if</span> (tid)
<a name="l00489"></a>00489         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs: couldn&#39;t find pid %d &quot;</span>
<a name="l00490"></a>00490                  <span class="stringliteral">&quot;(kernel thread %d) in procinfo list.&quot;</span>),
<a name="l00491"></a>00491                pid, tid);
<a name="l00492"></a>00492       <span class="keywordflow">else</span>
<a name="l00493"></a>00493         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs: couldn&#39;t find pid %d in procinfo list.&quot;</span>), pid);
<a name="l00494"></a>00494     }
<a name="l00495"></a>00495   <span class="keywordflow">return</span> pi;
<a name="l00496"></a>00496 }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 <span class="comment">/* Wrapper for `open&#39;.  The appropriate open call is attempted; if</span>
<a name="l00499"></a>00499 <span class="comment">   unsuccessful, it will be retried as many times as needed for the</span>
<a name="l00500"></a>00500 <span class="comment">   EAGAIN and EINTR conditions.</span>
<a name="l00501"></a>00501 <span class="comment"></span>
<a name="l00502"></a>00502 <span class="comment">   For other conditions, retry the open a limited number of times.  In</span>
<a name="l00503"></a>00503 <span class="comment">   addition, a short sleep is imposed prior to retrying the open.  The</span>
<a name="l00504"></a>00504 <span class="comment">   reason for this sleep is to give the kernel a chance to catch up</span>
<a name="l00505"></a>00505 <span class="comment">   and create the file in question in the event that GDB &quot;wins&quot; the</span>
<a name="l00506"></a>00506 <span class="comment">   race to open a file before the kernel has created it.  */</span>
<a name="l00507"></a>00507 
<a name="l00508"></a>00508 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00509"></a><a class="code" href="procfs_8c.html#a8537de378e19c8806d9837b90505a62d">00509</a> <a class="code" href="procfs_8c.html#a8537de378e19c8806d9837b90505a62d">open_with_retry</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">pathname</a>, <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>)
<a name="l00510"></a>00510 {
<a name="l00511"></a>00511   <span class="keywordtype">int</span> retries_remaining, <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00512"></a>00512 
<a name="l00513"></a>00513   retries_remaining = 2;
<a name="l00514"></a>00514 
<a name="l00515"></a>00515   <span class="keywordflow">while</span> (1)
<a name="l00516"></a>00516     {
<a name="l00517"></a>00517       status = open (pathname, flags);
<a name="l00518"></a>00518 
<a name="l00519"></a>00519       <span class="keywordflow">if</span> (status &gt;= 0 || retries_remaining == 0)
<a name="l00520"></a>00520         <span class="keywordflow">break</span>;
<a name="l00521"></a>00521       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (errno != EINTR &amp;&amp; errno != EAGAIN)
<a name="l00522"></a>00522         {
<a name="l00523"></a>00523           retries_remaining--;
<a name="l00524"></a>00524           <a class="code" href="util_8tcl.html#a190f969d039ba77d2889be0dd9313023">sleep</a> (1);
<a name="l00525"></a>00525         }
<a name="l00526"></a>00526     }
<a name="l00527"></a>00527 
<a name="l00528"></a>00528   <span class="keywordflow">return</span> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00529"></a>00529 }
<a name="l00530"></a>00530 
<a name="l00531"></a>00531 <span class="comment">/* Open the file descriptor for the process or LWP.  If NEW_PROC_API</span>
<a name="l00532"></a>00532 <span class="comment">   is defined, we only open the control file descriptor; the others</span>
<a name="l00533"></a>00533 <span class="comment">   are opened lazily as needed.  Otherwise (if not NEW_PROC_API),</span>
<a name="l00534"></a>00534 <span class="comment">   there is only one real file descriptor, but we keep multiple copies</span>
<a name="l00535"></a>00535 <span class="comment">   of it so that the code that uses them does not have to be #ifdef&#39;d.</span>
<a name="l00536"></a>00536 <span class="comment">   Returns the file descriptor, or zero for failure.  */</span>
<a name="l00537"></a>00537 
<a name="l00538"></a><a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca14a7bec1b8050b1bc5e4335e59bf0db5">00538</a> <span class="keyword">enum</span> { <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca242b7fbe149191cf293910e1f2f65bd6">FD_CTL</a>, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca14a7bec1b8050b1bc5e4335e59bf0db5">FD_STATUS</a>, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca619a7f13145c989adc5f80dad9d9caaf">FD_AS</a> };
<a name="l00539"></a>00539 
<a name="l00540"></a>00540 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00541"></a><a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">00541</a> <a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">int</span> which)
<a name="l00542"></a>00542 {
<a name="l00543"></a>00543 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l00544"></a>00544 <span class="preprocessor"></span>  <span class="keywordtype">char</span> tmp[<a class="code" href="procfs_8c.html#a516ed8ab3b65b65276525efba4b38d6d">MAX_PROC_NAME_SIZE</a>];
<a name="l00545"></a>00545 <span class="preprocessor">#endif</span>
<a name="l00546"></a>00546 <span class="preprocessor"></span>  <span class="keywordtype">int</span>  fd;
<a name="l00547"></a>00547 
<a name="l00548"></a>00548   <span class="comment">/* This function is getting ALMOST long enough to break up into</span>
<a name="l00549"></a>00549 <span class="comment">     several.  Here is some rationale:</span>
<a name="l00550"></a>00550 <span class="comment"></span>
<a name="l00551"></a>00551 <span class="comment">     NEW_PROC_API (Solaris 2.6, Solaris 2.7):</span>
<a name="l00552"></a>00552 <span class="comment">     There are several file descriptors that may need to be open</span>
<a name="l00553"></a>00553 <span class="comment">       for any given process or LWP.  The ones we&#39;re intereted in are:</span>
<a name="l00554"></a>00554 <span class="comment">         - control       (ctl)    write-only    change the state</span>
<a name="l00555"></a>00555 <span class="comment">         - status        (status) read-only     query the state</span>
<a name="l00556"></a>00556 <span class="comment">         - address space (as)     read/write    access memory</span>
<a name="l00557"></a>00557 <span class="comment">         - map           (map)    read-only     virtual addr map</span>
<a name="l00558"></a>00558 <span class="comment">       Most of these are opened lazily as they are needed.</span>
<a name="l00559"></a>00559 <span class="comment">       The pathnames for the &#39;files&#39; for an LWP look slightly</span>
<a name="l00560"></a>00560 <span class="comment">       different from those of a first-class process:</span>
<a name="l00561"></a>00561 <span class="comment">         Pathnames for a process (&lt;proc-id&gt;):</span>
<a name="l00562"></a>00562 <span class="comment">           /proc/&lt;proc-id&gt;/ctl</span>
<a name="l00563"></a>00563 <span class="comment">           /proc/&lt;proc-id&gt;/status</span>
<a name="l00564"></a>00564 <span class="comment">           /proc/&lt;proc-id&gt;/as</span>
<a name="l00565"></a>00565 <span class="comment">           /proc/&lt;proc-id&gt;/map</span>
<a name="l00566"></a>00566 <span class="comment">         Pathnames for an LWP (lwp-id):</span>
<a name="l00567"></a>00567 <span class="comment">           /proc/&lt;proc-id&gt;/lwp/&lt;lwp-id&gt;/lwpctl</span>
<a name="l00568"></a>00568 <span class="comment">           /proc/&lt;proc-id&gt;/lwp/&lt;lwp-id&gt;/lwpstatus</span>
<a name="l00569"></a>00569 <span class="comment">       An LWP has no map or address space file descriptor, since</span>
<a name="l00570"></a>00570 <span class="comment">       the memory map and address space are shared by all LWPs.</span>
<a name="l00571"></a>00571 <span class="comment"></span>
<a name="l00572"></a>00572 <span class="comment">     Everyone else (Solaris 2.5, Irix, OSF)</span>
<a name="l00573"></a>00573 <span class="comment">       There is only one file descriptor for each process or LWP.</span>
<a name="l00574"></a>00574 <span class="comment">       For convenience, we copy the same file descriptor into all</span>
<a name="l00575"></a>00575 <span class="comment">       three fields of the procinfo struct (ctl_fd, status_fd, and</span>
<a name="l00576"></a>00576 <span class="comment">       as_fd, see NEW_PROC_API above) so that code that uses them</span>
<a name="l00577"></a>00577 <span class="comment">       doesn&#39;t need any #ifdef&#39;s.</span>
<a name="l00578"></a>00578 <span class="comment">         Pathname for all:</span>
<a name="l00579"></a>00579 <span class="comment">           /proc/&lt;proc-id&gt;</span>
<a name="l00580"></a>00580 <span class="comment"></span>
<a name="l00581"></a>00581 <span class="comment">       Solaris 2.5 LWP&#39;s:</span>
<a name="l00582"></a>00582 <span class="comment">         Each LWP has an independent file descriptor, but these</span>
<a name="l00583"></a>00583 <span class="comment">         are not obtained via the &#39;open&#39; system call like the rest:</span>
<a name="l00584"></a>00584 <span class="comment">         instead, they&#39;re obtained thru an ioctl call (PIOCOPENLWP)</span>
<a name="l00585"></a>00585 <span class="comment">         to the file descriptor of the parent process.</span>
<a name="l00586"></a>00586 <span class="comment"></span>
<a name="l00587"></a>00587 <span class="comment">       OSF threads:</span>
<a name="l00588"></a>00588 <span class="comment">         These do not even have their own independent file descriptor.</span>
<a name="l00589"></a>00589 <span class="comment">         All operations are carried out on the file descriptor of the</span>
<a name="l00590"></a>00590 <span class="comment">         parent process.  Therefore we just call open again for each</span>
<a name="l00591"></a>00591 <span class="comment">         thread, getting a new handle for the same &#39;file&#39;.  */</span>
<a name="l00592"></a>00592 
<a name="l00593"></a>00593 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l00594"></a>00594 <span class="preprocessor"></span>  <span class="comment">/* In this case, there are several different file descriptors that</span>
<a name="l00595"></a>00595 <span class="comment">     we might be asked to open.  The control file descriptor will be</span>
<a name="l00596"></a>00596 <span class="comment">     opened early, but the others will be opened lazily as they are</span>
<a name="l00597"></a>00597 <span class="comment">     needed.  */</span>
<a name="l00598"></a>00598 
<a name="l00599"></a>00599   strcpy (tmp, pi-&gt;<a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">pathname</a>);
<a name="l00600"></a>00600   <span class="keywordflow">switch</span> (which) {      <span class="comment">/* Which file descriptor to open?  */</span>
<a name="l00601"></a>00601   <span class="keywordflow">case</span> <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca242b7fbe149191cf293910e1f2f65bd6">FD_CTL</a>:
<a name="l00602"></a>00602     <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>)
<a name="l00603"></a>00603       strcat (tmp, <span class="stringliteral">&quot;/lwpctl&quot;</span>);
<a name="l00604"></a>00604     <span class="keywordflow">else</span>
<a name="l00605"></a>00605       strcat (tmp, <span class="stringliteral">&quot;/ctl&quot;</span>);
<a name="l00606"></a>00606     fd = <a class="code" href="procfs_8c.html#a8537de378e19c8806d9837b90505a62d">open_with_retry</a> (tmp, O_WRONLY);
<a name="l00607"></a>00607     <span class="keywordflow">if</span> (fd &lt; 0)
<a name="l00608"></a>00608       <span class="keywordflow">return</span> 0;         <span class="comment">/* fail */</span>
<a name="l00609"></a>00609     pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a> = fd;
<a name="l00610"></a>00610     <span class="keywordflow">break</span>;
<a name="l00611"></a>00611   <span class="keywordflow">case</span> <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca619a7f13145c989adc5f80dad9d9caaf">FD_AS</a>:
<a name="l00612"></a>00612     <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>)
<a name="l00613"></a>00613       <span class="keywordflow">return</span> 0;         <span class="comment">/* There is no &#39;as&#39; file descriptor for an lwp.  */</span>
<a name="l00614"></a>00614     strcat (tmp, <span class="stringliteral">&quot;/as&quot;</span>);
<a name="l00615"></a>00615     fd = <a class="code" href="procfs_8c.html#a8537de378e19c8806d9837b90505a62d">open_with_retry</a> (tmp, O_RDWR);
<a name="l00616"></a>00616     <span class="keywordflow">if</span> (fd &lt; 0)
<a name="l00617"></a>00617       <span class="keywordflow">return</span> 0;         <span class="comment">/* fail */</span>
<a name="l00618"></a>00618     pi-&gt;<a class="code" href="structprocinfo.html#a74f0f6631babefdb4908262293bb6f2e">as_fd</a> = fd;
<a name="l00619"></a>00619     <span class="keywordflow">break</span>;
<a name="l00620"></a>00620   <span class="keywordflow">case</span> <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca14a7bec1b8050b1bc5e4335e59bf0db5">FD_STATUS</a>:
<a name="l00621"></a>00621     <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>)
<a name="l00622"></a>00622       strcat (tmp, <span class="stringliteral">&quot;/lwpstatus&quot;</span>);
<a name="l00623"></a>00623     <span class="keywordflow">else</span>
<a name="l00624"></a>00624       strcat (tmp, <span class="stringliteral">&quot;/status&quot;</span>);
<a name="l00625"></a>00625     fd = <a class="code" href="procfs_8c.html#a8537de378e19c8806d9837b90505a62d">open_with_retry</a> (tmp, O_RDONLY);
<a name="l00626"></a>00626     <span class="keywordflow">if</span> (fd &lt; 0)
<a name="l00627"></a>00627       <span class="keywordflow">return</span> 0;         <span class="comment">/* fail */</span>
<a name="l00628"></a>00628     pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a> = fd;
<a name="l00629"></a>00629     <span class="keywordflow">break</span>;
<a name="l00630"></a>00630   <span class="keywordflow">default</span>:
<a name="l00631"></a>00631     <span class="keywordflow">return</span> 0;           <span class="comment">/* unknown file descriptor */</span>
<a name="l00632"></a>00632   }
<a name="l00633"></a>00633 <span class="preprocessor">#else  </span><span class="comment">/* not NEW_PROC_API */</span>
<a name="l00634"></a>00634   <span class="comment">/* In this case, there is only one file descriptor for each procinfo</span>
<a name="l00635"></a>00635 <span class="comment">     (ie. each process or LWP).  In fact, only the file descriptor for</span>
<a name="l00636"></a>00636 <span class="comment">     the process can actually be opened by an &#39;open&#39; system call.  The</span>
<a name="l00637"></a>00637 <span class="comment">     ones for the LWPs have to be obtained thru an IOCTL call on the</span>
<a name="l00638"></a>00638 <span class="comment">     process&#39;s file descriptor.</span>
<a name="l00639"></a>00639 <span class="comment"></span>
<a name="l00640"></a>00640 <span class="comment">     For convenience, we copy each procinfo&#39;s single file descriptor</span>
<a name="l00641"></a>00641 <span class="comment">     into all of the fields occupied by the several file descriptors</span>
<a name="l00642"></a>00642 <span class="comment">     of the NEW_PROC_API implementation.  That way, the code that uses</span>
<a name="l00643"></a>00643 <span class="comment">     them can be written without ifdefs.  */</span>
<a name="l00644"></a>00644 
<a name="l00645"></a>00645 
<a name="l00646"></a>00646 <span class="preprocessor">#ifdef PIOCTSTATUS      </span><span class="comment">/* OSF */</span>
<a name="l00647"></a>00647   <span class="comment">/* Only one FD; just open it.  */</span>
<a name="l00648"></a>00648   <span class="keywordflow">if</span> ((fd = <a class="code" href="procfs_8c.html#a8537de378e19c8806d9837b90505a62d">open_with_retry</a> (pi-&gt;<a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">pathname</a>, O_RDWR)) &lt; 0)
<a name="l00649"></a>00649     <span class="keywordflow">return</span> 0;
<a name="l00650"></a>00650 <span class="preprocessor">#else                   </span><span class="comment">/* Sol 2.5, Irix, other?  */</span>
<a name="l00651"></a>00651   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> == 0)     <span class="comment">/* Master procinfo for the process */</span>
<a name="l00652"></a>00652     {
<a name="l00653"></a>00653       fd = <a class="code" href="procfs_8c.html#a8537de378e19c8806d9837b90505a62d">open_with_retry</a> (pi-&gt;<a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">pathname</a>, O_RDWR);
<a name="l00654"></a>00654       <span class="keywordflow">if</span> (fd &lt; 0)
<a name="l00655"></a>00655         <span class="keywordflow">return</span> 0;       <span class="comment">/* fail */</span>
<a name="l00656"></a>00656     }
<a name="l00657"></a>00657   <span class="keywordflow">else</span>                  <span class="comment">/* LWP thread procinfo */</span>
<a name="l00658"></a>00658     {
<a name="l00659"></a>00659 <span class="preprocessor">#ifdef PIOCOPENLWP      </span><span class="comment">/* Sol 2.5, thread/LWP */</span>
<a name="l00660"></a>00660       <a class="code" href="structprocinfo.html">procinfo</a> *process;
<a name="l00661"></a>00661       <span class="keywordtype">int</span> lwpid = pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663       <span class="comment">/* Find the procinfo for the entire process.  */</span>
<a name="l00664"></a>00664       <span class="keywordflow">if</span> ((process = <a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0)) == NULL)
<a name="l00665"></a>00665         <span class="keywordflow">return</span> 0;       <span class="comment">/* fail */</span>
<a name="l00666"></a>00666 
<a name="l00667"></a>00667       <span class="comment">/* Now obtain the file descriptor for the LWP.  */</span>
<a name="l00668"></a>00668       <span class="keywordflow">if</span> ((fd = ioctl (process-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCOPENLWP, &amp;lwpid)) &lt; 0)
<a name="l00669"></a>00669         <span class="keywordflow">return</span> 0;       <span class="comment">/* fail */</span>
<a name="l00670"></a>00670 <span class="preprocessor">#else                   </span><span class="comment">/* Irix, other?  */</span>
<a name="l00671"></a>00671       <span class="keywordflow">return</span> 0;         <span class="comment">/* Don&#39;t know how to open threads.  */</span>
<a name="l00672"></a>00672 <span class="preprocessor">#endif  </span><span class="comment">/* Sol 2.5 PIOCOPENLWP */</span>
<a name="l00673"></a>00673     }
<a name="l00674"></a>00674 <span class="preprocessor">#endif  </span><span class="comment">/* OSF     PIOCTSTATUS */</span>
<a name="l00675"></a>00675   pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a> = pi-&gt;<a class="code" href="structprocinfo.html#a74f0f6631babefdb4908262293bb6f2e">as_fd</a> = pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a> = fd;
<a name="l00676"></a>00676 <span class="preprocessor">#endif  </span><span class="comment">/* NEW_PROC_API */</span>
<a name="l00677"></a>00677 
<a name="l00678"></a>00678   <span class="keywordflow">return</span> 1;             <span class="comment">/* success */</span>
<a name="l00679"></a>00679 }
<a name="l00680"></a>00680 
<a name="l00681"></a>00681 <span class="comment">/* Allocate a data structure and link it into the procinfo list.</span>
<a name="l00682"></a>00682 <span class="comment">   First tries to find a pre-existing one (FIXME: why?).  Returns the</span>
<a name="l00683"></a>00683 <span class="comment">   pointer to new procinfo struct.  */</span>
<a name="l00684"></a>00684 
<a name="l00685"></a>00685 <span class="keyword">static</span> <a class="code" href="structprocinfo.html">procinfo</a> *
<a name="l00686"></a><a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">00686</a> <a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a> (<span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, <span class="keywordtype">int</span> <a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>)
<a name="l00687"></a>00687 {
<a name="l00688"></a>00688   <a class="code" href="structprocinfo.html">procinfo</a> *pi, *parent = NULL;
<a name="l00689"></a>00689 
<a name="l00690"></a>00690   <span class="keywordflow">if</span> ((pi = <a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (pid, tid)))
<a name="l00691"></a>00691     <span class="keywordflow">return</span> pi;                  <span class="comment">/* Already exists, nothing to do.  */</span>
<a name="l00692"></a>00692 
<a name="l00693"></a>00693   <span class="comment">/* Find parent before doing malloc, to save having to cleanup.  */</span>
<a name="l00694"></a>00694   <span class="keywordflow">if</span> (tid != 0)
<a name="l00695"></a>00695     parent = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pid, 0);     <span class="comment">/* FIXME: should I</span>
<a name="l00696"></a>00696 <span class="comment">                                                   create it if it</span>
<a name="l00697"></a>00697 <span class="comment">                                                   doesn&#39;t exist yet?  */</span>
<a name="l00698"></a>00698 
<a name="l00699"></a>00699   pi = (<a class="code" href="structprocinfo.html">procinfo</a> *) <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<a class="code" href="structprocinfo.html">procinfo</a>));
<a name="l00700"></a>00700   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (pi, 0, <span class="keyword">sizeof</span> (<a class="code" href="structprocinfo.html">procinfo</a>));
<a name="l00701"></a>00701   pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a> = <a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>;
<a name="l00702"></a>00702   pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> = <a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704 <span class="preprocessor">#ifdef DYNAMIC_SYSCALLS</span>
<a name="l00705"></a>00705 <span class="preprocessor"></span>  load_syscalls (pi);
<a name="l00706"></a>00706 <span class="preprocessor">#endif</span>
<a name="l00707"></a>00707 <span class="preprocessor"></span>
<a name="l00708"></a>00708   pi-&gt;<a class="code" href="structprocinfo.html#a7df20e8108a16cdf00b4a40039b97164">saved_entryset</a> = <a class="code" href="procfs_8c.html#a46e37b7eaec868b43af27d24b556e9c9">sysset_t_alloc</a> (pi);
<a name="l00709"></a>00709   pi-&gt;<a class="code" href="structprocinfo.html#aa7801fdd3d9f15fda54aa8d81b3ccfd8">saved_exitset</a> = <a class="code" href="procfs_8c.html#a46e37b7eaec868b43af27d24b556e9c9">sysset_t_alloc</a> (pi);
<a name="l00710"></a>00710 
<a name="l00711"></a>00711   <span class="comment">/* Chain into list.  */</span>
<a name="l00712"></a>00712   <span class="keywordflow">if</span> (tid == 0)
<a name="l00713"></a>00713     {
<a name="l00714"></a>00714       sprintf (pi-&gt;<a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">pathname</a>, <a class="code" href="procfs_8c.html#a4a950932827615e651aba7ed9f169b0d">MAIN_PROC_NAME_FMT</a>, pid);
<a name="l00715"></a>00715       pi-&gt;<a class="code" href="structprocinfo.html#a423589ec10ab03a958088139858eeb8d">next</a> = <a class="code" href="procfs_8c.html#a8fb538c8bbea3a9a18523a063ddcec24">procinfo_list</a>;
<a name="l00716"></a>00716       procinfo_list = pi;
<a name="l00717"></a>00717     }
<a name="l00718"></a>00718   <span class="keywordflow">else</span>
<a name="l00719"></a>00719     {
<a name="l00720"></a>00720 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l00721"></a>00721 <span class="preprocessor"></span>      sprintf (pi-&gt;<a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">pathname</a>, <span class="stringliteral">&quot;/proc/%05d/lwp/%d&quot;</span>, pid, tid);
<a name="l00722"></a>00722 <span class="preprocessor">#else</span>
<a name="l00723"></a>00723 <span class="preprocessor"></span>      sprintf (pi-&gt;<a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">pathname</a>, <a class="code" href="procfs_8c.html#a4a950932827615e651aba7ed9f169b0d">MAIN_PROC_NAME_FMT</a>, pid);
<a name="l00724"></a>00724 <span class="preprocessor">#endif</span>
<a name="l00725"></a>00725 <span class="preprocessor"></span>      pi-&gt;<a class="code" href="structprocinfo.html#a423589ec10ab03a958088139858eeb8d">next</a> = parent-&gt;<a class="code" href="structprocinfo.html#ac9b6c53503df0c67d97f747b041fa10f">thread_list</a>;
<a name="l00726"></a>00726       parent-&gt;<a class="code" href="structprocinfo.html#ac9b6c53503df0c67d97f747b041fa10f">thread_list</a> = pi;
<a name="l00727"></a>00727     }
<a name="l00728"></a>00728   <span class="keywordflow">return</span> pi;
<a name="l00729"></a>00729 }
<a name="l00730"></a>00730 
<a name="l00731"></a>00731 <span class="comment">/* Close all file descriptors associated with the procinfo.  */</span>
<a name="l00732"></a>00732 
<a name="l00733"></a>00733 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00734"></a><a class="code" href="procfs_8c.html#ad61e7432a6ca3e0653550d2bf7c8be53">00734</a> <a class="code" href="procfs_8c.html#ad61e7432a6ca3e0653550d2bf7c8be53">close_procinfo_files</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l00735"></a>00735 {
<a name="l00736"></a>00736   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a> &gt; 0)
<a name="l00737"></a>00737     close (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>);
<a name="l00738"></a>00738 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l00739"></a>00739 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a74f0f6631babefdb4908262293bb6f2e">as_fd</a> &gt; 0)
<a name="l00740"></a>00740     close (pi-&gt;<a class="code" href="structprocinfo.html#a74f0f6631babefdb4908262293bb6f2e">as_fd</a>);
<a name="l00741"></a>00741   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a> &gt; 0)
<a name="l00742"></a>00742     close (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a>);
<a name="l00743"></a>00743 <span class="preprocessor">#endif</span>
<a name="l00744"></a>00744 <span class="preprocessor"></span>  pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a> = pi-&gt;<a class="code" href="structprocinfo.html#a74f0f6631babefdb4908262293bb6f2e">as_fd</a> = pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a> = 0;
<a name="l00745"></a>00745 }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 <span class="comment">/* Destructor function.  Close, unlink and deallocate the object.  */</span>
<a name="l00748"></a>00748 
<a name="l00749"></a>00749 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00750"></a><a class="code" href="procfs_8c.html#afa82c8d35661410a78f95c75c3987575">00750</a> <a class="code" href="procfs_8c.html#afa82c8d35661410a78f95c75c3987575">destroy_one_procinfo</a> (<a class="code" href="structprocinfo.html">procinfo</a> **list, <a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l00751"></a>00751 {
<a name="l00752"></a>00752   <a class="code" href="structprocinfo.html">procinfo</a> *ptr;
<a name="l00753"></a>00753 
<a name="l00754"></a>00754   <span class="comment">/* Step one: unlink the procinfo from its list.  */</span>
<a name="l00755"></a>00755   <span class="keywordflow">if</span> (pi == *list)
<a name="l00756"></a>00756     *list = pi-&gt;<a class="code" href="structprocinfo.html#a423589ec10ab03a958088139858eeb8d">next</a>;
<a name="l00757"></a>00757   <span class="keywordflow">else</span>
<a name="l00758"></a>00758     <span class="keywordflow">for</span> (ptr = *list; ptr; ptr = ptr-&gt;<a class="code" href="structprocinfo.html#a423589ec10ab03a958088139858eeb8d">next</a>)
<a name="l00759"></a>00759       <span class="keywordflow">if</span> (ptr-&gt;<a class="code" href="structprocinfo.html#a423589ec10ab03a958088139858eeb8d">next</a> == pi)
<a name="l00760"></a>00760         {
<a name="l00761"></a>00761           ptr-&gt;<a class="code" href="structprocinfo.html#a423589ec10ab03a958088139858eeb8d">next</a> =  pi-&gt;<a class="code" href="structprocinfo.html#a423589ec10ab03a958088139858eeb8d">next</a>;
<a name="l00762"></a>00762           <span class="keywordflow">break</span>;
<a name="l00763"></a>00763         }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765   <span class="comment">/* Step two: close any open file descriptors.  */</span>
<a name="l00766"></a>00766   <a class="code" href="procfs_8c.html#ad61e7432a6ca3e0653550d2bf7c8be53">close_procinfo_files</a> (pi);
<a name="l00767"></a>00767 
<a name="l00768"></a>00768   <span class="comment">/* Step three: free the memory.  */</span>
<a name="l00769"></a>00769 <span class="preprocessor">#ifdef DYNAMIC_SYSCALLS</span>
<a name="l00770"></a>00770 <span class="preprocessor"></span>  free_syscalls (pi);
<a name="l00771"></a>00771 <span class="preprocessor">#endif</span>
<a name="l00772"></a>00772 <span class="preprocessor"></span>  <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (pi-&gt;<a class="code" href="structprocinfo.html#a7df20e8108a16cdf00b4a40039b97164">saved_entryset</a>);
<a name="l00773"></a>00773   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (pi-&gt;<a class="code" href="structprocinfo.html#aa7801fdd3d9f15fda54aa8d81b3ccfd8">saved_exitset</a>);
<a name="l00774"></a>00774   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (pi);
<a name="l00775"></a>00775 }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00778"></a><a class="code" href="procfs_8c.html#af0251ed126d7aa5845297cab52db3b68">00778</a> <a class="code" href="procfs_8c.html#af0251ed126d7aa5845297cab52db3b68">destroy_procinfo</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l00779"></a>00779 {
<a name="l00780"></a>00780   <a class="code" href="structprocinfo.html">procinfo</a> *tmp;
<a name="l00781"></a>00781 
<a name="l00782"></a>00782   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)     <span class="comment">/* Destroy a thread procinfo.  */</span>
<a name="l00783"></a>00783     {
<a name="l00784"></a>00784       tmp = <a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0); <span class="comment">/* Find the parent process.  */</span>
<a name="l00785"></a>00785       <a class="code" href="procfs_8c.html#afa82c8d35661410a78f95c75c3987575">destroy_one_procinfo</a> (&amp;tmp-&gt;<a class="code" href="structprocinfo.html#ac9b6c53503df0c67d97f747b041fa10f">thread_list</a>, pi);
<a name="l00786"></a>00786     }
<a name="l00787"></a>00787   <span class="keywordflow">else</span>                  <span class="comment">/* Destroy a process procinfo and all its threads.  */</span>
<a name="l00788"></a>00788     {
<a name="l00789"></a>00789       <span class="comment">/* First destroy the children, if any; */</span>
<a name="l00790"></a>00790       <span class="keywordflow">while</span> (pi-&gt;<a class="code" href="structprocinfo.html#ac9b6c53503df0c67d97f747b041fa10f">thread_list</a> != NULL)
<a name="l00791"></a>00791         <a class="code" href="procfs_8c.html#afa82c8d35661410a78f95c75c3987575">destroy_one_procinfo</a> (&amp;pi-&gt;<a class="code" href="structprocinfo.html#ac9b6c53503df0c67d97f747b041fa10f">thread_list</a>, pi-&gt;<a class="code" href="structprocinfo.html#ac9b6c53503df0c67d97f747b041fa10f">thread_list</a>);
<a name="l00792"></a>00792       <span class="comment">/* Then destroy the parent.  Genocide!!!  */</span>
<a name="l00793"></a>00793       <a class="code" href="procfs_8c.html#afa82c8d35661410a78f95c75c3987575">destroy_one_procinfo</a> (&amp;procinfo_list, pi);
<a name="l00794"></a>00794     }
<a name="l00795"></a>00795 }
<a name="l00796"></a>00796 
<a name="l00797"></a>00797 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00798"></a><a class="code" href="procfs_8c.html#ab2c6317aa8356e2091a2bc12eb69f1c2">00798</a> <a class="code" href="procfs_8c.html#ab2c6317aa8356e2091a2bc12eb69f1c2">do_destroy_procinfo_cleanup</a> (<span class="keywordtype">void</span> *pi)
<a name="l00799"></a>00799 {
<a name="l00800"></a>00800   <a class="code" href="procfs_8c.html#af0251ed126d7aa5845297cab52db3b68">destroy_procinfo</a> (pi);
<a name="l00801"></a>00801 }
<a name="l00802"></a>00802 
<a name="l00803"></a><a class="code" href="procfs_8c.html#a0ae1e3bf78c960c83e2d437efd802058abe2503b6c561e99c096631b995eaa539">00803</a> <span class="keyword">enum</span> { <a class="code" href="procfs_8c.html#a0ae1e3bf78c960c83e2d437efd802058abe2503b6c561e99c096631b995eaa539">NOKILL</a>, <a class="code" href="procfs_8c.html#a0ae1e3bf78c960c83e2d437efd802058a702a32e3574ea40b8d2f358dec764298">KILL</a> };
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 <span class="comment">/* To be called on a non_recoverable error for a procinfo.  Prints</span>
<a name="l00806"></a>00806 <span class="comment">   error messages, optionally sends a SIGKILL to the process, then</span>
<a name="l00807"></a>00807 <span class="comment">   destroys the data structure.  */</span>
<a name="l00808"></a>00808 
<a name="l00809"></a>00809 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00810"></a><a class="code" href="procfs_8c.html#a4a363dfa0e8f3f68a66a7152e0d95913">00810</a> <a class="code" href="procfs_8c.html#a4a363dfa0e8f3f68a66a7152e0d95913">dead_procinfo</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">char</span> *msg, <span class="keywordtype">int</span> kill_p)
<a name="l00811"></a>00811 {
<a name="l00812"></a>00812   <span class="keywordtype">char</span> procfile[80];
<a name="l00813"></a>00813 
<a name="l00814"></a>00814   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">pathname</a>)
<a name="l00815"></a>00815     {
<a name="l00816"></a>00816       <a class="code" href="utils_8c.html#a539ee53fd58602e5967f3852c6689792">print_sys_errmsg</a> (pi-&gt;<a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">pathname</a>, errno);
<a name="l00817"></a>00817     }
<a name="l00818"></a>00818   <span class="keywordflow">else</span>
<a name="l00819"></a>00819     {
<a name="l00820"></a>00820       sprintf (procfile, <span class="stringliteral">&quot;process %d&quot;</span>, pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>);
<a name="l00821"></a>00821       <a class="code" href="utils_8c.html#a539ee53fd58602e5967f3852c6689792">print_sys_errmsg</a> (procfile, errno);
<a name="l00822"></a>00822     }
<a name="l00823"></a>00823   <span class="keywordflow">if</span> (kill_p == <a class="code" href="procfs_8c.html#a0ae1e3bf78c960c83e2d437efd802058a702a32e3574ea40b8d2f358dec764298">KILL</a>)
<a name="l00824"></a>00824     kill (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, SIGKILL);
<a name="l00825"></a>00825 
<a name="l00826"></a>00826   <a class="code" href="procfs_8c.html#af0251ed126d7aa5845297cab52db3b68">destroy_procinfo</a> (pi);
<a name="l00827"></a>00827   <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<span class="stringliteral">&quot;%s&quot;</span>, msg);
<a name="l00828"></a>00828 }
<a name="l00829"></a>00829 
<a name="l00830"></a>00830 <span class="comment">/* Returns the (complete) size of a sysset_t struct.  Normally, this</span>
<a name="l00831"></a>00831 <span class="comment">   is just sizeof (sysset_t), but in the case of Monterey/64, the</span>
<a name="l00832"></a>00832 <span class="comment">   actual size of sysset_t isn&#39;t known until runtime.  */</span>
<a name="l00833"></a>00833 
<a name="l00834"></a>00834 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00835"></a><a class="code" href="procfs_8c.html#a1cdd2d8ca6008592b9aeb49b7f6e4f10">00835</a> <a class="code" href="procfs_8c.html#a1cdd2d8ca6008592b9aeb49b7f6e4f10">sysset_t_size</a> (<a class="code" href="structprocinfo.html">procinfo</a> * pi)
<a name="l00836"></a>00836 {
<a name="l00837"></a>00837 <span class="preprocessor">#ifndef DYNAMIC_SYSCALLS</span>
<a name="l00838"></a>00838 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <span class="keyword">sizeof</span> (sysset_t);
<a name="l00839"></a>00839 <span class="preprocessor">#else</span>
<a name="l00840"></a>00840 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <span class="keyword">sizeof</span> (sysset_t) - <span class="keyword">sizeof</span> (uint64_t)
<a name="l00841"></a>00841     + <span class="keyword">sizeof</span> (uint64_t) * ((pi-&gt;num_syscalls + (8 * sizeof (uint64_t) - 1))
<a name="l00842"></a>00842                            / (8 * <span class="keyword">sizeof</span> (uint64_t)));
<a name="l00843"></a>00843 <span class="preprocessor">#endif</span>
<a name="l00844"></a>00844 <span class="preprocessor"></span>}
<a name="l00845"></a>00845 
<a name="l00846"></a>00846 <span class="comment">/* Allocate and (partially) initialize a sysset_t struct.  */</span>
<a name="l00847"></a>00847 
<a name="l00848"></a>00848 <span class="keyword">static</span> sysset_t *
<a name="l00849"></a><a class="code" href="procfs_8c.html#a46e37b7eaec868b43af27d24b556e9c9">00849</a> <a class="code" href="procfs_8c.html#a46e37b7eaec868b43af27d24b556e9c9">sysset_t_alloc</a> (<a class="code" href="structprocinfo.html">procinfo</a> * pi)
<a name="l00850"></a>00850 {
<a name="l00851"></a>00851   sysset_t *ret;
<a name="l00852"></a>00852   <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> = <a class="code" href="procfs_8c.html#a1cdd2d8ca6008592b9aeb49b7f6e4f10">sysset_t_size</a> (pi);
<a name="l00853"></a>00853 
<a name="l00854"></a>00854   ret = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (size);
<a name="l00855"></a>00855 <span class="preprocessor">#ifdef DYNAMIC_SYSCALLS</span>
<a name="l00856"></a>00856 <span class="preprocessor"></span>  ret-&gt;pr_size = ((pi-&gt;num_syscalls + (8 * <span class="keyword">sizeof</span> (uint64_t) - 1))
<a name="l00857"></a>00857                   / (8 * <span class="keyword">sizeof</span> (uint64_t)));
<a name="l00858"></a>00858 <span class="preprocessor">#endif</span>
<a name="l00859"></a>00859 <span class="preprocessor"></span>  <span class="keywordflow">return</span> ret;
<a name="l00860"></a>00860 }
<a name="l00861"></a>00861 
<a name="l00862"></a>00862 <span class="preprocessor">#ifdef DYNAMIC_SYSCALLS</span>
<a name="l00863"></a>00863 <span class="preprocessor"></span>
<a name="l00864"></a>00864 <span class="comment">/* Extract syscall numbers and names from /proc/&lt;pid&gt;/sysent.  Initialize</span>
<a name="l00865"></a>00865 <span class="comment">   pi-&gt;num_syscalls with the number of syscalls and pi-&gt;syscall_names</span>
<a name="l00866"></a>00866 <span class="comment">   with the names.  (Certain numbers may be skipped in which case the</span>
<a name="l00867"></a>00867 <span class="comment">   names for these numbers will be left as NULL.)  */</span>
<a name="l00868"></a>00868 
<a name="l00869"></a>00869 <span class="preprocessor">#define MAX_SYSCALL_NAME_LENGTH 256</span>
<a name="l00870"></a>00870 <span class="preprocessor"></span><span class="preprocessor">#define MAX_SYSCALLS 65536</span>
<a name="l00871"></a>00871 <span class="preprocessor"></span>
<a name="l00872"></a>00872 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00873"></a>00873 load_syscalls (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l00874"></a>00874 {
<a name="l00875"></a>00875   <span class="keywordtype">char</span> <a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">pathname</a>[<a class="code" href="procfs_8c.html#a516ed8ab3b65b65276525efba4b38d6d">MAX_PROC_NAME_SIZE</a>];
<a name="l00876"></a>00876   <span class="keywordtype">int</span> sysent_fd;
<a name="l00877"></a>00877   prsysent_t header;
<a name="l00878"></a>00878   prsyscall_t *syscalls;
<a name="l00879"></a>00879   <span class="keywordtype">int</span> i, <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>, maxcall;
<a name="l00880"></a>00880   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups;
<a name="l00881"></a>00881 
<a name="l00882"></a>00882   pi-&gt;num_syscalls = 0;
<a name="l00883"></a>00883   pi-&gt;syscall_names = 0;
<a name="l00884"></a>00884 
<a name="l00885"></a>00885   <span class="comment">/* Open the file descriptor for the sysent file.  */</span>
<a name="l00886"></a>00886   sprintf (pathname, <span class="stringliteral">&quot;/proc/%d/sysent&quot;</span>, pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>);
<a name="l00887"></a>00887   sysent_fd = <a class="code" href="procfs_8c.html#a8537de378e19c8806d9837b90505a62d">open_with_retry</a> (pathname, O_RDONLY);
<a name="l00888"></a>00888   <span class="keywordflow">if</span> (sysent_fd &lt; 0)
<a name="l00889"></a>00889     {
<a name="l00890"></a>00890       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;load_syscalls: Can&#39;t open /proc/%d/sysent&quot;</span>), pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>);
<a name="l00891"></a>00891     }
<a name="l00892"></a>00892   cleanups = <a class="code" href="utils_8c.html#ae1c81b8331e815cc346382bc13e20095">make_cleanup_close</a> (sysent_fd);
<a name="l00893"></a>00893 
<a name="l00894"></a>00894   size = <span class="keyword">sizeof</span> header - <span class="keyword">sizeof</span> (prsyscall_t);
<a name="l00895"></a>00895   <span class="keywordflow">if</span> (<a class="code" href="expect-read1_8c.html#af32a16ad2dd9e48482f8f790db7dbbd2">read</a> (sysent_fd, &amp;header, size) != <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>)
<a name="l00896"></a>00896     {
<a name="l00897"></a>00897       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;load_syscalls: Error reading /proc/%d/sysent&quot;</span>), pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>);
<a name="l00898"></a>00898     }
<a name="l00899"></a>00899 
<a name="l00900"></a>00900   <span class="keywordflow">if</span> (header.pr_nsyscalls == 0)
<a name="l00901"></a>00901     {
<a name="l00902"></a>00902       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;load_syscalls: /proc/%d/sysent contains no syscalls!&quot;</span>),
<a name="l00903"></a>00903              pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>);
<a name="l00904"></a>00904     }
<a name="l00905"></a>00905 
<a name="l00906"></a>00906   size = header.pr_nsyscalls * <span class="keyword">sizeof</span> (prsyscall_t);
<a name="l00907"></a>00907   syscalls = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (size);
<a name="l00908"></a>00908   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="utils_8c.html#a6d8c21606d3f67a431a7bfbb1f47d12e">free_current_contents</a>, &amp;syscalls);
<a name="l00909"></a>00909 
<a name="l00910"></a>00910   <span class="keywordflow">if</span> (<a class="code" href="expect-read1_8c.html#af32a16ad2dd9e48482f8f790db7dbbd2">read</a> (sysent_fd, syscalls, size) != size)
<a name="l00911"></a>00911     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;load_syscalls: Error reading /proc/%d/sysent&quot;</span>), pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913   <span class="comment">/* Find maximum syscall number.  This may not be the same as</span>
<a name="l00914"></a>00914 <span class="comment">     pr_nsyscalls since that value refers to the number of entries</span>
<a name="l00915"></a>00915 <span class="comment">     in the table.  (Also, the docs indicate that some system</span>
<a name="l00916"></a>00916 <span class="comment">     call numbers may be skipped.)  */</span>
<a name="l00917"></a>00917 
<a name="l00918"></a>00918   maxcall = syscalls[0].pr_number;
<a name="l00919"></a>00919 
<a name="l00920"></a>00920   <span class="keywordflow">for</span> (i = 1; i &lt;  header.pr_nsyscalls; i++)
<a name="l00921"></a>00921     <span class="keywordflow">if</span> (syscalls[i].pr_number &gt; maxcall
<a name="l00922"></a>00922         &amp;&amp; syscalls[i].pr_nameoff &gt; 0
<a name="l00923"></a>00923         &amp;&amp; syscalls[i].pr_number &lt; <a class="code" href="proc-events_8c.html#a88ef3d98617b4673404cd57e1fa4e516">MAX_SYSCALLS</a>)
<a name="l00924"></a>00924       maxcall = syscalls[i].pr_number;
<a name="l00925"></a>00925 
<a name="l00926"></a>00926   pi-&gt;num_syscalls = maxcall+1;
<a name="l00927"></a>00927   pi-&gt;syscall_names = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (pi-&gt;num_syscalls * sizeof (<span class="keywordtype">char</span> *));
<a name="l00928"></a>00928 
<a name="l00929"></a>00929   <span class="keywordflow">for</span> (i = 0; i &lt; pi-&gt;num_syscalls; i++)
<a name="l00930"></a>00930     pi-&gt;syscall_names[i] = NULL;
<a name="l00931"></a>00931 
<a name="l00932"></a>00932   <span class="comment">/* Read the syscall names in.  */</span>
<a name="l00933"></a>00933   for (i = 0; i &lt; header.pr_nsyscalls; i++)
<a name="l00934"></a>00934     {
<a name="l00935"></a>00935       <span class="keywordtype">char</span> namebuf[MAX_SYSCALL_NAME_LENGTH];
<a name="l00936"></a>00936       <span class="keywordtype">int</span> nread;
<a name="l00937"></a>00937       <span class="keywordtype">int</span> callnum;
<a name="l00938"></a>00938 
<a name="l00939"></a>00939       <span class="keywordflow">if</span> (syscalls[i].pr_number &gt;= <a class="code" href="proc-events_8c.html#a88ef3d98617b4673404cd57e1fa4e516">MAX_SYSCALLS</a>
<a name="l00940"></a>00940           || syscalls[i].pr_number &lt; 0
<a name="l00941"></a>00941           || syscalls[i].pr_nameoff &lt;= 0
<a name="l00942"></a>00942           || (lseek (sysent_fd, (off_t) syscalls[i].pr_nameoff, SEEK_SET)
<a name="l00943"></a>00943                                        != (off_t) syscalls[i].pr_nameoff))
<a name="l00944"></a>00944         <span class="keywordflow">continue</span>;
<a name="l00945"></a>00945 
<a name="l00946"></a>00946       nread = <a class="code" href="expect-read1_8c.html#af32a16ad2dd9e48482f8f790db7dbbd2">read</a> (sysent_fd, namebuf, <span class="keyword">sizeof</span> namebuf);
<a name="l00947"></a>00947       <span class="keywordflow">if</span> (nread &lt;= 0)
<a name="l00948"></a>00948         <span class="keywordflow">continue</span>;
<a name="l00949"></a>00949 
<a name="l00950"></a>00950       callnum = syscalls[i].pr_number;
<a name="l00951"></a>00951 
<a name="l00952"></a>00952       <span class="keywordflow">if</span> (pi-&gt;syscall_names[callnum] != NULL)
<a name="l00953"></a>00953         {
<a name="l00954"></a>00954           <span class="comment">/* FIXME: Generate warning.  */</span>
<a name="l00955"></a>00955           <span class="keywordflow">continue</span>;
<a name="l00956"></a>00956         }
<a name="l00957"></a>00957 
<a name="l00958"></a>00958       namebuf[nread-1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00959"></a>00959       size = strlen (namebuf) + 1;
<a name="l00960"></a>00960       pi-&gt;syscall_names[callnum] = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (size);
<a name="l00961"></a>00961       strncpy (pi-&gt;syscall_names[callnum], namebuf, size-1);
<a name="l00962"></a>00962       pi-&gt;syscall_names[callnum][size-1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00963"></a>00963     }
<a name="l00964"></a>00964 
<a name="l00965"></a>00965   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l00966"></a>00966 }
<a name="l00967"></a>00967 
<a name="l00968"></a>00968 <span class="comment">/* Free the space allocated for the syscall names from the procinfo</span>
<a name="l00969"></a>00969 <span class="comment">   structure.  */</span>
<a name="l00970"></a>00970 
<a name="l00971"></a>00971 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00972"></a>00972 free_syscalls (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l00973"></a>00973 {
<a name="l00974"></a>00974   <span class="keywordflow">if</span> (pi-&gt;syscall_names)
<a name="l00975"></a>00975     {
<a name="l00976"></a>00976       <span class="keywordtype">int</span> i;
<a name="l00977"></a>00977 
<a name="l00978"></a>00978       <span class="keywordflow">for</span> (i = 0; i &lt; pi-&gt;num_syscalls; i++)
<a name="l00979"></a>00979         <span class="keywordflow">if</span> (pi-&gt;syscall_names[i] != NULL)
<a name="l00980"></a>00980           <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (pi-&gt;syscall_names[i]);
<a name="l00981"></a>00981 
<a name="l00982"></a>00982       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (pi-&gt;syscall_names);
<a name="l00983"></a>00983       pi-&gt;syscall_names = 0;
<a name="l00984"></a>00984     }
<a name="l00985"></a>00985 }
<a name="l00986"></a>00986 
<a name="l00987"></a>00987 <span class="comment">/* Given a name, look up (and return) the corresponding syscall number.</span>
<a name="l00988"></a>00988 <span class="comment">   If no match is found, return -1.  */</span>
<a name="l00989"></a>00989 
<a name="l00990"></a>00990 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00991"></a>00991 find_syscall (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>)
<a name="l00992"></a>00992 {
<a name="l00993"></a>00993   <span class="keywordtype">int</span> i;
<a name="l00994"></a>00994 
<a name="l00995"></a>00995   <span class="keywordflow">for</span> (i = 0; i &lt; pi-&gt;num_syscalls; i++)
<a name="l00996"></a>00996     {
<a name="l00997"></a>00997       <span class="keywordflow">if</span> (pi-&gt;syscall_names[i] &amp;&amp; strcmp (name, pi-&gt;syscall_names[i]) == 0)
<a name="l00998"></a>00998         <span class="keywordflow">return</span> i;
<a name="l00999"></a>00999     }
<a name="l01000"></a>01000   <span class="keywordflow">return</span> -1;
<a name="l01001"></a>01001 }
<a name="l01002"></a>01002 <span class="preprocessor">#endif</span>
<a name="l01003"></a>01003 <span class="preprocessor"></span>
<a name="l01004"></a>01004 <span class="comment">/* =================== END, STRUCT PROCINFO &quot;MODULE&quot; =================== */</span>
<a name="l01005"></a>01005 
<a name="l01006"></a>01006 <span class="comment">/* ===================  /proc  &quot;MODULE&quot; =================== */</span>
<a name="l01007"></a>01007 
<a name="l01008"></a>01008 <span class="comment">/* This &quot;module&quot; is the interface layer between the /proc system API</span>
<a name="l01009"></a>01009 <span class="comment">   and the gdb target vector functions.  This layer consists of access</span>
<a name="l01010"></a>01010 <span class="comment">   functions that encapsulate each of the basic operations that we</span>
<a name="l01011"></a>01011 <span class="comment">   need to use from the /proc API.</span>
<a name="l01012"></a>01012 <span class="comment"></span>
<a name="l01013"></a>01013 <span class="comment">   The main motivation for this layer is to hide the fact that there</span>
<a name="l01014"></a>01014 <span class="comment">   are two very different implementations of the /proc API.  Rather</span>
<a name="l01015"></a>01015 <span class="comment">   than have a bunch of #ifdefs all thru the gdb target vector</span>
<a name="l01016"></a>01016 <span class="comment">   functions, we do our best to hide them all in here.  */</span>
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 <span class="keyword">static</span> <span class="keywordtype">long</span> <a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (<a class="code" href="structprocinfo.html">procinfo</a> * pi);
<a name="l01019"></a>01019 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="procfs_8c.html#af1d2febb017ce0acde9f56bbfcbfde9e">proc_why</a> (<a class="code" href="structprocinfo.html">procinfo</a> * pi);
<a name="l01020"></a>01020 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="procfs_8c.html#a8f54b931ed7656bcce6696ea27b8b3c3">proc_what</a> (<a class="code" href="structprocinfo.html">procinfo</a> * pi);
<a name="l01021"></a>01021 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="procfs_8c.html#ad042ba71cbc842f0407b54cfe972fb19">proc_set_current_signal</a> (<a class="code" href="structprocinfo.html">procinfo</a> * pi, <span class="keywordtype">int</span> signo);
<a name="l01022"></a>01022 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">proc_get_current_thread</a> (<a class="code" href="structprocinfo.html">procinfo</a> * pi);
<a name="l01023"></a>01023 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="procfs_8c.html#a5fcfad306ae6b00c6d9b3c201d568580">proc_iterate_over_threads</a>
<a name="l01024"></a>01024   (<a class="code" href="structprocinfo.html">procinfo</a> * pi,
<a name="l01025"></a>01025    <span class="keywordtype">int</span> (*<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>) (<a class="code" href="structprocinfo.html">procinfo</a> *, <a class="code" href="structprocinfo.html">procinfo</a> *, <span class="keywordtype">void</span> *),
<a name="l01026"></a>01026    <span class="keywordtype">void</span> *ptr);
<a name="l01027"></a>01027 
<a name="l01028"></a>01028 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01029"></a><a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">01029</a> <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">char</span> *<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>, <span class="keywordtype">int</span> <a class="code" href="symtab_8h.html#a41ebd28ef1d7c6ade45642cb6acc1039">line</a>)
<a name="l01030"></a>01030 {
<a name="l01031"></a>01031   sprintf (errmsg, <span class="stringliteral">&quot;procfs: %s line %d, %s&quot;</span>, func, line, pi-&gt;<a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">pathname</a>);
<a name="l01032"></a>01032   <a class="code" href="utils_8c.html#a539ee53fd58602e5967f3852c6689792">print_sys_errmsg</a> (errmsg, errno);
<a name="l01033"></a>01033 }
<a name="l01034"></a>01034 
<a name="l01035"></a>01035 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01036"></a><a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">01036</a> <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">char</span> *<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>, <span class="keywordtype">int</span> <a class="code" href="symtab_8h.html#a41ebd28ef1d7c6ade45642cb6acc1039">line</a>)
<a name="l01037"></a>01037 {
<a name="l01038"></a>01038   sprintf (errmsg, <span class="stringliteral">&quot;procfs: %s line %d, %s&quot;</span>, func, line, pi-&gt;<a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">pathname</a>);
<a name="l01039"></a>01039   <a class="code" href="utils_8c.html#a14801ceb45147833b8ce111c89ea0d5f">perror_with_name</a> (errmsg);
<a name="l01040"></a>01040 }
<a name="l01041"></a>01041 
<a name="l01042"></a>01042 <span class="comment">/* Updates the status struct in the procinfo.  There is a &#39;valid&#39;</span>
<a name="l01043"></a>01043 <span class="comment">   flag, to let other functions know when this function needs to be</span>
<a name="l01044"></a>01044 <span class="comment">   called (so the status is only read when it is needed).  The status</span>
<a name="l01045"></a>01045 <span class="comment">   file descriptor is also only opened when it is needed.  Returns</span>
<a name="l01046"></a>01046 <span class="comment">   non-zero for success, zero for failure.  */</span>
<a name="l01047"></a>01047 
<a name="l01048"></a>01048 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01049"></a><a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">01049</a> <a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l01050"></a>01050 {
<a name="l01051"></a>01051   <span class="comment">/* Status file descriptor is opened &quot;lazily&quot;.  */</span>
<a name="l01052"></a>01052   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a> == 0 &amp;&amp;
<a name="l01053"></a>01053       <a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (pi, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca14a7bec1b8050b1bc5e4335e59bf0db5">FD_STATUS</a>) == 0)
<a name="l01054"></a>01054     {
<a name="l01055"></a>01055       pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 0;
<a name="l01056"></a>01056       <span class="keywordflow">return</span> 0;
<a name="l01057"></a>01057     }
<a name="l01058"></a>01058 
<a name="l01059"></a>01059 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01060"></a>01060 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (lseek (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a>, 0, SEEK_SET) &lt; 0)
<a name="l01061"></a>01061     pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 0;                       <span class="comment">/* fail */</span>
<a name="l01062"></a>01062   <span class="keywordflow">else</span>
<a name="l01063"></a>01063     {
<a name="l01064"></a>01064       <span class="comment">/* Sigh... I have to read a different data structure,</span>
<a name="l01065"></a>01065 <span class="comment">         depending on whether this is a main process or an LWP.  */</span>
<a name="l01066"></a>01066       <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>)
<a name="l01067"></a>01067         pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = (<a class="code" href="expect-read1_8c.html#af32a16ad2dd9e48482f8f790db7dbbd2">read</a> (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a>,
<a name="l01068"></a>01068                                   (<span class="keywordtype">char</span> *) &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_lwp,
<a name="l01069"></a>01069                                   sizeof (lwpstatus_t))
<a name="l01070"></a>01070                             == <span class="keyword">sizeof</span> (lwpstatus_t));
<a name="l01071"></a>01071       <span class="keywordflow">else</span>
<a name="l01072"></a>01072         {
<a name="l01073"></a>01073           pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = (<a class="code" href="expect-read1_8c.html#af32a16ad2dd9e48482f8f790db7dbbd2">read</a> (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a>,
<a name="l01074"></a>01074                                     (<span class="keywordtype">char</span> *) &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>,
<a name="l01075"></a>01075                                     sizeof (gdb_prstatus_t))
<a name="l01076"></a>01076                               == <span class="keyword">sizeof</span> (<a class="code" href="procfs_8c.html#ace613f26c881ade2663acd95a538314b">gdb_prstatus_t</a>));
<a name="l01077"></a>01077         }
<a name="l01078"></a>01078     }
<a name="l01079"></a>01079 <span class="preprocessor">#else   </span><span class="comment">/* ioctl method */</span>
<a name="l01080"></a>01080 <span class="preprocessor">#ifdef PIOCTSTATUS      </span><span class="comment">/* osf */</span>
<a name="l01081"></a>01081   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> == 0)     <span class="comment">/* main process */</span>
<a name="l01082"></a>01082     {
<a name="l01083"></a>01083       <span class="comment">/* Just read the danged status.  Now isn&#39;t that simple?  */</span>
<a name="l01084"></a>01084       pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> =
<a name="l01085"></a>01085         (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a>, PIOCSTATUS, &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>) &gt;= 0);
<a name="l01086"></a>01086     }
<a name="l01087"></a>01087   <span class="keywordflow">else</span>
<a name="l01088"></a>01088     {
<a name="l01089"></a>01089       <span class="keywordtype">int</span> win;
<a name="l01090"></a>01090       <span class="keyword">struct </span>{
<a name="l01091"></a>01091         <span class="keywordtype">long</span> pr_count;
<a name="l01092"></a>01092         tid_t pr_error_thread;
<a name="l01093"></a>01093         <span class="keyword">struct </span>prstatus status;
<a name="l01094"></a>01094       } thread_status;
<a name="l01095"></a>01095 
<a name="l01096"></a>01096       thread_status.pr_count = 1;
<a name="l01097"></a>01097       thread_status.status.pr_tid = pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>;
<a name="l01098"></a>01098       win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a>, PIOCTSTATUS, &amp;thread_status) &gt;= 0);
<a name="l01099"></a>01099       <span class="keywordflow">if</span> (win)
<a name="l01100"></a>01100         {
<a name="l01101"></a>01101           <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (&amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>, &amp;thread_status.status,
<a name="l01102"></a>01102                   sizeof (pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>));
<a name="l01103"></a>01103           pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 1;
<a name="l01104"></a>01104         }
<a name="l01105"></a>01105     }
<a name="l01106"></a>01106 <span class="preprocessor">#else</span>
<a name="l01107"></a>01107 <span class="preprocessor"></span>  <span class="comment">/* Just read the danged status.  Now isn&#39;t that simple?  */</span>
<a name="l01108"></a>01108   pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a>, PIOCSTATUS, &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>) &gt;= 0);
<a name="l01109"></a>01109 <span class="preprocessor">#endif</span>
<a name="l01110"></a>01110 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01111"></a>01111 <span class="preprocessor"></span>
<a name="l01112"></a>01112   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l01113"></a>01113     {
<a name="l01114"></a>01114       <a class="code" href="proc-utils_8h.html#aa775a2a305216480d1e937964905083f">PROC_PRETTYFPRINT_STATUS</a> (<a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (pi),
<a name="l01115"></a>01115                                 <a class="code" href="procfs_8c.html#af1d2febb017ce0acde9f56bbfcbfde9e">proc_why</a> (pi),
<a name="l01116"></a>01116                                 <a class="code" href="procfs_8c.html#a8f54b931ed7656bcce6696ea27b8b3c3">proc_what</a> (pi),
<a name="l01117"></a>01117                                 <a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">proc_get_current_thread</a> (pi));
<a name="l01118"></a>01118     }
<a name="l01119"></a>01119 
<a name="l01120"></a>01120   <span class="comment">/* The status struct includes general regs, so mark them valid too.  */</span>
<a name="l01121"></a>01121   pi-&gt;<a class="code" href="structprocinfo.html#af644c8cc9c6b4f09babb3eaf994fa5fc">gregs_valid</a>  = pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>;
<a name="l01122"></a>01122 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01123"></a>01123 <span class="preprocessor"></span>  <span class="comment">/* In the read/write multiple-fd model, the status struct includes</span>
<a name="l01124"></a>01124 <span class="comment">     the fp regs too, so mark them valid too.  */</span>
<a name="l01125"></a>01125   pi-&gt;<a class="code" href="structprocinfo.html#a687b93500ed96768255ec07735113afb">fpregs_valid</a> = pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>;
<a name="l01126"></a>01126 <span class="preprocessor">#endif</span>
<a name="l01127"></a>01127 <span class="preprocessor"></span>  <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>;      <span class="comment">/* True if success, false if failure.  */</span>
<a name="l01128"></a>01128 }
<a name="l01129"></a>01129 
<a name="l01130"></a>01130 <span class="comment">/* Returns the process flags (pr_flags field).  */</span>
<a name="l01131"></a>01131 
<a name="l01132"></a>01132 <span class="keyword">static</span> <span class="keywordtype">long</span>
<a name="l01133"></a><a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">01133</a> <a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l01134"></a>01134 {
<a name="l01135"></a>01135   <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l01136"></a>01136     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l01137"></a>01137       <span class="keywordflow">return</span> 0; <span class="comment">/* FIXME: not a good failure value (but what is?)  */</span>
<a name="l01138"></a>01138 
<a name="l01139"></a>01139 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01140"></a>01140 <span class="preprocessor"></span>  <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_lwp.pr_flags;
<a name="l01141"></a>01141 <span class="preprocessor">#else</span>
<a name="l01142"></a>01142 <span class="preprocessor"></span>  <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_flags;
<a name="l01143"></a>01143 <span class="preprocessor">#endif</span>
<a name="l01144"></a>01144 <span class="preprocessor"></span>}
<a name="l01145"></a>01145 
<a name="l01146"></a>01146 <span class="comment">/* Returns the pr_why field (why the process stopped).  */</span>
<a name="l01147"></a>01147 
<a name="l01148"></a>01148 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01149"></a><a class="code" href="procfs_8c.html#af1d2febb017ce0acde9f56bbfcbfde9e">01149</a> <a class="code" href="procfs_8c.html#af1d2febb017ce0acde9f56bbfcbfde9e">proc_why</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l01150"></a>01150 {
<a name="l01151"></a>01151   <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l01152"></a>01152     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l01153"></a>01153       <span class="keywordflow">return</span> 0; <span class="comment">/* FIXME: not a good failure value (but what is?)  */</span>
<a name="l01154"></a>01154 
<a name="l01155"></a>01155 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01156"></a>01156 <span class="preprocessor"></span>  <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_lwp.pr_why;
<a name="l01157"></a>01157 <span class="preprocessor">#else</span>
<a name="l01158"></a>01158 <span class="preprocessor"></span>  <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_why;
<a name="l01159"></a>01159 <span class="preprocessor">#endif</span>
<a name="l01160"></a>01160 <span class="preprocessor"></span>}
<a name="l01161"></a>01161 
<a name="l01162"></a>01162 <span class="comment">/* Returns the pr_what field (details of why the process stopped).  */</span>
<a name="l01163"></a>01163 
<a name="l01164"></a>01164 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01165"></a><a class="code" href="procfs_8c.html#a8f54b931ed7656bcce6696ea27b8b3c3">01165</a> <a class="code" href="procfs_8c.html#a8f54b931ed7656bcce6696ea27b8b3c3">proc_what</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l01166"></a>01166 {
<a name="l01167"></a>01167   <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l01168"></a>01168     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l01169"></a>01169       <span class="keywordflow">return</span> 0; <span class="comment">/* FIXME: not a good failure value (but what is?)  */</span>
<a name="l01170"></a>01170 
<a name="l01171"></a>01171 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01172"></a>01172 <span class="preprocessor"></span>  <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_lwp.pr_what;
<a name="l01173"></a>01173 <span class="preprocessor">#else</span>
<a name="l01174"></a>01174 <span class="preprocessor"></span>  <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_what;
<a name="l01175"></a>01175 <span class="preprocessor">#endif</span>
<a name="l01176"></a>01176 <span class="preprocessor"></span>}
<a name="l01177"></a>01177 
<a name="l01178"></a>01178 <span class="comment">/* This function is only called when PI is stopped by a watchpoint.</span>
<a name="l01179"></a>01179 <span class="comment">   Assuming the OS supports it, write to *ADDR the data address which</span>
<a name="l01180"></a>01180 <span class="comment">   triggered it and return 1.  Return 0 if it is not possible to know</span>
<a name="l01181"></a>01181 <span class="comment">   the address.  */</span>
<a name="l01182"></a>01182 
<a name="l01183"></a>01183 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01184"></a><a class="code" href="procfs_8c.html#a1999701b7976474d9e0b339762fe6eaf">01184</a> <a class="code" href="procfs_8c.html#a1999701b7976474d9e0b339762fe6eaf">proc_watchpoint_address</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *addr)
<a name="l01185"></a>01185 {
<a name="l01186"></a>01186   <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l01187"></a>01187     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l01188"></a>01188       <span class="keywordflow">return</span> 0;
<a name="l01189"></a>01189 
<a name="l01190"></a>01190 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01191"></a>01191 <span class="preprocessor"></span>  *addr = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) <a class="code" href="gdbarch_8c.html#a2b208565ab90d977dea704d510998609">gdbarch_pointer_to_address</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> (),
<a name="l01192"></a>01192             <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ())-&gt;<a class="code" href="structbuiltin__type.html#a55f6f9ff7436431777683d8ba62f662a">builtin_data_ptr</a>,
<a name="l01193"></a>01193             (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *) &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_lwp.pr_info.si_addr);
<a name="l01194"></a>01194 <span class="preprocessor">#else</span>
<a name="l01195"></a>01195 <span class="preprocessor"></span>  *addr = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) <a class="code" href="gdbarch_8c.html#a2b208565ab90d977dea704d510998609">gdbarch_pointer_to_address</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> (),
<a name="l01196"></a>01196             <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ())-&gt;<a class="code" href="structbuiltin__type.html#a55f6f9ff7436431777683d8ba62f662a">builtin_data_ptr</a>,
<a name="l01197"></a>01197             (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *) &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_info.si_addr);
<a name="l01198"></a>01198 <span class="preprocessor">#endif</span>
<a name="l01199"></a>01199 <span class="preprocessor"></span>  <span class="keywordflow">return</span> 1;
<a name="l01200"></a>01200 }
<a name="l01201"></a>01201 
<a name="l01202"></a>01202 <span class="preprocessor">#ifndef PIOCSSPCACT     </span><span class="comment">/* The following is not supported on OSF.  */</span>
<a name="l01203"></a>01203 
<a name="l01204"></a>01204 <span class="comment">/* Returns the pr_nsysarg field (number of args to the current</span>
<a name="l01205"></a>01205 <span class="comment">   syscall).  */</span>
<a name="l01206"></a>01206 
<a name="l01207"></a>01207 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01208"></a><a class="code" href="procfs_8c.html#a935646407d6d87eebb4de911ba9e6264">01208</a> <a class="code" href="procfs_8c.html#a935646407d6d87eebb4de911ba9e6264">proc_nsysarg</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l01209"></a>01209 {
<a name="l01210"></a>01210   <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l01211"></a>01211     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l01212"></a>01212       <span class="keywordflow">return</span> 0;
<a name="l01213"></a>01213 
<a name="l01214"></a>01214 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01215"></a>01215 <span class="preprocessor"></span>  <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_lwp.pr_nsysarg;
<a name="l01216"></a>01216 <span class="preprocessor">#else</span>
<a name="l01217"></a>01217 <span class="preprocessor"></span>  <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_nsysarg;
<a name="l01218"></a>01218 <span class="preprocessor">#endif</span>
<a name="l01219"></a>01219 <span class="preprocessor"></span>}
<a name="l01220"></a>01220 
<a name="l01221"></a>01221 <span class="comment">/* Returns the pr_sysarg field (pointer to the arguments of current</span>
<a name="l01222"></a>01222 <span class="comment">   syscall).  */</span>
<a name="l01223"></a>01223 
<a name="l01224"></a>01224 <span class="keyword">static</span> <span class="keywordtype">long</span> *
<a name="l01225"></a><a class="code" href="procfs_8c.html#a90ed1254f4a601bd6ba6c217beb0b437">01225</a> <a class="code" href="procfs_8c.html#a90ed1254f4a601bd6ba6c217beb0b437">proc_sysargs</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l01226"></a>01226 {
<a name="l01227"></a>01227   <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l01228"></a>01228     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l01229"></a>01229       <span class="keywordflow">return</span> NULL;
<a name="l01230"></a>01230 
<a name="l01231"></a>01231 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01232"></a>01232 <span class="preprocessor"></span>  <span class="keywordflow">return</span> (<span class="keywordtype">long</span> *) &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_lwp.pr_sysarg;
<a name="l01233"></a>01233 <span class="preprocessor">#else</span>
<a name="l01234"></a>01234 <span class="preprocessor"></span>  <span class="keywordflow">return</span> (<span class="keywordtype">long</span> *) &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_sysarg;
<a name="l01235"></a>01235 <span class="preprocessor">#endif</span>
<a name="l01236"></a>01236 <span class="preprocessor"></span>}
<a name="l01237"></a>01237 <span class="preprocessor">#endif </span><span class="comment">/* PIOCSSPCACT */</span>
<a name="l01238"></a>01238 
<a name="l01239"></a>01239 <span class="preprocessor">#ifdef PROCFS_DONT_PIOCSSIG_CURSIG</span>
<a name="l01240"></a>01240 <span class="preprocessor"></span><span class="comment">/* Returns the pr_cursig field (current signal).  */</span>
<a name="l01241"></a>01241 
<a name="l01242"></a>01242 <span class="keyword">static</span> <span class="keywordtype">long</span>
<a name="l01243"></a>01243 proc_cursig (<span class="keyword">struct</span> <a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l01244"></a>01244 {
<a name="l01245"></a>01245   <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l01246"></a>01246     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l01247"></a>01247       <span class="keywordflow">return</span> 0; <span class="comment">/* FIXME: not a good failure value (but what is?)  */</span>
<a name="l01248"></a>01248 
<a name="l01249"></a>01249 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01250"></a>01250 <span class="preprocessor"></span>  <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_lwp.pr_cursig;
<a name="l01251"></a>01251 <span class="preprocessor">#else</span>
<a name="l01252"></a>01252 <span class="preprocessor"></span>  <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_cursig;
<a name="l01253"></a>01253 <span class="preprocessor">#endif</span>
<a name="l01254"></a>01254 <span class="preprocessor"></span>}
<a name="l01255"></a>01255 <span class="preprocessor">#endif </span><span class="comment">/* PROCFS_DONT_PIOCSSIG_CURSIG */</span>
<a name="l01256"></a>01256 
<a name="l01257"></a>01257 <span class="comment">/* === I appologize for the messiness of this function.</span>
<a name="l01258"></a>01258 <span class="comment">   === This is an area where the different versions of</span>
<a name="l01259"></a>01259 <span class="comment">   === /proc are more inconsistent than usual.</span>
<a name="l01260"></a>01260 <span class="comment"></span>
<a name="l01261"></a>01261 <span class="comment">   Set or reset any of the following process flags:</span>
<a name="l01262"></a>01262 <span class="comment">      PR_FORK   -- forked child will inherit trace flags</span>
<a name="l01263"></a>01263 <span class="comment">      PR_RLC    -- traced process runs when last /proc file closed.</span>
<a name="l01264"></a>01264 <span class="comment">      PR_KLC    -- traced process is killed when last /proc file closed.</span>
<a name="l01265"></a>01265 <span class="comment">      PR_ASYNC  -- LWP&#39;s get to run/stop independently.</span>
<a name="l01266"></a>01266 <span class="comment"></span>
<a name="l01267"></a>01267 <span class="comment">   There are three methods for doing this function:</span>
<a name="l01268"></a>01268 <span class="comment">   1) Newest: read/write [PCSET/PCRESET/PCUNSET]</span>
<a name="l01269"></a>01269 <span class="comment">      [Sol6, Sol7, UW]</span>
<a name="l01270"></a>01270 <span class="comment">   2) Middle: PIOCSET/PIOCRESET</span>
<a name="l01271"></a>01271 <span class="comment">      [Irix, Sol5]</span>
<a name="l01272"></a>01272 <span class="comment">   3) Oldest: PIOCSFORK/PIOCRFORK/PIOCSRLC/PIOCRRLC</span>
<a name="l01273"></a>01273 <span class="comment">      [OSF, Sol5]</span>
<a name="l01274"></a>01274 <span class="comment"></span>
<a name="l01275"></a>01275 <span class="comment">   Note: Irix does not define PR_ASYNC.</span>
<a name="l01276"></a>01276 <span class="comment">   Note: OSF  does not define PR_KLC.</span>
<a name="l01277"></a>01277 <span class="comment">   Note: OSF  is the only one that can ONLY use the oldest method.</span>
<a name="l01278"></a>01278 <span class="comment"></span>
<a name="l01279"></a>01279 <span class="comment">   Arguments:</span>
<a name="l01280"></a>01280 <span class="comment">      pi   -- the procinfo</span>
<a name="l01281"></a>01281 <span class="comment">      flag -- one of PR_FORK, PR_RLC, or PR_ASYNC</span>
<a name="l01282"></a>01282 <span class="comment">      mode -- 1 for set, 0 for reset.</span>
<a name="l01283"></a>01283 <span class="comment"></span>
<a name="l01284"></a>01284 <span class="comment">   Returns non-zero for success, zero for failure.  */</span>
<a name="l01285"></a>01285 
<a name="l01286"></a><a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dadadd120ee5969e963eb496b7a32d13e376">01286</a> <span class="keyword">enum</span> { <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dada34921dc2c1632e9847571a81ce00124c">FLAG_RESET</a>, <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dadadd120ee5969e963eb496b7a32d13e376">FLAG_SET</a> };
<a name="l01287"></a>01287 
<a name="l01288"></a>01288 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01289"></a><a class="code" href="procfs_8c.html#aae0b714031e786b2503ff283d9672a1e">01289</a> <a class="code" href="procfs_8c.html#aae0b714031e786b2503ff283d9672a1e">proc_modify_flag</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">long</span> flag, <span class="keywordtype">long</span> mode)
<a name="l01290"></a>01290 {
<a name="l01291"></a>01291   <span class="keywordtype">long</span> win = 0;         <span class="comment">/* default to fail */</span>
<a name="l01292"></a>01292 
<a name="l01293"></a>01293   <span class="comment">/* These operations affect the process as a whole, and applying them</span>
<a name="l01294"></a>01294 <span class="comment">     to an individual LWP has the same meaning as applying them to the</span>
<a name="l01295"></a>01295 <span class="comment">     main process.  Therefore, if we&#39;re ever called with a pointer to</span>
<a name="l01296"></a>01296 <span class="comment">     an LWP&#39;s procinfo, let&#39;s substitute the process&#39;s procinfo and</span>
<a name="l01297"></a>01297 <span class="comment">     avoid opening the LWP&#39;s file descriptor unnecessarily.  */</span>
<a name="l01298"></a>01298 
<a name="l01299"></a>01299   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a> != 0)
<a name="l01300"></a>01300     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l01301"></a>01301 
<a name="l01302"></a>01302 <span class="preprocessor">#ifdef NEW_PROC_API     </span><span class="comment">/* Newest method: Newer Solarii.  */</span>
<a name="l01303"></a>01303   <span class="comment">/* First normalize the PCUNSET/PCRESET command opcode</span>
<a name="l01304"></a>01304 <span class="comment">     (which for no obvious reason has a different definition</span>
<a name="l01305"></a>01305 <span class="comment">     from one operating system to the next...)  */</span>
<a name="l01306"></a>01306 <span class="preprocessor">#ifdef  PCUNSET</span>
<a name="l01307"></a>01307 <span class="preprocessor"></span><span class="preprocessor">#define GDBRESET PCUNSET</span>
<a name="l01308"></a>01308 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l01309"></a>01309 <span class="preprocessor"></span><span class="preprocessor">#ifdef  PCRESET</span>
<a name="l01310"></a>01310 <span class="preprocessor"></span><span class="preprocessor">#define GDBRESET PCRESET</span>
<a name="l01311"></a>01311 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01312"></a>01312 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01313"></a>01313 <span class="preprocessor"></span>  {
<a name="l01314"></a>01314     <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> arg[2];
<a name="l01315"></a>01315 
<a name="l01316"></a>01316     <span class="keywordflow">if</span> (mode == <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dadadd120ee5969e963eb496b7a32d13e376">FLAG_SET</a>)       <span class="comment">/* Set the flag (RLC, FORK, or ASYNC).  */</span>
<a name="l01317"></a>01317       arg[0] = PCSET;
<a name="l01318"></a>01318     <span class="keywordflow">else</span>                        <span class="comment">/* Reset the flag.  */</span>
<a name="l01319"></a>01319       arg[0] = GDBRESET;
<a name="l01320"></a>01320 
<a name="l01321"></a>01321     arg[1] = flag;
<a name="l01322"></a>01322     win = (write (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, (<span class="keywordtype">void</span> *) &amp;arg, sizeof (arg)) == <span class="keyword">sizeof</span> (arg));
<a name="l01323"></a>01323   }
<a name="l01324"></a>01324 <span class="preprocessor">#else</span>
<a name="l01325"></a>01325 <span class="preprocessor"></span><span class="preprocessor">#ifdef PIOCSET          </span><span class="comment">/* Irix/Sol5 method */</span>
<a name="l01326"></a>01326   <span class="keywordflow">if</span> (mode == <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dadadd120ee5969e963eb496b7a32d13e376">FLAG_SET</a>) <span class="comment">/* Set the flag (hopefully RLC, FORK, or ASYNC).  */</span>
<a name="l01327"></a>01327     {
<a name="l01328"></a>01328       win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSET, &amp;flag)   &gt;= 0);
<a name="l01329"></a>01329     }
<a name="l01330"></a>01330   <span class="keywordflow">else</span>                  <span class="comment">/* Reset the flag.  */</span>
<a name="l01331"></a>01331     {
<a name="l01332"></a>01332       win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCRESET, &amp;flag) &gt;= 0);
<a name="l01333"></a>01333     }
<a name="l01334"></a>01334 
<a name="l01335"></a>01335 <span class="preprocessor">#else</span>
<a name="l01336"></a>01336 <span class="preprocessor"></span><span class="preprocessor">#ifdef PIOCSRLC         </span><span class="comment">/* Oldest method: OSF */</span>
<a name="l01337"></a>01337   <span class="keywordflow">switch</span> (flag) {
<a name="l01338"></a>01338   <span class="keywordflow">case</span> PR_RLC:
<a name="l01339"></a>01339     <span class="keywordflow">if</span> (mode == <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dadadd120ee5969e963eb496b7a32d13e376">FLAG_SET</a>)       <span class="comment">/* Set run-on-last-close */</span>
<a name="l01340"></a>01340       {
<a name="l01341"></a>01341         win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSRLC, NULL) &gt;= 0);
<a name="l01342"></a>01342       }
<a name="l01343"></a>01343     <span class="keywordflow">else</span>                        <span class="comment">/* Clear run-on-last-close */</span>
<a name="l01344"></a>01344       {
<a name="l01345"></a>01345         win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCRRLC, NULL) &gt;= 0);
<a name="l01346"></a>01346       }
<a name="l01347"></a>01347     <span class="keywordflow">break</span>;
<a name="l01348"></a>01348   <span class="keywordflow">case</span> PR_FORK:
<a name="l01349"></a>01349     <span class="keywordflow">if</span> (mode == <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dadadd120ee5969e963eb496b7a32d13e376">FLAG_SET</a>)       <span class="comment">/* Set inherit-on-fork */</span>
<a name="l01350"></a>01350       {
<a name="l01351"></a>01351         win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSFORK, NULL) &gt;= 0);
<a name="l01352"></a>01352       }
<a name="l01353"></a>01353     <span class="keywordflow">else</span>                        <span class="comment">/* Clear inherit-on-fork */</span>
<a name="l01354"></a>01354       {
<a name="l01355"></a>01355         win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCRFORK, NULL) &gt;= 0);
<a name="l01356"></a>01356       }
<a name="l01357"></a>01357     <span class="keywordflow">break</span>;
<a name="l01358"></a>01358   <span class="keywordflow">default</span>:
<a name="l01359"></a>01359     win = 0;            <span class="comment">/* Fail -- unknown flag (can&#39;t do PR_ASYNC).  */</span>
<a name="l01360"></a>01360     <span class="keywordflow">break</span>;
<a name="l01361"></a>01361   }
<a name="l01362"></a>01362 <span class="preprocessor">#endif</span>
<a name="l01363"></a>01363 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01364"></a>01364 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01365"></a>01365 <span class="preprocessor"></span><span class="preprocessor">#undef GDBRESET</span>
<a name="l01366"></a>01366 <span class="preprocessor"></span>  <span class="comment">/* The above operation renders the procinfo&#39;s cached pstatus</span>
<a name="l01367"></a>01367 <span class="comment">     obsolete.  */</span>
<a name="l01368"></a>01368   pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 0;
<a name="l01369"></a>01369 
<a name="l01370"></a>01370   <span class="keywordflow">if</span> (!win)
<a name="l01371"></a>01371     <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs: modify_flag failed to turn %s %s&quot;</span>),
<a name="l01372"></a>01372              flag == PR_FORK  ? <span class="stringliteral">&quot;PR_FORK&quot;</span>  :
<a name="l01373"></a>01373              flag == PR_RLC   ? <span class="stringliteral">&quot;PR_RLC&quot;</span>   :
<a name="l01374"></a>01374 #ifdef PR_ASYNC
<a name="l01375"></a>01375              flag == PR_ASYNC ? <span class="stringliteral">&quot;PR_ASYNC&quot;</span> :
<a name="l01376"></a>01376 #endif
<a name="l01377"></a>01377 #ifdef PR_KLC
<a name="l01378"></a>01378              flag == PR_KLC   ? <span class="stringliteral">&quot;PR_KLC&quot;</span>   :
<a name="l01379"></a>01379 #endif
<a name="l01380"></a>01380              <span class="stringliteral">&quot;&lt;unknown flag&gt;&quot;</span>,
<a name="l01381"></a>01381              mode == <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dada34921dc2c1632e9847571a81ce00124c">FLAG_RESET</a> ? <span class="stringliteral">&quot;off&quot;</span> : <span class="stringliteral">&quot;on&quot;</span>);
<a name="l01382"></a>01382 
<a name="l01383"></a>01383   <span class="keywordflow">return</span> win;
<a name="l01384"></a>01384 }
<a name="l01385"></a>01385 
<a name="l01386"></a>01386 <span class="comment">/* Set the run_on_last_close flag.  Process with all threads will</span>
<a name="l01387"></a>01387 <span class="comment">   become runnable when debugger closes all /proc fds.  Returns</span>
<a name="l01388"></a>01388 <span class="comment">   non-zero for success, zero for failure.  */</span>
<a name="l01389"></a>01389 
<a name="l01390"></a>01390 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01391"></a><a class="code" href="procfs_8c.html#adc200acb760eee688f9efffce872cfe1">01391</a> <a class="code" href="procfs_8c.html#adc200acb760eee688f9efffce872cfe1">proc_set_run_on_last_close</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l01392"></a>01392 {
<a name="l01393"></a>01393   <span class="keywordflow">return</span> <a class="code" href="procfs_8c.html#aae0b714031e786b2503ff283d9672a1e">proc_modify_flag</a> (pi, PR_RLC, <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dadadd120ee5969e963eb496b7a32d13e376">FLAG_SET</a>);
<a name="l01394"></a>01394 }
<a name="l01395"></a>01395 
<a name="l01396"></a>01396 <span class="comment">/* Reset the run_on_last_close flag.  The process will NOT become</span>
<a name="l01397"></a>01397 <span class="comment">   runnable when debugger closes its file handles.  Returns non-zero</span>
<a name="l01398"></a>01398 <span class="comment">   for success, zero for failure.  */</span>
<a name="l01399"></a>01399 
<a name="l01400"></a>01400 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01401"></a><a class="code" href="procfs_8c.html#aa77e25cc788690550931b8a8b0a26aab">01401</a> <a class="code" href="procfs_8c.html#aa77e25cc788690550931b8a8b0a26aab">proc_unset_run_on_last_close</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l01402"></a>01402 {
<a name="l01403"></a>01403   <span class="keywordflow">return</span> <a class="code" href="procfs_8c.html#aae0b714031e786b2503ff283d9672a1e">proc_modify_flag</a> (pi, PR_RLC, <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dada34921dc2c1632e9847571a81ce00124c">FLAG_RESET</a>);
<a name="l01404"></a>01404 }
<a name="l01405"></a>01405 
<a name="l01406"></a>01406 <span class="comment">/* Reset inherit_on_fork flag.  If the process forks a child while we</span>
<a name="l01407"></a>01407 <span class="comment">   are registered for events in the parent, then we will NOT recieve</span>
<a name="l01408"></a>01408 <span class="comment">   events from the child.  Returns non-zero for success, zero for</span>
<a name="l01409"></a>01409 <span class="comment">   failure.  */</span>
<a name="l01410"></a>01410 
<a name="l01411"></a>01411 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01412"></a><a class="code" href="procfs_8c.html#ab1738fc6f50141fc293139c7a0a2996a">01412</a> <a class="code" href="procfs_8c.html#ab1738fc6f50141fc293139c7a0a2996a">proc_unset_inherit_on_fork</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l01413"></a>01413 {
<a name="l01414"></a>01414   <span class="keywordflow">return</span> <a class="code" href="procfs_8c.html#aae0b714031e786b2503ff283d9672a1e">proc_modify_flag</a> (pi, PR_FORK, <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dada34921dc2c1632e9847571a81ce00124c">FLAG_RESET</a>);
<a name="l01415"></a>01415 }
<a name="l01416"></a>01416 
<a name="l01417"></a>01417 <span class="preprocessor">#ifdef PR_ASYNC</span>
<a name="l01418"></a>01418 <span class="preprocessor"></span><span class="comment">/* Set PR_ASYNC flag.  If one LWP stops because of a debug event</span>
<a name="l01419"></a>01419 <span class="comment">   (signal etc.), the remaining LWPs will continue to run.  Returns</span>
<a name="l01420"></a>01420 <span class="comment">   non-zero for success, zero for failure.  */</span>
<a name="l01421"></a>01421 
<a name="l01422"></a>01422 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01423"></a>01423 proc_set_async (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l01424"></a>01424 {
<a name="l01425"></a>01425   <span class="keywordflow">return</span> <a class="code" href="procfs_8c.html#aae0b714031e786b2503ff283d9672a1e">proc_modify_flag</a> (pi, PR_ASYNC, <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dadadd120ee5969e963eb496b7a32d13e376">FLAG_SET</a>);
<a name="l01426"></a>01426 }
<a name="l01427"></a>01427 
<a name="l01428"></a>01428 <span class="comment">/* Reset PR_ASYNC flag.  If one LWP stops because of a debug event</span>
<a name="l01429"></a>01429 <span class="comment">   (signal etc.), then all other LWPs will stop as well.  Returns</span>
<a name="l01430"></a>01430 <span class="comment">   non-zero for success, zero for failure.  */</span>
<a name="l01431"></a>01431 
<a name="l01432"></a>01432 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01433"></a>01433 proc_unset_async (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l01434"></a>01434 {
<a name="l01435"></a>01435   <span class="keywordflow">return</span> <a class="code" href="procfs_8c.html#aae0b714031e786b2503ff283d9672a1e">proc_modify_flag</a> (pi, PR_ASYNC, <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dada34921dc2c1632e9847571a81ce00124c">FLAG_RESET</a>);
<a name="l01436"></a>01436 }
<a name="l01437"></a>01437 <span class="preprocessor">#endif </span><span class="comment">/* PR_ASYNC */</span>
<a name="l01438"></a>01438 
<a name="l01439"></a>01439 <span class="comment">/* Request the process/LWP to stop.  Does not wait.  Returns non-zero</span>
<a name="l01440"></a>01440 <span class="comment">   for success, zero for failure.  */</span>
<a name="l01441"></a>01441 
<a name="l01442"></a>01442 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01443"></a><a class="code" href="procfs_8c.html#a7dd9898eb050acf3e17c9436dcb4cc66">01443</a> <a class="code" href="procfs_8c.html#a7dd9898eb050acf3e17c9436dcb4cc66">proc_stop_process</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l01444"></a>01444 {
<a name="l01445"></a>01445   <span class="keywordtype">int</span> win;
<a name="l01446"></a>01446 
<a name="l01447"></a>01447   <span class="comment">/* We might conceivably apply this operation to an LWP, and the</span>
<a name="l01448"></a>01448 <span class="comment">     LWP&#39;s ctl file descriptor might not be open.  */</span>
<a name="l01449"></a>01449 
<a name="l01450"></a>01450   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a> == 0 &amp;&amp;
<a name="l01451"></a>01451       <a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (pi, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca242b7fbe149191cf293910e1f2f65bd6">FD_CTL</a>) == 0)
<a name="l01452"></a>01452     <span class="keywordflow">return</span> 0;
<a name="l01453"></a>01453   <span class="keywordflow">else</span>
<a name="l01454"></a>01454     {
<a name="l01455"></a>01455 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01456"></a>01456 <span class="preprocessor"></span>      <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd = PCSTOP;
<a name="l01457"></a>01457 
<a name="l01458"></a>01458       win = (write (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, (<span class="keywordtype">char</span> *) &amp;cmd, sizeof (cmd)) == <span class="keyword">sizeof</span> (cmd));
<a name="l01459"></a>01459 <span class="preprocessor">#else   </span><span class="comment">/* ioctl method */</span>
<a name="l01460"></a>01460       win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSTOP, &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>) &gt;= 0);
<a name="l01461"></a>01461       <span class="comment">/* Note: the call also reads the prstatus.  */</span>
<a name="l01462"></a>01462       <span class="keywordflow">if</span> (win)
<a name="l01463"></a>01463         {
<a name="l01464"></a>01464           pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 1;
<a name="l01465"></a>01465           <a class="code" href="proc-utils_8h.html#aa775a2a305216480d1e937964905083f">PROC_PRETTYFPRINT_STATUS</a> (<a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (pi),
<a name="l01466"></a>01466                                     <a class="code" href="procfs_8c.html#af1d2febb017ce0acde9f56bbfcbfde9e">proc_why</a> (pi),
<a name="l01467"></a>01467                                     <a class="code" href="procfs_8c.html#a8f54b931ed7656bcce6696ea27b8b3c3">proc_what</a> (pi),
<a name="l01468"></a>01468                                     <a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">proc_get_current_thread</a> (pi));
<a name="l01469"></a>01469         }
<a name="l01470"></a>01470 <span class="preprocessor">#endif</span>
<a name="l01471"></a>01471 <span class="preprocessor"></span>    }
<a name="l01472"></a>01472 
<a name="l01473"></a>01473   <span class="keywordflow">return</span> win;
<a name="l01474"></a>01474 }
<a name="l01475"></a>01475 
<a name="l01476"></a>01476 <span class="comment">/* Wait for the process or LWP to stop (block until it does).  Returns</span>
<a name="l01477"></a>01477 <span class="comment">   non-zero for success, zero for failure.  */</span>
<a name="l01478"></a>01478 
<a name="l01479"></a>01479 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01480"></a><a class="code" href="procfs_8c.html#ac6105e9b1d932acc33f65ca921e8d1cb">01480</a> <a class="code" href="procfs_8c.html#ac6105e9b1d932acc33f65ca921e8d1cb">proc_wait_for_stop</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l01481"></a>01481 {
<a name="l01482"></a>01482   <span class="keywordtype">int</span> win;
<a name="l01483"></a>01483 
<a name="l01484"></a>01484   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l01485"></a>01485 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l01486"></a>01486 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l01487"></a>01487 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l01488"></a>01488 
<a name="l01489"></a>01489   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l01490"></a>01490     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l01491"></a>01491 
<a name="l01492"></a>01492 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01493"></a>01493 <span class="preprocessor"></span>  {
<a name="l01494"></a>01494     <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd = PCWSTOP;
<a name="l01495"></a>01495 
<a name="l01496"></a>01496     win = (write (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, (<span class="keywordtype">char</span> *) &amp;cmd, sizeof (cmd)) == <span class="keyword">sizeof</span> (cmd));
<a name="l01497"></a>01497     <span class="comment">/* We been runnin&#39; and we stopped -- need to update status.  */</span>
<a name="l01498"></a>01498     pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 0;
<a name="l01499"></a>01499   }
<a name="l01500"></a>01500 <span class="preprocessor">#else   </span><span class="comment">/* ioctl method */</span>
<a name="l01501"></a>01501   win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCWSTOP, &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>) &gt;= 0);
<a name="l01502"></a>01502   <span class="comment">/* Above call also refreshes the prstatus.  */</span>
<a name="l01503"></a>01503   <span class="keywordflow">if</span> (win)
<a name="l01504"></a>01504     {
<a name="l01505"></a>01505       pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 1;
<a name="l01506"></a>01506       <a class="code" href="proc-utils_8h.html#aa775a2a305216480d1e937964905083f">PROC_PRETTYFPRINT_STATUS</a> (<a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (pi),
<a name="l01507"></a>01507                                 <a class="code" href="procfs_8c.html#af1d2febb017ce0acde9f56bbfcbfde9e">proc_why</a> (pi),
<a name="l01508"></a>01508                                 <a class="code" href="procfs_8c.html#a8f54b931ed7656bcce6696ea27b8b3c3">proc_what</a> (pi),
<a name="l01509"></a>01509                                 <a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">proc_get_current_thread</a> (pi));
<a name="l01510"></a>01510     }
<a name="l01511"></a>01511 <span class="preprocessor">#endif</span>
<a name="l01512"></a>01512 <span class="preprocessor"></span>
<a name="l01513"></a>01513   <span class="keywordflow">return</span> win;
<a name="l01514"></a>01514 }
<a name="l01515"></a>01515 
<a name="l01516"></a>01516 <span class="comment">/* Make the process or LWP runnable.</span>
<a name="l01517"></a>01517 <span class="comment"></span>
<a name="l01518"></a>01518 <span class="comment">   Options (not all are implemented):</span>
<a name="l01519"></a>01519 <span class="comment">     - single-step</span>
<a name="l01520"></a>01520 <span class="comment">     - clear current fault</span>
<a name="l01521"></a>01521 <span class="comment">     - clear current signal</span>
<a name="l01522"></a>01522 <span class="comment">     - abort the current system call</span>
<a name="l01523"></a>01523 <span class="comment">     - stop as soon as finished with system call</span>
<a name="l01524"></a>01524 <span class="comment">     - (ioctl): set traced signal set</span>
<a name="l01525"></a>01525 <span class="comment">     - (ioctl): set held   signal set</span>
<a name="l01526"></a>01526 <span class="comment">     - (ioctl): set traced fault  set</span>
<a name="l01527"></a>01527 <span class="comment">     - (ioctl): set start pc (vaddr)</span>
<a name="l01528"></a>01528 <span class="comment"></span>
<a name="l01529"></a>01529 <span class="comment">   Always clears the current fault.  PI is the process or LWP to</span>
<a name="l01530"></a>01530 <span class="comment">   operate on.  If STEP is true, set the process or LWP to trap after</span>
<a name="l01531"></a>01531 <span class="comment">   one instruction.  If SIGNO is zero, clear the current signal if</span>
<a name="l01532"></a>01532 <span class="comment">   any; if non-zero, set the current signal to this one.  Returns</span>
<a name="l01533"></a>01533 <span class="comment">   non-zero for success, zero for failure.  */</span>
<a name="l01534"></a>01534 
<a name="l01535"></a>01535 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01536"></a><a class="code" href="procfs_8c.html#ad2d6284c468ce487d8a75149b4dd2c07">01536</a> <a class="code" href="procfs_8c.html#ad2d6284c468ce487d8a75149b4dd2c07">proc_run_process</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">int</span> step, <span class="keywordtype">int</span> signo)
<a name="l01537"></a>01537 {
<a name="l01538"></a>01538   <span class="keywordtype">int</span> win;
<a name="l01539"></a>01539   <span class="keywordtype">int</span> runflags;
<a name="l01540"></a>01540 
<a name="l01541"></a>01541   <span class="comment">/* We will probably have to apply this operation to individual</span>
<a name="l01542"></a>01542 <span class="comment">     threads, so make sure the control file descriptor is open.  */</span>
<a name="l01543"></a>01543 
<a name="l01544"></a>01544   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a> == 0 &amp;&amp;
<a name="l01545"></a>01545       <a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (pi, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca242b7fbe149191cf293910e1f2f65bd6">FD_CTL</a>) == 0)
<a name="l01546"></a>01546     {
<a name="l01547"></a>01547       <span class="keywordflow">return</span> 0;
<a name="l01548"></a>01548     }
<a name="l01549"></a>01549 
<a name="l01550"></a>01550   runflags    = PRCFAULT;       <span class="comment">/* Always clear current fault.  */</span>
<a name="l01551"></a>01551   <span class="keywordflow">if</span> (step)
<a name="l01552"></a>01552     runflags |= PRSTEP;
<a name="l01553"></a>01553   <span class="keywordflow">if</span> (signo == 0)
<a name="l01554"></a>01554     runflags |= PRCSIG;
<a name="l01555"></a>01555   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (signo != -1)         <span class="comment">/* -1 means do nothing W.R.T. signals.  */</span>
<a name="l01556"></a>01556     <a class="code" href="procfs_8c.html#ad042ba71cbc842f0407b54cfe972fb19">proc_set_current_signal</a> (pi, signo);
<a name="l01557"></a>01557 
<a name="l01558"></a>01558 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01559"></a>01559 <span class="preprocessor"></span>  {
<a name="l01560"></a>01560     <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd[2];
<a name="l01561"></a>01561 
<a name="l01562"></a>01562     cmd[0]  = PCRUN;
<a name="l01563"></a>01563     cmd[1]  = runflags;
<a name="l01564"></a>01564     win = (write (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, (<span class="keywordtype">char</span> *) &amp;cmd, sizeof (cmd)) == <span class="keyword">sizeof</span> (cmd));
<a name="l01565"></a>01565   }
<a name="l01566"></a>01566 <span class="preprocessor">#else   </span><span class="comment">/* ioctl method */</span>
<a name="l01567"></a>01567   {
<a name="l01568"></a>01568     prrun_t prrun;
<a name="l01569"></a>01569 
<a name="l01570"></a>01570     <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;prrun, 0, <span class="keyword">sizeof</span> (prrun));
<a name="l01571"></a>01571     prrun.pr_flags  = runflags;
<a name="l01572"></a>01572     win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCRUN, &amp;prrun) &gt;= 0);
<a name="l01573"></a>01573   }
<a name="l01574"></a>01574 <span class="preprocessor">#endif</span>
<a name="l01575"></a>01575 <span class="preprocessor"></span>
<a name="l01576"></a>01576   <span class="keywordflow">return</span> win;
<a name="l01577"></a>01577 }
<a name="l01578"></a>01578 
<a name="l01579"></a>01579 <span class="comment">/* Register to trace signals in the process or LWP.  Returns non-zero</span>
<a name="l01580"></a>01580 <span class="comment">   for success, zero for failure.  */</span>
<a name="l01581"></a>01581 
<a name="l01582"></a>01582 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01583"></a><a class="code" href="procfs_8c.html#af04151458bd3246bc210bc06eae93f66">01583</a> <a class="code" href="procfs_8c.html#af04151458bd3246bc210bc06eae93f66">proc_set_traced_signals</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, gdb_sigset_t *sigset)
<a name="l01584"></a>01584 {
<a name="l01585"></a>01585   <span class="keywordtype">int</span> win;
<a name="l01586"></a>01586 
<a name="l01587"></a>01587   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l01588"></a>01588 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l01589"></a>01589 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l01590"></a>01590 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l01591"></a>01591 
<a name="l01592"></a>01592   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l01593"></a>01593     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l01594"></a>01594 
<a name="l01595"></a>01595 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01596"></a>01596 <span class="preprocessor"></span>  {
<a name="l01597"></a>01597     <span class="keyword">struct </span>{
<a name="l01598"></a>01598       <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd;
<a name="l01599"></a>01599       <span class="comment">/* Use char array to avoid alignment issues.  */</span>
<a name="l01600"></a>01600       <span class="keywordtype">char</span> sigset[<span class="keyword">sizeof</span> (<a class="code" href="procfs_8c.html#a56b2350f878be186aca0fe5bb960d6d4">gdb_sigset_t</a>)];
<a name="l01601"></a>01601     } arg;
<a name="l01602"></a>01602 
<a name="l01603"></a>01603     arg.cmd = PCSTRACE;
<a name="l01604"></a>01604     <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (&amp;arg.sigset, sigset, sizeof (gdb_sigset_t));
<a name="l01605"></a>01605 
<a name="l01606"></a>01606     win = (write (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, (<span class="keywordtype">char</span> *) &amp;arg, sizeof (arg)) == <span class="keyword">sizeof</span> (arg));
<a name="l01607"></a>01607   }
<a name="l01608"></a>01608 <span class="preprocessor">#else   </span><span class="comment">/* ioctl method */</span>
<a name="l01609"></a>01609   win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSTRACE, sigset) &gt;= 0);
<a name="l01610"></a>01610 <span class="preprocessor">#endif</span>
<a name="l01611"></a>01611 <span class="preprocessor"></span>  <span class="comment">/* The above operation renders the procinfo&#39;s cached pstatus obsolete.  */</span>
<a name="l01612"></a>01612   pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 0;
<a name="l01613"></a>01613 
<a name="l01614"></a>01614   <span class="keywordflow">if</span> (!win)
<a name="l01615"></a>01615     <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs: set_traced_signals failed&quot;</span>));
<a name="l01616"></a>01616   <span class="keywordflow">return</span> win;
<a name="l01617"></a>01617 }
<a name="l01618"></a>01618 
<a name="l01619"></a>01619 <span class="comment">/* Register to trace hardware faults in the process or LWP.  Returns</span>
<a name="l01620"></a>01620 <span class="comment">   non-zero for success, zero for failure.  */</span>
<a name="l01621"></a>01621 
<a name="l01622"></a>01622 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01623"></a><a class="code" href="procfs_8c.html#af0ddd9f46992fe62b051be4c4f014bc3">01623</a> <a class="code" href="procfs_8c.html#af0ddd9f46992fe62b051be4c4f014bc3">proc_set_traced_faults</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, fltset_t *fltset)
<a name="l01624"></a>01624 {
<a name="l01625"></a>01625   <span class="keywordtype">int</span> win;
<a name="l01626"></a>01626 
<a name="l01627"></a>01627   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l01628"></a>01628 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l01629"></a>01629 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l01630"></a>01630 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l01631"></a>01631 
<a name="l01632"></a>01632   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l01633"></a>01633     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l01634"></a>01634 
<a name="l01635"></a>01635 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01636"></a>01636 <span class="preprocessor"></span>  {
<a name="l01637"></a>01637     <span class="keyword">struct </span>{
<a name="l01638"></a>01638       <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd;
<a name="l01639"></a>01639       <span class="comment">/* Use char array to avoid alignment issues.  */</span>
<a name="l01640"></a>01640       <span class="keywordtype">char</span> fltset[<span class="keyword">sizeof</span> (fltset_t)];
<a name="l01641"></a>01641     } arg;
<a name="l01642"></a>01642 
<a name="l01643"></a>01643     arg.cmd = PCSFAULT;
<a name="l01644"></a>01644     <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (&amp;arg.fltset, fltset, sizeof (fltset_t));
<a name="l01645"></a>01645 
<a name="l01646"></a>01646     win = (write (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, (<span class="keywordtype">char</span> *) &amp;arg, sizeof (arg)) == <span class="keyword">sizeof</span> (arg));
<a name="l01647"></a>01647   }
<a name="l01648"></a>01648 <span class="preprocessor">#else   </span><span class="comment">/* ioctl method */</span>
<a name="l01649"></a>01649   win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSFAULT, fltset) &gt;= 0);
<a name="l01650"></a>01650 <span class="preprocessor">#endif</span>
<a name="l01651"></a>01651 <span class="preprocessor"></span>  <span class="comment">/* The above operation renders the procinfo&#39;s cached pstatus obsolete.  */</span>
<a name="l01652"></a>01652   pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 0;
<a name="l01653"></a>01653 
<a name="l01654"></a>01654   <span class="keywordflow">return</span> win;
<a name="l01655"></a>01655 }
<a name="l01656"></a>01656 
<a name="l01657"></a>01657 <span class="comment">/* Register to trace entry to system calls in the process or LWP.</span>
<a name="l01658"></a>01658 <span class="comment">   Returns non-zero for success, zero for failure.  */</span>
<a name="l01659"></a>01659 
<a name="l01660"></a>01660 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01661"></a><a class="code" href="procfs_8c.html#a84e53147df27900c8c107d200c34b795">01661</a> <a class="code" href="procfs_8c.html#a84e53147df27900c8c107d200c34b795">proc_set_traced_sysentry</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, sysset_t *sysset)
<a name="l01662"></a>01662 {
<a name="l01663"></a>01663   <span class="keywordtype">int</span> win;
<a name="l01664"></a>01664 
<a name="l01665"></a>01665   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l01666"></a>01666 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l01667"></a>01667 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l01668"></a>01668 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l01669"></a>01669 
<a name="l01670"></a>01670   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l01671"></a>01671     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l01672"></a>01672 
<a name="l01673"></a>01673 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01674"></a>01674 <span class="preprocessor"></span>  {
<a name="l01675"></a>01675     <span class="keyword">struct </span>gdb_proc_ctl_pcsentry {
<a name="l01676"></a>01676       <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd;
<a name="l01677"></a>01677       <span class="comment">/* Use char array to avoid alignment issues.  */</span>
<a name="l01678"></a>01678       <span class="keywordtype">char</span> sysset[<span class="keyword">sizeof</span> (sysset_t)];
<a name="l01679"></a>01679     } *argp;
<a name="l01680"></a>01680     <span class="keywordtype">int</span> argp_size = <span class="keyword">sizeof</span> (<span class="keyword">struct </span>gdb_proc_ctl_pcsentry)
<a name="l01681"></a>01681                   - sizeof (sysset_t)
<a name="l01682"></a>01682                   + sysset_t_size (pi);
<a name="l01683"></a>01683 
<a name="l01684"></a>01684     argp = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (argp_size);
<a name="l01685"></a>01685 
<a name="l01686"></a>01686     argp-&gt;cmd = PCSENTRY;
<a name="l01687"></a>01687     <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (&amp;argp-&gt;sysset, sysset, sysset_t_size (pi));
<a name="l01688"></a>01688 
<a name="l01689"></a>01689     win = (write (pi-&gt;ctl_fd, (<span class="keywordtype">char</span> *) argp, argp_size) == argp_size);
<a name="l01690"></a>01690     <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (argp);
<a name="l01691"></a>01691   }
<a name="l01692"></a>01692 <span class="preprocessor">#else   </span><span class="comment">/* ioctl method */</span>
<a name="l01693"></a>01693   win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSENTRY, sysset) &gt;= 0);
<a name="l01694"></a>01694 <span class="preprocessor">#endif</span>
<a name="l01695"></a>01695 <span class="preprocessor"></span>  <span class="comment">/* The above operation renders the procinfo&#39;s cached pstatus</span>
<a name="l01696"></a>01696 <span class="comment">     obsolete.  */</span>
<a name="l01697"></a>01697   pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 0;
<a name="l01698"></a>01698 
<a name="l01699"></a>01699   <span class="keywordflow">return</span> win;
<a name="l01700"></a>01700 }
<a name="l01701"></a>01701 
<a name="l01702"></a>01702 <span class="comment">/* Register to trace exit from system calls in the process or LWP.</span>
<a name="l01703"></a>01703 <span class="comment">   Returns non-zero for success, zero for failure.  */</span>
<a name="l01704"></a>01704 
<a name="l01705"></a>01705 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01706"></a><a class="code" href="procfs_8c.html#a33c100a98eea13970f4ac33a7e9af14f">01706</a> <a class="code" href="procfs_8c.html#a33c100a98eea13970f4ac33a7e9af14f">proc_set_traced_sysexit</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, sysset_t *sysset)
<a name="l01707"></a>01707 {
<a name="l01708"></a>01708   <span class="keywordtype">int</span> win;
<a name="l01709"></a>01709 
<a name="l01710"></a>01710   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l01711"></a>01711 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l01712"></a>01712 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l01713"></a>01713 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l01714"></a>01714 
<a name="l01715"></a>01715   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l01716"></a>01716     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l01717"></a>01717 
<a name="l01718"></a>01718 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01719"></a>01719 <span class="preprocessor"></span>  {
<a name="l01720"></a>01720     <span class="keyword">struct </span>gdb_proc_ctl_pcsexit {
<a name="l01721"></a>01721       <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd;
<a name="l01722"></a>01722       <span class="comment">/* Use char array to avoid alignment issues.  */</span>
<a name="l01723"></a>01723       <span class="keywordtype">char</span> sysset[<span class="keyword">sizeof</span> (sysset_t)];
<a name="l01724"></a>01724     } *argp;
<a name="l01725"></a>01725     <span class="keywordtype">int</span> argp_size = <span class="keyword">sizeof</span> (<span class="keyword">struct </span>gdb_proc_ctl_pcsexit)
<a name="l01726"></a>01726                   - sizeof (sysset_t)
<a name="l01727"></a>01727                   + sysset_t_size (pi);
<a name="l01728"></a>01728 
<a name="l01729"></a>01729     argp = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (argp_size);
<a name="l01730"></a>01730 
<a name="l01731"></a>01731     argp-&gt;cmd = PCSEXIT;
<a name="l01732"></a>01732     <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (&amp;argp-&gt;sysset, sysset, sysset_t_size (pi));
<a name="l01733"></a>01733 
<a name="l01734"></a>01734     win = (write (pi-&gt;ctl_fd, (<span class="keywordtype">char</span> *) argp, argp_size) == argp_size);
<a name="l01735"></a>01735     <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (argp);
<a name="l01736"></a>01736   }
<a name="l01737"></a>01737 <span class="preprocessor">#else   </span><span class="comment">/* ioctl method */</span>
<a name="l01738"></a>01738   win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSEXIT, sysset) &gt;= 0);
<a name="l01739"></a>01739 <span class="preprocessor">#endif</span>
<a name="l01740"></a>01740 <span class="preprocessor"></span>  <span class="comment">/* The above operation renders the procinfo&#39;s cached pstatus</span>
<a name="l01741"></a>01741 <span class="comment">     obsolete.  */</span>
<a name="l01742"></a>01742   pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 0;
<a name="l01743"></a>01743 
<a name="l01744"></a>01744   <span class="keywordflow">return</span> win;
<a name="l01745"></a>01745 }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747 <span class="comment">/* Specify the set of blocked / held signals in the process or LWP.</span>
<a name="l01748"></a>01748 <span class="comment">   Returns non-zero for success, zero for failure.  */</span>
<a name="l01749"></a>01749 
<a name="l01750"></a>01750 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01751"></a><a class="code" href="procfs_8c.html#a7d94f41f793319ce6745ed55b76664a8">01751</a> <a class="code" href="procfs_8c.html#a7d94f41f793319ce6745ed55b76664a8">proc_set_held_signals</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, gdb_sigset_t *sighold)
<a name="l01752"></a>01752 {
<a name="l01753"></a>01753   <span class="keywordtype">int</span> win;
<a name="l01754"></a>01754 
<a name="l01755"></a>01755   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l01756"></a>01756 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l01757"></a>01757 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l01758"></a>01758 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l01759"></a>01759 
<a name="l01760"></a>01760   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l01761"></a>01761     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l01762"></a>01762 
<a name="l01763"></a>01763 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01764"></a>01764 <span class="preprocessor"></span>  {
<a name="l01765"></a>01765     <span class="keyword">struct </span>{
<a name="l01766"></a>01766       <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd;
<a name="l01767"></a>01767       <span class="comment">/* Use char array to avoid alignment issues.  */</span>
<a name="l01768"></a>01768       <span class="keywordtype">char</span> hold[<span class="keyword">sizeof</span> (<a class="code" href="procfs_8c.html#a56b2350f878be186aca0fe5bb960d6d4">gdb_sigset_t</a>)];
<a name="l01769"></a>01769     } arg;
<a name="l01770"></a>01770 
<a name="l01771"></a>01771     arg.cmd  = PCSHOLD;
<a name="l01772"></a>01772     <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (&amp;arg.hold, sighold, sizeof (gdb_sigset_t));
<a name="l01773"></a>01773     win = (write (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, (<span class="keywordtype">void</span> *) &amp;arg, sizeof (arg)) == <span class="keyword">sizeof</span> (arg));
<a name="l01774"></a>01774   }
<a name="l01775"></a>01775 <span class="preprocessor">#else</span>
<a name="l01776"></a>01776 <span class="preprocessor"></span>  win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSHOLD, sighold) &gt;= 0);
<a name="l01777"></a>01777 <span class="preprocessor">#endif</span>
<a name="l01778"></a>01778 <span class="preprocessor"></span>  <span class="comment">/* The above operation renders the procinfo&#39;s cached pstatus</span>
<a name="l01779"></a>01779 <span class="comment">     obsolete.  */</span>
<a name="l01780"></a>01780   pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 0;
<a name="l01781"></a>01781 
<a name="l01782"></a>01782   <span class="keywordflow">return</span> win;
<a name="l01783"></a>01783 }
<a name="l01784"></a>01784 
<a name="l01785"></a>01785 <span class="comment">/* Returns the set of signals that are held / blocked.  Will also copy</span>
<a name="l01786"></a>01786 <span class="comment">   the sigset if SAVE is non-zero.  */</span>
<a name="l01787"></a>01787 
<a name="l01788"></a>01788 <span class="keyword">static</span> gdb_sigset_t *
<a name="l01789"></a><a class="code" href="procfs_8c.html#a46d2e8aed15e86c7026a4b41ac4f025d">01789</a> <a class="code" href="procfs_8c.html#a46d2e8aed15e86c7026a4b41ac4f025d">proc_get_held_signals</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, gdb_sigset_t *<a class="code" href="namespaceSession.html#a760bd9a972f5c93149918376625ad07f">save</a>)
<a name="l01790"></a>01790 {
<a name="l01791"></a>01791   gdb_sigset_t *ret = NULL;
<a name="l01792"></a>01792 
<a name="l01793"></a>01793   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l01794"></a>01794 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l01795"></a>01795 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l01796"></a>01796 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l01797"></a>01797 
<a name="l01798"></a>01798   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l01799"></a>01799     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l01800"></a>01800 
<a name="l01801"></a>01801 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01802"></a>01802 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l01803"></a>01803     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l01804"></a>01804       <span class="keywordflow">return</span> NULL;
<a name="l01805"></a>01805 
<a name="l01806"></a>01806   ret = &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_lwp.pr_lwphold;
<a name="l01807"></a>01807 <span class="preprocessor">#else  </span><span class="comment">/* not NEW_PROC_API */</span>
<a name="l01808"></a>01808   {
<a name="l01809"></a>01809     <span class="keyword">static</span> gdb_sigset_t sigheld;
<a name="l01810"></a>01810 
<a name="l01811"></a>01811     <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCGHOLD, &amp;sigheld) &gt;= 0)
<a name="l01812"></a>01812       ret = &amp;sigheld;
<a name="l01813"></a>01813   }
<a name="l01814"></a>01814 <span class="preprocessor">#endif </span><span class="comment">/* NEW_PROC_API */</span>
<a name="l01815"></a>01815   <span class="keywordflow">if</span> (save &amp;&amp; ret)
<a name="l01816"></a>01816     <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (save, ret, <span class="keyword">sizeof</span> (gdb_sigset_t));
<a name="l01817"></a>01817 
<a name="l01818"></a>01818   <span class="keywordflow">return</span> ret;
<a name="l01819"></a>01819 }
<a name="l01820"></a>01820 
<a name="l01821"></a>01821 <span class="comment">/* Returns the set of signals that are traced / debugged.  Will also</span>
<a name="l01822"></a>01822 <span class="comment">   copy the sigset if SAVE is non-zero.  */</span>
<a name="l01823"></a>01823 
<a name="l01824"></a>01824 <span class="keyword">static</span> gdb_sigset_t *
<a name="l01825"></a><a class="code" href="procfs_8c.html#a5b69e531d7ab6145e6a1d32487707a47">01825</a> <a class="code" href="procfs_8c.html#a5b69e531d7ab6145e6a1d32487707a47">proc_get_traced_signals</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, gdb_sigset_t *<a class="code" href="namespaceSession.html#a760bd9a972f5c93149918376625ad07f">save</a>)
<a name="l01826"></a>01826 {
<a name="l01827"></a>01827   gdb_sigset_t *ret = NULL;
<a name="l01828"></a>01828 
<a name="l01829"></a>01829   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l01830"></a>01830 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l01831"></a>01831 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l01832"></a>01832 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l01833"></a>01833 
<a name="l01834"></a>01834   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l01835"></a>01835     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l01836"></a>01836 
<a name="l01837"></a>01837 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01838"></a>01838 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l01839"></a>01839     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l01840"></a>01840       <span class="keywordflow">return</span> NULL;
<a name="l01841"></a>01841 
<a name="l01842"></a>01842   ret = &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_sigtrace;
<a name="l01843"></a>01843 <span class="preprocessor">#else</span>
<a name="l01844"></a>01844 <span class="preprocessor"></span>  {
<a name="l01845"></a>01845     <span class="keyword">static</span> gdb_sigset_t sigtrace;
<a name="l01846"></a>01846 
<a name="l01847"></a>01847     <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCGTRACE, &amp;sigtrace) &gt;= 0)
<a name="l01848"></a>01848       ret = &amp;sigtrace;
<a name="l01849"></a>01849   }
<a name="l01850"></a>01850 <span class="preprocessor">#endif</span>
<a name="l01851"></a>01851 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (save &amp;&amp; ret)
<a name="l01852"></a>01852     <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (save, ret, <span class="keyword">sizeof</span> (gdb_sigset_t));
<a name="l01853"></a>01853 
<a name="l01854"></a>01854   <span class="keywordflow">return</span> ret;
<a name="l01855"></a>01855 }
<a name="l01856"></a>01856 
<a name="l01857"></a>01857 <span class="comment">/* Returns the set of hardware faults that are traced /debugged.  Will</span>
<a name="l01858"></a>01858 <span class="comment">   also copy the faultset if SAVE is non-zero.  */</span>
<a name="l01859"></a>01859 
<a name="l01860"></a>01860 <span class="keyword">static</span> fltset_t *
<a name="l01861"></a><a class="code" href="procfs_8c.html#a97bc5054c707856cb46f4e7272ae8817">01861</a> <a class="code" href="procfs_8c.html#a97bc5054c707856cb46f4e7272ae8817">proc_get_traced_faults</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, fltset_t *<a class="code" href="namespaceSession.html#a760bd9a972f5c93149918376625ad07f">save</a>)
<a name="l01862"></a>01862 {
<a name="l01863"></a>01863   fltset_t *ret = NULL;
<a name="l01864"></a>01864 
<a name="l01865"></a>01865   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l01866"></a>01866 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l01867"></a>01867 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l01868"></a>01868 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l01869"></a>01869 
<a name="l01870"></a>01870   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l01871"></a>01871     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l01872"></a>01872 
<a name="l01873"></a>01873 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01874"></a>01874 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l01875"></a>01875     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l01876"></a>01876       <span class="keywordflow">return</span> NULL;
<a name="l01877"></a>01877 
<a name="l01878"></a>01878   ret = &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_flttrace;
<a name="l01879"></a>01879 <span class="preprocessor">#else</span>
<a name="l01880"></a>01880 <span class="preprocessor"></span>  {
<a name="l01881"></a>01881     <span class="keyword">static</span> fltset_t flttrace;
<a name="l01882"></a>01882 
<a name="l01883"></a>01883     <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCGFAULT, &amp;flttrace) &gt;= 0)
<a name="l01884"></a>01884       ret = &amp;flttrace;
<a name="l01885"></a>01885   }
<a name="l01886"></a>01886 <span class="preprocessor">#endif</span>
<a name="l01887"></a>01887 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (save &amp;&amp; ret)
<a name="l01888"></a>01888     <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (save, ret, <span class="keyword">sizeof</span> (fltset_t));
<a name="l01889"></a>01889 
<a name="l01890"></a>01890   <span class="keywordflow">return</span> ret;
<a name="l01891"></a>01891 }
<a name="l01892"></a>01892 
<a name="l01893"></a>01893 <span class="comment">/* Returns the set of syscalls that are traced /debugged on entry.</span>
<a name="l01894"></a>01894 <span class="comment">   Will also copy the syscall set if SAVE is non-zero.  */</span>
<a name="l01895"></a>01895 
<a name="l01896"></a>01896 <span class="keyword">static</span> sysset_t *
<a name="l01897"></a><a class="code" href="procfs_8c.html#a383f37198255501af0d2097360b52063">01897</a> <a class="code" href="procfs_8c.html#a383f37198255501af0d2097360b52063">proc_get_traced_sysentry</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, sysset_t *<a class="code" href="namespaceSession.html#a760bd9a972f5c93149918376625ad07f">save</a>)
<a name="l01898"></a>01898 {
<a name="l01899"></a>01899   sysset_t *ret = NULL;
<a name="l01900"></a>01900 
<a name="l01901"></a>01901   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l01902"></a>01902 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l01903"></a>01903 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l01904"></a>01904 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l01905"></a>01905 
<a name="l01906"></a>01906   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l01907"></a>01907     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l01908"></a>01908 
<a name="l01909"></a>01909 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01910"></a>01910 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l01911"></a>01911     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l01912"></a>01912       <span class="keywordflow">return</span> NULL;
<a name="l01913"></a>01913 
<a name="l01914"></a>01914 <span class="preprocessor">#ifndef DYNAMIC_SYSCALLS</span>
<a name="l01915"></a>01915 <span class="preprocessor"></span>  ret = &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_sysentry;
<a name="l01916"></a>01916 <span class="preprocessor">#else </span><span class="comment">/* DYNAMIC_SYSCALLS */</span>
<a name="l01917"></a>01917   {
<a name="l01918"></a>01918     <span class="keyword">static</span> sysset_t *sysentry;
<a name="l01919"></a>01919     <span class="keywordtype">size_t</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l01920"></a>01920 
<a name="l01921"></a>01921     <span class="keywordflow">if</span> (!sysentry)
<a name="l01922"></a>01922       sysentry = <a class="code" href="procfs_8c.html#a46e37b7eaec868b43af27d24b556e9c9">sysset_t_alloc</a> (pi);
<a name="l01923"></a>01923     ret = sysentry;
<a name="l01924"></a>01924     <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a> == 0 &amp;&amp; <a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (pi, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca14a7bec1b8050b1bc5e4335e59bf0db5">FD_STATUS</a>) == 0)
<a name="l01925"></a>01925       <span class="keywordflow">return</span> NULL;
<a name="l01926"></a>01926     <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_sysentry_offset == 0)
<a name="l01927"></a>01927       {
<a name="l01928"></a>01928         <a class="code" href="procfs_8c.html#a59f0624d8796729e70bea1dda0394b81">gdb_premptysysset</a> (sysentry);
<a name="l01929"></a>01929       }
<a name="l01930"></a>01930     <span class="keywordflow">else</span>
<a name="l01931"></a>01931       {
<a name="l01932"></a>01932         <span class="keywordtype">int</span> rsize;
<a name="l01933"></a>01933 
<a name="l01934"></a>01934         <span class="keywordflow">if</span> (lseek (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a>, (off_t) pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_sysentry_offset,
<a name="l01935"></a>01935                    SEEK_SET)
<a name="l01936"></a>01936             != (off_t) pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_sysentry_offset)
<a name="l01937"></a>01937           <span class="keywordflow">return</span> NULL;
<a name="l01938"></a>01938         size = <a class="code" href="procfs_8c.html#a1cdd2d8ca6008592b9aeb49b7f6e4f10">sysset_t_size</a> (pi);
<a name="l01939"></a>01939         <a class="code" href="procfs_8c.html#a59f0624d8796729e70bea1dda0394b81">gdb_premptysysset</a> (sysentry);
<a name="l01940"></a>01940         rsize = <a class="code" href="expect-read1_8c.html#af32a16ad2dd9e48482f8f790db7dbbd2">read</a> (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a>, sysentry, size);
<a name="l01941"></a>01941         <span class="keywordflow">if</span> (rsize &lt; 0)
<a name="l01942"></a>01942           <span class="keywordflow">return</span> NULL;
<a name="l01943"></a>01943       }
<a name="l01944"></a>01944   }
<a name="l01945"></a>01945 <span class="preprocessor">#endif </span><span class="comment">/* DYNAMIC_SYSCALLS */</span>
<a name="l01946"></a>01946 <span class="preprocessor">#else </span><span class="comment">/* !NEW_PROC_API */</span>
<a name="l01947"></a>01947   {
<a name="l01948"></a>01948     <span class="keyword">static</span> sysset_t sysentry;
<a name="l01949"></a>01949 
<a name="l01950"></a>01950     <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCGENTRY, &amp;sysentry) &gt;= 0)
<a name="l01951"></a>01951       ret = &amp;sysentry;
<a name="l01952"></a>01952   }
<a name="l01953"></a>01953 <span class="preprocessor">#endif </span><span class="comment">/* NEW_PROC_API */</span>
<a name="l01954"></a>01954   <span class="keywordflow">if</span> (save &amp;&amp; ret)
<a name="l01955"></a>01955     <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (save, ret, <a class="code" href="procfs_8c.html#a1cdd2d8ca6008592b9aeb49b7f6e4f10">sysset_t_size</a> (pi));
<a name="l01956"></a>01956 
<a name="l01957"></a>01957   <span class="keywordflow">return</span> ret;
<a name="l01958"></a>01958 }
<a name="l01959"></a>01959 
<a name="l01960"></a>01960 <span class="comment">/* Returns the set of syscalls that are traced /debugged on exit.</span>
<a name="l01961"></a>01961 <span class="comment">   Will also copy the syscall set if SAVE is non-zero.  */</span>
<a name="l01962"></a>01962 
<a name="l01963"></a>01963 <span class="keyword">static</span> sysset_t *
<a name="l01964"></a><a class="code" href="procfs_8c.html#afb19be38f985cb48545d7f81771dcf60">01964</a> <a class="code" href="procfs_8c.html#afb19be38f985cb48545d7f81771dcf60">proc_get_traced_sysexit</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, sysset_t *<a class="code" href="namespaceSession.html#a760bd9a972f5c93149918376625ad07f">save</a>)
<a name="l01965"></a>01965 {
<a name="l01966"></a>01966   sysset_t * ret = NULL;
<a name="l01967"></a>01967 
<a name="l01968"></a>01968   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l01969"></a>01969 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l01970"></a>01970 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l01971"></a>01971 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l01972"></a>01972 
<a name="l01973"></a>01973   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l01974"></a>01974     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l01975"></a>01975 
<a name="l01976"></a>01976 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l01977"></a>01977 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l01978"></a>01978     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l01979"></a>01979       <span class="keywordflow">return</span> NULL;
<a name="l01980"></a>01980 
<a name="l01981"></a>01981 <span class="preprocessor">#ifndef DYNAMIC_SYSCALLS</span>
<a name="l01982"></a>01982 <span class="preprocessor"></span>  ret = &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_sysexit;
<a name="l01983"></a>01983 <span class="preprocessor">#else </span><span class="comment">/* DYNAMIC_SYSCALLS */</span>
<a name="l01984"></a>01984   {
<a name="l01985"></a>01985     <span class="keyword">static</span> sysset_t *sysexit;
<a name="l01986"></a>01986     <span class="keywordtype">size_t</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l01987"></a>01987 
<a name="l01988"></a>01988     <span class="keywordflow">if</span> (!sysexit)
<a name="l01989"></a>01989       sysexit = <a class="code" href="procfs_8c.html#a46e37b7eaec868b43af27d24b556e9c9">sysset_t_alloc</a> (pi);
<a name="l01990"></a>01990     ret = sysexit;
<a name="l01991"></a>01991     <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a> == 0 &amp;&amp; <a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (pi, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca14a7bec1b8050b1bc5e4335e59bf0db5">FD_STATUS</a>) == 0)
<a name="l01992"></a>01992       <span class="keywordflow">return</span> NULL;
<a name="l01993"></a>01993     <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_sysexit_offset == 0)
<a name="l01994"></a>01994       {
<a name="l01995"></a>01995         <a class="code" href="procfs_8c.html#a59f0624d8796729e70bea1dda0394b81">gdb_premptysysset</a> (sysexit);
<a name="l01996"></a>01996       }
<a name="l01997"></a>01997     <span class="keywordflow">else</span>
<a name="l01998"></a>01998       {
<a name="l01999"></a>01999         <span class="keywordtype">int</span> rsize;
<a name="l02000"></a>02000 
<a name="l02001"></a>02001         <span class="keywordflow">if</span> (lseek (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a>, (off_t) pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_sysexit_offset,
<a name="l02002"></a>02002                    SEEK_SET)
<a name="l02003"></a>02003             != (off_t) pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_sysexit_offset)
<a name="l02004"></a>02004           <span class="keywordflow">return</span> NULL;
<a name="l02005"></a>02005         size = <a class="code" href="procfs_8c.html#a1cdd2d8ca6008592b9aeb49b7f6e4f10">sysset_t_size</a> (pi);
<a name="l02006"></a>02006         <a class="code" href="procfs_8c.html#a59f0624d8796729e70bea1dda0394b81">gdb_premptysysset</a> (sysexit);
<a name="l02007"></a>02007         rsize = <a class="code" href="expect-read1_8c.html#af32a16ad2dd9e48482f8f790db7dbbd2">read</a> (pi-&gt;<a class="code" href="structprocinfo.html#a0dc827e627fae025814c2a47f0cf8052">status_fd</a>, sysexit, size);
<a name="l02008"></a>02008         <span class="keywordflow">if</span> (rsize &lt; 0)
<a name="l02009"></a>02009           <span class="keywordflow">return</span> NULL;
<a name="l02010"></a>02010       }
<a name="l02011"></a>02011   }
<a name="l02012"></a>02012 <span class="preprocessor">#endif </span><span class="comment">/* DYNAMIC_SYSCALLS */</span>
<a name="l02013"></a>02013 <span class="preprocessor">#else</span>
<a name="l02014"></a>02014 <span class="preprocessor"></span>  {
<a name="l02015"></a>02015     <span class="keyword">static</span> sysset_t sysexit;
<a name="l02016"></a>02016 
<a name="l02017"></a>02017     <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCGEXIT, &amp;sysexit) &gt;= 0)
<a name="l02018"></a>02018       ret = &amp;sysexit;
<a name="l02019"></a>02019   }
<a name="l02020"></a>02020 <span class="preprocessor">#endif</span>
<a name="l02021"></a>02021 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (save &amp;&amp; ret)
<a name="l02022"></a>02022     <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (save, ret, <a class="code" href="procfs_8c.html#a1cdd2d8ca6008592b9aeb49b7f6e4f10">sysset_t_size</a> (pi));
<a name="l02023"></a>02023 
<a name="l02024"></a>02024   <span class="keywordflow">return</span> ret;
<a name="l02025"></a>02025 }
<a name="l02026"></a>02026 
<a name="l02027"></a>02027 <span class="comment">/* The current fault (if any) is cleared; the associated signal will</span>
<a name="l02028"></a>02028 <span class="comment">   not be sent to the process or LWP when it resumes.  Returns</span>
<a name="l02029"></a>02029 <span class="comment">   non-zero for success, zero for failure.  */</span>
<a name="l02030"></a>02030 
<a name="l02031"></a>02031 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02032"></a><a class="code" href="procfs_8c.html#a7e91a0e63d7a14be7175af82ce8228a3">02032</a> <a class="code" href="procfs_8c.html#a7e91a0e63d7a14be7175af82ce8228a3">proc_clear_current_fault</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02033"></a>02033 {
<a name="l02034"></a>02034   <span class="keywordtype">int</span> win;
<a name="l02035"></a>02035 
<a name="l02036"></a>02036   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l02037"></a>02037 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l02038"></a>02038 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l02039"></a>02039 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l02040"></a>02040 
<a name="l02041"></a>02041   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l02042"></a>02042     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l02043"></a>02043 
<a name="l02044"></a>02044 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l02045"></a>02045 <span class="preprocessor"></span>  {
<a name="l02046"></a>02046     <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd = PCCFAULT;
<a name="l02047"></a>02047 
<a name="l02048"></a>02048     win = (write (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, (<span class="keywordtype">void</span> *) &amp;cmd, sizeof (cmd)) == <span class="keyword">sizeof</span> (cmd));
<a name="l02049"></a>02049   }
<a name="l02050"></a>02050 <span class="preprocessor">#else</span>
<a name="l02051"></a>02051 <span class="preprocessor"></span>  win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCCFAULT, 0) &gt;= 0);
<a name="l02052"></a>02052 <span class="preprocessor">#endif</span>
<a name="l02053"></a>02053 <span class="preprocessor"></span>
<a name="l02054"></a>02054   <span class="keywordflow">return</span> win;
<a name="l02055"></a>02055 }
<a name="l02056"></a>02056 
<a name="l02057"></a>02057 <span class="comment">/* Set the &quot;current signal&quot; that will be delivered next to the</span>
<a name="l02058"></a>02058 <span class="comment">   process.  NOTE: semantics are different from those of KILL.  This</span>
<a name="l02059"></a>02059 <span class="comment">   signal will be delivered to the process or LWP immediately when it</span>
<a name="l02060"></a>02060 <span class="comment">   is resumed (even if the signal is held/blocked); it will NOT</span>
<a name="l02061"></a>02061 <span class="comment">   immediately cause another event of interest, and will NOT first</span>
<a name="l02062"></a>02062 <span class="comment">   trap back to the debugger.  Returns non-zero for success, zero for</span>
<a name="l02063"></a>02063 <span class="comment">   failure.  */</span>
<a name="l02064"></a>02064 
<a name="l02065"></a>02065 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02066"></a><a class="code" href="procfs_8c.html#ad042ba71cbc842f0407b54cfe972fb19">02066</a> <a class="code" href="procfs_8c.html#ad042ba71cbc842f0407b54cfe972fb19">proc_set_current_signal</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">int</span> signo)
<a name="l02067"></a>02067 {
<a name="l02068"></a>02068   <span class="keywordtype">int</span> win;
<a name="l02069"></a>02069   <span class="keyword">struct </span>{
<a name="l02070"></a>02070     <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd;
<a name="l02071"></a>02071     <span class="comment">/* Use char array to avoid alignment issues.  */</span>
<a name="l02072"></a>02072     <span class="keywordtype">char</span> sinfo[<span class="keyword">sizeof</span> (<a class="code" href="procfs_8c.html#acf8fd807272e10a609db9462334e3e26">gdb_siginfo_t</a>)];
<a name="l02073"></a>02073   } arg;
<a name="l02074"></a>02074   gdb_siginfo_t mysinfo;
<a name="l02075"></a>02075   <a class="code" href="structptid.html">ptid_t</a> wait_ptid;
<a name="l02076"></a>02076   <span class="keyword">struct </span><a class="code" href="structtarget__waitstatus.html">target_waitstatus</a> wait_status;
<a name="l02077"></a>02077 
<a name="l02078"></a>02078   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l02079"></a>02079 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l02080"></a>02080 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l02081"></a>02081 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l02082"></a>02082 
<a name="l02083"></a>02083   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l02084"></a>02084     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l02085"></a>02085 
<a name="l02086"></a>02086 <span class="preprocessor">#ifdef PROCFS_DONT_PIOCSSIG_CURSIG</span>
<a name="l02087"></a>02087 <span class="preprocessor"></span>  <span class="comment">/* With Alpha OSF/1 procfs, the kernel gets really confused if it</span>
<a name="l02088"></a>02088 <span class="comment">     receives a PIOCSSIG with a signal identical to the current</span>
<a name="l02089"></a>02089 <span class="comment">     signal, it messes up the current signal.  Work around the kernel</span>
<a name="l02090"></a>02090 <span class="comment">     bug.  */</span>
<a name="l02091"></a>02091   <span class="keywordflow">if</span> (signo &gt; 0 &amp;&amp;
<a name="l02092"></a>02092       signo == proc_cursig (pi))
<a name="l02093"></a>02093     <span class="keywordflow">return</span> 1;           <span class="comment">/* I assume this is a success?  */</span>
<a name="l02094"></a>02094 <span class="preprocessor">#endif</span>
<a name="l02095"></a>02095 <span class="preprocessor"></span>
<a name="l02096"></a>02096   <span class="comment">/* The pointer is just a type alias.  */</span>
<a name="l02097"></a>02097   <a class="code" href="inferior_8h.html#a4a47a81bc60d7b0fd147f0d4ce8de8bc">get_last_target_status</a> (&amp;wait_ptid, &amp;wait_status);
<a name="l02098"></a>02098   <span class="keywordflow">if</span> (<a class="code" href="ptid_8c.html#a0df58c8db2620a2cec647934b4f77266">ptid_equal</a> (wait_ptid, <a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>)
<a name="l02099"></a>02099       &amp;&amp; wait_status.<a class="code" href="structtarget__waitstatus.html#a17ed1783e9146f443fa51ace8da76198">kind</a> == <a class="code" href="waitstatus_8h.html#aa3229b489ec985f04f7e9f652138b7c3a8e1dc525cf3131501a541b4412bcd493">TARGET_WAITKIND_STOPPED</a>
<a name="l02100"></a>02100       &amp;&amp; wait_status.<a class="code" href="structtarget__waitstatus.html#af33b8f5721dc36f6b5b829286d38f825">value</a>.<a class="code" href="structtarget__waitstatus.html#a7cc711572c26d1f095a87105f4afd1e1">sig</a> == <a class="code" href="gdb__signals_8h.html#a11fcc2899ec63af2c688695243202f1a">gdb_signal_from_host</a> (signo)
<a name="l02101"></a>02101       &amp;&amp; <a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi)
<a name="l02102"></a>02102 #ifdef NEW_PROC_API
<a name="l02103"></a>02103       &amp;&amp; pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_lwp.pr_info.si_signo == signo
<a name="l02104"></a>02104 #<span class="keywordflow">else</span>
<a name="l02105"></a>02105       &amp;&amp; pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_info.si_signo == signo
<a name="l02106"></a>02106 #endif
<a name="l02107"></a>02107       )
<a name="l02108"></a>02108     <span class="comment">/* Use the siginfo associated with the signal being</span>
<a name="l02109"></a>02109 <span class="comment">       redelivered.  */</span>
<a name="l02110"></a>02110 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l02111"></a>02111 <span class="preprocessor"></span>    <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (arg.sinfo, &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_lwp.pr_info, sizeof (gdb_siginfo_t));
<a name="l02112"></a>02112 <span class="preprocessor">#else</span>
<a name="l02113"></a>02113 <span class="preprocessor"></span>    <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (arg.sinfo, &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_info, sizeof (gdb_siginfo_t));
<a name="l02114"></a>02114 <span class="preprocessor">#endif</span>
<a name="l02115"></a>02115 <span class="preprocessor"></span>  <span class="keywordflow">else</span>
<a name="l02116"></a>02116     {
<a name="l02117"></a>02117       mysinfo.si_signo = signo;
<a name="l02118"></a>02118       mysinfo.si_code  = 0;
<a name="l02119"></a>02119       mysinfo.si_pid   = getpid ();       <span class="comment">/* ?why? */</span>
<a name="l02120"></a>02120       mysinfo.si_uid   = getuid ();       <span class="comment">/* ?why? */</span>
<a name="l02121"></a>02121       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (arg.sinfo, &amp;mysinfo, sizeof (gdb_siginfo_t));
<a name="l02122"></a>02122     }
<a name="l02123"></a>02123 
<a name="l02124"></a>02124 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l02125"></a>02125 <span class="preprocessor"></span>  arg.cmd = PCSSIG;
<a name="l02126"></a>02126   win = (write (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, (<span class="keywordtype">void</span> *) &amp;arg, sizeof (arg))  == <span class="keyword">sizeof</span> (arg));
<a name="l02127"></a>02127 <span class="preprocessor">#else</span>
<a name="l02128"></a>02128 <span class="preprocessor"></span>  win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSSIG, (<span class="keywordtype">void</span> *) &amp;arg.sinfo) &gt;= 0);
<a name="l02129"></a>02129 <span class="preprocessor">#endif</span>
<a name="l02130"></a>02130 <span class="preprocessor"></span>
<a name="l02131"></a>02131   <span class="keywordflow">return</span> win;
<a name="l02132"></a>02132 }
<a name="l02133"></a>02133 
<a name="l02134"></a>02134 <span class="comment">/* The current signal (if any) is cleared, and is not sent to the</span>
<a name="l02135"></a>02135 <span class="comment">   process or LWP when it resumes.  Returns non-zero for success, zero</span>
<a name="l02136"></a>02136 <span class="comment">   for failure.  */</span>
<a name="l02137"></a>02137 
<a name="l02138"></a>02138 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02139"></a><a class="code" href="procfs_8c.html#acf498bb6db60da249ab7425b373c25b1">02139</a> <a class="code" href="procfs_8c.html#acf498bb6db60da249ab7425b373c25b1">proc_clear_current_signal</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02140"></a>02140 {
<a name="l02141"></a>02141   <span class="keywordtype">int</span> win;
<a name="l02142"></a>02142 
<a name="l02143"></a>02143   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l02144"></a>02144 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l02145"></a>02145 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l02146"></a>02146 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l02147"></a>02147 
<a name="l02148"></a>02148   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l02149"></a>02149     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l02150"></a>02150 
<a name="l02151"></a>02151 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l02152"></a>02152 <span class="preprocessor"></span>  {
<a name="l02153"></a>02153     <span class="keyword">struct </span>{
<a name="l02154"></a>02154       <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd;
<a name="l02155"></a>02155       <span class="comment">/* Use char array to avoid alignment issues.  */</span>
<a name="l02156"></a>02156       <span class="keywordtype">char</span> sinfo[<span class="keyword">sizeof</span> (<a class="code" href="procfs_8c.html#acf8fd807272e10a609db9462334e3e26">gdb_siginfo_t</a>)];
<a name="l02157"></a>02157     } arg;
<a name="l02158"></a>02158     gdb_siginfo_t mysinfo;
<a name="l02159"></a>02159 
<a name="l02160"></a>02160     arg.cmd = PCSSIG;
<a name="l02161"></a>02161     <span class="comment">/* The pointer is just a type alias.  */</span>
<a name="l02162"></a>02162     mysinfo.si_signo = 0;
<a name="l02163"></a>02163     mysinfo.si_code  = 0;
<a name="l02164"></a>02164     mysinfo.si_errno = 0;
<a name="l02165"></a>02165     mysinfo.si_pid   = getpid ();       <span class="comment">/* ?why? */</span>
<a name="l02166"></a>02166     mysinfo.si_uid   = getuid ();       <span class="comment">/* ?why? */</span>
<a name="l02167"></a>02167     <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (arg.sinfo, &amp;mysinfo, sizeof (gdb_siginfo_t));
<a name="l02168"></a>02168 
<a name="l02169"></a>02169     win = (write (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, (<span class="keywordtype">void</span> *) &amp;arg, sizeof (arg)) == <span class="keyword">sizeof</span> (arg));
<a name="l02170"></a>02170   }
<a name="l02171"></a>02171 <span class="preprocessor">#else</span>
<a name="l02172"></a>02172 <span class="preprocessor"></span>  win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSSIG, 0) &gt;= 0);
<a name="l02173"></a>02173 <span class="preprocessor">#endif</span>
<a name="l02174"></a>02174 <span class="preprocessor"></span>
<a name="l02175"></a>02175   <span class="keywordflow">return</span> win;
<a name="l02176"></a>02176 }
<a name="l02177"></a>02177 
<a name="l02178"></a>02178 <span class="comment">/* Return the general-purpose registers for the process or LWP</span>
<a name="l02179"></a>02179 <span class="comment">   corresponding to PI.  Upon failure, return NULL.  */</span>
<a name="l02180"></a>02180 
<a name="l02181"></a>02181 <span class="keyword">static</span> <a class="code" href="gregset_8h.html#ad358cd20eb83ca9e131c708c8aa14c89">gdb_gregset_t</a> *
<a name="l02182"></a><a class="code" href="procfs_8c.html#a186019d8eb03e08d77a0121384fec317">02182</a> <a class="code" href="procfs_8c.html#a186019d8eb03e08d77a0121384fec317">proc_get_gregs</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02183"></a>02183 {
<a name="l02184"></a>02184   <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> || !pi-&gt;<a class="code" href="structprocinfo.html#af644c8cc9c6b4f09babb3eaf994fa5fc">gregs_valid</a>)
<a name="l02185"></a>02185     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l02186"></a>02186       <span class="keywordflow">return</span> NULL;
<a name="l02187"></a>02187 
<a name="l02188"></a>02188 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l02189"></a>02189 <span class="preprocessor"></span>  <span class="keywordflow">return</span> &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_lwp.pr_reg;
<a name="l02190"></a>02190 <span class="preprocessor">#else</span>
<a name="l02191"></a>02191 <span class="preprocessor"></span>  <span class="keywordflow">return</span> &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_reg;
<a name="l02192"></a>02192 <span class="preprocessor">#endif</span>
<a name="l02193"></a>02193 <span class="preprocessor"></span>}
<a name="l02194"></a>02194 
<a name="l02195"></a>02195 <span class="comment">/* Return the general-purpose registers for the process or LWP</span>
<a name="l02196"></a>02196 <span class="comment">   corresponding to PI.  Upon failure, return NULL.  */</span>
<a name="l02197"></a>02197 
<a name="l02198"></a>02198 <span class="keyword">static</span> <a class="code" href="gregset_8h.html#ac5319835a36948bae33bef8f21542def">gdb_fpregset_t</a> *
<a name="l02199"></a><a class="code" href="procfs_8c.html#a92e3ada52963db8a97f6afbcf5a8d20e">02199</a> <a class="code" href="procfs_8c.html#a92e3ada52963db8a97f6afbcf5a8d20e">proc_get_fpregs</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02200"></a>02200 {
<a name="l02201"></a>02201 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l02202"></a>02202 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> || !pi-&gt;<a class="code" href="structprocinfo.html#a687b93500ed96768255ec07735113afb">fpregs_valid</a>)
<a name="l02203"></a>02203     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l02204"></a>02204       <span class="keywordflow">return</span> NULL;
<a name="l02205"></a>02205 
<a name="l02206"></a>02206   <span class="keywordflow">return</span> &amp;pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_lwp.pr_fpreg;
<a name="l02207"></a>02207 
<a name="l02208"></a>02208 <span class="preprocessor">#else  </span><span class="comment">/* not NEW_PROC_API */</span>
<a name="l02209"></a>02209   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a687b93500ed96768255ec07735113afb">fpregs_valid</a>)
<a name="l02210"></a>02210     <span class="keywordflow">return</span> &amp;pi-&gt;<a class="code" href="structprocinfo.html#a4e75ee94e9ea452db34145cb09890827">fpregset</a>;       <span class="comment">/* Already got &#39;em.  */</span>
<a name="l02211"></a>02211   <span class="keywordflow">else</span>
<a name="l02212"></a>02212     {
<a name="l02213"></a>02213       <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a> == 0 &amp;&amp; <a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (pi, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca242b7fbe149191cf293910e1f2f65bd6">FD_CTL</a>) == 0)
<a name="l02214"></a>02214         {
<a name="l02215"></a>02215           <span class="keywordflow">return</span> NULL;
<a name="l02216"></a>02216         }
<a name="l02217"></a>02217       <span class="keywordflow">else</span>
<a name="l02218"></a>02218         {
<a name="l02219"></a>02219 <span class="preprocessor"># ifdef PIOCTGFPREG</span>
<a name="l02220"></a>02220 <span class="preprocessor"></span>          <span class="keyword">struct </span>{
<a name="l02221"></a>02221             <span class="keywordtype">long</span> pr_count;
<a name="l02222"></a>02222             tid_t pr_error_thread;
<a name="l02223"></a>02223             tfpregset_t thread_1;
<a name="l02224"></a>02224           } thread_fpregs;
<a name="l02225"></a>02225 
<a name="l02226"></a>02226           thread_fpregs.pr_count = 1;
<a name="l02227"></a>02227           thread_fpregs.thread_1.tid = pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>;
<a name="l02228"></a>02228 
<a name="l02229"></a>02229           <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> == 0
<a name="l02230"></a>02230               &amp;&amp; ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCGFPREG, &amp;pi-&gt;<a class="code" href="structprocinfo.html#a4e75ee94e9ea452db34145cb09890827">fpregset</a>) &gt;= 0)
<a name="l02231"></a>02231             {
<a name="l02232"></a>02232               pi-&gt;<a class="code" href="structprocinfo.html#a687b93500ed96768255ec07735113afb">fpregs_valid</a> = 1;
<a name="l02233"></a>02233               <span class="keywordflow">return</span> &amp;pi-&gt;<a class="code" href="structprocinfo.html#a4e75ee94e9ea452db34145cb09890827">fpregset</a>; <span class="comment">/* Got &#39;em now!  */</span>
<a name="l02234"></a>02234             }
<a name="l02235"></a>02235           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0
<a name="l02236"></a>02236                    &amp;&amp; ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCTGFPREG, &amp;thread_fpregs) &gt;= 0)
<a name="l02237"></a>02237             {
<a name="l02238"></a>02238               <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (&amp;pi-&gt;<a class="code" href="structprocinfo.html#a4e75ee94e9ea452db34145cb09890827">fpregset</a>, &amp;thread_fpregs.thread_1.pr_fpregs,
<a name="l02239"></a>02239                       sizeof (pi-&gt;<a class="code" href="structprocinfo.html#a4e75ee94e9ea452db34145cb09890827">fpregset</a>));
<a name="l02240"></a>02240               pi-&gt;<a class="code" href="structprocinfo.html#a687b93500ed96768255ec07735113afb">fpregs_valid</a> = 1;
<a name="l02241"></a>02241               <span class="keywordflow">return</span> &amp;pi-&gt;<a class="code" href="structprocinfo.html#a4e75ee94e9ea452db34145cb09890827">fpregset</a>; <span class="comment">/* Got &#39;em now!  */</span>
<a name="l02242"></a>02242             }
<a name="l02243"></a>02243           <span class="keywordflow">else</span>
<a name="l02244"></a>02244             {
<a name="l02245"></a>02245               <span class="keywordflow">return</span> NULL;
<a name="l02246"></a>02246             }
<a name="l02247"></a>02247 <span class="preprocessor"># else</span>
<a name="l02248"></a>02248 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCGFPREG, &amp;pi-&gt;<a class="code" href="structprocinfo.html#a4e75ee94e9ea452db34145cb09890827">fpregset</a>) &gt;= 0)
<a name="l02249"></a>02249             {
<a name="l02250"></a>02250               pi-&gt;<a class="code" href="structprocinfo.html#a687b93500ed96768255ec07735113afb">fpregs_valid</a> = 1;
<a name="l02251"></a>02251               <span class="keywordflow">return</span> &amp;pi-&gt;<a class="code" href="structprocinfo.html#a4e75ee94e9ea452db34145cb09890827">fpregset</a>; <span class="comment">/* Got &#39;em now!  */</span>
<a name="l02252"></a>02252             }
<a name="l02253"></a>02253           <span class="keywordflow">else</span>
<a name="l02254"></a>02254             {
<a name="l02255"></a>02255               <span class="keywordflow">return</span> NULL;
<a name="l02256"></a>02256             }
<a name="l02257"></a>02257 <span class="preprocessor"># endif</span>
<a name="l02258"></a>02258 <span class="preprocessor"></span>        }
<a name="l02259"></a>02259     }
<a name="l02260"></a>02260 <span class="preprocessor">#endif </span><span class="comment">/* NEW_PROC_API */</span>
<a name="l02261"></a>02261 }
<a name="l02262"></a>02262 
<a name="l02263"></a>02263 <span class="comment">/* Write the general-purpose registers back to the process or LWP</span>
<a name="l02264"></a>02264 <span class="comment">   corresponding to PI.  Return non-zero for success, zero for</span>
<a name="l02265"></a>02265 <span class="comment">   failure.  */</span>
<a name="l02266"></a>02266 
<a name="l02267"></a>02267 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02268"></a><a class="code" href="procfs_8c.html#a157837678e57bda96a70afe61ef02c57">02268</a> <a class="code" href="procfs_8c.html#a157837678e57bda96a70afe61ef02c57">proc_set_gregs</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02269"></a>02269 {
<a name="l02270"></a>02270   <a class="code" href="gregset_8h.html#ad358cd20eb83ca9e131c708c8aa14c89">gdb_gregset_t</a> *gregs;
<a name="l02271"></a>02271   <span class="keywordtype">int</span> win;
<a name="l02272"></a>02272 
<a name="l02273"></a>02273   gregs = <a class="code" href="procfs_8c.html#a186019d8eb03e08d77a0121384fec317">proc_get_gregs</a> (pi);
<a name="l02274"></a>02274   <span class="keywordflow">if</span> (gregs == NULL)
<a name="l02275"></a>02275     <span class="keywordflow">return</span> 0;                   <span class="comment">/* proc_get_regs has already warned.  */</span>
<a name="l02276"></a>02276 
<a name="l02277"></a>02277   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a> == 0 &amp;&amp; <a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (pi, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca242b7fbe149191cf293910e1f2f65bd6">FD_CTL</a>) == 0)
<a name="l02278"></a>02278     {
<a name="l02279"></a>02279       <span class="keywordflow">return</span> 0;
<a name="l02280"></a>02280     }
<a name="l02281"></a>02281   <span class="keywordflow">else</span>
<a name="l02282"></a>02282     {
<a name="l02283"></a>02283 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l02284"></a>02284 <span class="preprocessor"></span>      <span class="keyword">struct </span>{
<a name="l02285"></a>02285         <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd;
<a name="l02286"></a>02286         <span class="comment">/* Use char array to avoid alignment issues.  */</span>
<a name="l02287"></a>02287         <span class="keywordtype">char</span> gregs[<span class="keyword">sizeof</span> (<a class="code" href="gregset_8h.html#ad358cd20eb83ca9e131c708c8aa14c89">gdb_gregset_t</a>)];
<a name="l02288"></a>02288       } arg;
<a name="l02289"></a>02289 
<a name="l02290"></a>02290       arg.cmd = PCSREG;
<a name="l02291"></a>02291       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (&amp;arg.gregs, gregs, sizeof (arg.gregs));
<a name="l02292"></a>02292       win = (write (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, (<span class="keywordtype">void</span> *) &amp;arg, sizeof (arg)) == <span class="keyword">sizeof</span> (arg));
<a name="l02293"></a>02293 <span class="preprocessor">#else</span>
<a name="l02294"></a>02294 <span class="preprocessor"></span>      win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSREG, gregs) &gt;= 0);
<a name="l02295"></a>02295 <span class="preprocessor">#endif</span>
<a name="l02296"></a>02296 <span class="preprocessor"></span>    }
<a name="l02297"></a>02297 
<a name="l02298"></a>02298   <span class="comment">/* Policy: writing the registers invalidates our cache.  */</span>
<a name="l02299"></a>02299   pi-&gt;<a class="code" href="structprocinfo.html#af644c8cc9c6b4f09babb3eaf994fa5fc">gregs_valid</a> = 0;
<a name="l02300"></a>02300   <span class="keywordflow">return</span> win;
<a name="l02301"></a>02301 }
<a name="l02302"></a>02302 
<a name="l02303"></a>02303 <span class="comment">/* Write the floating-pointer registers back to the process or LWP</span>
<a name="l02304"></a>02304 <span class="comment">   corresponding to PI.  Return non-zero for success, zero for</span>
<a name="l02305"></a>02305 <span class="comment">   failure.  */</span>
<a name="l02306"></a>02306 
<a name="l02307"></a>02307 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02308"></a><a class="code" href="procfs_8c.html#a409cfe587b50c92fd09c4c1e71edcf17">02308</a> <a class="code" href="procfs_8c.html#a409cfe587b50c92fd09c4c1e71edcf17">proc_set_fpregs</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02309"></a>02309 {
<a name="l02310"></a>02310   <a class="code" href="gregset_8h.html#ac5319835a36948bae33bef8f21542def">gdb_fpregset_t</a> *fpregs;
<a name="l02311"></a>02311   <span class="keywordtype">int</span> win;
<a name="l02312"></a>02312 
<a name="l02313"></a>02313   fpregs = <a class="code" href="procfs_8c.html#a92e3ada52963db8a97f6afbcf5a8d20e">proc_get_fpregs</a> (pi);
<a name="l02314"></a>02314   <span class="keywordflow">if</span> (fpregs == NULL)
<a name="l02315"></a>02315     <span class="keywordflow">return</span> 0;                   <span class="comment">/* proc_get_fpregs has already warned.  */</span>
<a name="l02316"></a>02316 
<a name="l02317"></a>02317   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a> == 0 &amp;&amp; <a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (pi, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca242b7fbe149191cf293910e1f2f65bd6">FD_CTL</a>) == 0)
<a name="l02318"></a>02318     {
<a name="l02319"></a>02319       <span class="keywordflow">return</span> 0;
<a name="l02320"></a>02320     }
<a name="l02321"></a>02321   <span class="keywordflow">else</span>
<a name="l02322"></a>02322     {
<a name="l02323"></a>02323 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l02324"></a>02324 <span class="preprocessor"></span>      <span class="keyword">struct </span>{
<a name="l02325"></a>02325         <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd;
<a name="l02326"></a>02326         <span class="comment">/* Use char array to avoid alignment issues.  */</span>
<a name="l02327"></a>02327         <span class="keywordtype">char</span> fpregs[<span class="keyword">sizeof</span> (<a class="code" href="gregset_8h.html#ac5319835a36948bae33bef8f21542def">gdb_fpregset_t</a>)];
<a name="l02328"></a>02328       } arg;
<a name="l02329"></a>02329 
<a name="l02330"></a>02330       arg.cmd = PCSFPREG;
<a name="l02331"></a>02331       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (&amp;arg.fpregs, fpregs, sizeof (arg.fpregs));
<a name="l02332"></a>02332       win = (write (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, (<span class="keywordtype">void</span> *) &amp;arg, sizeof (arg)) == <span class="keyword">sizeof</span> (arg));
<a name="l02333"></a>02333 <span class="preprocessor">#else</span>
<a name="l02334"></a>02334 <span class="preprocessor"></span><span class="preprocessor"># ifdef PIOCTSFPREG</span>
<a name="l02335"></a>02335 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> == 0)
<a name="l02336"></a>02336         win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSFPREG, fpregs) &gt;= 0);
<a name="l02337"></a>02337       <span class="keywordflow">else</span>
<a name="l02338"></a>02338         {
<a name="l02339"></a>02339           <span class="keyword">struct </span>{
<a name="l02340"></a>02340             <span class="keywordtype">long</span> pr_count;
<a name="l02341"></a>02341             tid_t pr_error_thread;
<a name="l02342"></a>02342             tfpregset_t thread_1;
<a name="l02343"></a>02343           } thread_fpregs;
<a name="l02344"></a>02344 
<a name="l02345"></a>02345           thread_fpregs.pr_count = 1;
<a name="l02346"></a>02346           thread_fpregs.thread_1.tid = pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>;
<a name="l02347"></a>02347           <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (&amp;thread_fpregs.thread_1.pr_fpregs, fpregs,
<a name="l02348"></a>02348                   sizeof (*fpregs));
<a name="l02349"></a>02349           win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCTSFPREG, &amp;thread_fpregs) &gt;= 0);
<a name="l02350"></a>02350         }
<a name="l02351"></a>02351 <span class="preprocessor"># else</span>
<a name="l02352"></a>02352 <span class="preprocessor"></span>      win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSFPREG, fpregs) &gt;= 0);
<a name="l02353"></a>02353 <span class="preprocessor"># endif</span>
<a name="l02354"></a>02354 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* NEW_PROC_API */</span>
<a name="l02355"></a>02355     }
<a name="l02356"></a>02356 
<a name="l02357"></a>02357   <span class="comment">/* Policy: writing the registers invalidates our cache.  */</span>
<a name="l02358"></a>02358   pi-&gt;<a class="code" href="structprocinfo.html#a687b93500ed96768255ec07735113afb">fpregs_valid</a> = 0;
<a name="l02359"></a>02359   <span class="keywordflow">return</span> win;
<a name="l02360"></a>02360 }
<a name="l02361"></a>02361 
<a name="l02362"></a>02362 <span class="comment">/* Send a signal to the proc or lwp with the semantics of &quot;kill()&quot;.</span>
<a name="l02363"></a>02363 <span class="comment">   Returns non-zero for success, zero for failure.  */</span>
<a name="l02364"></a>02364 
<a name="l02365"></a>02365 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02366"></a><a class="code" href="procfs_8c.html#a84a4b60eae474b08fe9ede25c27b5d26">02366</a> <a class="code" href="procfs_8c.html#a84a4b60eae474b08fe9ede25c27b5d26">proc_kill</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">int</span> signo)
<a name="l02367"></a>02367 {
<a name="l02368"></a>02368   <span class="keywordtype">int</span> win;
<a name="l02369"></a>02369 
<a name="l02370"></a>02370   <span class="comment">/* We might conceivably apply this operation to an LWP, and the</span>
<a name="l02371"></a>02371 <span class="comment">     LWP&#39;s ctl file descriptor might not be open.  */</span>
<a name="l02372"></a>02372 
<a name="l02373"></a>02373   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a> == 0 &amp;&amp;
<a name="l02374"></a>02374       <a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (pi, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca242b7fbe149191cf293910e1f2f65bd6">FD_CTL</a>) == 0)
<a name="l02375"></a>02375     {
<a name="l02376"></a>02376       <span class="keywordflow">return</span> 0;
<a name="l02377"></a>02377     }
<a name="l02378"></a>02378   <span class="keywordflow">else</span>
<a name="l02379"></a>02379     {
<a name="l02380"></a>02380 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l02381"></a>02381 <span class="preprocessor"></span>      <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd[2];
<a name="l02382"></a>02382 
<a name="l02383"></a>02383       cmd[0] = PCKILL;
<a name="l02384"></a>02384       cmd[1] = signo;
<a name="l02385"></a>02385       win = (write (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, (<span class="keywordtype">char</span> *) &amp;cmd, sizeof (cmd)) == <span class="keyword">sizeof</span> (cmd));
<a name="l02386"></a>02386 <span class="preprocessor">#else   </span><span class="comment">/* ioctl method */</span>
<a name="l02387"></a>02387       <span class="comment">/* FIXME: do I need the Alpha OSF fixups present in</span>
<a name="l02388"></a>02388 <span class="comment">         procfs.c/unconditionally_kill_inferior?  Perhaps only for SIGKILL?  */</span>
<a name="l02389"></a>02389       win = (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCKILL, &amp;signo) &gt;= 0);
<a name="l02390"></a>02390 <span class="preprocessor">#endif</span>
<a name="l02391"></a>02391 <span class="preprocessor"></span>  }
<a name="l02392"></a>02392 
<a name="l02393"></a>02393   <span class="keywordflow">return</span> win;
<a name="l02394"></a>02394 }
<a name="l02395"></a>02395 
<a name="l02396"></a>02396 <span class="comment">/* Find the pid of the process that started this one.  Returns the</span>
<a name="l02397"></a>02397 <span class="comment">   parent process pid, or zero.  */</span>
<a name="l02398"></a>02398 
<a name="l02399"></a>02399 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02400"></a><a class="code" href="procfs_8c.html#a045d9529c1ae6766642a42468f2dbaf0">02400</a> <a class="code" href="procfs_8c.html#a045d9529c1ae6766642a42468f2dbaf0">proc_parent_pid</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02401"></a>02401 {
<a name="l02402"></a>02402   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l02403"></a>02403 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l02404"></a>02404 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l02405"></a>02405 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l02406"></a>02406 
<a name="l02407"></a>02407   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l02408"></a>02408     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l02409"></a>02409 
<a name="l02410"></a>02410   <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l02411"></a>02411     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l02412"></a>02412       <span class="keywordflow">return</span> 0;
<a name="l02413"></a>02413 
<a name="l02414"></a>02414   <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_ppid;
<a name="l02415"></a>02415 }
<a name="l02416"></a>02416 
<a name="l02417"></a>02417 <span class="comment">/* Convert a target address (a.k.a. CORE_ADDR) into a host address</span>
<a name="l02418"></a>02418 <span class="comment">   (a.k.a void pointer)!  */</span>
<a name="l02419"></a>02419 
<a name="l02420"></a>02420 <span class="preprocessor">#if (defined (PCWATCH) || defined (PIOCSWATCH)) \</span>
<a name="l02421"></a>02421 <span class="preprocessor">    &amp;&amp; !(defined (PIOCOPENLWP))</span>
<a name="l02422"></a>02422 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> *
<a name="l02423"></a>02423 procfs_address_to_host_pointer (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr)
<a name="l02424"></a>02424 {
<a name="l02425"></a>02425   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *ptr_type = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ())-&gt;<a class="code" href="structbuiltin__type.html#a55f6f9ff7436431777683d8ba62f662a">builtin_data_ptr</a>;
<a name="l02426"></a>02426   <span class="keywordtype">void</span> *ptr;
<a name="l02427"></a>02427 
<a name="l02428"></a>02428   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<span class="keyword">sizeof</span> (ptr) == <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (ptr_type));
<a name="l02429"></a>02429   <a class="code" href="gdbarch_8c.html#aa6e70eb13dad5ac1e181afa8efcaa63a">gdbarch_address_to_pointer</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> (), ptr_type,
<a name="l02430"></a>02430                               (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *) &amp;ptr, addr);
<a name="l02431"></a>02431   <span class="keywordflow">return</span> ptr;
<a name="l02432"></a>02432 }
<a name="l02433"></a>02433 <span class="preprocessor">#endif</span>
<a name="l02434"></a>02434 <span class="preprocessor"></span>
<a name="l02435"></a>02435 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02436"></a><a class="code" href="procfs_8c.html#aa1e38d492f0fd834456562100b02517b">02436</a> <a class="code" href="procfs_8c.html#aa1e38d492f0fd834456562100b02517b">proc_set_watchpoint</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr, <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>, <span class="keywordtype">int</span> wflags)
<a name="l02437"></a>02437 {
<a name="l02438"></a>02438 <span class="preprocessor">#if !defined (PCWATCH) &amp;&amp; !defined (PIOCSWATCH)</span>
<a name="l02439"></a>02439 <span class="preprocessor"></span>  <span class="comment">/* If neither or these is defined, we can&#39;t support watchpoints.</span>
<a name="l02440"></a>02440 <span class="comment">     This just avoids possibly failing to compile the below on such</span>
<a name="l02441"></a>02441 <span class="comment">     systems.  */</span>
<a name="l02442"></a>02442   <span class="keywordflow">return</span> 0;
<a name="l02443"></a>02443 <span class="preprocessor">#else</span>
<a name="l02444"></a>02444 <span class="preprocessor"></span><span class="comment">/* Horrible hack!  Detect Solaris 2.5, because this doesn&#39;t work on 2.5.  */</span>
<a name="l02445"></a>02445 <span class="preprocessor">#if defined (PIOCOPENLWP)       </span><span class="comment">/* Solaris 2.5: bail out.  */</span>
<a name="l02446"></a>02446   <span class="keywordflow">return</span> 0;
<a name="l02447"></a>02447 <span class="preprocessor">#else</span>
<a name="l02448"></a>02448 <span class="preprocessor"></span>  <span class="keyword">struct </span>{
<a name="l02449"></a>02449     <a class="code" href="proc-utils_8h.html#a9ee61b96d4ef1f68f6c83a9852fb46a3">procfs_ctl_t</a> cmd;
<a name="l02450"></a>02450     <span class="keywordtype">char</span> watch[<span class="keyword">sizeof</span> (prwatch_t)];
<a name="l02451"></a>02451   } arg;
<a name="l02452"></a>02452   prwatch_t pwatch;
<a name="l02453"></a>02453 
<a name="l02454"></a>02454   <span class="comment">/* NOTE: cagney/2003-02-01: Even more horrible hack.  Need to</span>
<a name="l02455"></a>02455 <span class="comment">     convert a target address into something that can be stored in a</span>
<a name="l02456"></a>02456 <span class="comment">     native data structure.  */</span>
<a name="l02457"></a>02457 <span class="preprocessor">#ifdef PCAGENT  </span><span class="comment">/* Horrible hack: only defined on Solaris 2.6+ */</span>
<a name="l02458"></a>02458   pwatch.pr_vaddr  = (uintptr_t) procfs_address_to_host_pointer (addr);
<a name="l02459"></a>02459 <span class="preprocessor">#else</span>
<a name="l02460"></a>02460 <span class="preprocessor"></span>  pwatch.pr_vaddr  = (caddr_t) procfs_address_to_host_pointer (addr);
<a name="l02461"></a>02461 <span class="preprocessor">#endif</span>
<a name="l02462"></a>02462 <span class="preprocessor"></span>  pwatch.pr_size   = <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l02463"></a>02463   pwatch.pr_wflags = wflags;
<a name="l02464"></a>02464 <span class="preprocessor">#if defined(NEW_PROC_API) &amp;&amp; defined (PCWATCH)</span>
<a name="l02465"></a>02465 <span class="preprocessor"></span>  arg.cmd = PCWATCH;
<a name="l02466"></a>02466   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (arg.watch, &amp;pwatch, sizeof (prwatch_t));
<a name="l02467"></a>02467   <span class="keywordflow">return</span> (write (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, &amp;arg, sizeof (arg)) == <span class="keyword">sizeof</span> (arg));
<a name="l02468"></a>02468 <span class="preprocessor">#else</span>
<a name="l02469"></a>02469 <span class="preprocessor"></span><span class="preprocessor">#if defined (PIOCSWATCH)</span>
<a name="l02470"></a>02470 <span class="preprocessor"></span>  <span class="keywordflow">return</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSWATCH, &amp;pwatch) &gt;= 0);
<a name="l02471"></a>02471 <span class="preprocessor">#else</span>
<a name="l02472"></a>02472 <span class="preprocessor"></span>  <span class="keywordflow">return</span> 0;     <span class="comment">/* Fail */</span>
<a name="l02473"></a>02473 <span class="preprocessor">#endif</span>
<a name="l02474"></a>02474 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02475"></a>02475 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02476"></a>02476 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02477"></a>02477 <span class="preprocessor"></span>}
<a name="l02478"></a>02478 
<a name="l02479"></a>02479 <span class="preprocessor">#if (defined(__i386__) || defined(__x86_64__)) &amp;&amp; defined (sun)</span>
<a name="l02480"></a>02480 <span class="preprocessor"></span>
<a name="l02481"></a>02481 <span class="preprocessor">#include &lt;sys/sysi86.h&gt;</span>
<a name="l02482"></a>02482 
<a name="l02483"></a>02483 <span class="comment">/* The KEY is actually the value of the lower 16 bits of the GS</span>
<a name="l02484"></a>02484 <span class="comment">   register for the LWP that we&#39;re interested in.  Returns the</span>
<a name="l02485"></a>02485 <span class="comment">   matching ssh struct (LDT entry).  */</span>
<a name="l02486"></a>02486 
<a name="l02487"></a>02487 <span class="keyword">static</span> <span class="keyword">struct </span>ssd *
<a name="l02488"></a>02488 proc_get_LDT_entry (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">int</span> key)
<a name="l02489"></a>02489 {
<a name="l02490"></a>02490   <span class="keyword">static</span> <span class="keyword">struct </span>ssd *ldt_entry = NULL;
<a name="l02491"></a>02491 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l02492"></a>02492 <span class="preprocessor"></span>  <span class="keywordtype">char</span> pathname[<a class="code" href="procfs_8c.html#a516ed8ab3b65b65276525efba4b38d6d">MAX_PROC_NAME_SIZE</a>];
<a name="l02493"></a>02493   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_chain = NULL;
<a name="l02494"></a>02494   <span class="keywordtype">int</span>  fd;
<a name="l02495"></a>02495 
<a name="l02496"></a>02496   <span class="comment">/* Allocate space for one LDT entry.</span>
<a name="l02497"></a>02497 <span class="comment">     This alloc must persist, because we return a pointer to it.  */</span>
<a name="l02498"></a>02498   <span class="keywordflow">if</span> (ldt_entry == NULL)
<a name="l02499"></a>02499     ldt_entry = (<span class="keyword">struct </span>ssd *) <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> ssd));
<a name="l02500"></a>02500 
<a name="l02501"></a>02501   <span class="comment">/* Open the file descriptor for the LDT table.  */</span>
<a name="l02502"></a>02502   sprintf (pathname, <span class="stringliteral">&quot;/proc/%d/ldt&quot;</span>, pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>);
<a name="l02503"></a>02503   <span class="keywordflow">if</span> ((fd = <a class="code" href="procfs_8c.html#a8537de378e19c8806d9837b90505a62d">open_with_retry</a> (pathname, O_RDONLY)) &lt; 0)
<a name="l02504"></a>02504     {
<a name="l02505"></a>02505       <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;proc_get_LDT_entry (open)&quot;</span>, __LINE__);
<a name="l02506"></a>02506       <span class="keywordflow">return</span> NULL;
<a name="l02507"></a>02507     }
<a name="l02508"></a>02508   <span class="comment">/* Make sure it gets closed again!  */</span>
<a name="l02509"></a>02509   old_chain = <a class="code" href="utils_8c.html#ae1c81b8331e815cc346382bc13e20095">make_cleanup_close</a> (fd);
<a name="l02510"></a>02510 
<a name="l02511"></a>02511   <span class="comment">/* Now &#39;read&#39; thru the table, find a match and return it.  */</span>
<a name="l02512"></a>02512   <span class="keywordflow">while</span> (<a class="code" href="expect-read1_8c.html#af32a16ad2dd9e48482f8f790db7dbbd2">read</a> (fd, ldt_entry, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> ssd)) == <span class="keyword">sizeof</span> (<span class="keyword">struct</span> ssd))
<a name="l02513"></a>02513     {
<a name="l02514"></a>02514       <span class="keywordflow">if</span> (ldt_entry-&gt;sel == 0 &amp;&amp;
<a name="l02515"></a>02515           ldt_entry-&gt;bo  == 0 &amp;&amp;
<a name="l02516"></a>02516           ldt_entry-&gt;acc1 == 0 &amp;&amp;
<a name="l02517"></a>02517           ldt_entry-&gt;acc2 == 0)
<a name="l02518"></a>02518         <span class="keywordflow">break</span>;  <span class="comment">/* end of table */</span>
<a name="l02519"></a>02519       <span class="comment">/* If key matches, return this entry.  */</span>
<a name="l02520"></a>02520       <span class="keywordflow">if</span> (ldt_entry-&gt;sel == key)
<a name="l02521"></a>02521         <span class="keywordflow">return</span> ldt_entry;
<a name="l02522"></a>02522     }
<a name="l02523"></a>02523   <span class="comment">/* Loop ended, match not found.  */</span>
<a name="l02524"></a>02524   <span class="keywordflow">return</span> NULL;
<a name="l02525"></a>02525 <span class="preprocessor">#else</span>
<a name="l02526"></a>02526 <span class="preprocessor"></span>  <span class="keywordtype">int</span> nldt, i;
<a name="l02527"></a>02527   <span class="keyword">static</span> <span class="keywordtype">int</span> nalloc = 0;
<a name="l02528"></a>02528 
<a name="l02529"></a>02529   <span class="comment">/* Get the number of LDT entries.  */</span>
<a name="l02530"></a>02530   <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCNLDT, &amp;nldt) &lt; 0)
<a name="l02531"></a>02531     {
<a name="l02532"></a>02532       <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;proc_get_LDT_entry (PIOCNLDT)&quot;</span>, __LINE__);
<a name="l02533"></a>02533       <span class="keywordflow">return</span> NULL;
<a name="l02534"></a>02534     }
<a name="l02535"></a>02535 
<a name="l02536"></a>02536   <span class="comment">/* Allocate space for the number of LDT entries.  */</span>
<a name="l02537"></a>02537   <span class="comment">/* This alloc has to persist, &#39;cause we return a pointer to it.  */</span>
<a name="l02538"></a>02538   <span class="keywordflow">if</span> (nldt &gt; nalloc)
<a name="l02539"></a>02539     {
<a name="l02540"></a>02540       ldt_entry = (<span class="keyword">struct </span>ssd *)
<a name="l02541"></a>02541         <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (ldt_entry, (nldt + 1) * <span class="keyword">sizeof</span> (<span class="keyword">struct </span>ssd));
<a name="l02542"></a>02542       nalloc = nldt;
<a name="l02543"></a>02543     }
<a name="l02544"></a>02544 
<a name="l02545"></a>02545   <span class="comment">/* Read the whole table in one gulp.  */</span>
<a name="l02546"></a>02546   <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCLDT, ldt_entry) &lt; 0)
<a name="l02547"></a>02547     {
<a name="l02548"></a>02548       <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;proc_get_LDT_entry (PIOCLDT)&quot;</span>, __LINE__);
<a name="l02549"></a>02549       <span class="keywordflow">return</span> NULL;
<a name="l02550"></a>02550     }
<a name="l02551"></a>02551 
<a name="l02552"></a>02552   <span class="comment">/* Search the table and return the (first) entry matching &#39;key&#39;.  */</span>
<a name="l02553"></a>02553   <span class="keywordflow">for</span> (i = 0; i &lt; nldt; i++)
<a name="l02554"></a>02554     <span class="keywordflow">if</span> (ldt_entry[i].sel == key)
<a name="l02555"></a>02555       <span class="keywordflow">return</span> &amp;ldt_entry[i];
<a name="l02556"></a>02556 
<a name="l02557"></a>02557   <span class="comment">/* Loop ended, match not found.  */</span>
<a name="l02558"></a>02558   <span class="keywordflow">return</span> NULL;
<a name="l02559"></a>02559 <span class="preprocessor">#endif</span>
<a name="l02560"></a>02560 <span class="preprocessor"></span>}
<a name="l02561"></a>02561 
<a name="l02562"></a>02562 <span class="comment">/* Returns the pointer to the LDT entry of PTID.  */</span>
<a name="l02563"></a>02563 
<a name="l02564"></a>02564 <span class="keyword">struct </span>ssd *
<a name="l02565"></a>02565 procfs_find_LDT_entry (<a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a>)
<a name="l02566"></a>02566 {
<a name="l02567"></a>02567   <a class="code" href="gregset_8h.html#ad358cd20eb83ca9e131c708c8aa14c89">gdb_gregset_t</a> *gregs;
<a name="l02568"></a>02568   <span class="keywordtype">int</span>            key;
<a name="l02569"></a>02569   <a class="code" href="structprocinfo.html">procinfo</a>      *pi;
<a name="l02570"></a>02570 
<a name="l02571"></a>02571   <span class="comment">/* Find procinfo for the lwp.  */</span>
<a name="l02572"></a>02572   <span class="keywordflow">if</span> ((pi = <a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (ptid), <a class="code" href="ptid_8c.html#af5b67a5f356c507b7809af2fa4e63b44">ptid_get_lwp</a> (ptid))) == NULL)
<a name="l02573"></a>02573     {
<a name="l02574"></a>02574       <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs_find_LDT_entry: could not find procinfo for %d:%ld.&quot;</span>),
<a name="l02575"></a>02575                <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (ptid), <a class="code" href="ptid_8c.html#af5b67a5f356c507b7809af2fa4e63b44">ptid_get_lwp</a> (ptid));
<a name="l02576"></a>02576       <span class="keywordflow">return</span> NULL;
<a name="l02577"></a>02577     }
<a name="l02578"></a>02578   <span class="comment">/* get its general registers.  */</span>
<a name="l02579"></a>02579   <span class="keywordflow">if</span> ((gregs = <a class="code" href="procfs_8c.html#a186019d8eb03e08d77a0121384fec317">proc_get_gregs</a> (pi)) == NULL)
<a name="l02580"></a>02580     {
<a name="l02581"></a>02581       <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs_find_LDT_entry: could not read gregs for %d:%ld.&quot;</span>),
<a name="l02582"></a>02582                <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (ptid), <a class="code" href="ptid_8c.html#af5b67a5f356c507b7809af2fa4e63b44">ptid_get_lwp</a> (ptid));
<a name="l02583"></a>02583       <span class="keywordflow">return</span> NULL;
<a name="l02584"></a>02584     }
<a name="l02585"></a>02585   <span class="comment">/* Now extract the GS register&#39;s lower 16 bits.  */</span>
<a name="l02586"></a>02586   key = (*gregs)[GS] &amp; 0xffff;
<a name="l02587"></a>02587 
<a name="l02588"></a>02588   <span class="comment">/* Find the matching entry and return it.  */</span>
<a name="l02589"></a>02589   <span class="keywordflow">return</span> proc_get_LDT_entry (pi, key);
<a name="l02590"></a>02590 }
<a name="l02591"></a>02591 
<a name="l02592"></a>02592 <span class="preprocessor">#endif</span>
<a name="l02593"></a>02593 <span class="preprocessor"></span>
<a name="l02594"></a>02594 <span class="comment">/* =============== END, non-thread part of /proc  &quot;MODULE&quot; =============== */</span>
<a name="l02595"></a>02595 
<a name="l02596"></a>02596 <span class="comment">/* =================== Thread &quot;MODULE&quot; =================== */</span>
<a name="l02597"></a>02597 
<a name="l02598"></a>02598 <span class="comment">/* NOTE: you&#39;ll see more ifdefs and duplication of functions here,</span>
<a name="l02599"></a>02599 <span class="comment">   since there is a different way to do threads on every OS.  */</span>
<a name="l02600"></a>02600 
<a name="l02601"></a>02601 <span class="comment">/* Returns the number of threads for the process.  */</span>
<a name="l02602"></a>02602 
<a name="l02603"></a>02603 <span class="preprocessor">#if defined (PIOCNTHR) &amp;&amp; defined (PIOCTLIST)</span>
<a name="l02604"></a>02604 <span class="preprocessor"></span><span class="comment">/* OSF version */</span>
<a name="l02605"></a>02605 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02606"></a>02606 <a class="code" href="procfs_8c.html#a011be1a5ae96e7e39bb1dc60b512e977">proc_get_nthreads</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02607"></a>02607 {
<a name="l02608"></a>02608   <span class="keywordtype">int</span> nthreads = 0;
<a name="l02609"></a>02609 
<a name="l02610"></a>02610   <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCNTHR, &amp;nthreads) &lt; 0)
<a name="l02611"></a>02611     <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;procfs: PIOCNTHR failed&quot;</span>, __LINE__);
<a name="l02612"></a>02612 
<a name="l02613"></a>02613   <span class="keywordflow">return</span> nthreads;
<a name="l02614"></a>02614 }
<a name="l02615"></a>02615 
<a name="l02616"></a>02616 <span class="preprocessor">#else</span>
<a name="l02617"></a>02617 <span class="preprocessor"></span><span class="preprocessor">#if defined (SYS_lwpcreate) || defined (SYS_lwp_create) </span><span class="comment">/* FIXME: multiple */</span>
<a name="l02618"></a>02618 <span class="comment">/* Solaris version */</span>
<a name="l02619"></a>02619 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02620"></a>02620 <a class="code" href="procfs_8c.html#a011be1a5ae96e7e39bb1dc60b512e977">proc_get_nthreads</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02621"></a>02621 {
<a name="l02622"></a>02622   <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l02623"></a>02623     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l02624"></a>02624       <span class="keywordflow">return</span> 0;
<a name="l02625"></a>02625 
<a name="l02626"></a>02626   <span class="comment">/* NEW_PROC_API: only works for the process procinfo, because the</span>
<a name="l02627"></a>02627 <span class="comment">     LWP procinfos do not get prstatus filled in.  */</span>
<a name="l02628"></a>02628 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l02629"></a>02629 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)     <span class="comment">/* Find the parent process procinfo.  */</span>
<a name="l02630"></a>02630     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l02631"></a>02631 <span class="preprocessor">#endif</span>
<a name="l02632"></a>02632 <span class="preprocessor"></span>  <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_nlwp;
<a name="l02633"></a>02633 }
<a name="l02634"></a>02634 
<a name="l02635"></a>02635 <span class="preprocessor">#else</span>
<a name="l02636"></a>02636 <span class="preprocessor"></span><span class="comment">/* Default version */</span>
<a name="l02637"></a>02637 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02638"></a><a class="code" href="procfs_8c.html#a011be1a5ae96e7e39bb1dc60b512e977">02638</a> <a class="code" href="procfs_8c.html#a011be1a5ae96e7e39bb1dc60b512e977">proc_get_nthreads</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02639"></a>02639 {
<a name="l02640"></a>02640   <span class="keywordflow">return</span> 0;
<a name="l02641"></a>02641 }
<a name="l02642"></a>02642 <span class="preprocessor">#endif</span>
<a name="l02643"></a>02643 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02644"></a>02644 <span class="preprocessor"></span>
<a name="l02645"></a>02645 <span class="comment">/* LWP version.</span>
<a name="l02646"></a>02646 <span class="comment"></span>
<a name="l02647"></a>02647 <span class="comment">   Return the ID of the thread that had an event of interest.</span>
<a name="l02648"></a>02648 <span class="comment">   (ie. the one that hit a breakpoint or other traced event).  All</span>
<a name="l02649"></a>02649 <span class="comment">   other things being equal, this should be the ID of a thread that is</span>
<a name="l02650"></a>02650 <span class="comment">   currently executing.  */</span>
<a name="l02651"></a>02651 
<a name="l02652"></a>02652 <span class="preprocessor">#if defined (SYS_lwpcreate) || defined (SYS_lwp_create) </span><span class="comment">/* FIXME: multiple */</span>
<a name="l02653"></a>02653 <span class="comment">/* Solaris version */</span>
<a name="l02654"></a>02654 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02655"></a>02655 <a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">proc_get_current_thread</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02656"></a>02656 {
<a name="l02657"></a>02657   <span class="comment">/* Note: this should be applied to the root procinfo for the</span>
<a name="l02658"></a>02658 <span class="comment">     process, not to the procinfo for an LWP.  If applied to the</span>
<a name="l02659"></a>02659 <span class="comment">     procinfo for an LWP, it will simply return that LWP&#39;s ID.  In</span>
<a name="l02660"></a>02660 <span class="comment">     that case, find the parent process procinfo.  */</span>
<a name="l02661"></a>02661 
<a name="l02662"></a>02662   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l02663"></a>02663     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l02664"></a>02664 
<a name="l02665"></a>02665   <span class="keywordflow">if</span> (!pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>)
<a name="l02666"></a>02666     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l02667"></a>02667       <span class="keywordflow">return</span> 0;
<a name="l02668"></a>02668 
<a name="l02669"></a>02669 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l02670"></a>02670 <span class="preprocessor"></span>  <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_lwp.pr_lwpid;
<a name="l02671"></a>02671 <span class="preprocessor">#else</span>
<a name="l02672"></a>02672 <span class="preprocessor"></span>  <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_who;
<a name="l02673"></a>02673 <span class="preprocessor">#endif</span>
<a name="l02674"></a>02674 <span class="preprocessor"></span>}
<a name="l02675"></a>02675 
<a name="l02676"></a>02676 <span class="preprocessor">#else</span>
<a name="l02677"></a>02677 <span class="preprocessor"></span><span class="preprocessor">#if defined (PIOCNTHR) &amp;&amp; defined (PIOCTLIST)</span>
<a name="l02678"></a>02678 <span class="preprocessor"></span><span class="comment">/* OSF version */</span>
<a name="l02679"></a>02679 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02680"></a>02680 <a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">proc_get_current_thread</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02681"></a>02681 {
<a name="l02682"></a>02682 <span class="preprocessor">#if 0   </span><span class="comment">/* FIXME: not ready for prime time?  */</span>
<a name="l02683"></a>02683   <span class="keywordflow">return</span> pi-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>.pr_tid;
<a name="l02684"></a>02684 <span class="preprocessor">#else</span>
<a name="l02685"></a>02685 <span class="preprocessor"></span>  <span class="keywordflow">return</span> 0;
<a name="l02686"></a>02686 <span class="preprocessor">#endif</span>
<a name="l02687"></a>02687 <span class="preprocessor"></span>}
<a name="l02688"></a>02688 
<a name="l02689"></a>02689 <span class="preprocessor">#else</span>
<a name="l02690"></a>02690 <span class="preprocessor"></span><span class="comment">/* Default version */</span>
<a name="l02691"></a>02691 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02692"></a><a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">02692</a> <a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">proc_get_current_thread</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02693"></a>02693 {
<a name="l02694"></a>02694   <span class="keywordflow">return</span> 0;
<a name="l02695"></a>02695 }
<a name="l02696"></a>02696 
<a name="l02697"></a>02697 <span class="preprocessor">#endif</span>
<a name="l02698"></a>02698 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02699"></a>02699 <span class="preprocessor"></span>
<a name="l02700"></a>02700 <span class="comment">/* Discover the IDs of all the threads within the process, and create</span>
<a name="l02701"></a>02701 <span class="comment">   a procinfo for each of them (chained to the parent).  This</span>
<a name="l02702"></a>02702 <span class="comment">   unfortunately requires a different method on every OS.  Returns</span>
<a name="l02703"></a>02703 <span class="comment">   non-zero for success, zero for failure.  */</span>
<a name="l02704"></a>02704 
<a name="l02705"></a>02705 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02706"></a><a class="code" href="procfs_8c.html#a1bfb068a66b1798f81df0a03c34d3c82">02706</a> <a class="code" href="procfs_8c.html#a1bfb068a66b1798f81df0a03c34d3c82">proc_delete_dead_threads</a> (<a class="code" href="structprocinfo.html">procinfo</a> *parent, <a class="code" href="structprocinfo.html">procinfo</a> *thread, <span class="keywordtype">void</span> *<a class="code" href="corelow_8c.html#ac54c1aef0966c38fc155dec95a38db50">ignore</a>)
<a name="l02707"></a>02707 {
<a name="l02708"></a>02708   <span class="keywordflow">if</span> (thread &amp;&amp; parent) <span class="comment">/* sanity */</span>
<a name="l02709"></a>02709     {
<a name="l02710"></a>02710       thread-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 0;
<a name="l02711"></a>02711       <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (thread))
<a name="l02712"></a>02712         <a class="code" href="procfs_8c.html#afa82c8d35661410a78f95c75c3987575">destroy_one_procinfo</a> (&amp;parent-&gt;<a class="code" href="structprocinfo.html#ac9b6c53503df0c67d97f747b041fa10f">thread_list</a>, thread);
<a name="l02713"></a>02713     }
<a name="l02714"></a>02714   <span class="keywordflow">return</span> 0;     <span class="comment">/* keep iterating */</span>
<a name="l02715"></a>02715 }
<a name="l02716"></a>02716 
<a name="l02717"></a>02717 <span class="preprocessor">#if defined (PIOCLSTATUS)</span>
<a name="l02718"></a>02718 <span class="preprocessor"></span><span class="comment">/* Solaris 2.5 (ioctl) version */</span>
<a name="l02719"></a>02719 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02720"></a>02720 <a class="code" href="procfs_8c.html#a9c8694c7c5546e9cd62a960bc350b018">proc_update_threads</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02721"></a>02721 {
<a name="l02722"></a>02722   gdb_prstatus_t *prstatus;
<a name="l02723"></a>02723   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_chain = NULL;
<a name="l02724"></a>02724   <a class="code" href="structprocinfo.html">procinfo</a> *thread;
<a name="l02725"></a>02725   <span class="keywordtype">int</span> nlwp, i;
<a name="l02726"></a>02726 
<a name="l02727"></a>02727   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l02728"></a>02728 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l02729"></a>02729 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l02730"></a>02730 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l02731"></a>02731 
<a name="l02732"></a>02732   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l02733"></a>02733     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l02734"></a>02734 
<a name="l02735"></a>02735   <a class="code" href="procfs_8c.html#a5fcfad306ae6b00c6d9b3c201d568580">proc_iterate_over_threads</a> (pi, <a class="code" href="procfs_8c.html#a1bfb068a66b1798f81df0a03c34d3c82">proc_delete_dead_threads</a>, NULL);
<a name="l02736"></a>02736 
<a name="l02737"></a>02737   <span class="keywordflow">if</span> ((nlwp = <a class="code" href="procfs_8c.html#a011be1a5ae96e7e39bb1dc60b512e977">proc_get_nthreads</a> (pi)) &lt;= 1)
<a name="l02738"></a>02738     <span class="keywordflow">return</span> 1;   <span class="comment">/* Process is not multi-threaded; nothing to do.  */</span>
<a name="l02739"></a>02739 
<a name="l02740"></a>02740   prstatus = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (gdb_prstatus_t) * (nlwp + 1));
<a name="l02741"></a>02741 
<a name="l02742"></a>02742   old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, prstatus);
<a name="l02743"></a>02743   <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCLSTATUS, prstatus) &lt; 0)
<a name="l02744"></a>02744     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;update_threads (PIOCLSTATUS)&quot;</span>, __LINE__);
<a name="l02745"></a>02745 
<a name="l02746"></a>02746   <span class="comment">/* Skip element zero, which represents the process as a whole.  */</span>
<a name="l02747"></a>02747   <span class="keywordflow">for</span> (i = 1; i &lt; nlwp + 1; i++)
<a name="l02748"></a>02748     {
<a name="l02749"></a>02749       <span class="keywordflow">if</span> ((thread = <a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, prstatus[i].pr_who)) == NULL)
<a name="l02750"></a>02750         <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;update_threads, create_procinfo&quot;</span>, __LINE__);
<a name="l02751"></a>02751 
<a name="l02752"></a>02752       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (&amp;thread-&gt;<a class="code" href="structprocinfo.html#a55a3784721d5ec25a79a381486aa360f">prstatus</a>, &amp;prstatus[i], sizeof (*prstatus));
<a name="l02753"></a>02753       thread-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 1;
<a name="l02754"></a>02754     }
<a name="l02755"></a>02755   pi-&gt;<a class="code" href="structprocinfo.html#a29eed4e1916725d4db440b31b010a2a3">threads_valid</a> = 1;
<a name="l02756"></a>02756   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l02757"></a>02757   <span class="keywordflow">return</span> 1;
<a name="l02758"></a>02758 }
<a name="l02759"></a>02759 <span class="preprocessor">#else</span>
<a name="l02760"></a>02760 <span class="preprocessor"></span><span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l02761"></a>02761 <span class="preprocessor"></span><span class="comment">/* Solaris 6 (and later) version.  */</span>
<a name="l02762"></a>02762 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02763"></a>02763 <a class="code" href="nto-procfs_8c.html#aaeffea92def975743eb7025b70de57d7">do_closedir_cleanup</a> (<span class="keywordtype">void</span> *dir)
<a name="l02764"></a>02764 {
<a name="l02765"></a>02765   closedir (dir);
<a name="l02766"></a>02766 }
<a name="l02767"></a>02767 
<a name="l02768"></a>02768 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02769"></a>02769 <a class="code" href="procfs_8c.html#a9c8694c7c5546e9cd62a960bc350b018">proc_update_threads</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02770"></a>02770 {
<a name="l02771"></a>02771   <span class="keywordtype">char</span> pathname[<a class="code" href="procfs_8c.html#a516ed8ab3b65b65276525efba4b38d6d">MAX_PROC_NAME_SIZE</a> + 16];
<a name="l02772"></a>02772   <span class="keyword">struct </span><a class="code" href="gdb__dirent_8h.html#a89957e9be80ef12a50eb4eca72ecd888">dirent</a> *direntry;
<a name="l02773"></a>02773   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_chain = NULL;
<a name="l02774"></a>02774   <a class="code" href="structprocinfo.html">procinfo</a> *thread;
<a name="l02775"></a>02775   DIR *dirp;
<a name="l02776"></a>02776   <span class="keywordtype">int</span> lwpid;
<a name="l02777"></a>02777 
<a name="l02778"></a>02778   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l02779"></a>02779 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l02780"></a>02780 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l02781"></a>02781 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l02782"></a>02782 
<a name="l02783"></a>02783   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l02784"></a>02784     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l02785"></a>02785 
<a name="l02786"></a>02786   <a class="code" href="procfs_8c.html#a5fcfad306ae6b00c6d9b3c201d568580">proc_iterate_over_threads</a> (pi, <a class="code" href="procfs_8c.html#a1bfb068a66b1798f81df0a03c34d3c82">proc_delete_dead_threads</a>, NULL);
<a name="l02787"></a>02787 
<a name="l02788"></a>02788   <span class="comment">/* Note: this brute-force method was originally devised for Unixware</span>
<a name="l02789"></a>02789 <span class="comment">     (support removed since), and will also work on Solaris 2.6 and</span>
<a name="l02790"></a>02790 <span class="comment">     2.7.  The original comment mentioned the existence of a much</span>
<a name="l02791"></a>02791 <span class="comment">     simpler and more elegant way to do this on Solaris, but didn&#39;t</span>
<a name="l02792"></a>02792 <span class="comment">     point out what that was.  */</span>
<a name="l02793"></a>02793 
<a name="l02794"></a>02794   strcpy (pathname, pi-&gt;<a class="code" href="structprocinfo.html#aa16ad0bc5ac326c369a69f8a8b92bd5e">pathname</a>);
<a name="l02795"></a>02795   strcat (pathname, <span class="stringliteral">&quot;/lwp&quot;</span>);
<a name="l02796"></a>02796   <span class="keywordflow">if</span> ((dirp = opendir (pathname)) == NULL)
<a name="l02797"></a>02797     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;update_threads, opendir&quot;</span>, __LINE__);
<a name="l02798"></a>02798 
<a name="l02799"></a>02799   old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="nto-procfs_8c.html#aaeffea92def975743eb7025b70de57d7">do_closedir_cleanup</a>, dirp);
<a name="l02800"></a>02800   <span class="keywordflow">while</span> ((direntry = readdir (dirp)) != NULL)
<a name="l02801"></a>02801     <span class="keywordflow">if</span> (direntry-&gt;d_name[0] != <span class="charliteral">&#39;.&#39;</span>)             <span class="comment">/* skip &#39;.&#39; and &#39;..&#39; */</span>
<a name="l02802"></a>02802       {
<a name="l02803"></a>02803         lwpid = atoi (&amp;direntry-&gt;d_name[0]);
<a name="l02804"></a>02804         <span class="keywordflow">if</span> ((thread = <a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, lwpid)) == NULL)
<a name="l02805"></a>02805           <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;update_threads, create_procinfo&quot;</span>, __LINE__);
<a name="l02806"></a>02806       }
<a name="l02807"></a>02807   pi-&gt;<a class="code" href="structprocinfo.html#a29eed4e1916725d4db440b31b010a2a3">threads_valid</a> = 1;
<a name="l02808"></a>02808   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l02809"></a>02809   <span class="keywordflow">return</span> 1;
<a name="l02810"></a>02810 }
<a name="l02811"></a>02811 <span class="preprocessor">#else</span>
<a name="l02812"></a>02812 <span class="preprocessor"></span><span class="preprocessor">#ifdef PIOCTLIST</span>
<a name="l02813"></a>02813 <span class="preprocessor"></span><span class="comment">/* OSF version */</span>
<a name="l02814"></a>02814 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02815"></a>02815 <a class="code" href="procfs_8c.html#a9c8694c7c5546e9cd62a960bc350b018">proc_update_threads</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02816"></a>02816 {
<a name="l02817"></a>02817   <span class="keywordtype">int</span> nthreads, i;
<a name="l02818"></a>02818   tid_t *threads;
<a name="l02819"></a>02819 
<a name="l02820"></a>02820   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l02821"></a>02821 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l02822"></a>02822 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l02823"></a>02823 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l02824"></a>02824 
<a name="l02825"></a>02825   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l02826"></a>02826     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l02827"></a>02827 
<a name="l02828"></a>02828   <a class="code" href="procfs_8c.html#a5fcfad306ae6b00c6d9b3c201d568580">proc_iterate_over_threads</a> (pi, <a class="code" href="procfs_8c.html#a1bfb068a66b1798f81df0a03c34d3c82">proc_delete_dead_threads</a>, NULL);
<a name="l02829"></a>02829 
<a name="l02830"></a>02830   nthreads = <a class="code" href="procfs_8c.html#a011be1a5ae96e7e39bb1dc60b512e977">proc_get_nthreads</a> (pi);
<a name="l02831"></a>02831   <span class="keywordflow">if</span> (nthreads &lt; 2)
<a name="l02832"></a>02832     <span class="keywordflow">return</span> 0;           <span class="comment">/* Nothing to do for 1 or fewer threads.  */</span>
<a name="l02833"></a>02833 
<a name="l02834"></a>02834   threads = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (nthreads * <span class="keyword">sizeof</span> (tid_t));
<a name="l02835"></a>02835 
<a name="l02836"></a>02836   <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCTLIST, threads) &lt; 0)
<a name="l02837"></a>02837     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;procfs: update_threads (PIOCTLIST)&quot;</span>, __LINE__);
<a name="l02838"></a>02838 
<a name="l02839"></a>02839   <span class="keywordflow">for</span> (i = 0; i &lt; nthreads; i++)
<a name="l02840"></a>02840     {
<a name="l02841"></a>02841       <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, threads[i]))
<a name="l02842"></a>02842         <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a>  (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, threads[i]))
<a name="l02843"></a>02843           <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;update_threads, create_procinfo&quot;</span>, __LINE__);
<a name="l02844"></a>02844     }
<a name="l02845"></a>02845   pi-&gt;<a class="code" href="structprocinfo.html#a29eed4e1916725d4db440b31b010a2a3">threads_valid</a> = 1;
<a name="l02846"></a>02846   <span class="keywordflow">return</span> 1;
<a name="l02847"></a>02847 }
<a name="l02848"></a>02848 <span class="preprocessor">#else</span>
<a name="l02849"></a>02849 <span class="preprocessor"></span><span class="comment">/* Default version */</span>
<a name="l02850"></a>02850 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02851"></a><a class="code" href="procfs_8c.html#a9c8694c7c5546e9cd62a960bc350b018">02851</a> <a class="code" href="procfs_8c.html#a9c8694c7c5546e9cd62a960bc350b018">proc_update_threads</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02852"></a>02852 {
<a name="l02853"></a>02853   <span class="keywordflow">return</span> 0;
<a name="l02854"></a>02854 }
<a name="l02855"></a>02855 <span class="preprocessor">#endif  </span><span class="comment">/* OSF PIOCTLIST */</span>
<a name="l02856"></a>02856 <span class="preprocessor">#endif  </span><span class="comment">/* NEW_PROC_API   */</span>
<a name="l02857"></a>02857 <span class="preprocessor">#endif  </span><span class="comment">/* SOL 2.5 PIOCLSTATUS */</span>
<a name="l02858"></a>02858 
<a name="l02859"></a>02859 <span class="comment">/* Given a pointer to a function, call that function once for each lwp</span>
<a name="l02860"></a>02860 <span class="comment">   in the procinfo list, until the function returns non-zero, in which</span>
<a name="l02861"></a>02861 <span class="comment">   event return the value returned by the function.</span>
<a name="l02862"></a>02862 <span class="comment"></span>
<a name="l02863"></a>02863 <span class="comment">   Note: this function does NOT call update_threads.  If you want to</span>
<a name="l02864"></a>02864 <span class="comment">   discover new threads first, you must call that function explicitly.</span>
<a name="l02865"></a>02865 <span class="comment">   This function just makes a quick pass over the currently-known</span>
<a name="l02866"></a>02866 <span class="comment">   procinfos.</span>
<a name="l02867"></a>02867 <span class="comment"></span>
<a name="l02868"></a>02868 <span class="comment">   PI is the parent process procinfo.  FUNC is the per-thread</span>
<a name="l02869"></a>02869 <span class="comment">   function.  PTR is an opaque parameter for function.  Returns the</span>
<a name="l02870"></a>02870 <span class="comment">   first non-zero return value from the callee, or zero.  */</span>
<a name="l02871"></a>02871 
<a name="l02872"></a>02872 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02873"></a><a class="code" href="procfs_8c.html#a5fcfad306ae6b00c6d9b3c201d568580">02873</a> <a class="code" href="procfs_8c.html#a5fcfad306ae6b00c6d9b3c201d568580">proc_iterate_over_threads</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi,
<a name="l02874"></a>02874                            <span class="keywordtype">int</span> (*<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>) (<a class="code" href="structprocinfo.html">procinfo</a> *, <a class="code" href="structprocinfo.html">procinfo</a> *, <span class="keywordtype">void</span> *),
<a name="l02875"></a>02875                            <span class="keywordtype">void</span> *ptr)
<a name="l02876"></a>02876 {
<a name="l02877"></a>02877   <a class="code" href="structprocinfo.html">procinfo</a> *thread, *<a class="code" href="structcleanup.html#ab2180fdccd25b4babed9353144358172">next</a>;
<a name="l02878"></a>02878   <span class="keywordtype">int</span> retval = 0;
<a name="l02879"></a>02879 
<a name="l02880"></a>02880   <span class="comment">/* We should never have to apply this operation to any procinfo</span>
<a name="l02881"></a>02881 <span class="comment">     except the one for the main process.  If that ever changes for</span>
<a name="l02882"></a>02882 <span class="comment">     any reason, then take out the following clause and replace it</span>
<a name="l02883"></a>02883 <span class="comment">     with one that makes sure the ctl_fd is open.  */</span>
<a name="l02884"></a>02884 
<a name="l02885"></a>02885   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l02886"></a>02886     pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, 0);
<a name="l02887"></a>02887 
<a name="l02888"></a>02888   <span class="keywordflow">for</span> (thread = pi-&gt;<a class="code" href="structprocinfo.html#ac9b6c53503df0c67d97f747b041fa10f">thread_list</a>; thread != NULL; thread = next)
<a name="l02889"></a>02889     {
<a name="l02890"></a>02890       next = thread-&gt;<a class="code" href="structprocinfo.html#a423589ec10ab03a958088139858eeb8d">next</a>;      <span class="comment">/* In case thread is destroyed.  */</span>
<a name="l02891"></a>02891       <span class="keywordflow">if</span> ((retval = (*<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>) (pi, thread, ptr)) != 0)
<a name="l02892"></a>02892         <span class="keywordflow">break</span>;
<a name="l02893"></a>02893     }
<a name="l02894"></a>02894 
<a name="l02895"></a>02895   <span class="keywordflow">return</span> retval;
<a name="l02896"></a>02896 }
<a name="l02897"></a>02897 
<a name="l02898"></a>02898 <span class="comment">/* =================== END, Thread &quot;MODULE&quot; =================== */</span>
<a name="l02899"></a>02899 
<a name="l02900"></a>02900 <span class="comment">/* =================== END, /proc  &quot;MODULE&quot; =================== */</span>
<a name="l02901"></a>02901 
<a name="l02902"></a>02902 <span class="comment">/* ===================  GDB  &quot;MODULE&quot; =================== */</span>
<a name="l02903"></a>02903 
<a name="l02904"></a>02904 <span class="comment">/* Here are all of the gdb target vector functions and their</span>
<a name="l02905"></a>02905 <span class="comment">   friends.  */</span>
<a name="l02906"></a>02906 
<a name="l02907"></a>02907 <span class="keyword">static</span> <a class="code" href="structptid.html">ptid_t</a> <a class="code" href="procfs_8c.html#af41d7a4d0a797c9991aa58bcc53d7e08">do_attach</a> (<a class="code" href="structptid.html">ptid_t</a> ptid);
<a name="l02908"></a>02908 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#a254f9040db8c0382864ac9a23c6b3fcc">do_detach</a> (<span class="keywordtype">int</span> signo);
<a name="l02909"></a>02909 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="procfs_8c.html#ae027347db869ac7b72aa4a12608fb54b">proc_trace_syscalls_1</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">int</span> syscallnum,
<a name="l02910"></a>02910                                    <span class="keywordtype">int</span> entry_or_exit, <span class="keywordtype">int</span> mode, <span class="keywordtype">int</span> from_tty);
<a name="l02911"></a>02911 
<a name="l02912"></a>02912 <span class="comment">/* On mips-irix, we need to insert a breakpoint at __dbx_link during</span>
<a name="l02913"></a>02913 <span class="comment">   the startup phase.  The following two variables are used to record</span>
<a name="l02914"></a>02914 <span class="comment">   the address of the breakpoint, and the code that was replaced by</span>
<a name="l02915"></a>02915 <span class="comment">   a breakpoint.  */</span>
<a name="l02916"></a><a class="code" href="procfs_8c.html#a68c42765a585ea0e5830e88b5457569f">02916</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="procfs_8c.html#a68c42765a585ea0e5830e88b5457569f">dbx_link_bpt_addr</a> = 0;
<a name="l02917"></a><a class="code" href="procfs_8c.html#aa0ca62006e545d6895e243d22cd2bee3">02917</a> <span class="keyword">static</span> <span class="keywordtype">void</span> *<a class="code" href="procfs_8c.html#aa0ca62006e545d6895e243d22cd2bee3">dbx_link_bpt</a>;
<a name="l02918"></a>02918 
<a name="l02919"></a>02919 <span class="comment">/* Sets up the inferior to be debugged.  Registers to trace signals,</span>
<a name="l02920"></a>02920 <span class="comment">   hardware faults, and syscalls.  Note: does not set RLC flag: caller</span>
<a name="l02921"></a>02921 <span class="comment">   may want to customize that.  Returns zero for success (note!</span>
<a name="l02922"></a>02922 <span class="comment">   unlike most functions in this module); on failure, returns the LINE</span>
<a name="l02923"></a>02923 <span class="comment">   NUMBER where it failed!  */</span>
<a name="l02924"></a>02924 
<a name="l02925"></a>02925 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02926"></a><a class="code" href="procfs_8c.html#a80e7d9aa440370eb496a13d228ff3e69">02926</a> <a class="code" href="procfs_8c.html#a80e7d9aa440370eb496a13d228ff3e69">procfs_debug_inferior</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l02927"></a>02927 {
<a name="l02928"></a>02928   fltset_t traced_faults;
<a name="l02929"></a>02929   gdb_sigset_t traced_signals;
<a name="l02930"></a>02930   sysset_t *traced_syscall_entries;
<a name="l02931"></a>02931   sysset_t *traced_syscall_exits;
<a name="l02932"></a>02932   <span class="keywordtype">int</span> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l02933"></a>02933 
<a name="l02934"></a>02934 <span class="preprocessor">#ifdef PROCFS_DONT_TRACE_FAULTS</span>
<a name="l02935"></a>02935 <span class="preprocessor"></span>  <span class="comment">/* On some systems (OSF), we don&#39;t trace hardware faults.</span>
<a name="l02936"></a>02936 <span class="comment">     Apparently it&#39;s enough that we catch them as signals.</span>
<a name="l02937"></a>02937 <span class="comment">     Wonder why we don&#39;t just do that in general?  */</span>
<a name="l02938"></a>02938   premptyset (&amp;traced_faults);          <span class="comment">/* don&#39;t trace faults.  */</span>
<a name="l02939"></a>02939 <span class="preprocessor">#else</span>
<a name="l02940"></a>02940 <span class="preprocessor"></span>  <span class="comment">/* Register to trace hardware faults in the child.  */</span>
<a name="l02941"></a>02941   prfillset (&amp;traced_faults);           <span class="comment">/* trace all faults...  */</span>
<a name="l02942"></a>02942   <a class="code" href="procfs_8c.html#a15c2ad85ffb214687d7804f6b67ccd30">gdb_prdelset</a>  (&amp;traced_faults, FLTPAGE);      <span class="comment">/* except page fault.  */</span>
<a name="l02943"></a>02943 <span class="preprocessor">#endif</span>
<a name="l02944"></a>02944 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#af0ddd9f46992fe62b051be4c4f014bc3">proc_set_traced_faults</a>  (pi, &amp;traced_faults))
<a name="l02945"></a>02945     <span class="keywordflow">return</span> __LINE__;
<a name="l02946"></a>02946 
<a name="l02947"></a>02947   <span class="comment">/* Initially, register to trace all signals in the child.  */</span>
<a name="l02948"></a>02948   prfillset (&amp;traced_signals);
<a name="l02949"></a>02949   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#af04151458bd3246bc210bc06eae93f66">proc_set_traced_signals</a> (pi, &amp;traced_signals))
<a name="l02950"></a>02950     <span class="keywordflow">return</span> __LINE__;
<a name="l02951"></a>02951 
<a name="l02952"></a>02952 
<a name="l02953"></a>02953   <span class="comment">/* Register to trace the &#39;exit&#39; system call (on entry).  */</span>
<a name="l02954"></a>02954   traced_syscall_entries = <a class="code" href="procfs_8c.html#a46e37b7eaec868b43af27d24b556e9c9">sysset_t_alloc</a> (pi);
<a name="l02955"></a>02955   <a class="code" href="procfs_8c.html#a59f0624d8796729e70bea1dda0394b81">gdb_premptysysset</a> (traced_syscall_entries);
<a name="l02956"></a>02956 <span class="preprocessor">#ifdef SYS_exit</span>
<a name="l02957"></a>02957 <span class="preprocessor"></span>  <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (traced_syscall_entries, SYS_exit);
<a name="l02958"></a>02958 <span class="preprocessor">#endif</span>
<a name="l02959"></a>02959 <span class="preprocessor"></span><span class="preprocessor">#ifdef SYS_lwpexit</span>
<a name="l02960"></a>02960 <span class="preprocessor"></span>  <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (traced_syscall_entries, SYS_lwpexit);<span class="comment">/* And _lwp_exit...  */</span>
<a name="l02961"></a>02961 <span class="preprocessor">#endif</span>
<a name="l02962"></a>02962 <span class="preprocessor"></span><span class="preprocessor">#ifdef SYS_lwp_exit</span>
<a name="l02963"></a>02963 <span class="preprocessor"></span>  <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (traced_syscall_entries, SYS_lwp_exit);
<a name="l02964"></a>02964 <span class="preprocessor">#endif</span>
<a name="l02965"></a>02965 <span class="preprocessor"></span><span class="preprocessor">#ifdef DYNAMIC_SYSCALLS</span>
<a name="l02966"></a>02966 <span class="preprocessor"></span>  {
<a name="l02967"></a>02967     <span class="keywordtype">int</span> callnum = find_syscall (pi, <span class="stringliteral">&quot;_exit&quot;</span>);
<a name="l02968"></a>02968 
<a name="l02969"></a>02969     <span class="keywordflow">if</span> (callnum &gt;= 0)
<a name="l02970"></a>02970       <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (traced_syscall_entries, callnum);
<a name="l02971"></a>02971   }
<a name="l02972"></a>02972 <span class="preprocessor">#endif</span>
<a name="l02973"></a>02973 <span class="preprocessor"></span>
<a name="l02974"></a>02974   status = <a class="code" href="procfs_8c.html#a84e53147df27900c8c107d200c34b795">proc_set_traced_sysentry</a> (pi, traced_syscall_entries);
<a name="l02975"></a>02975   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (traced_syscall_entries);
<a name="l02976"></a>02976   <span class="keywordflow">if</span> (!status)
<a name="l02977"></a>02977     <span class="keywordflow">return</span> __LINE__;
<a name="l02978"></a>02978 
<a name="l02979"></a>02979 <span class="preprocessor">#ifdef PRFS_STOPEXEC    </span><span class="comment">/* defined on OSF */</span>
<a name="l02980"></a>02980   <span class="comment">/* OSF method for tracing exec syscalls.  Quoting:</span>
<a name="l02981"></a>02981 <span class="comment">     Under Alpha OSF/1 we have to use a PIOCSSPCACT ioctl to trace</span>
<a name="l02982"></a>02982 <span class="comment">     exits from exec system calls because of the user level loader.  */</span>
<a name="l02983"></a>02983   <span class="comment">/* FIXME: make nice and maybe move into an access function.  */</span>
<a name="l02984"></a>02984   {
<a name="l02985"></a>02985     <span class="keywordtype">int</span> prfs_flags;
<a name="l02986"></a>02986 
<a name="l02987"></a>02987     <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCGSPCACT, &amp;prfs_flags) &lt; 0)
<a name="l02988"></a>02988       <span class="keywordflow">return</span> __LINE__;
<a name="l02989"></a>02989 
<a name="l02990"></a>02990     prfs_flags |= PRFS_STOPEXEC;
<a name="l02991"></a>02991 
<a name="l02992"></a>02992     <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSSPCACT, &amp;prfs_flags) &lt; 0)
<a name="l02993"></a>02993       <span class="keywordflow">return</span> __LINE__;
<a name="l02994"></a>02994   }
<a name="l02995"></a>02995 <span class="preprocessor">#else </span><span class="comment">/* not PRFS_STOPEXEC */</span>
<a name="l02996"></a>02996   <span class="comment">/* Everyone else&#39;s (except OSF) method for tracing exec syscalls.  */</span>
<a name="l02997"></a>02997   <span class="comment">/* GW: Rationale...</span>
<a name="l02998"></a>02998 <span class="comment">     Not all systems with /proc have all the exec* syscalls with the same</span>
<a name="l02999"></a>02999 <span class="comment">     names.  On the SGI, for example, there is no SYS_exec, but there</span>
<a name="l03000"></a>03000 <span class="comment">     *is* a SYS_execv.  So, we try to account for that.  */</span>
<a name="l03001"></a>03001 
<a name="l03002"></a>03002   traced_syscall_exits = <a class="code" href="procfs_8c.html#a46e37b7eaec868b43af27d24b556e9c9">sysset_t_alloc</a> (pi);
<a name="l03003"></a>03003   <a class="code" href="procfs_8c.html#a59f0624d8796729e70bea1dda0394b81">gdb_premptysysset</a> (traced_syscall_exits);
<a name="l03004"></a>03004 <span class="preprocessor">#ifdef SYS_exec</span>
<a name="l03005"></a>03005 <span class="preprocessor"></span>  <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (traced_syscall_exits, SYS_exec);
<a name="l03006"></a>03006 <span class="preprocessor">#endif</span>
<a name="l03007"></a>03007 <span class="preprocessor"></span><span class="preprocessor">#ifdef SYS_execve</span>
<a name="l03008"></a>03008 <span class="preprocessor"></span>  <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (traced_syscall_exits, SYS_execve);
<a name="l03009"></a>03009 <span class="preprocessor">#endif</span>
<a name="l03010"></a>03010 <span class="preprocessor"></span><span class="preprocessor">#ifdef SYS_execv</span>
<a name="l03011"></a>03011 <span class="preprocessor"></span>  <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (traced_syscall_exits, SYS_execv);
<a name="l03012"></a>03012 <span class="preprocessor">#endif</span>
<a name="l03013"></a>03013 <span class="preprocessor"></span>
<a name="l03014"></a>03014 <span class="preprocessor">#ifdef SYS_lwpcreate</span>
<a name="l03015"></a>03015 <span class="preprocessor"></span>  <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (traced_syscall_exits, SYS_lwpcreate);
<a name="l03016"></a>03016   <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (traced_syscall_exits, SYS_lwpexit);
<a name="l03017"></a>03017 <span class="preprocessor">#endif</span>
<a name="l03018"></a>03018 <span class="preprocessor"></span>
<a name="l03019"></a>03019 <span class="preprocessor">#ifdef SYS_lwp_create   </span><span class="comment">/* FIXME: once only, please.  */</span>
<a name="l03020"></a>03020   <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (traced_syscall_exits, SYS_lwp_create);
<a name="l03021"></a>03021   <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (traced_syscall_exits, SYS_lwp_exit);
<a name="l03022"></a>03022 <span class="preprocessor">#endif</span>
<a name="l03023"></a>03023 <span class="preprocessor"></span>
<a name="l03024"></a>03024 <span class="preprocessor">#ifdef DYNAMIC_SYSCALLS</span>
<a name="l03025"></a>03025 <span class="preprocessor"></span>  {
<a name="l03026"></a>03026     <span class="keywordtype">int</span> callnum = find_syscall (pi, <span class="stringliteral">&quot;execve&quot;</span>);
<a name="l03027"></a>03027 
<a name="l03028"></a>03028     <span class="keywordflow">if</span> (callnum &gt;= 0)
<a name="l03029"></a>03029       <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (traced_syscall_exits, callnum);
<a name="l03030"></a>03030     callnum = find_syscall (pi, <span class="stringliteral">&quot;ra_execve&quot;</span>);
<a name="l03031"></a>03031     <span class="keywordflow">if</span> (callnum &gt;= 0)
<a name="l03032"></a>03032       <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (traced_syscall_exits, callnum);
<a name="l03033"></a>03033   }
<a name="l03034"></a>03034 <span class="preprocessor">#endif</span>
<a name="l03035"></a>03035 <span class="preprocessor"></span>
<a name="l03036"></a>03036   status = <a class="code" href="procfs_8c.html#a33c100a98eea13970f4ac33a7e9af14f">proc_set_traced_sysexit</a> (pi, traced_syscall_exits);
<a name="l03037"></a>03037   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (traced_syscall_exits);
<a name="l03038"></a>03038   <span class="keywordflow">if</span> (!status)
<a name="l03039"></a>03039     <span class="keywordflow">return</span> __LINE__;
<a name="l03040"></a>03040 
<a name="l03041"></a>03041 <span class="preprocessor">#endif </span><span class="comment">/* PRFS_STOPEXEC */</span>
<a name="l03042"></a>03042   <span class="keywordflow">return</span> 0;
<a name="l03043"></a>03043 }
<a name="l03044"></a>03044 
<a name="l03045"></a>03045 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03046"></a><a class="code" href="procfs_8c.html#ad90b52d13ae8d868b4fc3e8e6a7ede28">03046</a> <a class="code" href="procfs_8c.html#ad90b52d13ae8d868b4fc3e8e6a7ede28">procfs_attach</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops, <span class="keywordtype">char</span> *args, <span class="keywordtype">int</span> from_tty)
<a name="l03047"></a>03047 {
<a name="l03048"></a>03048   <span class="keywordtype">char</span> *exec_file;
<a name="l03049"></a>03049   <span class="keywordtype">int</span>   pid;
<a name="l03050"></a>03050 
<a name="l03051"></a>03051   pid = <a class="code" href="utils_8c.html#a43a6282af36461b8e447c1da66cee68d">parse_pid_to_attach</a> (args);
<a name="l03052"></a>03052 
<a name="l03053"></a>03053   <span class="keywordflow">if</span> (pid == getpid ())
<a name="l03054"></a>03054     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attaching GDB to itself is not a good idea...&quot;</span>));
<a name="l03055"></a>03055 
<a name="l03056"></a>03056   <span class="keywordflow">if</span> (from_tty)
<a name="l03057"></a>03057     {
<a name="l03058"></a>03058       exec_file = <a class="code" href="corefile_8c.html#a4e814b1531684005d22fea3e17f1781d">get_exec_file</a> (0);
<a name="l03059"></a>03059 
<a name="l03060"></a>03060       <span class="keywordflow">if</span> (exec_file)
<a name="l03061"></a>03061         <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attaching to program `%s&#39;, %s\n&quot;</span>),
<a name="l03062"></a>03062                          exec_file, <a class="code" href="target_8c.html#a25ebd5fbc0b84bf9b914f7a21bfa6f7b">target_pid_to_str</a> (<a class="code" href="ptid_8c.html#a41fa537798e02ba25c7980a7c1e46272">pid_to_ptid</a> (pid)));
<a name="l03063"></a>03063       <span class="keywordflow">else</span>
<a name="l03064"></a>03064         <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attaching to %s\n&quot;</span>),
<a name="l03065"></a>03065                          <a class="code" href="target_8c.html#a25ebd5fbc0b84bf9b914f7a21bfa6f7b">target_pid_to_str</a> (<a class="code" href="ptid_8c.html#a41fa537798e02ba25c7980a7c1e46272">pid_to_ptid</a> (pid)));
<a name="l03066"></a>03066 
<a name="l03067"></a>03067       fflush (stdout);
<a name="l03068"></a>03068     }
<a name="l03069"></a>03069   <a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a> = <a class="code" href="procfs_8c.html#af41d7a4d0a797c9991aa58bcc53d7e08">do_attach</a> (<a class="code" href="ptid_8c.html#a41fa537798e02ba25c7980a7c1e46272">pid_to_ptid</a> (pid));
<a name="l03070"></a>03070   <a class="code" href="target_8c.html#ada1b9dc1eeb0546d39b86ba7ac645e67">push_target</a> (ops);
<a name="l03071"></a>03071 }
<a name="l03072"></a>03072 
<a name="l03073"></a>03073 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03074"></a><a class="code" href="procfs_8c.html#aba2a9d7aaf48b661b2007c57749cc2fa">03074</a> <a class="code" href="procfs_8c.html#aba2a9d7aaf48b661b2007c57749cc2fa">procfs_detach</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops, <span class="keywordtype">char</span> *args, <span class="keywordtype">int</span> from_tty)
<a name="l03075"></a>03075 {
<a name="l03076"></a>03076   <span class="keywordtype">int</span> sig = 0;
<a name="l03077"></a>03077   <span class="keywordtype">int</span> pid = <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>);
<a name="l03078"></a>03078 
<a name="l03079"></a>03079   <span class="keywordflow">if</span> (args)
<a name="l03080"></a>03080     sig = atoi (args);
<a name="l03081"></a>03081 
<a name="l03082"></a>03082   <span class="keywordflow">if</span> (from_tty)
<a name="l03083"></a>03083     {
<a name="l03084"></a>03084       <span class="keywordtype">char</span> *exec_file;
<a name="l03085"></a>03085 
<a name="l03086"></a>03086       exec_file = <a class="code" href="corefile_8c.html#a4e814b1531684005d22fea3e17f1781d">get_exec_file</a> (0);
<a name="l03087"></a>03087       <span class="keywordflow">if</span> (exec_file == NULL)
<a name="l03088"></a>03088         exec_file = <span class="stringliteral">&quot;&quot;</span>;
<a name="l03089"></a>03089 
<a name="l03090"></a>03090       <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Detaching from program: %s, %s\n&quot;</span>), exec_file,
<a name="l03091"></a>03091                        <a class="code" href="target_8c.html#a25ebd5fbc0b84bf9b914f7a21bfa6f7b">target_pid_to_str</a> (<a class="code" href="ptid_8c.html#a41fa537798e02ba25c7980a7c1e46272">pid_to_ptid</a> (pid)));
<a name="l03092"></a>03092       <a class="code" href="ui-file_8c.html#a046f07b5ef1bcc35c28b4be983e39998">gdb_flush</a> (<a class="code" href="main_8c.html#a41a2b997ba5454df787d61f051dd918c">gdb_stdout</a>);
<a name="l03093"></a>03093     }
<a name="l03094"></a>03094 
<a name="l03095"></a>03095   <a class="code" href="procfs_8c.html#a254f9040db8c0382864ac9a23c6b3fcc">do_detach</a> (sig);
<a name="l03096"></a>03096 
<a name="l03097"></a>03097   <a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a> = <a class="code" href="ptid_8c.html#acba69c857786546b204883bbcc90a64e">null_ptid</a>;
<a name="l03098"></a>03098   <a class="code" href="inferior_8c.html#a8e6501d60127be44b15b9f7c9986513e">detach_inferior</a> (pid);
<a name="l03099"></a>03099   <a class="code" href="target_8c.html#a9599d37847d1388531abb3f2aeba6616">unpush_target</a> (ops);
<a name="l03100"></a>03100 }
<a name="l03101"></a>03101 
<a name="l03102"></a>03102 <span class="keyword">static</span> <a class="code" href="structptid.html">ptid_t</a>
<a name="l03103"></a><a class="code" href="procfs_8c.html#af41d7a4d0a797c9991aa58bcc53d7e08">03103</a> <a class="code" href="procfs_8c.html#af41d7a4d0a797c9991aa58bcc53d7e08">do_attach</a> (<a class="code" href="structptid.html">ptid_t</a> ptid)
<a name="l03104"></a>03104 {
<a name="l03105"></a>03105   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l03106"></a>03106   <span class="keyword">struct </span><a class="code" href="structinferior.html">inferior</a> *<a class="code" href="namespacearm-linux.html#aaf6bae53545ee96f24d7ba560ed0a205">inf</a>;
<a name="l03107"></a>03107   <span class="keywordtype">int</span> fail;
<a name="l03108"></a>03108   <span class="keywordtype">int</span> lwpid;
<a name="l03109"></a>03109 
<a name="l03110"></a>03110   <span class="keywordflow">if</span> ((pi = <a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (ptid), 0)) == NULL)
<a name="l03111"></a>03111     perror (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs: out of memory in &#39;attach&#39;&quot;</span>));
<a name="l03112"></a>03112 
<a name="l03113"></a>03113   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (pi, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca242b7fbe149191cf293910e1f2f65bd6">FD_CTL</a>))
<a name="l03114"></a>03114     {
<a name="l03115"></a>03115       <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, <span class="stringliteral">&quot;procfs:%d -- &quot;</span>, __LINE__);
<a name="l03116"></a>03116       sprintf (errmsg, <span class="stringliteral">&quot;do_attach: couldn&#39;t open /proc file for process %d&quot;</span>,
<a name="l03117"></a>03117                <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (ptid));
<a name="l03118"></a>03118       <a class="code" href="procfs_8c.html#a4a363dfa0e8f3f68a66a7152e0d95913">dead_procinfo</a> (pi, errmsg, <a class="code" href="procfs_8c.html#a0ae1e3bf78c960c83e2d437efd802058abe2503b6c561e99c096631b995eaa539">NOKILL</a>);
<a name="l03119"></a>03119     }
<a name="l03120"></a>03120 
<a name="l03121"></a>03121   <span class="comment">/* Stop the process (if it isn&#39;t already stopped).  */</span>
<a name="l03122"></a>03122   <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (pi) &amp; (PR_STOPPED | PR_ISTOP))
<a name="l03123"></a>03123     {
<a name="l03124"></a>03124       pi-&gt;<a class="code" href="structprocinfo.html#a4d5e4bdafb9c9f76174c84a3f1b8ccd8">was_stopped</a> = 1;
<a name="l03125"></a>03125       <a class="code" href="proc-utils_8h.html#ad359cee950a98ba9d3562d4e339e7b66">proc_prettyprint_why</a> (<a class="code" href="procfs_8c.html#af1d2febb017ce0acde9f56bbfcbfde9e">proc_why</a> (pi), <a class="code" href="procfs_8c.html#a8f54b931ed7656bcce6696ea27b8b3c3">proc_what</a> (pi), 1);
<a name="l03126"></a>03126     }
<a name="l03127"></a>03127   <span class="keywordflow">else</span>
<a name="l03128"></a>03128     {
<a name="l03129"></a>03129       pi-&gt;<a class="code" href="structprocinfo.html#a4d5e4bdafb9c9f76174c84a3f1b8ccd8">was_stopped</a> = 0;
<a name="l03130"></a>03130       <span class="comment">/* Set the process to run again when we close it.  */</span>
<a name="l03131"></a>03131       <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#adc200acb760eee688f9efffce872cfe1">proc_set_run_on_last_close</a> (pi))
<a name="l03132"></a>03132         <a class="code" href="procfs_8c.html#a4a363dfa0e8f3f68a66a7152e0d95913">dead_procinfo</a> (pi, <span class="stringliteral">&quot;do_attach: couldn&#39;t set RLC.&quot;</span>, <a class="code" href="procfs_8c.html#a0ae1e3bf78c960c83e2d437efd802058abe2503b6c561e99c096631b995eaa539">NOKILL</a>);
<a name="l03133"></a>03133 
<a name="l03134"></a>03134       <span class="comment">/* Now stop the process.  */</span>
<a name="l03135"></a>03135       <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dd9898eb050acf3e17c9436dcb4cc66">proc_stop_process</a> (pi))
<a name="l03136"></a>03136         <a class="code" href="procfs_8c.html#a4a363dfa0e8f3f68a66a7152e0d95913">dead_procinfo</a> (pi, <span class="stringliteral">&quot;do_attach: couldn&#39;t stop the process.&quot;</span>, <a class="code" href="procfs_8c.html#a0ae1e3bf78c960c83e2d437efd802058abe2503b6c561e99c096631b995eaa539">NOKILL</a>);
<a name="l03137"></a>03137       pi-&gt;<a class="code" href="structprocinfo.html#a06291e3cc0449eb51f149e4d718d0218">ignore_next_sigstop</a> = 1;
<a name="l03138"></a>03138     }
<a name="l03139"></a>03139   <span class="comment">/* Save some of the /proc state to be restored if we detach.  */</span>
<a name="l03140"></a>03140   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a97bc5054c707856cb46f4e7272ae8817">proc_get_traced_faults</a>   (pi, &amp;pi-&gt;<a class="code" href="structprocinfo.html#ab6f5d831f0153fcc5441cb9050d62313">saved_fltset</a>))
<a name="l03141"></a>03141     <a class="code" href="procfs_8c.html#a4a363dfa0e8f3f68a66a7152e0d95913">dead_procinfo</a> (pi, <span class="stringliteral">&quot;do_attach: couldn&#39;t save traced faults.&quot;</span>, <a class="code" href="procfs_8c.html#a0ae1e3bf78c960c83e2d437efd802058abe2503b6c561e99c096631b995eaa539">NOKILL</a>);
<a name="l03142"></a>03142   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a5b69e531d7ab6145e6a1d32487707a47">proc_get_traced_signals</a>  (pi, &amp;pi-&gt;<a class="code" href="structprocinfo.html#ae6922e85e89e6c7b3597a74856307d5c">saved_sigset</a>))
<a name="l03143"></a>03143     <a class="code" href="procfs_8c.html#a4a363dfa0e8f3f68a66a7152e0d95913">dead_procinfo</a> (pi, <span class="stringliteral">&quot;do_attach: couldn&#39;t save traced signals.&quot;</span>, <a class="code" href="procfs_8c.html#a0ae1e3bf78c960c83e2d437efd802058abe2503b6c561e99c096631b995eaa539">NOKILL</a>);
<a name="l03144"></a>03144   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a383f37198255501af0d2097360b52063">proc_get_traced_sysentry</a> (pi, pi-&gt;<a class="code" href="structprocinfo.html#a7df20e8108a16cdf00b4a40039b97164">saved_entryset</a>))
<a name="l03145"></a>03145     <a class="code" href="procfs_8c.html#a4a363dfa0e8f3f68a66a7152e0d95913">dead_procinfo</a> (pi, <span class="stringliteral">&quot;do_attach: couldn&#39;t save traced syscall entries.&quot;</span>,
<a name="l03146"></a>03146                    <a class="code" href="procfs_8c.html#a0ae1e3bf78c960c83e2d437efd802058abe2503b6c561e99c096631b995eaa539">NOKILL</a>);
<a name="l03147"></a>03147   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#afb19be38f985cb48545d7f81771dcf60">proc_get_traced_sysexit</a>  (pi, pi-&gt;<a class="code" href="structprocinfo.html#aa7801fdd3d9f15fda54aa8d81b3ccfd8">saved_exitset</a>))
<a name="l03148"></a>03148     <a class="code" href="procfs_8c.html#a4a363dfa0e8f3f68a66a7152e0d95913">dead_procinfo</a> (pi, <span class="stringliteral">&quot;do_attach: couldn&#39;t save traced syscall exits.&quot;</span>,
<a name="l03149"></a>03149                    <a class="code" href="procfs_8c.html#a0ae1e3bf78c960c83e2d437efd802058abe2503b6c561e99c096631b995eaa539">NOKILL</a>);
<a name="l03150"></a>03150   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a46d2e8aed15e86c7026a4b41ac4f025d">proc_get_held_signals</a>    (pi, &amp;pi-&gt;<a class="code" href="structprocinfo.html#a8893f6113351ec1bf61f3610dc140417">saved_sighold</a>))
<a name="l03151"></a>03151     <a class="code" href="procfs_8c.html#a4a363dfa0e8f3f68a66a7152e0d95913">dead_procinfo</a> (pi, <span class="stringliteral">&quot;do_attach: couldn&#39;t save held signals.&quot;</span>, <a class="code" href="procfs_8c.html#a0ae1e3bf78c960c83e2d437efd802058abe2503b6c561e99c096631b995eaa539">NOKILL</a>);
<a name="l03152"></a>03152 
<a name="l03153"></a>03153   <span class="keywordflow">if</span> ((fail = <a class="code" href="procfs_8c.html#a80e7d9aa440370eb496a13d228ff3e69">procfs_debug_inferior</a> (pi)) != 0)
<a name="l03154"></a>03154     <a class="code" href="procfs_8c.html#a4a363dfa0e8f3f68a66a7152e0d95913">dead_procinfo</a> (pi, <span class="stringliteral">&quot;do_attach: failed in procfs_debug_inferior&quot;</span>, <a class="code" href="procfs_8c.html#a0ae1e3bf78c960c83e2d437efd802058abe2503b6c561e99c096631b995eaa539">NOKILL</a>);
<a name="l03155"></a>03155 
<a name="l03156"></a>03156   inf = <a class="code" href="inferior_8c.html#a9e592c83e7c0c1f89f1a4a392bd1a277">current_inferior</a> ();
<a name="l03157"></a>03157   <a class="code" href="inferior_8c.html#a0b129737f77321494f776acff0000fa1">inferior_appeared</a> (inf, pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>);
<a name="l03158"></a>03158   <span class="comment">/* Let GDB know that the inferior was attached.  */</span>
<a name="l03159"></a>03159   inf-&gt;<a class="code" href="structinferior.html#a2a806ec9d3ad6bda987e716e653a1980">attach_flag</a> = 1;
<a name="l03160"></a>03160 
<a name="l03161"></a>03161   <span class="comment">/* Create a procinfo for the current lwp.  */</span>
<a name="l03162"></a>03162   lwpid = <a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">proc_get_current_thread</a> (pi);
<a name="l03163"></a>03163   <a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, lwpid);
<a name="l03164"></a>03164 
<a name="l03165"></a>03165   <span class="comment">/* Add it to gdb&#39;s thread list.  */</span>
<a name="l03166"></a>03166   ptid = <a class="code" href="ptid_8c.html#aa96ee3f6a88626ec36045b4d84e27f79">ptid_build</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, lwpid, 0);
<a name="l03167"></a>03167   <a class="code" href="gdbthread_8h.html#a9e123f760f2bb2f9e96499816360d1cf">add_thread</a> (ptid);
<a name="l03168"></a>03168 
<a name="l03169"></a>03169   <span class="keywordflow">return</span> ptid;
<a name="l03170"></a>03170 }
<a name="l03171"></a>03171 
<a name="l03172"></a>03172 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03173"></a><a class="code" href="procfs_8c.html#a254f9040db8c0382864ac9a23c6b3fcc">03173</a> <a class="code" href="procfs_8c.html#a254f9040db8c0382864ac9a23c6b3fcc">do_detach</a> (<span class="keywordtype">int</span> signo)
<a name="l03174"></a>03174 {
<a name="l03175"></a>03175   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l03176"></a>03176 
<a name="l03177"></a>03177   <span class="comment">/* Find procinfo for the main process.  */</span>
<a name="l03178"></a>03178   pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>),
<a name="l03179"></a>03179                              0); <span class="comment">/* FIXME: threads */</span>
<a name="l03180"></a>03180   <span class="keywordflow">if</span> (signo)
<a name="l03181"></a>03181     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#ad042ba71cbc842f0407b54cfe972fb19">proc_set_current_signal</a> (pi, signo))
<a name="l03182"></a>03182       <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;do_detach, set_current_signal&quot;</span>, __LINE__);
<a name="l03183"></a>03183 
<a name="l03184"></a>03184   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#af04151458bd3246bc210bc06eae93f66">proc_set_traced_signals</a> (pi, &amp;pi-&gt;<a class="code" href="structprocinfo.html#ae6922e85e89e6c7b3597a74856307d5c">saved_sigset</a>))
<a name="l03185"></a>03185     <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;do_detach, set_traced_signal&quot;</span>, __LINE__);
<a name="l03186"></a>03186 
<a name="l03187"></a>03187   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#af0ddd9f46992fe62b051be4c4f014bc3">proc_set_traced_faults</a> (pi, &amp;pi-&gt;<a class="code" href="structprocinfo.html#ab6f5d831f0153fcc5441cb9050d62313">saved_fltset</a>))
<a name="l03188"></a>03188     <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;do_detach, set_traced_faults&quot;</span>, __LINE__);
<a name="l03189"></a>03189 
<a name="l03190"></a>03190   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a84e53147df27900c8c107d200c34b795">proc_set_traced_sysentry</a> (pi, pi-&gt;<a class="code" href="structprocinfo.html#a7df20e8108a16cdf00b4a40039b97164">saved_entryset</a>))
<a name="l03191"></a>03191     <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;do_detach, set_traced_sysentry&quot;</span>, __LINE__);
<a name="l03192"></a>03192 
<a name="l03193"></a>03193   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a33c100a98eea13970f4ac33a7e9af14f">proc_set_traced_sysexit</a> (pi, pi-&gt;<a class="code" href="structprocinfo.html#aa7801fdd3d9f15fda54aa8d81b3ccfd8">saved_exitset</a>))
<a name="l03194"></a>03194     <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;do_detach, set_traced_sysexit&quot;</span>, __LINE__);
<a name="l03195"></a>03195 
<a name="l03196"></a>03196   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7d94f41f793319ce6745ed55b76664a8">proc_set_held_signals</a> (pi, &amp;pi-&gt;<a class="code" href="structprocinfo.html#a8893f6113351ec1bf61f3610dc140417">saved_sighold</a>))
<a name="l03197"></a>03197     <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;do_detach, set_held_signals&quot;</span>, __LINE__);
<a name="l03198"></a>03198 
<a name="l03199"></a>03199   <span class="keywordflow">if</span> (signo || (<a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (pi) &amp; (PR_STOPPED | PR_ISTOP)))
<a name="l03200"></a>03200     <span class="keywordflow">if</span> (signo || !(pi-&gt;<a class="code" href="structprocinfo.html#a4d5e4bdafb9c9f76174c84a3f1b8ccd8">was_stopped</a>) ||
<a name="l03201"></a>03201         <a class="code" href="utils_8c.html#a4b369431cd1ce5d26bccf6b79a44c085">query</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Was stopped when attached, make it runnable again? &quot;</span>)))
<a name="l03202"></a>03202       {
<a name="l03203"></a>03203         <span class="comment">/* Clear any pending signal.  */</span>
<a name="l03204"></a>03204         <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7e91a0e63d7a14be7175af82ce8228a3">proc_clear_current_fault</a> (pi))
<a name="l03205"></a>03205           <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;do_detach, clear_current_fault&quot;</span>, __LINE__);
<a name="l03206"></a>03206 
<a name="l03207"></a>03207         <span class="keywordflow">if</span> (signo == 0 &amp;&amp; !<a class="code" href="procfs_8c.html#acf498bb6db60da249ab7425b373c25b1">proc_clear_current_signal</a> (pi))
<a name="l03208"></a>03208           <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;do_detach, clear_current_signal&quot;</span>, __LINE__);
<a name="l03209"></a>03209 
<a name="l03210"></a>03210         <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#adc200acb760eee688f9efffce872cfe1">proc_set_run_on_last_close</a> (pi))
<a name="l03211"></a>03211           <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;do_detach, set_rlc&quot;</span>, __LINE__);
<a name="l03212"></a>03212       }
<a name="l03213"></a>03213 
<a name="l03214"></a>03214   <a class="code" href="procfs_8c.html#af0251ed126d7aa5845297cab52db3b68">destroy_procinfo</a> (pi);
<a name="l03215"></a>03215 }
<a name="l03216"></a>03216 
<a name="l03217"></a>03217 <span class="comment">/* Fetch register REGNUM from the inferior.  If REGNUM is -1, do this</span>
<a name="l03218"></a>03218 <span class="comment">   for all registers.</span>
<a name="l03219"></a>03219 <span class="comment"></span>
<a name="l03220"></a>03220 <span class="comment">   ??? Is the following note still relevant?  We can&#39;t get individual</span>
<a name="l03221"></a>03221 <span class="comment">   registers with the PT_GETREGS ptrace(2) request either, yet we</span>
<a name="l03222"></a>03222 <span class="comment">   don&#39;t bother with caching at all in that case.</span>
<a name="l03223"></a>03223 <span class="comment"></span>
<a name="l03224"></a>03224 <span class="comment">   NOTE: Since the /proc interface cannot give us individual</span>
<a name="l03225"></a>03225 <span class="comment">   registers, we pay no attention to REGNUM, and just fetch them all.</span>
<a name="l03226"></a>03226 <span class="comment">   This results in the possibility that we will do unnecessarily many</span>
<a name="l03227"></a>03227 <span class="comment">   fetches, since we may be called repeatedly for individual</span>
<a name="l03228"></a>03228 <span class="comment">   registers.  So we cache the results, and mark the cache invalid</span>
<a name="l03229"></a>03229 <span class="comment">   when the process is resumed.  */</span>
<a name="l03230"></a>03230 
<a name="l03231"></a>03231 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03232"></a><a class="code" href="procfs_8c.html#aa018896dbc17e29f83fa7a79f6eba535">03232</a> <a class="code" href="procfs_8c.html#aa018896dbc17e29f83fa7a79f6eba535">procfs_fetch_registers</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l03233"></a>03233                         <span class="keyword">struct</span> <a class="code" href="structregcache.html">regcache</a> *<a class="code" href="structregcache.html">regcache</a>, <span class="keywordtype">int</span> <a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>)
<a name="l03234"></a>03234 {
<a name="l03235"></a>03235   <a class="code" href="gregset_8h.html#ad358cd20eb83ca9e131c708c8aa14c89">gdb_gregset_t</a> *gregs;
<a name="l03236"></a>03236   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l03237"></a>03237   <span class="keywordtype">int</span> <a class="code" href="structinferior.html#a1be87f581dbb6c893dbe1f2ff701636a">pid</a> = <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>);
<a name="l03238"></a>03238   <span class="keywordtype">int</span> tid = <a class="code" href="ptid_8c.html#af5b67a5f356c507b7809af2fa4e63b44">ptid_get_lwp</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>);
<a name="l03239"></a>03239   <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="regcache_8c.html#ad4f6d0cdf256b1fa45d59a6d71b50659">get_regcache_arch</a> (regcache);
<a name="l03240"></a>03240 
<a name="l03241"></a>03241   pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pid, tid);
<a name="l03242"></a>03242 
<a name="l03243"></a>03243   <span class="keywordflow">if</span> (pi == NULL)
<a name="l03244"></a>03244     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs: fetch_registers failed to find procinfo for %s&quot;</span>),
<a name="l03245"></a>03245            <a class="code" href="target_8c.html#a25ebd5fbc0b84bf9b914f7a21bfa6f7b">target_pid_to_str</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>));
<a name="l03246"></a>03246 
<a name="l03247"></a>03247   gregs = <a class="code" href="procfs_8c.html#a186019d8eb03e08d77a0121384fec317">proc_get_gregs</a> (pi);
<a name="l03248"></a>03248   <span class="keywordflow">if</span> (gregs == NULL)
<a name="l03249"></a>03249     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;fetch_registers, get_gregs&quot;</span>, __LINE__);
<a name="l03250"></a>03250 
<a name="l03251"></a>03251   <a class="code" href="aarch64-linux-nat_8c.html#a285dc81c71767c55f35955e6248bf1cd">supply_gregset</a> (regcache, (<span class="keyword">const</span> <a class="code" href="gregset_8h.html#ad358cd20eb83ca9e131c708c8aa14c89">gdb_gregset_t</a> *) gregs);
<a name="l03252"></a>03252 
<a name="l03253"></a>03253   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#acaa68f0472f945198b3cae4b382738d1">gdbarch_fp0_regnum</a> (gdbarch) &gt;= 0) <span class="comment">/* Do we have an FPU?  */</span>
<a name="l03254"></a>03254     {
<a name="l03255"></a>03255       <a class="code" href="gregset_8h.html#ac5319835a36948bae33bef8f21542def">gdb_fpregset_t</a> *fpregs;
<a name="l03256"></a>03256 
<a name="l03257"></a>03257       <span class="keywordflow">if</span> ((regnum &gt;= 0 &amp;&amp; regnum &lt; <a class="code" href="gdbarch_8c.html#acaa68f0472f945198b3cae4b382738d1">gdbarch_fp0_regnum</a> (gdbarch))
<a name="l03258"></a>03258           || regnum == <a class="code" href="gdbarch_8c.html#a07a162ebafea1269eb8f341db44e53e7">gdbarch_pc_regnum</a> (gdbarch)
<a name="l03259"></a>03259           || regnum == <a class="code" href="gdbarch_8c.html#a86f6193dd957c193df77477d9d84c4f3">gdbarch_sp_regnum</a> (gdbarch))
<a name="l03260"></a>03260         <span class="keywordflow">return</span>;                 <span class="comment">/* Not a floating point register.  */</span>
<a name="l03261"></a>03261 
<a name="l03262"></a>03262       fpregs = <a class="code" href="procfs_8c.html#a92e3ada52963db8a97f6afbcf5a8d20e">proc_get_fpregs</a> (pi);
<a name="l03263"></a>03263       <span class="keywordflow">if</span> (fpregs == NULL)
<a name="l03264"></a>03264         <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;fetch_registers, get_fpregs&quot;</span>, __LINE__);
<a name="l03265"></a>03265 
<a name="l03266"></a>03266       <a class="code" href="aarch64-linux-nat_8c.html#a784d41df464cedb2bd9a12f93af6cdb8">supply_fpregset</a> (regcache, (<span class="keyword">const</span> <a class="code" href="gregset_8h.html#ac5319835a36948bae33bef8f21542def">gdb_fpregset_t</a> *) fpregs);
<a name="l03267"></a>03267     }
<a name="l03268"></a>03268 }
<a name="l03269"></a>03269 
<a name="l03270"></a>03270 <span class="comment">/* Store register REGNUM back into the inferior.  If REGNUM is -1, do</span>
<a name="l03271"></a>03271 <span class="comment">   this for all registers.</span>
<a name="l03272"></a>03272 <span class="comment"></span>
<a name="l03273"></a>03273 <span class="comment">   NOTE: Since the /proc interface will not read individual registers,</span>
<a name="l03274"></a>03274 <span class="comment">   we will cache these requests until the process is resumed, and only</span>
<a name="l03275"></a>03275 <span class="comment">   then write them back to the inferior process.</span>
<a name="l03276"></a>03276 <span class="comment"></span>
<a name="l03277"></a>03277 <span class="comment">   FIXME: is that a really bad idea?  Have to think about cases where</span>
<a name="l03278"></a>03278 <span class="comment">   writing one register might affect the value of others, etc.  */</span>
<a name="l03279"></a>03279 
<a name="l03280"></a>03280 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03281"></a>03281 <a class="code" href="nto-procfs_8c.html#a44d7783e99db7311e058e6c32fa701a9">procfs_store_registers</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l03282"></a>03282                         <span class="keyword">struct</span> <a class="code" href="structregcache.html">regcache</a> *<a class="code" href="structregcache.html">regcache</a>, <span class="keywordtype">int</span> <a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>)
<a name="l03283"></a>03283 {
<a name="l03284"></a>03284   <a class="code" href="gregset_8h.html#ad358cd20eb83ca9e131c708c8aa14c89">gdb_gregset_t</a> *gregs;
<a name="l03285"></a>03285   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l03286"></a>03286   <span class="keywordtype">int</span> pid = <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>);
<a name="l03287"></a>03287   <span class="keywordtype">int</span> tid = <a class="code" href="ptid_8c.html#af5b67a5f356c507b7809af2fa4e63b44">ptid_get_lwp</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>);
<a name="l03288"></a>03288   <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="regcache_8c.html#ad4f6d0cdf256b1fa45d59a6d71b50659">get_regcache_arch</a> (regcache);
<a name="l03289"></a>03289 
<a name="l03290"></a>03290   pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (pid, tid);
<a name="l03291"></a>03291 
<a name="l03292"></a>03292   <span class="keywordflow">if</span> (pi == NULL)
<a name="l03293"></a>03293     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs: store_registers: failed to find procinfo for %s&quot;</span>),
<a name="l03294"></a>03294            <a class="code" href="target_8c.html#a25ebd5fbc0b84bf9b914f7a21bfa6f7b">target_pid_to_str</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>));
<a name="l03295"></a>03295 
<a name="l03296"></a>03296   gregs = <a class="code" href="procfs_8c.html#a186019d8eb03e08d77a0121384fec317">proc_get_gregs</a> (pi);
<a name="l03297"></a>03297   <span class="keywordflow">if</span> (gregs == NULL)
<a name="l03298"></a>03298     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;store_registers, get_gregs&quot;</span>, __LINE__);
<a name="l03299"></a>03299 
<a name="l03300"></a>03300   <a class="code" href="aarch64-linux-nat_8c.html#a59e9e7e4054210afa3fc8e9f0a1bbc61">fill_gregset</a> (regcache, gregs, regnum);
<a name="l03301"></a>03301   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a157837678e57bda96a70afe61ef02c57">proc_set_gregs</a> (pi))
<a name="l03302"></a>03302     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;store_registers, set_gregs&quot;</span>, __LINE__);
<a name="l03303"></a>03303 
<a name="l03304"></a>03304   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#acaa68f0472f945198b3cae4b382738d1">gdbarch_fp0_regnum</a> (gdbarch) &gt;= 0) <span class="comment">/* Do we have an FPU?  */</span>
<a name="l03305"></a>03305     {
<a name="l03306"></a>03306       <a class="code" href="gregset_8h.html#ac5319835a36948bae33bef8f21542def">gdb_fpregset_t</a> *fpregs;
<a name="l03307"></a>03307 
<a name="l03308"></a>03308       <span class="keywordflow">if</span> ((regnum &gt;= 0 &amp;&amp; regnum &lt; <a class="code" href="gdbarch_8c.html#acaa68f0472f945198b3cae4b382738d1">gdbarch_fp0_regnum</a> (gdbarch))
<a name="l03309"></a>03309           || regnum == <a class="code" href="gdbarch_8c.html#a07a162ebafea1269eb8f341db44e53e7">gdbarch_pc_regnum</a> (gdbarch)
<a name="l03310"></a>03310           || regnum == <a class="code" href="gdbarch_8c.html#a86f6193dd957c193df77477d9d84c4f3">gdbarch_sp_regnum</a> (gdbarch))
<a name="l03311"></a>03311         <span class="keywordflow">return</span>;                 <span class="comment">/* Not a floating point register.  */</span>
<a name="l03312"></a>03312 
<a name="l03313"></a>03313       fpregs = <a class="code" href="procfs_8c.html#a92e3ada52963db8a97f6afbcf5a8d20e">proc_get_fpregs</a> (pi);
<a name="l03314"></a>03314       <span class="keywordflow">if</span> (fpregs == NULL)
<a name="l03315"></a>03315         <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;store_registers, get_fpregs&quot;</span>, __LINE__);
<a name="l03316"></a>03316 
<a name="l03317"></a>03317       <a class="code" href="aarch64-linux-nat_8c.html#ad18ef6d17cc5848eb79210aed1177cbc">fill_fpregset</a> (regcache, fpregs, regnum);
<a name="l03318"></a>03318       <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a409cfe587b50c92fd09c4c1e71edcf17">proc_set_fpregs</a> (pi))
<a name="l03319"></a>03319         <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;store_registers, set_fpregs&quot;</span>, __LINE__);
<a name="l03320"></a>03320     }
<a name="l03321"></a>03321 }
<a name="l03322"></a>03322 
<a name="l03323"></a>03323 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03324"></a><a class="code" href="procfs_8c.html#a6e3f2c370c12bec354dffe684209990b">03324</a> <a class="code" href="procfs_8c.html#a6e3f2c370c12bec354dffe684209990b">syscall_is_lwp_exit</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">int</span> scall)
<a name="l03325"></a>03325 {
<a name="l03326"></a>03326 <span class="preprocessor">#ifdef SYS_lwp_exit</span>
<a name="l03327"></a>03327 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (scall == SYS_lwp_exit)
<a name="l03328"></a>03328     <span class="keywordflow">return</span> 1;
<a name="l03329"></a>03329 <span class="preprocessor">#endif</span>
<a name="l03330"></a>03330 <span class="preprocessor"></span><span class="preprocessor">#ifdef SYS_lwpexit</span>
<a name="l03331"></a>03331 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (scall == SYS_lwpexit)
<a name="l03332"></a>03332     <span class="keywordflow">return</span> 1;
<a name="l03333"></a>03333 <span class="preprocessor">#endif</span>
<a name="l03334"></a>03334 <span class="preprocessor"></span>  <span class="keywordflow">return</span> 0;
<a name="l03335"></a>03335 }
<a name="l03336"></a>03336 
<a name="l03337"></a>03337 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03338"></a><a class="code" href="procfs_8c.html#a1880ef46b6496fc78c69d92282d0f341">03338</a> <a class="code" href="procfs_8c.html#a1880ef46b6496fc78c69d92282d0f341">syscall_is_exit</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">int</span> scall)
<a name="l03339"></a>03339 {
<a name="l03340"></a>03340 <span class="preprocessor">#ifdef SYS_exit</span>
<a name="l03341"></a>03341 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (scall == SYS_exit)
<a name="l03342"></a>03342     <span class="keywordflow">return</span> 1;
<a name="l03343"></a>03343 <span class="preprocessor">#endif</span>
<a name="l03344"></a>03344 <span class="preprocessor"></span><span class="preprocessor">#ifdef DYNAMIC_SYSCALLS</span>
<a name="l03345"></a>03345 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (find_syscall (pi, <span class="stringliteral">&quot;_exit&quot;</span>) == scall)
<a name="l03346"></a>03346     <span class="keywordflow">return</span> 1;
<a name="l03347"></a>03347 <span class="preprocessor">#endif</span>
<a name="l03348"></a>03348 <span class="preprocessor"></span>  <span class="keywordflow">return</span> 0;
<a name="l03349"></a>03349 }
<a name="l03350"></a>03350 
<a name="l03351"></a>03351 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03352"></a><a class="code" href="procfs_8c.html#ad92afe0f66e46b19c7be753af28344e7">03352</a> <a class="code" href="procfs_8c.html#ad92afe0f66e46b19c7be753af28344e7">syscall_is_exec</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">int</span> scall)
<a name="l03353"></a>03353 {
<a name="l03354"></a>03354 <span class="preprocessor">#ifdef SYS_exec</span>
<a name="l03355"></a>03355 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (scall == SYS_exec)
<a name="l03356"></a>03356     <span class="keywordflow">return</span> 1;
<a name="l03357"></a>03357 <span class="preprocessor">#endif</span>
<a name="l03358"></a>03358 <span class="preprocessor"></span><span class="preprocessor">#ifdef SYS_execv</span>
<a name="l03359"></a>03359 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (scall == SYS_execv)
<a name="l03360"></a>03360     <span class="keywordflow">return</span> 1;
<a name="l03361"></a>03361 <span class="preprocessor">#endif</span>
<a name="l03362"></a>03362 <span class="preprocessor"></span><span class="preprocessor">#ifdef SYS_execve</span>
<a name="l03363"></a>03363 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (scall == SYS_execve)
<a name="l03364"></a>03364     <span class="keywordflow">return</span> 1;
<a name="l03365"></a>03365 <span class="preprocessor">#endif</span>
<a name="l03366"></a>03366 <span class="preprocessor"></span><span class="preprocessor">#ifdef DYNAMIC_SYSCALLS</span>
<a name="l03367"></a>03367 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (find_syscall (pi, <span class="stringliteral">&quot;_execve&quot;</span>))
<a name="l03368"></a>03368     <span class="keywordflow">return</span> 1;
<a name="l03369"></a>03369   <span class="keywordflow">if</span> (find_syscall (pi, <span class="stringliteral">&quot;ra_execve&quot;</span>))
<a name="l03370"></a>03370     <span class="keywordflow">return</span> 1;
<a name="l03371"></a>03371 <span class="preprocessor">#endif</span>
<a name="l03372"></a>03372 <span class="preprocessor"></span>  <span class="keywordflow">return</span> 0;
<a name="l03373"></a>03373 }
<a name="l03374"></a>03374 
<a name="l03375"></a>03375 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03376"></a><a class="code" href="procfs_8c.html#a1f3758fff8a06e70fe419c337c453b75">03376</a> <a class="code" href="procfs_8c.html#a1f3758fff8a06e70fe419c337c453b75">syscall_is_lwp_create</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">int</span> scall)
<a name="l03377"></a>03377 {
<a name="l03378"></a>03378 <span class="preprocessor">#ifdef SYS_lwp_create</span>
<a name="l03379"></a>03379 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (scall == SYS_lwp_create)
<a name="l03380"></a>03380     <span class="keywordflow">return</span> 1;
<a name="l03381"></a>03381 <span class="preprocessor">#endif</span>
<a name="l03382"></a>03382 <span class="preprocessor"></span><span class="preprocessor">#ifdef SYS_lwpcreate</span>
<a name="l03383"></a>03383 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (scall == SYS_lwpcreate)
<a name="l03384"></a>03384     <span class="keywordflow">return</span> 1;
<a name="l03385"></a>03385 <span class="preprocessor">#endif</span>
<a name="l03386"></a>03386 <span class="preprocessor"></span>  <span class="keywordflow">return</span> 0;
<a name="l03387"></a>03387 }
<a name="l03388"></a>03388 
<a name="l03389"></a>03389 <span class="comment">/* Remove the breakpoint that we inserted in __dbx_link().</span>
<a name="l03390"></a>03390 <span class="comment">   Does nothing if the breakpoint hasn&#39;t been inserted or has already</span>
<a name="l03391"></a>03391 <span class="comment">   been removed.  */</span>
<a name="l03392"></a>03392 
<a name="l03393"></a>03393 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03394"></a><a class="code" href="procfs_8c.html#a19f268411a415e1010ff2800808be2f1">03394</a> <a class="code" href="procfs_8c.html#a19f268411a415e1010ff2800808be2f1">remove_dbx_link_breakpoint</a> (<span class="keywordtype">void</span>)
<a name="l03395"></a>03395 {
<a name="l03396"></a>03396   <span class="keywordflow">if</span> (dbx_link_bpt_addr == 0)
<a name="l03397"></a>03397     <span class="keywordflow">return</span>;
<a name="l03398"></a>03398 
<a name="l03399"></a>03399   <span class="keywordflow">if</span> (<a class="code" href="breakpoint_8c.html#a1355b81d333bd3fe9e87bd29ea08b779">deprecated_remove_raw_breakpoint</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> (), dbx_link_bpt) != 0)
<a name="l03400"></a>03400     <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unable to remove __dbx_link breakpoint.&quot;</span>));
<a name="l03401"></a>03401 
<a name="l03402"></a>03402   dbx_link_bpt_addr = 0;
<a name="l03403"></a>03403   dbx_link_bpt = NULL;
<a name="l03404"></a>03404 }
<a name="l03405"></a>03405 
<a name="l03406"></a>03406 <span class="preprocessor">#ifdef SYS_syssgi</span>
<a name="l03407"></a>03407 <span class="preprocessor"></span><span class="comment">/* Return the address of the __dbx_link() function in the file</span>
<a name="l03408"></a>03408 <span class="comment">   refernced by ABFD by scanning its symbol table.  Return 0 if</span>
<a name="l03409"></a>03409 <span class="comment">   the symbol was not found.  */</span>
<a name="l03410"></a>03410 
<a name="l03411"></a>03411 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l03412"></a>03412 dbx_link_addr (bfd *abfd)
<a name="l03413"></a>03413 {
<a name="l03414"></a>03414   <span class="keywordtype">long</span> storage_needed;
<a name="l03415"></a>03415   asymbol **symbol_table;
<a name="l03416"></a>03416   <span class="keywordtype">long</span> number_of_symbols;
<a name="l03417"></a>03417   <span class="keywordtype">long</span> i;
<a name="l03418"></a>03418 
<a name="l03419"></a>03419   storage_needed = bfd_get_symtab_upper_bound (abfd);
<a name="l03420"></a>03420   <span class="keywordflow">if</span> (storage_needed &lt;= 0)
<a name="l03421"></a>03421     <span class="keywordflow">return</span> 0;
<a name="l03422"></a>03422 
<a name="l03423"></a>03423   symbol_table = (asymbol **) <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (storage_needed);
<a name="l03424"></a>03424   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, symbol_table);
<a name="l03425"></a>03425 
<a name="l03426"></a>03426   number_of_symbols = bfd_canonicalize_symtab (abfd, symbol_table);
<a name="l03427"></a>03427 
<a name="l03428"></a>03428   <span class="keywordflow">for</span> (i = 0; i &lt; number_of_symbols; i++)
<a name="l03429"></a>03429     {
<a name="l03430"></a>03430       asymbol *sym = symbol_table[i];
<a name="l03431"></a>03431 
<a name="l03432"></a>03432       <span class="keywordflow">if</span> ((sym-&gt;flags &amp; BSF_GLOBAL)
<a name="l03433"></a>03433           &amp;&amp; sym-&gt;name != NULL &amp;&amp; strcmp (sym-&gt;name, <span class="stringliteral">&quot;__dbx_link&quot;</span>) == 0)
<a name="l03434"></a>03434         <span class="keywordflow">return</span> (sym-&gt;value + sym-&gt;section-&gt;vma);
<a name="l03435"></a>03435     }
<a name="l03436"></a>03436 
<a name="l03437"></a>03437   <span class="comment">/* Symbol not found, return NULL.  */</span>
<a name="l03438"></a>03438   <span class="keywordflow">return</span> 0;
<a name="l03439"></a>03439 }
<a name="l03440"></a>03440 
<a name="l03441"></a>03441 <span class="comment">/* Search the symbol table of the file referenced by FD for a symbol</span>
<a name="l03442"></a>03442 <span class="comment">   named __dbx_link().  If found, then insert a breakpoint at this location,</span>
<a name="l03443"></a>03443 <span class="comment">   and return nonzero.  Return zero otherwise.  */</span>
<a name="l03444"></a>03444 
<a name="l03445"></a>03445 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03446"></a>03446 insert_dbx_link_bpt_in_file (<span class="keywordtype">int</span> fd, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ignored)
<a name="l03447"></a>03447 {
<a name="l03448"></a>03448   bfd *abfd;
<a name="l03449"></a>03449   <span class="keywordtype">long</span> storage_needed;
<a name="l03450"></a>03450   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> sym_addr;
<a name="l03451"></a>03451 
<a name="l03452"></a>03452   abfd = <a class="code" href="gdb__bfd_8c.html#add3698f5cacbaf2016ae805684dc01d6">gdb_bfd_fdopenr</a> (<span class="stringliteral">&quot;unamed&quot;</span>, 0, fd);
<a name="l03453"></a>03453   <span class="keywordflow">if</span> (abfd == NULL)
<a name="l03454"></a>03454     {
<a name="l03455"></a>03455       <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Failed to create a bfd: %s.&quot;</span>), bfd_errmsg (bfd_get_error ()));
<a name="l03456"></a>03456       <span class="keywordflow">return</span> 0;
<a name="l03457"></a>03457     }
<a name="l03458"></a>03458 
<a name="l03459"></a>03459   <span class="keywordflow">if</span> (!bfd_check_format (abfd, bfd_object))
<a name="l03460"></a>03460     {
<a name="l03461"></a>03461       <span class="comment">/* Not the correct format, so we can not possibly find the dbx_link</span>
<a name="l03462"></a>03462 <span class="comment">         symbol in it.  */</span>
<a name="l03463"></a>03463       <a class="code" href="gdb__bfd_8c.html#a1027b59a8494f937b5760901040dc125">gdb_bfd_unref</a> (abfd);
<a name="l03464"></a>03464       <span class="keywordflow">return</span> 0;
<a name="l03465"></a>03465     }
<a name="l03466"></a>03466 
<a name="l03467"></a>03467   sym_addr = dbx_link_addr (abfd);
<a name="l03468"></a>03468   <span class="keywordflow">if</span> (sym_addr != 0)
<a name="l03469"></a>03469     {
<a name="l03470"></a>03470       <span class="comment">/* Insert the breakpoint.  */</span>
<a name="l03471"></a>03471       dbx_link_bpt_addr = sym_addr;
<a name="l03472"></a>03472       dbx_link_bpt = <a class="code" href="breakpoint_8c.html#ae69a79875b28e9bbe7a56465f378ff2a">deprecated_insert_raw_breakpoint</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> (), NULL,
<a name="l03473"></a>03473                                                        sym_addr);
<a name="l03474"></a>03474       <span class="keywordflow">if</span> (dbx_link_bpt == NULL)
<a name="l03475"></a>03475         {
<a name="l03476"></a>03476           <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Failed to insert dbx_link breakpoint.&quot;</span>));
<a name="l03477"></a>03477           <a class="code" href="gdb__bfd_8c.html#a1027b59a8494f937b5760901040dc125">gdb_bfd_unref</a> (abfd);
<a name="l03478"></a>03478           <span class="keywordflow">return</span> 0;
<a name="l03479"></a>03479         }
<a name="l03480"></a>03480       <a class="code" href="gdb__bfd_8c.html#a1027b59a8494f937b5760901040dc125">gdb_bfd_unref</a> (abfd);
<a name="l03481"></a>03481       <span class="keywordflow">return</span> 1;
<a name="l03482"></a>03482     }
<a name="l03483"></a>03483 
<a name="l03484"></a>03484   <a class="code" href="gdb__bfd_8c.html#a1027b59a8494f937b5760901040dc125">gdb_bfd_unref</a> (abfd);
<a name="l03485"></a>03485   <span class="keywordflow">return</span> 0;
<a name="l03486"></a>03486 }
<a name="l03487"></a>03487 
<a name="l03488"></a>03488 <span class="comment">/* Calls the supplied callback function once for each mapped address</span>
<a name="l03489"></a>03489 <span class="comment">   space in the process.  The callback function receives an open file</span>
<a name="l03490"></a>03490 <span class="comment">   descriptor for the file corresponding to that mapped address space</span>
<a name="l03491"></a>03491 <span class="comment">   (if there is one), and the base address of the mapped space.  Quit</span>
<a name="l03492"></a>03492 <span class="comment">   when the callback function returns a nonzero value, or at teh end</span>
<a name="l03493"></a>03493 <span class="comment">   of the mappings.  Returns the first non-zero return value of the</span>
<a name="l03494"></a>03494 <span class="comment">   callback function, or zero.  */</span>
<a name="l03495"></a>03495 
<a name="l03496"></a>03496 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03497"></a>03497 solib_mappings_callback (<span class="keyword">struct</span> prmap *map, <span class="keywordtype">int</span> (*<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>) (<span class="keywordtype">int</span>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>),
<a name="l03498"></a>03498                          <span class="keywordtype">void</span> *data)
<a name="l03499"></a>03499 {
<a name="l03500"></a>03500   <a class="code" href="structprocinfo.html">procinfo</a> *pi = <a class="code" href="structgdbarch.html#a2e98934f7a42feae42149766e3fa770d">data</a>;
<a name="l03501"></a>03501   <span class="keywordtype">int</span> fd;
<a name="l03502"></a>03502 
<a name="l03503"></a>03503 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l03504"></a>03504 <span class="preprocessor"></span>  <span class="keywordtype">char</span> name[<a class="code" href="procfs_8c.html#a516ed8ab3b65b65276525efba4b38d6d">MAX_PROC_NAME_SIZE</a> + <span class="keyword">sizeof</span> (map-&gt;pr_mapname)];
<a name="l03505"></a>03505 
<a name="l03506"></a>03506   <span class="keywordflow">if</span> (map-&gt;pr_vaddr == 0 &amp;&amp; map-&gt;pr_size == 0)
<a name="l03507"></a>03507     <span class="keywordflow">return</span> -1;          <span class="comment">/* sanity */</span>
<a name="l03508"></a>03508 
<a name="l03509"></a>03509   <span class="keywordflow">if</span> (map-&gt;pr_mapname[0] == 0)
<a name="l03510"></a>03510     {
<a name="l03511"></a>03511       fd = -1;  <span class="comment">/* no map file */</span>
<a name="l03512"></a>03512     }
<a name="l03513"></a>03513   <span class="keywordflow">else</span>
<a name="l03514"></a>03514     {
<a name="l03515"></a>03515       sprintf (name, <span class="stringliteral">&quot;/proc/%d/object/%s&quot;</span>, pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, map-&gt;pr_mapname);
<a name="l03516"></a>03516       <span class="comment">/* Note: caller&#39;s responsibility to close this fd!  */</span>
<a name="l03517"></a>03517       fd = <a class="code" href="procfs_8c.html#a8537de378e19c8806d9837b90505a62d">open_with_retry</a> (name, O_RDONLY);
<a name="l03518"></a>03518       <span class="comment">/* Note: we don&#39;t test the above call for failure;</span>
<a name="l03519"></a>03519 <span class="comment">         we just pass the FD on as given.  Sometimes there is</span>
<a name="l03520"></a>03520 <span class="comment">         no file, so the open may return failure, but that&#39;s</span>
<a name="l03521"></a>03521 <span class="comment">         not a problem.  */</span>
<a name="l03522"></a>03522     }
<a name="l03523"></a>03523 <span class="preprocessor">#else</span>
<a name="l03524"></a>03524 <span class="preprocessor"></span>  fd = ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCOPENM, &amp;map-&gt;pr_vaddr);
<a name="l03525"></a>03525   <span class="comment">/* Note: we don&#39;t test the above call for failure;</span>
<a name="l03526"></a>03526 <span class="comment">     we just pass the FD on as given.  Sometimes there is</span>
<a name="l03527"></a>03527 <span class="comment">     no file, so the ioctl may return failure, but that&#39;s</span>
<a name="l03528"></a>03528 <span class="comment">     not a problem.  */</span>
<a name="l03529"></a>03529 <span class="preprocessor">#endif</span>
<a name="l03530"></a>03530 <span class="preprocessor"></span>  <span class="keywordflow">return</span> (*<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>) (fd, (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) map-&gt;pr_vaddr);
<a name="l03531"></a>03531 }
<a name="l03532"></a>03532 
<a name="l03533"></a>03533 <span class="comment">/* If the given memory region MAP contains a symbol named __dbx_link,</span>
<a name="l03534"></a>03534 <span class="comment">   insert a breakpoint at this location and return nonzero.  Return</span>
<a name="l03535"></a>03535 <span class="comment">   zero otherwise.  */</span>
<a name="l03536"></a>03536 
<a name="l03537"></a>03537 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03538"></a>03538 insert_dbx_link_bpt_in_region (<span class="keyword">struct</span> prmap *map,
<a name="l03539"></a>03539                                <a class="code" href="defs_8h.html#a9d6528d2f701ee8e47c35c038752ac99">find_memory_region_ftype</a> child_func,
<a name="l03540"></a>03540                                <span class="keywordtype">void</span> *data)
<a name="l03541"></a>03541 {
<a name="l03542"></a>03542   <a class="code" href="structprocinfo.html">procinfo</a> *pi = (<a class="code" href="structprocinfo.html">procinfo</a> *) data;
<a name="l03543"></a>03543 
<a name="l03544"></a>03544   <span class="comment">/* We know the symbol we&#39;re looking for is in a text region, so</span>
<a name="l03545"></a>03545 <span class="comment">     only look for it if the region is a text one.  */</span>
<a name="l03546"></a>03546   <span class="keywordflow">if</span> (map-&gt;pr_mflags &amp; MA_EXEC)
<a name="l03547"></a>03547     <span class="keywordflow">return</span> solib_mappings_callback (map, insert_dbx_link_bpt_in_file, pi);
<a name="l03548"></a>03548 
<a name="l03549"></a>03549   <span class="keywordflow">return</span> 0;
<a name="l03550"></a>03550 }
<a name="l03551"></a>03551 
<a name="l03552"></a>03552 <span class="comment">/* Search all memory regions for a symbol named __dbx_link.  If found,</span>
<a name="l03553"></a>03553 <span class="comment">   insert a breakpoint at its location, and return nonzero.  Return zero</span>
<a name="l03554"></a>03554 <span class="comment">   otherwise.  */</span>
<a name="l03555"></a>03555 
<a name="l03556"></a>03556 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03557"></a>03557 insert_dbx_link_breakpoint (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l03558"></a>03558 {
<a name="l03559"></a>03559   <span class="keywordflow">return</span> <a class="code" href="procfs_8c.html#a2c2c4e0ad3531aa668e8a6f38b50ba29">iterate_over_mappings</a> (pi, NULL, pi, insert_dbx_link_bpt_in_region);
<a name="l03560"></a>03560 }
<a name="l03561"></a>03561 <span class="preprocessor">#endif</span>
<a name="l03562"></a>03562 <span class="preprocessor"></span>
<a name="l03563"></a>03563 <span class="comment">/* Retrieve the next stop event from the child process.  If child has</span>
<a name="l03564"></a>03564 <span class="comment">   not stopped yet, wait for it to stop.  Translate /proc eventcodes</span>
<a name="l03565"></a>03565 <span class="comment">   (or possibly wait eventcodes) into gdb internal event codes.</span>
<a name="l03566"></a>03566 <span class="comment">   Returns the id of process (and possibly thread) that incurred the</span>
<a name="l03567"></a>03567 <span class="comment">   event.  Event codes are returned through a pointer parameter.  */</span>
<a name="l03568"></a>03568 
<a name="l03569"></a>03569 <span class="keyword">static</span> <a class="code" href="structptid.html">ptid_t</a>
<a name="l03570"></a><a class="code" href="procfs_8c.html#a3d55bc6a9a2a8842d23a3c352d6fc0c2">03570</a> <a class="code" href="procfs_8c.html#a3d55bc6a9a2a8842d23a3c352d6fc0c2">procfs_wait</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l03571"></a>03571              <a class="code" href="structptid.html">ptid_t</a> ptid, <span class="keyword">struct</span> <a class="code" href="structtarget__waitstatus.html">target_waitstatus</a> *<a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>, <span class="keywordtype">int</span> options)
<a name="l03572"></a>03572 {
<a name="l03573"></a>03573   <span class="comment">/* First cut: loosely based on original version 2.1.  */</span>
<a name="l03574"></a>03574   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l03575"></a>03575   <span class="keywordtype">int</span>       wstat;
<a name="l03576"></a>03576   <span class="keywordtype">int</span>       temp_tid;
<a name="l03577"></a>03577   <a class="code" href="structptid.html">ptid_t</a>    retval, temp_ptid;
<a name="l03578"></a>03578   <span class="keywordtype">int</span>       why, what, <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>;
<a name="l03579"></a>03579   <span class="keywordtype">int</span>       retry = 0;
<a name="l03580"></a>03580 
<a name="l03581"></a>03581 wait_again:
<a name="l03582"></a>03582 
<a name="l03583"></a>03583   retry++;
<a name="l03584"></a>03584   wstat    = 0;
<a name="l03585"></a>03585   retval   = <a class="code" href="ptid_8c.html#a41fa537798e02ba25c7980a7c1e46272">pid_to_ptid</a> (-1);
<a name="l03586"></a>03586 
<a name="l03587"></a>03587   <span class="comment">/* Find procinfo for main process.  */</span>
<a name="l03588"></a>03588   pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>), 0);
<a name="l03589"></a>03589   <span class="keywordflow">if</span> (pi)
<a name="l03590"></a>03590     {
<a name="l03591"></a>03591       <span class="comment">/* We must assume that the status is stale now...  */</span>
<a name="l03592"></a>03592       pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 0;
<a name="l03593"></a>03593       pi-&gt;<a class="code" href="structprocinfo.html#af644c8cc9c6b4f09babb3eaf994fa5fc">gregs_valid</a>  = 0;
<a name="l03594"></a>03594       pi-&gt;<a class="code" href="structprocinfo.html#a687b93500ed96768255ec07735113afb">fpregs_valid</a> = 0;
<a name="l03595"></a>03595 
<a name="l03596"></a>03596 <span class="preprocessor">#if 0   </span><span class="comment">/* just try this out...  */</span>
<a name="l03597"></a>03597       flags = <a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (pi);
<a name="l03598"></a>03598       why   = <a class="code" href="procfs_8c.html#af1d2febb017ce0acde9f56bbfcbfde9e">proc_why</a> (pi);
<a name="l03599"></a>03599       <span class="keywordflow">if</span> ((flags &amp; PR_STOPPED) &amp;&amp; (why == PR_REQUESTED))
<a name="l03600"></a>03600         pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 0;   <span class="comment">/* re-read again, IMMEDIATELY...  */</span>
<a name="l03601"></a>03601 <span class="preprocessor">#endif</span>
<a name="l03602"></a>03602 <span class="preprocessor"></span>      <span class="comment">/* If child is not stopped, wait for it to stop.  */</span>
<a name="l03603"></a>03603       <span class="keywordflow">if</span> (!(<a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (pi) &amp; (PR_STOPPED | PR_ISTOP)) &amp;&amp;
<a name="l03604"></a>03604           !<a class="code" href="procfs_8c.html#ac6105e9b1d932acc33f65ca921e8d1cb">proc_wait_for_stop</a> (pi))
<a name="l03605"></a>03605         {
<a name="l03606"></a>03606           <span class="comment">/* wait_for_stop failed: has the child terminated?  */</span>
<a name="l03607"></a>03607           <span class="keywordflow">if</span> (errno == ENOENT)
<a name="l03608"></a>03608             {
<a name="l03609"></a>03609               <span class="keywordtype">int</span> wait_retval;
<a name="l03610"></a>03610 
<a name="l03611"></a>03611               <span class="comment">/* /proc file not found; presumably child has terminated.  */</span>
<a name="l03612"></a>03612               wait_retval = wait (&amp;wstat); <span class="comment">/* &quot;wait&quot; for the child&#39;s exit.  */</span>
<a name="l03613"></a>03613 
<a name="l03614"></a>03614               <span class="comment">/* Wrong child?  */</span>
<a name="l03615"></a>03615               <span class="keywordflow">if</span> (wait_retval != <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>))
<a name="l03616"></a>03616                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs: couldn&#39;t stop &quot;</span>
<a name="l03617"></a>03617                          <span class="stringliteral">&quot;process %d: wait returned %d.&quot;</span>),
<a name="l03618"></a>03618                        <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>), wait_retval);
<a name="l03619"></a>03619               <span class="comment">/* FIXME: might I not just use waitpid?</span>
<a name="l03620"></a>03620 <span class="comment">                 Or try find_procinfo to see if I know about this child?  */</span>
<a name="l03621"></a>03621               retval = <a class="code" href="ptid_8c.html#a41fa537798e02ba25c7980a7c1e46272">pid_to_ptid</a> (wait_retval);
<a name="l03622"></a>03622             }
<a name="l03623"></a>03623           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (errno == EINTR)
<a name="l03624"></a>03624             <span class="keywordflow">goto</span> wait_again;
<a name="l03625"></a>03625           <span class="keywordflow">else</span>
<a name="l03626"></a>03626             {
<a name="l03627"></a>03627               <span class="comment">/* Unknown error from wait_for_stop.  */</span>
<a name="l03628"></a>03628               <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;target_wait (wait_for_stop)&quot;</span>, __LINE__);
<a name="l03629"></a>03629             }
<a name="l03630"></a>03630         }
<a name="l03631"></a>03631       <span class="keywordflow">else</span>
<a name="l03632"></a>03632         {
<a name="l03633"></a>03633           <span class="comment">/* This long block is reached if either:</span>
<a name="l03634"></a>03634 <span class="comment">             a) the child was already stopped, or</span>
<a name="l03635"></a>03635 <span class="comment">             b) we successfully waited for the child with wait_for_stop.</span>
<a name="l03636"></a>03636 <span class="comment">             This block will analyze the /proc status, and translate it</span>
<a name="l03637"></a>03637 <span class="comment">             into a waitstatus for GDB.</span>
<a name="l03638"></a>03638 <span class="comment"></span>
<a name="l03639"></a>03639 <span class="comment">             If we actually had to call wait because the /proc file</span>
<a name="l03640"></a>03640 <span class="comment">             is gone (child terminated), then we skip this block,</span>
<a name="l03641"></a>03641 <span class="comment">             because we already have a waitstatus.  */</span>
<a name="l03642"></a>03642 
<a name="l03643"></a>03643           flags = <a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (pi);
<a name="l03644"></a>03644           why   = <a class="code" href="procfs_8c.html#af1d2febb017ce0acde9f56bbfcbfde9e">proc_why</a> (pi);
<a name="l03645"></a>03645           what  = <a class="code" href="procfs_8c.html#a8f54b931ed7656bcce6696ea27b8b3c3">proc_what</a> (pi);
<a name="l03646"></a>03646 
<a name="l03647"></a>03647           <span class="keywordflow">if</span> (flags &amp; (PR_STOPPED | PR_ISTOP))
<a name="l03648"></a>03648             {
<a name="l03649"></a>03649 <span class="preprocessor">#ifdef PR_ASYNC</span>
<a name="l03650"></a>03650 <span class="preprocessor"></span>              <span class="comment">/* If it&#39;s running async (for single_thread control),</span>
<a name="l03651"></a>03651 <span class="comment">                 set it back to normal again.  */</span>
<a name="l03652"></a>03652               <span class="keywordflow">if</span> (flags &amp; PR_ASYNC)
<a name="l03653"></a>03653                 <span class="keywordflow">if</span> (!proc_unset_async (pi))
<a name="l03654"></a>03654                   <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;target_wait, unset_async&quot;</span>, __LINE__);
<a name="l03655"></a>03655 <span class="preprocessor">#endif</span>
<a name="l03656"></a>03656 <span class="preprocessor"></span>
<a name="l03657"></a>03657               <span class="keywordflow">if</span> (<a class="code" href="defs_8h.html#a3f2f91ed92de5dfaa6d27fb82822f8d5">info_verbose</a>)
<a name="l03658"></a>03658                 <a class="code" href="proc-utils_8h.html#ad359cee950a98ba9d3562d4e339e7b66">proc_prettyprint_why</a> (why, what, 1);
<a name="l03659"></a>03659 
<a name="l03660"></a>03660               <span class="comment">/* The &#39;pid&#39; we will return to GDB is composed of</span>
<a name="l03661"></a>03661 <span class="comment">                 the process ID plus the lwp ID.  */</span>
<a name="l03662"></a>03662               retval = <a class="code" href="ptid_8c.html#aa96ee3f6a88626ec36045b4d84e27f79">ptid_build</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, <a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">proc_get_current_thread</a> (pi), 0);
<a name="l03663"></a>03663 
<a name="l03664"></a>03664               <span class="keywordflow">switch</span> (why) {
<a name="l03665"></a>03665               <span class="keywordflow">case</span> PR_SIGNALLED:
<a name="l03666"></a>03666                 wstat = (what &lt;&lt; 8) | 0177;
<a name="l03667"></a>03667                 <span class="keywordflow">break</span>;
<a name="l03668"></a>03668               <span class="keywordflow">case</span> PR_SYSENTRY:
<a name="l03669"></a>03669                 <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#a6e3f2c370c12bec354dffe684209990b">syscall_is_lwp_exit</a> (pi, what))
<a name="l03670"></a>03670                   {
<a name="l03671"></a>03671                     <span class="keywordflow">if</span> (<a class="code" href="gdbthread_8h.html#abd6b89e5f0d1d1b5dd0126d9523e5c0d">print_thread_events</a>)
<a name="l03672"></a>03672                       <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;[%s exited]\n&quot;</span>),
<a name="l03673"></a>03673                                          <a class="code" href="target_8c.html#a25ebd5fbc0b84bf9b914f7a21bfa6f7b">target_pid_to_str</a> (retval));
<a name="l03674"></a>03674                     <a class="code" href="gdbthread_8h.html#a8081b2ccccf2e2cdce0c21c93aac0ae0">delete_thread</a> (retval);
<a name="l03675"></a>03675                     status-&gt;<a class="code" href="structtarget__waitstatus.html#a17ed1783e9146f443fa51ace8da76198">kind</a> = <a class="code" href="waitstatus_8h.html#aa3229b489ec985f04f7e9f652138b7c3a1fc05a908dc19601f71ccd273e124a33">TARGET_WAITKIND_SPURIOUS</a>;
<a name="l03676"></a>03676                     <span class="keywordflow">return</span> retval;
<a name="l03677"></a>03677                   }
<a name="l03678"></a>03678                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#a1880ef46b6496fc78c69d92282d0f341">syscall_is_exit</a> (pi, what))
<a name="l03679"></a>03679                   {
<a name="l03680"></a>03680                     <span class="keyword">struct </span><a class="code" href="structinferior.html">inferior</a> *<a class="code" href="namespacearm-linux.html#aaf6bae53545ee96f24d7ba560ed0a205">inf</a>;
<a name="l03681"></a>03681 
<a name="l03682"></a>03682                     <span class="comment">/* Handle SYS_exit call only.  */</span>
<a name="l03683"></a>03683                     <span class="comment">/* Stopped at entry to SYS_exit.</span>
<a name="l03684"></a>03684 <span class="comment">                       Make it runnable, resume it, then use</span>
<a name="l03685"></a>03685 <span class="comment">                       the wait system call to get its exit code.</span>
<a name="l03686"></a>03686 <span class="comment">                       Proc_run_process always clears the current</span>
<a name="l03687"></a>03687 <span class="comment">                       fault and signal.</span>
<a name="l03688"></a>03688 <span class="comment">                       Then return its exit status.  */</span>
<a name="l03689"></a>03689                     pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 0;
<a name="l03690"></a>03690                     wstat = 0;
<a name="l03691"></a>03691                     <span class="comment">/* FIXME: what we should do is return</span>
<a name="l03692"></a>03692 <span class="comment">                       TARGET_WAITKIND_SPURIOUS.  */</span>
<a name="l03693"></a>03693                     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#ad2d6284c468ce487d8a75149b4dd2c07">proc_run_process</a> (pi, 0, 0))
<a name="l03694"></a>03694                       <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;target_wait, run_process&quot;</span>, __LINE__);
<a name="l03695"></a>03695 
<a name="l03696"></a>03696                     inf = <a class="code" href="inferior_8c.html#aa6cb4e509f05c4b88a55198f804dc2cc">find_inferior_pid</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>);
<a name="l03697"></a>03697                     <span class="keywordflow">if</span> (inf-&gt;<a class="code" href="structinferior.html#a2a806ec9d3ad6bda987e716e653a1980">attach_flag</a>)
<a name="l03698"></a>03698                       {
<a name="l03699"></a>03699                         <span class="comment">/* Don&#39;t call wait: simulate waiting for exit,</span>
<a name="l03700"></a>03700 <span class="comment">                           return a &quot;success&quot; exit code.  Bogus: what if</span>
<a name="l03701"></a>03701 <span class="comment">                           it returns something else?  */</span>
<a name="l03702"></a>03702                         wstat = 0;
<a name="l03703"></a>03703                         retval = <a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>;  <span class="comment">/* ? ? ? */</span>
<a name="l03704"></a>03704                       }
<a name="l03705"></a>03705                     <span class="keywordflow">else</span>
<a name="l03706"></a>03706                       {
<a name="l03707"></a>03707                         <span class="keywordtype">int</span> temp = wait (&amp;wstat);
<a name="l03708"></a>03708 
<a name="l03709"></a>03709                         <span class="comment">/* FIXME: shouldn&#39;t I make sure I get the right</span>
<a name="l03710"></a>03710 <span class="comment">                           event from the right process?  If (for</span>
<a name="l03711"></a>03711 <span class="comment">                           instance) I have killed an earlier inferior</span>
<a name="l03712"></a>03712 <span class="comment">                           process but failed to clean up after it</span>
<a name="l03713"></a>03713 <span class="comment">                           somehow, I could get its termination event</span>
<a name="l03714"></a>03714 <span class="comment">                           here.  */</span>
<a name="l03715"></a>03715 
<a name="l03716"></a>03716                         <span class="comment">/* If wait returns -1, that&#39;s what we return</span>
<a name="l03717"></a>03717 <span class="comment">                           to GDB.  */</span>
<a name="l03718"></a>03718                         <span class="keywordflow">if</span> (temp &lt; 0)
<a name="l03719"></a>03719                           retval = <a class="code" href="ptid_8c.html#a41fa537798e02ba25c7980a7c1e46272">pid_to_ptid</a> (temp);
<a name="l03720"></a>03720                       }
<a name="l03721"></a>03721                   }
<a name="l03722"></a>03722                 <span class="keywordflow">else</span>
<a name="l03723"></a>03723                   {
<a name="l03724"></a>03724                     <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs: trapped on entry to &quot;</span>));
<a name="l03725"></a>03725                     <a class="code" href="proc-events_8c.html#a2c9245f59f05383c10cd1c719403f003">proc_prettyprint_syscall</a> (<a class="code" href="procfs_8c.html#a8f54b931ed7656bcce6696ea27b8b3c3">proc_what</a> (pi), 0);
<a name="l03726"></a>03726                     <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03727"></a>03727 <span class="preprocessor">#ifndef PIOCSSPCACT</span>
<a name="l03728"></a>03728 <span class="preprocessor"></span>                    {
<a name="l03729"></a>03729                       <span class="keywordtype">long</span> i, nsysargs, *sysargs;
<a name="l03730"></a>03730 
<a name="l03731"></a>03731                       <span class="keywordflow">if</span> ((nsysargs = <a class="code" href="procfs_8c.html#a935646407d6d87eebb4de911ba9e6264">proc_nsysarg</a> (pi)) &gt; 0 &amp;&amp;
<a name="l03732"></a>03732                           (sysargs  = <a class="code" href="procfs_8c.html#a90ed1254f4a601bd6ba6c217beb0b437">proc_sysargs</a> (pi)) != NULL)
<a name="l03733"></a>03733                         {
<a name="l03734"></a>03734                           <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;%ld syscall arguments:\n&quot;</span>),
<a name="l03735"></a>03735                                            nsysargs);
<a name="l03736"></a>03736                           <span class="keywordflow">for</span> (i = 0; i &lt; nsysargs; i++)
<a name="l03737"></a>03737                             <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;#%ld: 0x%08lx\n&quot;</span>,
<a name="l03738"></a>03738                                              i, sysargs[i]);
<a name="l03739"></a>03739                         }
<a name="l03740"></a>03740 
<a name="l03741"></a>03741                     }
<a name="l03742"></a>03742 <span class="preprocessor">#endif</span>
<a name="l03743"></a>03743 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> (status)
<a name="l03744"></a>03744                       {
<a name="l03745"></a>03745                         <span class="comment">/* How to exit gracefully, returning &quot;unknown</span>
<a name="l03746"></a>03746 <span class="comment">                           event&quot;.  */</span>
<a name="l03747"></a>03747                         status-&gt;<a class="code" href="structtarget__waitstatus.html#a17ed1783e9146f443fa51ace8da76198">kind</a> = <a class="code" href="waitstatus_8h.html#aa3229b489ec985f04f7e9f652138b7c3a1fc05a908dc19601f71ccd273e124a33">TARGET_WAITKIND_SPURIOUS</a>;
<a name="l03748"></a>03748                         <span class="keywordflow">return</span> <a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>;
<a name="l03749"></a>03749                       }
<a name="l03750"></a>03750                     <span class="keywordflow">else</span>
<a name="l03751"></a>03751                       {
<a name="l03752"></a>03752                         <span class="comment">/* How to keep going without returning to wfi: */</span>
<a name="l03753"></a>03753                         <a class="code" href="target_8c.html#a10cefb24ce83949fae9ba2756d0bf476">target_resume</a> (ptid, 0, GDB_SIGNAL_0);
<a name="l03754"></a>03754                         <span class="keywordflow">goto</span> wait_again;
<a name="l03755"></a>03755                       }
<a name="l03756"></a>03756                   }
<a name="l03757"></a>03757                 <span class="keywordflow">break</span>;
<a name="l03758"></a>03758               <span class="keywordflow">case</span> PR_SYSEXIT:
<a name="l03759"></a>03759                 <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#ad92afe0f66e46b19c7be753af28344e7">syscall_is_exec</a> (pi, what))
<a name="l03760"></a>03760                   {
<a name="l03761"></a>03761                     <span class="comment">/* Hopefully this is our own &quot;fork-child&quot; execing</span>
<a name="l03762"></a>03762 <span class="comment">                       the real child.  Hoax this event into a trap, and</span>
<a name="l03763"></a>03763 <span class="comment">                       GDB will see the child about to execute its start</span>
<a name="l03764"></a>03764 <span class="comment">                       address.  */</span>
<a name="l03765"></a>03765                     wstat = (SIGTRAP &lt;&lt; 8) | 0177;
<a name="l03766"></a>03766                   }
<a name="l03767"></a>03767 <span class="preprocessor">#ifdef SYS_syssgi</span>
<a name="l03768"></a>03768 <span class="preprocessor"></span>                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (what == SYS_syssgi)
<a name="l03769"></a>03769                   {
<a name="l03770"></a>03770                     <span class="comment">/* see if we can break on dbx_link().  If yes, then</span>
<a name="l03771"></a>03771 <span class="comment">                       we no longer need the SYS_syssgi notifications.  */</span>
<a name="l03772"></a>03772                     <span class="keywordflow">if</span> (insert_dbx_link_breakpoint (pi))
<a name="l03773"></a>03773                       <a class="code" href="procfs_8c.html#ae027347db869ac7b72aa4a12608fb54b">proc_trace_syscalls_1</a> (pi, SYS_syssgi, PR_SYSEXIT,
<a name="l03774"></a>03774                                              <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dada34921dc2c1632e9847571a81ce00124c">FLAG_RESET</a>, 0);
<a name="l03775"></a>03775 
<a name="l03776"></a>03776                     <span class="comment">/* This is an internal event and should be transparent</span>
<a name="l03777"></a>03777 <span class="comment">                       to wfi, so resume the execution and wait again.  See</span>
<a name="l03778"></a>03778 <span class="comment">                       comment in procfs_init_inferior() for more details.  */</span>
<a name="l03779"></a>03779                     <a class="code" href="target_8c.html#a10cefb24ce83949fae9ba2756d0bf476">target_resume</a> (ptid, 0, GDB_SIGNAL_0);
<a name="l03780"></a>03780                     <span class="keywordflow">goto</span> wait_again;
<a name="l03781"></a>03781                   }
<a name="l03782"></a>03782 <span class="preprocessor">#endif</span>
<a name="l03783"></a>03783 <span class="preprocessor"></span>                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#a1f3758fff8a06e70fe419c337c453b75">syscall_is_lwp_create</a> (pi, what))
<a name="l03784"></a>03784                   {
<a name="l03785"></a>03785                     <span class="comment">/* This syscall is somewhat like fork/exec.  We</span>
<a name="l03786"></a>03786 <span class="comment">                       will get the event twice: once for the parent</span>
<a name="l03787"></a>03787 <span class="comment">                       LWP, and once for the child.  We should already</span>
<a name="l03788"></a>03788 <span class="comment">                       know about the parent LWP, but the child will</span>
<a name="l03789"></a>03789 <span class="comment">                       be new to us.  So, whenever we get this event,</span>
<a name="l03790"></a>03790 <span class="comment">                       if it represents a new thread, simply add the</span>
<a name="l03791"></a>03791 <span class="comment">                       thread to the list.  */</span>
<a name="l03792"></a>03792 
<a name="l03793"></a>03793                     <span class="comment">/* If not in procinfo list, add it.  */</span>
<a name="l03794"></a>03794                     temp_tid = <a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">proc_get_current_thread</a> (pi);
<a name="l03795"></a>03795                     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, temp_tid))
<a name="l03796"></a>03796                       <a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a>  (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, temp_tid);
<a name="l03797"></a>03797 
<a name="l03798"></a>03798                     temp_ptid = <a class="code" href="ptid_8c.html#aa96ee3f6a88626ec36045b4d84e27f79">ptid_build</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, temp_tid, 0);
<a name="l03799"></a>03799                     <span class="comment">/* If not in GDB&#39;s thread list, add it.  */</span>
<a name="l03800"></a>03800                     <span class="keywordflow">if</span> (!<a class="code" href="gdbthread_8h.html#a75cff5779f03e4119723fd41a5583fa7">in_thread_list</a> (temp_ptid))
<a name="l03801"></a>03801                       <a class="code" href="gdbthread_8h.html#a9e123f760f2bb2f9e96499816360d1cf">add_thread</a> (temp_ptid);
<a name="l03802"></a>03802 
<a name="l03803"></a>03803                     <span class="comment">/* Return to WFI, but tell it to immediately resume.  */</span>
<a name="l03804"></a>03804                     status-&gt;<a class="code" href="structtarget__waitstatus.html#a17ed1783e9146f443fa51ace8da76198">kind</a> = <a class="code" href="waitstatus_8h.html#aa3229b489ec985f04f7e9f652138b7c3a1fc05a908dc19601f71ccd273e124a33">TARGET_WAITKIND_SPURIOUS</a>;
<a name="l03805"></a>03805                     <span class="keywordflow">return</span> <a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>;
<a name="l03806"></a>03806                   }
<a name="l03807"></a>03807                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#a6e3f2c370c12bec354dffe684209990b">syscall_is_lwp_exit</a> (pi, what))
<a name="l03808"></a>03808                   {
<a name="l03809"></a>03809                     <span class="keywordflow">if</span> (<a class="code" href="gdbthread_8h.html#abd6b89e5f0d1d1b5dd0126d9523e5c0d">print_thread_events</a>)
<a name="l03810"></a>03810                       <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;[%s exited]\n&quot;</span>),
<a name="l03811"></a>03811                                          <a class="code" href="target_8c.html#a25ebd5fbc0b84bf9b914f7a21bfa6f7b">target_pid_to_str</a> (retval));
<a name="l03812"></a>03812                     <a class="code" href="gdbthread_8h.html#a8081b2ccccf2e2cdce0c21c93aac0ae0">delete_thread</a> (retval);
<a name="l03813"></a>03813                     status-&gt;<a class="code" href="structtarget__waitstatus.html#a17ed1783e9146f443fa51ace8da76198">kind</a> = <a class="code" href="waitstatus_8h.html#aa3229b489ec985f04f7e9f652138b7c3a1fc05a908dc19601f71ccd273e124a33">TARGET_WAITKIND_SPURIOUS</a>;
<a name="l03814"></a>03814                     <span class="keywordflow">return</span> retval;
<a name="l03815"></a>03815                   }
<a name="l03816"></a>03816                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0)
<a name="l03817"></a>03817                   {
<a name="l03818"></a>03818                     <span class="comment">/* FIXME:  Do we need to handle SYS_sproc,</span>
<a name="l03819"></a>03819 <span class="comment">                       SYS_fork, or SYS_vfork here?  The old procfs</span>
<a name="l03820"></a>03820 <span class="comment">                       seemed to use this event to handle threads on</span>
<a name="l03821"></a>03821 <span class="comment">                       older (non-LWP) systems, where I&#39;m assuming</span>
<a name="l03822"></a>03822 <span class="comment">                       that threads were actually separate processes.</span>
<a name="l03823"></a>03823 <span class="comment">                       Irix, maybe?  Anyway, low priority for now.  */</span>
<a name="l03824"></a>03824                   }
<a name="l03825"></a>03825                 <span class="keywordflow">else</span>
<a name="l03826"></a>03826                   {
<a name="l03827"></a>03827                     <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs: trapped on exit from &quot;</span>));
<a name="l03828"></a>03828                     <a class="code" href="proc-events_8c.html#a2c9245f59f05383c10cd1c719403f003">proc_prettyprint_syscall</a> (<a class="code" href="procfs_8c.html#a8f54b931ed7656bcce6696ea27b8b3c3">proc_what</a> (pi), 0);
<a name="l03829"></a>03829                     <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03830"></a>03830 <span class="preprocessor">#ifndef PIOCSSPCACT</span>
<a name="l03831"></a>03831 <span class="preprocessor"></span>                    {
<a name="l03832"></a>03832                       <span class="keywordtype">long</span> i, nsysargs, *sysargs;
<a name="l03833"></a>03833 
<a name="l03834"></a>03834                       <span class="keywordflow">if</span> ((nsysargs = <a class="code" href="procfs_8c.html#a935646407d6d87eebb4de911ba9e6264">proc_nsysarg</a> (pi)) &gt; 0 &amp;&amp;
<a name="l03835"></a>03835                           (sysargs  = <a class="code" href="procfs_8c.html#a90ed1254f4a601bd6ba6c217beb0b437">proc_sysargs</a> (pi)) != NULL)
<a name="l03836"></a>03836                         {
<a name="l03837"></a>03837                           <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;%ld syscall arguments:\n&quot;</span>),
<a name="l03838"></a>03838                                            nsysargs);
<a name="l03839"></a>03839                           <span class="keywordflow">for</span> (i = 0; i &lt; nsysargs; i++)
<a name="l03840"></a>03840                             <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;#%ld: 0x%08lx\n&quot;</span>,
<a name="l03841"></a>03841                                              i, sysargs[i]);
<a name="l03842"></a>03842                         }
<a name="l03843"></a>03843                     }
<a name="l03844"></a>03844 <span class="preprocessor">#endif</span>
<a name="l03845"></a>03845 <span class="preprocessor"></span>                    status-&gt;<a class="code" href="structtarget__waitstatus.html#a17ed1783e9146f443fa51ace8da76198">kind</a> = <a class="code" href="waitstatus_8h.html#aa3229b489ec985f04f7e9f652138b7c3a1fc05a908dc19601f71ccd273e124a33">TARGET_WAITKIND_SPURIOUS</a>;
<a name="l03846"></a>03846                     <span class="keywordflow">return</span> <a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>;
<a name="l03847"></a>03847                   }
<a name="l03848"></a>03848                 <span class="keywordflow">break</span>;
<a name="l03849"></a>03849               <span class="keywordflow">case</span> PR_REQUESTED:
<a name="l03850"></a>03850 <span class="preprocessor">#if 0   </span><span class="comment">/* FIXME */</span>
<a name="l03851"></a>03851                 wstat = (SIGSTOP &lt;&lt; 8) | 0177;
<a name="l03852"></a>03852                 <span class="keywordflow">break</span>;
<a name="l03853"></a>03853 <span class="preprocessor">#else</span>
<a name="l03854"></a>03854 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (retry &lt; 5)
<a name="l03855"></a>03855                   {
<a name="l03856"></a>03856                     <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Retry #%d:\n&quot;</span>), retry);
<a name="l03857"></a>03857                     pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a> = 0;
<a name="l03858"></a>03858                     <span class="keywordflow">goto</span> wait_again;
<a name="l03859"></a>03859                   }
<a name="l03860"></a>03860                 <span class="keywordflow">else</span>
<a name="l03861"></a>03861                   {
<a name="l03862"></a>03862                     <span class="comment">/* If not in procinfo list, add it.  */</span>
<a name="l03863"></a>03863                     temp_tid = <a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">proc_get_current_thread</a> (pi);
<a name="l03864"></a>03864                     <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, temp_tid))
<a name="l03865"></a>03865                       <a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a>  (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, temp_tid);
<a name="l03866"></a>03866 
<a name="l03867"></a>03867                     <span class="comment">/* If not in GDB&#39;s thread list, add it.  */</span>
<a name="l03868"></a>03868                     temp_ptid = <a class="code" href="ptid_8c.html#aa96ee3f6a88626ec36045b4d84e27f79">ptid_build</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, temp_tid, 0);
<a name="l03869"></a>03869                     <span class="keywordflow">if</span> (!<a class="code" href="gdbthread_8h.html#a75cff5779f03e4119723fd41a5583fa7">in_thread_list</a> (temp_ptid))
<a name="l03870"></a>03870                       <a class="code" href="gdbthread_8h.html#a9e123f760f2bb2f9e96499816360d1cf">add_thread</a> (temp_ptid);
<a name="l03871"></a>03871 
<a name="l03872"></a>03872                     status-&gt;<a class="code" href="structtarget__waitstatus.html#a17ed1783e9146f443fa51ace8da76198">kind</a> = <a class="code" href="waitstatus_8h.html#aa3229b489ec985f04f7e9f652138b7c3a8e1dc525cf3131501a541b4412bcd493">TARGET_WAITKIND_STOPPED</a>;
<a name="l03873"></a>03873                     status-&gt;<a class="code" href="structtarget__waitstatus.html#af33b8f5721dc36f6b5b829286d38f825">value</a>.<a class="code" href="structtarget__waitstatus.html#a7cc711572c26d1f095a87105f4afd1e1">sig</a> = 0;
<a name="l03874"></a>03874                     <span class="keywordflow">return</span> retval;
<a name="l03875"></a>03875                   }
<a name="l03876"></a>03876 <span class="preprocessor">#endif</span>
<a name="l03877"></a>03877 <span class="preprocessor"></span>              <span class="keywordflow">case</span> PR_JOBCONTROL:
<a name="l03878"></a>03878                 wstat = (what &lt;&lt; 8) | 0177;
<a name="l03879"></a>03879                 <span class="keywordflow">break</span>;
<a name="l03880"></a>03880               <span class="keywordflow">case</span> PR_FAULTED:
<a name="l03881"></a>03881                 <span class="keywordflow">switch</span> (what) {
<a name="l03882"></a>03882 <span class="preprocessor">#ifdef FLTWATCH</span>
<a name="l03883"></a>03883 <span class="preprocessor"></span>                <span class="keywordflow">case</span> FLTWATCH:
<a name="l03884"></a>03884                   wstat = (SIGTRAP &lt;&lt; 8) | 0177;
<a name="l03885"></a>03885                   <span class="keywordflow">break</span>;
<a name="l03886"></a>03886 <span class="preprocessor">#endif</span>
<a name="l03887"></a>03887 <span class="preprocessor"></span><span class="preprocessor">#ifdef FLTKWATCH</span>
<a name="l03888"></a>03888 <span class="preprocessor"></span>                <span class="keywordflow">case</span> FLTKWATCH:
<a name="l03889"></a>03889                   wstat = (SIGTRAP &lt;&lt; 8) | 0177;
<a name="l03890"></a>03890                   <span class="keywordflow">break</span>;
<a name="l03891"></a>03891 <span class="preprocessor">#endif</span>
<a name="l03892"></a>03892 <span class="preprocessor"></span>                  <span class="comment">/* FIXME: use si_signo where possible.  */</span>
<a name="l03893"></a>03893                 <span class="keywordflow">case</span> FLTPRIV:
<a name="l03894"></a>03894 <span class="preprocessor">#if (FLTILL != FLTPRIV)         </span><span class="comment">/* Avoid &quot;duplicate case&quot; error.  */</span>
<a name="l03895"></a>03895                 <span class="keywordflow">case</span> FLTILL:
<a name="l03896"></a>03896 <span class="preprocessor">#endif</span>
<a name="l03897"></a>03897 <span class="preprocessor"></span>                  wstat = (SIGILL &lt;&lt; 8) | 0177;
<a name="l03898"></a>03898                   <span class="keywordflow">break</span>;
<a name="l03899"></a>03899                 <span class="keywordflow">case</span> FLTBPT:
<a name="l03900"></a>03900 <span class="preprocessor">#if (FLTTRACE != FLTBPT)        </span><span class="comment">/* Avoid &quot;duplicate case&quot; error.  */</span>
<a name="l03901"></a>03901                 <span class="keywordflow">case</span> FLTTRACE:
<a name="l03902"></a>03902 <span class="preprocessor">#endif</span>
<a name="l03903"></a>03903 <span class="preprocessor"></span>                  <span class="comment">/* If we hit our __dbx_link() internal breakpoint,</span>
<a name="l03904"></a>03904 <span class="comment">                     then remove it.  See comments in procfs_init_inferior()</span>
<a name="l03905"></a>03905 <span class="comment">                     for more details.  */</span>
<a name="l03906"></a>03906                   <span class="keywordflow">if</span> (dbx_link_bpt_addr != 0
<a name="l03907"></a>03907                       &amp;&amp; dbx_link_bpt_addr
<a name="l03908"></a>03908                          == <a class="code" href="regcache_8c.html#a01b72bb2ee2d14e0097af17241cee731">regcache_read_pc</a> (<a class="code" href="regcache_8c.html#a09a386286dc22d882378f639630fecef">get_current_regcache</a> ()))
<a name="l03909"></a>03909                     <a class="code" href="procfs_8c.html#a19f268411a415e1010ff2800808be2f1">remove_dbx_link_breakpoint</a> ();
<a name="l03910"></a>03910 
<a name="l03911"></a>03911                   wstat = (SIGTRAP &lt;&lt; 8) | 0177;
<a name="l03912"></a>03912                   <span class="keywordflow">break</span>;
<a name="l03913"></a>03913                 <span class="keywordflow">case</span> FLTSTACK:
<a name="l03914"></a>03914                 <span class="keywordflow">case</span> FLTACCESS:
<a name="l03915"></a>03915 <span class="preprocessor">#if (FLTBOUNDS != FLTSTACK)     </span><span class="comment">/* Avoid &quot;duplicate case&quot; error.  */</span>
<a name="l03916"></a>03916                 <span class="keywordflow">case</span> FLTBOUNDS:
<a name="l03917"></a>03917 <span class="preprocessor">#endif</span>
<a name="l03918"></a>03918 <span class="preprocessor"></span>                  wstat = (SIGSEGV &lt;&lt; 8) | 0177;
<a name="l03919"></a>03919                   <span class="keywordflow">break</span>;
<a name="l03920"></a>03920                 <span class="keywordflow">case</span> FLTIOVF:
<a name="l03921"></a>03921                 <span class="keywordflow">case</span> FLTIZDIV:
<a name="l03922"></a>03922 <span class="preprocessor">#if (FLTFPE != FLTIOVF)         </span><span class="comment">/* Avoid &quot;duplicate case&quot; error.  */</span>
<a name="l03923"></a>03923                 <span class="keywordflow">case</span> FLTFPE:
<a name="l03924"></a>03924 <span class="preprocessor">#endif</span>
<a name="l03925"></a>03925 <span class="preprocessor"></span>                  wstat = (SIGFPE &lt;&lt; 8) | 0177;
<a name="l03926"></a>03926                   <span class="keywordflow">break</span>;
<a name="l03927"></a>03927                 <span class="keywordflow">case</span> FLTPAGE:   <span class="comment">/* Recoverable page fault */</span>
<a name="l03928"></a>03928                 <span class="keywordflow">default</span>:        <span class="comment">/* FIXME: use si_signo if possible for</span>
<a name="l03929"></a>03929 <span class="comment">                                   fault.  */</span>
<a name="l03930"></a>03930                   retval = <a class="code" href="ptid_8c.html#a41fa537798e02ba25c7980a7c1e46272">pid_to_ptid</a> (-1);
<a name="l03931"></a>03931                   <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;procfs:%d -- &quot;</span>, __LINE__);
<a name="l03932"></a>03932                   <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;child stopped for unknown reason:\n&quot;</span>));
<a name="l03933"></a>03933                   <a class="code" href="proc-utils_8h.html#ad359cee950a98ba9d3562d4e339e7b66">proc_prettyprint_why</a> (why, what, 1);
<a name="l03934"></a>03934                   <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;... giving up...&quot;</span>));
<a name="l03935"></a>03935                   <span class="keywordflow">break</span>;
<a name="l03936"></a>03936                 }
<a name="l03937"></a>03937                 <span class="keywordflow">break</span>;  <span class="comment">/* case PR_FAULTED: */</span>
<a name="l03938"></a>03938               <span class="keywordflow">default</span>:  <span class="comment">/* switch (why) unmatched */</span>
<a name="l03939"></a>03939                 <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;procfs:%d -- &quot;</span>, __LINE__);
<a name="l03940"></a>03940                 <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;child stopped for unknown reason:\n&quot;</span>));
<a name="l03941"></a>03941                 <a class="code" href="proc-utils_8h.html#ad359cee950a98ba9d3562d4e339e7b66">proc_prettyprint_why</a> (why, what, 1);
<a name="l03942"></a>03942                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;... giving up...&quot;</span>));
<a name="l03943"></a>03943                 <span class="keywordflow">break</span>;
<a name="l03944"></a>03944               }
<a name="l03945"></a>03945               <span class="comment">/* Got this far without error: If retval isn&#39;t in the</span>
<a name="l03946"></a>03946 <span class="comment">                 threads database, add it.  */</span>
<a name="l03947"></a>03947               <span class="keywordflow">if</span> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (retval) &gt; 0 &amp;&amp;
<a name="l03948"></a>03948                   !<a class="code" href="ptid_8c.html#a0df58c8db2620a2cec647934b4f77266">ptid_equal</a> (retval, <a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>) &amp;&amp;
<a name="l03949"></a>03949                   !<a class="code" href="gdbthread_8h.html#a75cff5779f03e4119723fd41a5583fa7">in_thread_list</a> (retval))
<a name="l03950"></a>03950                 {
<a name="l03951"></a>03951                   <span class="comment">/* We have a new thread.  We need to add it both to</span>
<a name="l03952"></a>03952 <span class="comment">                     GDB&#39;s list and to our own.  If we don&#39;t create a</span>
<a name="l03953"></a>03953 <span class="comment">                     procinfo, resume may be unhappy later.  */</span>
<a name="l03954"></a>03954                   <a class="code" href="gdbthread_8h.html#a9e123f760f2bb2f9e96499816360d1cf">add_thread</a> (retval);
<a name="l03955"></a>03955                   <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (retval),
<a name="l03956"></a>03956                                      <a class="code" href="ptid_8c.html#af5b67a5f356c507b7809af2fa4e63b44">ptid_get_lwp</a> (retval)) == NULL)
<a name="l03957"></a>03957                     <a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (retval),
<a name="l03958"></a>03958                                      <a class="code" href="ptid_8c.html#af5b67a5f356c507b7809af2fa4e63b44">ptid_get_lwp</a> (retval));
<a name="l03959"></a>03959                 }
<a name="l03960"></a>03960             }
<a name="l03961"></a>03961           <span class="keywordflow">else</span>  <span class="comment">/* Flags do not indicate STOPPED.  */</span>
<a name="l03962"></a>03962             {
<a name="l03963"></a>03963               <span class="comment">/* surely this can&#39;t happen...  */</span>
<a name="l03964"></a>03964               <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;procfs:%d -- process not stopped.\n&quot;</span>,
<a name="l03965"></a>03965                                __LINE__);
<a name="l03966"></a>03966               <a class="code" href="proc-flags_8c.html#a3ce6eec093522070de47785f828edc68">proc_prettyprint_flags</a> (flags, 1);
<a name="l03967"></a>03967               <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs: ...giving up...&quot;</span>));
<a name="l03968"></a>03968             }
<a name="l03969"></a>03969         }
<a name="l03970"></a>03970 
<a name="l03971"></a>03971       <span class="keywordflow">if</span> (status)
<a name="l03972"></a>03972         <a class="code" href="inf-child_8c.html#a479b7649b96fd10f6eb9046f16f47fa0">store_waitstatus</a> (status, wstat);
<a name="l03973"></a>03973     }
<a name="l03974"></a>03974 
<a name="l03975"></a>03975   <span class="keywordflow">return</span> retval;
<a name="l03976"></a>03976 }
<a name="l03977"></a>03977 
<a name="l03978"></a>03978 <span class="comment">/* Perform a partial transfer to/from the specified object.  For</span>
<a name="l03979"></a>03979 <span class="comment">   memory transfers, fall back to the old memory xfer functions.  */</span>
<a name="l03980"></a>03980 
<a name="l03981"></a>03981 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l03982"></a><a class="code" href="procfs_8c.html#a002b7fd3f79adc554869931ff15b0c7f">03982</a> <a class="code" href="procfs_8c.html#a002b7fd3f79adc554869931ff15b0c7f">procfs_xfer_partial</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops, <span class="keyword">enum</span> <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2">target_object</a> <span class="keywordtype">object</span>,
<a name="l03983"></a>03983                      <span class="keyword">const</span> <span class="keywordtype">char</span> *annex, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *readbuf,
<a name="l03984"></a>03984                      <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *writebuf, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>)
<a name="l03985"></a>03985 {
<a name="l03986"></a>03986   <span class="keywordflow">switch</span> (<span class="keywordtype">object</span>)
<a name="l03987"></a>03987     {
<a name="l03988"></a>03988     <span class="keywordflow">case</span> <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a8d0adeab7f35c7245692a63b5a2a9f3a">TARGET_OBJECT_MEMORY</a>:
<a name="l03989"></a>03989       <span class="keywordflow">if</span> (readbuf)
<a name="l03990"></a>03990         <span class="keywordflow">return</span> (*ops-&gt;<a class="code" href="structtarget__ops.html#a64b004350c177cdbdde9b311226f397b">deprecated_xfer_memory</a>) (<a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, readbuf,
<a name="l03991"></a>03991                                                <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>, 0<span class="comment">/*read*/</span>, NULL, ops);
<a name="l03992"></a>03992       <span class="keywordflow">if</span> (writebuf)
<a name="l03993"></a>03993         <span class="keywordflow">return</span> (*ops-&gt;<a class="code" href="structtarget__ops.html#a64b004350c177cdbdde9b311226f397b">deprecated_xfer_memory</a>) (<a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *) writebuf,
<a name="l03994"></a>03994                                                len, 1<span class="comment">/*write*/</span>, NULL, ops);
<a name="l03995"></a>03995       <span class="keywordflow">return</span> -1;
<a name="l03996"></a>03996 
<a name="l03997"></a>03997 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l03998"></a>03998 <span class="preprocessor"></span>    <span class="keywordflow">case</span> <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a5d6f5f222b30d70fed32596fb55d50b1">TARGET_OBJECT_AUXV</a>:
<a name="l03999"></a>03999       <span class="keywordflow">return</span> <a class="code" href="auxv_8c.html#a6407d5afd1ec7b9351a9e4e33dbb6955">memory_xfer_auxv</a> (ops, <span class="keywordtype">object</span>, annex, readbuf, writebuf,
<a name="l04000"></a>04000                                offset, len);
<a name="l04001"></a>04001 <span class="preprocessor">#endif</span>
<a name="l04002"></a>04002 <span class="preprocessor"></span>
<a name="l04003"></a>04003     <span class="keywordflow">default</span>:
<a name="l04004"></a>04004       <span class="keywordflow">if</span> (ops-&gt;<a class="code" href="structtarget__ops.html#a1b180ccb4db2afccf46e691862bf2ddf">beneath</a> != NULL)
<a name="l04005"></a>04005         <span class="keywordflow">return</span> ops-&gt;<a class="code" href="structtarget__ops.html#a1b180ccb4db2afccf46e691862bf2ddf">beneath</a>-&gt;<a class="code" href="structtarget__ops.html#a095389eb9862ff7550e8286c54e33ad3">to_xfer_partial</a> (ops-&gt;<a class="code" href="structtarget__ops.html#a1b180ccb4db2afccf46e691862bf2ddf">beneath</a>, <span class="keywordtype">object</span>, annex,
<a name="l04006"></a>04006                                               readbuf, writebuf, offset, len);
<a name="l04007"></a>04007       <span class="keywordflow">return</span> -1;
<a name="l04008"></a>04008     }
<a name="l04009"></a>04009 }
<a name="l04010"></a>04010 
<a name="l04011"></a>04011 
<a name="l04012"></a>04012 <span class="comment">/* Transfer LEN bytes between GDB address MYADDR and target address</span>
<a name="l04013"></a>04013 <span class="comment">   MEMADDR.  If DOWRITE is non-zero, transfer them to the target,</span>
<a name="l04014"></a>04014 <span class="comment">   otherwise transfer them from the target.  TARGET is unused.</span>
<a name="l04015"></a>04015 <span class="comment"></span>
<a name="l04016"></a>04016 <span class="comment">   The return value is 0 if an error occurred or no bytes were</span>
<a name="l04017"></a>04017 <span class="comment">   transferred.  Otherwise, it will be a positive value which</span>
<a name="l04018"></a>04018 <span class="comment">   indicates the number of bytes transferred between gdb and the</span>
<a name="l04019"></a>04019 <span class="comment">   target.  (Note that the interface also makes provisions for</span>
<a name="l04020"></a>04020 <span class="comment">   negative values, but this capability isn&#39;t implemented here.)  */</span>
<a name="l04021"></a>04021 
<a name="l04022"></a>04022 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04023"></a><a class="code" href="procfs_8c.html#a7f53c1daa362f19a41f64509f422fc46">04023</a> <a class="code" href="procfs_8c.html#a7f53c1daa362f19a41f64509f422fc46">procfs_xfer_memory</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="exec_8h.html#ab268c3184bf49615e16de006a296a542">memaddr</a>, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *myaddr, <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>, <span class="keywordtype">int</span> dowrite,
<a name="l04024"></a>04024                     <span class="keyword">struct</span> <a class="code" href="structmem__attrib.html">mem_attrib</a> *attrib, <span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *target)
<a name="l04025"></a>04025 {
<a name="l04026"></a>04026   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l04027"></a>04027   <span class="keywordtype">int</span> nbytes = 0;
<a name="l04028"></a>04028 
<a name="l04029"></a>04029   <span class="comment">/* Find procinfo for main process.  */</span>
<a name="l04030"></a>04030   pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>), 0);
<a name="l04031"></a>04031   <span class="keywordflow">if</span> (pi-&gt;<a class="code" href="structprocinfo.html#a74f0f6631babefdb4908262293bb6f2e">as_fd</a> == 0 &amp;&amp;
<a name="l04032"></a>04032       <a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (pi, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca619a7f13145c989adc5f80dad9d9caaf">FD_AS</a>) == 0)
<a name="l04033"></a>04033     {
<a name="l04034"></a>04034       <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;xfer_memory, open_proc_files&quot;</span>, __LINE__);
<a name="l04035"></a>04035       <span class="keywordflow">return</span> 0;
<a name="l04036"></a>04036     }
<a name="l04037"></a>04037 
<a name="l04038"></a>04038   <span class="keywordflow">if</span> (lseek (pi-&gt;<a class="code" href="structprocinfo.html#a74f0f6631babefdb4908262293bb6f2e">as_fd</a>, (off_t) memaddr, SEEK_SET) == (off_t) memaddr)
<a name="l04039"></a>04039     {
<a name="l04040"></a>04040       <span class="keywordflow">if</span> (dowrite)
<a name="l04041"></a>04041         {
<a name="l04042"></a>04042 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l04043"></a>04043 <span class="preprocessor"></span>          <a class="code" href="proc-utils_8h.html#ab6c1419f0280a36475b81075fbc13ea5">PROCFS_NOTE</a> (<span class="stringliteral">&quot;write memory:\n&quot;</span>);
<a name="l04044"></a>04044 <span class="preprocessor">#else</span>
<a name="l04045"></a>04045 <span class="preprocessor"></span>          <a class="code" href="proc-utils_8h.html#ab6c1419f0280a36475b81075fbc13ea5">PROCFS_NOTE</a> (<span class="stringliteral">&quot;write memory:\n&quot;</span>);
<a name="l04046"></a>04046 <span class="preprocessor">#endif</span>
<a name="l04047"></a>04047 <span class="preprocessor"></span>          nbytes = write (pi-&gt;<a class="code" href="structprocinfo.html#a74f0f6631babefdb4908262293bb6f2e">as_fd</a>, myaddr, len);
<a name="l04048"></a>04048         }
<a name="l04049"></a>04049       <span class="keywordflow">else</span>
<a name="l04050"></a>04050         {
<a name="l04051"></a>04051           <a class="code" href="proc-utils_8h.html#ab6c1419f0280a36475b81075fbc13ea5">PROCFS_NOTE</a> (<span class="stringliteral">&quot;read  memory:\n&quot;</span>);
<a name="l04052"></a>04052           nbytes = <a class="code" href="expect-read1_8c.html#af32a16ad2dd9e48482f8f790db7dbbd2">read</a> (pi-&gt;<a class="code" href="structprocinfo.html#a74f0f6631babefdb4908262293bb6f2e">as_fd</a>, myaddr, len);
<a name="l04053"></a>04053         }
<a name="l04054"></a>04054       <span class="keywordflow">if</span> (nbytes &lt; 0)
<a name="l04055"></a>04055         {
<a name="l04056"></a>04056           nbytes = 0;
<a name="l04057"></a>04057         }
<a name="l04058"></a>04058     }
<a name="l04059"></a>04059   <span class="keywordflow">return</span> nbytes;
<a name="l04060"></a>04060 }
<a name="l04061"></a>04061 
<a name="l04062"></a>04062 <span class="comment">/* Called by target_resume before making child runnable.  Mark cached</span>
<a name="l04063"></a>04063 <span class="comment">   registers and status&#39;s invalid.  If there are &quot;dirty&quot; caches that</span>
<a name="l04064"></a>04064 <span class="comment">   need to be written back to the child process, do that.</span>
<a name="l04065"></a>04065 <span class="comment"></span>
<a name="l04066"></a>04066 <span class="comment">   File descriptors are also cached.  As they are a limited resource,</span>
<a name="l04067"></a>04067 <span class="comment">   we cannot hold onto them indefinitely.  However, as they are</span>
<a name="l04068"></a>04068 <span class="comment">   expensive to open, we don&#39;t want to throw them away</span>
<a name="l04069"></a>04069 <span class="comment">   indescriminately either.  As a compromise, we will keep the file</span>
<a name="l04070"></a>04070 <span class="comment">   descriptors for the parent process, but discard any file</span>
<a name="l04071"></a>04071 <span class="comment">   descriptors we may have accumulated for the threads.</span>
<a name="l04072"></a>04072 <span class="comment"></span>
<a name="l04073"></a>04073 <span class="comment">   As this function is called by iterate_over_threads, it always</span>
<a name="l04074"></a>04074 <span class="comment">   returns zero (so that iterate_over_threads will keep</span>
<a name="l04075"></a>04075 <span class="comment">   iterating).  */</span>
<a name="l04076"></a>04076 
<a name="l04077"></a>04077 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04078"></a><a class="code" href="procfs_8c.html#a0d02f2fc90ad771e5043d628d9556b0b">04078</a> <a class="code" href="procfs_8c.html#a0d02f2fc90ad771e5043d628d9556b0b">invalidate_cache</a> (<a class="code" href="structprocinfo.html">procinfo</a> *parent, <a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">void</span> *ptr)
<a name="l04079"></a>04079 {
<a name="l04080"></a>04080   <span class="comment">/* About to run the child; invalidate caches and do any other</span>
<a name="l04081"></a>04081 <span class="comment">     cleanup.  */</span>
<a name="l04082"></a>04082 
<a name="l04083"></a>04083 <span class="preprocessor">#if 0</span>
<a name="l04084"></a>04084 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (pi-&gt;gregs_dirty)
<a name="l04085"></a>04085     <span class="keywordflow">if</span> (parent == NULL ||
<a name="l04086"></a>04086         <a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">proc_get_current_thread</a> (parent) != pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>)
<a name="l04087"></a>04087       <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a157837678e57bda96a70afe61ef02c57">proc_set_gregs</a> (pi)) <span class="comment">/* flush gregs cache */</span>
<a name="l04088"></a>04088         <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;target_resume, set_gregs&quot;</span>,
<a name="l04089"></a>04089                    __LINE__);
<a name="l04090"></a>04090   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#acaa68f0472f945198b3cae4b382738d1">gdbarch_fp0_regnum</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ()) &gt;= 0)
<a name="l04091"></a>04091     <span class="keywordflow">if</span> (pi-&gt;fpregs_dirty)
<a name="l04092"></a>04092       <span class="keywordflow">if</span> (parent == NULL ||
<a name="l04093"></a>04093           <a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">proc_get_current_thread</a> (parent) != pi-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>)
<a name="l04094"></a>04094         <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a409cfe587b50c92fd09c4c1e71edcf17">proc_set_fpregs</a> (pi))      <span class="comment">/* flush fpregs cache */</span>
<a name="l04095"></a>04095           <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;target_resume, set_fpregs&quot;</span>,
<a name="l04096"></a>04096                      __LINE__);
<a name="l04097"></a>04097 <span class="preprocessor">#endif</span>
<a name="l04098"></a>04098 <span class="preprocessor"></span>
<a name="l04099"></a>04099   <span class="keywordflow">if</span> (parent != NULL)
<a name="l04100"></a>04100     {
<a name="l04101"></a>04101       <span class="comment">/* The presence of a parent indicates that this is an LWP.</span>
<a name="l04102"></a>04102 <span class="comment">         Close any file descriptors that it might have open.</span>
<a name="l04103"></a>04103 <span class="comment">         We don&#39;t do this to the master (parent) procinfo.  */</span>
<a name="l04104"></a>04104 
<a name="l04105"></a>04105       <a class="code" href="procfs_8c.html#ad61e7432a6ca3e0653550d2bf7c8be53">close_procinfo_files</a> (pi);
<a name="l04106"></a>04106     }
<a name="l04107"></a>04107   pi-&gt;<a class="code" href="structprocinfo.html#af644c8cc9c6b4f09babb3eaf994fa5fc">gregs_valid</a>   = 0;
<a name="l04108"></a>04108   pi-&gt;<a class="code" href="structprocinfo.html#a687b93500ed96768255ec07735113afb">fpregs_valid</a>  = 0;
<a name="l04109"></a>04109 <span class="preprocessor">#if 0</span>
<a name="l04110"></a>04110 <span class="preprocessor"></span>  pi-&gt;gregs_dirty   = 0;
<a name="l04111"></a>04111   pi-&gt;fpregs_dirty  = 0;
<a name="l04112"></a>04112 <span class="preprocessor">#endif</span>
<a name="l04113"></a>04113 <span class="preprocessor"></span>  pi-&gt;<a class="code" href="structprocinfo.html#aecad003d259439f20d6cdbca6a183f2f">status_valid</a>  = 0;
<a name="l04114"></a>04114   pi-&gt;<a class="code" href="structprocinfo.html#a29eed4e1916725d4db440b31b010a2a3">threads_valid</a> = 0;
<a name="l04115"></a>04115 
<a name="l04116"></a>04116   <span class="keywordflow">return</span> 0;
<a name="l04117"></a>04117 }
<a name="l04118"></a>04118 
<a name="l04119"></a>04119 <span class="preprocessor">#if 0</span>
<a name="l04120"></a>04120 <span class="preprocessor"></span><span class="comment">/* A callback function for iterate_over_threads.  Find the</span>
<a name="l04121"></a>04121 <span class="comment">   asynchronous signal thread, and make it runnable.  See if that</span>
<a name="l04122"></a>04122 <span class="comment">   helps matters any.  */</span>
<a name="l04123"></a>04123 
<a name="l04124"></a>04124 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04125"></a>04125 make_signal_thread_runnable (<a class="code" href="structprocinfo.html">procinfo</a> *process, <a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">void</span> *ptr)
<a name="l04126"></a>04126 {
<a name="l04127"></a>04127 <span class="preprocessor">#ifdef PR_ASLWP</span>
<a name="l04128"></a>04128 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (pi) &amp; PR_ASLWP)
<a name="l04129"></a>04129     {
<a name="l04130"></a>04130       <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#ad2d6284c468ce487d8a75149b4dd2c07">proc_run_process</a> (pi, 0, -1))
<a name="l04131"></a>04131         <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;make_signal_thread_runnable&quot;</span>, __LINE__);
<a name="l04132"></a>04132       <span class="keywordflow">return</span> 1;
<a name="l04133"></a>04133     }
<a name="l04134"></a>04134 <span class="preprocessor">#endif</span>
<a name="l04135"></a>04135 <span class="preprocessor"></span>  <span class="keywordflow">return</span> 0;
<a name="l04136"></a>04136 }
<a name="l04137"></a>04137 <span class="preprocessor">#endif</span>
<a name="l04138"></a>04138 <span class="preprocessor"></span>
<a name="l04139"></a>04139 <span class="comment">/* Make the child process runnable.  Normally we will then call</span>
<a name="l04140"></a>04140 <span class="comment">   procfs_wait and wait for it to stop again (unless gdb is async).</span>
<a name="l04141"></a>04141 <span class="comment"></span>
<a name="l04142"></a>04142 <span class="comment">   If STEP is true, then arrange for the child to stop again after</span>
<a name="l04143"></a>04143 <span class="comment">   executing a single instruction.  If SIGNO is zero, then cancel any</span>
<a name="l04144"></a>04144 <span class="comment">   pending signal; if non-zero, then arrange for the indicated signal</span>
<a name="l04145"></a>04145 <span class="comment">   to be delivered to the child when it runs.  If PID is -1, then</span>
<a name="l04146"></a>04146 <span class="comment">   allow any child thread to run; if non-zero, then allow only the</span>
<a name="l04147"></a>04147 <span class="comment">   indicated thread to run.  (not implemented yet).  */</span>
<a name="l04148"></a>04148 
<a name="l04149"></a>04149 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04150"></a><a class="code" href="procfs_8c.html#a172a8e5cc4dbcb8e0ff8a67dbaabe58a">04150</a> <a class="code" href="procfs_8c.html#a172a8e5cc4dbcb8e0ff8a67dbaabe58a">procfs_resume</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l04151"></a>04151                <a class="code" href="structptid.html">ptid_t</a> ptid, <span class="keywordtype">int</span> step, <span class="keyword">enum</span> gdb_signal signo)
<a name="l04152"></a>04152 {
<a name="l04153"></a>04153   <a class="code" href="structprocinfo.html">procinfo</a> *pi, *thread;
<a name="l04154"></a>04154   <span class="keywordtype">int</span> native_signo;
<a name="l04155"></a>04155 
<a name="l04156"></a>04156   <span class="comment">/* 2.1:</span>
<a name="l04157"></a>04157 <span class="comment">     prrun.prflags |= PRSVADDR;</span>
<a name="l04158"></a>04158 <span class="comment">     prrun.pr_vaddr = $PC;         set resume address</span>
<a name="l04159"></a>04159 <span class="comment">     prrun.prflags |= PRSTRACE;    trace signals in pr_trace (all)</span>
<a name="l04160"></a>04160 <span class="comment">     prrun.prflags |= PRSFAULT;    trace faults in pr_fault (all but PAGE)</span>
<a name="l04161"></a>04161 <span class="comment">     prrun.prflags |= PRCFAULT;    clear current fault.</span>
<a name="l04162"></a>04162 <span class="comment"></span>
<a name="l04163"></a>04163 <span class="comment">     PRSTRACE and PRSFAULT can be done by other means</span>
<a name="l04164"></a>04164 <span class="comment">        (proc_trace_signals, proc_trace_faults)</span>
<a name="l04165"></a>04165 <span class="comment">     PRSVADDR is unnecessary.</span>
<a name="l04166"></a>04166 <span class="comment">     PRCFAULT may be replaced by a PIOCCFAULT call (proc_clear_current_fault)</span>
<a name="l04167"></a>04167 <span class="comment">     This basically leaves PRSTEP and PRCSIG.</span>
<a name="l04168"></a>04168 <span class="comment">     PRCSIG is like PIOCSSIG (proc_clear_current_signal).</span>
<a name="l04169"></a>04169 <span class="comment">     So basically PR_STEP is the sole argument that must be passed</span>
<a name="l04170"></a>04170 <span class="comment">     to proc_run_process (for use in the prrun struct by ioctl).  */</span>
<a name="l04171"></a>04171 
<a name="l04172"></a>04172   <span class="comment">/* Find procinfo for main process.  */</span>
<a name="l04173"></a>04173   pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>), 0);
<a name="l04174"></a>04174 
<a name="l04175"></a>04175   <span class="comment">/* First cut: ignore pid argument.  */</span>
<a name="l04176"></a>04176   errno = 0;
<a name="l04177"></a>04177 
<a name="l04178"></a>04178   <span class="comment">/* Convert signal to host numbering.  */</span>
<a name="l04179"></a>04179   <span class="keywordflow">if</span> (signo == 0 ||
<a name="l04180"></a>04180       (signo == GDB_SIGNAL_STOP &amp;&amp; pi-&gt;<a class="code" href="structprocinfo.html#a06291e3cc0449eb51f149e4d718d0218">ignore_next_sigstop</a>))
<a name="l04181"></a>04181     native_signo = 0;
<a name="l04182"></a>04182   <span class="keywordflow">else</span>
<a name="l04183"></a>04183     native_signo = <a class="code" href="gdb__signals_8h.html#a3a52a48f62fea8cbc7a51a933b11384a">gdb_signal_to_host</a> (signo);
<a name="l04184"></a>04184 
<a name="l04185"></a>04185   pi-&gt;<a class="code" href="structprocinfo.html#a06291e3cc0449eb51f149e4d718d0218">ignore_next_sigstop</a> = 0;
<a name="l04186"></a>04186 
<a name="l04187"></a>04187   <span class="comment">/* Running the process voids all cached registers and status.  */</span>
<a name="l04188"></a>04188   <span class="comment">/* Void the threads&#39; caches first.  */</span>
<a name="l04189"></a>04189   <a class="code" href="procfs_8c.html#a5fcfad306ae6b00c6d9b3c201d568580">proc_iterate_over_threads</a> (pi, <a class="code" href="procfs_8c.html#a0d02f2fc90ad771e5043d628d9556b0b">invalidate_cache</a>, NULL);
<a name="l04190"></a>04190   <span class="comment">/* Void the process procinfo&#39;s caches.  */</span>
<a name="l04191"></a>04191   <a class="code" href="procfs_8c.html#a0d02f2fc90ad771e5043d628d9556b0b">invalidate_cache</a> (NULL, pi, NULL);
<a name="l04192"></a>04192 
<a name="l04193"></a>04193   <span class="keywordflow">if</span> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (ptid) != -1)
<a name="l04194"></a>04194     {
<a name="l04195"></a>04195       <span class="comment">/* Resume a specific thread, presumably suppressing the</span>
<a name="l04196"></a>04196 <span class="comment">         others.  */</span>
<a name="l04197"></a>04197       thread = <a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (ptid), <a class="code" href="ptid_8c.html#af5b67a5f356c507b7809af2fa4e63b44">ptid_get_lwp</a> (ptid));
<a name="l04198"></a>04198       <span class="keywordflow">if</span> (thread != NULL)
<a name="l04199"></a>04199         {
<a name="l04200"></a>04200           <span class="keywordflow">if</span> (thread-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a> != 0)
<a name="l04201"></a>04201             {
<a name="l04202"></a>04202               <span class="comment">/* We&#39;re to resume a specific thread, and not the</span>
<a name="l04203"></a>04203 <span class="comment">                 others.  Set the child process&#39;s PR_ASYNC flag.  */</span>
<a name="l04204"></a>04204 <span class="preprocessor">#ifdef PR_ASYNC</span>
<a name="l04205"></a>04205 <span class="preprocessor"></span>              <span class="keywordflow">if</span> (!proc_set_async (pi))
<a name="l04206"></a>04206                 <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;target_resume, set_async&quot;</span>, __LINE__);
<a name="l04207"></a>04207 <span class="preprocessor">#endif</span>
<a name="l04208"></a>04208 <span class="preprocessor"></span><span class="preprocessor">#if 0</span>
<a name="l04209"></a>04209 <span class="preprocessor"></span>              <a class="code" href="procfs_8c.html#a5fcfad306ae6b00c6d9b3c201d568580">proc_iterate_over_threads</a> (pi,
<a name="l04210"></a>04210                                          make_signal_thread_runnable,
<a name="l04211"></a>04211                                          NULL);
<a name="l04212"></a>04212 <span class="preprocessor">#endif</span>
<a name="l04213"></a>04213 <span class="preprocessor"></span>              pi = thread;      <span class="comment">/* Substitute the thread&#39;s procinfo</span>
<a name="l04214"></a>04214 <span class="comment">                                   for run.  */</span>
<a name="l04215"></a>04215             }
<a name="l04216"></a>04216         }
<a name="l04217"></a>04217     }
<a name="l04218"></a>04218 
<a name="l04219"></a>04219   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#ad2d6284c468ce487d8a75149b4dd2c07">proc_run_process</a> (pi, step, native_signo))
<a name="l04220"></a>04220     {
<a name="l04221"></a>04221       <span class="keywordflow">if</span> (errno == EBUSY)
<a name="l04222"></a>04222         <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;resume: target already running.  &quot;</span>
<a name="l04223"></a>04223                    <span class="stringliteral">&quot;Pretend to resume, and hope for the best!&quot;</span>));
<a name="l04224"></a>04224       <span class="keywordflow">else</span>
<a name="l04225"></a>04225         <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;target_resume&quot;</span>, __LINE__);
<a name="l04226"></a>04226     }
<a name="l04227"></a>04227 }
<a name="l04228"></a>04228 
<a name="l04229"></a>04229 <span class="comment">/* Set up to trace signals in the child process.  */</span>
<a name="l04230"></a>04230 
<a name="l04231"></a>04231 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04232"></a><a class="code" href="procfs_8c.html#a92457ed7ea9f9921b2dfe6a0e03e9fe7">04232</a> <a class="code" href="procfs_8c.html#a92457ed7ea9f9921b2dfe6a0e03e9fe7">procfs_pass_signals</a> (<span class="keywordtype">int</span> numsigs, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pass_signals)
<a name="l04233"></a>04233 {
<a name="l04234"></a>04234   gdb_sigset_t <a class="code" href="signals_8c.html#a0be4713a4f9c136a226c0fb7ab512a97">signals</a>;
<a name="l04235"></a>04235   <a class="code" href="structprocinfo.html">procinfo</a> *pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>), 0);
<a name="l04236"></a>04236   <span class="keywordtype">int</span> signo;
<a name="l04237"></a>04237 
<a name="l04238"></a>04238   prfillset (&amp;signals);
<a name="l04239"></a>04239 
<a name="l04240"></a>04240   <span class="keywordflow">for</span> (signo = 0; signo &lt; NSIG; signo++)
<a name="l04241"></a>04241     {
<a name="l04242"></a>04242       <span class="keywordtype">int</span> target_signo = <a class="code" href="gdb__signals_8h.html#a11fcc2899ec63af2c688695243202f1a">gdb_signal_from_host</a> (signo);
<a name="l04243"></a>04243       <span class="keywordflow">if</span> (target_signo &lt; numsigs &amp;&amp; pass_signals[target_signo])
<a name="l04244"></a>04244         <a class="code" href="procfs_8c.html#a15c2ad85ffb214687d7804f6b67ccd30">gdb_prdelset</a> (&amp;signals, signo);
<a name="l04245"></a>04245     }
<a name="l04246"></a>04246 
<a name="l04247"></a>04247   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#af04151458bd3246bc210bc06eae93f66">proc_set_traced_signals</a> (pi, &amp;signals))
<a name="l04248"></a>04248     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;pass_signals&quot;</span>, __LINE__);
<a name="l04249"></a>04249 }
<a name="l04250"></a>04250 
<a name="l04251"></a>04251 <span class="comment">/* Print status information about the child process.  */</span>
<a name="l04252"></a>04252 
<a name="l04253"></a>04253 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04254"></a><a class="code" href="procfs_8c.html#a2f8758826b72fd2021061324c6e047e1">04254</a> <a class="code" href="procfs_8c.html#a2f8758826b72fd2021061324c6e047e1">procfs_files_info</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *<a class="code" href="corelow_8c.html#ac54c1aef0966c38fc155dec95a38db50">ignore</a>)
<a name="l04255"></a>04255 {
<a name="l04256"></a>04256   <span class="keyword">struct </span><a class="code" href="structinferior.html">inferior</a> *<a class="code" href="structinf.html">inf</a> = <a class="code" href="inferior_8c.html#a9e592c83e7c0c1f89f1a4a392bd1a277">current_inferior</a> ();
<a name="l04257"></a>04257 
<a name="l04258"></a>04258   <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\tUsing the running image of %s %s via /proc.\n&quot;</span>),
<a name="l04259"></a>04259                    inf-&gt;<a class="code" href="structinferior.html#a2a806ec9d3ad6bda987e716e653a1980">attach_flag</a>? <span class="stringliteral">&quot;attached&quot;</span>: <span class="stringliteral">&quot;child&quot;</span>,
<a name="l04260"></a>04260                    <a class="code" href="target_8c.html#a25ebd5fbc0b84bf9b914f7a21bfa6f7b">target_pid_to_str</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>));
<a name="l04261"></a>04261 }
<a name="l04262"></a>04262 
<a name="l04263"></a>04263 <span class="comment">/* Stop the child process asynchronously, as when the gdb user types</span>
<a name="l04264"></a>04264 <span class="comment">   control-c or presses a &quot;stop&quot; button.  Works by sending</span>
<a name="l04265"></a>04265 <span class="comment">   kill(SIGINT) to the child&#39;s process group.  */</span>
<a name="l04266"></a>04266 
<a name="l04267"></a>04267 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04268"></a><a class="code" href="procfs_8c.html#a28b2e19292b62274a2ece8025614716e">04268</a> <a class="code" href="procfs_8c.html#a28b2e19292b62274a2ece8025614716e">procfs_stop</a> (<a class="code" href="structptid.html">ptid_t</a> ptid)
<a name="l04269"></a>04269 {
<a name="l04270"></a>04270   kill (-inferior_process_group (), SIGINT);
<a name="l04271"></a>04271 }
<a name="l04272"></a>04272 
<a name="l04273"></a>04273 <span class="comment">/* Make it die.  Wait for it to die.  Clean up after it.  Note: this</span>
<a name="l04274"></a>04274 <span class="comment">   should only be applied to the real process, not to an LWP, because</span>
<a name="l04275"></a>04275 <span class="comment">   of the check for parent-process.  If we need this to work for an</span>
<a name="l04276"></a>04276 <span class="comment">   LWP, it needs some more logic.  */</span>
<a name="l04277"></a>04277 
<a name="l04278"></a>04278 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04279"></a><a class="code" href="procfs_8c.html#a8bf46ac06a2d1dd67af84aedd0b81280">04279</a> <a class="code" href="procfs_8c.html#a8bf46ac06a2d1dd67af84aedd0b81280">unconditionally_kill_inferior</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi)
<a name="l04280"></a>04280 {
<a name="l04281"></a>04281   <span class="keywordtype">int</span> parent_pid;
<a name="l04282"></a>04282 
<a name="l04283"></a>04283   parent_pid = <a class="code" href="procfs_8c.html#a045d9529c1ae6766642a42468f2dbaf0">proc_parent_pid</a> (pi);
<a name="l04284"></a>04284 <span class="preprocessor">#ifdef PROCFS_NEED_CLEAR_CURSIG_FOR_KILL</span>
<a name="l04285"></a>04285 <span class="preprocessor"></span>  <span class="comment">/* FIXME: use access functions.  */</span>
<a name="l04286"></a>04286   <span class="comment">/* Alpha OSF/1-3.x procfs needs a clear of the current signal</span>
<a name="l04287"></a>04287 <span class="comment">     before the PIOCKILL, otherwise it might generate a corrupted core</span>
<a name="l04288"></a>04288 <span class="comment">     file for the inferior.  */</span>
<a name="l04289"></a>04289   <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSSIG, NULL) &lt; 0)
<a name="l04290"></a>04290     {
<a name="l04291"></a>04291       <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;unconditionally_kill: SSIG failed!\n&quot;</span>);
<a name="l04292"></a>04292     }
<a name="l04293"></a>04293 <span class="preprocessor">#endif</span>
<a name="l04294"></a>04294 <span class="preprocessor"></span><span class="preprocessor">#ifdef PROCFS_NEED_PIOCSSIG_FOR_KILL</span>
<a name="l04295"></a>04295 <span class="preprocessor"></span>  <span class="comment">/* Alpha OSF/1-2.x procfs needs a PIOCSSIG call with a SIGKILL signal</span>
<a name="l04296"></a>04296 <span class="comment">     to kill the inferior, otherwise it might remain stopped with a</span>
<a name="l04297"></a>04297 <span class="comment">     pending SIGKILL.</span>
<a name="l04298"></a>04298 <span class="comment">     We do not check the result of the PIOCSSIG, the inferior might have</span>
<a name="l04299"></a>04299 <span class="comment">     died already.  */</span>
<a name="l04300"></a>04300   {
<a name="l04301"></a>04301     gdb_siginfo_t newsiginfo;
<a name="l04302"></a>04302 
<a name="l04303"></a>04303     <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> ((<span class="keywordtype">char</span> *) &amp;newsiginfo, 0, <span class="keyword">sizeof</span> (newsiginfo));
<a name="l04304"></a>04304     newsiginfo.si_signo = SIGKILL;
<a name="l04305"></a>04305     newsiginfo.si_code = 0;
<a name="l04306"></a>04306     newsiginfo.si_errno = 0;
<a name="l04307"></a>04307     newsiginfo.si_pid = getpid ();
<a name="l04308"></a>04308     newsiginfo.si_uid = getuid ();
<a name="l04309"></a>04309     <span class="comment">/* FIXME: use proc_set_current_signal.  */</span>
<a name="l04310"></a>04310     ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSSIG, &amp;newsiginfo);
<a name="l04311"></a>04311   }
<a name="l04312"></a>04312 <span class="preprocessor">#else </span><span class="comment">/* PROCFS_NEED_PIOCSSIG_FOR_KILL */</span>
<a name="l04313"></a>04313   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a84a4b60eae474b08fe9ede25c27b5d26">proc_kill</a> (pi, SIGKILL))
<a name="l04314"></a>04314     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;unconditionally_kill, proc_kill&quot;</span>, __LINE__);
<a name="l04315"></a>04315 <span class="preprocessor">#endif </span><span class="comment">/* PROCFS_NEED_PIOCSSIG_FOR_KILL */</span>
<a name="l04316"></a>04316   <a class="code" href="procfs_8c.html#af0251ed126d7aa5845297cab52db3b68">destroy_procinfo</a> (pi);
<a name="l04317"></a>04317 
<a name="l04318"></a>04318   <span class="comment">/* If pi is GDB&#39;s child, wait for it to die.  */</span>
<a name="l04319"></a>04319   <span class="keywordflow">if</span> (parent_pid == getpid ())
<a name="l04320"></a>04320     <span class="comment">/* FIXME: should we use waitpid to make sure we get the right event?</span>
<a name="l04321"></a>04321 <span class="comment">       Should we check the returned event?  */</span>
<a name="l04322"></a>04322     {
<a name="l04323"></a>04323 <span class="preprocessor">#if 0</span>
<a name="l04324"></a>04324 <span class="preprocessor"></span>      <span class="keywordtype">int</span> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>, ret;
<a name="l04325"></a>04325 
<a name="l04326"></a>04326       ret = waitpid (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, &amp;status, 0);
<a name="l04327"></a>04327 <span class="preprocessor">#else</span>
<a name="l04328"></a>04328 <span class="preprocessor"></span>      wait (NULL);
<a name="l04329"></a>04329 <span class="preprocessor">#endif</span>
<a name="l04330"></a>04330 <span class="preprocessor"></span>    }
<a name="l04331"></a>04331 }
<a name="l04332"></a>04332 
<a name="l04333"></a>04333 <span class="comment">/* We&#39;re done debugging it, and we want it to go away.  Then we want</span>
<a name="l04334"></a>04334 <span class="comment">   GDB to forget all about it.  */</span>
<a name="l04335"></a>04335 
<a name="l04336"></a>04336 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04337"></a><a class="code" href="procfs_8c.html#a9e0074e6a1c64ae9a12f8bbc7dfabdad">04337</a> <a class="code" href="procfs_8c.html#a9e0074e6a1c64ae9a12f8bbc7dfabdad">procfs_kill_inferior</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops)
<a name="l04338"></a>04338 {
<a name="l04339"></a>04339   <span class="keywordflow">if</span> (!<a class="code" href="ptid_8c.html#a0df58c8db2620a2cec647934b4f77266">ptid_equal</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>, <a class="code" href="ptid_8c.html#acba69c857786546b204883bbcc90a64e">null_ptid</a>)) <span class="comment">/* ? */</span>
<a name="l04340"></a>04340     {
<a name="l04341"></a>04341       <span class="comment">/* Find procinfo for main process.  */</span>
<a name="l04342"></a>04342       <a class="code" href="structprocinfo.html">procinfo</a> *pi = <a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>), 0);
<a name="l04343"></a>04343 
<a name="l04344"></a>04344       <span class="keywordflow">if</span> (pi)
<a name="l04345"></a>04345         <a class="code" href="procfs_8c.html#a8bf46ac06a2d1dd67af84aedd0b81280">unconditionally_kill_inferior</a> (pi);
<a name="l04346"></a>04346       <a class="code" href="target_8c.html#a431ec8acf68f0b609e306fea2297a08f">target_mourn_inferior</a> ();
<a name="l04347"></a>04347     }
<a name="l04348"></a>04348 }
<a name="l04349"></a>04349 
<a name="l04350"></a>04350 <span class="comment">/* Forget we ever debugged this thing!  */</span>
<a name="l04351"></a>04351 
<a name="l04352"></a>04352 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04353"></a><a class="code" href="procfs_8c.html#a147a0734a33ddc5c6f60a741658ef5da">04353</a> <a class="code" href="procfs_8c.html#a147a0734a33ddc5c6f60a741658ef5da">procfs_mourn_inferior</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops)
<a name="l04354"></a>04354 {
<a name="l04355"></a>04355   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l04356"></a>04356 
<a name="l04357"></a>04357   <span class="keywordflow">if</span> (!<a class="code" href="ptid_8c.html#a0df58c8db2620a2cec647934b4f77266">ptid_equal</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>, <a class="code" href="ptid_8c.html#acba69c857786546b204883bbcc90a64e">null_ptid</a>))
<a name="l04358"></a>04358     {
<a name="l04359"></a>04359       <span class="comment">/* Find procinfo for main process.  */</span>
<a name="l04360"></a>04360       pi = <a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>), 0);
<a name="l04361"></a>04361       <span class="keywordflow">if</span> (pi)
<a name="l04362"></a>04362         <a class="code" href="procfs_8c.html#af0251ed126d7aa5845297cab52db3b68">destroy_procinfo</a> (pi);
<a name="l04363"></a>04363     }
<a name="l04364"></a>04364   <a class="code" href="target_8c.html#a9599d37847d1388531abb3f2aeba6616">unpush_target</a> (ops);
<a name="l04365"></a>04365 
<a name="l04366"></a>04366   <span class="keywordflow">if</span> (dbx_link_bpt != NULL)
<a name="l04367"></a>04367     {
<a name="l04368"></a>04368       <a class="code" href="breakpoint_8c.html#a1355b81d333bd3fe9e87bd29ea08b779">deprecated_remove_raw_breakpoint</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> (), dbx_link_bpt);
<a name="l04369"></a>04369       dbx_link_bpt_addr = 0;
<a name="l04370"></a>04370       dbx_link_bpt = NULL;
<a name="l04371"></a>04371     }
<a name="l04372"></a>04372 
<a name="l04373"></a>04373   <a class="code" href="inferior_8h.html#a9a32ba9b0213fdcd9dbf83969884ebcd">generic_mourn_inferior</a> ();
<a name="l04374"></a>04374 }
<a name="l04375"></a>04375 
<a name="l04376"></a>04376 <span class="comment">/* When GDB forks to create a runnable inferior process, this function</span>
<a name="l04377"></a>04377 <span class="comment">   is called on the parent side of the fork.  It&#39;s job is to do</span>
<a name="l04378"></a>04378 <span class="comment">   whatever is necessary to make the child ready to be debugged, and</span>
<a name="l04379"></a>04379 <span class="comment">   then wait for the child to synchronize.  */</span>
<a name="l04380"></a>04380 
<a name="l04381"></a>04381 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04382"></a><a class="code" href="procfs_8c.html#acc729f3b725f5336550c97d27f037541">04382</a> <a class="code" href="procfs_8c.html#acc729f3b725f5336550c97d27f037541">procfs_init_inferior</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops, <span class="keywordtype">int</span> pid)
<a name="l04383"></a>04383 {
<a name="l04384"></a>04384   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l04385"></a>04385   gdb_sigset_t <a class="code" href="signals_8c.html#a0be4713a4f9c136a226c0fb7ab512a97">signals</a>;
<a name="l04386"></a>04386   <span class="keywordtype">int</span> fail;
<a name="l04387"></a>04387   <span class="keywordtype">int</span> lwpid;
<a name="l04388"></a>04388 
<a name="l04389"></a>04389   <span class="comment">/* This routine called on the parent side (GDB side)</span>
<a name="l04390"></a>04390 <span class="comment">     after GDB forks the inferior.  */</span>
<a name="l04391"></a>04391   <a class="code" href="target_8c.html#ada1b9dc1eeb0546d39b86ba7ac645e67">push_target</a> (ops);
<a name="l04392"></a>04392 
<a name="l04393"></a>04393   <span class="keywordflow">if</span> ((pi = <a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a> (pid, 0)) == NULL)
<a name="l04394"></a>04394     perror (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs: out of memory in &#39;init_inferior&#39;&quot;</span>));
<a name="l04395"></a>04395 
<a name="l04396"></a>04396   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (pi, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca242b7fbe149191cf293910e1f2f65bd6">FD_CTL</a>))
<a name="l04397"></a>04397     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;init_inferior, open_proc_files&quot;</span>, __LINE__);
<a name="l04398"></a>04398 
<a name="l04399"></a>04399   <span class="comment">/*</span>
<a name="l04400"></a>04400 <span class="comment">    xmalloc                     // done</span>
<a name="l04401"></a>04401 <span class="comment">    open_procinfo_files         // done</span>
<a name="l04402"></a>04402 <span class="comment">    link list                   // done</span>
<a name="l04403"></a>04403 <span class="comment">    prfillset (trace)</span>
<a name="l04404"></a>04404 <span class="comment">    procfs_notice_signals</span>
<a name="l04405"></a>04405 <span class="comment">    prfillset (fault)</span>
<a name="l04406"></a>04406 <span class="comment">    prdelset (FLTPAGE)</span>
<a name="l04407"></a>04407 <span class="comment">    PIOCWSTOP</span>
<a name="l04408"></a>04408 <span class="comment">    PIOCSFAULT</span>
<a name="l04409"></a>04409 <span class="comment">    */</span>
<a name="l04410"></a>04410 
<a name="l04411"></a>04411   <span class="comment">/* If not stopped yet, wait for it to stop.  */</span>
<a name="l04412"></a>04412   <span class="keywordflow">if</span> (!(<a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (pi) &amp; PR_STOPPED) &amp;&amp;
<a name="l04413"></a>04413       !(<a class="code" href="procfs_8c.html#ac6105e9b1d932acc33f65ca921e8d1cb">proc_wait_for_stop</a> (pi)))
<a name="l04414"></a>04414     <a class="code" href="procfs_8c.html#a4a363dfa0e8f3f68a66a7152e0d95913">dead_procinfo</a> (pi, <span class="stringliteral">&quot;init_inferior: wait_for_stop failed&quot;</span>, <a class="code" href="procfs_8c.html#a0ae1e3bf78c960c83e2d437efd802058a702a32e3574ea40b8d2f358dec764298">KILL</a>);
<a name="l04415"></a>04415 
<a name="l04416"></a>04416   <span class="comment">/* Save some of the /proc state to be restored if we detach.  */</span>
<a name="l04417"></a>04417   <span class="comment">/* FIXME: Why?  In case another debugger was debugging it?</span>
<a name="l04418"></a>04418 <span class="comment">     We&#39;re it&#39;s parent, for Ghu&#39;s sake!  */</span>
<a name="l04419"></a>04419   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a5b69e531d7ab6145e6a1d32487707a47">proc_get_traced_signals</a>  (pi, &amp;pi-&gt;<a class="code" href="structprocinfo.html#ae6922e85e89e6c7b3597a74856307d5c">saved_sigset</a>))
<a name="l04420"></a>04420     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;init_inferior, get_traced_signals&quot;</span>, __LINE__);
<a name="l04421"></a>04421   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a46d2e8aed15e86c7026a4b41ac4f025d">proc_get_held_signals</a>    (pi, &amp;pi-&gt;<a class="code" href="structprocinfo.html#a8893f6113351ec1bf61f3610dc140417">saved_sighold</a>))
<a name="l04422"></a>04422     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;init_inferior, get_held_signals&quot;</span>, __LINE__);
<a name="l04423"></a>04423   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a97bc5054c707856cb46f4e7272ae8817">proc_get_traced_faults</a>   (pi, &amp;pi-&gt;<a class="code" href="structprocinfo.html#ab6f5d831f0153fcc5441cb9050d62313">saved_fltset</a>))
<a name="l04424"></a>04424     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;init_inferior, get_traced_faults&quot;</span>, __LINE__);
<a name="l04425"></a>04425   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a383f37198255501af0d2097360b52063">proc_get_traced_sysentry</a> (pi, pi-&gt;<a class="code" href="structprocinfo.html#a7df20e8108a16cdf00b4a40039b97164">saved_entryset</a>))
<a name="l04426"></a>04426     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;init_inferior, get_traced_sysentry&quot;</span>, __LINE__);
<a name="l04427"></a>04427   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#afb19be38f985cb48545d7f81771dcf60">proc_get_traced_sysexit</a>  (pi, pi-&gt;<a class="code" href="structprocinfo.html#aa7801fdd3d9f15fda54aa8d81b3ccfd8">saved_exitset</a>))
<a name="l04428"></a>04428     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;init_inferior, get_traced_sysexit&quot;</span>, __LINE__);
<a name="l04429"></a>04429 
<a name="l04430"></a>04430   <span class="keywordflow">if</span> ((fail = <a class="code" href="procfs_8c.html#a80e7d9aa440370eb496a13d228ff3e69">procfs_debug_inferior</a> (pi)) != 0)
<a name="l04431"></a>04431     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;init_inferior (procfs_debug_inferior)&quot;</span>, fail);
<a name="l04432"></a>04432 
<a name="l04433"></a>04433   <span class="comment">/* FIXME: logically, we should really be turning OFF run-on-last-close,</span>
<a name="l04434"></a>04434 <span class="comment">     and possibly even turning ON kill-on-last-close at this point.  But</span>
<a name="l04435"></a>04435 <span class="comment">     I can&#39;t make that change without careful testing which I don&#39;t have</span>
<a name="l04436"></a>04436 <span class="comment">     time to do right now...  */</span>
<a name="l04437"></a>04437   <span class="comment">/* Turn on run-on-last-close flag so that the child</span>
<a name="l04438"></a>04438 <span class="comment">     will die if GDB goes away for some reason.  */</span>
<a name="l04439"></a>04439   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#adc200acb760eee688f9efffce872cfe1">proc_set_run_on_last_close</a> (pi))
<a name="l04440"></a>04440     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;init_inferior, set_RLC&quot;</span>, __LINE__);
<a name="l04441"></a>04441 
<a name="l04442"></a>04442   <span class="comment">/* We now have have access to the lwpid of the main thread/lwp.  */</span>
<a name="l04443"></a>04443   lwpid = <a class="code" href="procfs_8c.html#a9cfc18a5fcd4a09c2942c74305aee26c">proc_get_current_thread</a> (pi);
<a name="l04444"></a>04444 
<a name="l04445"></a>04445   <span class="comment">/* Create a procinfo for the main lwp.  */</span>
<a name="l04446"></a>04446   <a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a> (pid, lwpid);
<a name="l04447"></a>04447 
<a name="l04448"></a>04448   <span class="comment">/* We already have a main thread registered in the thread table at</span>
<a name="l04449"></a>04449 <span class="comment">     this point, but it didn&#39;t have any lwp info yet.  Notify the core</span>
<a name="l04450"></a>04450 <span class="comment">     about it.  This changes inferior_ptid as well.  */</span>
<a name="l04451"></a>04451   <a class="code" href="gdbthread_8h.html#a590b4966eeab01fd5ac42494ac442b13">thread_change_ptid</a> (<a class="code" href="ptid_8c.html#a41fa537798e02ba25c7980a7c1e46272">pid_to_ptid</a> (pid),
<a name="l04452"></a>04452                       <a class="code" href="ptid_8c.html#aa96ee3f6a88626ec36045b4d84e27f79">ptid_build</a> (pid, lwpid, 0));
<a name="l04453"></a>04453 
<a name="l04454"></a>04454   <span class="comment">/* Typically two, one trap to exec the shell, one to exec the</span>
<a name="l04455"></a>04455 <span class="comment">     program being debugged.  Defined by &quot;inferior.h&quot;.  */</span>
<a name="l04456"></a>04456   <a class="code" href="fork-child_8c.html#a223849d6502ce1e823d679089805a4ff">startup_inferior</a> (<a class="code" href="nm-osf3_8h.html#ad7674ebad4954cd58745f00c31b7e27f">START_INFERIOR_TRAPS_EXPECTED</a>);
<a name="l04457"></a>04457 
<a name="l04458"></a>04458 <span class="preprocessor">#ifdef SYS_syssgi</span>
<a name="l04459"></a>04459 <span class="preprocessor"></span>  <span class="comment">/* On mips-irix, we need to stop the inferior early enough during</span>
<a name="l04460"></a>04460 <span class="comment">     the startup phase in order to be able to load the shared library</span>
<a name="l04461"></a>04461 <span class="comment">     symbols and insert the breakpoints that are located in these shared</span>
<a name="l04462"></a>04462 <span class="comment">     libraries.  Stopping at the program entry point is not good enough</span>
<a name="l04463"></a>04463 <span class="comment">     because the -init code is executed before the execution reaches</span>
<a name="l04464"></a>04464 <span class="comment">     that point.</span>
<a name="l04465"></a>04465 <span class="comment"></span>
<a name="l04466"></a>04466 <span class="comment">     So what we need to do is to insert a breakpoint in the runtime</span>
<a name="l04467"></a>04467 <span class="comment">     loader (rld), more precisely in __dbx_link().  This procedure is</span>
<a name="l04468"></a>04468 <span class="comment">     called by rld once all shared libraries have been mapped, but before</span>
<a name="l04469"></a>04469 <span class="comment">     the -init code is executed.  Unfortuantely, this is not straightforward,</span>
<a name="l04470"></a>04470 <span class="comment">     as rld is not part of the executable we are running, and thus we need</span>
<a name="l04471"></a>04471 <span class="comment">     the inferior to run until rld itself has been mapped in memory.</span>
<a name="l04472"></a>04472 <span class="comment"></span>
<a name="l04473"></a>04473 <span class="comment">     For this, we trace all syssgi() syscall exit events.  Each time</span>
<a name="l04474"></a>04474 <span class="comment">     we detect such an event, we iterate over each text memory maps,</span>
<a name="l04475"></a>04475 <span class="comment">     get its associated fd, and scan the symbol table for __dbx_link().</span>
<a name="l04476"></a>04476 <span class="comment">     When found, we know that rld has been mapped, and that we can insert</span>
<a name="l04477"></a>04477 <span class="comment">     the breakpoint at the symbol address.  Once the dbx_link() breakpoint</span>
<a name="l04478"></a>04478 <span class="comment">     has been inserted, the syssgi() notifications are no longer necessary,</span>
<a name="l04479"></a>04479 <span class="comment">     so they should be canceled.  */</span>
<a name="l04480"></a>04480   <a class="code" href="procfs_8c.html#ae027347db869ac7b72aa4a12608fb54b">proc_trace_syscalls_1</a> (pi, SYS_syssgi, PR_SYSEXIT, <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dadadd120ee5969e963eb496b7a32d13e376">FLAG_SET</a>, 0);
<a name="l04481"></a>04481 <span class="preprocessor">#endif</span>
<a name="l04482"></a>04482 <span class="preprocessor"></span>}
<a name="l04483"></a>04483 
<a name="l04484"></a>04484 <span class="comment">/* When GDB forks to create a new process, this function is called on</span>
<a name="l04485"></a>04485 <span class="comment">   the child side of the fork before GDB exec&#39;s the user program.  Its</span>
<a name="l04486"></a>04486 <span class="comment">   job is to make the child minimally debuggable, so that the parent</span>
<a name="l04487"></a>04487 <span class="comment">   GDB process can connect to the child and take over.  This function</span>
<a name="l04488"></a>04488 <span class="comment">   should do only the minimum to make that possible, and to</span>
<a name="l04489"></a>04489 <span class="comment">   synchronize with the parent process.  The parent process should</span>
<a name="l04490"></a>04490 <span class="comment">   take care of the details.  */</span>
<a name="l04491"></a>04491 
<a name="l04492"></a>04492 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04493"></a><a class="code" href="procfs_8c.html#a9f31120a080e3639ade9e906dae2648a">04493</a> <a class="code" href="procfs_8c.html#a9f31120a080e3639ade9e906dae2648a">procfs_set_exec_trap</a> (<span class="keywordtype">void</span>)
<a name="l04494"></a>04494 {
<a name="l04495"></a>04495   <span class="comment">/* This routine called on the child side (inferior side)</span>
<a name="l04496"></a>04496 <span class="comment">     after GDB forks the inferior.  It must use only local variables,</span>
<a name="l04497"></a>04497 <span class="comment">     because it may be sharing data space with its parent.  */</span>
<a name="l04498"></a>04498 
<a name="l04499"></a>04499   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l04500"></a>04500   sysset_t *exitset;
<a name="l04501"></a>04501 
<a name="l04502"></a>04502   <span class="keywordflow">if</span> ((pi = <a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a> (getpid (), 0)) == NULL)
<a name="l04503"></a>04503     <a class="code" href="utils_8c.html#a14801ceb45147833b8ce111c89ea0d5f">perror_with_name</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs: create_procinfo failed in child.&quot;</span>));
<a name="l04504"></a>04504 
<a name="l04505"></a>04505   <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (pi, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca242b7fbe149191cf293910e1f2f65bd6">FD_CTL</a>) == 0)
<a name="l04506"></a>04506     {
<a name="l04507"></a>04507       <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;set_exec_trap, open_proc_files&quot;</span>, __LINE__);
<a name="l04508"></a>04508       <a class="code" href="ui-file_8c.html#a046f07b5ef1bcc35c28b4be983e39998">gdb_flush</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>);
<a name="l04509"></a>04509       <span class="comment">/* No need to call &quot;dead_procinfo&quot;, because we&#39;re going to</span>
<a name="l04510"></a>04510 <span class="comment">         exit.  */</span>
<a name="l04511"></a>04511       _exit (127);
<a name="l04512"></a>04512     }
<a name="l04513"></a>04513 
<a name="l04514"></a>04514 <span class="preprocessor">#ifdef PRFS_STOPEXEC    </span><span class="comment">/* defined on OSF */</span>
<a name="l04515"></a>04515   <span class="comment">/* OSF method for tracing exec syscalls.  Quoting:</span>
<a name="l04516"></a>04516 <span class="comment">     Under Alpha OSF/1 we have to use a PIOCSSPCACT ioctl to trace</span>
<a name="l04517"></a>04517 <span class="comment">     exits from exec system calls because of the user level loader.  */</span>
<a name="l04518"></a>04518   <span class="comment">/* FIXME: make nice and maybe move into an access function.  */</span>
<a name="l04519"></a>04519   {
<a name="l04520"></a>04520     <span class="keywordtype">int</span> prfs_flags;
<a name="l04521"></a>04521 
<a name="l04522"></a>04522     <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCGSPCACT, &amp;prfs_flags) &lt; 0)
<a name="l04523"></a>04523       {
<a name="l04524"></a>04524         <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;set_exec_trap (PIOCGSPCACT)&quot;</span>, __LINE__);
<a name="l04525"></a>04525         <a class="code" href="ui-file_8c.html#a046f07b5ef1bcc35c28b4be983e39998">gdb_flush</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>);
<a name="l04526"></a>04526         _exit (127);
<a name="l04527"></a>04527       }
<a name="l04528"></a>04528     prfs_flags |= PRFS_STOPEXEC;
<a name="l04529"></a>04529 
<a name="l04530"></a>04530     <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCSSPCACT, &amp;prfs_flags) &lt; 0)
<a name="l04531"></a>04531       {
<a name="l04532"></a>04532         <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;set_exec_trap (PIOCSSPCACT)&quot;</span>, __LINE__);
<a name="l04533"></a>04533         <a class="code" href="ui-file_8c.html#a046f07b5ef1bcc35c28b4be983e39998">gdb_flush</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>);
<a name="l04534"></a>04534         _exit (127);
<a name="l04535"></a>04535       }
<a name="l04536"></a>04536   }
<a name="l04537"></a>04537 <span class="preprocessor">#else </span><span class="comment">/* not PRFS_STOPEXEC */</span>
<a name="l04538"></a>04538   <span class="comment">/* Everyone else&#39;s (except OSF) method for tracing exec syscalls.  */</span>
<a name="l04539"></a>04539   <span class="comment">/* GW: Rationale...</span>
<a name="l04540"></a>04540 <span class="comment">     Not all systems with /proc have all the exec* syscalls with the same</span>
<a name="l04541"></a>04541 <span class="comment">     names.  On the SGI, for example, there is no SYS_exec, but there</span>
<a name="l04542"></a>04542 <span class="comment">     *is* a SYS_execv.  So, we try to account for that.  */</span>
<a name="l04543"></a>04543 
<a name="l04544"></a>04544   exitset = <a class="code" href="procfs_8c.html#a46e37b7eaec868b43af27d24b556e9c9">sysset_t_alloc</a> (pi);
<a name="l04545"></a>04545   <a class="code" href="procfs_8c.html#a59f0624d8796729e70bea1dda0394b81">gdb_premptysysset</a> (exitset);
<a name="l04546"></a>04546 <span class="preprocessor">#ifdef SYS_exec</span>
<a name="l04547"></a>04547 <span class="preprocessor"></span>  <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (exitset, SYS_exec);
<a name="l04548"></a>04548 <span class="preprocessor">#endif</span>
<a name="l04549"></a>04549 <span class="preprocessor"></span><span class="preprocessor">#ifdef SYS_execve</span>
<a name="l04550"></a>04550 <span class="preprocessor"></span>  <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (exitset, SYS_execve);
<a name="l04551"></a>04551 <span class="preprocessor">#endif</span>
<a name="l04552"></a>04552 <span class="preprocessor"></span><span class="preprocessor">#ifdef SYS_execv</span>
<a name="l04553"></a>04553 <span class="preprocessor"></span>  <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (exitset, SYS_execv);
<a name="l04554"></a>04554 <span class="preprocessor">#endif</span>
<a name="l04555"></a>04555 <span class="preprocessor"></span><span class="preprocessor">#ifdef DYNAMIC_SYSCALLS</span>
<a name="l04556"></a>04556 <span class="preprocessor"></span>  {
<a name="l04557"></a>04557     <span class="keywordtype">int</span> callnum = find_syscall (pi, <span class="stringliteral">&quot;execve&quot;</span>);
<a name="l04558"></a>04558 
<a name="l04559"></a>04559     <span class="keywordflow">if</span> (callnum &gt;= 0)
<a name="l04560"></a>04560       <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (exitset, callnum);
<a name="l04561"></a>04561 
<a name="l04562"></a>04562     callnum = find_syscall (pi, <span class="stringliteral">&quot;ra_execve&quot;</span>);
<a name="l04563"></a>04563     <span class="keywordflow">if</span> (callnum &gt;= 0)
<a name="l04564"></a>04564       <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (exitset, callnum);
<a name="l04565"></a>04565   }
<a name="l04566"></a>04566 <span class="preprocessor">#endif </span><span class="comment">/* DYNAMIC_SYSCALLS */</span>
<a name="l04567"></a>04567 
<a name="l04568"></a>04568   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a33c100a98eea13970f4ac33a7e9af14f">proc_set_traced_sysexit</a> (pi, exitset))
<a name="l04569"></a>04569     {
<a name="l04570"></a>04570       <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;set_exec_trap, set_traced_sysexit&quot;</span>, __LINE__);
<a name="l04571"></a>04571       <a class="code" href="ui-file_8c.html#a046f07b5ef1bcc35c28b4be983e39998">gdb_flush</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>);
<a name="l04572"></a>04572       _exit (127);
<a name="l04573"></a>04573     }
<a name="l04574"></a>04574 <span class="preprocessor">#endif </span><span class="comment">/* PRFS_STOPEXEC */</span>
<a name="l04575"></a>04575 
<a name="l04576"></a>04576   <span class="comment">/* FIXME: should this be done in the parent instead?  */</span>
<a name="l04577"></a>04577   <span class="comment">/* Turn off inherit on fork flag so that all grand-children</span>
<a name="l04578"></a>04578 <span class="comment">     of gdb start with tracing flags cleared.  */</span>
<a name="l04579"></a>04579   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#ab1738fc6f50141fc293139c7a0a2996a">proc_unset_inherit_on_fork</a> (pi))
<a name="l04580"></a>04580     <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;set_exec_trap, unset_inherit&quot;</span>, __LINE__);
<a name="l04581"></a>04581 
<a name="l04582"></a>04582   <span class="comment">/* Turn off run on last close flag, so that the child process</span>
<a name="l04583"></a>04583 <span class="comment">     cannot run away just because we close our handle on it.</span>
<a name="l04584"></a>04584 <span class="comment">     We want it to wait for the parent to attach.  */</span>
<a name="l04585"></a>04585   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#aa77e25cc788690550931b8a8b0a26aab">proc_unset_run_on_last_close</a> (pi))
<a name="l04586"></a>04586     <a class="code" href="procfs_8c.html#a9ffe1d2869f42aa891724ad082069ed9">proc_warn</a> (pi, <span class="stringliteral">&quot;set_exec_trap, unset_RLC&quot;</span>, __LINE__);
<a name="l04587"></a>04587 
<a name="l04588"></a>04588   <span class="comment">/* FIXME: No need to destroy the procinfo --</span>
<a name="l04589"></a>04589 <span class="comment">     we have our own address space, and we&#39;re about to do an exec!  */</span>
<a name="l04590"></a>04590   <span class="comment">/*destroy_procinfo (pi);*/</span>
<a name="l04591"></a>04591 }
<a name="l04592"></a>04592 
<a name="l04593"></a>04593 <span class="comment">/* This function is called BEFORE gdb forks the inferior process.  Its</span>
<a name="l04594"></a>04594 <span class="comment">   only real responsibility is to set things up for the fork, and tell</span>
<a name="l04595"></a>04595 <span class="comment">   GDB which two functions to call after the fork (one for the parent,</span>
<a name="l04596"></a>04596 <span class="comment">   and one for the child).</span>
<a name="l04597"></a>04597 <span class="comment"></span>
<a name="l04598"></a>04598 <span class="comment">   This function does a complicated search for a unix shell program,</span>
<a name="l04599"></a>04599 <span class="comment">   which it then uses to parse arguments and environment variables to</span>
<a name="l04600"></a>04600 <span class="comment">   be sent to the child.  I wonder whether this code could not be</span>
<a name="l04601"></a>04601 <span class="comment">   abstracted out and shared with other unix targets such as</span>
<a name="l04602"></a>04602 <span class="comment">   inf-ptrace?  */</span>
<a name="l04603"></a>04603 
<a name="l04604"></a>04604 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04605"></a><a class="code" href="procfs_8c.html#a0b1570ab4c815fbae40a320dd7483258">04605</a> <a class="code" href="procfs_8c.html#a0b1570ab4c815fbae40a320dd7483258">procfs_create_inferior</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops, <span class="keywordtype">char</span> *exec_file,
<a name="l04606"></a>04606                         <span class="keywordtype">char</span> *allargs, <span class="keywordtype">char</span> **env, <span class="keywordtype">int</span> from_tty)
<a name="l04607"></a>04607 {
<a name="l04608"></a>04608   <span class="keywordtype">char</span> *shell_file = getenv (<span class="stringliteral">&quot;SHELL&quot;</span>);
<a name="l04609"></a>04609   <span class="keywordtype">char</span> *tryname;
<a name="l04610"></a>04610   <span class="keywordtype">int</span> <a class="code" href="structinferior.html#a1be87f581dbb6c893dbe1f2ff701636a">pid</a>;
<a name="l04611"></a>04611 
<a name="l04612"></a>04612   <span class="keywordflow">if</span> (shell_file != NULL &amp;&amp; <a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (shell_file, <span class="charliteral">&#39;/&#39;</span>) == NULL)
<a name="l04613"></a>04613     {
<a name="l04614"></a>04614 
<a name="l04615"></a>04615       <span class="comment">/* We will be looking down the PATH to find shell_file.  If we</span>
<a name="l04616"></a>04616 <span class="comment">         just do this the normal way (via execlp, which operates by</span>
<a name="l04617"></a>04617 <span class="comment">         attempting an exec for each element of the PATH until it</span>
<a name="l04618"></a>04618 <span class="comment">         finds one which succeeds), then there will be an exec for</span>
<a name="l04619"></a>04619 <span class="comment">         each failed attempt, each of which will cause a PR_SYSEXIT</span>
<a name="l04620"></a>04620 <span class="comment">         stop, and we won&#39;t know how to distinguish the PR_SYSEXIT&#39;s</span>
<a name="l04621"></a>04621 <span class="comment">         for these failed execs with the ones for successful execs</span>
<a name="l04622"></a>04622 <span class="comment">         (whether the exec has succeeded is stored at that time in the</span>
<a name="l04623"></a>04623 <span class="comment">         carry bit or some such architecture-specific and</span>
<a name="l04624"></a>04624 <span class="comment">         non-ABI-specified place).</span>
<a name="l04625"></a>04625 <span class="comment"></span>
<a name="l04626"></a>04626 <span class="comment">         So I can&#39;t think of anything better than to search the PATH</span>
<a name="l04627"></a>04627 <span class="comment">         now.  This has several disadvantages: (1) There is a race</span>
<a name="l04628"></a>04628 <span class="comment">         condition; if we find a file now and it is deleted before we</span>
<a name="l04629"></a>04629 <span class="comment">         exec it, we lose, even if the deletion leaves a valid file</span>
<a name="l04630"></a>04630 <span class="comment">         further down in the PATH, (2) there is no way to know exactly</span>
<a name="l04631"></a>04631 <span class="comment">         what an executable (in the sense of &quot;capable of being</span>
<a name="l04632"></a>04632 <span class="comment">         exec&#39;d&quot;) file is.  Using access() loses because it may lose</span>
<a name="l04633"></a>04633 <span class="comment">         if the caller is the superuser; failing to use it loses if</span>
<a name="l04634"></a>04634 <span class="comment">         there are ACLs or some such.  */</span>
<a name="l04635"></a>04635 
<a name="l04636"></a>04636       <span class="keywordtype">char</span> *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>;
<a name="l04637"></a>04637       <span class="keywordtype">char</span> *p1;
<a name="l04638"></a>04638       <span class="comment">/* FIXME-maybe: might want &quot;set path&quot; command so user can change what</span>
<a name="l04639"></a>04639 <span class="comment">         path is used from within GDB.  */</span>
<a name="l04640"></a>04640       <span class="keywordtype">char</span> *path = getenv (<span class="stringliteral">&quot;PATH&quot;</span>);
<a name="l04641"></a>04641       <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l04642"></a>04642       <span class="keyword">struct </span>stat statbuf;
<a name="l04643"></a>04643 
<a name="l04644"></a>04644       <span class="keywordflow">if</span> (path == NULL)
<a name="l04645"></a>04645         path = <span class="stringliteral">&quot;/bin:/usr/bin&quot;</span>;
<a name="l04646"></a>04646 
<a name="l04647"></a>04647       tryname = alloca (strlen (path) + strlen (shell_file) + 2);
<a name="l04648"></a>04648       <span class="keywordflow">for</span> (p = path; p != NULL; p = p1 ? p1 + 1: NULL)
<a name="l04649"></a>04649         {
<a name="l04650"></a>04650           p1 = <a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (p, <span class="charliteral">&#39;:&#39;</span>);
<a name="l04651"></a>04651           <span class="keywordflow">if</span> (p1 != NULL)
<a name="l04652"></a>04652             len = p1 - p;
<a name="l04653"></a>04653           <span class="keywordflow">else</span>
<a name="l04654"></a>04654             len = strlen (p);
<a name="l04655"></a>04655           strncpy (tryname, p, len);
<a name="l04656"></a>04656           tryname[<a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l04657"></a>04657           strcat (tryname, <span class="stringliteral">&quot;/&quot;</span>);
<a name="l04658"></a>04658           strcat (tryname, shell_file);
<a name="l04659"></a>04659           <span class="keywordflow">if</span> (access (tryname, X_OK) &lt; 0)
<a name="l04660"></a>04660             <span class="keywordflow">continue</span>;
<a name="l04661"></a>04661           <span class="keywordflow">if</span> (stat (tryname, &amp;statbuf) &lt; 0)
<a name="l04662"></a>04662             <span class="keywordflow">continue</span>;
<a name="l04663"></a>04663           <span class="keywordflow">if</span> (!S_ISREG (statbuf.st_mode))
<a name="l04664"></a>04664             <span class="comment">/* We certainly need to reject directories.  I&#39;m not quite</span>
<a name="l04665"></a>04665 <span class="comment">               as sure about FIFOs, sockets, etc., but I kind of doubt</span>
<a name="l04666"></a>04666 <span class="comment">               that people want to exec() these things.  */</span>
<a name="l04667"></a>04667             <span class="keywordflow">continue</span>;
<a name="l04668"></a>04668           <span class="keywordflow">break</span>;
<a name="l04669"></a>04669         }
<a name="l04670"></a>04670       <span class="keywordflow">if</span> (p == NULL)
<a name="l04671"></a>04671         <span class="comment">/* Not found.  This must be an error rather than merely passing</span>
<a name="l04672"></a>04672 <span class="comment">           the file to execlp(), because execlp() would try all the</span>
<a name="l04673"></a>04673 <span class="comment">           exec()s, causing GDB to get confused.  */</span>
<a name="l04674"></a>04674         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;procfs:%d -- Can&#39;t find shell %s in PATH&quot;</span>),
<a name="l04675"></a>04675                __LINE__, shell_file);
<a name="l04676"></a>04676 
<a name="l04677"></a>04677       shell_file = tryname;
<a name="l04678"></a>04678     }
<a name="l04679"></a>04679 
<a name="l04680"></a>04680   pid = <a class="code" href="fork-child_8c.html#ad6ae91d6cb01e16cd423ad80c03cd562">fork_inferior</a> (exec_file, allargs, env, <a class="code" href="procfs_8c.html#a9f31120a080e3639ade9e906dae2648a">procfs_set_exec_trap</a>,
<a name="l04681"></a>04681                        NULL, NULL, shell_file, NULL);
<a name="l04682"></a>04682 
<a name="l04683"></a>04683   <a class="code" href="procfs_8c.html#acc729f3b725f5336550c97d27f037541">procfs_init_inferior</a> (ops, pid);
<a name="l04684"></a>04684 }
<a name="l04685"></a>04685 
<a name="l04686"></a>04686 <span class="comment">/* An observer for the &quot;inferior_created&quot; event.  */</span>
<a name="l04687"></a>04687 
<a name="l04688"></a>04688 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04689"></a><a class="code" href="procfs_8c.html#a8833737d1c38c0eeaa0500af8c9f8180">04689</a> <a class="code" href="procfs_8c.html#a8833737d1c38c0eeaa0500af8c9f8180">procfs_inferior_created</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops, <span class="keywordtype">int</span> from_tty)
<a name="l04690"></a>04690 {
<a name="l04691"></a>04691 <span class="preprocessor">#ifdef SYS_syssgi</span>
<a name="l04692"></a>04692 <span class="preprocessor"></span>  <span class="comment">/* Make sure to cancel the syssgi() syscall-exit notifications.</span>
<a name="l04693"></a>04693 <span class="comment">     They should normally have been removed by now, but they may still</span>
<a name="l04694"></a>04694 <span class="comment">     be activated if the inferior doesn&#39;t use shared libraries, or if</span>
<a name="l04695"></a>04695 <span class="comment">     we didn&#39;t locate __dbx_link, or if we never stopped in __dbx_link.</span>
<a name="l04696"></a>04696 <span class="comment">     See procfs_init_inferior() for more details.</span>
<a name="l04697"></a>04697 <span class="comment"></span>
<a name="l04698"></a>04698 <span class="comment">     Since these notifications are only ever enabled when we spawned</span>
<a name="l04699"></a>04699 <span class="comment">     the inferior ourselves, there is nothing to do when the inferior</span>
<a name="l04700"></a>04700 <span class="comment">     was created by attaching to an already running process, or when</span>
<a name="l04701"></a>04701 <span class="comment">     debugging a core file.  */</span>
<a name="l04702"></a>04702   <span class="keywordflow">if</span> (<a class="code" href="inferior_8c.html#a9e592c83e7c0c1f89f1a4a392bd1a277">current_inferior</a> ()-&gt;attach_flag || !<a class="code" href="target_8h.html#a3c4e5f34cf395eb36ae58b0c47fd1c53">target_can_run</a> (&amp;<a class="code" href="target_8h.html#a2d8640b030266b58d3821eb5cfd112b9">current_target</a>))
<a name="l04703"></a>04703     <span class="keywordflow">return</span>;
<a name="l04704"></a>04704 
<a name="l04705"></a>04705   <a class="code" href="procfs_8c.html#ae027347db869ac7b72aa4a12608fb54b">proc_trace_syscalls_1</a> (<a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>),
<a name="l04706"></a>04706                          0), SYS_syssgi, PR_SYSEXIT, <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dada34921dc2c1632e9847571a81ce00124c">FLAG_RESET</a>, 0);
<a name="l04707"></a>04707 <span class="preprocessor">#endif</span>
<a name="l04708"></a>04708 <span class="preprocessor"></span>}
<a name="l04709"></a>04709 
<a name="l04710"></a>04710 <span class="comment">/* Callback for find_new_threads.  Calls &quot;add_thread&quot;.  */</span>
<a name="l04711"></a>04711 
<a name="l04712"></a>04712 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04713"></a><a class="code" href="procfs_8c.html#a6c164490e011ca806f9de6588f98c18a">04713</a> <a class="code" href="procfs_8c.html#a6c164490e011ca806f9de6588f98c18a">procfs_notice_thread</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <a class="code" href="structprocinfo.html">procinfo</a> *thread, <span class="keywordtype">void</span> *ptr)
<a name="l04714"></a>04714 {
<a name="l04715"></a>04715   <a class="code" href="structptid.html">ptid_t</a> gdb_threadid = <a class="code" href="ptid_8c.html#aa96ee3f6a88626ec36045b4d84e27f79">ptid_build</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, thread-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>, 0);
<a name="l04716"></a>04716 
<a name="l04717"></a>04717   <span class="keywordflow">if</span> (!<a class="code" href="gdbthread_8h.html#a75cff5779f03e4119723fd41a5583fa7">in_thread_list</a> (gdb_threadid) || <a class="code" href="gdbthread_8h.html#a4b919e1603e4636f9bc421f4a89c1d5d">is_exited</a> (gdb_threadid))
<a name="l04718"></a>04718     <a class="code" href="gdbthread_8h.html#a9e123f760f2bb2f9e96499816360d1cf">add_thread</a> (gdb_threadid);
<a name="l04719"></a>04719 
<a name="l04720"></a>04720   <span class="keywordflow">return</span> 0;
<a name="l04721"></a>04721 }
<a name="l04722"></a>04722 
<a name="l04723"></a>04723 <span class="comment">/* Query all the threads that the target knows about, and give them</span>
<a name="l04724"></a>04724 <span class="comment">   back to GDB to add to its list.  */</span>
<a name="l04725"></a>04725 
<a name="l04726"></a>04726 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04727"></a><a class="code" href="procfs_8c.html#a87845a7f84fc5b0f35b0c05728547bb6">04727</a> <a class="code" href="procfs_8c.html#a87845a7f84fc5b0f35b0c05728547bb6">procfs_find_new_threads</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops)
<a name="l04728"></a>04728 {
<a name="l04729"></a>04729   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l04730"></a>04730 
<a name="l04731"></a>04731   <span class="comment">/* Find procinfo for main process.  */</span>
<a name="l04732"></a>04732   pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>), 0);
<a name="l04733"></a>04733   <a class="code" href="procfs_8c.html#a9c8694c7c5546e9cd62a960bc350b018">proc_update_threads</a> (pi);
<a name="l04734"></a>04734   <a class="code" href="procfs_8c.html#a5fcfad306ae6b00c6d9b3c201d568580">proc_iterate_over_threads</a> (pi, <a class="code" href="procfs_8c.html#a6c164490e011ca806f9de6588f98c18a">procfs_notice_thread</a>, NULL);
<a name="l04735"></a>04735 }
<a name="l04736"></a>04736 
<a name="l04737"></a>04737 <span class="comment">/* Return true if the thread is still &#39;alive&#39;.  This guy doesn&#39;t</span>
<a name="l04738"></a>04738 <span class="comment">   really seem to be doing his job.  Got to investigate how to tell</span>
<a name="l04739"></a>04739 <span class="comment">   when a thread is really gone.  */</span>
<a name="l04740"></a>04740 
<a name="l04741"></a>04741 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04742"></a><a class="code" href="procfs_8c.html#accf520d09111d863ccec709512dd0a88">04742</a> <a class="code" href="procfs_8c.html#accf520d09111d863ccec709512dd0a88">procfs_thread_alive</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops, <a class="code" href="structptid.html">ptid_t</a> ptid)
<a name="l04743"></a>04743 {
<a name="l04744"></a>04744   <span class="keywordtype">int</span> <a class="code" href="structproc.html">proc</a>, thread;
<a name="l04745"></a>04745   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l04746"></a>04746 
<a name="l04747"></a>04747   proc    = <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (ptid);
<a name="l04748"></a>04748   thread  = <a class="code" href="ptid_8c.html#af5b67a5f356c507b7809af2fa4e63b44">ptid_get_lwp</a> (ptid);
<a name="l04749"></a>04749   <span class="comment">/* If I don&#39;t know it, it ain&#39;t alive!  */</span>
<a name="l04750"></a>04750   <span class="keywordflow">if</span> ((pi = <a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (proc, thread)) == NULL)
<a name="l04751"></a>04751     <span class="keywordflow">return</span> 0;
<a name="l04752"></a>04752 
<a name="l04753"></a>04753   <span class="comment">/* If I can&#39;t get its status, it ain&#39;t alive!</span>
<a name="l04754"></a>04754 <span class="comment">     What&#39;s more, I need to forget about it!  */</span>
<a name="l04755"></a>04755   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7dc03542839bb08e2a27f65099e81db5">proc_get_status</a> (pi))
<a name="l04756"></a>04756     {
<a name="l04757"></a>04757       <a class="code" href="procfs_8c.html#af0251ed126d7aa5845297cab52db3b68">destroy_procinfo</a> (pi);
<a name="l04758"></a>04758       <span class="keywordflow">return</span> 0;
<a name="l04759"></a>04759     }
<a name="l04760"></a>04760   <span class="comment">/* I couldn&#39;t have got its status if it weren&#39;t alive, so it&#39;s</span>
<a name="l04761"></a>04761 <span class="comment">     alive.  */</span>
<a name="l04762"></a>04762   <span class="keywordflow">return</span> 1;
<a name="l04763"></a>04763 }
<a name="l04764"></a>04764 
<a name="l04765"></a>04765 <span class="comment">/* Convert PTID to a string.  Returns the string in a static</span>
<a name="l04766"></a>04766 <span class="comment">   buffer.  */</span>
<a name="l04767"></a>04767 
<a name="l04768"></a>04768 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l04769"></a><a class="code" href="procfs_8c.html#ae4991ccbc9f5e4ee6355bae8da57c075">04769</a> <a class="code" href="procfs_8c.html#ae4991ccbc9f5e4ee6355bae8da57c075">procfs_pid_to_str</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops, <a class="code" href="structptid.html">ptid_t</a> ptid)
<a name="l04770"></a>04770 {
<a name="l04771"></a>04771   <span class="keyword">static</span> <span class="keywordtype">char</span> buf[80];
<a name="l04772"></a>04772 
<a name="l04773"></a>04773   <span class="keywordflow">if</span> (<a class="code" href="ptid_8c.html#af5b67a5f356c507b7809af2fa4e63b44">ptid_get_lwp</a> (ptid) == 0)
<a name="l04774"></a>04774     sprintf (buf, <span class="stringliteral">&quot;process %d&quot;</span>, <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (ptid));
<a name="l04775"></a>04775   <span class="keywordflow">else</span>
<a name="l04776"></a>04776     sprintf (buf, <span class="stringliteral">&quot;LWP %ld&quot;</span>, <a class="code" href="ptid_8c.html#af5b67a5f356c507b7809af2fa4e63b44">ptid_get_lwp</a> (ptid));
<a name="l04777"></a>04777 
<a name="l04778"></a>04778   <span class="keywordflow">return</span> buf;
<a name="l04779"></a>04779 }
<a name="l04780"></a>04780 
<a name="l04781"></a>04781 <span class="comment">/* Insert a watchpoint.  */</span>
<a name="l04782"></a>04782 
<a name="l04783"></a>04783 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04784"></a><a class="code" href="procfs_8c.html#ac64c6bc33b1f8eceb700d0baea6ea787">04784</a> <a class="code" href="procfs_8c.html#ac64c6bc33b1f8eceb700d0baea6ea787">procfs_set_watchpoint</a> (<a class="code" href="structptid.html">ptid_t</a> ptid, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr, <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>, <span class="keywordtype">int</span> rwflag,
<a name="l04785"></a>04785                        <span class="keywordtype">int</span> after)
<a name="l04786"></a>04786 {
<a name="l04787"></a>04787 <span class="preprocessor">#ifndef AIX5</span>
<a name="l04788"></a>04788 <span class="preprocessor"></span>  <span class="keywordtype">int</span>       pflags = 0;
<a name="l04789"></a>04789   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l04790"></a>04790 
<a name="l04791"></a>04791   pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (ptid) == -1 ?
<a name="l04792"></a>04792                              <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>) : <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (ptid),
<a name="l04793"></a>04793                              0);
<a name="l04794"></a>04794 
<a name="l04795"></a>04795   <span class="comment">/* Translate from GDB&#39;s flags to /proc&#39;s.  */</span>
<a name="l04796"></a>04796   <span class="keywordflow">if</span> (len &gt; 0)  <span class="comment">/* len == 0 means delete watchpoint.  */</span>
<a name="l04797"></a>04797     {
<a name="l04798"></a>04798       <span class="keywordflow">switch</span> (rwflag) {         <span class="comment">/* FIXME: need an enum!  */</span>
<a name="l04799"></a>04799       <span class="keywordflow">case</span> <a class="code" href="break-common_8h.html#ae1f701210980578c2ab1bc4ae89e69f3a7948cdb19d0afe80f18ac82ef466e07e">hw_write</a>:            <span class="comment">/* default watchpoint (write) */</span>
<a name="l04800"></a>04800         pflags = <a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469a644741ede8604b44c7e617774f7d35cd">WRITE_WATCHFLAG</a>;
<a name="l04801"></a>04801         <span class="keywordflow">break</span>;
<a name="l04802"></a>04802       <span class="keywordflow">case</span> <a class="code" href="break-common_8h.html#ae1f701210980578c2ab1bc4ae89e69f3afb52ba78eb7679d11a25bd2c44eb0606">hw_read</a>:             <span class="comment">/* read watchpoint */</span>
<a name="l04803"></a>04803         pflags = <a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469aa23bbbc5d536c27be78e36d38c5eb6ba">READ_WATCHFLAG</a>;
<a name="l04804"></a>04804         <span class="keywordflow">break</span>;
<a name="l04805"></a>04805       <span class="keywordflow">case</span> <a class="code" href="break-common_8h.html#ae1f701210980578c2ab1bc4ae89e69f3a8bef3f5dcfc5f1c5b482627a8ddf5736">hw_access</a>:           <span class="comment">/* access watchpoint */</span>
<a name="l04806"></a>04806         pflags = <a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469aa23bbbc5d536c27be78e36d38c5eb6ba">READ_WATCHFLAG</a> | <a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469a644741ede8604b44c7e617774f7d35cd">WRITE_WATCHFLAG</a>;
<a name="l04807"></a>04807         <span class="keywordflow">break</span>;
<a name="l04808"></a>04808       <span class="keywordflow">case</span> <a class="code" href="break-common_8h.html#ae1f701210980578c2ab1bc4ae89e69f3ab529775f3f7512f45955ea13f2ab491d">hw_execute</a>:          <span class="comment">/* execution HW breakpoint */</span>
<a name="l04809"></a>04809         pflags = <a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469a034244e5ab93752fad574e7e485e01da">EXEC_WATCHFLAG</a>;
<a name="l04810"></a>04810         <span class="keywordflow">break</span>;
<a name="l04811"></a>04811       <span class="keywordflow">default</span>:                  <span class="comment">/* Something weird.  Return error.  */</span>
<a name="l04812"></a>04812         <span class="keywordflow">return</span> -1;
<a name="l04813"></a>04813       }
<a name="l04814"></a>04814       <span class="keywordflow">if</span> (after)                <span class="comment">/* Stop after r/w access is completed.  */</span>
<a name="l04815"></a>04815         pflags |= <a class="code" href="procfs_8c.html#a10e74d65d7876276a8f6061c71dcf469aa78f7fda6eec37396f071af96baca552">AFTER_WATCHFLAG</a>;
<a name="l04816"></a>04816     }
<a name="l04817"></a>04817 
<a name="l04818"></a>04818   <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#aa1e38d492f0fd834456562100b02517b">proc_set_watchpoint</a> (pi, addr, len, pflags))
<a name="l04819"></a>04819     {
<a name="l04820"></a>04820       <span class="keywordflow">if</span> (errno == E2BIG)       <span class="comment">/* Typical error for no resources.  */</span>
<a name="l04821"></a>04821         <span class="keywordflow">return</span> -1;              <span class="comment">/* fail */</span>
<a name="l04822"></a>04822       <span class="comment">/* GDB may try to remove the same watchpoint twice.</span>
<a name="l04823"></a>04823 <span class="comment">         If a remove request returns no match, don&#39;t error.  */</span>
<a name="l04824"></a>04824       <span class="keywordflow">if</span> (errno == ESRCH &amp;&amp; len == 0)
<a name="l04825"></a>04825         <span class="keywordflow">return</span> 0;               <span class="comment">/* ignore */</span>
<a name="l04826"></a>04826       <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;set_watchpoint&quot;</span>, __LINE__);
<a name="l04827"></a>04827     }
<a name="l04828"></a>04828 <span class="preprocessor">#endif </span><span class="comment">/* AIX5 */</span>
<a name="l04829"></a>04829   <span class="keywordflow">return</span> 0;
<a name="l04830"></a>04830 }
<a name="l04831"></a>04831 
<a name="l04832"></a>04832 <span class="comment">/* Return non-zero if we can set a hardware watchpoint of type TYPE.  TYPE</span>
<a name="l04833"></a>04833 <span class="comment">   is one of bp_hardware_watchpoint, bp_read_watchpoint, bp_write_watchpoint,</span>
<a name="l04834"></a>04834 <span class="comment">   or bp_hardware_watchpoint.  CNT is the number of watchpoints used so</span>
<a name="l04835"></a>04835 <span class="comment">   far.</span>
<a name="l04836"></a>04836 <span class="comment"></span>
<a name="l04837"></a>04837 <span class="comment">   Note:  procfs_can_use_hw_breakpoint() is not yet used by all</span>
<a name="l04838"></a>04838 <span class="comment">   procfs.c targets due to the fact that some of them still define</span>
<a name="l04839"></a>04839 <span class="comment">   target_can_use_hardware_watchpoint.  */</span>
<a name="l04840"></a>04840 
<a name="l04841"></a>04841 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04842"></a><a class="code" href="procfs_8c.html#ab5ce316727a6fd139fa218545e095b28">04842</a> <a class="code" href="procfs_8c.html#ab5ce316727a6fd139fa218545e095b28">procfs_can_use_hw_breakpoint</a> (<span class="keywordtype">int</span> <a class="code" href="structtype.html">type</a>, <span class="keywordtype">int</span> cnt, <span class="keywordtype">int</span> othertype)
<a name="l04843"></a>04843 {
<a name="l04844"></a>04844   <span class="comment">/* Due to the way that proc_set_watchpoint() is implemented, host</span>
<a name="l04845"></a>04845 <span class="comment">     and target pointers must be of the same size.  If they are not,</span>
<a name="l04846"></a>04846 <span class="comment">     we can&#39;t use hardware watchpoints.  This limitation is due to the</span>
<a name="l04847"></a>04847 <span class="comment">     fact that proc_set_watchpoint() calls</span>
<a name="l04848"></a>04848 <span class="comment">     procfs_address_to_host_pointer(); a close inspection of</span>
<a name="l04849"></a>04849 <span class="comment">     procfs_address_to_host_pointer will reveal that an internal error</span>
<a name="l04850"></a>04850 <span class="comment">     will be generated when the host and target pointer sizes are</span>
<a name="l04851"></a>04851 <span class="comment">     different.  */</span>
<a name="l04852"></a>04852   <span class="keyword">struct </span>type *ptr_type = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ())-&gt;<a class="code" href="structbuiltin__type.html#a55f6f9ff7436431777683d8ba62f662a">builtin_data_ptr</a>;
<a name="l04853"></a>04853 
<a name="l04854"></a>04854   <span class="keywordflow">if</span> (<span class="keyword">sizeof</span> (<span class="keywordtype">void</span> *) != <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (ptr_type))
<a name="l04855"></a>04855     <span class="keywordflow">return</span> 0;
<a name="l04856"></a>04856 
<a name="l04857"></a>04857   <span class="comment">/* Other tests here???  */</span>
<a name="l04858"></a>04858 
<a name="l04859"></a>04859   <span class="keywordflow">return</span> 1;
<a name="l04860"></a>04860 }
<a name="l04861"></a>04861 
<a name="l04862"></a>04862 <span class="comment">/* Returns non-zero if process is stopped on a hardware watchpoint</span>
<a name="l04863"></a>04863 <span class="comment">   fault, else returns zero.  */</span>
<a name="l04864"></a>04864 
<a name="l04865"></a>04865 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04866"></a><a class="code" href="procfs_8c.html#a9838fbaaa65d52b96a94e2370ecfcdd2">04866</a> <a class="code" href="procfs_8c.html#a9838fbaaa65d52b96a94e2370ecfcdd2">procfs_stopped_by_watchpoint</a> (<span class="keywordtype">void</span>)
<a name="l04867"></a>04867 {
<a name="l04868"></a>04868   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l04869"></a>04869 
<a name="l04870"></a>04870   pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>), 0);
<a name="l04871"></a>04871 
<a name="l04872"></a>04872   <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (pi) &amp; (PR_STOPPED | PR_ISTOP))
<a name="l04873"></a>04873     {
<a name="l04874"></a>04874       <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#af1d2febb017ce0acde9f56bbfcbfde9e">proc_why</a> (pi) == PR_FAULTED)
<a name="l04875"></a>04875         {
<a name="l04876"></a>04876 <span class="preprocessor">#ifdef FLTWATCH</span>
<a name="l04877"></a>04877 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#a8f54b931ed7656bcce6696ea27b8b3c3">proc_what</a> (pi) == FLTWATCH)
<a name="l04878"></a>04878             <span class="keywordflow">return</span> 1;
<a name="l04879"></a>04879 <span class="preprocessor">#endif</span>
<a name="l04880"></a>04880 <span class="preprocessor"></span><span class="preprocessor">#ifdef FLTKWATCH</span>
<a name="l04881"></a>04881 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#a8f54b931ed7656bcce6696ea27b8b3c3">proc_what</a> (pi) == FLTKWATCH)
<a name="l04882"></a>04882             <span class="keywordflow">return</span> 1;
<a name="l04883"></a>04883 <span class="preprocessor">#endif</span>
<a name="l04884"></a>04884 <span class="preprocessor"></span>        }
<a name="l04885"></a>04885     }
<a name="l04886"></a>04886   <span class="keywordflow">return</span> 0;
<a name="l04887"></a>04887 }
<a name="l04888"></a>04888 
<a name="l04889"></a>04889 <span class="comment">/* Returns 1 if the OS knows the position of the triggered watchpoint,</span>
<a name="l04890"></a>04890 <span class="comment">   and sets *ADDR to that address.  Returns 0 if OS cannot report that</span>
<a name="l04891"></a>04891 <span class="comment">   address.  This function is only called if</span>
<a name="l04892"></a>04892 <span class="comment">   procfs_stopped_by_watchpoint returned 1, thus no further checks are</span>
<a name="l04893"></a>04893 <span class="comment">   done.  The function also assumes that ADDR is not NULL.  */</span>
<a name="l04894"></a>04894 
<a name="l04895"></a>04895 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04896"></a><a class="code" href="procfs_8c.html#a7dc5ec0177612a719336b4a07c99fb90">04896</a> <a class="code" href="procfs_8c.html#a7dc5ec0177612a719336b4a07c99fb90">procfs_stopped_data_address</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *targ, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *addr)
<a name="l04897"></a>04897 {
<a name="l04898"></a>04898   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l04899"></a>04899 
<a name="l04900"></a>04900   pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>), 0);
<a name="l04901"></a>04901   <span class="keywordflow">return</span> <a class="code" href="procfs_8c.html#a1999701b7976474d9e0b339762fe6eaf">proc_watchpoint_address</a> (pi, addr);
<a name="l04902"></a>04902 }
<a name="l04903"></a>04903 
<a name="l04904"></a>04904 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04905"></a><a class="code" href="procfs_8c.html#a015d944daded3dbc8f55ff8fb2af97e9">04905</a> <a class="code" href="procfs_8c.html#a015d944daded3dbc8f55ff8fb2af97e9">procfs_insert_watchpoint</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr, <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>, <span class="keywordtype">int</span> <a class="code" href="structtype.html">type</a>,
<a name="l04906"></a>04906                           <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *cond)
<a name="l04907"></a>04907 {
<a name="l04908"></a>04908   <span class="keywordflow">if</span> (!<a class="code" href="target_8h.html#a28c375398cbc64f9732438cf03643042">target_have_steppable_watchpoint</a>
<a name="l04909"></a>04909       &amp;&amp; !<a class="code" href="gdbarch_8c.html#a09e81ebf90ac1440e9ab0ec7425f2f95">gdbarch_have_nonsteppable_watchpoint</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ()))
<a name="l04910"></a>04910     {
<a name="l04911"></a>04911       <span class="comment">/* When a hardware watchpoint fires off the PC will be left at</span>
<a name="l04912"></a>04912 <span class="comment">         the instruction following the one which caused the</span>
<a name="l04913"></a>04913 <span class="comment">         watchpoint.  It will *NOT* be necessary for GDB to step over</span>
<a name="l04914"></a>04914 <span class="comment">         the watchpoint.  */</span>
<a name="l04915"></a>04915       <span class="keywordflow">return</span> <a class="code" href="procfs_8c.html#ac64c6bc33b1f8eceb700d0baea6ea787">procfs_set_watchpoint</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>, addr, len, type, 1);
<a name="l04916"></a>04916     }
<a name="l04917"></a>04917   <span class="keywordflow">else</span>
<a name="l04918"></a>04918     {
<a name="l04919"></a>04919       <span class="comment">/* When a hardware watchpoint fires off the PC will be left at</span>
<a name="l04920"></a>04920 <span class="comment">         the instruction which caused the watchpoint.  It will be</span>
<a name="l04921"></a>04921 <span class="comment">         necessary for GDB to step over the watchpoint.  */</span>
<a name="l04922"></a>04922       <span class="keywordflow">return</span> <a class="code" href="procfs_8c.html#ac64c6bc33b1f8eceb700d0baea6ea787">procfs_set_watchpoint</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>, addr, len, type, 0);
<a name="l04923"></a>04923     }
<a name="l04924"></a>04924 }
<a name="l04925"></a>04925 
<a name="l04926"></a>04926 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04927"></a><a class="code" href="procfs_8c.html#adcd7fd4bf2c632c52ca3149da761d74f">04927</a> <a class="code" href="procfs_8c.html#adcd7fd4bf2c632c52ca3149da761d74f">procfs_remove_watchpoint</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr, <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>, <span class="keywordtype">int</span> <a class="code" href="structtype.html">type</a>,
<a name="l04928"></a>04928                           <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *cond)
<a name="l04929"></a>04929 {
<a name="l04930"></a>04930   <span class="keywordflow">return</span> <a class="code" href="procfs_8c.html#ac64c6bc33b1f8eceb700d0baea6ea787">procfs_set_watchpoint</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>, addr, 0, 0, 0);
<a name="l04931"></a>04931 }
<a name="l04932"></a>04932 
<a name="l04933"></a>04933 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04934"></a><a class="code" href="procfs_8c.html#ac252fbe100a51d6a0a53a6de091d7ee4">04934</a> <a class="code" href="procfs_8c.html#ac252fbe100a51d6a0a53a6de091d7ee4">procfs_region_ok_for_hw_watchpoint</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr, <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>)
<a name="l04935"></a>04935 {
<a name="l04936"></a>04936   <span class="comment">/* The man page for proc(4) on Solaris 2.6 and up says that the</span>
<a name="l04937"></a>04937 <span class="comment">     system can support &quot;thousands&quot; of hardware watchpoints, but gives</span>
<a name="l04938"></a>04938 <span class="comment">     no method for finding out how many; It doesn&#39;t say anything about</span>
<a name="l04939"></a>04939 <span class="comment">     the allowed size for the watched area either.  So we just tell</span>
<a name="l04940"></a>04940 <span class="comment">     GDB &#39;yes&#39;.  */</span>
<a name="l04941"></a>04941   <span class="keywordflow">return</span> 1;
<a name="l04942"></a>04942 }
<a name="l04943"></a>04943 
<a name="l04944"></a>04944 <span class="keywordtype">void</span>
<a name="l04945"></a><a class="code" href="procfs_8h.html#a71ffc48d7b08f31e14feec55ec1f9ef8">04945</a> <a class="code" href="procfs_8c.html#a71ffc48d7b08f31e14feec55ec1f9ef8">procfs_use_watchpoints</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *t)
<a name="l04946"></a>04946 {
<a name="l04947"></a>04947   t-&gt;<a class="code" href="structtarget__ops.html#aed96211f2a6c49e995e790caa2fb83b4">to_stopped_by_watchpoint</a> = <a class="code" href="procfs_8c.html#a9838fbaaa65d52b96a94e2370ecfcdd2">procfs_stopped_by_watchpoint</a>;
<a name="l04948"></a>04948   t-&gt;<a class="code" href="structtarget__ops.html#a11a089e0b00d79a77ad0cb247de34949">to_insert_watchpoint</a> = <a class="code" href="procfs_8c.html#a015d944daded3dbc8f55ff8fb2af97e9">procfs_insert_watchpoint</a>;
<a name="l04949"></a>04949   t-&gt;<a class="code" href="structtarget__ops.html#a310e5f59e27544ae28803274e2aa8338">to_remove_watchpoint</a> = <a class="code" href="procfs_8c.html#adcd7fd4bf2c632c52ca3149da761d74f">procfs_remove_watchpoint</a>;
<a name="l04950"></a>04950   t-&gt;<a class="code" href="structtarget__ops.html#ab2d8932fdc3bd9188d18f117b488b12b">to_region_ok_for_hw_watchpoint</a> = <a class="code" href="procfs_8c.html#ac252fbe100a51d6a0a53a6de091d7ee4">procfs_region_ok_for_hw_watchpoint</a>;
<a name="l04951"></a>04951   t-&gt;<a class="code" href="structtarget__ops.html#a7a1a220e1eb3c600f820ce09b1763a26">to_can_use_hw_breakpoint</a> = <a class="code" href="procfs_8c.html#ab5ce316727a6fd139fa218545e095b28">procfs_can_use_hw_breakpoint</a>;
<a name="l04952"></a>04952   t-&gt;<a class="code" href="structtarget__ops.html#a89a0d3c90763c2307c5c17b99003a20b">to_stopped_data_address</a> = <a class="code" href="procfs_8c.html#a7dc5ec0177612a719336b4a07c99fb90">procfs_stopped_data_address</a>;
<a name="l04953"></a>04953 }
<a name="l04954"></a>04954 
<a name="l04955"></a>04955 <span class="comment">/* Memory Mappings Functions: */</span>
<a name="l04956"></a>04956 
<a name="l04957"></a>04957 <span class="comment">/* Call a callback function once for each mapping, passing it the</span>
<a name="l04958"></a>04958 <span class="comment">   mapping, an optional secondary callback function, and some optional</span>
<a name="l04959"></a>04959 <span class="comment">   opaque data.  Quit and return the first non-zero value returned</span>
<a name="l04960"></a>04960 <span class="comment">   from the callback.</span>
<a name="l04961"></a>04961 <span class="comment"></span>
<a name="l04962"></a>04962 <span class="comment">   PI is the procinfo struct for the process to be mapped.  FUNC is</span>
<a name="l04963"></a>04963 <span class="comment">   the callback function to be called by this iterator.  DATA is the</span>
<a name="l04964"></a>04964 <span class="comment">   optional opaque data to be passed to the callback function.</span>
<a name="l04965"></a>04965 <span class="comment">   CHILD_FUNC is the optional secondary function pointer to be passed</span>
<a name="l04966"></a>04966 <span class="comment">   to the child function.  Returns the first non-zero return value</span>
<a name="l04967"></a>04967 <span class="comment">   from the callback function, or zero.  */</span>
<a name="l04968"></a>04968 
<a name="l04969"></a>04969 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04970"></a><a class="code" href="procfs_8c.html#a2c2c4e0ad3531aa668e8a6f38b50ba29">04970</a> <a class="code" href="procfs_8c.html#a2c2c4e0ad3531aa668e8a6f38b50ba29">iterate_over_mappings</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <a class="code" href="defs_8h.html#a9d6528d2f701ee8e47c35c038752ac99">find_memory_region_ftype</a> child_func,
<a name="l04971"></a>04971                        <span class="keywordtype">void</span> *data,
<a name="l04972"></a>04972                        <span class="keywordtype">int</span> (*<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>) (<span class="keyword">struct</span> prmap *map,
<a name="l04973"></a>04973                                     <a class="code" href="defs_8h.html#a9d6528d2f701ee8e47c35c038752ac99">find_memory_region_ftype</a> child_func,
<a name="l04974"></a>04974                                     <span class="keywordtype">void</span> *data))
<a name="l04975"></a>04975 {
<a name="l04976"></a>04976   <span class="keywordtype">char</span> pathname[<a class="code" href="procfs_8c.html#a516ed8ab3b65b65276525efba4b38d6d">MAX_PROC_NAME_SIZE</a>];
<a name="l04977"></a>04977   <span class="keyword">struct </span>prmap *prmaps;
<a name="l04978"></a>04978   <span class="keyword">struct </span>prmap *prmap;
<a name="l04979"></a>04979   <span class="keywordtype">int</span> funcstat;
<a name="l04980"></a>04980   <span class="keywordtype">int</span> map_fd;
<a name="l04981"></a>04981   <span class="keywordtype">int</span> nmap;
<a name="l04982"></a>04982   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, NULL);
<a name="l04983"></a>04983 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l04984"></a>04984 <span class="preprocessor"></span>  <span class="keyword">struct </span>stat sbuf;
<a name="l04985"></a>04985 <span class="preprocessor">#endif</span>
<a name="l04986"></a>04986 <span class="preprocessor"></span>
<a name="l04987"></a>04987   <span class="comment">/* Get the number of mappings, allocate space,</span>
<a name="l04988"></a>04988 <span class="comment">     and read the mappings into prmaps.  */</span>
<a name="l04989"></a>04989 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l04990"></a>04990 <span class="preprocessor"></span>  <span class="comment">/* Open map fd.  */</span>
<a name="l04991"></a>04991   sprintf (pathname, <span class="stringliteral">&quot;/proc/%d/map&quot;</span>, pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>);
<a name="l04992"></a>04992   <span class="keywordflow">if</span> ((map_fd = open (pathname, O_RDONLY)) &lt; 0)
<a name="l04993"></a>04993     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;iterate_over_mappings (open)&quot;</span>, __LINE__);
<a name="l04994"></a>04994 
<a name="l04995"></a>04995   <span class="comment">/* Make sure it gets closed again.  */</span>
<a name="l04996"></a>04996   <a class="code" href="utils_8c.html#ae1c81b8331e815cc346382bc13e20095">make_cleanup_close</a> (map_fd);
<a name="l04997"></a>04997 
<a name="l04998"></a>04998   <span class="comment">/* Use stat to determine the file size, and compute</span>
<a name="l04999"></a>04999 <span class="comment">     the number of prmap_t objects it contains.  */</span>
<a name="l05000"></a>05000   <span class="keywordflow">if</span> (fstat (map_fd, &amp;sbuf) != 0)
<a name="l05001"></a>05001     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;iterate_over_mappings (fstat)&quot;</span>, __LINE__);
<a name="l05002"></a>05002 
<a name="l05003"></a>05003   nmap = sbuf.st_size / <span class="keyword">sizeof</span> (prmap_t);
<a name="l05004"></a>05004   prmaps = (<span class="keyword">struct </span>prmap *) alloca ((nmap + 1) * <span class="keyword">sizeof</span> (*prmaps));
<a name="l05005"></a>05005   <span class="keywordflow">if</span> (<a class="code" href="expect-read1_8c.html#af32a16ad2dd9e48482f8f790db7dbbd2">read</a> (map_fd, (<span class="keywordtype">char</span> *) prmaps, nmap * <span class="keyword">sizeof</span> (*prmaps))
<a name="l05006"></a>05006       != (nmap * <span class="keyword">sizeof</span> (*prmaps)))
<a name="l05007"></a>05007     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;iterate_over_mappings (read)&quot;</span>, __LINE__);
<a name="l05008"></a>05008 <span class="preprocessor">#else</span>
<a name="l05009"></a>05009 <span class="preprocessor"></span>  <span class="comment">/* Use ioctl command PIOCNMAP to get number of mappings.  */</span>
<a name="l05010"></a>05010   <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCNMAP, &amp;nmap) != 0)
<a name="l05011"></a>05011     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;iterate_over_mappings (PIOCNMAP)&quot;</span>, __LINE__);
<a name="l05012"></a>05012 
<a name="l05013"></a>05013   prmaps = (<span class="keyword">struct </span>prmap *) alloca ((nmap + 1) * <span class="keyword">sizeof</span> (*prmaps));
<a name="l05014"></a>05014   <span class="keywordflow">if</span> (ioctl (pi-&gt;<a class="code" href="structprocinfo.html#a66b6307c60b78b06be8d673645d0a0a3">ctl_fd</a>, PIOCMAP, prmaps) != 0)
<a name="l05015"></a>05015     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;iterate_over_mappings (PIOCMAP)&quot;</span>, __LINE__);
<a name="l05016"></a>05016 <span class="preprocessor">#endif</span>
<a name="l05017"></a>05017 <span class="preprocessor"></span>
<a name="l05018"></a>05018   <span class="keywordflow">for</span> (prmap = prmaps; nmap &gt; 0; prmap++, nmap--)
<a name="l05019"></a>05019     <span class="keywordflow">if</span> ((funcstat = (*<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>) (prmap, child_func, data)) != 0)
<a name="l05020"></a>05020       {
<a name="l05021"></a>05021         <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l05022"></a>05022         <span class="keywordflow">return</span> funcstat;
<a name="l05023"></a>05023       }
<a name="l05024"></a>05024 
<a name="l05025"></a>05025   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l05026"></a>05026   <span class="keywordflow">return</span> 0;
<a name="l05027"></a>05027 }
<a name="l05028"></a>05028 
<a name="l05029"></a>05029 <span class="comment">/* Implements the to_find_memory_regions method.  Calls an external</span>
<a name="l05030"></a>05030 <span class="comment">   function for each memory region.</span>
<a name="l05031"></a>05031 <span class="comment">   Returns the integer value returned by the callback.  */</span>
<a name="l05032"></a>05032 
<a name="l05033"></a>05033 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05034"></a><a class="code" href="procfs_8c.html#aa789ab0855caf7cbdf8281e80c7c413a">05034</a> <a class="code" href="procfs_8c.html#aa789ab0855caf7cbdf8281e80c7c413a">find_memory_regions_callback</a> (<span class="keyword">struct</span> prmap *map,
<a name="l05035"></a>05035                               <a class="code" href="defs_8h.html#a9d6528d2f701ee8e47c35c038752ac99">find_memory_region_ftype</a> <a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>, <span class="keywordtype">void</span> *data)
<a name="l05036"></a>05036 {
<a name="l05037"></a>05037   <span class="keywordflow">return</span> (*func) ((<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) map-&gt;pr_vaddr,
<a name="l05038"></a>05038                   map-&gt;pr_size,
<a name="l05039"></a>05039                   (map-&gt;pr_mflags &amp; MA_READ) != 0,
<a name="l05040"></a>05040                   (map-&gt;pr_mflags &amp; MA_WRITE) != 0,
<a name="l05041"></a>05041                   (map-&gt;pr_mflags &amp; MA_EXEC) != 0,
<a name="l05042"></a>05042                   1, <span class="comment">/* MODIFIED is unknown, pass it as true.  */</span>
<a name="l05043"></a>05043                   data);
<a name="l05044"></a>05044 }
<a name="l05045"></a>05045 
<a name="l05046"></a>05046 <span class="comment">/* External interface.  Calls a callback function once for each</span>
<a name="l05047"></a>05047 <span class="comment">   mapped memory region in the child process, passing as arguments:</span>
<a name="l05048"></a>05048 <span class="comment"></span>
<a name="l05049"></a>05049 <span class="comment">        CORE_ADDR virtual_address,</span>
<a name="l05050"></a>05050 <span class="comment">        unsigned long size,</span>
<a name="l05051"></a>05051 <span class="comment">        int read,       TRUE if region is readable by the child</span>
<a name="l05052"></a>05052 <span class="comment">        int write,      TRUE if region is writable by the child</span>
<a name="l05053"></a>05053 <span class="comment">        int execute     TRUE if region is executable by the child.</span>
<a name="l05054"></a>05054 <span class="comment"></span>
<a name="l05055"></a>05055 <span class="comment">   Stops iterating and returns the first non-zero value returned by</span>
<a name="l05056"></a>05056 <span class="comment">   the callback.  */</span>
<a name="l05057"></a>05057 
<a name="l05058"></a>05058 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05059"></a><a class="code" href="procfs_8c.html#a092e007a97789383548b894507d1d427">05059</a> <a class="code" href="procfs_8c.html#a092e007a97789383548b894507d1d427">proc_find_memory_regions</a> (<a class="code" href="defs_8h.html#a9d6528d2f701ee8e47c35c038752ac99">find_memory_region_ftype</a> <a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>, <span class="keywordtype">void</span> *data)
<a name="l05060"></a>05060 {
<a name="l05061"></a>05061   <a class="code" href="structprocinfo.html">procinfo</a> *pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>), 0);
<a name="l05062"></a>05062 
<a name="l05063"></a>05063   <span class="keywordflow">return</span> <a class="code" href="procfs_8c.html#a2c2c4e0ad3531aa668e8a6f38b50ba29">iterate_over_mappings</a> (pi, func, data,
<a name="l05064"></a>05064                                 <a class="code" href="procfs_8c.html#aa789ab0855caf7cbdf8281e80c7c413a">find_memory_regions_callback</a>);
<a name="l05065"></a>05065 }
<a name="l05066"></a>05066 
<a name="l05067"></a>05067 <span class="comment">/* Returns an ascii representation of a memory mapping&#39;s flags.  */</span>
<a name="l05068"></a>05068 
<a name="l05069"></a>05069 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l05070"></a><a class="code" href="procfs_8c.html#a4d298b3afddc90deff1f7bc5daef704c">05070</a> <a class="code" href="procfs_8c.html#a4d298b3afddc90deff1f7bc5daef704c">mappingflags</a> (<span class="keywordtype">long</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>)
<a name="l05071"></a>05071 {
<a name="l05072"></a>05072   <span class="keyword">static</span> <span class="keywordtype">char</span> asciiflags[8];
<a name="l05073"></a>05073 
<a name="l05074"></a>05074   strcpy (asciiflags, <span class="stringliteral">&quot;-------&quot;</span>);
<a name="l05075"></a>05075 <span class="preprocessor">#if defined (MA_PHYS)</span>
<a name="l05076"></a>05076 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (flags &amp; MA_PHYS)
<a name="l05077"></a>05077     asciiflags[0] = <span class="charliteral">&#39;d&#39;</span>;
<a name="l05078"></a>05078 <span class="preprocessor">#endif</span>
<a name="l05079"></a>05079 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (flags &amp; MA_STACK)
<a name="l05080"></a>05080     asciiflags[1] = <span class="charliteral">&#39;s&#39;</span>;
<a name="l05081"></a>05081   <span class="keywordflow">if</span> (flags &amp; MA_BREAK)
<a name="l05082"></a>05082     asciiflags[2] = <span class="charliteral">&#39;b&#39;</span>;
<a name="l05083"></a>05083   <span class="keywordflow">if</span> (flags &amp; MA_SHARED)
<a name="l05084"></a>05084     asciiflags[3] = <span class="charliteral">&#39;s&#39;</span>;
<a name="l05085"></a>05085   <span class="keywordflow">if</span> (flags &amp; MA_READ)
<a name="l05086"></a>05086     asciiflags[4] = <span class="charliteral">&#39;r&#39;</span>;
<a name="l05087"></a>05087   <span class="keywordflow">if</span> (flags &amp; MA_WRITE)
<a name="l05088"></a>05088     asciiflags[5] = <span class="charliteral">&#39;w&#39;</span>;
<a name="l05089"></a>05089   <span class="keywordflow">if</span> (flags &amp; MA_EXEC)
<a name="l05090"></a>05090     asciiflags[6] = <span class="charliteral">&#39;x&#39;</span>;
<a name="l05091"></a>05091   <span class="keywordflow">return</span> (asciiflags);
<a name="l05092"></a>05092 }
<a name="l05093"></a>05093 
<a name="l05094"></a>05094 <span class="comment">/* Callback function, does the actual work for &#39;info proc</span>
<a name="l05095"></a>05095 <span class="comment">   mappings&#39;.  */</span>
<a name="l05096"></a>05096 
<a name="l05097"></a>05097 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05098"></a><a class="code" href="procfs_8c.html#a43317a5a0a86fb86367af2bfce545871">05098</a> <a class="code" href="procfs_8c.html#a43317a5a0a86fb86367af2bfce545871">info_mappings_callback</a> (<span class="keyword">struct</span> prmap *map, <a class="code" href="defs_8h.html#a9d6528d2f701ee8e47c35c038752ac99">find_memory_region_ftype</a> <a class="code" href="corelow_8c.html#ac54c1aef0966c38fc155dec95a38db50">ignore</a>,
<a name="l05099"></a>05099                         <span class="keywordtype">void</span> *unused)
<a name="l05100"></a>05100 {
<a name="l05101"></a>05101   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pr_off;
<a name="l05102"></a>05102 
<a name="l05103"></a>05103 <span class="preprocessor">#ifdef PCAGENT  </span><span class="comment">/* Horrible hack: only defined on Solaris 2.6+ */</span>
<a name="l05104"></a>05104   pr_off = (<span class="keywordtype">unsigned</span> <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>) map-&gt;pr_offset;
<a name="l05105"></a>05105 #<span class="keywordflow">else</span>
<a name="l05106"></a>05106   pr_off = map-&gt;pr_off;
<a name="l05107"></a>05107 #endif
<a name="l05108"></a>05108 
<a name="l05109"></a>05109   if (<a class="code" href="gdbarch_8c.html#a3ee335ac98782b6633ab7fc235182cc9">gdbarch_addr_bit</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ()) == 32)
<a name="l05110"></a>05110     <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;\t%#10lx %#10lx %#10lx %#10x %7s\n&quot;</span>,
<a name="l05111"></a>05111                      (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) map-&gt;pr_vaddr,
<a name="l05112"></a>05112                      (<span class="keywordtype">unsigned</span> <a class="code" href="namespacegdb_1_1printing.html#ae264c8b9a4ff02c4b077df5db5944977">long</a>) map-&gt;pr_vaddr + map-&gt;pr_size - 1,
<a name="l05113"></a>05113                      (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) map-&gt;pr_size,
<a name="l05114"></a>05114                      pr_off,
<a name="l05115"></a>05115                      <a class="code" href="procfs_8c.html#a4d298b3afddc90deff1f7bc5daef704c">mappingflags</a> (map-&gt;pr_mflags));
<a name="l05116"></a>05116   <span class="keywordflow">else</span>
<a name="l05117"></a>05117     <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;  %#18lx %#18lx %#10lx %#10x %7s\n&quot;</span>,
<a name="l05118"></a>05118                      (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) map-&gt;pr_vaddr,
<a name="l05119"></a>05119                      (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) map-&gt;pr_vaddr + map-&gt;pr_size - 1,
<a name="l05120"></a>05120                      (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) map-&gt;pr_size,
<a name="l05121"></a>05121                      pr_off,
<a name="l05122"></a>05122                      <a class="code" href="procfs_8c.html#a4d298b3afddc90deff1f7bc5daef704c">mappingflags</a> (map-&gt;pr_mflags));
<a name="l05123"></a>05123 
<a name="l05124"></a>05124   <span class="keywordflow">return</span> 0;
<a name="l05125"></a>05125 }
<a name="l05126"></a>05126 
<a name="l05127"></a>05127 <span class="comment">/* Implement the &quot;info proc mappings&quot; subcommand.  */</span>
<a name="l05128"></a>05128 
<a name="l05129"></a>05129 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05130"></a><a class="code" href="procfs_8c.html#ad3ad96cfe43a10819b979b8fbc336523">05130</a> <a class="code" href="procfs_8c.html#ad3ad96cfe43a10819b979b8fbc336523">info_proc_mappings</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">int</span> summary)
<a name="l05131"></a>05131 {
<a name="l05132"></a>05132   <span class="keywordflow">if</span> (summary)
<a name="l05133"></a>05133     <span class="keywordflow">return</span>;     <span class="comment">/* No output for summary mode.  */</span>
<a name="l05134"></a>05134 
<a name="l05135"></a>05135   <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Mapped address spaces:\n\n&quot;</span>));
<a name="l05136"></a>05136   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#ae356193e481873e4377ff922d984f13f">gdbarch_ptr_bit</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ()) == 32)
<a name="l05137"></a>05137     <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;\t%10s %10s %10s %10s %7s\n&quot;</span>,
<a name="l05138"></a>05138                      <span class="stringliteral">&quot;Start Addr&quot;</span>,
<a name="l05139"></a>05139                      <span class="stringliteral">&quot;  End Addr&quot;</span>,
<a name="l05140"></a>05140                      <span class="stringliteral">&quot;      Size&quot;</span>,
<a name="l05141"></a>05141                      <span class="stringliteral">&quot;    Offset&quot;</span>,
<a name="l05142"></a>05142                      <span class="stringliteral">&quot;Flags&quot;</span>);
<a name="l05143"></a>05143   <span class="keywordflow">else</span>
<a name="l05144"></a>05144     <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;  %18s %18s %10s %10s %7s\n&quot;</span>,
<a name="l05145"></a>05145                      <span class="stringliteral">&quot;Start Addr&quot;</span>,
<a name="l05146"></a>05146                      <span class="stringliteral">&quot;  End Addr&quot;</span>,
<a name="l05147"></a>05147                      <span class="stringliteral">&quot;      Size&quot;</span>,
<a name="l05148"></a>05148                      <span class="stringliteral">&quot;    Offset&quot;</span>,
<a name="l05149"></a>05149                      <span class="stringliteral">&quot;Flags&quot;</span>);
<a name="l05150"></a>05150 
<a name="l05151"></a>05151   <a class="code" href="procfs_8c.html#a2c2c4e0ad3531aa668e8a6f38b50ba29">iterate_over_mappings</a> (pi, NULL, NULL, <a class="code" href="procfs_8c.html#a43317a5a0a86fb86367af2bfce545871">info_mappings_callback</a>);
<a name="l05152"></a>05152   <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l05153"></a>05153 }
<a name="l05154"></a>05154 
<a name="l05155"></a>05155 <span class="comment">/* Implement the &quot;info proc&quot; command.  */</span>
<a name="l05156"></a>05156 
<a name="l05157"></a>05157 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05158"></a><a class="code" href="procfs_8c.html#af62e88d644ae20074ae2801e643a0b2f">05158</a> <a class="code" href="procfs_8c.html#af62e88d644ae20074ae2801e643a0b2f">procfs_info_proc</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops, <span class="keywordtype">char</span> *args,
<a name="l05159"></a>05159                   <span class="keyword">enum</span> <a class="code" href="defs_8h.html#a766e85723d7470eb8519ed31b1ef8bf4">info_proc_what</a> what)
<a name="l05160"></a>05160 {
<a name="l05161"></a>05161   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_chain;
<a name="l05162"></a>05162   <a class="code" href="structprocinfo.html">procinfo</a> *process  = NULL;
<a name="l05163"></a>05163   <a class="code" href="structprocinfo.html">procinfo</a> *thread   = NULL;
<a name="l05164"></a>05164   <span class="keywordtype">char</span>    **argv     = NULL;
<a name="l05165"></a>05165   <span class="keywordtype">char</span>     *tmp      = NULL;
<a name="l05166"></a>05166   <span class="keywordtype">int</span>       pid      = 0;
<a name="l05167"></a>05167   <span class="keywordtype">int</span>       tid      = 0;
<a name="l05168"></a>05168   <span class="keywordtype">int</span>       <a class="code" href="amd64-windows-nat_8c.html#a63e913341a495aa4ee2a9a44f8de9da8">mappings</a> = 0;
<a name="l05169"></a>05169 
<a name="l05170"></a>05170   <span class="keywordflow">switch</span> (what)
<a name="l05171"></a>05171     {
<a name="l05172"></a>05172     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#a766e85723d7470eb8519ed31b1ef8bf4a84d2498271da96af1176ce110b4a8593">IP_MINIMAL</a>:
<a name="l05173"></a>05173       <span class="keywordflow">break</span>;
<a name="l05174"></a>05174 
<a name="l05175"></a>05175     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#a766e85723d7470eb8519ed31b1ef8bf4a518444ea255fa3daff32c86ff6fcd1b6">IP_MAPPINGS</a>:
<a name="l05176"></a>05176     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#a766e85723d7470eb8519ed31b1ef8bf4a4b937b28dd7e683b7b49c99c6e28f53e">IP_ALL</a>:
<a name="l05177"></a>05177       mappings = 1;
<a name="l05178"></a>05178       <span class="keywordflow">break</span>;
<a name="l05179"></a>05179 
<a name="l05180"></a>05180     <span class="keywordflow">default</span>:
<a name="l05181"></a>05181       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Not supported on this target.&quot;</span>));
<a name="l05182"></a>05182     }
<a name="l05183"></a>05183 
<a name="l05184"></a>05184   old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, 0);
<a name="l05185"></a>05185   <span class="keywordflow">if</span> (args)
<a name="l05186"></a>05186     {
<a name="l05187"></a>05187       argv = <a class="code" href="utils_8c.html#a146bf06d6062174a10a36700c40fdae4">gdb_buildargv</a> (args);
<a name="l05188"></a>05188       <a class="code" href="utils_8c.html#aad1e14fe73668592441775f7346f558e">make_cleanup_freeargv</a> (argv);
<a name="l05189"></a>05189     }
<a name="l05190"></a>05190   <span class="keywordflow">while</span> (argv != NULL &amp;&amp; *argv != NULL)
<a name="l05191"></a>05191     {
<a name="l05192"></a>05192       <span class="keywordflow">if</span> (isdigit (argv[0][0]))
<a name="l05193"></a>05193         {
<a name="l05194"></a>05194           pid = strtoul (argv[0], &amp;tmp, 10);
<a name="l05195"></a>05195           <span class="keywordflow">if</span> (*tmp == <span class="charliteral">&#39;/&#39;</span>)
<a name="l05196"></a>05196             tid = strtoul (++tmp, NULL, 10);
<a name="l05197"></a>05197         }
<a name="l05198"></a>05198       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[0][0] == <span class="charliteral">&#39;/&#39;</span>)
<a name="l05199"></a>05199         {
<a name="l05200"></a>05200           tid = strtoul (argv[0] + 1, NULL, 10);
<a name="l05201"></a>05201         }
<a name="l05202"></a>05202       argv++;
<a name="l05203"></a>05203     }
<a name="l05204"></a>05204   <span class="keywordflow">if</span> (pid == 0)
<a name="l05205"></a>05205     pid = <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>);
<a name="l05206"></a>05206   <span class="keywordflow">if</span> (pid == 0)
<a name="l05207"></a>05207     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No current process: you must name one.&quot;</span>));
<a name="l05208"></a>05208   <span class="keywordflow">else</span>
<a name="l05209"></a>05209     {
<a name="l05210"></a>05210       <span class="comment">/* Have pid, will travel.</span>
<a name="l05211"></a>05211 <span class="comment">         First see if it&#39;s a process we&#39;re already debugging.  */</span>
<a name="l05212"></a>05212       process = <a class="code" href="procfs_8c.html#a56326184f092cce267aef78648cc9fb0">find_procinfo</a> (pid, 0);
<a name="l05213"></a>05213        <span class="keywordflow">if</span> (process == NULL)
<a name="l05214"></a>05214          {
<a name="l05215"></a>05215            <span class="comment">/* No.  So open a procinfo for it, but</span>
<a name="l05216"></a>05216 <span class="comment">              remember to close it again when finished.  */</span>
<a name="l05217"></a>05217            process = <a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a> (pid, 0);
<a name="l05218"></a>05218            <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="procfs_8c.html#ab2c6317aa8356e2091a2bc12eb69f1c2">do_destroy_procinfo_cleanup</a>, process);
<a name="l05219"></a>05219            <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a7fdc8bf1a246c58621c4e7740194c01e">open_procinfo_files</a> (process, <a class="code" href="procfs_8c.html#a1f3b6c692395e5007ff47ce5d9304c1ca242b7fbe149191cf293910e1f2f65bd6">FD_CTL</a>))
<a name="l05220"></a>05220              <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (process, <span class="stringliteral">&quot;info proc, open_procinfo_files&quot;</span>, __LINE__);
<a name="l05221"></a>05221          }
<a name="l05222"></a>05222     }
<a name="l05223"></a>05223   <span class="keywordflow">if</span> (tid != 0)
<a name="l05224"></a>05224     thread = <a class="code" href="procfs_8c.html#a4ebad4ce47381410447fe0379a955834">create_procinfo</a> (pid, tid);
<a name="l05225"></a>05225 
<a name="l05226"></a>05226   <span class="keywordflow">if</span> (process)
<a name="l05227"></a>05227     {
<a name="l05228"></a>05228       <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;process %d flags:\n&quot;</span>), process-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>);
<a name="l05229"></a>05229       <a class="code" href="proc-flags_8c.html#a3ce6eec093522070de47785f828edc68">proc_prettyprint_flags</a> (<a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (process), 1);
<a name="l05230"></a>05230       <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (process) &amp; (PR_STOPPED | PR_ISTOP))
<a name="l05231"></a>05231         <a class="code" href="proc-utils_8h.html#ad359cee950a98ba9d3562d4e339e7b66">proc_prettyprint_why</a> (<a class="code" href="procfs_8c.html#af1d2febb017ce0acde9f56bbfcbfde9e">proc_why</a> (process), <a class="code" href="procfs_8c.html#a8f54b931ed7656bcce6696ea27b8b3c3">proc_what</a> (process), 1);
<a name="l05232"></a>05232       <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#a011be1a5ae96e7e39bb1dc60b512e977">proc_get_nthreads</a> (process) &gt; 1)
<a name="l05233"></a>05233         <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;Process has %d threads.\n&quot;</span>,
<a name="l05234"></a>05234                          <a class="code" href="procfs_8c.html#a011be1a5ae96e7e39bb1dc60b512e977">proc_get_nthreads</a> (process));
<a name="l05235"></a>05235     }
<a name="l05236"></a>05236   <span class="keywordflow">if</span> (thread)
<a name="l05237"></a>05237     {
<a name="l05238"></a>05238       <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;thread %d flags:\n&quot;</span>), thread-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>);
<a name="l05239"></a>05239       <a class="code" href="proc-flags_8c.html#a3ce6eec093522070de47785f828edc68">proc_prettyprint_flags</a> (<a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (thread), 1);
<a name="l05240"></a>05240       <span class="keywordflow">if</span> (<a class="code" href="procfs_8c.html#ae44bddc9591a9f7833e35c344343535e">proc_flags</a> (thread) &amp; (PR_STOPPED | PR_ISTOP))
<a name="l05241"></a>05241         <a class="code" href="proc-utils_8h.html#ad359cee950a98ba9d3562d4e339e7b66">proc_prettyprint_why</a> (<a class="code" href="procfs_8c.html#af1d2febb017ce0acde9f56bbfcbfde9e">proc_why</a> (thread), <a class="code" href="procfs_8c.html#a8f54b931ed7656bcce6696ea27b8b3c3">proc_what</a> (thread), 1);
<a name="l05242"></a>05242     }
<a name="l05243"></a>05243 
<a name="l05244"></a>05244   <span class="keywordflow">if</span> (mappings)
<a name="l05245"></a>05245     {
<a name="l05246"></a>05246       <a class="code" href="procfs_8c.html#ad3ad96cfe43a10819b979b8fbc336523">info_proc_mappings</a> (process, 0);
<a name="l05247"></a>05247     }
<a name="l05248"></a>05248 
<a name="l05249"></a>05249   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l05250"></a>05250 }
<a name="l05251"></a>05251 
<a name="l05252"></a>05252 <span class="comment">/* Modify the status of the system call identified by SYSCALLNUM in</span>
<a name="l05253"></a>05253 <span class="comment">   the set of syscalls that are currently traced/debugged.</span>
<a name="l05254"></a>05254 <span class="comment"></span>
<a name="l05255"></a>05255 <span class="comment">   If ENTRY_OR_EXIT is set to PR_SYSENTRY, then the entry syscalls set</span>
<a name="l05256"></a>05256 <span class="comment">   will be updated.  Otherwise, the exit syscalls set will be updated.</span>
<a name="l05257"></a>05257 <span class="comment"></span>
<a name="l05258"></a>05258 <span class="comment">   If MODE is FLAG_SET, then traces will be enabled.  Otherwise, they</span>
<a name="l05259"></a>05259 <span class="comment">   will be disabled.  */</span>
<a name="l05260"></a>05260 
<a name="l05261"></a>05261 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05262"></a><a class="code" href="procfs_8c.html#ae027347db869ac7b72aa4a12608fb54b">05262</a> <a class="code" href="procfs_8c.html#ae027347db869ac7b72aa4a12608fb54b">proc_trace_syscalls_1</a> (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <span class="keywordtype">int</span> syscallnum, <span class="keywordtype">int</span> entry_or_exit,
<a name="l05263"></a>05263                        <span class="keywordtype">int</span> mode, <span class="keywordtype">int</span> from_tty)
<a name="l05264"></a>05264 {
<a name="l05265"></a>05265   sysset_t *sysset;
<a name="l05266"></a>05266 
<a name="l05267"></a>05267   <span class="keywordflow">if</span> (entry_or_exit == PR_SYSENTRY)
<a name="l05268"></a>05268     sysset = <a class="code" href="procfs_8c.html#a383f37198255501af0d2097360b52063">proc_get_traced_sysentry</a> (pi, NULL);
<a name="l05269"></a>05269   <span class="keywordflow">else</span>
<a name="l05270"></a>05270     sysset = <a class="code" href="procfs_8c.html#afb19be38f985cb48545d7f81771dcf60">proc_get_traced_sysexit</a> (pi, NULL);
<a name="l05271"></a>05271 
<a name="l05272"></a>05272   <span class="keywordflow">if</span> (sysset == NULL)
<a name="l05273"></a>05273     <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;proc-trace, get_traced_sysset&quot;</span>, __LINE__);
<a name="l05274"></a>05274 
<a name="l05275"></a>05275   <span class="keywordflow">if</span> (mode == <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dadadd120ee5969e963eb496b7a32d13e376">FLAG_SET</a>)
<a name="l05276"></a>05276     <a class="code" href="procfs_8c.html#a76301aeffe9629a8b2a76aa554cc01f3">gdb_praddsysset</a> (sysset, syscallnum);
<a name="l05277"></a>05277   <span class="keywordflow">else</span>
<a name="l05278"></a>05278     <a class="code" href="procfs_8c.html#af43f8629f8c66a037cff9ef248521308">gdb_prdelsysset</a> (sysset, syscallnum);
<a name="l05279"></a>05279 
<a name="l05280"></a>05280   <span class="keywordflow">if</span> (entry_or_exit == PR_SYSENTRY)
<a name="l05281"></a>05281     {
<a name="l05282"></a>05282       <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a84e53147df27900c8c107d200c34b795">proc_set_traced_sysentry</a> (pi, sysset))
<a name="l05283"></a>05283         <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;proc-trace, set_traced_sysentry&quot;</span>, __LINE__);
<a name="l05284"></a>05284     }
<a name="l05285"></a>05285   <span class="keywordflow">else</span>
<a name="l05286"></a>05286     {
<a name="l05287"></a>05287       <span class="keywordflow">if</span> (!<a class="code" href="procfs_8c.html#a33c100a98eea13970f4ac33a7e9af14f">proc_set_traced_sysexit</a> (pi, sysset))
<a name="l05288"></a>05288         <a class="code" href="procfs_8c.html#aac5f66b26dd59c245f470918411a55b5">proc_error</a> (pi, <span class="stringliteral">&quot;proc-trace, set_traced_sysexit&quot;</span>, __LINE__);
<a name="l05289"></a>05289     }
<a name="l05290"></a>05290 }
<a name="l05291"></a>05291 
<a name="l05292"></a>05292 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05293"></a><a class="code" href="procfs_8c.html#aa8cc6f7a81b074572be5506dfd38ae6d">05293</a> <a class="code" href="procfs_8c.html#aa8cc6f7a81b074572be5506dfd38ae6d">proc_trace_syscalls</a> (<span class="keywordtype">char</span> *args, <span class="keywordtype">int</span> from_tty, <span class="keywordtype">int</span> entry_or_exit, <span class="keywordtype">int</span> mode)
<a name="l05294"></a>05294 {
<a name="l05295"></a>05295   <a class="code" href="structprocinfo.html">procinfo</a> *pi;
<a name="l05296"></a>05296 
<a name="l05297"></a>05297   <span class="keywordflow">if</span> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>) &lt;= 0)
<a name="l05298"></a>05298     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;you must be debugging a process to use this command.&quot;</span>));
<a name="l05299"></a>05299 
<a name="l05300"></a>05300   <span class="keywordflow">if</span> (args == NULL || args[0] == 0)
<a name="l05301"></a>05301     <a class="code" href="cli-cmds_8c.html#a68aef78cdf72abc9df2495a4618842c3">error_no_arg</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;system call to trace&quot;</span>));
<a name="l05302"></a>05302 
<a name="l05303"></a>05303   pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>), 0);
<a name="l05304"></a>05304   <span class="keywordflow">if</span> (isdigit (args[0]))
<a name="l05305"></a>05305     {
<a name="l05306"></a>05306       <span class="keyword">const</span> <span class="keywordtype">int</span> syscallnum = atoi (args);
<a name="l05307"></a>05307 
<a name="l05308"></a>05308       <a class="code" href="procfs_8c.html#ae027347db869ac7b72aa4a12608fb54b">proc_trace_syscalls_1</a> (pi, syscallnum, entry_or_exit, mode, from_tty);
<a name="l05309"></a>05309     }
<a name="l05310"></a>05310 }
<a name="l05311"></a>05311 
<a name="l05312"></a>05312 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05313"></a><a class="code" href="procfs_8c.html#a817a4775151d68dc3efd8de24145170d">05313</a> <a class="code" href="procfs_8c.html#a817a4775151d68dc3efd8de24145170d">proc_trace_sysentry_cmd</a> (<span class="keywordtype">char</span> *args, <span class="keywordtype">int</span> from_tty)
<a name="l05314"></a>05314 {
<a name="l05315"></a>05315   <a class="code" href="procfs_8c.html#aa8cc6f7a81b074572be5506dfd38ae6d">proc_trace_syscalls</a> (args, from_tty, PR_SYSENTRY, <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dadadd120ee5969e963eb496b7a32d13e376">FLAG_SET</a>);
<a name="l05316"></a>05316 }
<a name="l05317"></a>05317 
<a name="l05318"></a>05318 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05319"></a><a class="code" href="procfs_8c.html#ad3a780ae0c3d5612c2443c44997dcbcf">05319</a> <a class="code" href="procfs_8c.html#ad3a780ae0c3d5612c2443c44997dcbcf">proc_trace_sysexit_cmd</a> (<span class="keywordtype">char</span> *args, <span class="keywordtype">int</span> from_tty)
<a name="l05320"></a>05320 {
<a name="l05321"></a>05321   <a class="code" href="procfs_8c.html#aa8cc6f7a81b074572be5506dfd38ae6d">proc_trace_syscalls</a> (args, from_tty, PR_SYSEXIT, <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dadadd120ee5969e963eb496b7a32d13e376">FLAG_SET</a>);
<a name="l05322"></a>05322 }
<a name="l05323"></a>05323 
<a name="l05324"></a>05324 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05325"></a><a class="code" href="procfs_8c.html#a9d2a3d296d11e83293ee4af6f05189b2">05325</a> <a class="code" href="procfs_8c.html#a9d2a3d296d11e83293ee4af6f05189b2">proc_untrace_sysentry_cmd</a> (<span class="keywordtype">char</span> *args, <span class="keywordtype">int</span> from_tty)
<a name="l05326"></a>05326 {
<a name="l05327"></a>05327   <a class="code" href="procfs_8c.html#aa8cc6f7a81b074572be5506dfd38ae6d">proc_trace_syscalls</a> (args, from_tty, PR_SYSENTRY, <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dada34921dc2c1632e9847571a81ce00124c">FLAG_RESET</a>);
<a name="l05328"></a>05328 }
<a name="l05329"></a>05329 
<a name="l05330"></a>05330 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05331"></a><a class="code" href="procfs_8c.html#aa57f70e2848eefa83210e6dd45b83ef6">05331</a> <a class="code" href="procfs_8c.html#aa57f70e2848eefa83210e6dd45b83ef6">proc_untrace_sysexit_cmd</a> (<span class="keywordtype">char</span> *args, <span class="keywordtype">int</span> from_tty)
<a name="l05332"></a>05332 {
<a name="l05333"></a>05333   <a class="code" href="procfs_8c.html#aa8cc6f7a81b074572be5506dfd38ae6d">proc_trace_syscalls</a> (args, from_tty, PR_SYSEXIT, <a class="code" href="procfs_8c.html#a01aea4eb01aa6415eee118b5a5ee3dada34921dc2c1632e9847571a81ce00124c">FLAG_RESET</a>);
<a name="l05334"></a>05334 }
<a name="l05335"></a>05335 
<a name="l05336"></a>05336 
<a name="l05337"></a>05337 <span class="comment">/* Provide a prototype to silence -Wmissing-prototypes.  */</span>
<a name="l05338"></a>05338 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="nto-procfs_8c.html#a25bf4eaf21f18d879152bf1a6bab04eb">_initialize_procfs</a> (<span class="keywordtype">void</span>);
<a name="l05339"></a>05339 
<a name="l05340"></a>05340 <span class="keywordtype">void</span>
<a name="l05341"></a>05341 <a class="code" href="nto-procfs_8c.html#a25bf4eaf21f18d879152bf1a6bab04eb">_initialize_procfs</a> (<span class="keywordtype">void</span>)
<a name="l05342"></a>05342 {
<a name="l05343"></a>05343   <a class="code" href="observer_8h.html#af49321328b079457d8950fb05de0b2b6">observer_attach_inferior_created</a> (<a class="code" href="procfs_8c.html#a8833737d1c38c0eeaa0500af8c9f8180">procfs_inferior_created</a>);
<a name="l05344"></a>05344 
<a name="l05345"></a>05345   <a class="code" href="cli-decode_8c.html#a0df0ca36d9acd96440e24407cbef593c">add_com</a> (<span class="stringliteral">&quot;proc-trace-entry&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49afbf489a4abce7e8770b178aa54f0908b">no_class</a>, <a class="code" href="procfs_8c.html#a817a4775151d68dc3efd8de24145170d">proc_trace_sysentry_cmd</a>,
<a name="l05346"></a>05346            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Give a trace of entries into the syscall.&quot;</span>));
<a name="l05347"></a>05347   <a class="code" href="cli-decode_8c.html#a0df0ca36d9acd96440e24407cbef593c">add_com</a> (<span class="stringliteral">&quot;proc-trace-exit&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49afbf489a4abce7e8770b178aa54f0908b">no_class</a>, <a class="code" href="procfs_8c.html#ad3a780ae0c3d5612c2443c44997dcbcf">proc_trace_sysexit_cmd</a>,
<a name="l05348"></a>05348            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Give a trace of exits from the syscall.&quot;</span>));
<a name="l05349"></a>05349   <a class="code" href="cli-decode_8c.html#a0df0ca36d9acd96440e24407cbef593c">add_com</a> (<span class="stringliteral">&quot;proc-untrace-entry&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49afbf489a4abce7e8770b178aa54f0908b">no_class</a>, <a class="code" href="procfs_8c.html#a9d2a3d296d11e83293ee4af6f05189b2">proc_untrace_sysentry_cmd</a>,
<a name="l05350"></a>05350            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cancel a trace of entries into the syscall.&quot;</span>));
<a name="l05351"></a>05351   <a class="code" href="cli-decode_8c.html#a0df0ca36d9acd96440e24407cbef593c">add_com</a> (<span class="stringliteral">&quot;proc-untrace-exit&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49afbf489a4abce7e8770b178aa54f0908b">no_class</a>, <a class="code" href="procfs_8c.html#aa57f70e2848eefa83210e6dd45b83ef6">proc_untrace_sysexit_cmd</a>,
<a name="l05352"></a>05352            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cancel a trace of exits from the syscall.&quot;</span>));
<a name="l05353"></a>05353 }
<a name="l05354"></a>05354 
<a name="l05355"></a>05355 <span class="comment">/* =================== END, GDB  &quot;MODULE&quot; =================== */</span>
<a name="l05356"></a>05356 
<a name="l05357"></a>05357 
<a name="l05358"></a>05358 
<a name="l05359"></a>05359 <span class="comment">/* miscellaneous stubs: */</span>
<a name="l05360"></a>05360 
<a name="l05361"></a>05361 <span class="comment">/* The following satisfy a few random symbols mostly created by the</span>
<a name="l05362"></a>05362 <span class="comment">   solaris threads implementation, which I will chase down later.  */</span>
<a name="l05363"></a>05363 
<a name="l05364"></a>05364 <span class="comment">/* Return a pid for which we guarantee we will be able to find a</span>
<a name="l05365"></a>05365 <span class="comment">   &#39;live&#39; procinfo.  */</span>
<a name="l05366"></a>05366 
<a name="l05367"></a>05367 <a class="code" href="structptid.html">ptid_t</a>
<a name="l05368"></a><a class="code" href="procfs_8h.html#a31818fe4236fb8af745451ec33677584">05368</a> <a class="code" href="procfs_8c.html#a31818fe4236fb8af745451ec33677584">procfs_first_available</a> (<span class="keywordtype">void</span>)
<a name="l05369"></a>05369 {
<a name="l05370"></a>05370   <span class="keywordflow">return</span> <a class="code" href="ptid_8c.html#a41fa537798e02ba25c7980a7c1e46272">pid_to_ptid</a> (procinfo_list ? procinfo_list-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a> : -1);
<a name="l05371"></a>05371 }
<a name="l05372"></a>05372 
<a name="l05373"></a>05373 <span class="comment">/* ===================  GCORE .NOTE &quot;MODULE&quot; =================== */</span>
<a name="l05374"></a>05374 <span class="preprocessor">#if defined (PIOCOPENLWP) || defined (PCAGENT)</span>
<a name="l05375"></a>05375 <span class="preprocessor"></span><span class="comment">/* gcore only implemented on solaris (so far) */</span>
<a name="l05376"></a>05376 
<a name="l05377"></a>05377 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l05378"></a>05378 procfs_do_thread_registers (bfd *obfd, <a class="code" href="structptid.html">ptid_t</a> ptid,
<a name="l05379"></a>05379                             <span class="keywordtype">char</span> *note_data, <span class="keywordtype">int</span> *note_size,
<a name="l05380"></a>05380                             <span class="keyword">enum</span> gdb_signal stop_signal)
<a name="l05381"></a>05381 {
<a name="l05382"></a>05382   <span class="keyword">struct </span>regcache *regcache = <a class="code" href="regcache_8c.html#aec7af24a2f0b7c27c042f6a22c51291b">get_thread_regcache</a> (ptid);
<a name="l05383"></a>05383   <a class="code" href="gregset_8h.html#ad358cd20eb83ca9e131c708c8aa14c89">gdb_gregset_t</a> gregs;
<a name="l05384"></a>05384   <a class="code" href="gregset_8h.html#ac5319835a36948bae33bef8f21542def">gdb_fpregset_t</a> fpregs;
<a name="l05385"></a>05385   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> merged_pid;
<a name="l05386"></a>05386   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_chain;
<a name="l05387"></a>05387 
<a name="l05388"></a>05388   merged_pid = <a class="code" href="ptid_8c.html#af5b67a5f356c507b7809af2fa4e63b44">ptid_get_lwp</a> (ptid) &lt;&lt; 16 | <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (ptid);
<a name="l05389"></a>05389 
<a name="l05390"></a>05390   <span class="comment">/* This part is the old method for fetching registers.</span>
<a name="l05391"></a>05391 <span class="comment">     It should be replaced by the newer one using regsets</span>
<a name="l05392"></a>05392 <span class="comment">     once it is implemented in this platform:</span>
<a name="l05393"></a>05393 <span class="comment">     gdbarch_regset_from_core_section() and regset-&gt;collect_regset().  */</span>
<a name="l05394"></a>05394 
<a name="l05395"></a>05395   old_chain = <a class="code" href="inferior_8h.html#a3f4175640dba9bda8c87957bb0c183fb">save_inferior_ptid</a> ();
<a name="l05396"></a>05396   <a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a> = ptid;
<a name="l05397"></a>05397   <a class="code" href="target_8c.html#a5e70515af98ce168933d973817e91a01">target_fetch_registers</a> (regcache, -1);
<a name="l05398"></a>05398 
<a name="l05399"></a>05399   <a class="code" href="aarch64-linux-nat_8c.html#a59e9e7e4054210afa3fc8e9f0a1bbc61">fill_gregset</a> (regcache, &amp;gregs, -1);
<a name="l05400"></a>05400 <span class="preprocessor">#if defined (NEW_PROC_API)</span>
<a name="l05401"></a>05401 <span class="preprocessor"></span>  note_data = (<span class="keywordtype">char</span> *) elfcore_write_lwpstatus (obfd,
<a name="l05402"></a>05402                                                 note_data,
<a name="l05403"></a>05403                                                 note_size,
<a name="l05404"></a>05404                                                 merged_pid,
<a name="l05405"></a>05405                                                 stop_signal,
<a name="l05406"></a>05406                                                 &amp;gregs);
<a name="l05407"></a>05407 <span class="preprocessor">#else</span>
<a name="l05408"></a>05408 <span class="preprocessor"></span>  note_data = (<span class="keywordtype">char</span> *) elfcore_write_prstatus (obfd,
<a name="l05409"></a>05409                                                note_data,
<a name="l05410"></a>05410                                                note_size,
<a name="l05411"></a>05411                                                merged_pid,
<a name="l05412"></a>05412                                                stop_signal,
<a name="l05413"></a>05413                                                &amp;gregs);
<a name="l05414"></a>05414 <span class="preprocessor">#endif</span>
<a name="l05415"></a>05415 <span class="preprocessor"></span>  <a class="code" href="aarch64-linux-nat_8c.html#ad18ef6d17cc5848eb79210aed1177cbc">fill_fpregset</a> (regcache, &amp;fpregs, -1);
<a name="l05416"></a>05416   note_data = (<span class="keywordtype">char</span> *) elfcore_write_prfpreg (obfd,
<a name="l05417"></a>05417                                               note_data,
<a name="l05418"></a>05418                                               note_size,
<a name="l05419"></a>05419                                               &amp;fpregs,
<a name="l05420"></a>05420                                               <span class="keyword">sizeof</span> (fpregs));
<a name="l05421"></a>05421 
<a name="l05422"></a>05422   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l05423"></a>05423 
<a name="l05424"></a>05424   <span class="keywordflow">return</span> note_data;
<a name="l05425"></a>05425 }
<a name="l05426"></a>05426 
<a name="l05427"></a>05427 <span class="keyword">struct </span>procfs_corefile_thread_data {
<a name="l05428"></a>05428   bfd *obfd;
<a name="l05429"></a>05429   <span class="keywordtype">char</span> *note_data;
<a name="l05430"></a>05430   <span class="keywordtype">int</span> *note_size;
<a name="l05431"></a>05431   <span class="keyword">enum</span> gdb_signal stop_signal;
<a name="l05432"></a>05432 };
<a name="l05433"></a>05433 
<a name="l05434"></a>05434 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05435"></a>05435 procfs_corefile_thread_callback (<a class="code" href="structprocinfo.html">procinfo</a> *pi, <a class="code" href="structprocinfo.html">procinfo</a> *thread, <span class="keywordtype">void</span> *data)
<a name="l05436"></a>05436 {
<a name="l05437"></a>05437   <span class="keyword">struct </span>procfs_corefile_thread_data *args = data;
<a name="l05438"></a>05438 
<a name="l05439"></a>05439   <span class="keywordflow">if</span> (pi != NULL)
<a name="l05440"></a>05440     {
<a name="l05441"></a>05441       <a class="code" href="structptid.html">ptid_t</a> ptid = <a class="code" href="ptid_8c.html#aa96ee3f6a88626ec36045b4d84e27f79">ptid_build</a> (pi-&gt;<a class="code" href="structprocinfo.html#ae002718da51a0d048c7a68ae3ef1a850">pid</a>, thread-&gt;<a class="code" href="structprocinfo.html#a77bd5f473024a584c989057194191236">tid</a>, 0);
<a name="l05442"></a>05442 
<a name="l05443"></a>05443       args-&gt;note_data = procfs_do_thread_registers (args-&gt;obfd, ptid,
<a name="l05444"></a>05444                                                     args-&gt;note_data,
<a name="l05445"></a>05445                                                     args-&gt;note_size,
<a name="l05446"></a>05446                                                     args-&gt;stop_signal);
<a name="l05447"></a>05447     }
<a name="l05448"></a>05448   <span class="keywordflow">return</span> 0;
<a name="l05449"></a>05449 }
<a name="l05450"></a>05450 
<a name="l05451"></a>05451 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05452"></a>05452 <a class="code" href="fbsd-nat_8c.html#ade999fad2068ea88f956167517c08043">find_signalled_thread</a> (<span class="keyword">struct</span> <a class="code" href="structthread__info.html">thread_info</a> *info, <span class="keywordtype">void</span> *data)
<a name="l05453"></a>05453 {
<a name="l05454"></a>05454   <span class="keywordflow">if</span> (info-&gt;<a class="code" href="structthread__info.html#ab9bd2a327c3c001e408093a5e19cbc61">suspend</a>.<a class="code" href="structthread__suspend__state.html#aec982934ba29f3fbd8cab717e67f2763">stop_signal</a> != GDB_SIGNAL_0
<a name="l05455"></a>05455       &amp;&amp; <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (info-&gt;<a class="code" href="structthread__info.html#a533aa3979b60affd446e9fbff93fdd2c">ptid</a>) == <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>))
<a name="l05456"></a>05456     <span class="keywordflow">return</span> 1;
<a name="l05457"></a>05457 
<a name="l05458"></a>05458   <span class="keywordflow">return</span> 0;
<a name="l05459"></a>05459 }
<a name="l05460"></a>05460 
<a name="l05461"></a>05461 <span class="keyword">static</span> <span class="keyword">enum</span> gdb_signal
<a name="l05462"></a>05462 <a class="code" href="fbsd-nat_8c.html#a94a244b35f46c3187bfdb29661b561d4">find_stop_signal</a> (<span class="keywordtype">void</span>)
<a name="l05463"></a>05463 {
<a name="l05464"></a>05464   <span class="keyword">struct </span><a class="code" href="structthread__info.html">thread_info</a> *info =
<a name="l05465"></a>05465     <a class="code" href="gdbthread_8h.html#a5dc20fee3cc8a79f615f2f5d695ae1bc">iterate_over_threads</a> (<a class="code" href="fbsd-nat_8c.html#ade999fad2068ea88f956167517c08043">find_signalled_thread</a>, NULL);
<a name="l05466"></a>05466 
<a name="l05467"></a>05467   <span class="keywordflow">if</span> (info)
<a name="l05468"></a>05468     <span class="keywordflow">return</span> info-&gt;<a class="code" href="structthread__info.html#ab9bd2a327c3c001e408093a5e19cbc61">suspend</a>.<a class="code" href="structthread__suspend__state.html#aec982934ba29f3fbd8cab717e67f2763">stop_signal</a>;
<a name="l05469"></a>05469   <span class="keywordflow">else</span>
<a name="l05470"></a>05470     <span class="keywordflow">return</span> GDB_SIGNAL_0;
<a name="l05471"></a>05471 }
<a name="l05472"></a>05472 
<a name="l05473"></a>05473 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l05474"></a>05474 <a class="code" href="procfs_8c.html#afb51266a729cd7c07438948856cbf72a">procfs_make_note_section</a> (bfd *obfd, <span class="keywordtype">int</span> *note_size)
<a name="l05475"></a>05475 {
<a name="l05476"></a>05476   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_chain;
<a name="l05477"></a>05477   <a class="code" href="gregset_8h.html#ad358cd20eb83ca9e131c708c8aa14c89">gdb_gregset_t</a> gregs;
<a name="l05478"></a>05478   <a class="code" href="gregset_8h.html#ac5319835a36948bae33bef8f21542def">gdb_fpregset_t</a> fpregs;
<a name="l05479"></a>05479   <span class="keywordtype">char</span> fname[16] = {<span class="charliteral">&#39;\0&#39;</span>};
<a name="l05480"></a>05480   <span class="keywordtype">char</span> psargs[80] = {<span class="charliteral">&#39;\0&#39;</span>};
<a name="l05481"></a>05481   <a class="code" href="structprocinfo.html">procinfo</a> *pi = <a class="code" href="procfs_8c.html#a392cadc65a1dbb80e2bcadc3f73fc311">find_procinfo_or_die</a> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>), 0);
<a name="l05482"></a>05482   <span class="keywordtype">char</span> *note_data = NULL;
<a name="l05483"></a>05483   <span class="keywordtype">char</span> *inf_args;
<a name="l05484"></a>05484   <span class="keyword">struct </span>procfs_corefile_thread_data thread_args;
<a name="l05485"></a>05485   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *auxv;
<a name="l05486"></a>05486   <span class="keywordtype">int</span> auxv_len;
<a name="l05487"></a>05487   <span class="keyword">enum</span> gdb_signal stop_signal;
<a name="l05488"></a>05488 
<a name="l05489"></a>05489   <span class="keywordflow">if</span> (<a class="code" href="corefile_8c.html#a4e814b1531684005d22fea3e17f1781d">get_exec_file</a> (0))
<a name="l05490"></a>05490     {
<a name="l05491"></a>05491       strncpy (fname, lbasename (<a class="code" href="corefile_8c.html#a4e814b1531684005d22fea3e17f1781d">get_exec_file</a> (0)), <span class="keyword">sizeof</span> (fname));
<a name="l05492"></a>05492       fname[<span class="keyword">sizeof</span> (fname) - 1] = 0;
<a name="l05493"></a>05493       strncpy (psargs, <a class="code" href="corefile_8c.html#a4e814b1531684005d22fea3e17f1781d">get_exec_file</a> (0), <span class="keyword">sizeof</span> (psargs));
<a name="l05494"></a>05494       psargs[<span class="keyword">sizeof</span> (psargs) - 1] = 0;
<a name="l05495"></a>05495 
<a name="l05496"></a>05496       inf_args = <a class="code" href="infcmd_8c.html#a8174ce36eb3ae6ff2d654aa3731a22bd">get_inferior_args</a> ();
<a name="l05497"></a>05497       <span class="keywordflow">if</span> (inf_args &amp;&amp; *inf_args &amp;&amp;
<a name="l05498"></a>05498           strlen (inf_args) &lt; ((<span class="keywordtype">int</span>) <span class="keyword">sizeof</span> (psargs) - (<span class="keywordtype">int</span>) strlen (psargs)))
<a name="l05499"></a>05499         {
<a name="l05500"></a>05500           strncat (psargs, <span class="stringliteral">&quot; &quot;</span>,
<a name="l05501"></a>05501                    <span class="keyword">sizeof</span> (psargs) - strlen (psargs));
<a name="l05502"></a>05502           strncat (psargs, inf_args,
<a name="l05503"></a>05503                    <span class="keyword">sizeof</span> (psargs) - strlen (psargs));
<a name="l05504"></a>05504         }
<a name="l05505"></a>05505     }
<a name="l05506"></a>05506 
<a name="l05507"></a>05507   note_data = (<span class="keywordtype">char</span> *) elfcore_write_prpsinfo (obfd,
<a name="l05508"></a>05508                                                note_data,
<a name="l05509"></a>05509                                                note_size,
<a name="l05510"></a>05510                                                fname,
<a name="l05511"></a>05511                                                psargs);
<a name="l05512"></a>05512 
<a name="l05513"></a>05513   stop_signal = <a class="code" href="fbsd-nat_8c.html#a94a244b35f46c3187bfdb29661b561d4">find_stop_signal</a> ();
<a name="l05514"></a>05514 
<a name="l05515"></a>05515 <span class="preprocessor">#ifdef NEW_PROC_API</span>
<a name="l05516"></a>05516 <span class="preprocessor"></span>  <a class="code" href="aarch64-linux-nat_8c.html#a59e9e7e4054210afa3fc8e9f0a1bbc61">fill_gregset</a> (<a class="code" href="regcache_8c.html#a09a386286dc22d882378f639630fecef">get_current_regcache</a> (), &amp;gregs, -1);
<a name="l05517"></a>05517   note_data = elfcore_write_pstatus (obfd, note_data, note_size,
<a name="l05518"></a>05518                                      <a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>),
<a name="l05519"></a>05519                                      stop_signal, &amp;gregs);
<a name="l05520"></a>05520 <span class="preprocessor">#endif</span>
<a name="l05521"></a>05521 <span class="preprocessor"></span>
<a name="l05522"></a>05522   thread_args.obfd = obfd;
<a name="l05523"></a>05523   thread_args.note_data = note_data;
<a name="l05524"></a>05524   thread_args.note_size = note_size;
<a name="l05525"></a>05525   thread_args.stop_signal = stop_signal;
<a name="l05526"></a>05526   <a class="code" href="procfs_8c.html#a5fcfad306ae6b00c6d9b3c201d568580">proc_iterate_over_threads</a> (pi, procfs_corefile_thread_callback,
<a name="l05527"></a>05527                              &amp;thread_args);
<a name="l05528"></a>05528 
<a name="l05529"></a>05529   <span class="comment">/* There should be always at least one thread.  */</span>
<a name="l05530"></a>05530   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (thread_args.note_data != note_data);
<a name="l05531"></a>05531   note_data = thread_args.note_data;
<a name="l05532"></a>05532 
<a name="l05533"></a>05533   auxv_len = <a class="code" href="target_8c.html#a3fa3cddea970cd3b7fb5a5ecfb62eeac">target_read_alloc</a> (&amp;current_target, <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a5d6f5f222b30d70fed32596fb55d50b1">TARGET_OBJECT_AUXV</a>,
<a name="l05534"></a>05534                                 NULL, &amp;auxv);
<a name="l05535"></a>05535   <span class="keywordflow">if</span> (auxv_len &gt; 0)
<a name="l05536"></a>05536     {
<a name="l05537"></a>05537       note_data = elfcore_write_note (obfd, note_data, note_size,
<a name="l05538"></a>05538                                       <span class="stringliteral">&quot;CORE&quot;</span>, NT_AUXV, auxv, auxv_len);
<a name="l05539"></a>05539       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (auxv);
<a name="l05540"></a>05540     }
<a name="l05541"></a>05541 
<a name="l05542"></a>05542   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, note_data);
<a name="l05543"></a>05543   <span class="keywordflow">return</span> note_data;
<a name="l05544"></a>05544 }
<a name="l05545"></a>05545 <span class="preprocessor">#else </span><span class="comment">/* !Solaris */</span>
<a name="l05546"></a>05546 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l05547"></a><a class="code" href="procfs_8c.html#afb51266a729cd7c07438948856cbf72a">05547</a> <a class="code" href="procfs_8c.html#afb51266a729cd7c07438948856cbf72a">procfs_make_note_section</a> (bfd *obfd, <span class="keywordtype">int</span> *note_size)
<a name="l05548"></a>05548 {
<a name="l05549"></a>05549   <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;gcore not implemented for this host.&quot;</span>));
<a name="l05550"></a>05550   <span class="keywordflow">return</span> NULL;  <span class="comment">/* lint */</span>
<a name="l05551"></a>05551 }
<a name="l05552"></a>05552 <span class="preprocessor">#endif </span><span class="comment">/* Solaris */</span>
<a name="l05553"></a>05553 <span class="comment">/* ===================  END GCORE .NOTE &quot;MODULE&quot; =================== */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:13:31 for GDB (xrefs) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
