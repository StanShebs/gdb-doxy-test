<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (xrefs): /home/stan/gdb/src/gdb/cp-support.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (xrefs)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/cp-support.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="cp-support_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Helper routines for C++ support in GDB.</span>
<a name="l00002"></a>00002 <span class="comment">   Copyright (C) 2002-2013 Free Software Foundation, Inc.</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">   Contributed by MontaVista Software.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">   This file is part of GDB.</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00010"></a>00010 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00011"></a>00011 <span class="comment">   (at your option) any later version.</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00014"></a>00014 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00015"></a>00015 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00016"></a>00016 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00019"></a>00019 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="cp-support_8h.html">cp-support.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="gdb__string_8h.html">gdb_string.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;demangle.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="gdb__assert_8h.html">gdb_assert.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="gdbcmd_8h.html">gdbcmd.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="dictionary_8h.html">dictionary.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="objfiles_8h.html">objfiles.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="frame_8h.html">frame.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="block_8h.html">block.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="complaints_8h.html">complaints.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="gdbtypes_8h.html">gdbtypes.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="exceptions_8h.html">exceptions.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="expression_8h.html">expression.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="value_8h.html">value.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="cp-abi_8h.html">cp-abi.h</a>&quot;</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;safe-ctype.h&quot;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a><a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">00041</a> <span class="preprocessor">#define d_left(dc) (dc)-&gt;u.s_binary.left</span>
<a name="l00042"></a><a class="code" href="cp-support_8c.html#a40ba63c4584baeb86422c25e58fac461">00042</a> <span class="preprocessor"></span><span class="preprocessor">#define d_right(dc) (dc)-&gt;u.s_binary.right</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="comment">/* Functions related to demangled name parsing.  */</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="cp-support_8c.html#a192a52cfc07b8d9f4867c9ba46eecc3c">cp_find_first_component_aux</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>,
<a name="l00047"></a>00047                                                  <span class="keywordtype">int</span> permissive);
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="cp-support_8c.html#af3c166e5237ade66318ff3b315a214e9">demangled_name_complaint</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>);
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="comment">/* Functions/variables related to overload resolution.  */</span>
<a name="l00052"></a>00052 
<a name="l00053"></a><a class="code" href="cp-support_8c.html#a286a911b3ffab718b9a9f9e2f19cdf0e">00053</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="cp-support_8c.html#a286a911b3ffab718b9a9f9e2f19cdf0e">sym_return_val_size</a> = -1;
<a name="l00054"></a><a class="code" href="cp-support_8c.html#ab09a37ac5384668e3c7c8c11be5e8bd9">00054</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="cp-support_8c.html#ab09a37ac5384668e3c7c8c11be5e8bd9">sym_return_val_index</a>;
<a name="l00055"></a><a class="code" href="cp-support_8c.html#aa192c52fc8cfcda353c80526979c9765">00055</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> **<a class="code" href="cp-support_8c.html#aa192c52fc8cfcda353c80526979c9765">sym_return_val</a>;
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="cp-support_8c.html#a131464ca43faa1916f95fd3418c9f842">overload_list_add_symbol</a> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym,
<a name="l00058"></a>00058                                       <span class="keyword">const</span> <span class="keywordtype">char</span> *oload_name);
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="cp-support_8c.html#acbb67821ca29600912150f7fd6a6754b">make_symbol_overload_list_using</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *func_name,
<a name="l00061"></a>00061                                              <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">namespace</span>);
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="cp-support_8c.html#ab9a4da62634573a5ebeeca51db94992e">make_symbol_overload_list_qualified</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *func_name);
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="comment">/* The list of &quot;maint cplus&quot; commands.  */</span>
<a name="l00066"></a>00066 
<a name="l00067"></a><a class="code" href="cp-support_8h.html#af091ae584b9c9a9e47f75d6d7290026c">00067</a> <span class="keyword">struct </span><a class="code" href="structcmd__list__element.html">cmd_list_element</a> *<a class="code" href="cp-support_8c.html#af091ae584b9c9a9e47f75d6d7290026c">maint_cplus_cmd_list</a> = NULL;
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">/* The actual commands.  */</span>
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="cp-support_8c.html#ac5f976c363ca20800af871dc327a2c22">maint_cplus_command</a> (<span class="keywordtype">char</span> *arg, <span class="keywordtype">int</span> from_tty);
<a name="l00072"></a>00072 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="cp-support_8c.html#a6bc3e0d9410908a36b5015576e434171">first_component_command</a> (<span class="keywordtype">char</span> *arg, <span class="keywordtype">int</span> from_tty);
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="comment">/* A list of typedefs which should not be substituted by replace_typedefs.  */</span>
<a name="l00075"></a><a class="code" href="cp-support_8c.html#a643441484094765ff99cfec329c74126">00075</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> <a class="code" href="cp-support_8c.html#a643441484094765ff99cfec329c74126">ignore_typedefs</a>[] =
<a name="l00076"></a>00076   {
<a name="l00077"></a>00077     <span class="stringliteral">&quot;std::istream&quot;</span>, <span class="stringliteral">&quot;std::iostream&quot;</span>, <span class="stringliteral">&quot;std::ostream&quot;</span>, <span class="stringliteral">&quot;std::string&quot;</span>
<a name="l00078"></a>00078   };
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00081"></a>00081   <a class="code" href="cp-support_8c.html#a895f49490c31653166566bb2b590be5f">replace_typedefs</a> (<span class="keyword">struct</span> <a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *info,
<a name="l00082"></a>00082                     <span class="keyword">struct</span> demangle_component *ret_comp,
<a name="l00083"></a>00083                     <a class="code" href="cp-support_8h.html#adff53f004d48f7abf0932da77f6c0258">canonicalization_ftype</a> *finder,
<a name="l00084"></a>00084                     <span class="keywordtype">void</span> *data);
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="comment">/* A convenience function to copy STRING into OBSTACK, returning a pointer</span>
<a name="l00087"></a>00087 <span class="comment">   to the newly allocated string and saving the number of bytes saved in LEN.</span>
<a name="l00088"></a>00088 <span class="comment"></span>
<a name="l00089"></a>00089 <span class="comment">   It does not copy the terminating &#39;\0&#39; byte!  */</span>
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00092"></a><a class="code" href="cp-support_8c.html#a17927f61037567ec76811adc280ef678">00092</a> <a class="code" href="cp-support_8c.html#a17927f61037567ec76811adc280ef678">copy_string_to_obstack</a> (<span class="keyword">struct</span> obstack *obstack, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>,
<a name="l00093"></a>00093                         <span class="keywordtype">long</span> *<a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>)
<a name="l00094"></a>00094 {
<a name="l00095"></a>00095   *len = strlen (<span class="keywordtype">string</span>);
<a name="l00096"></a>00096   <span class="keywordflow">return</span> obstack_copy (obstack, <span class="keywordtype">string</span>, *len);
<a name="l00097"></a>00097 }
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="comment">/* A cleanup wrapper for cp_demangled_name_parse_free.  */</span>
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00102"></a><a class="code" href="cp-support_8c.html#a5d0ff64e013b34fb41d4ea9823604933">00102</a> <a class="code" href="cp-support_8c.html#a5d0ff64e013b34fb41d4ea9823604933">do_demangled_name_parse_free_cleanup</a> (<span class="keywordtype">void</span> *data)
<a name="l00103"></a>00103 {
<a name="l00104"></a>00104   <span class="keyword">struct </span><a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *<a class="code" href="structdemangle__parse__info.html#a5fb8c7e5dccffb6e98ac9658ce0dc330">info</a> = (<span class="keyword">struct </span><a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *) data;
<a name="l00105"></a>00105 
<a name="l00106"></a>00106   <a class="code" href="cp-support_8h.html#ace2dc64c57d30cdb4af45ed66ad18700">cp_demangled_name_parse_free</a> (info);
<a name="l00107"></a>00107 }
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="comment">/* Create a cleanup for C++ name parsing.  */</span>
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *
<a name="l00112"></a><a class="code" href="cp-support_8h.html#a38fc4e0f4a3cac657adcc89d2ca0e6df">00112</a> <a class="code" href="cp-support_8c.html#a20eb54bcb337663cdc39eb0ed8810845">make_cleanup_cp_demangled_name_parse_free</a> (<span class="keyword">struct</span> <a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *info)
<a name="l00113"></a>00113 {
<a name="l00114"></a>00114   <span class="keywordflow">return</span> <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cp-support_8c.html#a5d0ff64e013b34fb41d4ea9823604933">do_demangled_name_parse_free_cleanup</a>, info);
<a name="l00115"></a>00115 }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 <span class="comment">/* Return 1 if STRING is clearly already in canonical form.  This</span>
<a name="l00118"></a>00118 <span class="comment">   function is conservative; things which it does not recognize are</span>
<a name="l00119"></a>00119 <span class="comment">   assumed to be non-canonical, and the parser will sort them out</span>
<a name="l00120"></a>00120 <span class="comment">   afterwards.  This speeds up the critical path for alphanumeric</span>
<a name="l00121"></a>00121 <span class="comment">   identifiers.  */</span>
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00124"></a><a class="code" href="cp-support_8c.html#a33726fba864495f299baa2155db46d6b">00124</a> <a class="code" href="cp-support_8c.html#a33726fba864495f299baa2155db46d6b">cp_already_canonical</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>)
<a name="l00125"></a>00125 {
<a name="l00126"></a>00126   <span class="comment">/* Identifier start character [a-zA-Z_].  */</span>
<a name="l00127"></a>00127   <span class="keywordflow">if</span> (!ISIDST (<span class="keywordtype">string</span>[0]))
<a name="l00128"></a>00128     <span class="keywordflow">return</span> 0;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   <span class="comment">/* These are the only two identifiers which canonicalize to other</span>
<a name="l00131"></a>00131 <span class="comment">     than themselves or an error: unsigned -&gt; unsigned int and</span>
<a name="l00132"></a>00132 <span class="comment">     signed -&gt; int.  */</span>
<a name="l00133"></a>00133   <span class="keywordflow">if</span> (<span class="keywordtype">string</span>[0] == <span class="charliteral">&#39;u&#39;</span> &amp;&amp; strcmp (&amp;<span class="keywordtype">string</span>[1], <span class="stringliteral">&quot;nsigned&quot;</span>) == 0)
<a name="l00134"></a>00134     <span class="keywordflow">return</span> 0;
<a name="l00135"></a>00135   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keywordtype">string</span>[0] == <span class="charliteral">&#39;s&#39;</span> &amp;&amp; strcmp (&amp;<span class="keywordtype">string</span>[1], <span class="stringliteral">&quot;igned&quot;</span>) == 0)
<a name="l00136"></a>00136     <span class="keywordflow">return</span> 0;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138   <span class="comment">/* Identifier character [a-zA-Z0-9_].  */</span>
<a name="l00139"></a>00139   <span class="keywordflow">while</span> (ISIDNUM (<span class="keywordtype">string</span>[1]))
<a name="l00140"></a>00140     <span class="keywordtype">string</span>++;
<a name="l00141"></a>00141 
<a name="l00142"></a>00142   <span class="keywordflow">if</span> (<span class="keywordtype">string</span>[1] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l00143"></a>00143     <span class="keywordflow">return</span> 1;
<a name="l00144"></a>00144   <span class="keywordflow">else</span>
<a name="l00145"></a>00145     <span class="keywordflow">return</span> 0;
<a name="l00146"></a>00146 }
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 <span class="comment">/* Inspect the given RET_COMP for its type.  If it is a typedef,</span>
<a name="l00149"></a>00149 <span class="comment">   replace the node with the typedef&#39;s tree.</span>
<a name="l00150"></a>00150 <span class="comment"></span>
<a name="l00151"></a>00151 <span class="comment">   Returns 1 if any typedef substitutions were made, 0 otherwise.  */</span>
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00154"></a><a class="code" href="cp-support_8c.html#a3f336ace1dead101ebecad8714e44410">00154</a> <a class="code" href="cp-support_8c.html#a3f336ace1dead101ebecad8714e44410">inspect_type</a> (<span class="keyword">struct</span> <a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *info,
<a name="l00155"></a>00155               <span class="keyword">struct</span> demangle_component *ret_comp,
<a name="l00156"></a>00156               <a class="code" href="cp-support_8h.html#adff53f004d48f7abf0932da77f6c0258">canonicalization_ftype</a> *finder,
<a name="l00157"></a>00157               <span class="keywordtype">void</span> *data)
<a name="l00158"></a>00158 {
<a name="l00159"></a>00159   <span class="keywordtype">int</span> i;
<a name="l00160"></a>00160   <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l00161"></a>00161   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l00162"></a>00162   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> except;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164   <span class="comment">/* Copy the symbol&#39;s name from RET_COMP and look it up</span>
<a name="l00165"></a>00165 <span class="comment">     in the symbol table.  */</span>
<a name="l00166"></a>00166   name = (<span class="keywordtype">char</span> *) alloca (ret_comp-&gt;u.s_name.len + 1);
<a name="l00167"></a>00167   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (name, ret_comp-&gt;u.s_name.s, ret_comp-&gt;u.s_name.len);
<a name="l00168"></a>00168   name[ret_comp-&gt;u.s_name.len] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00169"></a>00169 
<a name="l00170"></a>00170   <span class="comment">/* Ignore any typedefs that should not be substituted.  */</span>
<a name="l00171"></a>00171   <span class="keywordflow">for</span> (i = 0; i &lt; ARRAY_SIZE (<a class="code" href="cp-support_8c.html#a643441484094765ff99cfec329c74126">ignore_typedefs</a>); ++i)
<a name="l00172"></a>00172     {
<a name="l00173"></a>00173       <span class="keywordflow">if</span> (strcmp (name, <a class="code" href="cp-support_8c.html#a643441484094765ff99cfec329c74126">ignore_typedefs</a>[i]) == 0)
<a name="l00174"></a>00174         <span class="keywordflow">return</span> 0;
<a name="l00175"></a>00175     }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177   sym = NULL;
<a name="l00178"></a>00178   <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6ab50fde886a7de8c013bf2bd4e7c073a4">RETURN_MASK_ALL</a>)
<a name="l00179"></a>00179   {
<a name="l00180"></a>00180     sym = <a class="code" href="symtab_8c.html#a8a5c3f803198aed047a55c0e4f61b315">lookup_symbol</a> (name, 0, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, 0);
<a name="l00181"></a>00181   }
<a name="l00182"></a>00182 
<a name="l00183"></a>00183   <span class="keywordflow">if</span> (except.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &gt;= 0 &amp;&amp; sym != NULL)
<a name="l00184"></a>00184     {
<a name="l00185"></a>00185       <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *otype = <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187       <span class="keywordflow">if</span> (finder != NULL)
<a name="l00188"></a>00188         {
<a name="l00189"></a>00189           <span class="keyword">const</span> <span class="keywordtype">char</span> *new_name = (*finder) (otype, data);
<a name="l00190"></a>00190 
<a name="l00191"></a>00191           <span class="keywordflow">if</span> (new_name != NULL)
<a name="l00192"></a>00192             {
<a name="l00193"></a>00193               ret_comp-&gt;u.s_name.s = new_name;
<a name="l00194"></a>00194               ret_comp-&gt;u.s_name.len = strlen (new_name);
<a name="l00195"></a>00195               <span class="keywordflow">return</span> 1;
<a name="l00196"></a>00196             }
<a name="l00197"></a>00197 
<a name="l00198"></a>00198           <span class="keywordflow">return</span> 0;
<a name="l00199"></a>00199         }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201       <span class="comment">/* If the type is a typedef, replace it.  */</span>
<a name="l00202"></a>00202       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (otype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>)
<a name="l00203"></a>00203         {
<a name="l00204"></a>00204           <span class="keywordtype">long</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l00205"></a>00205           <span class="keywordtype">int</span> is_anon;
<a name="l00206"></a>00206           <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l00207"></a>00207           <span class="keyword">struct </span><a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *i;
<a name="l00208"></a>00208           <span class="keyword">struct </span><a class="code" href="structui__file.html">ui_file</a> *buf;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210           <span class="comment">/* Get the real type of the typedef.  */</span>
<a name="l00211"></a>00211           type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (otype);
<a name="l00212"></a>00212 
<a name="l00213"></a>00213           is_anon = (<a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) == NULL
<a name="l00214"></a>00214                      &amp;&amp; (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>
<a name="l00215"></a>00215                          || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l00216"></a>00216                          || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>));
<a name="l00217"></a>00217           <span class="keywordflow">if</span> (is_anon)
<a name="l00218"></a>00218             {
<a name="l00219"></a>00219               <span class="keyword">struct </span>type *last = otype;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221               <span class="comment">/* Find the last typedef for the type.  */</span>
<a name="l00222"></a>00222               <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (last) != NULL
<a name="l00223"></a>00223                      &amp;&amp; (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (last))
<a name="l00224"></a>00224                          == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>))
<a name="l00225"></a>00225                 last = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (last);
<a name="l00226"></a>00226 
<a name="l00227"></a>00227               <span class="comment">/* If there is only one typedef for this anonymous type,</span>
<a name="l00228"></a>00228 <span class="comment">                 do not substitute it.  */</span>
<a name="l00229"></a>00229               <span class="keywordflow">if</span> (type == otype)
<a name="l00230"></a>00230                 <span class="keywordflow">return</span> 0;
<a name="l00231"></a>00231               <span class="keywordflow">else</span>
<a name="l00232"></a>00232                 <span class="comment">/* Use the last typedef seen as the type for this</span>
<a name="l00233"></a>00233 <span class="comment">                   anonymous type.  */</span>
<a name="l00234"></a>00234                 type = last;
<a name="l00235"></a>00235             }
<a name="l00236"></a>00236 
<a name="l00237"></a>00237           buf = <a class="code" href="ui-file_8c.html#a340771735f105582d314e191a399a45c">mem_fileopen</a> ();
<a name="l00238"></a>00238           <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l00239"></a>00239           {
<a name="l00240"></a>00240             <a class="code" href="typeprint_8c.html#ad50c90b55385094557cceaa1ea985e47">type_print</a> (type, <span class="stringliteral">&quot;&quot;</span>, buf, -1);
<a name="l00241"></a>00241           }
<a name="l00242"></a>00242 
<a name="l00243"></a>00243           <span class="comment">/* If type_print threw an exception, there is little point</span>
<a name="l00244"></a>00244 <span class="comment">             in continuing, so just bow out gracefully.  */</span>
<a name="l00245"></a>00245           <span class="keywordflow">if</span> (except.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0)
<a name="l00246"></a>00246             {
<a name="l00247"></a>00247               <a class="code" href="ui-file_8c.html#a17fda20af14c0187cbda770d4eb2777b">ui_file_delete</a> (buf);
<a name="l00248"></a>00248               <span class="keywordflow">return</span> 0;
<a name="l00249"></a>00249             }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251           name = <a class="code" href="ui-file_8c.html#a541c31fdc6f196280a6a1447090b8488">ui_file_obsavestring</a> (buf, &amp;info-&gt;<a class="code" href="structdemangle__parse__info.html#a1708e9579c50b043b93700358383715d">obstack</a>, &amp;len);
<a name="l00252"></a>00252           <a class="code" href="ui-file_8c.html#a17fda20af14c0187cbda770d4eb2777b">ui_file_delete</a> (buf);
<a name="l00253"></a>00253 
<a name="l00254"></a>00254           <span class="comment">/* Turn the result into a new tree.  Note that this</span>
<a name="l00255"></a>00255 <span class="comment">             tree will contain pointers into NAME, so NAME cannot</span>
<a name="l00256"></a>00256 <span class="comment">             be free&#39;d until all typedef conversion is done and</span>
<a name="l00257"></a>00257 <span class="comment">             the final result is converted into a string.  */</span>
<a name="l00258"></a>00258           i = <a class="code" href="cp-support_8h.html#acd1741db1e809ee2eda9add915443492">cp_demangled_name_to_comp</a> (name, NULL);
<a name="l00259"></a>00259           <span class="keywordflow">if</span> (i != NULL)
<a name="l00260"></a>00260             {
<a name="l00261"></a>00261               <span class="comment">/* Merge the two trees.  */</span>
<a name="l00262"></a>00262               <a class="code" href="cp-support_8h.html#ae6f616ba936600cc03413aef4cc4b5e4">cp_merge_demangle_parse_infos</a> (info, ret_comp, i);
<a name="l00263"></a>00263 
<a name="l00264"></a>00264               <span class="comment">/* Replace any newly introduced typedefs -- but not</span>
<a name="l00265"></a>00265 <span class="comment">                 if the type is anonymous (that would lead to infinite</span>
<a name="l00266"></a>00266 <span class="comment">                 looping).  */</span>
<a name="l00267"></a>00267               <span class="keywordflow">if</span> (!is_anon)
<a name="l00268"></a>00268                 <a class="code" href="cp-support_8c.html#a895f49490c31653166566bb2b590be5f">replace_typedefs</a> (info, ret_comp, finder, data);
<a name="l00269"></a>00269             }
<a name="l00270"></a>00270           <span class="keywordflow">else</span>
<a name="l00271"></a>00271             {
<a name="l00272"></a>00272               <span class="comment">/* This shouldn&#39;t happen unless the type printer has</span>
<a name="l00273"></a>00273 <span class="comment">                 output something that the name parser cannot grok.</span>
<a name="l00274"></a>00274 <span class="comment">                 Nonetheless, an ounce of prevention...</span>
<a name="l00275"></a>00275 <span class="comment"></span>
<a name="l00276"></a>00276 <span class="comment">                 Canonicalize the name again, and store it in the</span>
<a name="l00277"></a>00277 <span class="comment">                 current node (RET_COMP).  */</span>
<a name="l00278"></a>00278               <span class="keywordtype">char</span> *canon = <a class="code" href="cp-support_8c.html#aaf9c874ab77ecdf8d9a4ceb0c4a8588f">cp_canonicalize_string_no_typedefs</a> (name);
<a name="l00279"></a>00279 
<a name="l00280"></a>00280               <span class="keywordflow">if</span> (canon != NULL)
<a name="l00281"></a>00281                 {
<a name="l00282"></a>00282                   <span class="comment">/* Copy the canonicalization into the obstack and</span>
<a name="l00283"></a>00283 <span class="comment">                     free CANON.  */</span>
<a name="l00284"></a>00284                   name = <a class="code" href="cp-support_8c.html#a17927f61037567ec76811adc280ef678">copy_string_to_obstack</a> (&amp;info-&gt;<a class="code" href="structdemangle__parse__info.html#a1708e9579c50b043b93700358383715d">obstack</a>, canon, &amp;len);
<a name="l00285"></a>00285                   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (canon);
<a name="l00286"></a>00286                 }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288               ret_comp-&gt;u.s_name.s = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l00289"></a>00289               ret_comp-&gt;u.s_name.len = <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l00290"></a>00290             }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292           <span class="keywordflow">return</span> 1;
<a name="l00293"></a>00293         }
<a name="l00294"></a>00294     }
<a name="l00295"></a>00295 
<a name="l00296"></a>00296   <span class="keywordflow">return</span> 0;
<a name="l00297"></a>00297 }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 <span class="comment">/* Replace any typedefs appearing in the qualified name</span>
<a name="l00300"></a>00300 <span class="comment">   (DEMANGLE_COMPONENT_QUAL_NAME) represented in RET_COMP for the name parse</span>
<a name="l00301"></a>00301 <span class="comment">   given in INFO.  */</span>
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00304"></a><a class="code" href="cp-support_8c.html#acb1194ae2d31c6a519b81c8bf7305868">00304</a> <a class="code" href="cp-support_8c.html#acb1194ae2d31c6a519b81c8bf7305868">replace_typedefs_qualified_name</a> (<span class="keyword">struct</span> <a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *info,
<a name="l00305"></a>00305                                  <span class="keyword">struct</span> demangle_component *ret_comp,
<a name="l00306"></a>00306                                  <a class="code" href="cp-support_8h.html#adff53f004d48f7abf0932da77f6c0258">canonicalization_ftype</a> *finder,
<a name="l00307"></a>00307                                  <span class="keywordtype">void</span> *data)
<a name="l00308"></a>00308 {
<a name="l00309"></a>00309   <span class="keywordtype">long</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l00310"></a>00310   <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l00311"></a>00311   <span class="keyword">struct </span><a class="code" href="structui__file.html">ui_file</a> *buf = <a class="code" href="ui-file_8c.html#a340771735f105582d314e191a399a45c">mem_fileopen</a> ();
<a name="l00312"></a>00312   <span class="keyword">struct </span>demangle_component *comp = ret_comp;
<a name="l00313"></a>00313 
<a name="l00314"></a>00314   <span class="comment">/* Walk each node of the qualified name, reconstructing the name of</span>
<a name="l00315"></a>00315 <span class="comment">     this element.  With every node, check for any typedef substitutions.</span>
<a name="l00316"></a>00316 <span class="comment">     If a substitution has occurred, replace the qualified name node</span>
<a name="l00317"></a>00317 <span class="comment">     with a DEMANGLE_COMPONENT_NAME node representing the new, typedef-</span>
<a name="l00318"></a>00318 <span class="comment">     substituted name.  */</span>
<a name="l00319"></a>00319   <span class="keywordflow">while</span> (comp-&gt;type == DEMANGLE_COMPONENT_QUAL_NAME)
<a name="l00320"></a>00320     {
<a name="l00321"></a>00321       <span class="keywordflow">if</span> (<a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (comp)-&gt;<a class="code" href="structtype.html">type</a> == DEMANGLE_COMPONENT_NAME)
<a name="l00322"></a>00322         {
<a name="l00323"></a>00323           <span class="keyword">struct </span>demangle_component new;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325           <a class="code" href="ui-file_8c.html#ae2919852a87266b0c46608646a49f46f">ui_file_write</a> (buf, <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (comp)-&gt;u.s_name.s,
<a name="l00326"></a>00326                          <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (comp)-&gt;u.s_name.len);
<a name="l00327"></a>00327           name = <a class="code" href="ui-file_8c.html#a541c31fdc6f196280a6a1447090b8488">ui_file_obsavestring</a> (buf, &amp;info-&gt;<a class="code" href="structdemangle__parse__info.html#a1708e9579c50b043b93700358383715d">obstack</a>, &amp;len);
<a name="l00328"></a>00328           <span class="keyword">new</span>.type = DEMANGLE_COMPONENT_NAME;
<a name="l00329"></a>00329           <span class="keyword">new</span>.u.s_name.s = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l00330"></a>00330           <span class="keyword">new</span>.u.s_name.len = <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l00331"></a>00331           <span class="keywordflow">if</span> (<a class="code" href="cp-support_8c.html#a3f336ace1dead101ebecad8714e44410">inspect_type</a> (info, &amp;<span class="keyword">new</span>, finder, data))
<a name="l00332"></a>00332             {
<a name="l00333"></a>00333               <span class="keywordtype">char</span> *n, *s;
<a name="l00334"></a>00334               <span class="keywordtype">long</span> slen;
<a name="l00335"></a>00335 
<a name="l00336"></a>00336               <span class="comment">/* A typedef was substituted in NEW.  Convert it to a</span>
<a name="l00337"></a>00337 <span class="comment">                 string and replace the top DEMANGLE_COMPONENT_QUAL_NAME</span>
<a name="l00338"></a>00338 <span class="comment">                 node.  */</span>
<a name="l00339"></a>00339 
<a name="l00340"></a>00340               <a class="code" href="ui-file_8c.html#a6fb0cfd369b36cf6237439e80cf3d60c">ui_file_rewind</a> (buf);
<a name="l00341"></a>00341               n = <a class="code" href="cp-support_8h.html#acfcf757fc9842cd18eba35eae4185096">cp_comp_to_string</a> (&amp;<span class="keyword">new</span>, 100);
<a name="l00342"></a>00342               <span class="keywordflow">if</span> (n == NULL)
<a name="l00343"></a>00343                 {
<a name="l00344"></a>00344                   <span class="comment">/* If something went astray, abort typedef substitutions.  */</span>
<a name="l00345"></a>00345                   <a class="code" href="ui-file_8c.html#a17fda20af14c0187cbda770d4eb2777b">ui_file_delete</a> (buf);
<a name="l00346"></a>00346                   <span class="keywordflow">return</span>;
<a name="l00347"></a>00347                 }
<a name="l00348"></a>00348 
<a name="l00349"></a>00349               s = <a class="code" href="cp-support_8c.html#a17927f61037567ec76811adc280ef678">copy_string_to_obstack</a> (&amp;info-&gt;<a class="code" href="structdemangle__parse__info.html#a1708e9579c50b043b93700358383715d">obstack</a>, n, &amp;slen);
<a name="l00350"></a>00350               <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (n);
<a name="l00351"></a>00351 
<a name="l00352"></a>00352               <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp)-&gt;type = DEMANGLE_COMPONENT_NAME;
<a name="l00353"></a>00353               <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp)-&gt;u.s_name.s = s;
<a name="l00354"></a>00354               <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp)-&gt;u.s_name.len = slen;
<a name="l00355"></a>00355               <a class="code" href="cp-support_8c.html#a40ba63c4584baeb86422c25e58fac461">d_right</a> (ret_comp) = <a class="code" href="cp-support_8c.html#a40ba63c4584baeb86422c25e58fac461">d_right</a> (comp);
<a name="l00356"></a>00356               comp = ret_comp;
<a name="l00357"></a>00357               <span class="keywordflow">continue</span>;
<a name="l00358"></a>00358             }
<a name="l00359"></a>00359         }
<a name="l00360"></a>00360       <span class="keywordflow">else</span>
<a name="l00361"></a>00361         {
<a name="l00362"></a>00362           <span class="comment">/* The current node is not a name, so simply replace any</span>
<a name="l00363"></a>00363 <span class="comment">             typedefs in it.  Then print it to the stream to continue</span>
<a name="l00364"></a>00364 <span class="comment">             checking for more typedefs in the tree.  */</span>
<a name="l00365"></a>00365           <a class="code" href="cp-support_8c.html#a895f49490c31653166566bb2b590be5f">replace_typedefs</a> (info, <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (comp), finder, data);
<a name="l00366"></a>00366           name = <a class="code" href="cp-support_8h.html#acfcf757fc9842cd18eba35eae4185096">cp_comp_to_string</a> (<a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (comp), 100);
<a name="l00367"></a>00367           <span class="keywordflow">if</span> (name == NULL)
<a name="l00368"></a>00368             {
<a name="l00369"></a>00369               <span class="comment">/* If something went astray, abort typedef substitutions.  */</span>
<a name="l00370"></a>00370               <a class="code" href="ui-file_8c.html#a17fda20af14c0187cbda770d4eb2777b">ui_file_delete</a> (buf);
<a name="l00371"></a>00371               <span class="keywordflow">return</span>;
<a name="l00372"></a>00372             }
<a name="l00373"></a>00373           <a class="code" href="ui-file_8c.html#aae3b905f888b1dcdce586f77b9554153">fputs_unfiltered</a> (name, buf);
<a name="l00374"></a>00374           <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (name);
<a name="l00375"></a>00375         }
<a name="l00376"></a>00376 
<a name="l00377"></a>00377       <a class="code" href="ui-file_8c.html#ae2919852a87266b0c46608646a49f46f">ui_file_write</a> (buf, <span class="stringliteral">&quot;::&quot;</span>, 2);
<a name="l00378"></a>00378       comp = <a class="code" href="cp-support_8c.html#a40ba63c4584baeb86422c25e58fac461">d_right</a> (comp);
<a name="l00379"></a>00379     }
<a name="l00380"></a>00380 
<a name="l00381"></a>00381   <span class="comment">/* If the next component is DEMANGLE_COMPONENT_NAME, save the qualified</span>
<a name="l00382"></a>00382 <span class="comment">     name assembled above and append the name given by COMP.  Then use this</span>
<a name="l00383"></a>00383 <span class="comment">     reassembled name to check for a typedef.  */</span>
<a name="l00384"></a>00384 
<a name="l00385"></a>00385   <span class="keywordflow">if</span> (comp-&gt;type == DEMANGLE_COMPONENT_NAME)
<a name="l00386"></a>00386     {
<a name="l00387"></a>00387       <a class="code" href="ui-file_8c.html#ae2919852a87266b0c46608646a49f46f">ui_file_write</a> (buf, comp-&gt;u.s_name.s, comp-&gt;u.s_name.len);
<a name="l00388"></a>00388       name = <a class="code" href="ui-file_8c.html#a541c31fdc6f196280a6a1447090b8488">ui_file_obsavestring</a> (buf, &amp;info-&gt;<a class="code" href="structdemangle__parse__info.html#a1708e9579c50b043b93700358383715d">obstack</a>, &amp;len);
<a name="l00389"></a>00389 
<a name="l00390"></a>00390       <span class="comment">/* Replace the top (DEMANGLE_COMPONENT_QUAL_NAME) node</span>
<a name="l00391"></a>00391 <span class="comment">         with a DEMANGLE_COMPONENT_NAME node containing the whole</span>
<a name="l00392"></a>00392 <span class="comment">         name.  */</span>
<a name="l00393"></a>00393       ret_comp-&gt;type = DEMANGLE_COMPONENT_NAME;
<a name="l00394"></a>00394       ret_comp-&gt;u.s_name.s = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l00395"></a>00395       ret_comp-&gt;u.s_name.len = <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l00396"></a>00396       <a class="code" href="cp-support_8c.html#a3f336ace1dead101ebecad8714e44410">inspect_type</a> (info, ret_comp, finder, data);
<a name="l00397"></a>00397     }
<a name="l00398"></a>00398   <span class="keywordflow">else</span>
<a name="l00399"></a>00399     <a class="code" href="cp-support_8c.html#a895f49490c31653166566bb2b590be5f">replace_typedefs</a> (info, comp, finder, data);
<a name="l00400"></a>00400 
<a name="l00401"></a>00401   <a class="code" href="ui-file_8c.html#a17fda20af14c0187cbda770d4eb2777b">ui_file_delete</a> (buf);
<a name="l00402"></a>00402 }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <span class="comment">/* A function to check const and volatile qualifiers for argument types.</span>
<a name="l00406"></a>00406 <span class="comment"></span>
<a name="l00407"></a>00407 <span class="comment">   &quot;Parameter declarations that differ only in the presence</span>
<a name="l00408"></a>00408 <span class="comment">   or absence of `const&#39; and/or `volatile&#39; are equivalent.&quot;</span>
<a name="l00409"></a>00409 <span class="comment">   C++ Standard N3290, clause 13.1.3 #4.  */</span>
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00412"></a><a class="code" href="cp-support_8c.html#ad0a9bc28a44eadf49ab44a837568f816">00412</a> <a class="code" href="cp-support_8c.html#ad0a9bc28a44eadf49ab44a837568f816">check_cv_qualifiers</a> (<span class="keyword">struct</span> demangle_component *ret_comp)
<a name="l00413"></a>00413 {
<a name="l00414"></a>00414   <span class="keywordflow">while</span> (<a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp) != NULL
<a name="l00415"></a>00415          &amp;&amp; (<a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp)-&gt;<a class="code" href="structtype.html">type</a> == DEMANGLE_COMPONENT_CONST
<a name="l00416"></a>00416              || <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp)-&gt;<a class="code" href="structtype.html">type</a> == DEMANGLE_COMPONENT_VOLATILE))
<a name="l00417"></a>00417     {
<a name="l00418"></a>00418       <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp) = <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (<a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp));
<a name="l00419"></a>00419     }
<a name="l00420"></a>00420 }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 <span class="comment">/* Walk the parse tree given by RET_COMP, replacing any typedefs with</span>
<a name="l00423"></a>00423 <span class="comment">   their basic types.  */</span>
<a name="l00424"></a>00424 
<a name="l00425"></a>00425 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00426"></a><a class="code" href="cp-support_8c.html#a895f49490c31653166566bb2b590be5f">00426</a> <a class="code" href="cp-support_8c.html#a895f49490c31653166566bb2b590be5f">replace_typedefs</a> (<span class="keyword">struct</span> <a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *info,
<a name="l00427"></a>00427                   <span class="keyword">struct</span> demangle_component *ret_comp,
<a name="l00428"></a>00428                   <a class="code" href="cp-support_8h.html#adff53f004d48f7abf0932da77f6c0258">canonicalization_ftype</a> *finder,
<a name="l00429"></a>00429                   <span class="keywordtype">void</span> *data)
<a name="l00430"></a>00430 {
<a name="l00431"></a>00431   <span class="keywordflow">if</span> (ret_comp)
<a name="l00432"></a>00432     {
<a name="l00433"></a>00433       <span class="keywordflow">if</span> (finder != NULL
<a name="l00434"></a>00434           &amp;&amp; (ret_comp-&gt;type == DEMANGLE_COMPONENT_NAME
<a name="l00435"></a>00435               || ret_comp-&gt;type == DEMANGLE_COMPONENT_QUAL_NAME
<a name="l00436"></a>00436               || ret_comp-&gt;type == DEMANGLE_COMPONENT_TEMPLATE
<a name="l00437"></a>00437               || ret_comp-&gt;type == DEMANGLE_COMPONENT_BUILTIN_TYPE))
<a name="l00438"></a>00438         {
<a name="l00439"></a>00439           <span class="keywordtype">char</span> *local_name = <a class="code" href="cp-support_8h.html#acfcf757fc9842cd18eba35eae4185096">cp_comp_to_string</a> (ret_comp, 10);
<a name="l00440"></a>00440 
<a name="l00441"></a>00441           <span class="keywordflow">if</span> (local_name != NULL)
<a name="l00442"></a>00442             {
<a name="l00443"></a>00443               <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l00444"></a>00444               <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> except;
<a name="l00445"></a>00445 
<a name="l00446"></a>00446               sym = NULL;
<a name="l00447"></a>00447               <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6ab50fde886a7de8c013bf2bd4e7c073a4">RETURN_MASK_ALL</a>)
<a name="l00448"></a>00448                 {
<a name="l00449"></a>00449                   sym = <a class="code" href="symtab_8c.html#a8a5c3f803198aed047a55c0e4f61b315">lookup_symbol</a> (local_name, 0, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, 0);
<a name="l00450"></a>00450                 }
<a name="l00451"></a>00451               <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (local_name);
<a name="l00452"></a>00452 
<a name="l00453"></a>00453               <span class="keywordflow">if</span> (except.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &gt;= 0 &amp;&amp; sym != NULL)
<a name="l00454"></a>00454                 {
<a name="l00455"></a>00455                   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *otype = <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym);
<a name="l00456"></a>00456                   <span class="keyword">const</span> <span class="keywordtype">char</span> *new_name = (*finder) (otype, data);
<a name="l00457"></a>00457 
<a name="l00458"></a>00458                   <span class="keywordflow">if</span> (new_name != NULL)
<a name="l00459"></a>00459                     {
<a name="l00460"></a>00460                       ret_comp-&gt;type = DEMANGLE_COMPONENT_NAME;
<a name="l00461"></a>00461                       ret_comp-&gt;u.s_name.s = new_name;
<a name="l00462"></a>00462                       ret_comp-&gt;u.s_name.len = strlen (new_name);
<a name="l00463"></a>00463                       <span class="keywordflow">return</span>;
<a name="l00464"></a>00464                     }
<a name="l00465"></a>00465                 }
<a name="l00466"></a>00466             }
<a name="l00467"></a>00467         }
<a name="l00468"></a>00468 
<a name="l00469"></a>00469       <span class="keywordflow">switch</span> (ret_comp-&gt;type)
<a name="l00470"></a>00470         {
<a name="l00471"></a>00471         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_ARGLIST:
<a name="l00472"></a>00472           <a class="code" href="cp-support_8c.html#ad0a9bc28a44eadf49ab44a837568f816">check_cv_qualifiers</a> (ret_comp);
<a name="l00473"></a>00473           <span class="comment">/* Fall through */</span>
<a name="l00474"></a>00474 
<a name="l00475"></a>00475         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_FUNCTION_TYPE:
<a name="l00476"></a>00476         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_TEMPLATE:
<a name="l00477"></a>00477         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
<a name="l00478"></a>00478         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_TYPED_NAME:
<a name="l00479"></a>00479           <a class="code" href="cp-support_8c.html#a895f49490c31653166566bb2b590be5f">replace_typedefs</a> (info, <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp), finder, data);
<a name="l00480"></a>00480           <a class="code" href="cp-support_8c.html#a895f49490c31653166566bb2b590be5f">replace_typedefs</a> (info, <a class="code" href="cp-support_8c.html#a40ba63c4584baeb86422c25e58fac461">d_right</a> (ret_comp), finder, data);
<a name="l00481"></a>00481           <span class="keywordflow">break</span>;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_NAME:
<a name="l00484"></a>00484           <a class="code" href="cp-support_8c.html#a3f336ace1dead101ebecad8714e44410">inspect_type</a> (info, ret_comp, finder, data);
<a name="l00485"></a>00485           <span class="keywordflow">break</span>;
<a name="l00486"></a>00486 
<a name="l00487"></a>00487         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_QUAL_NAME:
<a name="l00488"></a>00488           <a class="code" href="cp-support_8c.html#acb1194ae2d31c6a519b81c8bf7305868">replace_typedefs_qualified_name</a> (info, ret_comp, finder, data);
<a name="l00489"></a>00489           <span class="keywordflow">break</span>;
<a name="l00490"></a>00490 
<a name="l00491"></a>00491         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_LOCAL_NAME:
<a name="l00492"></a>00492         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_CTOR:
<a name="l00493"></a>00493         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_ARRAY_TYPE:
<a name="l00494"></a>00494         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_PTRMEM_TYPE:
<a name="l00495"></a>00495           <a class="code" href="cp-support_8c.html#a895f49490c31653166566bb2b590be5f">replace_typedefs</a> (info, <a class="code" href="cp-support_8c.html#a40ba63c4584baeb86422c25e58fac461">d_right</a> (ret_comp), finder, data);
<a name="l00496"></a>00496           <span class="keywordflow">break</span>;
<a name="l00497"></a>00497 
<a name="l00498"></a>00498         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_CONST:
<a name="l00499"></a>00499         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_RESTRICT:
<a name="l00500"></a>00500         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_VOLATILE:
<a name="l00501"></a>00501         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_VOLATILE_THIS:
<a name="l00502"></a>00502         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_CONST_THIS:
<a name="l00503"></a>00503         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_RESTRICT_THIS:
<a name="l00504"></a>00504         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_POINTER:
<a name="l00505"></a>00505         <span class="keywordflow">case</span> DEMANGLE_COMPONENT_REFERENCE:
<a name="l00506"></a>00506           <a class="code" href="cp-support_8c.html#a895f49490c31653166566bb2b590be5f">replace_typedefs</a> (info, <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp), finder, data);
<a name="l00507"></a>00507           <span class="keywordflow">break</span>;
<a name="l00508"></a>00508 
<a name="l00509"></a>00509         <span class="keywordflow">default</span>:
<a name="l00510"></a>00510           <span class="keywordflow">break</span>;
<a name="l00511"></a>00511         }
<a name="l00512"></a>00512     }
<a name="l00513"></a>00513 }
<a name="l00514"></a>00514 
<a name="l00515"></a>00515 <span class="comment">/* Parse STRING and convert it to canonical form, resolving any typedefs.</span>
<a name="l00516"></a>00516 <span class="comment">   If parsing fails, or if STRING is already canonical, return NULL.</span>
<a name="l00517"></a>00517 <span class="comment">   Otherwise return the canonical form.  The return value is allocated via</span>
<a name="l00518"></a>00518 <span class="comment">   xmalloc.  If FINDER is not NULL, then type components are passed to</span>
<a name="l00519"></a>00519 <span class="comment">   FINDER to be looked up.  DATA is passed verbatim to FINDER.  */</span>
<a name="l00520"></a>00520 
<a name="l00521"></a>00521 <span class="keywordtype">char</span> *
<a name="l00522"></a><a class="code" href="cp-support_8h.html#a2f821f7cdf2e1c54a878d51f19b4337f">00522</a> <a class="code" href="cp-support_8c.html#a2f821f7cdf2e1c54a878d51f19b4337f">cp_canonicalize_string_full</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>,
<a name="l00523"></a>00523                              <a class="code" href="cp-support_8h.html#adff53f004d48f7abf0932da77f6c0258">canonicalization_ftype</a> *finder,
<a name="l00524"></a>00524                              <span class="keywordtype">void</span> *data)
<a name="l00525"></a>00525 {
<a name="l00526"></a>00526   <span class="keywordtype">char</span> *ret;
<a name="l00527"></a>00527   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> estimated_len;
<a name="l00528"></a>00528   <span class="keyword">struct </span><a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *<a class="code" href="structdemangle__parse__info.html#a5fb8c7e5dccffb6e98ac9658ce0dc330">info</a>;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530   ret = NULL;
<a name="l00531"></a>00531   estimated_len = strlen (<span class="keywordtype">string</span>) * 2;
<a name="l00532"></a>00532   info = <a class="code" href="cp-support_8h.html#acd1741db1e809ee2eda9add915443492">cp_demangled_name_to_comp</a> (<span class="keywordtype">string</span>, NULL);
<a name="l00533"></a>00533   <span class="keywordflow">if</span> (info != NULL)
<a name="l00534"></a>00534     {
<a name="l00535"></a>00535       <span class="comment">/* Replace all the typedefs in the tree.  */</span>
<a name="l00536"></a>00536       <a class="code" href="cp-support_8c.html#a895f49490c31653166566bb2b590be5f">replace_typedefs</a> (info, info-&gt;<a class="code" href="structdemangle__parse__info.html#a5b5cc3882be46fff69af215b64e1e0bb">tree</a>, finder, data);
<a name="l00537"></a>00537 
<a name="l00538"></a>00538       <span class="comment">/* Convert the tree back into a string.  */</span>
<a name="l00539"></a>00539       ret = <a class="code" href="cp-support_8h.html#acfcf757fc9842cd18eba35eae4185096">cp_comp_to_string</a> (info-&gt;<a class="code" href="structdemangle__parse__info.html#a5b5cc3882be46fff69af215b64e1e0bb">tree</a>, estimated_len);
<a name="l00540"></a>00540       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (ret != NULL);
<a name="l00541"></a>00541 
<a name="l00542"></a>00542       <span class="comment">/* Free the parse information.  */</span>
<a name="l00543"></a>00543       <a class="code" href="cp-support_8h.html#ace2dc64c57d30cdb4af45ed66ad18700">cp_demangled_name_parse_free</a> (info);
<a name="l00544"></a>00544 
<a name="l00545"></a>00545       <span class="comment">/* Finally, compare the original string with the computed</span>
<a name="l00546"></a>00546 <span class="comment">         name, returning NULL if they are the same.  */</span>
<a name="l00547"></a>00547       <span class="keywordflow">if</span> (strcmp (<span class="keywordtype">string</span>, ret) == 0)
<a name="l00548"></a>00548         {
<a name="l00549"></a>00549           <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (ret);
<a name="l00550"></a>00550           <span class="keywordflow">return</span> NULL;
<a name="l00551"></a>00551         }
<a name="l00552"></a>00552     }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554   <span class="keywordflow">return</span> ret;
<a name="l00555"></a>00555 }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557 <span class="comment">/* Like cp_canonicalize_string_full, but always passes NULL for</span>
<a name="l00558"></a>00558 <span class="comment">   FINDER.  */</span>
<a name="l00559"></a>00559 
<a name="l00560"></a>00560 <span class="keywordtype">char</span> *
<a name="l00561"></a><a class="code" href="cp-support_8h.html#aaf9c874ab77ecdf8d9a4ceb0c4a8588f">00561</a> <a class="code" href="cp-support_8c.html#aaf9c874ab77ecdf8d9a4ceb0c4a8588f">cp_canonicalize_string_no_typedefs</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>)
<a name="l00562"></a>00562 {
<a name="l00563"></a>00563   <span class="keywordflow">return</span> <a class="code" href="cp-support_8c.html#a2f821f7cdf2e1c54a878d51f19b4337f">cp_canonicalize_string_full</a> (<span class="keywordtype">string</span>, NULL, NULL);
<a name="l00564"></a>00564 }
<a name="l00565"></a>00565 
<a name="l00566"></a>00566 <span class="comment">/* Parse STRING and convert it to canonical form.  If parsing fails,</span>
<a name="l00567"></a>00567 <span class="comment">   or if STRING is already canonical, return NULL.  Otherwise return</span>
<a name="l00568"></a>00568 <span class="comment">   the canonical form.  The return value is allocated via xmalloc.  */</span>
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 <span class="keywordtype">char</span> *
<a name="l00571"></a><a class="code" href="cp-support_8h.html#a8fdbec9f6e31d857cb084d73ec5a62f8">00571</a> <a class="code" href="cp-support_8c.html#a8fdbec9f6e31d857cb084d73ec5a62f8">cp_canonicalize_string</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>)
<a name="l00572"></a>00572 {
<a name="l00573"></a>00573   <span class="keyword">struct </span><a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *<a class="code" href="structdemangle__parse__info.html#a5fb8c7e5dccffb6e98ac9658ce0dc330">info</a>;
<a name="l00574"></a>00574   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> estimated_len;
<a name="l00575"></a>00575   <span class="keywordtype">char</span> *ret;
<a name="l00576"></a>00576 
<a name="l00577"></a>00577   <span class="keywordflow">if</span> (<a class="code" href="cp-support_8c.html#a33726fba864495f299baa2155db46d6b">cp_already_canonical</a> (<span class="keywordtype">string</span>))
<a name="l00578"></a>00578     <span class="keywordflow">return</span> NULL;
<a name="l00579"></a>00579 
<a name="l00580"></a>00580   info = <a class="code" href="cp-support_8h.html#acd1741db1e809ee2eda9add915443492">cp_demangled_name_to_comp</a> (<span class="keywordtype">string</span>, NULL);
<a name="l00581"></a>00581   <span class="keywordflow">if</span> (info == NULL)
<a name="l00582"></a>00582     <span class="keywordflow">return</span> NULL;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584   estimated_len = strlen (<span class="keywordtype">string</span>) * 2;
<a name="l00585"></a>00585   ret = <a class="code" href="cp-support_8h.html#acfcf757fc9842cd18eba35eae4185096">cp_comp_to_string</a> (info-&gt;<a class="code" href="structdemangle__parse__info.html#a5b5cc3882be46fff69af215b64e1e0bb">tree</a>, estimated_len);
<a name="l00586"></a>00586   <a class="code" href="cp-support_8h.html#ace2dc64c57d30cdb4af45ed66ad18700">cp_demangled_name_parse_free</a> (info);
<a name="l00587"></a>00587 
<a name="l00588"></a>00588   <span class="keywordflow">if</span> (ret == NULL)
<a name="l00589"></a>00589     {
<a name="l00590"></a>00590       <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;internal error: string \&quot;%s\&quot; failed to be canonicalized&quot;</span>),
<a name="l00591"></a>00591                <span class="keywordtype">string</span>);
<a name="l00592"></a>00592       <span class="keywordflow">return</span> NULL;
<a name="l00593"></a>00593     }
<a name="l00594"></a>00594 
<a name="l00595"></a>00595   <span class="keywordflow">if</span> (strcmp (<span class="keywordtype">string</span>, ret) == 0)
<a name="l00596"></a>00596     {
<a name="l00597"></a>00597       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (ret);
<a name="l00598"></a>00598       <span class="keywordflow">return</span> NULL;
<a name="l00599"></a>00599     }
<a name="l00600"></a>00600 
<a name="l00601"></a>00601   <span class="keywordflow">return</span> ret;
<a name="l00602"></a>00602 }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604 <span class="comment">/* Convert a mangled name to a demangle_component tree.  *MEMORY is</span>
<a name="l00605"></a>00605 <span class="comment">   set to the block of used memory that should be freed when finished</span>
<a name="l00606"></a>00606 <span class="comment">   with the tree.  DEMANGLED_P is set to the char * that should be</span>
<a name="l00607"></a>00607 <span class="comment">   freed when finished with the tree, or NULL if none was needed.</span>
<a name="l00608"></a>00608 <span class="comment">   OPTIONS will be passed to the demangler.  */</span>
<a name="l00609"></a>00609 
<a name="l00610"></a>00610 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *
<a name="l00611"></a><a class="code" href="cp-support_8c.html#a69bc78926309f050cc8f9ebfee2aa796">00611</a> <a class="code" href="cp-support_8c.html#a69bc78926309f050cc8f9ebfee2aa796">mangled_name_to_comp</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *mangled_name, <span class="keywordtype">int</span> options,
<a name="l00612"></a>00612                       <span class="keywordtype">void</span> **memory, <span class="keywordtype">char</span> **demangled_p)
<a name="l00613"></a>00613 {
<a name="l00614"></a>00614   <span class="keywordtype">char</span> *demangled_name;
<a name="l00615"></a>00615   <span class="keyword">struct </span><a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *<a class="code" href="structdemangle__parse__info.html#a5fb8c7e5dccffb6e98ac9658ce0dc330">info</a>;
<a name="l00616"></a>00616 
<a name="l00617"></a>00617   <span class="comment">/* If it looks like a v3 mangled name, then try to go directly</span>
<a name="l00618"></a>00618 <span class="comment">     to trees.  */</span>
<a name="l00619"></a>00619   <span class="keywordflow">if</span> (mangled_name[0] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; mangled_name[1] == <span class="charliteral">&#39;Z&#39;</span>)
<a name="l00620"></a>00620     {
<a name="l00621"></a>00621       <span class="keyword">struct </span>demangle_component *ret;
<a name="l00622"></a>00622 
<a name="l00623"></a>00623       ret = cplus_demangle_v3_components (mangled_name,
<a name="l00624"></a>00624                                           options, memory);
<a name="l00625"></a>00625       <span class="keywordflow">if</span> (ret)
<a name="l00626"></a>00626         {
<a name="l00627"></a>00627           info = <a class="code" href="cp-support_8h.html#a28e63278b5352bde7625bd9f0853cce2">cp_new_demangle_parse_info</a> ();
<a name="l00628"></a>00628           info-&gt;<a class="code" href="structdemangle__parse__info.html#a5b5cc3882be46fff69af215b64e1e0bb">tree</a> = ret;
<a name="l00629"></a>00629           *demangled_p = NULL;
<a name="l00630"></a>00630           <span class="keywordflow">return</span> info;
<a name="l00631"></a>00631         }
<a name="l00632"></a>00632     }
<a name="l00633"></a>00633 
<a name="l00634"></a>00634   <span class="comment">/* If it doesn&#39;t, or if that failed, then try to demangle the</span>
<a name="l00635"></a>00635 <span class="comment">     name.  */</span>
<a name="l00636"></a>00636   demangled_name = <a class="code" href="cp-support_8c.html#aa3fac1cb74e2709738e9ab3af7aac6b6">gdb_demangle</a> (mangled_name, options);
<a name="l00637"></a>00637   <span class="keywordflow">if</span> (demangled_name == NULL)
<a name="l00638"></a>00638    <span class="keywordflow">return</span> NULL;
<a name="l00639"></a>00639   
<a name="l00640"></a>00640   <span class="comment">/* If we could demangle the name, parse it to build the component</span>
<a name="l00641"></a>00641 <span class="comment">     tree.  */</span>
<a name="l00642"></a>00642   info = <a class="code" href="cp-support_8h.html#acd1741db1e809ee2eda9add915443492">cp_demangled_name_to_comp</a> (demangled_name, NULL);
<a name="l00643"></a>00643 
<a name="l00644"></a>00644   <span class="keywordflow">if</span> (info == NULL)
<a name="l00645"></a>00645     {
<a name="l00646"></a>00646       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (demangled_name);
<a name="l00647"></a>00647       <span class="keywordflow">return</span> NULL;
<a name="l00648"></a>00648     }
<a name="l00649"></a>00649 
<a name="l00650"></a>00650   *demangled_p = demangled_name;
<a name="l00651"></a>00651   <span class="keywordflow">return</span> info;
<a name="l00652"></a>00652 }
<a name="l00653"></a>00653 
<a name="l00654"></a>00654 <span class="comment">/* Return the name of the class containing method PHYSNAME.  */</span>
<a name="l00655"></a>00655 
<a name="l00656"></a>00656 <span class="keywordtype">char</span> *
<a name="l00657"></a><a class="code" href="cp-support_8h.html#ad75edb57d73043830a000a4d358d1714">00657</a> <a class="code" href="cp-support_8c.html#ad75edb57d73043830a000a4d358d1714">cp_class_name_from_physname</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *physname)
<a name="l00658"></a>00658 {
<a name="l00659"></a>00659   <span class="keywordtype">void</span> *storage = NULL;
<a name="l00660"></a>00660   <span class="keywordtype">char</span> *demangled_name = NULL, *ret;
<a name="l00661"></a>00661   <span class="keyword">struct </span>demangle_component *ret_comp, *prev_comp, *cur_comp;
<a name="l00662"></a>00662   <span class="keyword">struct </span><a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *<a class="code" href="structdemangle__parse__info.html#a5fb8c7e5dccffb6e98ac9658ce0dc330">info</a>;
<a name="l00663"></a>00663   <span class="keywordtype">int</span> done;
<a name="l00664"></a>00664 
<a name="l00665"></a>00665   info = <a class="code" href="cp-support_8c.html#a69bc78926309f050cc8f9ebfee2aa796">mangled_name_to_comp</a> (physname, DMGL_ANSI,
<a name="l00666"></a>00666                                &amp;storage, &amp;demangled_name);
<a name="l00667"></a>00667   <span class="keywordflow">if</span> (info == NULL)
<a name="l00668"></a>00668     <span class="keywordflow">return</span> NULL;
<a name="l00669"></a>00669 
<a name="l00670"></a>00670   done = 0;
<a name="l00671"></a>00671   ret_comp = info-&gt;<a class="code" href="structdemangle__parse__info.html#a5b5cc3882be46fff69af215b64e1e0bb">tree</a>;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673   <span class="comment">/* First strip off any qualifiers, if we have a function or</span>
<a name="l00674"></a>00674 <span class="comment">     method.  */</span>
<a name="l00675"></a>00675   <span class="keywordflow">while</span> (!done)
<a name="l00676"></a>00676     <span class="keywordflow">switch</span> (ret_comp-&gt;type)
<a name="l00677"></a>00677       {
<a name="l00678"></a>00678       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_CONST:
<a name="l00679"></a>00679       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_RESTRICT:
<a name="l00680"></a>00680       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_VOLATILE:
<a name="l00681"></a>00681       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_CONST_THIS:
<a name="l00682"></a>00682       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_RESTRICT_THIS:
<a name="l00683"></a>00683       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_VOLATILE_THIS:
<a name="l00684"></a>00684       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
<a name="l00685"></a>00685         ret_comp = <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp);
<a name="l00686"></a>00686         <span class="keywordflow">break</span>;
<a name="l00687"></a>00687       <span class="keywordflow">default</span>:
<a name="l00688"></a>00688         done = 1;
<a name="l00689"></a>00689         <span class="keywordflow">break</span>;
<a name="l00690"></a>00690       }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692   <span class="comment">/* If what we have now is a function, discard the argument list.  */</span>
<a name="l00693"></a>00693   <span class="keywordflow">if</span> (ret_comp-&gt;type == DEMANGLE_COMPONENT_TYPED_NAME)
<a name="l00694"></a>00694     ret_comp = <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp);
<a name="l00695"></a>00695 
<a name="l00696"></a>00696   <span class="comment">/* If what we have now is a template, strip off the template</span>
<a name="l00697"></a>00697 <span class="comment">     arguments.  The left subtree may be a qualified name.  */</span>
<a name="l00698"></a>00698   <span class="keywordflow">if</span> (ret_comp-&gt;type == DEMANGLE_COMPONENT_TEMPLATE)
<a name="l00699"></a>00699     ret_comp = <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp);
<a name="l00700"></a>00700 
<a name="l00701"></a>00701   <span class="comment">/* What we have now should be a name, possibly qualified.</span>
<a name="l00702"></a>00702 <span class="comment">     Additional qualifiers could live in the left subtree or the right</span>
<a name="l00703"></a>00703 <span class="comment">     subtree.  Find the last piece.  */</span>
<a name="l00704"></a>00704   done = 0;
<a name="l00705"></a>00705   prev_comp = NULL;
<a name="l00706"></a>00706   cur_comp = ret_comp;
<a name="l00707"></a>00707   <span class="keywordflow">while</span> (!done)
<a name="l00708"></a>00708     <span class="keywordflow">switch</span> (cur_comp-&gt;type)
<a name="l00709"></a>00709       {
<a name="l00710"></a>00710       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_QUAL_NAME:
<a name="l00711"></a>00711       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_LOCAL_NAME:
<a name="l00712"></a>00712         prev_comp = cur_comp;
<a name="l00713"></a>00713         cur_comp = <a class="code" href="cp-support_8c.html#a40ba63c4584baeb86422c25e58fac461">d_right</a> (cur_comp);
<a name="l00714"></a>00714         <span class="keywordflow">break</span>;
<a name="l00715"></a>00715       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_TEMPLATE:
<a name="l00716"></a>00716       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_NAME:
<a name="l00717"></a>00717       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_CTOR:
<a name="l00718"></a>00718       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_DTOR:
<a name="l00719"></a>00719       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_OPERATOR:
<a name="l00720"></a>00720       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
<a name="l00721"></a>00721         done = 1;
<a name="l00722"></a>00722         <span class="keywordflow">break</span>;
<a name="l00723"></a>00723       <span class="keywordflow">default</span>:
<a name="l00724"></a>00724         done = 1;
<a name="l00725"></a>00725         cur_comp = NULL;
<a name="l00726"></a>00726         <span class="keywordflow">break</span>;
<a name="l00727"></a>00727       }
<a name="l00728"></a>00728 
<a name="l00729"></a>00729   ret = NULL;
<a name="l00730"></a>00730   <span class="keywordflow">if</span> (cur_comp != NULL &amp;&amp; prev_comp != NULL)
<a name="l00731"></a>00731     {
<a name="l00732"></a>00732       <span class="comment">/* We want to discard the rightmost child of PREV_COMP.  */</span>
<a name="l00733"></a>00733       *prev_comp = *<a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (prev_comp);
<a name="l00734"></a>00734       <span class="comment">/* The ten is completely arbitrary; we don&#39;t have a good</span>
<a name="l00735"></a>00735 <span class="comment">         estimate.  */</span>
<a name="l00736"></a>00736       ret = <a class="code" href="cp-support_8h.html#acfcf757fc9842cd18eba35eae4185096">cp_comp_to_string</a> (ret_comp, 10);
<a name="l00737"></a>00737     }
<a name="l00738"></a>00738 
<a name="l00739"></a>00739   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (storage);
<a name="l00740"></a>00740   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (demangled_name);
<a name="l00741"></a>00741   <a class="code" href="cp-support_8h.html#ace2dc64c57d30cdb4af45ed66ad18700">cp_demangled_name_parse_free</a> (info);
<a name="l00742"></a>00742   <span class="keywordflow">return</span> ret;
<a name="l00743"></a>00743 }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745 <span class="comment">/* Return the child of COMP which is the basename of a method,</span>
<a name="l00746"></a>00746 <span class="comment">   variable, et cetera.  All scope qualifiers are discarded, but</span>
<a name="l00747"></a>00747 <span class="comment">   template arguments will be included.  The component tree may be</span>
<a name="l00748"></a>00748 <span class="comment">   modified.  */</span>
<a name="l00749"></a>00749 
<a name="l00750"></a>00750 <span class="keyword">static</span> <span class="keyword">struct </span>demangle_component *
<a name="l00751"></a><a class="code" href="cp-support_8c.html#a87310c20e5348d35bb96e54ef5328c50">00751</a> <a class="code" href="cp-support_8c.html#a87310c20e5348d35bb96e54ef5328c50">unqualified_name_from_comp</a> (<span class="keyword">struct</span> demangle_component *comp)
<a name="l00752"></a>00752 {
<a name="l00753"></a>00753   <span class="keyword">struct </span>demangle_component *ret_comp = comp, *last_template;
<a name="l00754"></a>00754   <span class="keywordtype">int</span> done;
<a name="l00755"></a>00755 
<a name="l00756"></a>00756   done = 0;
<a name="l00757"></a>00757   last_template = NULL;
<a name="l00758"></a>00758   <span class="keywordflow">while</span> (!done)
<a name="l00759"></a>00759     <span class="keywordflow">switch</span> (ret_comp-&gt;type)
<a name="l00760"></a>00760       {
<a name="l00761"></a>00761       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_QUAL_NAME:
<a name="l00762"></a>00762       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_LOCAL_NAME:
<a name="l00763"></a>00763         ret_comp = <a class="code" href="cp-support_8c.html#a40ba63c4584baeb86422c25e58fac461">d_right</a> (ret_comp);
<a name="l00764"></a>00764         <span class="keywordflow">break</span>;
<a name="l00765"></a>00765       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_TYPED_NAME:
<a name="l00766"></a>00766         ret_comp = <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp);
<a name="l00767"></a>00767         <span class="keywordflow">break</span>;
<a name="l00768"></a>00768       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_TEMPLATE:
<a name="l00769"></a>00769         <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (last_template == NULL);
<a name="l00770"></a>00770         last_template = ret_comp;
<a name="l00771"></a>00771         ret_comp = <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp);
<a name="l00772"></a>00772         <span class="keywordflow">break</span>;
<a name="l00773"></a>00773       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_CONST:
<a name="l00774"></a>00774       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_RESTRICT:
<a name="l00775"></a>00775       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_VOLATILE:
<a name="l00776"></a>00776       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_CONST_THIS:
<a name="l00777"></a>00777       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_RESTRICT_THIS:
<a name="l00778"></a>00778       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_VOLATILE_THIS:
<a name="l00779"></a>00779       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
<a name="l00780"></a>00780         ret_comp = <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp);
<a name="l00781"></a>00781         <span class="keywordflow">break</span>;
<a name="l00782"></a>00782       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_NAME:
<a name="l00783"></a>00783       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_CTOR:
<a name="l00784"></a>00784       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_DTOR:
<a name="l00785"></a>00785       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_OPERATOR:
<a name="l00786"></a>00786       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_EXTENDED_OPERATOR:
<a name="l00787"></a>00787         done = 1;
<a name="l00788"></a>00788         <span class="keywordflow">break</span>;
<a name="l00789"></a>00789       <span class="keywordflow">default</span>:
<a name="l00790"></a>00790         <span class="keywordflow">return</span> NULL;
<a name="l00791"></a>00791         <span class="keywordflow">break</span>;
<a name="l00792"></a>00792       }
<a name="l00793"></a>00793 
<a name="l00794"></a>00794   <span class="keywordflow">if</span> (last_template)
<a name="l00795"></a>00795     {
<a name="l00796"></a>00796       <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (last_template) = ret_comp;
<a name="l00797"></a>00797       <span class="keywordflow">return</span> last_template;
<a name="l00798"></a>00798     }
<a name="l00799"></a>00799 
<a name="l00800"></a>00800   <span class="keywordflow">return</span> ret_comp;
<a name="l00801"></a>00801 }
<a name="l00802"></a>00802 
<a name="l00803"></a>00803 <span class="comment">/* Return the name of the method whose linkage name is PHYSNAME.  */</span>
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 <span class="keywordtype">char</span> *
<a name="l00806"></a><a class="code" href="cp-support_8h.html#abe7c1d5b3718a7821b15477cdd989809">00806</a> <a class="code" href="cp-support_8c.html#abe7c1d5b3718a7821b15477cdd989809">method_name_from_physname</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *physname)
<a name="l00807"></a>00807 {
<a name="l00808"></a>00808   <span class="keywordtype">void</span> *storage = NULL;
<a name="l00809"></a>00809   <span class="keywordtype">char</span> *demangled_name = NULL, *ret;
<a name="l00810"></a>00810   <span class="keyword">struct </span>demangle_component *ret_comp;
<a name="l00811"></a>00811   <span class="keyword">struct </span><a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *<a class="code" href="structdemangle__parse__info.html#a5fb8c7e5dccffb6e98ac9658ce0dc330">info</a>;
<a name="l00812"></a>00812 
<a name="l00813"></a>00813   info = <a class="code" href="cp-support_8c.html#a69bc78926309f050cc8f9ebfee2aa796">mangled_name_to_comp</a> (physname, DMGL_ANSI,
<a name="l00814"></a>00814                                &amp;storage, &amp;demangled_name);
<a name="l00815"></a>00815   <span class="keywordflow">if</span> (info == NULL)
<a name="l00816"></a>00816     <span class="keywordflow">return</span> NULL;
<a name="l00817"></a>00817 
<a name="l00818"></a>00818   ret_comp = <a class="code" href="cp-support_8c.html#a87310c20e5348d35bb96e54ef5328c50">unqualified_name_from_comp</a> (info-&gt;<a class="code" href="structdemangle__parse__info.html#a5b5cc3882be46fff69af215b64e1e0bb">tree</a>);
<a name="l00819"></a>00819 
<a name="l00820"></a>00820   ret = NULL;
<a name="l00821"></a>00821   <span class="keywordflow">if</span> (ret_comp != NULL)
<a name="l00822"></a>00822     <span class="comment">/* The ten is completely arbitrary; we don&#39;t have a good</span>
<a name="l00823"></a>00823 <span class="comment">       estimate.  */</span>
<a name="l00824"></a>00824     ret = <a class="code" href="cp-support_8h.html#acfcf757fc9842cd18eba35eae4185096">cp_comp_to_string</a> (ret_comp, 10);
<a name="l00825"></a>00825 
<a name="l00826"></a>00826   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (storage);
<a name="l00827"></a>00827   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (demangled_name);
<a name="l00828"></a>00828   <a class="code" href="cp-support_8h.html#ace2dc64c57d30cdb4af45ed66ad18700">cp_demangled_name_parse_free</a> (info);
<a name="l00829"></a>00829   <span class="keywordflow">return</span> ret;
<a name="l00830"></a>00830 }
<a name="l00831"></a>00831 
<a name="l00832"></a>00832 <span class="comment">/* If FULL_NAME is the demangled name of a C++ function (including an</span>
<a name="l00833"></a>00833 <span class="comment">   arg list, possibly including namespace/class qualifications),</span>
<a name="l00834"></a>00834 <span class="comment">   return a new string containing only the function name (without the</span>
<a name="l00835"></a>00835 <span class="comment">   arg list/class qualifications).  Otherwise, return NULL.  The</span>
<a name="l00836"></a>00836 <span class="comment">   caller is responsible for freeing the memory in question.  */</span>
<a name="l00837"></a>00837 
<a name="l00838"></a>00838 <span class="keywordtype">char</span> *
<a name="l00839"></a><a class="code" href="cp-support_8h.html#a275dd20b2397da19cfb1eada20b61686">00839</a> <a class="code" href="cp-support_8c.html#a275dd20b2397da19cfb1eada20b61686">cp_func_name</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *full_name)
<a name="l00840"></a>00840 {
<a name="l00841"></a>00841   <span class="keywordtype">char</span> *ret;
<a name="l00842"></a>00842   <span class="keyword">struct </span>demangle_component *ret_comp;
<a name="l00843"></a>00843   <span class="keyword">struct </span><a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *<a class="code" href="structdemangle__parse__info.html#a5fb8c7e5dccffb6e98ac9658ce0dc330">info</a>;
<a name="l00844"></a>00844 
<a name="l00845"></a>00845   info = <a class="code" href="cp-support_8h.html#acd1741db1e809ee2eda9add915443492">cp_demangled_name_to_comp</a> (full_name, NULL);
<a name="l00846"></a>00846   <span class="keywordflow">if</span> (!info)
<a name="l00847"></a>00847     <span class="keywordflow">return</span> NULL;
<a name="l00848"></a>00848 
<a name="l00849"></a>00849   ret_comp = <a class="code" href="cp-support_8c.html#a87310c20e5348d35bb96e54ef5328c50">unqualified_name_from_comp</a> (info-&gt;<a class="code" href="structdemangle__parse__info.html#a5b5cc3882be46fff69af215b64e1e0bb">tree</a>);
<a name="l00850"></a>00850 
<a name="l00851"></a>00851   ret = NULL;
<a name="l00852"></a>00852   <span class="keywordflow">if</span> (ret_comp != NULL)
<a name="l00853"></a>00853     ret = <a class="code" href="cp-support_8h.html#acfcf757fc9842cd18eba35eae4185096">cp_comp_to_string</a> (ret_comp, 10);
<a name="l00854"></a>00854 
<a name="l00855"></a>00855   <a class="code" href="cp-support_8h.html#ace2dc64c57d30cdb4af45ed66ad18700">cp_demangled_name_parse_free</a> (info);
<a name="l00856"></a>00856   <span class="keywordflow">return</span> ret;
<a name="l00857"></a>00857 }
<a name="l00858"></a>00858 
<a name="l00859"></a>00859 <span class="comment">/* DEMANGLED_NAME is the name of a function, including parameters and</span>
<a name="l00860"></a>00860 <span class="comment">   (optionally) a return type.  Return the name of the function without</span>
<a name="l00861"></a>00861 <span class="comment">   parameters or return type, or NULL if we can not parse the name.  */</span>
<a name="l00862"></a>00862 
<a name="l00863"></a>00863 <span class="keywordtype">char</span> *
<a name="l00864"></a><a class="code" href="cp-support_8h.html#a6a38238179eb06d9c4927adf4385b2e7">00864</a> <a class="code" href="cp-support_8c.html#a6a38238179eb06d9c4927adf4385b2e7">cp_remove_params</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *demangled_name)
<a name="l00865"></a>00865 {
<a name="l00866"></a>00866   <span class="keywordtype">int</span> done = 0;
<a name="l00867"></a>00867   <span class="keyword">struct </span>demangle_component *ret_comp;
<a name="l00868"></a>00868   <span class="keyword">struct </span><a class="code" href="structdemangle__parse__info.html">demangle_parse_info</a> *<a class="code" href="structdemangle__parse__info.html#a5fb8c7e5dccffb6e98ac9658ce0dc330">info</a>;
<a name="l00869"></a>00869   <span class="keywordtype">char</span> *ret = NULL;
<a name="l00870"></a>00870 
<a name="l00871"></a>00871   <span class="keywordflow">if</span> (demangled_name == NULL)
<a name="l00872"></a>00872     <span class="keywordflow">return</span> NULL;
<a name="l00873"></a>00873 
<a name="l00874"></a>00874   info = <a class="code" href="cp-support_8h.html#acd1741db1e809ee2eda9add915443492">cp_demangled_name_to_comp</a> (demangled_name, NULL);
<a name="l00875"></a>00875   <span class="keywordflow">if</span> (info == NULL)
<a name="l00876"></a>00876     <span class="keywordflow">return</span> NULL;
<a name="l00877"></a>00877 
<a name="l00878"></a>00878   <span class="comment">/* First strip off any qualifiers, if we have a function or method.  */</span>
<a name="l00879"></a>00879   ret_comp = info-&gt;<a class="code" href="structdemangle__parse__info.html#a5b5cc3882be46fff69af215b64e1e0bb">tree</a>;
<a name="l00880"></a>00880   <span class="keywordflow">while</span> (!done)
<a name="l00881"></a>00881     <span class="keywordflow">switch</span> (ret_comp-&gt;type)
<a name="l00882"></a>00882       {
<a name="l00883"></a>00883       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_CONST:
<a name="l00884"></a>00884       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_RESTRICT:
<a name="l00885"></a>00885       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_VOLATILE:
<a name="l00886"></a>00886       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_CONST_THIS:
<a name="l00887"></a>00887       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_RESTRICT_THIS:
<a name="l00888"></a>00888       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_VOLATILE_THIS:
<a name="l00889"></a>00889       <span class="keywordflow">case</span> DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
<a name="l00890"></a>00890         ret_comp = <a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp);
<a name="l00891"></a>00891         <span class="keywordflow">break</span>;
<a name="l00892"></a>00892       <span class="keywordflow">default</span>:
<a name="l00893"></a>00893         done = 1;
<a name="l00894"></a>00894         <span class="keywordflow">break</span>;
<a name="l00895"></a>00895       }
<a name="l00896"></a>00896 
<a name="l00897"></a>00897   <span class="comment">/* What we have now should be a function.  Return its name.  */</span>
<a name="l00898"></a>00898   <span class="keywordflow">if</span> (ret_comp-&gt;type == DEMANGLE_COMPONENT_TYPED_NAME)
<a name="l00899"></a>00899     ret = <a class="code" href="cp-support_8h.html#acfcf757fc9842cd18eba35eae4185096">cp_comp_to_string</a> (<a class="code" href="cp-support_8c.html#a8af4a97f61d1d64bb4d039633c5645d3">d_left</a> (ret_comp), 10);
<a name="l00900"></a>00900 
<a name="l00901"></a>00901   <a class="code" href="cp-support_8h.html#ace2dc64c57d30cdb4af45ed66ad18700">cp_demangled_name_parse_free</a> (info);
<a name="l00902"></a>00902   <span class="keywordflow">return</span> ret;
<a name="l00903"></a>00903 }
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 <span class="comment">/* Here are some random pieces of trivia to keep in mind while trying</span>
<a name="l00906"></a>00906 <span class="comment">   to take apart demangled names:</span>
<a name="l00907"></a>00907 <span class="comment"></span>
<a name="l00908"></a>00908 <span class="comment">   - Names can contain function arguments or templates, so the process</span>
<a name="l00909"></a>00909 <span class="comment">     has to be, to some extent recursive: maybe keep track of your</span>
<a name="l00910"></a>00910 <span class="comment">     depth based on encountering &lt;&gt; and ().</span>
<a name="l00911"></a>00911 <span class="comment"></span>
<a name="l00912"></a>00912 <span class="comment">   - Parentheses don&#39;t just have to happen at the end of a name: they</span>
<a name="l00913"></a>00913 <span class="comment">     can occur even if the name in question isn&#39;t a function, because</span>
<a name="l00914"></a>00914 <span class="comment">     a template argument might be a type that&#39;s a function.</span>
<a name="l00915"></a>00915 <span class="comment"></span>
<a name="l00916"></a>00916 <span class="comment">   - Conversely, even if you&#39;re trying to deal with a function, its</span>
<a name="l00917"></a>00917 <span class="comment">     demangled name might not end with &#39;)&#39;: it could be a const or</span>
<a name="l00918"></a>00918 <span class="comment">     volatile class method, in which case it ends with &quot;const&quot; or</span>
<a name="l00919"></a>00919 <span class="comment">     &quot;volatile&quot;.</span>
<a name="l00920"></a>00920 <span class="comment"></span>
<a name="l00921"></a>00921 <span class="comment">   - Parentheses are also used in anonymous namespaces: a variable</span>
<a name="l00922"></a>00922 <span class="comment">     &#39;foo&#39; in an anonymous namespace gets demangled as &quot;(anonymous</span>
<a name="l00923"></a>00923 <span class="comment">     namespace)::foo&quot;.</span>
<a name="l00924"></a>00924 <span class="comment"></span>
<a name="l00925"></a>00925 <span class="comment">   - And operator names can contain parentheses or angle brackets.  */</span>
<a name="l00926"></a>00926 
<a name="l00927"></a>00927 <span class="comment">/* FIXME: carlton/2003-03-13: We have several functions here with</span>
<a name="l00928"></a>00928 <span class="comment">   overlapping functionality; can we combine them?  Also, do they</span>
<a name="l00929"></a>00929 <span class="comment">   handle all the above considerations correctly?  */</span>
<a name="l00930"></a>00930 
<a name="l00931"></a>00931 
<a name="l00932"></a>00932 <span class="comment">/* This returns the length of first component of NAME, which should be</span>
<a name="l00933"></a>00933 <span class="comment">   the demangled name of a C++ variable/function/method/etc.</span>
<a name="l00934"></a>00934 <span class="comment">   Specifically, it returns the index of the first colon forming the</span>
<a name="l00935"></a>00935 <span class="comment">   boundary of the first component: so, given &#39;A::foo&#39; or &#39;A::B::foo&#39;</span>
<a name="l00936"></a>00936 <span class="comment">   it returns the 1, and given &#39;foo&#39;, it returns 0.  */</span>
<a name="l00937"></a>00937 
<a name="l00938"></a>00938 <span class="comment">/* The character in NAME indexed by the return value is guaranteed to</span>
<a name="l00939"></a>00939 <span class="comment">   always be either &#39;:&#39; or &#39;\0&#39;.  */</span>
<a name="l00940"></a>00940 
<a name="l00941"></a>00941 <span class="comment">/* NOTE: carlton/2003-03-13: This function is currently only intended</span>
<a name="l00942"></a>00942 <span class="comment">   for internal use: it&#39;s probably not entirely safe when called on</span>
<a name="l00943"></a>00943 <span class="comment">   user-generated input, because some of the &#39;index += 2&#39; lines in</span>
<a name="l00944"></a>00944 <span class="comment">   cp_find_first_component_aux might go past the end of malformed</span>
<a name="l00945"></a>00945 <span class="comment">   input.  */</span>
<a name="l00946"></a>00946 
<a name="l00947"></a>00947 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00948"></a><a class="code" href="cp-support_8h.html#a9220248a41cd63dc5f0a64d5222cd623">00948</a> <a class="code" href="cp-support_8c.html#a9220248a41cd63dc5f0a64d5222cd623">cp_find_first_component</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>)
<a name="l00949"></a>00949 {
<a name="l00950"></a>00950   <span class="keywordflow">return</span> <a class="code" href="cp-support_8c.html#a192a52cfc07b8d9f4867c9ba46eecc3c">cp_find_first_component_aux</a> (name, 0);
<a name="l00951"></a>00951 }
<a name="l00952"></a>00952 
<a name="l00953"></a>00953 <span class="comment">/* Helper function for cp_find_first_component.  Like that function,</span>
<a name="l00954"></a>00954 <span class="comment">   it returns the length of the first component of NAME, but to make</span>
<a name="l00955"></a>00955 <span class="comment">   the recursion easier, it also stops if it reaches an unexpected &#39;)&#39;</span>
<a name="l00956"></a>00956 <span class="comment">   or &#39;&gt;&#39; if the value of PERMISSIVE is nonzero.  */</span>
<a name="l00957"></a>00957 
<a name="l00958"></a>00958 <span class="comment">/* Let&#39;s optimize away calls to strlen(&quot;operator&quot;).  */</span>
<a name="l00959"></a>00959 
<a name="l00960"></a><a class="code" href="cp-support_8c.html#a812591eb28df39da1583f52c55f78feb">00960</a> <span class="preprocessor">#define LENGTH_OF_OPERATOR 8</span>
<a name="l00961"></a>00961 <span class="preprocessor"></span>
<a name="l00962"></a>00962 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00963"></a><a class="code" href="cp-support_8c.html#a192a52cfc07b8d9f4867c9ba46eecc3c">00963</a> <a class="code" href="cp-support_8c.html#a192a52cfc07b8d9f4867c9ba46eecc3c">cp_find_first_component_aux</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keywordtype">int</span> permissive)
<a name="l00964"></a>00964 {
<a name="l00965"></a>00965   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 0;
<a name="l00966"></a>00966   <span class="comment">/* Operator names can show up in unexpected places.  Since these can</span>
<a name="l00967"></a>00967 <span class="comment">     contain parentheses or angle brackets, they can screw up the</span>
<a name="l00968"></a>00968 <span class="comment">     recursion.  But not every string &#39;operator&#39; is part of an</span>
<a name="l00969"></a>00969 <span class="comment">     operater name: e.g. you could have a variable &#39;cooperator&#39;.  So</span>
<a name="l00970"></a>00970 <span class="comment">     this variable tells us whether or not we should treat the string</span>
<a name="l00971"></a>00971 <span class="comment">     &#39;operator&#39; as starting an operator.  */</span>
<a name="l00972"></a>00972   <span class="keywordtype">int</span> operator_possible = 1;
<a name="l00973"></a>00973 
<a name="l00974"></a>00974   <span class="keywordflow">for</span> (;; ++index)
<a name="l00975"></a>00975     {
<a name="l00976"></a>00976       <span class="keywordflow">switch</span> (name[index])
<a name="l00977"></a>00977         {
<a name="l00978"></a>00978         <span class="keywordflow">case</span> <span class="charliteral">&#39;&lt;&#39;</span>:
<a name="l00979"></a>00979           <span class="comment">/* Template; eat it up.  The calls to cp_first_component</span>
<a name="l00980"></a>00980 <span class="comment">             should only return (I hope!) when they reach the &#39;&gt;&#39;</span>
<a name="l00981"></a>00981 <span class="comment">             terminating the component or a &#39;::&#39; between two</span>
<a name="l00982"></a>00982 <span class="comment">             components.  (Hence the &#39;+ 2&#39;.)  */</span>
<a name="l00983"></a>00983           index += 1;
<a name="l00984"></a>00984           <span class="keywordflow">for</span> (index += <a class="code" href="cp-support_8c.html#a192a52cfc07b8d9f4867c9ba46eecc3c">cp_find_first_component_aux</a> (name + index, 1);
<a name="l00985"></a>00985                name[index] != <span class="charliteral">&#39;&gt;&#39;</span>;
<a name="l00986"></a>00986                index += <a class="code" href="cp-support_8c.html#a192a52cfc07b8d9f4867c9ba46eecc3c">cp_find_first_component_aux</a> (name + index, 1))
<a name="l00987"></a>00987             {
<a name="l00988"></a>00988               <span class="keywordflow">if</span> (name[index] != <span class="charliteral">&#39;:&#39;</span>)
<a name="l00989"></a>00989                 {
<a name="l00990"></a>00990                   <a class="code" href="cp-support_8c.html#af3c166e5237ade66318ff3b315a214e9">demangled_name_complaint</a> (name);
<a name="l00991"></a>00991                   <span class="keywordflow">return</span> strlen (name);
<a name="l00992"></a>00992                 }
<a name="l00993"></a>00993               index += 2;
<a name="l00994"></a>00994             }
<a name="l00995"></a>00995           operator_possible = 1;
<a name="l00996"></a>00996           <span class="keywordflow">break</span>;
<a name="l00997"></a>00997         <span class="keywordflow">case</span> <span class="charliteral">&#39;(&#39;</span>:
<a name="l00998"></a>00998           <span class="comment">/* Similar comment as to &#39;&lt;&#39;.  */</span>
<a name="l00999"></a>00999           index += 1;
<a name="l01000"></a>01000           <span class="keywordflow">for</span> (index += <a class="code" href="cp-support_8c.html#a192a52cfc07b8d9f4867c9ba46eecc3c">cp_find_first_component_aux</a> (name + index, 1);
<a name="l01001"></a>01001                name[index] != <span class="charliteral">&#39;)&#39;</span>;
<a name="l01002"></a>01002                index += <a class="code" href="cp-support_8c.html#a192a52cfc07b8d9f4867c9ba46eecc3c">cp_find_first_component_aux</a> (name + index, 1))
<a name="l01003"></a>01003             {
<a name="l01004"></a>01004               <span class="keywordflow">if</span> (name[index] != <span class="charliteral">&#39;:&#39;</span>)
<a name="l01005"></a>01005                 {
<a name="l01006"></a>01006                   <a class="code" href="cp-support_8c.html#af3c166e5237ade66318ff3b315a214e9">demangled_name_complaint</a> (name);
<a name="l01007"></a>01007                   <span class="keywordflow">return</span> strlen (name);
<a name="l01008"></a>01008                 }
<a name="l01009"></a>01009               index += 2;
<a name="l01010"></a>01010             }
<a name="l01011"></a>01011           operator_possible = 1;
<a name="l01012"></a>01012           <span class="keywordflow">break</span>;
<a name="l01013"></a>01013         <span class="keywordflow">case</span> <span class="charliteral">&#39;&gt;&#39;</span>:
<a name="l01014"></a>01014         <span class="keywordflow">case</span> <span class="charliteral">&#39;)&#39;</span>:
<a name="l01015"></a>01015           <span class="keywordflow">if</span> (permissive)
<a name="l01016"></a>01016             <span class="keywordflow">return</span> index;
<a name="l01017"></a>01017           <span class="keywordflow">else</span>
<a name="l01018"></a>01018             {
<a name="l01019"></a>01019               <a class="code" href="cp-support_8c.html#af3c166e5237ade66318ff3b315a214e9">demangled_name_complaint</a> (name);
<a name="l01020"></a>01020               <span class="keywordflow">return</span> strlen (name);
<a name="l01021"></a>01021             }
<a name="l01022"></a>01022         <span class="keywordflow">case</span> <span class="charliteral">&#39;\0&#39;</span>:
<a name="l01023"></a>01023         <span class="keywordflow">case</span> <span class="charliteral">&#39;:&#39;</span>:
<a name="l01024"></a>01024           <span class="keywordflow">return</span> index;
<a name="l01025"></a>01025         <span class="keywordflow">case</span> <span class="charliteral">&#39;o&#39;</span>:
<a name="l01026"></a>01026           <span class="comment">/* Operator names can screw up the recursion.  */</span>
<a name="l01027"></a>01027           <span class="keywordflow">if</span> (operator_possible
<a name="l01028"></a>01028               &amp;&amp; strncmp (name + index, <span class="stringliteral">&quot;operator&quot;</span>,
<a name="l01029"></a>01029                           <a class="code" href="cp-support_8c.html#a812591eb28df39da1583f52c55f78feb">LENGTH_OF_OPERATOR</a>) == 0)
<a name="l01030"></a>01030             {
<a name="l01031"></a>01031               index += <a class="code" href="cp-support_8c.html#a812591eb28df39da1583f52c55f78feb">LENGTH_OF_OPERATOR</a>;
<a name="l01032"></a>01032               <span class="keywordflow">while</span> (ISSPACE(name[index]))
<a name="l01033"></a>01033                 ++index;
<a name="l01034"></a>01034               <span class="keywordflow">switch</span> (name[index])
<a name="l01035"></a>01035                 {
<a name="l01036"></a>01036                   <span class="comment">/* Skip over one less than the appropriate number of</span>
<a name="l01037"></a>01037 <span class="comment">                     characters: the for loop will skip over the last</span>
<a name="l01038"></a>01038 <span class="comment">                     one.  */</span>
<a name="l01039"></a>01039                 <span class="keywordflow">case</span> <span class="charliteral">&#39;&lt;&#39;</span>:
<a name="l01040"></a>01040                   <span class="keywordflow">if</span> (name[index + 1] == <span class="charliteral">&#39;&lt;&#39;</span>)
<a name="l01041"></a>01041                     index += 1;
<a name="l01042"></a>01042                   <span class="keywordflow">else</span>
<a name="l01043"></a>01043                     index += 0;
<a name="l01044"></a>01044                   <span class="keywordflow">break</span>;
<a name="l01045"></a>01045                 <span class="keywordflow">case</span> <span class="charliteral">&#39;&gt;&#39;</span>:
<a name="l01046"></a>01046                 <span class="keywordflow">case</span> <span class="charliteral">&#39;-&#39;</span>:
<a name="l01047"></a>01047                   <span class="keywordflow">if</span> (name[index + 1] == <span class="charliteral">&#39;&gt;&#39;</span>)
<a name="l01048"></a>01048                     index += 1;
<a name="l01049"></a>01049                   <span class="keywordflow">else</span>
<a name="l01050"></a>01050                     index += 0;
<a name="l01051"></a>01051                   <span class="keywordflow">break</span>;
<a name="l01052"></a>01052                 <span class="keywordflow">case</span> <span class="charliteral">&#39;(&#39;</span>:
<a name="l01053"></a>01053                   index += 1;
<a name="l01054"></a>01054                   <span class="keywordflow">break</span>;
<a name="l01055"></a>01055                 <span class="keywordflow">default</span>:
<a name="l01056"></a>01056                   index += 0;
<a name="l01057"></a>01057                   <span class="keywordflow">break</span>;
<a name="l01058"></a>01058                 }
<a name="l01059"></a>01059             }
<a name="l01060"></a>01060           operator_possible = 0;
<a name="l01061"></a>01061           <span class="keywordflow">break</span>;
<a name="l01062"></a>01062         <span class="keywordflow">case</span> <span class="charliteral">&#39; &#39;</span>:
<a name="l01063"></a>01063         <span class="keywordflow">case</span> <span class="charliteral">&#39;,&#39;</span>:
<a name="l01064"></a>01064         <span class="keywordflow">case</span> <span class="charliteral">&#39;.&#39;</span>:
<a name="l01065"></a>01065         <span class="keywordflow">case</span> <span class="charliteral">&#39;&amp;&#39;</span>:
<a name="l01066"></a>01066         <span class="keywordflow">case</span> <span class="charliteral">&#39;*&#39;</span>:
<a name="l01067"></a>01067           <span class="comment">/* NOTE: carlton/2003-04-18: I&#39;m not sure what the precise</span>
<a name="l01068"></a>01068 <span class="comment">             set of relevant characters are here: it&#39;s necessary to</span>
<a name="l01069"></a>01069 <span class="comment">             include any character that can show up before &#39;operator&#39;</span>
<a name="l01070"></a>01070 <span class="comment">             in a demangled name, and it&#39;s safe to include any</span>
<a name="l01071"></a>01071 <span class="comment">             character that can&#39;t be part of an identifier&#39;s name.  */</span>
<a name="l01072"></a>01072           operator_possible = 1;
<a name="l01073"></a>01073           <span class="keywordflow">break</span>;
<a name="l01074"></a>01074         <span class="keywordflow">default</span>:
<a name="l01075"></a>01075           operator_possible = 0;
<a name="l01076"></a>01076           <span class="keywordflow">break</span>;
<a name="l01077"></a>01077         }
<a name="l01078"></a>01078     }
<a name="l01079"></a>01079 }
<a name="l01080"></a>01080 
<a name="l01081"></a>01081 <span class="comment">/* Complain about a demangled name that we don&#39;t know how to parse.</span>
<a name="l01082"></a>01082 <span class="comment">   NAME is the demangled name in question.  */</span>
<a name="l01083"></a>01083 
<a name="l01084"></a>01084 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01085"></a><a class="code" href="cp-support_8c.html#af3c166e5237ade66318ff3b315a214e9">01085</a> <a class="code" href="cp-support_8c.html#af3c166e5237ade66318ff3b315a214e9">demangled_name_complaint</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>)
<a name="l01086"></a>01086 {
<a name="l01087"></a>01087   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01088"></a>01088              <span class="stringliteral">&quot;unexpected demangled name &#39;%s&#39;&quot;</span>, name);
<a name="l01089"></a>01089 }
<a name="l01090"></a>01090 
<a name="l01091"></a>01091 <span class="comment">/* If NAME is the fully-qualified name of a C++</span>
<a name="l01092"></a>01092 <span class="comment">   function/variable/method/etc., this returns the length of its</span>
<a name="l01093"></a>01093 <span class="comment">   entire prefix: all of the namespaces and classes that make up its</span>
<a name="l01094"></a>01094 <span class="comment">   name.  Given &#39;A::foo&#39;, it returns 1, given &#39;A::B::foo&#39;, it returns</span>
<a name="l01095"></a>01095 <span class="comment">   4, given &#39;foo&#39;, it returns 0.  */</span>
<a name="l01096"></a>01096 
<a name="l01097"></a>01097 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l01098"></a><a class="code" href="cp-support_8h.html#aa1d1a847584d5d54a516ff055fca5fab">01098</a> <a class="code" href="cp-support_8c.html#aa1d1a847584d5d54a516ff055fca5fab">cp_entire_prefix_len</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>)
<a name="l01099"></a>01099 {
<a name="l01100"></a>01100   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_len = <a class="code" href="cp-support_8c.html#a9220248a41cd63dc5f0a64d5222cd623">cp_find_first_component</a> (name);
<a name="l01101"></a>01101   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> previous_len = 0;
<a name="l01102"></a>01102 
<a name="l01103"></a>01103   <span class="keywordflow">while</span> (name[current_len] != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l01104"></a>01104     {
<a name="l01105"></a>01105       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (name[current_len] == <span class="charliteral">&#39;:&#39;</span>);
<a name="l01106"></a>01106       previous_len = current_len;
<a name="l01107"></a>01107       <span class="comment">/* Skip the &#39;::&#39;.  */</span>
<a name="l01108"></a>01108       current_len += 2;
<a name="l01109"></a>01109       current_len += <a class="code" href="cp-support_8c.html#a9220248a41cd63dc5f0a64d5222cd623">cp_find_first_component</a> (name + current_len);
<a name="l01110"></a>01110     }
<a name="l01111"></a>01111 
<a name="l01112"></a>01112   <span class="keywordflow">return</span> previous_len;
<a name="l01113"></a>01113 }
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 <span class="comment">/* Overload resolution functions.  */</span>
<a name="l01116"></a>01116 
<a name="l01117"></a>01117 <span class="comment">/* Test to see if SYM is a symbol that we haven&#39;t seen corresponding</span>
<a name="l01118"></a>01118 <span class="comment">   to a function named OLOAD_NAME.  If so, add it to the current</span>
<a name="l01119"></a>01119 <span class="comment">   completion list.  */</span>
<a name="l01120"></a>01120 
<a name="l01121"></a>01121 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01122"></a><a class="code" href="cp-support_8c.html#a131464ca43faa1916f95fd3418c9f842">01122</a> <a class="code" href="cp-support_8c.html#a131464ca43faa1916f95fd3418c9f842">overload_list_add_symbol</a> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym,
<a name="l01123"></a>01123                           <span class="keyword">const</span> <span class="keywordtype">char</span> *oload_name)
<a name="l01124"></a>01124 {
<a name="l01125"></a>01125   <span class="keywordtype">int</span> newsize;
<a name="l01126"></a>01126   <span class="keywordtype">int</span> i;
<a name="l01127"></a>01127   <span class="keywordtype">char</span> *sym_name;
<a name="l01128"></a>01128 
<a name="l01129"></a>01129   <span class="comment">/* If there is no type information, we can&#39;t do anything, so</span>
<a name="l01130"></a>01130 <span class="comment">     skip.  */</span>
<a name="l01131"></a>01131   <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym) == NULL)
<a name="l01132"></a>01132     <span class="keywordflow">return</span>;
<a name="l01133"></a>01133 
<a name="l01134"></a>01134   <span class="comment">/* skip any symbols that we&#39;ve already considered.  */</span>
<a name="l01135"></a>01135   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="cp-support_8c.html#ab09a37ac5384668e3c7c8c11be5e8bd9">sym_return_val_index</a>; ++i)
<a name="l01136"></a>01136     <span class="keywordflow">if</span> (strcmp (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym),
<a name="l01137"></a>01137                 <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym_return_val[i])) == 0)
<a name="l01138"></a>01138       <span class="keywordflow">return</span>;
<a name="l01139"></a>01139 
<a name="l01140"></a>01140   <span class="comment">/* Get the demangled name without parameters */</span>
<a name="l01141"></a>01141   sym_name = <a class="code" href="cp-support_8c.html#a6a38238179eb06d9c4927adf4385b2e7">cp_remove_params</a> (<a class="code" href="symtab_8h.html#a243e66afa96ff58a851b38f428bb3394">SYMBOL_NATURAL_NAME</a> (sym));
<a name="l01142"></a>01142   <span class="keywordflow">if</span> (!sym_name)
<a name="l01143"></a>01143     <span class="keywordflow">return</span>;
<a name="l01144"></a>01144 
<a name="l01145"></a>01145   <span class="comment">/* skip symbols that cannot match */</span>
<a name="l01146"></a>01146   <span class="keywordflow">if</span> (strcmp (sym_name, oload_name) != 0)
<a name="l01147"></a>01147     {
<a name="l01148"></a>01148       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (sym_name);
<a name="l01149"></a>01149       <span class="keywordflow">return</span>;
<a name="l01150"></a>01150     }
<a name="l01151"></a>01151 
<a name="l01152"></a>01152   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (sym_name);
<a name="l01153"></a>01153 
<a name="l01154"></a>01154   <span class="comment">/* We have a match for an overload instance, so add SYM to the</span>
<a name="l01155"></a>01155 <span class="comment">     current list of overload instances */</span>
<a name="l01156"></a>01156   <span class="keywordflow">if</span> (sym_return_val_index + 3 &gt; <a class="code" href="cp-support_8c.html#a286a911b3ffab718b9a9f9e2f19cdf0e">sym_return_val_size</a>)
<a name="l01157"></a>01157     {
<a name="l01158"></a>01158       newsize = (<a class="code" href="cp-support_8c.html#a286a911b3ffab718b9a9f9e2f19cdf0e">sym_return_val_size</a> *= 2) * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *);
<a name="l01159"></a>01159       sym_return_val = (<span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> **)
<a name="l01160"></a>01160         <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> ((<span class="keywordtype">char</span> *) <a class="code" href="cp-support_8c.html#aa192c52fc8cfcda353c80526979c9765">sym_return_val</a>, newsize);
<a name="l01161"></a>01161     }
<a name="l01162"></a>01162   sym_return_val[sym_return_val_index++] = sym;
<a name="l01163"></a>01163   sym_return_val[<a class="code" href="cp-support_8c.html#ab09a37ac5384668e3c7c8c11be5e8bd9">sym_return_val_index</a>] = NULL;
<a name="l01164"></a>01164 }
<a name="l01165"></a>01165 
<a name="l01166"></a>01166 <span class="comment">/* Return a null-terminated list of pointers to function symbols that</span>
<a name="l01167"></a>01167 <span class="comment">   are named FUNC_NAME and are visible within NAMESPACE.  */</span>
<a name="l01168"></a>01168 
<a name="l01169"></a>01169 <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> **
<a name="l01170"></a><a class="code" href="cp-support_8h.html#a12e08b28ad7184b5aae467b375ceec9c">01170</a> <a class="code" href="cp-support_8c.html#acc44ea3d596fbf6b94b891b29194bcb7">make_symbol_overload_list</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *func_name,
<a name="l01171"></a>01171                            <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">namespace</span>)
<a name="l01172"></a>01172 {
<a name="l01173"></a>01173   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_cleanups;
<a name="l01174"></a>01174   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01175"></a>01175 
<a name="l01176"></a>01176   <a class="code" href="cp-support_8c.html#a286a911b3ffab718b9a9f9e2f19cdf0e">sym_return_val_size</a> = 100;
<a name="l01177"></a>01177   <a class="code" href="cp-support_8c.html#ab09a37ac5384668e3c7c8c11be5e8bd9">sym_return_val_index</a> = 0;
<a name="l01178"></a>01178   sym_return_val = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> ((<a class="code" href="cp-support_8c.html#a286a911b3ffab718b9a9f9e2f19cdf0e">sym_return_val_size</a> + 1) *
<a name="l01179"></a>01179                             <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *));
<a name="l01180"></a>01180   sym_return_val[0] = NULL;
<a name="l01181"></a>01181 
<a name="l01182"></a>01182   old_cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, sym_return_val);
<a name="l01183"></a>01183 
<a name="l01184"></a>01184   <a class="code" href="cp-support_8c.html#acbb67821ca29600912150f7fd6a6754b">make_symbol_overload_list_using</a> (func_name, <span class="keyword">namespace</span>);
<a name="l01185"></a>01185 
<a name="l01186"></a>01186   <span class="keywordflow">if</span> (<span class="keyword">namespace</span>[0] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l01187"></a>01187     name = func_name;
<a name="l01188"></a>01188   <span class="keywordflow">else</span>
<a name="l01189"></a>01189     {
<a name="l01190"></a>01190       <span class="keywordtype">char</span> *concatenated_name
<a name="l01191"></a>01191         = alloca (strlen (<span class="keyword">namespace</span>) + 2 + strlen (func_name) + 1);
<a name="l01192"></a>01192       strcpy (concatenated_name, <span class="keyword">namespace</span>);
<a name="l01193"></a>01193       strcat (concatenated_name, <span class="stringliteral">&quot;::&quot;</span>);
<a name="l01194"></a>01194       strcat (concatenated_name, func_name);
<a name="l01195"></a>01195       name = concatenated_name;
<a name="l01196"></a>01196     }
<a name="l01197"></a>01197 
<a name="l01198"></a>01198   <a class="code" href="cp-support_8c.html#ab9a4da62634573a5ebeeca51db94992e">make_symbol_overload_list_qualified</a> (name);
<a name="l01199"></a>01199 
<a name="l01200"></a>01200   <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (old_cleanups);
<a name="l01201"></a>01201 
<a name="l01202"></a>01202   <span class="keywordflow">return</span> <a class="code" href="cp-support_8c.html#aa192c52fc8cfcda353c80526979c9765">sym_return_val</a>;
<a name="l01203"></a>01203 }
<a name="l01204"></a>01204 
<a name="l01205"></a>01205 <span class="comment">/* Add all symbols with a name matching NAME in BLOCK to the overload</span>
<a name="l01206"></a>01206 <span class="comment">   list.  */</span>
<a name="l01207"></a>01207 
<a name="l01208"></a>01208 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01209"></a><a class="code" href="cp-support_8c.html#a72595ce2638139257bcb4cb4a4fc0d4f">01209</a> <a class="code" href="cp-support_8c.html#a72595ce2638139257bcb4cb4a4fc0d4f">make_symbol_overload_list_block</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>,
<a name="l01210"></a>01210                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>)
<a name="l01211"></a>01211 {
<a name="l01212"></a>01212   <span class="keyword">struct </span><a class="code" href="structblock__iterator.html">block_iterator</a> iter;
<a name="l01213"></a>01213   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l01214"></a>01214 
<a name="l01215"></a>01215   <span class="keywordflow">for</span> (sym = <a class="code" href="block_8c.html#a077ebe84420062d3573ee9286ddaa1ff">block_iter_name_first</a> (block, name, &amp;iter);
<a name="l01216"></a>01216        sym != NULL;
<a name="l01217"></a>01217        sym = <a class="code" href="block_8c.html#a0abf5fc0dc2fce3b86c7a352674906c8">block_iter_name_next</a> (name, &amp;iter))
<a name="l01218"></a>01218     <a class="code" href="cp-support_8c.html#a131464ca43faa1916f95fd3418c9f842">overload_list_add_symbol</a> (sym, name);
<a name="l01219"></a>01219 }
<a name="l01220"></a>01220 
<a name="l01221"></a>01221 <span class="comment">/* Adds the function FUNC_NAME from NAMESPACE to the overload set.  */</span>
<a name="l01222"></a>01222 
<a name="l01223"></a>01223 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01224"></a><a class="code" href="cp-support_8c.html#a023e5c8cfaf7e45c2513dfe9e8fb4521">01224</a> <a class="code" href="cp-support_8c.html#a023e5c8cfaf7e45c2513dfe9e8fb4521">make_symbol_overload_list_namespace</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *func_name,
<a name="l01225"></a>01225                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">namespace</span>)
<a name="l01226"></a>01226 {
<a name="l01227"></a>01227   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01228"></a>01228   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a> = NULL;
<a name="l01229"></a>01229 
<a name="l01230"></a>01230   <span class="keywordflow">if</span> (<span class="keyword">namespace</span>[0] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l01231"></a>01231     name = func_name;
<a name="l01232"></a>01232   <span class="keywordflow">else</span>
<a name="l01233"></a>01233     {
<a name="l01234"></a>01234       <span class="keywordtype">char</span> *concatenated_name
<a name="l01235"></a>01235         = alloca (strlen (<span class="keyword">namespace</span>) + 2 + strlen (func_name) + 1);
<a name="l01236"></a>01236 
<a name="l01237"></a>01237       strcpy (concatenated_name, <span class="keyword">namespace</span>);
<a name="l01238"></a>01238       strcat (concatenated_name, <span class="stringliteral">&quot;::&quot;</span>);
<a name="l01239"></a>01239       strcat (concatenated_name, func_name);
<a name="l01240"></a>01240       name = concatenated_name;
<a name="l01241"></a>01241     }
<a name="l01242"></a>01242 
<a name="l01243"></a>01243   <span class="comment">/* Look in the static block.  */</span>
<a name="l01244"></a>01244   block = <a class="code" href="block_8c.html#a05911f60e374e7045638058c1ef6dfd1">block_static_block</a> (<a class="code" href="frame_8h.html#a91efbdcf182d840c28d378def97cfc23">get_selected_block</a> (0));
<a name="l01245"></a>01245   <span class="keywordflow">if</span> (block)
<a name="l01246"></a>01246     <a class="code" href="cp-support_8c.html#a72595ce2638139257bcb4cb4a4fc0d4f">make_symbol_overload_list_block</a> (name, block);
<a name="l01247"></a>01247 
<a name="l01248"></a>01248   <span class="comment">/* Look in the global block.  */</span>
<a name="l01249"></a>01249   block = <a class="code" href="block_8c.html#a6ea3857615da29cabf77e842297c22f0">block_global_block</a> (block);
<a name="l01250"></a>01250   <span class="keywordflow">if</span> (block)
<a name="l01251"></a>01251     <a class="code" href="cp-support_8c.html#a72595ce2638139257bcb4cb4a4fc0d4f">make_symbol_overload_list_block</a> (name, block);
<a name="l01252"></a>01252 
<a name="l01253"></a>01253 }
<a name="l01254"></a>01254 
<a name="l01255"></a>01255 <span class="comment">/* Search the namespace of the given type and namespace of and public</span>
<a name="l01256"></a>01256 <span class="comment">   base types.  */</span>
<a name="l01257"></a>01257 
<a name="l01258"></a>01258 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01259"></a><a class="code" href="cp-support_8c.html#afea96f16babc0c88e6bdfe8ea097b779">01259</a> <a class="code" href="cp-support_8c.html#afea96f16babc0c88e6bdfe8ea097b779">make_symbol_overload_list_adl_namespace</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>,
<a name="l01260"></a>01260                                          <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name)
<a name="l01261"></a>01261 {
<a name="l01262"></a>01262   <span class="keywordtype">char</span> *<span class="keyword">namespace</span>;
<a name="l01263"></a>01263   <span class="keyword">const</span> <span class="keywordtype">char</span> *type_name;
<a name="l01264"></a>01264   <span class="keywordtype">int</span> i, prefix_len;
<a name="l01265"></a>01265 
<a name="l01266"></a>01266   <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l01267"></a>01267          || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>
<a name="l01268"></a>01268          || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l01269"></a>01269          || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>)
<a name="l01270"></a>01270     {
<a name="l01271"></a>01271       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>)
<a name="l01272"></a>01272         type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a>(type);
<a name="l01273"></a>01273       <span class="keywordflow">else</span>
<a name="l01274"></a>01274         type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l01275"></a>01275     }
<a name="l01276"></a>01276 
<a name="l01277"></a>01277   type_name = <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type);
<a name="l01278"></a>01278 
<a name="l01279"></a>01279   <span class="keywordflow">if</span> (type_name == NULL)
<a name="l01280"></a>01280     <span class="keywordflow">return</span>;
<a name="l01281"></a>01281 
<a name="l01282"></a>01282   prefix_len = <a class="code" href="cp-support_8c.html#aa1d1a847584d5d54a516ff055fca5fab">cp_entire_prefix_len</a> (type_name);
<a name="l01283"></a>01283 
<a name="l01284"></a>01284   <span class="keywordflow">if</span> (prefix_len != 0)
<a name="l01285"></a>01285     {
<a name="l01286"></a>01286       <span class="keyword">namespace </span>= alloca (prefix_len + 1);
<a name="l01287"></a>01287       strncpy (<span class="keyword">namespace</span>, type_name, prefix_len);
<a name="l01288"></a>01288       <span class="keyword">namespace</span>[prefix_len] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l01289"></a>01289 
<a name="l01290"></a>01290       <a class="code" href="cp-support_8c.html#a023e5c8cfaf7e45c2513dfe9e8fb4521">make_symbol_overload_list_namespace</a> (func_name, <span class="keyword">namespace</span>);
<a name="l01291"></a>01291     }
<a name="l01292"></a>01292 
<a name="l01293"></a>01293   <span class="comment">/* Check public base type */</span>
<a name="l01294"></a>01294   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a9f70b67b4d14548a879667f544eab4ef">TYPE_CODE_CLASS</a>)
<a name="l01295"></a>01295     <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (type); i++)
<a name="l01296"></a>01296       {
<a name="l01297"></a>01297         <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#adb19c8aef61bc4ce36cf98f6d40afa55">BASETYPE_VIA_PUBLIC</a> (type, i))
<a name="l01298"></a>01298           <a class="code" href="cp-support_8c.html#afea96f16babc0c88e6bdfe8ea097b779">make_symbol_overload_list_adl_namespace</a> (<a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">TYPE_BASECLASS</a> (type,
<a name="l01299"></a>01299                                                                    i),
<a name="l01300"></a>01300                                                    func_name);
<a name="l01301"></a>01301       }
<a name="l01302"></a>01302 }
<a name="l01303"></a>01303 
<a name="l01304"></a>01304 <span class="comment">/* Adds the overload list overload candidates for FUNC_NAME found</span>
<a name="l01305"></a>01305 <span class="comment">   through argument dependent lookup.  */</span>
<a name="l01306"></a>01306 
<a name="l01307"></a>01307 <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> **
<a name="l01308"></a><a class="code" href="cp-support_8h.html#a2065e45f2d40dd1f677702315dd962c8">01308</a> <a class="code" href="cp-support_8c.html#a2065e45f2d40dd1f677702315dd962c8">make_symbol_overload_list_adl</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **arg_types, <span class="keywordtype">int</span> nargs,
<a name="l01309"></a>01309                                <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name)
<a name="l01310"></a>01310 {
<a name="l01311"></a>01311   <span class="keywordtype">int</span> i;
<a name="l01312"></a>01312 
<a name="l01313"></a>01313   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="cp-support_8c.html#a286a911b3ffab718b9a9f9e2f19cdf0e">sym_return_val_size</a> != -1);
<a name="l01314"></a>01314 
<a name="l01315"></a>01315   <span class="keywordflow">for</span> (i = 1; i &lt;= nargs; i++)
<a name="l01316"></a>01316     <a class="code" href="cp-support_8c.html#afea96f16babc0c88e6bdfe8ea097b779">make_symbol_overload_list_adl_namespace</a> (arg_types[i - 1],
<a name="l01317"></a>01317                                              func_name);
<a name="l01318"></a>01318 
<a name="l01319"></a>01319   <span class="keywordflow">return</span> <a class="code" href="cp-support_8c.html#aa192c52fc8cfcda353c80526979c9765">sym_return_val</a>;
<a name="l01320"></a>01320 }
<a name="l01321"></a>01321 
<a name="l01322"></a>01322 <span class="comment">/* Used for cleanups to reset the &quot;searched&quot; flag in case of an</span>
<a name="l01323"></a>01323 <span class="comment">   error.  */</span>
<a name="l01324"></a>01324 
<a name="l01325"></a>01325 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01326"></a><a class="code" href="cp-support_8c.html#af1857aa6ed2ce310b70d1d5f30c35ac8">01326</a> <a class="code" href="cp-support_8c.html#af1857aa6ed2ce310b70d1d5f30c35ac8">reset_directive_searched</a> (<span class="keywordtype">void</span> *data)
<a name="l01327"></a>01327 {
<a name="l01328"></a>01328   <span class="keyword">struct </span><a class="code" href="structusing__direct.html">using_direct</a> *direct = data;
<a name="l01329"></a>01329   direct-&gt;<a class="code" href="structusing__direct.html#a87f3ea8bd7a0ffba2bca5aa7275f22e0">searched</a> = 0;
<a name="l01330"></a>01330 }
<a name="l01331"></a>01331 
<a name="l01332"></a>01332 <span class="comment">/* This applies the using directives to add namespaces to search in,</span>
<a name="l01333"></a>01333 <span class="comment">   and then searches for overloads in all of those namespaces.  It</span>
<a name="l01334"></a>01334 <span class="comment">   adds the symbols found to sym_return_val.  Arguments are as in</span>
<a name="l01335"></a>01335 <span class="comment">   make_symbol_overload_list.  */</span>
<a name="l01336"></a>01336 
<a name="l01337"></a>01337 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01338"></a><a class="code" href="cp-support_8c.html#acbb67821ca29600912150f7fd6a6754b">01338</a> <a class="code" href="cp-support_8c.html#acbb67821ca29600912150f7fd6a6754b">make_symbol_overload_list_using</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *func_name,
<a name="l01339"></a>01339                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">namespace</span>)
<a name="l01340"></a>01340 {
<a name="l01341"></a>01341   <span class="keyword">struct </span><a class="code" href="structusing__direct.html">using_direct</a> *current;
<a name="l01342"></a>01342   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>;
<a name="l01343"></a>01343 
<a name="l01344"></a>01344   <span class="comment">/* First, go through the using directives.  If any of them apply,</span>
<a name="l01345"></a>01345 <span class="comment">     look in the appropriate namespaces for new functions to match</span>
<a name="l01346"></a>01346 <span class="comment">     on.  */</span>
<a name="l01347"></a>01347 
<a name="l01348"></a>01348   <span class="keywordflow">for</span> (block = <a class="code" href="frame_8h.html#a91efbdcf182d840c28d378def97cfc23">get_selected_block</a> (0);
<a name="l01349"></a>01349        block != NULL;
<a name="l01350"></a>01350        block = <a class="code" href="block_8h.html#a8b7633ab6d6feadf9b2ee58e10ad8397">BLOCK_SUPERBLOCK</a> (block))
<a name="l01351"></a>01351     <span class="keywordflow">for</span> (current = <a class="code" href="block_8c.html#a11255951da8adeed4a547d68aaae2f94">block_using</a> (block);
<a name="l01352"></a>01352         current != NULL;
<a name="l01353"></a>01353         current = current-&gt;<a class="code" href="structusing__direct.html#a4dbe9f7ec48f69b08033318ed8d9fe21">next</a>)
<a name="l01354"></a>01354       {
<a name="l01355"></a>01355         <span class="comment">/* Prevent recursive calls.  */</span>
<a name="l01356"></a>01356         <span class="keywordflow">if</span> (current-&gt;<a class="code" href="structusing__direct.html#a87f3ea8bd7a0ffba2bca5aa7275f22e0">searched</a>)
<a name="l01357"></a>01357           <span class="keywordflow">continue</span>;
<a name="l01358"></a>01358 
<a name="l01359"></a>01359         <span class="comment">/* If this is a namespace alias or imported declaration ignore</span>
<a name="l01360"></a>01360 <span class="comment">           it.  */</span>
<a name="l01361"></a>01361         <span class="keywordflow">if</span> (current-&gt;<a class="code" href="structusing__direct.html#af95a48807c7077f58e21a96725567796">alias</a> != NULL || current-&gt;<a class="code" href="structusing__direct.html#ad7f653da9d16dcc442846e6c1356281f">declaration</a> != NULL)
<a name="l01362"></a>01362           <span class="keywordflow">continue</span>;
<a name="l01363"></a>01363 
<a name="l01364"></a>01364         <span class="keywordflow">if</span> (strcmp (<span class="keyword">namespace</span>, current-&gt;<a class="code" href="structusing__direct.html#acec26c64783fe22a417bbe0e46604dc1">import_dest</a>) == 0)
<a name="l01365"></a>01365           {
<a name="l01366"></a>01366             <span class="comment">/* Mark this import as searched so that the recursive call</span>
<a name="l01367"></a>01367 <span class="comment">               does not search it again.  */</span>
<a name="l01368"></a>01368             <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_chain;
<a name="l01369"></a>01369             current-&gt;<a class="code" href="structusing__direct.html#a87f3ea8bd7a0ffba2bca5aa7275f22e0">searched</a> = 1;
<a name="l01370"></a>01370             old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cp-support_8c.html#af1857aa6ed2ce310b70d1d5f30c35ac8">reset_directive_searched</a>,
<a name="l01371"></a>01371                                       current);
<a name="l01372"></a>01372 
<a name="l01373"></a>01373             <a class="code" href="cp-support_8c.html#acbb67821ca29600912150f7fd6a6754b">make_symbol_overload_list_using</a> (func_name,
<a name="l01374"></a>01374                                              current-&gt;<a class="code" href="structusing__direct.html#aa2bc6cbc689cb360e1313188e226ea7a">import_src</a>);
<a name="l01375"></a>01375 
<a name="l01376"></a>01376             current-&gt;<a class="code" href="structusing__direct.html#a87f3ea8bd7a0ffba2bca5aa7275f22e0">searched</a> = 0;
<a name="l01377"></a>01377             <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (old_chain);
<a name="l01378"></a>01378           }
<a name="l01379"></a>01379       }
<a name="l01380"></a>01380 
<a name="l01381"></a>01381   <span class="comment">/* Now, add names for this namespace.  */</span>
<a name="l01382"></a>01382   <a class="code" href="cp-support_8c.html#a023e5c8cfaf7e45c2513dfe9e8fb4521">make_symbol_overload_list_namespace</a> (func_name, <span class="keyword">namespace</span>);
<a name="l01383"></a>01383 }
<a name="l01384"></a>01384 
<a name="l01385"></a>01385 <span class="comment">/* This does the bulk of the work of finding overloaded symbols.</span>
<a name="l01386"></a>01386 <span class="comment">   FUNC_NAME is the name of the overloaded function we&#39;re looking for</span>
<a name="l01387"></a>01387 <span class="comment">   (possibly including namespace info).  */</span>
<a name="l01388"></a>01388 
<a name="l01389"></a>01389 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01390"></a><a class="code" href="cp-support_8c.html#ab9a4da62634573a5ebeeca51db94992e">01390</a> <a class="code" href="cp-support_8c.html#ab9a4da62634573a5ebeeca51db94992e">make_symbol_overload_list_qualified</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *func_name)
<a name="l01391"></a>01391 {
<a name="l01392"></a>01392   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *s;
<a name="l01393"></a>01393   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>;
<a name="l01394"></a>01394   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *b, *surrounding_static_block = 0;
<a name="l01395"></a>01395 
<a name="l01396"></a>01396   <span class="comment">/* Look through the partial symtabs for all symbols which begin by</span>
<a name="l01397"></a>01397 <span class="comment">     matching FUNC_NAME.  Make sure we read that symbol table in.  */</span>
<a name="l01398"></a>01398 
<a name="l01399"></a>01399   <a class="code" href="objfiles_8h.html#a8efee3b85a322006131a6056d45058b3">ALL_OBJFILES</a> (objfile)
<a name="l01400"></a>01400   {
<a name="l01401"></a>01401     <span class="keywordflow">if</span> (objfile-&gt;<a class="code" href="structobjfile.html#af6814df9c2fd1f669fd79d0b0c94262c">sf</a>)
<a name="l01402"></a>01402       objfile-&gt;<a class="code" href="structobjfile.html#af6814df9c2fd1f669fd79d0b0c94262c">sf</a>-&gt;<a class="code" href="structsym__fns.html#ae4cb3e689cab6e5ecf8e2fb8770b55b0">qf</a>-&gt;<a class="code" href="structquick__symbol__functions.html#a782e298a4e1d4e98876671ded4ede549">expand_symtabs_for_function</a> (objfile, func_name);
<a name="l01403"></a>01403   }
<a name="l01404"></a>01404 
<a name="l01405"></a>01405   <span class="comment">/* Search upwards from currently selected frame (so that we can</span>
<a name="l01406"></a>01406 <span class="comment">     complete on local vars.  */</span>
<a name="l01407"></a>01407 
<a name="l01408"></a>01408   <span class="keywordflow">for</span> (b = <a class="code" href="frame_8h.html#a91efbdcf182d840c28d378def97cfc23">get_selected_block</a> (0); b != NULL; b = <a class="code" href="block_8h.html#a8b7633ab6d6feadf9b2ee58e10ad8397">BLOCK_SUPERBLOCK</a> (b))
<a name="l01409"></a>01409     <a class="code" href="cp-support_8c.html#a72595ce2638139257bcb4cb4a4fc0d4f">make_symbol_overload_list_block</a> (func_name, b);
<a name="l01410"></a>01410 
<a name="l01411"></a>01411   surrounding_static_block = <a class="code" href="block_8c.html#a05911f60e374e7045638058c1ef6dfd1">block_static_block</a> (<a class="code" href="frame_8h.html#a91efbdcf182d840c28d378def97cfc23">get_selected_block</a> (0));
<a name="l01412"></a>01412 
<a name="l01413"></a>01413   <span class="comment">/* Go through the symtabs and check the externs and statics for</span>
<a name="l01414"></a>01414 <span class="comment">     symbols which match.  */</span>
<a name="l01415"></a>01415 
<a name="l01416"></a>01416   <a class="code" href="objfiles_8h.html#ac80c9acdada8be123653694d316dc247">ALL_PRIMARY_SYMTABS</a> (objfile, s)
<a name="l01417"></a>01417   {
<a name="l01418"></a>01418     <a class="code" href="defs_8h.html#ad24e2b54375e12474e65ebf7175988fb">QUIT</a>;
<a name="l01419"></a>01419     b = <a class="code" href="block_8h.html#a84c4a3aa7b6b4d9a127a1c018dd6a776">BLOCKVECTOR_BLOCK</a> (<a class="code" href="symtab_8h.html#a6cd84410d73680ff8006ac44b1b98a9c">BLOCKVECTOR</a> (s), <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124a973ee91cbe4b0cee4eb7603252a29bec">GLOBAL_BLOCK</a>);
<a name="l01420"></a>01420     <a class="code" href="cp-support_8c.html#a72595ce2638139257bcb4cb4a4fc0d4f">make_symbol_overload_list_block</a> (func_name, b);
<a name="l01421"></a>01421   }
<a name="l01422"></a>01422 
<a name="l01423"></a>01423   <a class="code" href="objfiles_8h.html#ac80c9acdada8be123653694d316dc247">ALL_PRIMARY_SYMTABS</a> (objfile, s)
<a name="l01424"></a>01424   {
<a name="l01425"></a>01425     <a class="code" href="defs_8h.html#ad24e2b54375e12474e65ebf7175988fb">QUIT</a>;
<a name="l01426"></a>01426     b = <a class="code" href="block_8h.html#a84c4a3aa7b6b4d9a127a1c018dd6a776">BLOCKVECTOR_BLOCK</a> (<a class="code" href="symtab_8h.html#a6cd84410d73680ff8006ac44b1b98a9c">BLOCKVECTOR</a> (s), <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124a4842990ca5391ee943c2069b28443a99">STATIC_BLOCK</a>);
<a name="l01427"></a>01427     <span class="comment">/* Don&#39;t do this block twice.  */</span>
<a name="l01428"></a>01428     <span class="keywordflow">if</span> (b == surrounding_static_block)
<a name="l01429"></a>01429       <span class="keywordflow">continue</span>;
<a name="l01430"></a>01430     <a class="code" href="cp-support_8c.html#a72595ce2638139257bcb4cb4a4fc0d4f">make_symbol_overload_list_block</a> (func_name, b);
<a name="l01431"></a>01431   }
<a name="l01432"></a>01432 }
<a name="l01433"></a>01433 
<a name="l01434"></a>01434 <span class="comment">/* Lookup the rtti type for a class name.  */</span>
<a name="l01435"></a>01435 
<a name="l01436"></a>01436 <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l01437"></a><a class="code" href="cp-support_8h.html#a523b6b6f7b17c4f51e593269aef92d6e">01437</a> <a class="code" href="cp-support_8c.html#a523b6b6f7b17c4f51e593269aef92d6e">cp_lookup_rtti_type</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>)
<a name="l01438"></a>01438 {
<a name="l01439"></a>01439   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> * rtti_sym;
<a name="l01440"></a>01440   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> * rtti_type;
<a name="l01441"></a>01441 
<a name="l01442"></a>01442   rtti_sym = <a class="code" href="symtab_8c.html#a8a5c3f803198aed047a55c0e4f61b315">lookup_symbol</a> (name, block, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa1f05a16e681efd2e892974878c353f11">STRUCT_DOMAIN</a>, NULL);
<a name="l01443"></a>01443 
<a name="l01444"></a>01444   <span class="keywordflow">if</span> (rtti_sym == NULL)
<a name="l01445"></a>01445     {
<a name="l01446"></a>01446       <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;RTTI symbol not found for class &#39;%s&#39;&quot;</span>), name);
<a name="l01447"></a>01447       <span class="keywordflow">return</span> NULL;
<a name="l01448"></a>01448     }
<a name="l01449"></a>01449 
<a name="l01450"></a>01450   <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (rtti_sym) != <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>)
<a name="l01451"></a>01451     {
<a name="l01452"></a>01452       <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;RTTI symbol for class &#39;%s&#39; is not a type&quot;</span>), name);
<a name="l01453"></a>01453       <span class="keywordflow">return</span> NULL;
<a name="l01454"></a>01454     }
<a name="l01455"></a>01455 
<a name="l01456"></a>01456   rtti_type = <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (rtti_sym);
<a name="l01457"></a>01457 
<a name="l01458"></a>01458   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (rtti_type))
<a name="l01459"></a>01459     {
<a name="l01460"></a>01460     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a9f70b67b4d14548a879667f544eab4ef">TYPE_CODE_CLASS</a>:
<a name="l01461"></a>01461       <span class="keywordflow">break</span>;
<a name="l01462"></a>01462     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae5cdf73186d3029211503380f64949b6">TYPE_CODE_NAMESPACE</a>:
<a name="l01463"></a>01463       <span class="comment">/* chastain/2003-11-26: the symbol tables often contain fake</span>
<a name="l01464"></a>01464 <span class="comment">         symbols for namespaces with the same name as the struct.</span>
<a name="l01465"></a>01465 <span class="comment">         This warning is an indication of a bug in the lookup order</span>
<a name="l01466"></a>01466 <span class="comment">         or a bug in the way that the symbol tables are populated.  */</span>
<a name="l01467"></a>01467       <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;RTTI symbol for class &#39;%s&#39; is a namespace&quot;</span>), name);
<a name="l01468"></a>01468       <span class="keywordflow">return</span> NULL;
<a name="l01469"></a>01469     <span class="keywordflow">default</span>:
<a name="l01470"></a>01470       <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;RTTI symbol for class &#39;%s&#39; has bad type&quot;</span>), name);
<a name="l01471"></a>01471       <span class="keywordflow">return</span> NULL;
<a name="l01472"></a>01472     }
<a name="l01473"></a>01473 
<a name="l01474"></a>01474   <span class="keywordflow">return</span> rtti_type;
<a name="l01475"></a>01475 }
<a name="l01476"></a>01476 
<a name="l01477"></a>01477 <span class="comment">/* A wrapper for bfd_demangle.  */</span>
<a name="l01478"></a>01478 
<a name="l01479"></a>01479 <span class="keywordtype">char</span> *
<a name="l01480"></a><a class="code" href="cp-support_8h.html#aa3fac1cb74e2709738e9ab3af7aac6b6">01480</a> <a class="code" href="cp-support_8c.html#aa3fac1cb74e2709738e9ab3af7aac6b6">gdb_demangle</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keywordtype">int</span> options)
<a name="l01481"></a>01481 {
<a name="l01482"></a>01482   <span class="keywordflow">return</span> bfd_demangle (NULL, name, options);
<a name="l01483"></a>01483 }
<a name="l01484"></a>01484 
<a name="l01485"></a>01485 <span class="comment">/* Don&#39;t allow just &quot;maintenance cplus&quot;.  */</span>
<a name="l01486"></a>01486 
<a name="l01487"></a>01487 <span class="keyword">static</span>  <span class="keywordtype">void</span>
<a name="l01488"></a><a class="code" href="cp-support_8c.html#ac5f976c363ca20800af871dc327a2c22">01488</a> <a class="code" href="cp-support_8c.html#ac5f976c363ca20800af871dc327a2c22">maint_cplus_command</a> (<span class="keywordtype">char</span> *arg, <span class="keywordtype">int</span> from_tty)
<a name="l01489"></a>01489 {
<a name="l01490"></a>01490   <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\&quot;maintenance cplus\&quot; must be followed &quot;</span>
<a name="l01491"></a>01491                        <span class="stringliteral">&quot;by the name of a command.\n&quot;</span>));
<a name="l01492"></a>01492   <a class="code" href="cli-decode_8c.html#a2ae762f5189f3597666852868defc038">help_list</a> (maint_cplus_cmd_list,
<a name="l01493"></a>01493              <span class="stringliteral">&quot;maintenance cplus &quot;</span>,
<a name="l01494"></a>01494              -1, <a class="code" href="main_8c.html#a41a2b997ba5454df787d61f051dd918c">gdb_stdout</a>);
<a name="l01495"></a>01495 }
<a name="l01496"></a>01496 
<a name="l01497"></a>01497 <span class="comment">/* This is a front end for cp_find_first_component, for unit testing.</span>
<a name="l01498"></a>01498 <span class="comment">   Be careful when using it: see the NOTE above</span>
<a name="l01499"></a>01499 <span class="comment">   cp_find_first_component.  */</span>
<a name="l01500"></a>01500 
<a name="l01501"></a>01501 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01502"></a><a class="code" href="cp-support_8c.html#a6bc3e0d9410908a36b5015576e434171">01502</a> <a class="code" href="cp-support_8c.html#a6bc3e0d9410908a36b5015576e434171">first_component_command</a> (<span class="keywordtype">char</span> *arg, <span class="keywordtype">int</span> from_tty)
<a name="l01503"></a>01503 {
<a name="l01504"></a>01504   <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;  
<a name="l01505"></a>01505   <span class="keywordtype">char</span> *prefix; 
<a name="l01506"></a>01506 
<a name="l01507"></a>01507   <span class="keywordflow">if</span> (!arg)
<a name="l01508"></a>01508     <span class="keywordflow">return</span>;
<a name="l01509"></a>01509 
<a name="l01510"></a>01510   len = <a class="code" href="cp-support_8c.html#a9220248a41cd63dc5f0a64d5222cd623">cp_find_first_component</a> (arg);
<a name="l01511"></a>01511   prefix = alloca (len + 1);
<a name="l01512"></a>01512 
<a name="l01513"></a>01513   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (prefix, arg, len);
<a name="l01514"></a>01514   prefix[<a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l01515"></a>01515 
<a name="l01516"></a>01516   <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<span class="stringliteral">&quot;%s\n&quot;</span>, prefix);
<a name="l01517"></a>01517 }
<a name="l01518"></a>01518 
<a name="l01519"></a>01519 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#a686ed07d4fdcdc366f2bc677216ca08d">initialize_file_ftype</a> <a class="code" href="cp-support_8c.html#a6cc853ed2516480cb57d0009f8c8685a">_initialize_cp_support</a>; <span class="comment">/* -Wmissing-prototypes */</span>
<a name="l01520"></a>01520 
<a name="l01521"></a>01521 
<a name="l01522"></a>01522 <span class="comment">/* Implement &quot;info vtbl&quot;.  */</span>
<a name="l01523"></a>01523 
<a name="l01524"></a>01524 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01525"></a><a class="code" href="cp-support_8c.html#a5ca9a4373307adb945ec9c265076969d">01525</a> <a class="code" href="cp-support_8c.html#a5ca9a4373307adb945ec9c265076969d">info_vtbl_command</a> (<span class="keywordtype">char</span> *arg, <span class="keywordtype">int</span> from_tty)
<a name="l01526"></a>01526 {
<a name="l01527"></a>01527   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html">value</a>;
<a name="l01528"></a>01528 
<a name="l01529"></a>01529   value = <a class="code" href="eval_8c.html#a4e744c8c383f947f6e3da4112541c2f7">parse_and_eval</a> (arg);
<a name="l01530"></a>01530   <a class="code" href="cp-abi_8c.html#a1f236467c134925e304d51007a6c2eaf">cplus_print_vtable</a> (value);
<a name="l01531"></a>01531 }
<a name="l01532"></a>01532 
<a name="l01533"></a>01533 <span class="keywordtype">void</span>
<a name="l01534"></a><a class="code" href="cp-support_8c.html#a17f621e19b260923e278bd5080bb4e2f">01534</a> <a class="code" href="cp-support_8c.html#a6cc853ed2516480cb57d0009f8c8685a">_initialize_cp_support</a> (<span class="keywordtype">void</span>)
<a name="l01535"></a>01535 {
<a name="l01536"></a>01536   <a class="code" href="cli-decode_8c.html#a8abc1e9af59eb3cb12bb03977d5e8e5a">add_prefix_cmd</a> (<span class="stringliteral">&quot;cplus&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a502c7b57c7172ac88ef735f68070bb59">class_maintenance</a>,
<a name="l01537"></a>01537                   <a class="code" href="cp-support_8c.html#ac5f976c363ca20800af871dc327a2c22">maint_cplus_command</a>,
<a name="l01538"></a>01538                   <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;C++ maintenance commands.&quot;</span>),
<a name="l01539"></a>01539                   &amp;maint_cplus_cmd_list,
<a name="l01540"></a>01540                   <span class="stringliteral">&quot;maintenance cplus &quot;</span>,
<a name="l01541"></a>01541                   0, &amp;<a class="code" href="cli-cmds_8c.html#ab063b8cc1899a71b24df72922339d766">maintenancelist</a>);
<a name="l01542"></a>01542   <a class="code" href="cli-decode_8c.html#a81a250b03b0a6626b31d35be82961c38">add_alias_cmd</a> (<span class="stringliteral">&quot;cp&quot;</span>, <span class="stringliteral">&quot;cplus&quot;</span>,
<a name="l01543"></a>01543                  <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a502c7b57c7172ac88ef735f68070bb59">class_maintenance</a>, 1,
<a name="l01544"></a>01544                  &amp;<a class="code" href="cli-cmds_8c.html#ab063b8cc1899a71b24df72922339d766">maintenancelist</a>);
<a name="l01545"></a>01545 
<a name="l01546"></a>01546   <a class="code" href="cli-decode_8c.html#ab87b0ba51ed9aa4c8aac0c96373537f8">add_cmd</a> (<span class="stringliteral">&quot;first_component&quot;</span>,
<a name="l01547"></a>01547            <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a502c7b57c7172ac88ef735f68070bb59">class_maintenance</a>,
<a name="l01548"></a>01548            <a class="code" href="cp-support_8c.html#a6bc3e0d9410908a36b5015576e434171">first_component_command</a>,
<a name="l01549"></a>01549            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Print the first class/namespace component of NAME.&quot;</span>),
<a name="l01550"></a>01550            &amp;maint_cplus_cmd_list);
<a name="l01551"></a>01551 
<a name="l01552"></a>01552   <a class="code" href="cli-decode_8c.html#a9f6cd2f7798c32a7a27cab617e71cf6a">add_info</a> (<span class="stringliteral">&quot;vtbl&quot;</span>, <a class="code" href="cp-support_8c.html#a5ca9a4373307adb945ec9c265076969d">info_vtbl_command</a>,
<a name="l01553"></a>01553             <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Show the virtual function table for a C++ object.\n\</span>
<a name="l01554"></a>01554 <span class="stringliteral">Usage: info vtbl EXPRESSION\n\</span>
<a name="l01555"></a>01555 <span class="stringliteral">Evaluate EXPRESSION and display the virtual function table for the\n\</span>
<a name="l01556"></a>01556 <span class="stringliteral">resulting object.&quot;</span>));
<a name="l01557"></a>01557 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:13:24 for GDB (xrefs) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
