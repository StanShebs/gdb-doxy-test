<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (xrefs): /home/stan/gdb/src/gdb/dwarf2read.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (xrefs)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/dwarf2read.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="dwarf2read_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* DWARF 2 debugging format support for GDB.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 1994-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,</span>
<a name="l00006"></a>00006 <span class="comment">   Inc.  with support from Florida State University (under contract</span>
<a name="l00007"></a>00007 <span class="comment">   with the Ada Joint Program Office), and Silicon Graphics, Inc.</span>
<a name="l00008"></a>00008 <span class="comment">   Initial contribution by Brent Benson, Harris Computer Systems, Inc.,</span>
<a name="l00009"></a>00009 <span class="comment">   based on Fred Fish&#39;s (Cygnus Support) implementation of DWARF 1</span>
<a name="l00010"></a>00010 <span class="comment">   support.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   This file is part of GDB.</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00015"></a>00015 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00016"></a>00016 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00017"></a>00017 <span class="comment">   (at your option) any later version.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00020"></a>00020 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00021"></a>00021 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00022"></a>00022 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00023"></a>00023 <span class="comment"></span>
<a name="l00024"></a>00024 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00025"></a>00025 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment">/* FIXME: Various die-reading functions need to be more careful with</span>
<a name="l00028"></a>00028 <span class="comment">   reading off the end of the section.</span>
<a name="l00029"></a>00029 <span class="comment">   E.g., load_partial_dies, read_partial_die.  */</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;bfd.h&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;elf-bfd.h&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="gdbtypes_8h.html">gdbtypes.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="objfiles_8h.html">objfiles.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;dwarf2.h&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="buildsym_8h.html">buildsym.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;demangle.h&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="gdb-demangle_8h.html">gdb-demangle.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="expression_8h.html">expression.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;filenames.h&quot;</span>  <span class="comment">/* for DOSish file names */</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="macrotab_8h.html">macrotab.h</a>&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="language_8h.html">language.h</a>&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="complaints_8h.html">complaints.h</a>&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;<a class="code" href="bcache_8h.html">bcache.h</a>&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="dwarf2expr_8h.html">dwarf2expr.h</a>&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="dwarf2loc_8h.html">dwarf2loc.h</a>&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;<a class="code" href="cp-support_8h.html">cp-support.h</a>&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;hashtab.h&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;<a class="code" href="command_8h.html">command.h</a>&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;<a class="code" href="gdbcmd_8h.html">gdbcmd.h</a>&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;<a class="code" href="block_8h.html">block.h</a>&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;<a class="code" href="addrmap_8h.html">addrmap.h</a>&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;<a class="code" href="typeprint_8h.html">typeprint.h</a>&quot;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &quot;<a class="code" href="jv-lang_8h.html">jv-lang.h</a>&quot;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &quot;<a class="code" href="psympriv_8h.html">psympriv.h</a>&quot;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &quot;<a class="code" href="exceptions_8h.html">exceptions.h</a>&quot;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &quot;<a class="code" href="gdb__stat_8h.html">gdb_stat.h</a>&quot;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &quot;<a class="code" href="completer_8h.html">completer.h</a>&quot;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &quot;<a class="code" href="vec_8h.html">vec.h</a>&quot;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &quot;<a class="code" href="c-lang_8h.html">c-lang.h</a>&quot;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &quot;<a class="code" href="go-lang_8h.html">go-lang.h</a>&quot;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &quot;<a class="code" href="valprint_8h.html">valprint.h</a>&quot;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &quot;<a class="code" href="gdbcore_8h.html">gdbcore.h</a>&quot;</span> <span class="comment">/* for gnutarget */</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &quot;gdb/gdb-index.h&quot;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &quot;<a class="code" href="gdb__bfd_8h.html">gdb_bfd.h</a>&quot;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &quot;<a class="code" href="f-lang_8h.html">f-lang.h</a>&quot;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &quot;<a class="code" href="source_8h.html">source.h</a>&quot;</span>
<a name="l00071"></a>00071 <span class="preprocessor">#include &quot;<a class="code" href="filestuff_8h.html">filestuff.h</a>&quot;</span>
<a name="l00072"></a>00072 <span class="preprocessor">#include &quot;<a class="code" href="build-id_8h.html">build-id.h</a>&quot;</span>
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
<a name="l00075"></a>00075 <span class="preprocessor">#include &quot;<a class="code" href="gdb__string_8h.html">gdb_string.h</a>&quot;</span>
<a name="l00076"></a>00076 <span class="preprocessor">#include &quot;<a class="code" href="gdb__assert_8h.html">gdb_assert.h</a>&quot;</span>
<a name="l00077"></a>00077 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00078"></a>00078 
<a name="l00079"></a><a class="code" href="dwarf2read_8c.html#af4cfb57f8a20c4f02a52ca8959d1f718">00079</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *<a class="code" href="dwarf2read_8c.html#af4cfb57f8a20c4f02a52ca8959d1f718">symbolp</a>;
<a name="l00080"></a>00080 <a class="code" href="vec_8h.html#af9d77557e51db07808428f28a3559803">DEF_VEC_P</a> (symbolp);
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 <span class="comment">/* When non-zero, print basic high level tracing messages.</span>
<a name="l00083"></a>00083 <span class="comment">   This is in contrast to the low level DIE reading of dwarf2_die_debug.  */</span>
<a name="l00084"></a><a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">00084</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a> = 0;
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="comment">/* When non-zero, dump DIEs after they are read in.  */</span>
<a name="l00087"></a><a class="code" href="dwarf2read_8c.html#a1a718830b2084a029498b587ad66aeae">00087</a> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a1a718830b2084a029498b587ad66aeae">dwarf2_die_debug</a> = 0;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="comment">/* When non-zero, cross-check physname against demangler.  */</span>
<a name="l00090"></a><a class="code" href="dwarf2read_8c.html#ab19a913cb7d8473545da6cb3149bc1ad">00090</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#ab19a913cb7d8473545da6cb3149bc1ad">check_physname</a> = 0;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="comment">/* When non-zero, do not reject deprecated .gdb_index sections.  */</span>
<a name="l00093"></a><a class="code" href="dwarf2read_8c.html#a0a43a194f055955e1de1eb7be957096f">00093</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a0a43a194f055955e1de1eb7be957096f">use_deprecated_index_sections</a> = 0;
<a name="l00094"></a>00094 
<a name="l00095"></a><a class="code" href="dwarf2read_8c.html#a9fcfdd623d890b4c3b4ac0ba42e7df4b">00095</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>objfile_data *<a class="code" href="dwarf2read_8c.html#a9fcfdd623d890b4c3b4ac0ba42e7df4b">dwarf2_objfile_data_key</a>;
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="comment">/* The &quot;aclass&quot; indices for various kinds of computed DWARF symbols.  */</span>
<a name="l00098"></a>00098 
<a name="l00099"></a><a class="code" href="dwarf2read_8c.html#a52b4c75a920c1e0dbff24148745bc8ca">00099</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a52b4c75a920c1e0dbff24148745bc8ca">dwarf2_locexpr_index</a>;
<a name="l00100"></a><a class="code" href="dwarf2read_8c.html#a3e79ed48463ba20f601bd45aebff27df">00100</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a3e79ed48463ba20f601bd45aebff27df">dwarf2_loclist_index</a>;
<a name="l00101"></a><a class="code" href="dwarf2read_8c.html#a4cc0c49c12a38ac40188b11401c91db5">00101</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a4cc0c49c12a38ac40188b11401c91db5">dwarf2_locexpr_block_index</a>;
<a name="l00102"></a><a class="code" href="dwarf2read_8c.html#a5eb136e90359757c6d4c7769be39145a">00102</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a5eb136e90359757c6d4c7769be39145a">dwarf2_loclist_block_index</a>;
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="comment">/* A descriptor for dwarf sections.</span>
<a name="l00105"></a>00105 <span class="comment"></span>
<a name="l00106"></a>00106 <span class="comment">   S.ASECTION, SIZE are typically initialized when the objfile is first</span>
<a name="l00107"></a>00107 <span class="comment">   scanned.  BUFFER, READIN are filled in later when the section is read.</span>
<a name="l00108"></a>00108 <span class="comment">   If the section contained compressed data then SIZE is updated to record</span>
<a name="l00109"></a>00109 <span class="comment">   the uncompressed size of the section.</span>
<a name="l00110"></a>00110 <span class="comment"></span>
<a name="l00111"></a>00111 <span class="comment">   DWP file format V2 introduces a wrinkle that is easiest to handle by</span>
<a name="l00112"></a>00112 <span class="comment">   creating the concept of virtual sections contained within a real section.</span>
<a name="l00113"></a>00113 <span class="comment">   In DWP V2 the sections of the input DWO files are concatenated together</span>
<a name="l00114"></a>00114 <span class="comment">   into one section, but section offsets are kept relative to the original</span>
<a name="l00115"></a>00115 <span class="comment">   input section.</span>
<a name="l00116"></a>00116 <span class="comment">   If this is a virtual dwp-v2 section, S.CONTAINING_SECTION is a backlink to</span>
<a name="l00117"></a>00117 <span class="comment">   the real section this &quot;virtual&quot; section is contained in, and BUFFER,SIZE</span>
<a name="l00118"></a>00118 <span class="comment">   describe the virtual section.  */</span>
<a name="l00119"></a>00119 
<a name="l00120"></a><a class="code" href="structdwarf2__section__info.html">00120</a> <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a>
<a name="l00121"></a>00121 {
<a name="l00122"></a>00122   <span class="keyword">union</span>
<a name="l00123"></a>00123   {
<a name="l00124"></a>00124     <span class="comment">/* If this is a real section, the bfd section.  */</span>
<a name="l00125"></a><a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">00125</a>     <a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> *<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a>;
<a name="l00126"></a>00126     <span class="comment">/* If this is a virtual section, pointer to the containing (&quot;real&quot;)</span>
<a name="l00127"></a>00127 <span class="comment">       section.  */</span>
<a name="l00128"></a><a class="code" href="structdwarf2__section__info.html#a57c7432f009d2575fa1b3961bf80e912">00128</a>     <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *<a class="code" href="structdwarf2__section__info.html#a57c7432f009d2575fa1b3961bf80e912">containing_section</a>;
<a name="l00129"></a>00129   } <a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>;
<a name="l00130"></a>00130   <span class="comment">/* Pointer to section data, only valid if readin.  */</span>
<a name="l00131"></a><a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">00131</a>   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>;
<a name="l00132"></a>00132   <span class="comment">/* The size of the section, real or virtual.  */</span>
<a name="l00133"></a><a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">00133</a>   bfd_size_type <a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>;
<a name="l00134"></a>00134   <span class="comment">/* If this is a virtual section, the offset in the real section.</span>
<a name="l00135"></a>00135 <span class="comment">     Only valid if is_virtual.  */</span>
<a name="l00136"></a><a class="code" href="structdwarf2__section__info.html#a28b1e09df667dbfed7cc7f7a9e8f7e7e">00136</a>   bfd_size_type <a class="code" href="structdwarf2__section__info.html#a28b1e09df667dbfed7cc7f7a9e8f7e7e">virtual_offset</a>;
<a name="l00137"></a>00137   <span class="comment">/* True if we have tried to read this section.  */</span>
<a name="l00138"></a><a class="code" href="structdwarf2__section__info.html#ae115f99a7eba2f52b75574809537e723">00138</a>   <span class="keywordtype">char</span> <a class="code" href="structdwarf2__section__info.html#ae115f99a7eba2f52b75574809537e723">readin</a>;
<a name="l00139"></a>00139   <span class="comment">/* True if this is a virtual section, False otherwise.</span>
<a name="l00140"></a>00140 <span class="comment">     This specifies which of s.asection and s.containing_section to use.  */</span>
<a name="l00141"></a><a class="code" href="structdwarf2__section__info.html#a580140de2ff419885dd24bfc36862b48">00141</a>   <span class="keywordtype">char</span> <a class="code" href="structdwarf2__section__info.html#a580140de2ff419885dd24bfc36862b48">is_virtual</a>;
<a name="l00142"></a>00142 };
<a name="l00143"></a>00143 
<a name="l00144"></a><a class="code" href="dwarf2read_8c.html#a846f1994ff34968f2f5b5f41d5ae3a38">00144</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>;
<a name="l00145"></a>00145 <a class="code" href="vec_8h.html#abc2d38563a8b5bed340654cf06060f11">DEF_VEC_O</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>);
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="comment">/* All offsets in the index are of this type.  It must be</span>
<a name="l00148"></a>00148 <span class="comment">   architecture-independent.  */</span>
<a name="l00149"></a><a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">00149</a> <span class="keyword">typedef</span> uint32_t <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <a class="code" href="vec_8h.html#a132f1333e64143af97c40ec9d9bd6956">DEF_VEC_I</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>);
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="comment">/* Ensure only legit values are used.  */</span>
<a name="l00154"></a><a class="code" href="dwarf2read_8c.html#a26eda357e574747a050ac7622002f3cd">00154</a> <span class="preprocessor">#define DW2_GDB_INDEX_SYMBOL_STATIC_SET_VALUE(cu_index, value) \</span>
<a name="l00155"></a>00155 <span class="preprocessor">  do { \</span>
<a name="l00156"></a>00156 <span class="preprocessor">    gdb_assert ((unsigned int) (value) &lt;= 1); \</span>
<a name="l00157"></a>00157 <span class="preprocessor">    GDB_INDEX_SYMBOL_STATIC_SET_VALUE((cu_index), (value)); \</span>
<a name="l00158"></a>00158 <span class="preprocessor">  } while (0)</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>
<a name="l00160"></a>00160 <span class="comment">/* Ensure only legit values are used.  */</span>
<a name="l00161"></a><a class="code" href="dwarf2read_8c.html#a601a861ff857c55b64e41f2c78684641">00161</a> <span class="preprocessor">#define DW2_GDB_INDEX_SYMBOL_KIND_SET_VALUE(cu_index, value) \</span>
<a name="l00162"></a>00162 <span class="preprocessor">  do { \</span>
<a name="l00163"></a>00163 <span class="preprocessor">    gdb_assert ((value) &gt;= GDB_INDEX_SYMBOL_KIND_TYPE \</span>
<a name="l00164"></a>00164 <span class="preprocessor">                &amp;&amp; (value) &lt;= GDB_INDEX_SYMBOL_KIND_OTHER); \</span>
<a name="l00165"></a>00165 <span class="preprocessor">    GDB_INDEX_SYMBOL_KIND_SET_VALUE((cu_index), (value)); \</span>
<a name="l00166"></a>00166 <span class="preprocessor">  } while (0)</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span>
<a name="l00168"></a>00168 <span class="comment">/* Ensure we don&#39;t use more than the alloted nuber of bits for the CU.  */</span>
<a name="l00169"></a><a class="code" href="dwarf2read_8c.html#aa3a7f3b66e193362a9af82eaebd585d1">00169</a> <span class="preprocessor">#define DW2_GDB_INDEX_CU_SET_VALUE(cu_index, value) \</span>
<a name="l00170"></a>00170 <span class="preprocessor">  do { \</span>
<a name="l00171"></a>00171 <span class="preprocessor">    gdb_assert (((value) &amp; ~GDB_INDEX_CU_MASK) == 0); \</span>
<a name="l00172"></a>00172 <span class="preprocessor">    GDB_INDEX_CU_SET_VALUE((cu_index), (value)); \</span>
<a name="l00173"></a>00173 <span class="preprocessor">  } while (0)</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span>
<a name="l00175"></a>00175 <span class="comment">/* A description of the mapped index.  The file format is described in</span>
<a name="l00176"></a>00176 <span class="comment">   a comment by the code that writes the index.  */</span>
<a name="l00177"></a><a class="code" href="structmapped__index.html">00177</a> <span class="keyword">struct </span><a class="code" href="structmapped__index.html">mapped_index</a>
<a name="l00178"></a>00178 {
<a name="l00179"></a>00179   <span class="comment">/* Index data format version.  */</span>
<a name="l00180"></a><a class="code" href="structmapped__index.html#a6204ce2b69334c8d243357d524858ccd">00180</a>   <span class="keywordtype">int</span> <a class="code" href="structmapped__index.html#a6204ce2b69334c8d243357d524858ccd">version</a>;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182   <span class="comment">/* The total length of the buffer.  */</span>
<a name="l00183"></a><a class="code" href="structmapped__index.html#a11c53f2d9e8ca2194ea0f0a7fd18d8f5">00183</a>   off_t <a class="code" href="structmapped__index.html#a11c53f2d9e8ca2194ea0f0a7fd18d8f5">total_size</a>;
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   <span class="comment">/* A pointer to the address table data.  */</span>
<a name="l00186"></a><a class="code" href="structmapped__index.html#a2de47f34aaf83fd1677f34ae9c405bdc">00186</a>   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structmapped__index.html#a2de47f34aaf83fd1677f34ae9c405bdc">address_table</a>;
<a name="l00187"></a>00187 
<a name="l00188"></a>00188   <span class="comment">/* Size of the address table data in bytes.  */</span>
<a name="l00189"></a><a class="code" href="structmapped__index.html#a6715a56da889a4b7d94ede0d14c1b8ba">00189</a>   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> <a class="code" href="structmapped__index.html#a6715a56da889a4b7d94ede0d14c1b8ba">address_table_size</a>;
<a name="l00190"></a>00190 
<a name="l00191"></a>00191   <span class="comment">/* The symbol table, implemented as a hash table.  */</span>
<a name="l00192"></a><a class="code" href="structmapped__index.html#af7415bd86bc9cfb1ba447c40762e5045">00192</a>   <span class="keyword">const</span> <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> *<a class="code" href="structmapped__index.html#af7415bd86bc9cfb1ba447c40762e5045">symbol_table</a>;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194   <span class="comment">/* Size in slots, each slot is 2 offset_types.  */</span>
<a name="l00195"></a><a class="code" href="structmapped__index.html#a3e01c3306b6fd1f53604a4f0856013f3">00195</a>   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> <a class="code" href="structmapped__index.html#a3e01c3306b6fd1f53604a4f0856013f3">symbol_table_slots</a>;
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   <span class="comment">/* A pointer to the constant pool.  */</span>
<a name="l00198"></a><a class="code" href="structmapped__index.html#a3f51d3222825ba2465d4c73f2d364cc1">00198</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structmapped__index.html#a3f51d3222825ba2465d4c73f2d364cc1">constant_pool</a>;
<a name="l00199"></a>00199 };
<a name="l00200"></a>00200 
<a name="l00201"></a><a class="code" href="dwarf2read_8c.html#ac512041155835494b9413965186d1da1">00201</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *<a class="code" href="dwarf2read_8c.html#ac512041155835494b9413965186d1da1">dwarf2_per_cu_ptr</a>;
<a name="l00202"></a>00202 <a class="code" href="vec_8h.html#af9d77557e51db07808428f28a3559803">DEF_VEC_P</a> (dwarf2_per_cu_ptr);
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="comment">/* Collection of data recorded per objfile.</span>
<a name="l00205"></a>00205 <span class="comment">   This hangs off of dwarf2_objfile_data_key.  */</span>
<a name="l00206"></a>00206 
<a name="l00207"></a><a class="code" href="structdwarf2__per__objfile.html">00207</a> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__objfile.html">dwarf2_per_objfile</a>
<a name="l00208"></a>00208 {
<a name="l00209"></a><a class="code" href="structdwarf2__per__objfile.html#ac4a5ed6e3f9908d638032ba24040a0b9">00209</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwarf2__per__objfile.html#ac4a5ed6e3f9908d638032ba24040a0b9">info</a>;
<a name="l00210"></a><a class="code" href="structdwarf2__per__objfile.html#a65f092d6a408e872a5b5f724728353de">00210</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwarf2__per__objfile.html#a65f092d6a408e872a5b5f724728353de">abbrev</a>;
<a name="l00211"></a><a class="code" href="structdwarf2__per__objfile.html#a79ce82df68fb97ec19e6860fdf9c729a">00211</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwarf2__per__objfile.html#a79ce82df68fb97ec19e6860fdf9c729a">line</a>;
<a name="l00212"></a><a class="code" href="structdwarf2__per__objfile.html#a13750fe533c751c64de32245c5617623">00212</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwarf2__per__objfile.html#a13750fe533c751c64de32245c5617623">loc</a>;
<a name="l00213"></a><a class="code" href="structdwarf2__per__objfile.html#a171eb0e6180390364c7907b187c923fc">00213</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwarf2__per__objfile.html#a171eb0e6180390364c7907b187c923fc">macinfo</a>;
<a name="l00214"></a><a class="code" href="structdwarf2__per__objfile.html#ab96c1115af7d65e9ca3912d1dc68803d">00214</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwarf2__per__objfile.html#ab96c1115af7d65e9ca3912d1dc68803d">macro</a>;
<a name="l00215"></a><a class="code" href="structdwarf2__per__objfile.html#aa102f0528a3f536a3e96802d8e76cc6b">00215</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwarf2__per__objfile.html#aa102f0528a3f536a3e96802d8e76cc6b">str</a>;
<a name="l00216"></a><a class="code" href="structdwarf2__per__objfile.html#a654a21dc8afa0f2dee30874b781462b0">00216</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwarf2__per__objfile.html#a654a21dc8afa0f2dee30874b781462b0">ranges</a>;
<a name="l00217"></a><a class="code" href="structdwarf2__per__objfile.html#a51717beb2e74eb048118463e0030a16f">00217</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwarf2__per__objfile.html#a51717beb2e74eb048118463e0030a16f">addr</a>;
<a name="l00218"></a><a class="code" href="structdwarf2__per__objfile.html#a4660d1b013f5514a60d8c74dd9483aa8">00218</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwarf2__per__objfile.html#a4660d1b013f5514a60d8c74dd9483aa8">frame</a>;
<a name="l00219"></a><a class="code" href="structdwarf2__per__objfile.html#a91415d7c88bb86ffe701ef532ab0525f">00219</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwarf2__per__objfile.html#a91415d7c88bb86ffe701ef532ab0525f">eh_frame</a>;
<a name="l00220"></a><a class="code" href="structdwarf2__per__objfile.html#a7dccae22ec3934fe5491ca6782d21cdd">00220</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwarf2__per__objfile.html#a7dccae22ec3934fe5491ca6782d21cdd">gdb_index</a>;
<a name="l00221"></a>00221 
<a name="l00222"></a><a class="code" href="structdwarf2__per__objfile.html#a79df6353ba5d903c8e3a5b8cce3e8754">00222</a>   <a class="code" href="structdwarf2__per__objfile.html#a79df6353ba5d903c8e3a5b8cce3e8754">VEC</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>) *types;
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   <span class="comment">/* Back link.  */</span>
<a name="l00225"></a>00225   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>;
<a name="l00226"></a>00226 
<a name="l00227"></a>00227   <span class="comment">/* Table of all the compilation units.  This is used to locate</span>
<a name="l00228"></a>00228 <span class="comment">     the target compilation unit of a particular reference.  */</span>
<a name="l00229"></a>00229   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> **all_comp_units;
<a name="l00230"></a>00230 
<a name="l00231"></a>00231   <span class="comment">/* The number of compilation units in ALL_COMP_UNITS.  */</span>
<a name="l00232"></a>00232   <span class="keywordtype">int</span> n_comp_units;
<a name="l00233"></a>00233 
<a name="l00234"></a>00234   <span class="comment">/* The number of .debug_types-related CUs.  */</span>
<a name="l00235"></a>00235   <span class="keywordtype">int</span> n_type_units;
<a name="l00236"></a>00236 
<a name="l00237"></a>00237   <span class="comment">/* The .debug_types-related CUs (TUs).</span>
<a name="l00238"></a>00238 <span class="comment">     This is stored in malloc space because we may realloc it.  */</span>
<a name="l00239"></a>00239   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> **all_type_units;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241   <span class="comment">/* The number of entries in all_type_unit_groups.  */</span>
<a name="l00242"></a>00242   <span class="keywordtype">int</span> n_type_unit_groups;
<a name="l00243"></a>00243 
<a name="l00244"></a>00244   <span class="comment">/* Table of type unit groups.</span>
<a name="l00245"></a>00245 <span class="comment">     This exists to make it easy to iterate over all CUs and TU groups.  */</span>
<a name="l00246"></a>00246   <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> **all_type_unit_groups;
<a name="l00247"></a>00247 
<a name="l00248"></a>00248   <span class="comment">/* Table of struct type_unit_group objects.</span>
<a name="l00249"></a>00249 <span class="comment">     The hash key is the DW_AT_stmt_list value.  */</span>
<a name="l00250"></a>00250   htab_t type_unit_groups;
<a name="l00251"></a>00251 
<a name="l00252"></a>00252   <span class="comment">/* A table mapping .debug_types signatures to its signatured_type entry.</span>
<a name="l00253"></a>00253 <span class="comment">     This is NULL if the .debug_types section hasn&#39;t been read in yet.  */</span>
<a name="l00254"></a>00254   htab_t signatured_types;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256   <span class="comment">/* Type unit statistics, to see how well the scaling improvements</span>
<a name="l00257"></a>00257 <span class="comment">     are doing.  */</span>
<a name="l00258"></a>00258   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__objfile.html#a8400b6ac2dd6967c4652daf45c991590">tu_stats</a>
<a name="l00259"></a>00259   {
<a name="l00260"></a>00260     <span class="keywordtype">int</span> nr_uniq_abbrev_tables;
<a name="l00261"></a>00261     <span class="keywordtype">int</span> nr_symtabs;
<a name="l00262"></a>00262     <span class="keywordtype">int</span> nr_symtab_sharers;
<a name="l00263"></a>00263     <span class="keywordtype">int</span> nr_stmt_less_type_units;
<a name="l00264"></a><a class="code" href="structdwarf2__per__objfile.html#a8400b6ac2dd6967c4652daf45c991590">00264</a>   } <a class="code" href="structdwarf2__per__objfile.html#a8400b6ac2dd6967c4652daf45c991590">tu_stats</a>;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266   <span class="comment">/* A chain of compilation units that are currently read in, so that</span>
<a name="l00267"></a>00267 <span class="comment">     they can be freed later.  */</span>
<a name="l00268"></a><a class="code" href="structdwarf2__per__objfile.html#a250e2511524a3122ba1489978a303221">00268</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *<a class="code" href="structdwarf2__per__objfile.html#a250e2511524a3122ba1489978a303221">read_in_chain</a>;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270   <span class="comment">/* A table mapping DW_AT_dwo_name values to struct dwo_file objects.</span>
<a name="l00271"></a>00271 <span class="comment">     This is NULL if the table hasn&#39;t been allocated yet.  */</span>
<a name="l00272"></a><a class="code" href="structdwarf2__per__objfile.html#a647f8cdf79433f5d61ed1380e038757e">00272</a>   htab_t <a class="code" href="structdwarf2__per__objfile.html#a647f8cdf79433f5d61ed1380e038757e">dwo_files</a>;
<a name="l00273"></a>00273 
<a name="l00274"></a>00274   <span class="comment">/* Non-zero if we&#39;ve check for whether there is a DWP file.  */</span>
<a name="l00275"></a><a class="code" href="structdwarf2__per__objfile.html#af1cad9a614ed37e4fa3d55aaa8f08de3">00275</a>   <span class="keywordtype">int</span> <a class="code" href="structdwarf2__per__objfile.html#af1cad9a614ed37e4fa3d55aaa8f08de3">dwp_checked</a>;
<a name="l00276"></a>00276 
<a name="l00277"></a>00277   <span class="comment">/* The DWP file if there is one, or NULL.  */</span>
<a name="l00278"></a><a class="code" href="structdwarf2__per__objfile.html#ad0c5cd80616059507d792e8648026317">00278</a>   <span class="keyword">struct </span><a class="code" href="structdwp__file.html">dwp_file</a> *<a class="code" href="structdwarf2__per__objfile.html#ad0c5cd80616059507d792e8648026317">dwp_file</a>;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280   <span class="comment">/* The shared &#39;.dwz&#39; file, if one exists.  This is used when the</span>
<a name="l00281"></a>00281 <span class="comment">     original data was compressed using &#39;dwz -m&#39;.  */</span>
<a name="l00282"></a><a class="code" href="structdwarf2__per__objfile.html#ad4eb71f5b2a05e7cb7426df5a13cbb50">00282</a>   <span class="keyword">struct </span><a class="code" href="structdwz__file.html">dwz_file</a> *<a class="code" href="structdwarf2__per__objfile.html#ad4eb71f5b2a05e7cb7426df5a13cbb50">dwz_file</a>;
<a name="l00283"></a>00283 
<a name="l00284"></a>00284   <span class="comment">/* A flag indicating wether this objfile has a section loaded at a</span>
<a name="l00285"></a>00285 <span class="comment">     VMA of 0.  */</span>
<a name="l00286"></a><a class="code" href="structdwarf2__per__objfile.html#ab6b03c3a65fa04f04741158e8aebc895">00286</a>   <span class="keywordtype">int</span> <a class="code" href="structdwarf2__per__objfile.html#ab6b03c3a65fa04f04741158e8aebc895">has_section_at_zero</a>;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   <span class="comment">/* True if we are using the mapped index,</span>
<a name="l00289"></a>00289 <span class="comment">     or we are faking it for OBJF_READNOW&#39;s sake.  */</span>
<a name="l00290"></a><a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">00290</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a>;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292   <span class="comment">/* The mapped index, or NULL if .gdb_index is missing or not being used.  */</span>
<a name="l00293"></a><a class="code" href="structdwarf2__per__objfile.html#a1e58a614b6e77589e24dac14dfdc62e5">00293</a>   <span class="keyword">struct </span><a class="code" href="structmapped__index.html">mapped_index</a> *<a class="code" href="structdwarf2__per__objfile.html#a1e58a614b6e77589e24dac14dfdc62e5">index_table</a>;
<a name="l00294"></a>00294 
<a name="l00295"></a>00295   <span class="comment">/* When using index_table, this keeps track of all quick_file_names entries.</span>
<a name="l00296"></a>00296 <span class="comment">     TUs typically share line table entries with a CU, so we maintain a</span>
<a name="l00297"></a>00297 <span class="comment">     separate table of all line table entries to support the sharing.</span>
<a name="l00298"></a>00298 <span class="comment">     Note that while there can be way more TUs than CUs, we&#39;ve already</span>
<a name="l00299"></a>00299 <span class="comment">     sorted all the TUs into &quot;type unit groups&quot;, grouped by their</span>
<a name="l00300"></a>00300 <span class="comment">     DW_AT_stmt_list value.  Therefore the only sharing done here is with a</span>
<a name="l00301"></a>00301 <span class="comment">     CU and its associated TU group if there is one.  */</span>
<a name="l00302"></a><a class="code" href="structdwarf2__per__objfile.html#aeb96e928b0cd54363e459b10effcb0b3">00302</a>   htab_t <a class="code" href="structdwarf2__per__objfile.html#aeb96e928b0cd54363e459b10effcb0b3">quick_file_names_table</a>;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   <span class="comment">/* Set during partial symbol reading, to prevent queueing of full</span>
<a name="l00305"></a>00305 <span class="comment">     symbols.  */</span>
<a name="l00306"></a><a class="code" href="structdwarf2__per__objfile.html#a91e7a3d79383661130df87b91ef1e6c9">00306</a>   <span class="keywordtype">int</span> <a class="code" href="structdwarf2__per__objfile.html#a91e7a3d79383661130df87b91ef1e6c9">reading_partial_symbols</a>;
<a name="l00307"></a>00307 
<a name="l00308"></a>00308   <span class="comment">/* Table mapping type DIEs to their struct type *.</span>
<a name="l00309"></a>00309 <span class="comment">     This is NULL if not allocated yet.</span>
<a name="l00310"></a>00310 <span class="comment">     The mapping is done via (CU/TU + DIE offset) -&gt; type.  */</span>
<a name="l00311"></a><a class="code" href="structdwarf2__per__objfile.html#a4e97a72558a0e6cf369ede2776063aa8">00311</a>   htab_t <a class="code" href="structdwarf2__per__objfile.html#a4e97a72558a0e6cf369ede2776063aa8">die_type_hash</a>;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313   <span class="comment">/* The CUs we recently read.  */</span>
<a name="l00314"></a>00314   <a class="code" href="structdwarf2__per__objfile.html#a79df6353ba5d903c8e3a5b8cce3e8754">VEC</a> (dwarf2_per_cu_ptr) *just_read_cus;
<a name="l00315"></a>00315 };
<a name="l00316"></a>00316 
<a name="l00317"></a><a class="code" href="dwarf2read_8c.html#a176749e928fd8a65db91f793373f6544">00317</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__objfile.html">dwarf2_per_objfile</a> *<a class="code" href="dwarf2read_8c.html#a176749e928fd8a65db91f793373f6544">dwarf2_per_objfile</a>;
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="comment">/* Default names of the debugging sections.  */</span>
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 <span class="comment">/* Note that if the debugging section has been compressed, it might</span>
<a name="l00322"></a>00322 <span class="comment">   have a name like .zdebug_info.  */</span>
<a name="l00323"></a>00323 
<a name="l00324"></a><a class="code" href="dwarf2read_8c.html#a0fa6765b64d6d280522a4ff18e3da6f2">00324</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__debug__sections.html">dwarf2_debug_sections</a> <a class="code" href="dwarf2read_8c.html#a0fa6765b64d6d280522a4ff18e3da6f2">dwarf2_elf_names</a> =
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326   { <span class="stringliteral">&quot;.debug_info&quot;</span>, <span class="stringliteral">&quot;.zdebug_info&quot;</span> },
<a name="l00327"></a>00327   { <span class="stringliteral">&quot;.debug_abbrev&quot;</span>, <span class="stringliteral">&quot;.zdebug_abbrev&quot;</span> },
<a name="l00328"></a>00328   { <span class="stringliteral">&quot;.debug_line&quot;</span>, <span class="stringliteral">&quot;.zdebug_line&quot;</span> },
<a name="l00329"></a>00329   { <span class="stringliteral">&quot;.debug_loc&quot;</span>, <span class="stringliteral">&quot;.zdebug_loc&quot;</span> },
<a name="l00330"></a>00330   { <span class="stringliteral">&quot;.debug_macinfo&quot;</span>, <span class="stringliteral">&quot;.zdebug_macinfo&quot;</span> },
<a name="l00331"></a>00331   { <span class="stringliteral">&quot;.debug_macro&quot;</span>, <span class="stringliteral">&quot;.zdebug_macro&quot;</span> },
<a name="l00332"></a>00332   { <span class="stringliteral">&quot;.debug_str&quot;</span>, <span class="stringliteral">&quot;.zdebug_str&quot;</span> },
<a name="l00333"></a>00333   { <span class="stringliteral">&quot;.debug_ranges&quot;</span>, <span class="stringliteral">&quot;.zdebug_ranges&quot;</span> },
<a name="l00334"></a>00334   { <span class="stringliteral">&quot;.debug_types&quot;</span>, <span class="stringliteral">&quot;.zdebug_types&quot;</span> },
<a name="l00335"></a>00335   { <span class="stringliteral">&quot;.debug_addr&quot;</span>, <span class="stringliteral">&quot;.zdebug_addr&quot;</span> },
<a name="l00336"></a>00336   { <span class="stringliteral">&quot;.debug_frame&quot;</span>, <span class="stringliteral">&quot;.zdebug_frame&quot;</span> },
<a name="l00337"></a>00337   { <span class="stringliteral">&quot;.eh_frame&quot;</span>, NULL },
<a name="l00338"></a>00338   { <span class="stringliteral">&quot;.gdb_index&quot;</span>, <span class="stringliteral">&quot;.zgdb_index&quot;</span> },
<a name="l00339"></a>00339   23
<a name="l00340"></a>00340 };
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 <span class="comment">/* List of DWO/DWP sections.  */</span>
<a name="l00343"></a>00343 
<a name="l00344"></a><a class="code" href="structdwop__section__names.html">00344</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwop__section__names.html">dwop_section_names</a>
<a name="l00345"></a>00345 {
<a name="l00346"></a><a class="code" href="structdwop__section__names.html#ae59cc2816c3829d001953c78ff8cfdf5">00346</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__names.html">dwarf2_section_names</a> <a class="code" href="structdwop__section__names.html#ae59cc2816c3829d001953c78ff8cfdf5">abbrev_dwo</a>;
<a name="l00347"></a><a class="code" href="structdwop__section__names.html#abcabf332b0c04d0f422ed3011178f45e">00347</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__names.html">dwarf2_section_names</a> <a class="code" href="structdwop__section__names.html#abcabf332b0c04d0f422ed3011178f45e">info_dwo</a>;
<a name="l00348"></a><a class="code" href="structdwop__section__names.html#a53e026523c28f96cf9ff9ce9fab9e235">00348</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__names.html">dwarf2_section_names</a> <a class="code" href="structdwop__section__names.html#a53e026523c28f96cf9ff9ce9fab9e235">line_dwo</a>;
<a name="l00349"></a><a class="code" href="structdwop__section__names.html#adc0f06e32cbd1167e26ec1321df8e63b">00349</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__names.html">dwarf2_section_names</a> <a class="code" href="structdwop__section__names.html#adc0f06e32cbd1167e26ec1321df8e63b">loc_dwo</a>;
<a name="l00350"></a><a class="code" href="structdwop__section__names.html#a8ebb4a5d32ae6414d9f9aa76b472da96">00350</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__names.html">dwarf2_section_names</a> <a class="code" href="structdwop__section__names.html#a8ebb4a5d32ae6414d9f9aa76b472da96">macinfo_dwo</a>;
<a name="l00351"></a><a class="code" href="structdwop__section__names.html#aced5043c2932561517e13c66aca3f238">00351</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__names.html">dwarf2_section_names</a> <a class="code" href="structdwop__section__names.html#aced5043c2932561517e13c66aca3f238">macro_dwo</a>;
<a name="l00352"></a><a class="code" href="structdwop__section__names.html#a0b6c94a6d611e5e3faac78072091d743">00352</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__names.html">dwarf2_section_names</a> <a class="code" href="structdwop__section__names.html#a0b6c94a6d611e5e3faac78072091d743">str_dwo</a>;
<a name="l00353"></a><a class="code" href="structdwop__section__names.html#a31b18ee25231b65438027a3134e9eb9d">00353</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__names.html">dwarf2_section_names</a> <a class="code" href="structdwop__section__names.html#a31b18ee25231b65438027a3134e9eb9d">str_offsets_dwo</a>;
<a name="l00354"></a><a class="code" href="structdwop__section__names.html#a1648f678e86667b0a897e7c7ad1b2cc6">00354</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__names.html">dwarf2_section_names</a> <a class="code" href="structdwop__section__names.html#a1648f678e86667b0a897e7c7ad1b2cc6">types_dwo</a>;
<a name="l00355"></a><a class="code" href="structdwop__section__names.html#a59b48fe1149b9b0925a32ab6662969ba">00355</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__names.html">dwarf2_section_names</a> <a class="code" href="structdwop__section__names.html#a59b48fe1149b9b0925a32ab6662969ba">cu_index</a>;
<a name="l00356"></a><a class="code" href="structdwop__section__names.html#a610f3eec837038963fdeee17997cc60b">00356</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__names.html">dwarf2_section_names</a> <a class="code" href="structdwop__section__names.html#a610f3eec837038963fdeee17997cc60b">tu_index</a>;
<a name="l00357"></a>00357 }
<a name="l00358"></a>00358 <a class="code" href="structdwop__section__names.html">dwop_section_names</a> =
<a name="l00359"></a>00359 {
<a name="l00360"></a>00360   { <span class="stringliteral">&quot;.debug_abbrev.dwo&quot;</span>, <span class="stringliteral">&quot;.zdebug_abbrev.dwo&quot;</span> },
<a name="l00361"></a>00361   { <span class="stringliteral">&quot;.debug_info.dwo&quot;</span>, <span class="stringliteral">&quot;.zdebug_info.dwo&quot;</span> },
<a name="l00362"></a>00362   { <span class="stringliteral">&quot;.debug_line.dwo&quot;</span>, <span class="stringliteral">&quot;.zdebug_line.dwo&quot;</span> },
<a name="l00363"></a>00363   { <span class="stringliteral">&quot;.debug_loc.dwo&quot;</span>, <span class="stringliteral">&quot;.zdebug_loc.dwo&quot;</span> },
<a name="l00364"></a>00364   { <span class="stringliteral">&quot;.debug_macinfo.dwo&quot;</span>, <span class="stringliteral">&quot;.zdebug_macinfo.dwo&quot;</span> },
<a name="l00365"></a>00365   { <span class="stringliteral">&quot;.debug_macro.dwo&quot;</span>, <span class="stringliteral">&quot;.zdebug_macro.dwo&quot;</span> },
<a name="l00366"></a>00366   { <span class="stringliteral">&quot;.debug_str.dwo&quot;</span>, <span class="stringliteral">&quot;.zdebug_str.dwo&quot;</span> },
<a name="l00367"></a>00367   { <span class="stringliteral">&quot;.debug_str_offsets.dwo&quot;</span>, <span class="stringliteral">&quot;.zdebug_str_offsets.dwo&quot;</span> },
<a name="l00368"></a>00368   { <span class="stringliteral">&quot;.debug_types.dwo&quot;</span>, <span class="stringliteral">&quot;.zdebug_types.dwo&quot;</span> },
<a name="l00369"></a>00369   { <span class="stringliteral">&quot;.debug_cu_index&quot;</span>, <span class="stringliteral">&quot;.zdebug_cu_index&quot;</span> },
<a name="l00370"></a>00370   { <span class="stringliteral">&quot;.debug_tu_index&quot;</span>, <span class="stringliteral">&quot;.zdebug_tu_index&quot;</span> },
<a name="l00371"></a>00371 };
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 <span class="comment">/* local data types */</span>
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 <span class="comment">/* The data in a compilation unit header, after target2host</span>
<a name="l00376"></a>00376 <span class="comment">   translation, looks like this.  */</span>
<a name="l00377"></a><a class="code" href="structcomp__unit__head.html">00377</a> <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a>
<a name="l00378"></a>00378 {
<a name="l00379"></a><a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">00379</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a>;
<a name="l00380"></a><a class="code" href="structcomp__unit__head.html#a68d6c482c646af0266771ad56b73748d">00380</a>   <span class="keywordtype">short</span> <a class="code" href="structcomp__unit__head.html#a68d6c482c646af0266771ad56b73748d">version</a>;
<a name="l00381"></a><a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">00381</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l00382"></a><a class="code" href="structcomp__unit__head.html#a4dbec66bb53896b38a53f9f4c8c5e1fb">00382</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structcomp__unit__head.html#a4dbec66bb53896b38a53f9f4c8c5e1fb">signed_addr_p</a>;
<a name="l00383"></a><a class="code" href="structcomp__unit__head.html#a5455b96122116b3881197362c7e35758">00383</a>   <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="structcomp__unit__head.html#a5455b96122116b3881197362c7e35758">abbrev_offset</a>;
<a name="l00384"></a>00384 
<a name="l00385"></a>00385   <span class="comment">/* Size of file offsets; either 4 or 8.  */</span>
<a name="l00386"></a><a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">00386</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388   <span class="comment">/* Size of the length field; either 4 or 12.  */</span>
<a name="l00389"></a><a class="code" href="structcomp__unit__head.html#ac7e963b953a807bdbcecd0c3dd4f1790">00389</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structcomp__unit__head.html#ac7e963b953a807bdbcecd0c3dd4f1790">initial_length_size</a>;
<a name="l00390"></a>00390 
<a name="l00391"></a>00391   <span class="comment">/* Offset to the first byte of this compilation unit header in the</span>
<a name="l00392"></a>00392 <span class="comment">     .debug_info section, for resolving relative reference dies.  */</span>
<a name="l00393"></a><a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">00393</a>   <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>;
<a name="l00394"></a>00394 
<a name="l00395"></a>00395   <span class="comment">/* Offset to first die in this cu from the start of the cu.</span>
<a name="l00396"></a>00396 <span class="comment">     This will be the first byte following the compilation unit header.  */</span>
<a name="l00397"></a><a class="code" href="structcomp__unit__head.html#a08a38b7787804c4cb0e7baa1280da286">00397</a>   <a class="code" href="structcu__offset.html">cu_offset</a> <a class="code" href="structcomp__unit__head.html#a08a38b7787804c4cb0e7baa1280da286">first_die_offset</a>;
<a name="l00398"></a>00398 };
<a name="l00399"></a>00399 
<a name="l00400"></a>00400 <span class="comment">/* Type used for delaying computation of method physnames.</span>
<a name="l00401"></a>00401 <span class="comment">   See comments for compute_delayed_physnames.  */</span>
<a name="l00402"></a><a class="code" href="structdelayed__method__info.html">00402</a> <span class="keyword">struct </span><a class="code" href="structdelayed__method__info.html">delayed_method_info</a>
<a name="l00403"></a>00403 {
<a name="l00404"></a>00404   <span class="comment">/* The type to which the method is attached, i.e., its parent class.  */</span>
<a name="l00405"></a><a class="code" href="structdelayed__method__info.html#a6d70fe3a74b112301dfc6b8a4f5f908b">00405</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structdelayed__method__info.html#a6d70fe3a74b112301dfc6b8a4f5f908b">type</a>;
<a name="l00406"></a>00406 
<a name="l00407"></a>00407   <span class="comment">/* The index of the method in the type&#39;s function fieldlists.  */</span>
<a name="l00408"></a><a class="code" href="structdelayed__method__info.html#a672fa3d4e9757cbb76ba478c50d13237">00408</a>   <span class="keywordtype">int</span> <a class="code" href="structdelayed__method__info.html#a672fa3d4e9757cbb76ba478c50d13237">fnfield_index</a>;
<a name="l00409"></a>00409 
<a name="l00410"></a>00410   <span class="comment">/* The index of the method in the fieldlist.  */</span>
<a name="l00411"></a><a class="code" href="structdelayed__method__info.html#ab8922c27cd39f06f1b0cc47a40837005">00411</a>   <span class="keywordtype">int</span> <a class="code" href="structdelayed__method__info.html#ab8922c27cd39f06f1b0cc47a40837005">index</a>;
<a name="l00412"></a>00412 
<a name="l00413"></a>00413   <span class="comment">/* The name of the DIE.  */</span>
<a name="l00414"></a><a class="code" href="structdelayed__method__info.html#ae73e61a20e7af5ffe8fc098dd38b2d8e">00414</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structdelayed__method__info.html#ae73e61a20e7af5ffe8fc098dd38b2d8e">name</a>;
<a name="l00415"></a>00415 
<a name="l00416"></a>00416   <span class="comment">/*  The DIE associated with this method.  */</span>
<a name="l00417"></a><a class="code" href="structdelayed__method__info.html#a14a3fea705611cf9993ed24a45f246bd">00417</a>   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *<a class="code" href="structdelayed__method__info.html#a14a3fea705611cf9993ed24a45f246bd">die</a>;
<a name="l00418"></a>00418 };
<a name="l00419"></a>00419 
<a name="l00420"></a><a class="code" href="dwarf2read_8c.html#a934ae867bf20794afb750ddd19678bc6">00420</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structdelayed__method__info.html">delayed_method_info</a> <a class="code" href="structdelayed__method__info.html">delayed_method_info</a>;
<a name="l00421"></a>00421 <a class="code" href="vec_8h.html#abc2d38563a8b5bed340654cf06060f11">DEF_VEC_O</a> (<a class="code" href="structdelayed__method__info.html">delayed_method_info</a>);
<a name="l00422"></a>00422 
<a name="l00423"></a>00423 <span class="comment">/* Internal state when decoding a particular compilation unit.  */</span>
<a name="l00424"></a><a class="code" href="structdwarf2__cu.html">00424</a> <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a>
<a name="l00425"></a>00425 {
<a name="l00426"></a>00426   <span class="comment">/* The objfile containing this compilation unit.  */</span>
<a name="l00427"></a><a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">00427</a>   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="comment">/* The header of the compilation unit.  */</span>
<a name="l00430"></a><a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">00430</a>   <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> <a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>;
<a name="l00431"></a>00431 
<a name="l00432"></a>00432   <span class="comment">/* Base address of this compilation unit.  */</span>
<a name="l00433"></a><a class="code" href="structdwarf2__cu.html#a23134f383c2bf69e7c15465e6bb7c128">00433</a>   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structdwarf2__cu.html#a23134f383c2bf69e7c15465e6bb7c128">base_address</a>;
<a name="l00434"></a>00434 
<a name="l00435"></a>00435   <span class="comment">/* Non-zero if base_address has been set.  */</span>
<a name="l00436"></a><a class="code" href="structdwarf2__cu.html#a119974d7d2639455e745de437261ade8">00436</a>   <span class="keywordtype">int</span> <a class="code" href="structdwarf2__cu.html#a119974d7d2639455e745de437261ade8">base_known</a>;
<a name="l00437"></a>00437 
<a name="l00438"></a>00438   <span class="comment">/* The language we are debugging.  */</span>
<a name="l00439"></a><a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">00439</a>   <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> <a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>;
<a name="l00440"></a><a class="code" href="structdwarf2__cu.html#aa12f3aeef950b4457378c14f9ba16f12">00440</a>   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlanguage__defn.html">language_defn</a> *<a class="code" href="structdwarf2__cu.html#aa12f3aeef950b4457378c14f9ba16f12">language_defn</a>;
<a name="l00441"></a>00441 
<a name="l00442"></a><a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">00442</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>;
<a name="l00443"></a>00443 
<a name="l00444"></a>00444   <span class="comment">/* The generic symbol table building routines have separate lists for</span>
<a name="l00445"></a>00445 <span class="comment">     file scope symbols and all all other scopes (local scopes).  So</span>
<a name="l00446"></a>00446 <span class="comment">     we need to select the right one to pass to add_symbol_to_list().</span>
<a name="l00447"></a>00447 <span class="comment">     We do it by keeping a pointer to the correct list in list_in_scope.</span>
<a name="l00448"></a>00448 <span class="comment"></span>
<a name="l00449"></a>00449 <span class="comment">     FIXME: The original dwarf code just treated the file scope as the</span>
<a name="l00450"></a>00450 <span class="comment">     first local scope, and all other local scopes as nested local</span>
<a name="l00451"></a>00451 <span class="comment">     scopes, and worked fine.  Check to see if we really need to</span>
<a name="l00452"></a>00452 <span class="comment">     distinguish these in buildsym.c.  */</span>
<a name="l00453"></a><a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">00453</a>   <span class="keyword">struct </span><a class="code" href="structpending.html">pending</a> **<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>;
<a name="l00454"></a>00454 
<a name="l00455"></a>00455   <span class="comment">/* The abbrev table for this CU.</span>
<a name="l00456"></a>00456 <span class="comment">     Normally this points to the abbrev table in the objfile.</span>
<a name="l00457"></a>00457 <span class="comment">     But if DWO_UNIT is non-NULL this is the abbrev table in the DWO file.  */</span>
<a name="l00458"></a><a class="code" href="structdwarf2__cu.html#a57e9b37ae0dfd83c0e16565ca75c9781">00458</a>   <span class="keyword">struct </span><a class="code" href="structabbrev__table.html">abbrev_table</a> *<a class="code" href="structdwarf2__cu.html#a57e9b37ae0dfd83c0e16565ca75c9781">abbrev_table</a>;
<a name="l00459"></a>00459 
<a name="l00460"></a>00460   <span class="comment">/* Hash table holding all the loaded partial DIEs</span>
<a name="l00461"></a>00461 <span class="comment">     with partial_die-&gt;offset.SECT_OFF as hash.  */</span>
<a name="l00462"></a><a class="code" href="structdwarf2__cu.html#a1e821881f894272409a466d336a88b1f">00462</a>   htab_t <a class="code" href="structdwarf2__cu.html#a1e821881f894272409a466d336a88b1f">partial_dies</a>;
<a name="l00463"></a>00463 
<a name="l00464"></a>00464   <span class="comment">/* Storage for things with the same lifetime as this read-in compilation</span>
<a name="l00465"></a>00465 <span class="comment">     unit, including partial DIEs.  */</span>
<a name="l00466"></a><a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">00466</a>   <span class="keyword">struct </span>obstack <a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>;
<a name="l00467"></a>00467 
<a name="l00468"></a>00468   <span class="comment">/* When multiple dwarf2_cu structures are living in memory, this field</span>
<a name="l00469"></a>00469 <span class="comment">     chains them all together, so that they can be released efficiently.</span>
<a name="l00470"></a>00470 <span class="comment">     We will probably also want a generation counter so that most-recently-used</span>
<a name="l00471"></a>00471 <span class="comment">     compilation units are cached...  */</span>
<a name="l00472"></a><a class="code" href="structdwarf2__cu.html#ad4caa7a7978fa4ca2edef259dd77a8ef">00472</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *<a class="code" href="structdwarf2__cu.html#ad4caa7a7978fa4ca2edef259dd77a8ef">read_in_chain</a>;
<a name="l00473"></a>00473 
<a name="l00474"></a>00474   <span class="comment">/* Backlink to our per_cu entry.  */</span>
<a name="l00475"></a><a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">00475</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;
<a name="l00476"></a>00476 
<a name="l00477"></a>00477   <span class="comment">/* How many compilation units ago was this CU last referenced?  */</span>
<a name="l00478"></a><a class="code" href="structdwarf2__cu.html#ae8de3b2f422c424b62543c1ef121de02">00478</a>   <span class="keywordtype">int</span> <a class="code" href="structdwarf2__cu.html#ae8de3b2f422c424b62543c1ef121de02">last_used</a>;
<a name="l00479"></a>00479 
<a name="l00480"></a>00480   <span class="comment">/* A hash table of DIE cu_offset for following references with</span>
<a name="l00481"></a>00481 <span class="comment">     die_info-&gt;offset.sect_off as hash.  */</span>
<a name="l00482"></a><a class="code" href="structdwarf2__cu.html#a681ffa0c8fdc7c63efa8fffb2a441f12">00482</a>   htab_t <a class="code" href="structdwarf2__cu.html#a681ffa0c8fdc7c63efa8fffb2a441f12">die_hash</a>;
<a name="l00483"></a>00483 
<a name="l00484"></a>00484   <span class="comment">/* Full DIEs if read in.  */</span>
<a name="l00485"></a><a class="code" href="structdwarf2__cu.html#abc8aaad6bb3799398e9769f989fd1692">00485</a>   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *<a class="code" href="structdwarf2__cu.html#abc8aaad6bb3799398e9769f989fd1692">dies</a>;
<a name="l00486"></a>00486 
<a name="l00487"></a>00487   <span class="comment">/* A set of pointers to dwarf2_per_cu_data objects for compilation</span>
<a name="l00488"></a>00488 <span class="comment">     units referenced by this one.  Only set during full symbol processing;</span>
<a name="l00489"></a>00489 <span class="comment">     partial symbol tables do not have dependencies.  */</span>
<a name="l00490"></a><a class="code" href="structdwarf2__cu.html#aba78cb69f78a0a03f004d6a25cd2dfdf">00490</a>   htab_t <a class="code" href="structdwarf2__cu.html#aba78cb69f78a0a03f004d6a25cd2dfdf">dependencies</a>;
<a name="l00491"></a>00491 
<a name="l00492"></a>00492   <span class="comment">/* Header data from the line table, during full symbol processing.  */</span>
<a name="l00493"></a><a class="code" href="structdwarf2__cu.html#a94864e6f22ffa7350c883da402931b99">00493</a>   <span class="keyword">struct </span><a class="code" href="structline__header.html">line_header</a> *<a class="code" href="structdwarf2__cu.html#a94864e6f22ffa7350c883da402931b99">line_header</a>;
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   <span class="comment">/* A list of methods which need to have physnames computed</span>
<a name="l00496"></a>00496 <span class="comment">     after all type information has been read.  */</span>
<a name="l00497"></a>00497   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structdelayed__method__info.html">delayed_method_info</a>) *method_list;
<a name="l00498"></a>00498 
<a name="l00499"></a>00499   <span class="comment">/* To be copied to symtab-&gt;call_site_htab.  */</span>
<a name="l00500"></a>00500   htab_t call_site_htab;
<a name="l00501"></a>00501 
<a name="l00502"></a>00502   <span class="comment">/* Non-NULL if this CU came from a DWO file.</span>
<a name="l00503"></a>00503 <span class="comment">     There is an invariant here that is important to remember:</span>
<a name="l00504"></a>00504 <span class="comment">     Except for attributes copied from the top level DIE in the &quot;main&quot;</span>
<a name="l00505"></a>00505 <span class="comment">     (or &quot;stub&quot;) file in preparation for reading the DWO file</span>
<a name="l00506"></a>00506 <span class="comment">     (e.g., DW_AT_GNU_addr_base), we KISS: there is only *one* CU.</span>
<a name="l00507"></a>00507 <span class="comment">     Either there isn&#39;t a DWO file (in which case this is NULL and the point</span>
<a name="l00508"></a>00508 <span class="comment">     is moot), or there is and either we&#39;re not going to read it (in which</span>
<a name="l00509"></a>00509 <span class="comment">     case this is NULL) or there is and we are reading it (in which case this</span>
<a name="l00510"></a>00510 <span class="comment">     is non-NULL).  */</span>
<a name="l00511"></a>00511   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structdwo__unit.html">dwo_unit</a>;
<a name="l00512"></a>00512 
<a name="l00513"></a>00513   <span class="comment">/* The DW_AT_addr_base attribute if present, zero otherwise</span>
<a name="l00514"></a>00514 <span class="comment">     (zero is a valid value though).</span>
<a name="l00515"></a>00515 <span class="comment">     Note this value comes from the stub CU/TU&#39;s DIE.  */</span>
<a name="l00516"></a>00516   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> addr_base;
<a name="l00517"></a>00517 
<a name="l00518"></a>00518   <span class="comment">/* The DW_AT_ranges_base attribute if present, zero otherwise</span>
<a name="l00519"></a>00519 <span class="comment">     (zero is a valid value though).</span>
<a name="l00520"></a>00520 <span class="comment">     Note this value comes from the stub CU/TU&#39;s DIE.</span>
<a name="l00521"></a>00521 <span class="comment">     Also note that the value is zero in the non-DWO case so this value can</span>
<a name="l00522"></a>00522 <span class="comment">     be used without needing to know whether DWO files are in use or not.</span>
<a name="l00523"></a>00523 <span class="comment">     N.B. This does not apply to DW_AT_ranges appearing in</span>
<a name="l00524"></a>00524 <span class="comment">     DW_TAG_compile_unit dies.  This is a bit of a wart, consider if ever</span>
<a name="l00525"></a>00525 <span class="comment">     DW_AT_ranges appeared in the DW_TAG_compile_unit of DWO DIEs: then</span>
<a name="l00526"></a>00526 <span class="comment">     DW_AT_ranges_base *would* have to be applied, and we&#39;d have to care</span>
<a name="l00527"></a>00527 <span class="comment">     whether the DW_AT_ranges attribute came from the skeleton or DWO.  */</span>
<a name="l00528"></a>00528   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> ranges_base;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530   <span class="comment">/* Mark used when releasing cached dies.  */</span>
<a name="l00531"></a>00531   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mark : 1;
<a name="l00532"></a>00532 
<a name="l00533"></a>00533   <span class="comment">/* This CU references .debug_loc.  See the symtab-&gt;locations_valid field.</span>
<a name="l00534"></a>00534 <span class="comment">     This test is imperfect as there may exist optimized debug code not using</span>
<a name="l00535"></a>00535 <span class="comment">     any location list and still facing inlining issues if handled as</span>
<a name="l00536"></a>00536 <span class="comment">     unoptimized code.  For a future better test see GCC PR other/32998.  */</span>
<a name="l00537"></a>00537   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> has_loclist : 1;
<a name="l00538"></a>00538 
<a name="l00539"></a>00539   <span class="comment">/* These cache the results for producer_is_* fields.  CHECKED_PRODUCER is set</span>
<a name="l00540"></a>00540 <span class="comment">     if all the producer_is_* fields are valid.  This information is cached</span>
<a name="l00541"></a>00541 <span class="comment">     because profiling CU expansion showed excessive time spent in</span>
<a name="l00542"></a>00542 <span class="comment">     producer_is_gxx_lt_4_6.  */</span>
<a name="l00543"></a>00543   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> checked_producer : 1;
<a name="l00544"></a>00544   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#aec4c30ddd1859273c792893367bf3bfa">producer_is_gxx_lt_4_6</a> : 1;
<a name="l00545"></a>00545   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a9dba089a951f33a1f8bf686aaf189554">producer_is_gcc_lt_4_3</a> : 1;
<a name="l00546"></a>00546   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a068e3816917d348ffb951c6369e057f0">producer_is_icc</a> : 1;
<a name="l00547"></a>00547 
<a name="l00548"></a>00548   <span class="comment">/* When set, the file that we&#39;re processing is known to have</span>
<a name="l00549"></a>00549 <span class="comment">     debugging info for C++ namespaces.  GCC 3.3.x did not produce</span>
<a name="l00550"></a>00550 <span class="comment">     this information, but later versions do.  */</span>
<a name="l00551"></a>00551 
<a name="l00552"></a>00552   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> processing_has_namespace_info : 1;
<a name="l00553"></a>00553 };
<a name="l00554"></a>00554 
<a name="l00555"></a>00555 <span class="comment">/* Persistent data held for a compilation unit, even when not</span>
<a name="l00556"></a>00556 <span class="comment">   processing it.  We put a pointer to this structure in the</span>
<a name="l00557"></a>00557 <span class="comment">   read_symtab_private field of the psymtab.  */</span>
<a name="l00558"></a>00558 
<a name="l00559"></a><a class="code" href="structdwarf2__per__cu__data.html">00559</a> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a>
<a name="l00560"></a>00560 {
<a name="l00561"></a>00561   <span class="comment">/* The start offset and length of this compilation unit.</span>
<a name="l00562"></a>00562 <span class="comment">     NOTE: Unlike comp_unit_head.length, this length includes</span>
<a name="l00563"></a>00563 <span class="comment">     initial_length_size.</span>
<a name="l00564"></a>00564 <span class="comment">     If the DIE refers to a DWO file, this is always of the original die,</span>
<a name="l00565"></a>00565 <span class="comment">     not the DWO file.  */</span>
<a name="l00566"></a><a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">00566</a>   <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>;
<a name="l00567"></a><a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">00567</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a>;
<a name="l00568"></a>00568 
<a name="l00569"></a>00569   <span class="comment">/* Flag indicating this compilation unit will be read in before</span>
<a name="l00570"></a>00570 <span class="comment">     any of the current compilation units are processed.  */</span>
<a name="l00571"></a><a class="code" href="structdwarf2__per__cu__data.html#a2eed1245c96a6300453e610421b98b93">00571</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structdwarf2__per__cu__data.html#a2eed1245c96a6300453e610421b98b93">queued</a> : 1;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573   <span class="comment">/* This flag will be set when reading partial DIEs if we need to load</span>
<a name="l00574"></a>00574 <span class="comment">     absolutely all DIEs for this compilation unit, instead of just the ones</span>
<a name="l00575"></a>00575 <span class="comment">     we think are interesting.  It gets set if we look for a DIE in the</span>
<a name="l00576"></a>00576 <span class="comment">     hash table and don&#39;t find it.  */</span>
<a name="l00577"></a><a class="code" href="structdwarf2__per__cu__data.html#a86105edb17badc0d1b99c4e4427d2911">00577</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structdwarf2__per__cu__data.html#a86105edb17badc0d1b99c4e4427d2911">load_all_dies</a> : 1;
<a name="l00578"></a>00578 
<a name="l00579"></a>00579   <span class="comment">/* Non-zero if this CU is from .debug_types.</span>
<a name="l00580"></a>00580 <span class="comment">     Struct dwarf2_per_cu_data is contained in struct signatured_type iff</span>
<a name="l00581"></a>00581 <span class="comment">     this is non-zero.  */</span>
<a name="l00582"></a><a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">00582</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a> : 1;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584   <span class="comment">/* Non-zero if this CU is from the .dwz file.  */</span>
<a name="l00585"></a><a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">00585</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a> : 1;
<a name="l00586"></a>00586 
<a name="l00587"></a>00587   <span class="comment">/* Non-zero if reading a TU directly from a DWO file, bypassing the stub.</span>
<a name="l00588"></a>00588 <span class="comment">     This flag is only valid if is_debug_types is true.</span>
<a name="l00589"></a>00589 <span class="comment">     We can&#39;t read a CU directly from a DWO file: There are required</span>
<a name="l00590"></a>00590 <span class="comment">     attributes in the stub.  */</span>
<a name="l00591"></a><a class="code" href="structdwarf2__per__cu__data.html#a3015da55655aee818845295b4bbccee5">00591</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structdwarf2__per__cu__data.html#a3015da55655aee818845295b4bbccee5">reading_dwo_directly</a> : 1;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593   <span class="comment">/* Non-zero if the TU has been read.</span>
<a name="l00594"></a>00594 <span class="comment">     This is used to assist the &quot;Stay in DWO Optimization&quot; for Fission:</span>
<a name="l00595"></a>00595 <span class="comment">     When reading a DWO, it&#39;s faster to read TUs from the DWO instead of</span>
<a name="l00596"></a>00596 <span class="comment">     fetching them from random other DWOs (due to comdat folding).</span>
<a name="l00597"></a>00597 <span class="comment">     If the TU has already been read, the optimization is unnecessary</span>
<a name="l00598"></a>00598 <span class="comment">     (and unwise - we don&#39;t want to change where gdb thinks the TU lives</span>
<a name="l00599"></a>00599 <span class="comment">     &quot;midflight&quot;).</span>
<a name="l00600"></a>00600 <span class="comment">     This flag is only valid if is_debug_types is true.  */</span>
<a name="l00601"></a><a class="code" href="structdwarf2__per__cu__data.html#ace5ce61a37eefad9502e7d9881173de8">00601</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structdwarf2__per__cu__data.html#ace5ce61a37eefad9502e7d9881173de8">tu_read</a> : 1;
<a name="l00602"></a>00602 
<a name="l00603"></a>00603   <span class="comment">/* The section this CU/TU lives in.</span>
<a name="l00604"></a>00604 <span class="comment">     If the DIE refers to a DWO file, this is always the original die,</span>
<a name="l00605"></a>00605 <span class="comment">     not the DWO file.  */</span>
<a name="l00606"></a><a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">00606</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *<a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a>;
<a name="l00607"></a>00607 
<a name="l00608"></a>00608   <span class="comment">/* Set to non-NULL iff this CU is currently loaded.  When it gets freed out</span>
<a name="l00609"></a>00609 <span class="comment">     of the CU cache it gets reset to NULL again.  */</span>
<a name="l00610"></a><a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">00610</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>;
<a name="l00611"></a>00611 
<a name="l00612"></a>00612   <span class="comment">/* The corresponding objfile.</span>
<a name="l00613"></a>00613 <span class="comment">     Normally we can get the objfile from dwarf2_per_objfile.</span>
<a name="l00614"></a>00614 <span class="comment">     However we can enter this file with just a &quot;per_cu&quot; handle.  */</span>
<a name="l00615"></a><a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">00615</a>   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>;
<a name="l00616"></a>00616 
<a name="l00617"></a>00617   <span class="comment">/* When using partial symbol tables, the &#39;psymtab&#39; field is active.</span>
<a name="l00618"></a>00618 <span class="comment">     Otherwise the &#39;quick&#39; field is active.  */</span>
<a name="l00619"></a>00619   <span class="keyword">union</span>
<a name="l00620"></a>00620   {
<a name="l00621"></a>00621     <span class="comment">/* The partial symbol table associated with this compilation unit,</span>
<a name="l00622"></a>00622 <span class="comment">       or NULL for unread partial units.  */</span>
<a name="l00623"></a><a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">00623</a>     <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a>;
<a name="l00624"></a>00624 
<a name="l00625"></a>00625     <span class="comment">/* Data needed by the &quot;quick&quot; functions.  */</span>
<a name="l00626"></a><a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">00626</a>     <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__quick__data.html">dwarf2_per_cu_quick_data</a> *<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>;
<a name="l00627"></a>00627   } <a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>;
<a name="l00628"></a>00628 
<a name="l00629"></a>00629   <span class="comment">/* The CUs we import using DW_TAG_imported_unit.  This is filled in</span>
<a name="l00630"></a>00630 <span class="comment">     while reading psymtabs, used to compute the psymtab dependencies,</span>
<a name="l00631"></a>00631 <span class="comment">     and then cleared.  Then it is filled in again while reading full</span>
<a name="l00632"></a>00632 <span class="comment">     symbols, and only deleted when the objfile is destroyed.</span>
<a name="l00633"></a>00633 <span class="comment"></span>
<a name="l00634"></a>00634 <span class="comment">     This is also used to work around a difference between the way gold</span>
<a name="l00635"></a>00635 <span class="comment">     generates .gdb_index version &lt;=7 and the way gdb does.  Arguably this</span>
<a name="l00636"></a>00636 <span class="comment">     is a gold bug.  For symbols coming from TUs, gold records in the index</span>
<a name="l00637"></a>00637 <span class="comment">     the CU that includes the TU instead of the TU itself.  This breaks</span>
<a name="l00638"></a>00638 <span class="comment">     dw2_lookup_symbol: It assumes that if the index says symbol X lives</span>
<a name="l00639"></a>00639 <span class="comment">     in CU/TU Y, then one need only expand Y and a subsequent lookup in Y</span>
<a name="l00640"></a>00640 <span class="comment">     will find X.  Alas TUs live in their own symtab, so after expanding CU Y</span>
<a name="l00641"></a>00641 <span class="comment">     we need to look in TU Z to find X.  Fortunately, this is akin to</span>
<a name="l00642"></a>00642 <span class="comment">     DW_TAG_imported_unit, so we just use the same mechanism: For</span>
<a name="l00643"></a>00643 <span class="comment">     .gdb_index version &lt;=7 this also records the TUs that the CU referred</span>
<a name="l00644"></a>00644 <span class="comment">     to.  Concurrently with this change gdb was modified to emit version 8</span>
<a name="l00645"></a>00645 <span class="comment">     indices so we only pay a price for gold generated indices.</span>
<a name="l00646"></a>00646 <span class="comment">     http://sourceware.org/bugzilla/show_bug.cgi?id=15021.  */</span>
<a name="l00647"></a>00647   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (dwarf2_per_cu_ptr) *imported_symtabs;
<a name="l00648"></a>00648 };
<a name="l00649"></a>00649 
<a name="l00650"></a>00650 <span class="comment">/* Entry in the signatured_types hash table.  */</span>
<a name="l00651"></a>00651 
<a name="l00652"></a><a class="code" href="structsignatured__type.html">00652</a> <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a>
<a name="l00653"></a>00653 {
<a name="l00654"></a>00654   <span class="comment">/* The &quot;per_cu&quot; object of this type.</span>
<a name="l00655"></a>00655 <span class="comment">     This struct is used iff per_cu.is_debug_types.</span>
<a name="l00656"></a>00656 <span class="comment">     N.B.: This is the first member so that it&#39;s easy to convert pointers</span>
<a name="l00657"></a>00657 <span class="comment">     between them.  */</span>
<a name="l00658"></a><a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">00658</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> <a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660   <span class="comment">/* The type&#39;s signature.  */</span>
<a name="l00661"></a><a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">00661</a>   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a>;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663   <span class="comment">/* Offset in the TU of the type&#39;s DIE, as read from the TU header.</span>
<a name="l00664"></a>00664 <span class="comment">     If this TU is a DWO stub and the definition lives in a DWO file</span>
<a name="l00665"></a>00665 <span class="comment">     (specified by DW_AT_GNU_dwo_name), this value is unusable.  */</span>
<a name="l00666"></a><a class="code" href="structsignatured__type.html#ab152a3e1f687ff6464b369502ce745a9">00666</a>   <a class="code" href="structcu__offset.html">cu_offset</a> <a class="code" href="structsignatured__type.html#ab152a3e1f687ff6464b369502ce745a9">type_offset_in_tu</a>;
<a name="l00667"></a>00667 
<a name="l00668"></a>00668   <span class="comment">/* Offset in the section of the type&#39;s DIE.</span>
<a name="l00669"></a>00669 <span class="comment">     If the definition lives in a DWO file, this is the offset in the</span>
<a name="l00670"></a>00670 <span class="comment">     .debug_types.dwo section.</span>
<a name="l00671"></a>00671 <span class="comment">     The value is zero until the actual value is known.</span>
<a name="l00672"></a>00672 <span class="comment">     Zero is otherwise not a valid section offset.  */</span>
<a name="l00673"></a><a class="code" href="structsignatured__type.html#aa8e49a69ad9d6311b553b063fa0fe62d">00673</a>   <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="structsignatured__type.html#aa8e49a69ad9d6311b553b063fa0fe62d">type_offset_in_section</a>;
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   <span class="comment">/* Type units are grouped by their DW_AT_stmt_list entry so that they</span>
<a name="l00676"></a>00676 <span class="comment">     can share them.  This points to the containing symtab.  */</span>
<a name="l00677"></a><a class="code" href="structsignatured__type.html#ab10f6f2df0f7691aa8ca948e28cbcf1e">00677</a>   <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> *<a class="code" href="structsignatured__type.html#ab10f6f2df0f7691aa8ca948e28cbcf1e">type_unit_group</a>;
<a name="l00678"></a>00678 
<a name="l00679"></a>00679   <span class="comment">/* The type.</span>
<a name="l00680"></a>00680 <span class="comment">     The first time we encounter this type we fully read it in and install it</span>
<a name="l00681"></a>00681 <span class="comment">     in the symbol tables.  Subsequent times we only need the type.  */</span>
<a name="l00682"></a><a class="code" href="structsignatured__type.html#a989d99d874e2a997ff78faa0bcf2e5d2">00682</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structsignatured__type.html#a989d99d874e2a997ff78faa0bcf2e5d2">type</a>;
<a name="l00683"></a>00683 
<a name="l00684"></a>00684   <span class="comment">/* Containing DWO unit.</span>
<a name="l00685"></a>00685 <span class="comment">     This field is valid iff per_cu.reading_dwo_directly.  */</span>
<a name="l00686"></a><a class="code" href="structsignatured__type.html#a8b6cf2131ff9f72ef62c56047f62f9d6">00686</a>   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structsignatured__type.html#a8b6cf2131ff9f72ef62c56047f62f9d6">dwo_unit</a>;
<a name="l00687"></a>00687 };
<a name="l00688"></a>00688 
<a name="l00689"></a><a class="code" href="dwarf2read_8c.html#a82d63e4798d3b20f0915b2d60439f2f7">00689</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *<a class="code" href="dwarf2read_8c.html#a82d63e4798d3b20f0915b2d60439f2f7">sig_type_ptr</a>;
<a name="l00690"></a>00690 <a class="code" href="vec_8h.html#af9d77557e51db07808428f28a3559803">DEF_VEC_P</a> (sig_type_ptr);
<a name="l00691"></a>00691 
<a name="l00692"></a>00692 <span class="comment">/* A struct that can be used as a hash key for tables based on DW_AT_stmt_list.</span>
<a name="l00693"></a>00693 <span class="comment">   This includes type_unit_group and quick_file_names.  */</span>
<a name="l00694"></a>00694 
<a name="l00695"></a><a class="code" href="structstmt__list__hash.html">00695</a> <span class="keyword">struct </span><a class="code" href="structstmt__list__hash.html">stmt_list_hash</a>
<a name="l00696"></a>00696 {
<a name="l00697"></a>00697   <span class="comment">/* The DWO unit this table is from or NULL if there is none.  */</span>
<a name="l00698"></a><a class="code" href="structstmt__list__hash.html#a2372dc58554f328becda07e68d6528a8">00698</a>   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structstmt__list__hash.html#a2372dc58554f328becda07e68d6528a8">dwo_unit</a>;
<a name="l00699"></a>00699 
<a name="l00700"></a>00700   <span class="comment">/* Offset in .debug_line or .debug_line.dwo.  */</span>
<a name="l00701"></a><a class="code" href="structstmt__list__hash.html#a9ee63f1d951d00448dd2b14430aba5fe">00701</a>   <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="structstmt__list__hash.html#a9ee63f1d951d00448dd2b14430aba5fe">line_offset</a>;
<a name="l00702"></a>00702 };
<a name="l00703"></a>00703 
<a name="l00704"></a>00704 <span class="comment">/* Each element of dwarf2_per_objfile-&gt;type_unit_groups is a pointer to</span>
<a name="l00705"></a>00705 <span class="comment">   an object of this type.  */</span>
<a name="l00706"></a>00706 
<a name="l00707"></a><a class="code" href="structtype__unit__group.html">00707</a> <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a>
<a name="l00708"></a>00708 {
<a name="l00709"></a>00709   <span class="comment">/* dwarf2read.c&#39;s main &quot;handle&quot; on a TU symtab.</span>
<a name="l00710"></a>00710 <span class="comment">     To simplify things we create an artificial CU that &quot;includes&quot; all the</span>
<a name="l00711"></a>00711 <span class="comment">     type units using this stmt_list so that the rest of the code still has</span>
<a name="l00712"></a>00712 <span class="comment">     a &quot;per_cu&quot; handle on the symtab.</span>
<a name="l00713"></a>00713 <span class="comment">     This PER_CU is recognized by having no section.  */</span>
<a name="l00714"></a><a class="code" href="dwarf2read_8c.html#aa278b6364c9b859353eeea535d81221e">00714</a> <span class="preprocessor">#define IS_TYPE_UNIT_GROUP(per_cu) ((per_cu)-&gt;section == NULL)</span>
<a name="l00715"></a><a class="code" href="structtype__unit__group.html#a4811e92ec66f2823829defcf2d3c9b29">00715</a> <span class="preprocessor"></span>  <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> <a class="code" href="structtype__unit__group.html#a4811e92ec66f2823829defcf2d3c9b29">per_cu</a>;
<a name="l00716"></a>00716 
<a name="l00717"></a>00717   <span class="comment">/* The TUs that share this DW_AT_stmt_list entry.</span>
<a name="l00718"></a>00718 <span class="comment">     This is added to while parsing type units to build partial symtabs,</span>
<a name="l00719"></a>00719 <span class="comment">     and is deleted afterwards and not used again.  */</span>
<a name="l00720"></a>00720   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (sig_type_ptr) *tus;
<a name="l00721"></a>00721 
<a name="l00722"></a>00722   <span class="comment">/* The primary symtab.</span>
<a name="l00723"></a>00723 <span class="comment">     Type units in a group needn&#39;t all be defined in the same source file,</span>
<a name="l00724"></a>00724 <span class="comment">     so we create an essentially anonymous symtab as the primary symtab.  */</span>
<a name="l00725"></a>00725   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *primary_symtab;
<a name="l00726"></a>00726 
<a name="l00727"></a>00727   <span class="comment">/* The data used to construct the hash key.  */</span>
<a name="l00728"></a>00728   <span class="keyword">struct </span><a class="code" href="structstmt__list__hash.html">stmt_list_hash</a> <a class="code" href="bcache_8c.html#a680b4550cc69a0827af4a7169fe3c372">hash</a>;
<a name="l00729"></a>00729 
<a name="l00730"></a>00730   <span class="comment">/* The number of symtabs from the line header.</span>
<a name="l00731"></a>00731 <span class="comment">     The value here must match line_header.num_file_names.  */</span>
<a name="l00732"></a>00732   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_symtabs;
<a name="l00733"></a>00733 
<a name="l00734"></a>00734   <span class="comment">/* The symbol tables for this TU (obtained from the files listed in</span>
<a name="l00735"></a>00735 <span class="comment">     DW_AT_stmt_list).</span>
<a name="l00736"></a>00736 <span class="comment">     WARNING: The order of entries here must match the order of entries</span>
<a name="l00737"></a>00737 <span class="comment">     in the line header.  After the first TU using this type_unit_group, the</span>
<a name="l00738"></a>00738 <span class="comment">     line header for the subsequent TUs is recreated from this.  This is done</span>
<a name="l00739"></a>00739 <span class="comment">     because we need to use the same symtabs for each TU using the same</span>
<a name="l00740"></a>00740 <span class="comment">     DW_AT_stmt_list value.  Also note that symtabs may be repeated here,</span>
<a name="l00741"></a>00741 <span class="comment">     there&#39;s no guarantee the line header doesn&#39;t have duplicate entries.  */</span>
<a name="l00742"></a>00742   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> **symtabs;
<a name="l00743"></a>00743 };
<a name="l00744"></a>00744 
<a name="l00745"></a>00745 <span class="comment">/* These sections are what may appear in a (real or virtual) DWO file.  */</span>
<a name="l00746"></a>00746 
<a name="l00747"></a><a class="code" href="structdwo__sections.html">00747</a> <span class="keyword">struct </span><a class="code" href="structdwo__sections.html">dwo_sections</a>
<a name="l00748"></a>00748 {
<a name="l00749"></a><a class="code" href="structdwo__sections.html#a77a177199056d70f8c5379e116538cff">00749</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwo__sections.html#a77a177199056d70f8c5379e116538cff">abbrev</a>;
<a name="l00750"></a><a class="code" href="structdwo__sections.html#af62a3f7d7e5333a93d30eb62504b3f86">00750</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwo__sections.html#af62a3f7d7e5333a93d30eb62504b3f86">line</a>;
<a name="l00751"></a><a class="code" href="structdwo__sections.html#ad3e9ca4610807f83ad1cc750fe465180">00751</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwo__sections.html#ad3e9ca4610807f83ad1cc750fe465180">loc</a>;
<a name="l00752"></a><a class="code" href="structdwo__sections.html#ae83c45d0e683d0deea40dd56417914e7">00752</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwo__sections.html#ae83c45d0e683d0deea40dd56417914e7">macinfo</a>;
<a name="l00753"></a><a class="code" href="structdwo__sections.html#ac745fa5543aa071d521f3b3f6c5829a5">00753</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwo__sections.html#ac745fa5543aa071d521f3b3f6c5829a5">macro</a>;
<a name="l00754"></a><a class="code" href="structdwo__sections.html#ae8ef8aea284e8f15890bc43155754ce2">00754</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwo__sections.html#ae8ef8aea284e8f15890bc43155754ce2">str</a>;
<a name="l00755"></a><a class="code" href="structdwo__sections.html#a931377e7a734f721034972c4061af209">00755</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwo__sections.html#a931377e7a734f721034972c4061af209">str_offsets</a>;
<a name="l00756"></a>00756   <span class="comment">/* In the case of a virtual DWO file, these two are unused.  */</span>
<a name="l00757"></a><a class="code" href="structdwo__sections.html#adf20047f5e83d7bbaa527ee01e0fe71a">00757</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwo__sections.html#adf20047f5e83d7bbaa527ee01e0fe71a">info</a>;
<a name="l00758"></a>00758   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>) *types;
<a name="l00759"></a>00759 };
<a name="l00760"></a>00760 
<a name="l00761"></a>00761 <span class="comment">/* CUs/TUs in DWP/DWO files.  */</span>
<a name="l00762"></a>00762 
<a name="l00763"></a><a class="code" href="structdwo__unit.html">00763</a> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a>
<a name="l00764"></a>00764 {
<a name="l00765"></a>00765   <span class="comment">/* Backlink to the containing struct dwo_file.  */</span>
<a name="l00766"></a><a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">00766</a>   <span class="keyword">struct </span><a class="code" href="structdwo__file.html">dwo_file</a> *<a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">dwo_file</a>;
<a name="l00767"></a>00767 
<a name="l00768"></a>00768   <span class="comment">/* The &quot;id&quot; that distinguishes this CU/TU.</span>
<a name="l00769"></a>00769 <span class="comment">     .debug_info calls this &quot;dwo_id&quot;, .debug_types calls this &quot;signature&quot;.</span>
<a name="l00770"></a>00770 <span class="comment">     Since signatures came first, we stick with it for consistency.  */</span>
<a name="l00771"></a><a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">00771</a>   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>;
<a name="l00772"></a>00772 
<a name="l00773"></a>00773   <span class="comment">/* The section this CU/TU lives in, in the DWO file.  */</span>
<a name="l00774"></a><a class="code" href="structdwo__unit.html#a808127fb35d399faddd33a3b28e5ec06">00774</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *<a class="code" href="structdwo__unit.html#a808127fb35d399faddd33a3b28e5ec06">section</a>;
<a name="l00775"></a>00775 
<a name="l00776"></a>00776   <span class="comment">/* Same as dwarf2_per_cu_data:{offset,length} but in the DWO section.  */</span>
<a name="l00777"></a><a class="code" href="structdwo__unit.html#a39192bd18fec52ffbb9cda4fc9d631e0">00777</a>   <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="structdwo__unit.html#a39192bd18fec52ffbb9cda4fc9d631e0">offset</a>;
<a name="l00778"></a><a class="code" href="structdwo__unit.html#adf4afc1b8bd4d2b879762c33930ef988">00778</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structdwo__unit.html#adf4afc1b8bd4d2b879762c33930ef988">length</a>;
<a name="l00779"></a>00779 
<a name="l00780"></a>00780   <span class="comment">/* For types, offset in the type&#39;s DIE of the type defined by this TU.  */</span>
<a name="l00781"></a><a class="code" href="structdwo__unit.html#a88b2cadfe8ed91777ee37fe16bfdc761">00781</a>   <a class="code" href="structcu__offset.html">cu_offset</a> <a class="code" href="structdwo__unit.html#a88b2cadfe8ed91777ee37fe16bfdc761">type_offset_in_tu</a>;
<a name="l00782"></a>00782 };
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 <span class="comment">/* include/dwarf2.h defines the DWP section codes.</span>
<a name="l00785"></a>00785 <span class="comment">   It defines a max value but it doesn&#39;t define a min value, which we</span>
<a name="l00786"></a>00786 <span class="comment">   use for error checking, so provide one.  */</span>
<a name="l00787"></a>00787 
<a name="l00788"></a><a class="code" href="dwarf2read_8c.html#a269649f64e6df73297a5c64e296ec147">00788</a> <span class="keyword">enum</span> <a class="code" href="dwarf2read_8c.html#a269649f64e6df73297a5c64e296ec147">dwp_v2_section_ids</a>
<a name="l00789"></a>00789 {
<a name="l00790"></a><a class="code" href="dwarf2read_8c.html#a269649f64e6df73297a5c64e296ec147ab46c48b40ddccb3cb1e889121140df0b">00790</a>   <a class="code" href="dwarf2read_8c.html#a269649f64e6df73297a5c64e296ec147ab46c48b40ddccb3cb1e889121140df0b">DW_SECT_MIN</a> = 1
<a name="l00791"></a>00791 };
<a name="l00792"></a>00792 
<a name="l00793"></a>00793 <span class="comment">/* Data for one DWO file.</span>
<a name="l00794"></a>00794 <span class="comment"></span>
<a name="l00795"></a>00795 <span class="comment">   This includes virtual DWO files (a virtual DWO file is a DWO file as it</span>
<a name="l00796"></a>00796 <span class="comment">   appears in a DWP file).  DWP files don&#39;t really have DWO files per se -</span>
<a name="l00797"></a>00797 <span class="comment">   comdat folding of types &quot;loses&quot; the DWO file they came from, and from</span>
<a name="l00798"></a>00798 <span class="comment">   a high level view DWP files appear to contain a mass of random types.</span>
<a name="l00799"></a>00799 <span class="comment">   However, to maintain consistency with the non-DWP case we pretend DWP</span>
<a name="l00800"></a>00800 <span class="comment">   files contain virtual DWO files, and we assign each TU with one virtual</span>
<a name="l00801"></a>00801 <span class="comment">   DWO file (generally based on the line and abbrev section offsets -</span>
<a name="l00802"></a>00802 <span class="comment">   a heuristic that seems to work in practice).  */</span>
<a name="l00803"></a>00803 
<a name="l00804"></a><a class="code" href="structdwo__file.html">00804</a> <span class="keyword">struct </span><a class="code" href="structdwo__file.html">dwo_file</a>
<a name="l00805"></a>00805 {
<a name="l00806"></a>00806   <span class="comment">/* The DW_AT_GNU_dwo_name attribute.</span>
<a name="l00807"></a>00807 <span class="comment">     For virtual DWO files the name is constructed from the section offsets</span>
<a name="l00808"></a>00808 <span class="comment">     of abbrev,line,loc,str_offsets so that we combine virtual DWO files</span>
<a name="l00809"></a>00809 <span class="comment">     from related CU+TUs.  */</span>
<a name="l00810"></a><a class="code" href="structdwo__file.html#a6df466b952ebc265d4610f244196e98a">00810</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structdwo__file.html#a6df466b952ebc265d4610f244196e98a">dwo_name</a>;
<a name="l00811"></a>00811 
<a name="l00812"></a>00812   <span class="comment">/* The DW_AT_comp_dir attribute.  */</span>
<a name="l00813"></a><a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">00813</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a>;
<a name="l00814"></a>00814 
<a name="l00815"></a>00815   <span class="comment">/* The bfd, when the file is open.  Otherwise this is NULL.</span>
<a name="l00816"></a>00816 <span class="comment">     This is unused(NULL) for virtual DWO files where we use dwp_file.dbfd.  */</span>
<a name="l00817"></a><a class="code" href="structdwo__file.html#a4121c7ff5fcbf6715852bd45d8e5c6a0">00817</a>   bfd *<a class="code" href="structdwo__file.html#a4121c7ff5fcbf6715852bd45d8e5c6a0">dbfd</a>;
<a name="l00818"></a>00818 
<a name="l00819"></a>00819   <span class="comment">/* The sections that make up this DWO file.</span>
<a name="l00820"></a>00820 <span class="comment">     Remember that for virtual DWO files in DWP V2, these are virtual</span>
<a name="l00821"></a>00821 <span class="comment">     sections (for lack of a better name).  */</span>
<a name="l00822"></a><a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">00822</a>   <span class="keyword">struct </span><a class="code" href="structdwo__sections.html">dwo_sections</a> <a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>;
<a name="l00823"></a>00823 
<a name="l00824"></a>00824   <span class="comment">/* The CU in the file.</span>
<a name="l00825"></a>00825 <span class="comment">     We only support one because having more than one requires hacking the</span>
<a name="l00826"></a>00826 <span class="comment">     dwo_name of each to match, which is highly unlikely to happen.</span>
<a name="l00827"></a>00827 <span class="comment">     Doing this means all TUs can share comp_dir: We also assume that</span>
<a name="l00828"></a>00828 <span class="comment">     DW_AT_comp_dir across all TUs in a DWO file will be identical.  */</span>
<a name="l00829"></a><a class="code" href="structdwo__file.html#a2da7541da154b831fe9428d4f390e932">00829</a>   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structdwo__file.html#a2da7541da154b831fe9428d4f390e932">cu</a>;
<a name="l00830"></a>00830 
<a name="l00831"></a>00831   <span class="comment">/* Table of TUs in the file.</span>
<a name="l00832"></a>00832 <span class="comment">     Each element is a struct dwo_unit.  */</span>
<a name="l00833"></a><a class="code" href="structdwo__file.html#a6ce93a5371a6e123e009d98d81f93ab2">00833</a>   htab_t <a class="code" href="structdwo__file.html#a6ce93a5371a6e123e009d98d81f93ab2">tus</a>;
<a name="l00834"></a>00834 };
<a name="l00835"></a>00835 
<a name="l00836"></a>00836 <span class="comment">/* These sections are what may appear in a DWP file.  */</span>
<a name="l00837"></a>00837 
<a name="l00838"></a><a class="code" href="structdwp__sections.html">00838</a> <span class="keyword">struct </span><a class="code" href="structdwp__sections.html">dwp_sections</a>
<a name="l00839"></a>00839 {
<a name="l00840"></a>00840   <span class="comment">/* These are used by both DWP version 1 and 2.  */</span>
<a name="l00841"></a><a class="code" href="structdwp__sections.html#a6c2c4c7c122c8801d7762bf918f895ba">00841</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwp__sections.html#a6c2c4c7c122c8801d7762bf918f895ba">str</a>;
<a name="l00842"></a><a class="code" href="structdwp__sections.html#a270bca9fb26055e71c6034c765aab8c5">00842</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwp__sections.html#a270bca9fb26055e71c6034c765aab8c5">cu_index</a>;
<a name="l00843"></a><a class="code" href="structdwp__sections.html#a8d3418c9bb110b773192d2e9bb26a3db">00843</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwp__sections.html#a8d3418c9bb110b773192d2e9bb26a3db">tu_index</a>;
<a name="l00844"></a>00844 
<a name="l00845"></a>00845   <span class="comment">/* These are only used by DWP version 2 files.</span>
<a name="l00846"></a>00846 <span class="comment">     In DWP version 1 the .debug_info.dwo, .debug_types.dwo, and other</span>
<a name="l00847"></a>00847 <span class="comment">     sections are referenced by section number, and are not recorded here.</span>
<a name="l00848"></a>00848 <span class="comment">     In DWP version 2 there is at most one copy of all these sections, each</span>
<a name="l00849"></a>00849 <span class="comment">     section being (effectively) comprised of the concatenation of all of the</span>
<a name="l00850"></a>00850 <span class="comment">     individual sections that exist in the version 1 format.</span>
<a name="l00851"></a>00851 <span class="comment">     To keep the code simple we treat each of these concatenated pieces as a</span>
<a name="l00852"></a>00852 <span class="comment">     section itself (a virtual section?).  */</span>
<a name="l00853"></a><a class="code" href="structdwp__sections.html#afa0a4063d5cde27a487217518620aa1c">00853</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwp__sections.html#afa0a4063d5cde27a487217518620aa1c">abbrev</a>;
<a name="l00854"></a><a class="code" href="structdwp__sections.html#a7d11f4f122b19804504fb5d9957a05ee">00854</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwp__sections.html#a7d11f4f122b19804504fb5d9957a05ee">info</a>;
<a name="l00855"></a><a class="code" href="structdwp__sections.html#a78f9d2149461fc3c17cf14437e5aa147">00855</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwp__sections.html#a78f9d2149461fc3c17cf14437e5aa147">line</a>;
<a name="l00856"></a><a class="code" href="structdwp__sections.html#a20c97d6a71b1e68d9b0746eb37843dbf">00856</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwp__sections.html#a20c97d6a71b1e68d9b0746eb37843dbf">loc</a>;
<a name="l00857"></a><a class="code" href="structdwp__sections.html#aaf6bc577681a8b83d024fb097dc13580">00857</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwp__sections.html#aaf6bc577681a8b83d024fb097dc13580">macinfo</a>;
<a name="l00858"></a><a class="code" href="structdwp__sections.html#a859d4582e590abb12e969a750bac824a">00858</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwp__sections.html#a859d4582e590abb12e969a750bac824a">macro</a>;
<a name="l00859"></a><a class="code" href="structdwp__sections.html#a8ff194c59ebf0fe4c9606c21de25f5b8">00859</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwp__sections.html#a8ff194c59ebf0fe4c9606c21de25f5b8">str_offsets</a>;
<a name="l00860"></a><a class="code" href="structdwp__sections.html#a9c5d6ccbf31f42fb4ce3c8a85b9b07d5">00860</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwp__sections.html#a9c5d6ccbf31f42fb4ce3c8a85b9b07d5">types</a>;
<a name="l00861"></a>00861 };
<a name="l00862"></a>00862 
<a name="l00863"></a>00863 <span class="comment">/* These sections are what may appear in a virtual DWO file in DWP version 1.</span>
<a name="l00864"></a>00864 <span class="comment">   A virtual DWO file is a DWO file as it appears in a DWP file.  */</span>
<a name="l00865"></a>00865 
<a name="l00866"></a><a class="code" href="structvirtual__v1__dwo__sections.html">00866</a> <span class="keyword">struct </span><a class="code" href="structvirtual__v1__dwo__sections.html">virtual_v1_dwo_sections</a>
<a name="l00867"></a>00867 {
<a name="l00868"></a><a class="code" href="structvirtual__v1__dwo__sections.html#a501b1f5e3d1cf05f8da6e8a3892e6f20">00868</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structvirtual__v1__dwo__sections.html#a501b1f5e3d1cf05f8da6e8a3892e6f20">abbrev</a>;
<a name="l00869"></a><a class="code" href="structvirtual__v1__dwo__sections.html#aacffb4df6e97deb27518090f70b0cfaa">00869</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structvirtual__v1__dwo__sections.html#aacffb4df6e97deb27518090f70b0cfaa">line</a>;
<a name="l00870"></a><a class="code" href="structvirtual__v1__dwo__sections.html#afda0ffb4ca37375bed44774dfe162a3b">00870</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structvirtual__v1__dwo__sections.html#afda0ffb4ca37375bed44774dfe162a3b">loc</a>;
<a name="l00871"></a><a class="code" href="structvirtual__v1__dwo__sections.html#a9df414f3ed733d94b08abf348e94a09e">00871</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structvirtual__v1__dwo__sections.html#a9df414f3ed733d94b08abf348e94a09e">macinfo</a>;
<a name="l00872"></a><a class="code" href="structvirtual__v1__dwo__sections.html#a77527da788781d0bde33d935df16d82c">00872</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structvirtual__v1__dwo__sections.html#a77527da788781d0bde33d935df16d82c">macro</a>;
<a name="l00873"></a><a class="code" href="structvirtual__v1__dwo__sections.html#a7c2a8ac2bad6195df6b195cce12fde5f">00873</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structvirtual__v1__dwo__sections.html#a7c2a8ac2bad6195df6b195cce12fde5f">str_offsets</a>;
<a name="l00874"></a>00874   <span class="comment">/* Each DWP hash table entry records one CU or one TU.</span>
<a name="l00875"></a>00875 <span class="comment">     That is recorded here, and copied to dwo_unit.section.  */</span>
<a name="l00876"></a><a class="code" href="structvirtual__v1__dwo__sections.html#a28578fc14ad94d56506c10dd292c0d99">00876</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structvirtual__v1__dwo__sections.html#a28578fc14ad94d56506c10dd292c0d99">info_or_types</a>;
<a name="l00877"></a>00877 };
<a name="l00878"></a>00878 
<a name="l00879"></a>00879 <span class="comment">/* Similar to virtual_v1_dwo_sections, but for DWP version 2.</span>
<a name="l00880"></a>00880 <span class="comment">   In version 2, the sections of the DWO files are concatenated together</span>
<a name="l00881"></a>00881 <span class="comment">   and stored in one section of that name.  Thus each ELF section contains</span>
<a name="l00882"></a>00882 <span class="comment">   several &quot;virtual&quot; sections.  */</span>
<a name="l00883"></a>00883 
<a name="l00884"></a><a class="code" href="structvirtual__v2__dwo__sections.html">00884</a> <span class="keyword">struct </span><a class="code" href="structvirtual__v2__dwo__sections.html">virtual_v2_dwo_sections</a>
<a name="l00885"></a>00885 {
<a name="l00886"></a><a class="code" href="structvirtual__v2__dwo__sections.html#a75b17e62efbe955972d07a3cff0ef896">00886</a>   bfd_size_type <a class="code" href="structvirtual__v2__dwo__sections.html#a75b17e62efbe955972d07a3cff0ef896">abbrev_offset</a>;
<a name="l00887"></a><a class="code" href="structvirtual__v2__dwo__sections.html#aeaaf1ae665fdd244492e765ab5de6f5a">00887</a>   bfd_size_type <a class="code" href="structvirtual__v2__dwo__sections.html#aeaaf1ae665fdd244492e765ab5de6f5a">abbrev_size</a>;
<a name="l00888"></a>00888 
<a name="l00889"></a><a class="code" href="structvirtual__v2__dwo__sections.html#ae66a1f7dd61c60b029ba22fb018e9d87">00889</a>   bfd_size_type <a class="code" href="structvirtual__v2__dwo__sections.html#ae66a1f7dd61c60b029ba22fb018e9d87">line_offset</a>;
<a name="l00890"></a><a class="code" href="structvirtual__v2__dwo__sections.html#adbfc93ddb6daaeadfcb3e3a770f95ee7">00890</a>   bfd_size_type <a class="code" href="structvirtual__v2__dwo__sections.html#adbfc93ddb6daaeadfcb3e3a770f95ee7">line_size</a>;
<a name="l00891"></a>00891 
<a name="l00892"></a><a class="code" href="structvirtual__v2__dwo__sections.html#a1e345f1a37dd2d3d9ffa1ef3e01e2008">00892</a>   bfd_size_type <a class="code" href="structvirtual__v2__dwo__sections.html#a1e345f1a37dd2d3d9ffa1ef3e01e2008">loc_offset</a>;
<a name="l00893"></a><a class="code" href="structvirtual__v2__dwo__sections.html#a88fcd4ca1a800e139eb19b1ad904a035">00893</a>   bfd_size_type <a class="code" href="structvirtual__v2__dwo__sections.html#a88fcd4ca1a800e139eb19b1ad904a035">loc_size</a>;
<a name="l00894"></a>00894 
<a name="l00895"></a><a class="code" href="structvirtual__v2__dwo__sections.html#a72986bbf071184450ed51f514c47d6dc">00895</a>   bfd_size_type <a class="code" href="structvirtual__v2__dwo__sections.html#a72986bbf071184450ed51f514c47d6dc">macinfo_offset</a>;
<a name="l00896"></a><a class="code" href="structvirtual__v2__dwo__sections.html#a3a94835aa03fd690c88c06bb625f14a5">00896</a>   bfd_size_type <a class="code" href="structvirtual__v2__dwo__sections.html#a3a94835aa03fd690c88c06bb625f14a5">macinfo_size</a>;
<a name="l00897"></a>00897 
<a name="l00898"></a><a class="code" href="structvirtual__v2__dwo__sections.html#a190f061c6507c1dc7c533d1603f6f9ac">00898</a>   bfd_size_type <a class="code" href="structvirtual__v2__dwo__sections.html#a190f061c6507c1dc7c533d1603f6f9ac">macro_offset</a>;
<a name="l00899"></a><a class="code" href="structvirtual__v2__dwo__sections.html#a036d6b6cf92d341f33ebb5591573cded">00899</a>   bfd_size_type <a class="code" href="structvirtual__v2__dwo__sections.html#a036d6b6cf92d341f33ebb5591573cded">macro_size</a>;
<a name="l00900"></a>00900 
<a name="l00901"></a><a class="code" href="structvirtual__v2__dwo__sections.html#a6201888dd2e2c792b2670bfe2ed4fe4d">00901</a>   bfd_size_type <a class="code" href="structvirtual__v2__dwo__sections.html#a6201888dd2e2c792b2670bfe2ed4fe4d">str_offsets_offset</a>;
<a name="l00902"></a><a class="code" href="structvirtual__v2__dwo__sections.html#a228e439bf2ef92c0e706ae462213f94d">00902</a>   bfd_size_type <a class="code" href="structvirtual__v2__dwo__sections.html#a228e439bf2ef92c0e706ae462213f94d">str_offsets_size</a>;
<a name="l00903"></a>00903 
<a name="l00904"></a>00904   <span class="comment">/* Each DWP hash table entry records one CU or one TU.</span>
<a name="l00905"></a>00905 <span class="comment">     That is recorded here, and copied to dwo_unit.section.  */</span>
<a name="l00906"></a><a class="code" href="structvirtual__v2__dwo__sections.html#aae75ff6da59935b575990609652bdcf8">00906</a>   bfd_size_type <a class="code" href="structvirtual__v2__dwo__sections.html#aae75ff6da59935b575990609652bdcf8">info_or_types_offset</a>;
<a name="l00907"></a><a class="code" href="structvirtual__v2__dwo__sections.html#af2293306baaead1763e24ad3745dc612">00907</a>   bfd_size_type <a class="code" href="structvirtual__v2__dwo__sections.html#af2293306baaead1763e24ad3745dc612">info_or_types_size</a>;
<a name="l00908"></a>00908 };
<a name="l00909"></a>00909 
<a name="l00910"></a>00910 <span class="comment">/* Contents of DWP hash tables.  */</span>
<a name="l00911"></a>00911 
<a name="l00912"></a><a class="code" href="structdwp__hash__table.html">00912</a> <span class="keyword">struct </span><a class="code" href="structdwp__hash__table.html">dwp_hash_table</a>
<a name="l00913"></a>00913 {
<a name="l00914"></a><a class="code" href="structdwp__hash__table.html#ad38d9c9206bccf97bd24595df1a835f5">00914</a>   uint32_t <a class="code" href="structdwp__hash__table.html#ad38d9c9206bccf97bd24595df1a835f5">version</a>, <a class="code" href="structdwp__hash__table.html#ae8d2ae0d45ddf25ba7e747073fa27a75">nr_columns</a>;
<a name="l00915"></a><a class="code" href="structdwp__hash__table.html#a7fc7c527fef9be71ffca081ac9196176">00915</a>   uint32_t <a class="code" href="structdwp__hash__table.html#a7fc7c527fef9be71ffca081ac9196176">nr_units</a>, <a class="code" href="structdwp__hash__table.html#acba74e56ea8e20a178776efb67f1f116">nr_slots</a>;
<a name="l00916"></a><a class="code" href="structdwp__hash__table.html#a39f54c3b62972c745b825ca208f75dc3">00916</a>   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structdwp__hash__table.html#a57d51c828de01425fca35da068091053">hash_table</a>, *<a class="code" href="structdwp__hash__table.html#a39f54c3b62972c745b825ca208f75dc3">unit_table</a>;
<a name="l00917"></a>00917   <span class="keyword">union</span>
<a name="l00918"></a>00918   {
<a name="l00919"></a>00919     <span class="keyword">struct</span>
<a name="l00920"></a>00920     {
<a name="l00921"></a><a class="code" href="structdwp__hash__table.html#a25d322582f788c2f36e21585a53ec198">00921</a>       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structdwp__hash__table.html#a25d322582f788c2f36e21585a53ec198">indices</a>;
<a name="l00922"></a>00922     } <a class="code" href="structdwp__hash__table.html#a26e7e69be056ca2e4f22137f854255a2">v1</a>;
<a name="l00923"></a>00923     <span class="keyword">struct</span>
<a name="l00924"></a>00924     {
<a name="l00925"></a>00925       <span class="comment">/* This is indexed by column number and gives the id of the section</span>
<a name="l00926"></a>00926 <span class="comment">         in that column.  */</span>
<a name="l00927"></a><a class="code" href="dwarf2read_8c.html#a1abfd0ab73e1d5e9a0e40c19892d67aa">00927</a> <span class="preprocessor">#define MAX_NR_V2_DWO_SECTIONS \</span>
<a name="l00928"></a>00928 <span class="preprocessor">  (1 </span><span class="comment">/* .debug_info or .debug_types */</span> \
<a name="l00929"></a>00929    + 1 <span class="comment">/* .debug_abbrev */</span> \
<a name="l00930"></a>00930    + 1 <span class="comment">/* .debug_line */</span> \
<a name="l00931"></a>00931    + 1 <span class="comment">/* .debug_loc */</span> \
<a name="l00932"></a>00932    + 1 <span class="comment">/* .debug_str_offsets */</span> \
<a name="l00933"></a>00933    + 1 <span class="comment">/* .debug_macro or .debug_macinfo */</span>)
<a name="l00934"></a><a class="code" href="structdwp__hash__table.html#ac3a230754c958ca88ea034222e38884b">00934</a>       <span class="keywordtype">int</span> <a class="code" href="structdwp__hash__table.html#ac3a230754c958ca88ea034222e38884b">section_ids</a>[<a class="code" href="dwarf2read_8c.html#a1abfd0ab73e1d5e9a0e40c19892d67aa">MAX_NR_V2_DWO_SECTIONS</a>];
<a name="l00935"></a><a class="code" href="structdwp__hash__table.html#ac0e1df56dcf2fb3aa943f8d41647c7bc">00935</a>       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structdwp__hash__table.html#ac0e1df56dcf2fb3aa943f8d41647c7bc">offsets</a>;
<a name="l00936"></a><a class="code" href="structdwp__hash__table.html#a2e68a1a290a498f9031e378cdcfe4d75">00936</a>       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structdwp__hash__table.html#a2e68a1a290a498f9031e378cdcfe4d75">sizes</a>;
<a name="l00937"></a>00937     } <a class="code" href="structdwp__hash__table.html#affa91d46f63f99d33ac14a22f6b7a4ab">v2</a>;
<a name="l00938"></a>00938   } <a class="code" href="structdwp__hash__table.html#a0978d29a4d56158c0aa01740e310fdfc">section_pool</a>;
<a name="l00939"></a>00939 };
<a name="l00940"></a>00940 
<a name="l00941"></a>00941 <span class="comment">/* Data for one DWP file.  */</span>
<a name="l00942"></a>00942 
<a name="l00943"></a><a class="code" href="structdwp__file.html">00943</a> <span class="keyword">struct </span><a class="code" href="structdwp__file.html">dwp_file</a>
<a name="l00944"></a>00944 {
<a name="l00945"></a>00945   <span class="comment">/* Name of the file.  */</span>
<a name="l00946"></a><a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">00946</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>;
<a name="l00947"></a>00947 
<a name="l00948"></a>00948   <span class="comment">/* File format version.  */</span>
<a name="l00949"></a><a class="code" href="structdwp__file.html#a140a3d3a09fc7aaf072b96eae87173fb">00949</a>   <span class="keywordtype">int</span> <a class="code" href="structdwp__file.html#a140a3d3a09fc7aaf072b96eae87173fb">version</a>;
<a name="l00950"></a>00950 
<a name="l00951"></a>00951   <span class="comment">/* The bfd.  */</span>
<a name="l00952"></a><a class="code" href="structdwp__file.html#adaac28c08d06f0daf3633e997b0abdb1">00952</a>   bfd *<a class="code" href="structdwp__file.html#adaac28c08d06f0daf3633e997b0abdb1">dbfd</a>;
<a name="l00953"></a>00953 
<a name="l00954"></a>00954   <span class="comment">/* Section info for this file.  */</span>
<a name="l00955"></a><a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">00955</a>   <span class="keyword">struct </span><a class="code" href="structdwp__sections.html">dwp_sections</a> <a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>;
<a name="l00956"></a>00956 
<a name="l00957"></a>00957   <span class="comment">/* Table of CUs in the file.  */</span>
<a name="l00958"></a><a class="code" href="structdwp__file.html#a6539ad818bafae68a09889c2eb985780">00958</a>   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwp__hash__table.html">dwp_hash_table</a> *<a class="code" href="structdwp__file.html#a6539ad818bafae68a09889c2eb985780">cus</a>;
<a name="l00959"></a>00959 
<a name="l00960"></a>00960   <span class="comment">/* Table of TUs in the file.  */</span>
<a name="l00961"></a><a class="code" href="structdwp__file.html#a1f5edbd4eb259b9605d86511d87f117c">00961</a>   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwp__hash__table.html">dwp_hash_table</a> *<a class="code" href="structdwp__file.html#a1f5edbd4eb259b9605d86511d87f117c">tus</a>;
<a name="l00962"></a>00962 
<a name="l00963"></a>00963   <span class="comment">/* Tables of loaded CUs/TUs.  Each entry is a struct dwo_unit *.  */</span>
<a name="l00964"></a><a class="code" href="structdwp__file.html#a4a52577c25dc38801f555317f99f7731">00964</a>   htab_t <a class="code" href="structdwp__file.html#a4a52577c25dc38801f555317f99f7731">loaded_cus</a>;
<a name="l00965"></a><a class="code" href="structdwp__file.html#a9115bf303bce67f7e83c91ec1c7ffb8f">00965</a>   htab_t <a class="code" href="structdwp__file.html#a9115bf303bce67f7e83c91ec1c7ffb8f">loaded_tus</a>;
<a name="l00966"></a>00966 
<a name="l00967"></a>00967   <span class="comment">/* Table to map ELF section numbers to their sections.</span>
<a name="l00968"></a>00968 <span class="comment">     This is only needed for the DWP V1 file format.  */</span>
<a name="l00969"></a><a class="code" href="structdwp__file.html#a3bf1bb3c9f65550e349531242e7cafcc">00969</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structdwp__file.html#a3bf1bb3c9f65550e349531242e7cafcc">num_sections</a>;
<a name="l00970"></a><a class="code" href="structdwp__file.html#a402f52900899dc36afb1ccabfe8b21cd">00970</a>   asection **<a class="code" href="structdwp__file.html#a402f52900899dc36afb1ccabfe8b21cd">elf_sections</a>;
<a name="l00971"></a>00971 };
<a name="l00972"></a>00972 
<a name="l00973"></a>00973 <span class="comment">/* This represents a &#39;.dwz&#39; file.  */</span>
<a name="l00974"></a>00974 
<a name="l00975"></a><a class="code" href="structdwz__file.html">00975</a> <span class="keyword">struct </span><a class="code" href="structdwz__file.html">dwz_file</a>
<a name="l00976"></a>00976 {
<a name="l00977"></a>00977   <span class="comment">/* A dwz file can only contain a few sections.  */</span>
<a name="l00978"></a><a class="code" href="structdwz__file.html#a6d54052c436197e540e433c95f5361e3">00978</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwz__file.html#a6d54052c436197e540e433c95f5361e3">abbrev</a>;
<a name="l00979"></a><a class="code" href="structdwz__file.html#a2c4f25245be0e458f196af80a990969c">00979</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwz__file.html#a2c4f25245be0e458f196af80a990969c">info</a>;
<a name="l00980"></a><a class="code" href="structdwz__file.html#a7eb5552ada9f95eca388ad29b74c28af">00980</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwz__file.html#a7eb5552ada9f95eca388ad29b74c28af">str</a>;
<a name="l00981"></a><a class="code" href="structdwz__file.html#ae4fcce172e64ed4d7940f70a5e5d6c32">00981</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwz__file.html#ae4fcce172e64ed4d7940f70a5e5d6c32">line</a>;
<a name="l00982"></a><a class="code" href="structdwz__file.html#a76ea7d4cb4937ee64a3383736362e123">00982</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwz__file.html#a76ea7d4cb4937ee64a3383736362e123">macro</a>;
<a name="l00983"></a><a class="code" href="structdwz__file.html#acc28fb02f48f40d5a1b7b454b138474d">00983</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> <a class="code" href="structdwz__file.html#acc28fb02f48f40d5a1b7b454b138474d">gdb_index</a>;
<a name="l00984"></a>00984 
<a name="l00985"></a>00985   <span class="comment">/* The dwz&#39;s BFD.  */</span>
<a name="l00986"></a><a class="code" href="structdwz__file.html#a9fc9bf241da902e55d1a4ddbaa8141eb">00986</a>   bfd *<a class="code" href="structdwz__file.html#a9fc9bf241da902e55d1a4ddbaa8141eb">dwz_bfd</a>;
<a name="l00987"></a>00987 };
<a name="l00988"></a>00988 
<a name="l00989"></a>00989 <span class="comment">/* Struct used to pass misc. parameters to read_die_and_children, et</span>
<a name="l00990"></a>00990 <span class="comment">   al.  which are used for both .debug_info and .debug_types dies.</span>
<a name="l00991"></a>00991 <span class="comment">   All parameters here are unchanging for the life of the call.  This</span>
<a name="l00992"></a>00992 <span class="comment">   struct exists to abstract away the constant parameters of die reading.  */</span>
<a name="l00993"></a>00993 
<a name="l00994"></a><a class="code" href="structdie__reader__specs.html">00994</a> <span class="keyword">struct </span><a class="code" href="structdie__reader__specs.html">die_reader_specs</a>
<a name="l00995"></a>00995 {
<a name="l00996"></a>00996   <span class="comment">/* The bfd of die_section.  */</span>
<a name="l00997"></a><a class="code" href="structdie__reader__specs.html#a1a2ea4151d385459f3a3fb7b0dad2973">00997</a>   bfd* <a class="code" href="structdie__reader__specs.html#a1a2ea4151d385459f3a3fb7b0dad2973">abfd</a>;
<a name="l00998"></a>00998 
<a name="l00999"></a>00999   <span class="comment">/* The CU of the DIE we are parsing.  */</span>
<a name="l01000"></a><a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">01000</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l01001"></a>01001 
<a name="l01002"></a>01002   <span class="comment">/* Non-NULL if reading a DWO file (including one packaged into a DWP).  */</span>
<a name="l01003"></a><a class="code" href="structdie__reader__specs.html#a64321aff4f42ed613b8831c4d0804c36">01003</a>   <span class="keyword">struct </span><a class="code" href="structdwo__file.html">dwo_file</a> *<a class="code" href="structdie__reader__specs.html#a64321aff4f42ed613b8831c4d0804c36">dwo_file</a>;
<a name="l01004"></a>01004 
<a name="l01005"></a>01005   <span class="comment">/* The section the die comes from.</span>
<a name="l01006"></a>01006 <span class="comment">     This is either .debug_info or .debug_types, or the .dwo variants.  */</span>
<a name="l01007"></a><a class="code" href="structdie__reader__specs.html#a59f8ddce0966e4c55a24c4f051a1917e">01007</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *<a class="code" href="structdie__reader__specs.html#a59f8ddce0966e4c55a24c4f051a1917e">die_section</a>;
<a name="l01008"></a>01008 
<a name="l01009"></a>01009   <span class="comment">/* die_section-&gt;buffer.  */</span>
<a name="l01010"></a><a class="code" href="structdie__reader__specs.html#a923f3b4252ec94584560d5433e848dc0">01010</a>   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structdie__reader__specs.html#a923f3b4252ec94584560d5433e848dc0">buffer</a>;
<a name="l01011"></a>01011 
<a name="l01012"></a>01012   <span class="comment">/* The end of the buffer.  */</span>
<a name="l01013"></a><a class="code" href="structdie__reader__specs.html#ae090c8e4b75582074889118172ea9095">01013</a>   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structdie__reader__specs.html#ae090c8e4b75582074889118172ea9095">buffer_end</a>;
<a name="l01014"></a>01014 
<a name="l01015"></a>01015   <span class="comment">/* The value of the DW_AT_comp_dir attribute.  */</span>
<a name="l01016"></a><a class="code" href="structdie__reader__specs.html#afca780af991e478e77f4915e4632102f">01016</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structdie__reader__specs.html#afca780af991e478e77f4915e4632102f">comp_dir</a>;
<a name="l01017"></a>01017 };
<a name="l01018"></a>01018 
<a name="l01019"></a>01019 <span class="comment">/* Type of function passed to init_cutu_and_read_dies, et.al.  */</span>
<a name="l01020"></a><a class="code" href="dwarf2read_8c.html#a78918e349d1b0b7715599fa171aab050">01020</a> <span class="keyword">typedef</span> void (<a class="code" href="dwarf2read_8c.html#a78918e349d1b0b7715599fa171aab050">die_reader_func_ftype</a>) (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l01021"></a>01021                                       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l01022"></a>01022                                       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *comp_unit_die,
<a name="l01023"></a>01023                                       <span class="keywordtype">int</span> has_children,
<a name="l01024"></a>01024                                       <span class="keywordtype">void</span> *data);
<a name="l01025"></a>01025 
<a name="l01026"></a>01026 <span class="comment">/* The line number information for a compilation unit (found in the</span>
<a name="l01027"></a>01027 <span class="comment">   .debug_line section) begins with a &quot;statement program header&quot;,</span>
<a name="l01028"></a>01028 <span class="comment">   which contains the following information.  */</span>
<a name="l01029"></a><a class="code" href="structline__header.html">01029</a> <span class="keyword">struct </span><a class="code" href="structline__header.html">line_header</a>
<a name="l01030"></a>01030 {
<a name="l01031"></a><a class="code" href="structline__header.html#af695cc75cf99fc2550f21b4039d9e53f">01031</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structline__header.html#af695cc75cf99fc2550f21b4039d9e53f">total_length</a>;
<a name="l01032"></a><a class="code" href="structline__header.html#a310e5e9f12b07a08e4c508370450cfcc">01032</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="structline__header.html#a310e5e9f12b07a08e4c508370450cfcc">version</a>;
<a name="l01033"></a><a class="code" href="structline__header.html#ad9d50c3392f8bdacce7da5b3c4eba3f1">01033</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structline__header.html#ad9d50c3392f8bdacce7da5b3c4eba3f1">header_length</a>;
<a name="l01034"></a><a class="code" href="structline__header.html#a0ded590fbc4ad196cc2ba36ca5963e1a">01034</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structline__header.html#a0ded590fbc4ad196cc2ba36ca5963e1a">minimum_instruction_length</a>;
<a name="l01035"></a><a class="code" href="structline__header.html#ab11deabba24eabe57960856f3e5a47bb">01035</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structline__header.html#ab11deabba24eabe57960856f3e5a47bb">maximum_ops_per_instruction</a>;
<a name="l01036"></a><a class="code" href="structline__header.html#a8d783ae46e1831d48f71693cbd8f4931">01036</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structline__header.html#a8d783ae46e1831d48f71693cbd8f4931">default_is_stmt</a>;
<a name="l01037"></a><a class="code" href="structline__header.html#a9c2448a272a79bb798d963fae8f5b305">01037</a>   <span class="keywordtype">int</span> <a class="code" href="structline__header.html#a9c2448a272a79bb798d963fae8f5b305">line_base</a>;
<a name="l01038"></a><a class="code" href="structline__header.html#a433918b1f2ecc23cc8116442b2800bfc">01038</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structline__header.html#a433918b1f2ecc23cc8116442b2800bfc">line_range</a>;
<a name="l01039"></a><a class="code" href="structline__header.html#ad2a6411397863aa4d1931feaa00327b6">01039</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structline__header.html#ad2a6411397863aa4d1931feaa00327b6">opcode_base</a>;
<a name="l01040"></a>01040 
<a name="l01041"></a>01041   <span class="comment">/* standard_opcode_lengths[i] is the number of operands for the</span>
<a name="l01042"></a>01042 <span class="comment">     standard opcode whose value is i.  This means that</span>
<a name="l01043"></a>01043 <span class="comment">     standard_opcode_lengths[0] is unused, and the last meaningful</span>
<a name="l01044"></a>01044 <span class="comment">     element is standard_opcode_lengths[opcode_base - 1].  */</span>
<a name="l01045"></a><a class="code" href="structline__header.html#a03b9061576badda7a0d72053c713dca8">01045</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="structline__header.html#a03b9061576badda7a0d72053c713dca8">standard_opcode_lengths</a>;
<a name="l01046"></a>01046 
<a name="l01047"></a>01047   <span class="comment">/* The include_directories table.  NOTE!  These strings are not</span>
<a name="l01048"></a>01048 <span class="comment">     allocated with xmalloc; instead, they are pointers into</span>
<a name="l01049"></a>01049 <span class="comment">     debug_line_buffer.  If you try to free them, `free&#39; will get</span>
<a name="l01050"></a>01050 <span class="comment">     indigestion.  */</span>
<a name="l01051"></a><a class="code" href="structline__header.html#a964a9375d1e583ba5af063ed07de0f8e">01051</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structline__header.html#a964a9375d1e583ba5af063ed07de0f8e">num_include_dirs</a>, <a class="code" href="structline__header.html#a56a396ec7694be5d0f9ad8f89da6a523">include_dirs_size</a>;
<a name="l01052"></a><a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">01052</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> **<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a>;
<a name="l01053"></a>01053 
<a name="l01054"></a>01054   <span class="comment">/* The file_names table.  NOTE!  These strings are not allocated</span>
<a name="l01055"></a>01055 <span class="comment">     with xmalloc; instead, they are pointers into debug_line_buffer.</span>
<a name="l01056"></a>01056 <span class="comment">     Don&#39;t try to free them directly.  */</span>
<a name="l01057"></a><a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">01057</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a>, <a class="code" href="structline__header.html#a1b6f1018fc0d5e55f09b75453c00a9ba">file_names_size</a>;
<a name="l01058"></a><a class="code" href="structline__header_1_1file__entry.html">01058</a>   <span class="keyword">struct </span><a class="code" href="structline__header_1_1file__entry.html">file_entry</a>
<a name="l01059"></a>01059   {
<a name="l01060"></a><a class="code" href="structline__header_1_1file__entry.html#a97ef624fdc8da05cda47eacc540e428b">01060</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structline__header_1_1file__entry.html#a97ef624fdc8da05cda47eacc540e428b">name</a>;
<a name="l01061"></a><a class="code" href="structline__header_1_1file__entry.html#a48fdbb04c65a3ff2e67c21024fcaeead">01061</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structline__header_1_1file__entry.html#a48fdbb04c65a3ff2e67c21024fcaeead">dir_index</a>;
<a name="l01062"></a><a class="code" href="structline__header_1_1file__entry.html#a5fe58468e55124982075c29d81e46cc5">01062</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structline__header_1_1file__entry.html#a5fe58468e55124982075c29d81e46cc5">mod_time</a>;
<a name="l01063"></a><a class="code" href="structline__header_1_1file__entry.html#a047222d5c52ac5003c2266ec8eb4fba4">01063</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structline__header_1_1file__entry.html#a047222d5c52ac5003c2266ec8eb4fba4">length</a>;
<a name="l01064"></a><a class="code" href="structline__header_1_1file__entry.html#a6a169260c0b31870645999eb38a0c86c">01064</a>     <span class="keywordtype">int</span> <a class="code" href="structline__header_1_1file__entry.html#a6a169260c0b31870645999eb38a0c86c">included_p</a>; <span class="comment">/* Non-zero if referenced by the Line Number Program.  */</span>
<a name="l01065"></a><a class="code" href="structline__header_1_1file__entry.html#af5f03277ff57c007ec3d1908999bf057">01065</a>     <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structline__header_1_1file__entry.html#af5f03277ff57c007ec3d1908999bf057">symtab</a>; <span class="comment">/* The associated symbol table, if any.  */</span>
<a name="l01066"></a>01066   } *<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>;
<a name="l01067"></a>01067 
<a name="l01068"></a>01068   <span class="comment">/* The start and end of the statement program following this</span>
<a name="l01069"></a>01069 <span class="comment">     header.  These point into dwarf2_per_objfile-&gt;line_buffer.  */</span>
<a name="l01070"></a><a class="code" href="structline__header.html#a213bcc6bc49b3282d163d89ccad32395">01070</a>   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structline__header.html#a213bcc6bc49b3282d163d89ccad32395">statement_program_start</a>, *<a class="code" href="structline__header.html#a0e8f9a1407b470dd4dd383c6508191a7">statement_program_end</a>;
<a name="l01071"></a>01071 };
<a name="l01072"></a>01072 
<a name="l01073"></a>01073 <span class="comment">/* When we construct a partial symbol table entry we only</span>
<a name="l01074"></a>01074 <span class="comment">   need this much information.  */</span>
<a name="l01075"></a><a class="code" href="structpartial__die__info.html">01075</a> <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a>
<a name="l01076"></a>01076   {
<a name="l01077"></a>01077     <span class="comment">/* Offset of this DIE.  */</span>
<a name="l01078"></a><a class="code" href="structpartial__die__info.html#a5db48cad0baeb15b63822fdaa0136c04">01078</a>     <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="structpartial__die__info.html#a5db48cad0baeb15b63822fdaa0136c04">offset</a>;
<a name="l01079"></a>01079 
<a name="l01080"></a>01080     <span class="comment">/* DWARF-2 tag for this DIE.  */</span>
<a name="l01081"></a><a class="code" href="structpartial__die__info.html#abba1696917b4fe569f4b35dbdbb4efe4">01081</a>     <a class="code" href="structpartial__die__info.html#abba1696917b4fe569f4b35dbdbb4efe4">ENUM_BITFIELD</a>(dwarf_tag) tag : 16;
<a name="l01082"></a>01082 
<a name="l01083"></a>01083     <span class="comment">/* Assorted flags describing the data found in this DIE.  */</span>
<a name="l01084"></a>01084     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> has_children : 1;
<a name="l01085"></a>01085     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_external : 1;
<a name="l01086"></a>01086     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_declaration : 1;
<a name="l01087"></a>01087     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> has_type : 1;
<a name="l01088"></a>01088     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> has_specification : 1;
<a name="l01089"></a>01089     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> has_pc_info : 1;
<a name="l01090"></a>01090     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> may_be_inlined : 1;
<a name="l01091"></a>01091 
<a name="l01092"></a>01092     <span class="comment">/* Flag set if the SCOPE field of this structure has been</span>
<a name="l01093"></a>01093 <span class="comment">       computed.  */</span>
<a name="l01094"></a>01094     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> scope_set : 1;
<a name="l01095"></a>01095 
<a name="l01096"></a>01096     <span class="comment">/* Flag set if the DIE has a byte_size attribute.  */</span>
<a name="l01097"></a>01097     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> has_byte_size : 1;
<a name="l01098"></a>01098 
<a name="l01099"></a>01099     <span class="comment">/* Flag set if any of the DIE&#39;s children are template arguments.  */</span>
<a name="l01100"></a>01100     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> has_template_arguments : 1;
<a name="l01101"></a>01101 
<a name="l01102"></a>01102     <span class="comment">/* Flag set if fixup_partial_die has been called on this die.  */</span>
<a name="l01103"></a>01103     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fixup_called : 1;
<a name="l01104"></a>01104 
<a name="l01105"></a>01105     <span class="comment">/* Flag set if DW_TAG_imported_unit uses DW_FORM_GNU_ref_alt.  */</span>
<a name="l01106"></a>01106     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_dwz : 1;
<a name="l01107"></a>01107 
<a name="l01108"></a>01108     <span class="comment">/* Flag set if spec_offset uses DW_FORM_GNU_ref_alt.  */</span>
<a name="l01109"></a>01109     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> spec_is_dwz : 1;
<a name="l01110"></a>01110 
<a name="l01111"></a>01111     <span class="comment">/* The name of this DIE.  Normally the value of DW_AT_name, but</span>
<a name="l01112"></a>01112 <span class="comment">       sometimes a default name for unnamed DIEs.  */</span>
<a name="l01113"></a>01113     <a class="code" href="p-lang_8h.html#a21296fc6f36ba2fc4d9780fdd126acb5">const</a> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01114"></a>01114 
<a name="l01115"></a>01115     <span class="comment">/* The linkage name, if present.  */</span>
<a name="l01116"></a>01116     <a class="code" href="p-lang_8h.html#a21296fc6f36ba2fc4d9780fdd126acb5">const</a> <span class="keywordtype">char</span> *linkage_name;
<a name="l01117"></a>01117 
<a name="l01118"></a>01118     <span class="comment">/* The scope to prepend to our children.  This is generally</span>
<a name="l01119"></a>01119 <span class="comment">       allocated on the comp_unit_obstack, so will disappear</span>
<a name="l01120"></a>01120 <span class="comment">       when this compilation unit leaves the cache.  */</span>
<a name="l01121"></a>01121     <a class="code" href="p-lang_8h.html#a21296fc6f36ba2fc4d9780fdd126acb5">const</a> <span class="keywordtype">char</span> *scope;
<a name="l01122"></a>01122 
<a name="l01123"></a>01123     <span class="comment">/* Some data associated with the partial DIE.  The tag determines</span>
<a name="l01124"></a>01124 <span class="comment">       which field is live.  */</span>
<a name="l01125"></a>01125     union
<a name="l01126"></a>01126     {
<a name="l01127"></a>01127       <span class="comment">/* The location description associated with this DIE, if any.  */</span>
<a name="l01128"></a>01128       <span class="keyword">struct </span><a class="code" href="structdwarf__block.html">dwarf_block</a> *locdesc;
<a name="l01129"></a>01129       <span class="comment">/* The offset of an import, for DW_TAG_imported_unit.  */</span>
<a name="l01130"></a>01130       <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="structpartial__die__info.html#a5db48cad0baeb15b63822fdaa0136c04">offset</a>;
<a name="l01131"></a><a class="code" href="structpartial__die__info.html#ab829867c034259d5dda8a61679232609">01131</a>     } <a class="code" href="structpartial__die__info.html#ab829867c034259d5dda8a61679232609">d</a>;
<a name="l01132"></a>01132 
<a name="l01133"></a>01133     <span class="comment">/* If HAS_PC_INFO, the PC range associated with this DIE.  */</span>
<a name="l01134"></a><a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">01134</a>     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a>;
<a name="l01135"></a><a class="code" href="structpartial__die__info.html#a958cea19f3de0168488931ed04efc700">01135</a>     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structpartial__die__info.html#a958cea19f3de0168488931ed04efc700">highpc</a>;
<a name="l01136"></a>01136 
<a name="l01137"></a>01137     <span class="comment">/* Pointer into the info_buffer (or types_buffer) pointing at the target of</span>
<a name="l01138"></a>01138 <span class="comment">       DW_AT_sibling, if any.  */</span>
<a name="l01139"></a>01139     <span class="comment">/* NOTE: This member isn&#39;t strictly necessary, read_partial_die could</span>
<a name="l01140"></a>01140 <span class="comment">       return DW_AT_sibling values to its caller load_partial_dies.  */</span>
<a name="l01141"></a><a class="code" href="structpartial__die__info.html#aaf967ab6265b2f79cd8cc292ee597c49">01141</a>     <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structpartial__die__info.html#aaf967ab6265b2f79cd8cc292ee597c49">sibling</a>;
<a name="l01142"></a>01142 
<a name="l01143"></a>01143     <span class="comment">/* If HAS_SPECIFICATION, the offset of the DIE referred to by</span>
<a name="l01144"></a>01144 <span class="comment">       DW_AT_specification (or DW_AT_abstract_origin or</span>
<a name="l01145"></a>01145 <span class="comment">       DW_AT_extension).  */</span>
<a name="l01146"></a><a class="code" href="structpartial__die__info.html#ac9faa23b0720fe4585288e1286917877">01146</a>     <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="structpartial__die__info.html#ac9faa23b0720fe4585288e1286917877">spec_offset</a>;
<a name="l01147"></a>01147 
<a name="l01148"></a>01148     <span class="comment">/* Pointers to this DIE&#39;s parent, first child, and next sibling,</span>
<a name="l01149"></a>01149 <span class="comment">       if any.  */</span>
<a name="l01150"></a><a class="code" href="structpartial__die__info.html#ad62d4a24f9c19d6835843c6a066fea36">01150</a>     <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *<a class="code" href="structpartial__die__info.html#add5cb3fe3a136089a2cafa7027e59687">die_parent</a>, *<a class="code" href="structpartial__die__info.html#a7761befb396a96f0d770f8b2a126291b">die_child</a>, *<a class="code" href="structpartial__die__info.html#ad62d4a24f9c19d6835843c6a066fea36">die_sibling</a>;
<a name="l01151"></a>01151   };
<a name="l01152"></a>01152 
<a name="l01153"></a>01153 <span class="comment">/* This data structure holds the information of an abbrev.  */</span>
<a name="l01154"></a><a class="code" href="structabbrev__info.html">01154</a> <span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a>
<a name="l01155"></a>01155   {
<a name="l01156"></a><a class="code" href="structabbrev__info.html#ac7dcce6d183c93d3af481347ba841eae">01156</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structabbrev__info.html#ac7dcce6d183c93d3af481347ba841eae">number</a>;        <span class="comment">/* number identifying abbrev */</span>
<a name="l01157"></a><a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">01157</a>     <span class="keyword">enum</span> dwarf_tag <a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a>;         <span class="comment">/* dwarf tag */</span>
<a name="l01158"></a><a class="code" href="structabbrev__info.html#ac84c5aceafdfea0a95c619f623b78de1">01158</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="structabbrev__info.html#ac84c5aceafdfea0a95c619f623b78de1">has_children</a>;                <span class="comment">/* boolean */</span>
<a name="l01159"></a><a class="code" href="structabbrev__info.html#a34d2e21fe3925a6c1613e8e42993581e">01159</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="structabbrev__info.html#a34d2e21fe3925a6c1613e8e42993581e">num_attrs</a>;   <span class="comment">/* number of attributes */</span>
<a name="l01160"></a><a class="code" href="structabbrev__info.html#aa70664d01df5b3d3567c6841c9de22f2">01160</a>     <span class="keyword">struct </span><a class="code" href="structattr__abbrev.html">attr_abbrev</a> *<a class="code" href="structabbrev__info.html#aa70664d01df5b3d3567c6841c9de22f2">attrs</a>;  <span class="comment">/* an array of attribute descriptions */</span>
<a name="l01161"></a><a class="code" href="structabbrev__info.html#ad6b9b79c292fe4b7c9f7367e1464fe33">01161</a>     <span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a> *<a class="code" href="structabbrev__info.html#ad6b9b79c292fe4b7c9f7367e1464fe33">next</a>;   <span class="comment">/* next in chain */</span>
<a name="l01162"></a>01162   };
<a name="l01163"></a>01163 
<a name="l01164"></a><a class="code" href="structattr__abbrev.html">01164</a> <span class="keyword">struct </span><a class="code" href="structattr__abbrev.html">attr_abbrev</a>
<a name="l01165"></a>01165   {
<a name="l01166"></a>01166     ENUM_BITFIELD(dwarf_attribute) <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a> : 16;
<a name="l01167"></a>01167     ENUM_BITFIELD(dwarf_form) form : 16;
<a name="l01168"></a>01168   };
<a name="l01169"></a>01169 
<a name="l01170"></a>01170 <span class="comment">/* Size of abbrev_table.abbrev_hash_table.  */</span>
<a name="l01171"></a><a class="code" href="dwarf2read_8c.html#a7b47d7d684ec59e2a7c822a58883362d">01171</a> <span class="preprocessor">#define ABBREV_HASH_SIZE 121</span>
<a name="l01172"></a>01172 <span class="preprocessor"></span>
<a name="l01173"></a>01173 <span class="comment">/* Top level data structure to contain an abbreviation table.  */</span>
<a name="l01174"></a>01174 
<a name="l01175"></a><a class="code" href="structabbrev__table.html">01175</a> <span class="keyword">struct </span><a class="code" href="structabbrev__table.html">abbrev_table</a>
<a name="l01176"></a>01176 {
<a name="l01177"></a>01177   <span class="comment">/* Where the abbrev table came from.</span>
<a name="l01178"></a>01178 <span class="comment">     This is used as a sanity check when the table is used.  */</span>
<a name="l01179"></a><a class="code" href="structabbrev__table.html#a5b67ef89ee9470388052b1acd4c44b57">01179</a>   <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="structabbrev__table.html#a5b67ef89ee9470388052b1acd4c44b57">offset</a>;
<a name="l01180"></a>01180 
<a name="l01181"></a>01181   <span class="comment">/* Storage for the abbrev table.  */</span>
<a name="l01182"></a><a class="code" href="structabbrev__table.html#a557aeda40bed392d106012843a4bf8e8">01182</a>   <span class="keyword">struct </span>obstack <a class="code" href="structabbrev__table.html#a557aeda40bed392d106012843a4bf8e8">abbrev_obstack</a>;
<a name="l01183"></a>01183 
<a name="l01184"></a>01184   <span class="comment">/* Hash table of abbrevs.</span>
<a name="l01185"></a>01185 <span class="comment">     This is an array of size ABBREV_HASH_SIZE allocated in abbrev_obstack.</span>
<a name="l01186"></a>01186 <span class="comment">     It could be statically allocated, but the previous code didn&#39;t so we</span>
<a name="l01187"></a>01187 <span class="comment">     don&#39;t either.  */</span>
<a name="l01188"></a><a class="code" href="structabbrev__table.html#a1d499a87c6d8a864be99c0c245c9f64d">01188</a>   <span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a> **<a class="code" href="structabbrev__table.html#a1d499a87c6d8a864be99c0c245c9f64d">abbrevs</a>;
<a name="l01189"></a>01189 };
<a name="l01190"></a>01190 
<a name="l01191"></a>01191 <span class="comment">/* Attributes have a name and a value.  */</span>
<a name="l01192"></a><a class="code" href="structattribute.html">01192</a> <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a>
<a name="l01193"></a>01193   {
<a name="l01194"></a><a class="code" href="structattribute.html#a5e42ef4c076d7005e4c1ef2b04903ed5">01194</a>     <a class="code" href="structattribute.html#a5e42ef4c076d7005e4c1ef2b04903ed5">ENUM_BITFIELD</a>(dwarf_attribute) <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a> : 16;
<a name="l01195"></a>01195     <a class="code" href="structattribute.html#a5e42ef4c076d7005e4c1ef2b04903ed5">ENUM_BITFIELD</a>(dwarf_form) form : 15;
<a name="l01196"></a>01196 
<a name="l01197"></a>01197     <span class="comment">/* Has DW_STRING already been updated by dwarf2_canonicalize_name?  This</span>
<a name="l01198"></a>01198 <span class="comment">       field should be in u.str (existing only for DW_STRING) but it is kept</span>
<a name="l01199"></a>01199 <span class="comment">       here for better struct attribute alignment.  */</span>
<a name="l01200"></a>01200     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> string_is_canonical : 1;
<a name="l01201"></a>01201 
<a name="l01202"></a>01202     union
<a name="l01203"></a>01203       {
<a name="l01204"></a>01204         <span class="keyword">const</span> <span class="keywordtype">char</span> *str;
<a name="l01205"></a>01205         <span class="keyword">struct </span><a class="code" href="structdwarf__block.html">dwarf_block</a> *blk;
<a name="l01206"></a>01206         <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> unsnd;
<a name="l01207"></a>01207         <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> snd;
<a name="l01208"></a>01208         <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr;
<a name="l01209"></a>01209         <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> signature;
<a name="l01210"></a>01210       }
<a name="l01211"></a><a class="code" href="structattribute.html#a615a09e185bf5cd35bc546cfd6833e5b">01211</a>     <a class="code" href="structattribute.html#a615a09e185bf5cd35bc546cfd6833e5b">u</a>;
<a name="l01212"></a>01212   };
<a name="l01213"></a>01213 
<a name="l01214"></a>01214 <span class="comment">/* This data structure holds a complete die structure.  */</span>
<a name="l01215"></a><a class="code" href="structdie__info.html">01215</a> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a>
<a name="l01216"></a>01216   {
<a name="l01217"></a>01217     <span class="comment">/* DWARF-2 tag for this DIE.  */</span>
<a name="l01218"></a>01218     ENUM_BITFIELD(dwarf_tag) tag : 16;
<a name="l01219"></a>01219 
<a name="l01220"></a>01220     <span class="comment">/* Number of attributes */</span>
<a name="l01221"></a>01221     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> num_attrs;
<a name="l01222"></a>01222 
<a name="l01223"></a>01223     <span class="comment">/* True if we&#39;re presently building the full type name for the</span>
<a name="l01224"></a>01224 <span class="comment">       type derived from this DIE.  */</span>
<a name="l01225"></a>01225     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> building_fullname : 1;
<a name="l01226"></a>01226 
<a name="l01227"></a>01227     <span class="comment">/* Abbrev number */</span>
<a name="l01228"></a>01228     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> abbrev;
<a name="l01229"></a>01229 
<a name="l01230"></a>01230     <span class="comment">/* Offset in .debug_info or .debug_types section.  */</span>
<a name="l01231"></a>01231     <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l01232"></a>01232 
<a name="l01233"></a>01233     <span class="comment">/* The dies in a compilation unit form an n-ary tree.  PARENT</span>
<a name="l01234"></a>01234 <span class="comment">       points to this die&#39;s parent; CHILD points to the first child of</span>
<a name="l01235"></a>01235 <span class="comment">       this node; and all the children of a given node are chained</span>
<a name="l01236"></a>01236 <span class="comment">       together via their SIBLING fields.  */</span>
<a name="l01237"></a>01237     <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child;     <span class="comment">/* Its first child, if any.  */</span>
<a name="l01238"></a>01238     <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *sibling;   <span class="comment">/* Its next sibling, if any.  */</span>
<a name="l01239"></a>01239     <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *parent;    <span class="comment">/* Its parent, if any.  */</span>
<a name="l01240"></a>01240 
<a name="l01241"></a>01241     <span class="comment">/* An array of attributes, with NUM_ATTRS elements.  There may be</span>
<a name="l01242"></a>01242 <span class="comment">       zero, but it&#39;s not common and zero-sized arrays are not</span>
<a name="l01243"></a>01243 <span class="comment">       sufficiently portable C.  */</span>
<a name="l01244"></a>01244     <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> attrs[1];
<a name="l01245"></a>01245   };
<a name="l01246"></a>01246 
<a name="l01247"></a>01247 <span class="comment">/* Get at parts of an attribute structure.  */</span>
<a name="l01248"></a>01248 
<a name="l01249"></a><a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">01249</a> <span class="preprocessor">#define DW_STRING(attr)    ((attr)-&gt;u.str)</span>
<a name="l01250"></a><a class="code" href="dwarf2read_8c.html#a307f18e0d403d80487696d1a0a5d0fd6">01250</a> <span class="preprocessor"></span><span class="preprocessor">#define DW_STRING_IS_CANONICAL(attr) ((attr)-&gt;string_is_canonical)</span>
<a name="l01251"></a><a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">01251</a> <span class="preprocessor"></span><span class="preprocessor">#define DW_UNSND(attr)     ((attr)-&gt;u.unsnd)</span>
<a name="l01252"></a><a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">01252</a> <span class="preprocessor"></span><span class="preprocessor">#define DW_BLOCK(attr)     ((attr)-&gt;u.blk)</span>
<a name="l01253"></a><a class="code" href="dwarf2read_8c.html#a66159661f7b11878469288def232a3e4">01253</a> <span class="preprocessor"></span><span class="preprocessor">#define DW_SND(attr)       ((attr)-&gt;u.snd)</span>
<a name="l01254"></a><a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">01254</a> <span class="preprocessor"></span><span class="preprocessor">#define DW_ADDR(attr)      ((attr)-&gt;u.addr)</span>
<a name="l01255"></a><a class="code" href="dwarf2read_8c.html#a8ba60632a90cfabc155c69f0bf2d2f83">01255</a> <span class="preprocessor"></span><span class="preprocessor">#define DW_SIGNATURE(attr) ((attr)-&gt;u.signature)</span>
<a name="l01256"></a>01256 <span class="preprocessor"></span>
<a name="l01257"></a>01257 <span class="comment">/* Blocks are a bunch of untyped bytes.  */</span>
<a name="l01258"></a><a class="code" href="structdwarf__block.html">01258</a> <span class="keyword">struct </span><a class="code" href="structdwarf__block.html">dwarf_block</a>
<a name="l01259"></a>01259   {
<a name="l01260"></a><a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">01260</a>     <span class="keywordtype">size_t</span> <a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a>;
<a name="l01261"></a>01261 
<a name="l01262"></a>01262     <span class="comment">/* Valid only if SIZE is not zero.  */</span>
<a name="l01263"></a><a class="code" href="structdwarf__block.html#af3a8e3eb0d783b103b0078662dbdc211">01263</a>     <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structdwarf__block.html#af3a8e3eb0d783b103b0078662dbdc211">data</a>;
<a name="l01264"></a>01264   };
<a name="l01265"></a>01265 
<a name="l01266"></a>01266 <span class="preprocessor">#ifndef ATTR_ALLOC_CHUNK</span>
<a name="l01267"></a><a class="code" href="dwarf2read_8c.html#a7539803265b0574cb2c4ac0d58c3841e">01267</a> <span class="preprocessor"></span><span class="preprocessor">#define ATTR_ALLOC_CHUNK 4</span>
<a name="l01268"></a>01268 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01269"></a>01269 <span class="preprocessor"></span>
<a name="l01270"></a>01270 <span class="comment">/* Allocate fields for structs, unions and enums in this size.  */</span>
<a name="l01271"></a>01271 <span class="preprocessor">#ifndef DW_FIELD_ALLOC_CHUNK</span>
<a name="l01272"></a><a class="code" href="dwarf2read_8c.html#aa40456d31b1edb968e39e63c9a8dd42b">01272</a> <span class="preprocessor"></span><span class="preprocessor">#define DW_FIELD_ALLOC_CHUNK 4</span>
<a name="l01273"></a>01273 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01274"></a>01274 <span class="preprocessor"></span>
<a name="l01275"></a>01275 <span class="comment">/* FIXME: We might want to set this from BFD via bfd_arch_bits_per_byte,</span>
<a name="l01276"></a>01276 <span class="comment">   but this would require a corresponding change in unpack_field_as_long</span>
<a name="l01277"></a>01277 <span class="comment">   and friends.  */</span>
<a name="l01278"></a><a class="code" href="dwarf2read_8c.html#aa777b588c12ad10add04077214f1c976">01278</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#aa777b588c12ad10add04077214f1c976">bits_per_byte</a> = 8;
<a name="l01279"></a>01279 
<a name="l01280"></a>01280 <span class="comment">/* The routines that read and process dies for a C struct or C++ class</span>
<a name="l01281"></a>01281 <span class="comment">   pass lists of data member fields and lists of member function fields</span>
<a name="l01282"></a>01282 <span class="comment">   in an instance of a field_info structure, as defined below.  */</span>
<a name="l01283"></a><a class="code" href="structfield__info.html">01283</a> <span class="keyword">struct </span><a class="code" href="structfield__info.html">field_info</a>
<a name="l01284"></a>01284   {
<a name="l01285"></a>01285     <span class="comment">/* List of data member and baseclasses fields.  */</span>
<a name="l01286"></a><a class="code" href="structfield__info_1_1nextfield.html">01286</a>     <span class="keyword">struct </span><a class="code" href="structfield__info_1_1nextfield.html">nextfield</a>
<a name="l01287"></a>01287       {
<a name="l01288"></a><a class="code" href="structfield__info_1_1nextfield.html#a1010bef865819b3dc9609941d15f3000">01288</a>         <span class="keyword">struct </span><a class="code" href="structfield__info_1_1nextfield.html">nextfield</a> *<a class="code" href="structfield__info_1_1nextfield.html#a1010bef865819b3dc9609941d15f3000">next</a>;
<a name="l01289"></a><a class="code" href="structfield__info_1_1nextfield.html#ac9cbfe60b3451f4af16076afb1cb464b">01289</a>         <span class="keywordtype">int</span> <a class="code" href="structfield__info_1_1nextfield.html#ac9cbfe60b3451f4af16076afb1cb464b">accessibility</a>;
<a name="l01290"></a><a class="code" href="structfield__info_1_1nextfield.html#ae767dcc6d3fa5f3ec83b10e811b6c944">01290</a>         <span class="keywordtype">int</span> <a class="code" href="structfield__info_1_1nextfield.html#ae767dcc6d3fa5f3ec83b10e811b6c944">virtuality</a>;
<a name="l01291"></a><a class="code" href="structfield__info_1_1nextfield.html#a92d769142ba51793df963957f82da966">01291</a>         <span class="keyword">struct </span><a class="code" href="structfield__info_1_1nextfield.html#a92d769142ba51793df963957f82da966">field</a> <a class="code" href="structfield__info_1_1nextfield.html#a92d769142ba51793df963957f82da966">field</a>;
<a name="l01292"></a>01292       }
<a name="l01293"></a>01293      *<a class="code" href="structfield__info.html#a2a3a9b900c54be57557e694dfd9281e2">fields</a>, *<a class="code" href="structfield__info.html#aacf7e4f83f9b1ef0b30c69ea61c67e14">baseclasses</a>;
<a name="l01294"></a>01294 
<a name="l01295"></a>01295     <span class="comment">/* Number of fields (including baseclasses).  */</span>
<a name="l01296"></a><a class="code" href="structfield__info.html#a09bd04c8bcdb22c9bc1ce43df30aac8d">01296</a>     <span class="keywordtype">int</span> <a class="code" href="structfield__info.html#a09bd04c8bcdb22c9bc1ce43df30aac8d">nfields</a>;
<a name="l01297"></a>01297 
<a name="l01298"></a>01298     <span class="comment">/* Number of baseclasses.  */</span>
<a name="l01299"></a><a class="code" href="structfield__info.html#a3e885cc79f0f6ddc667f29da409bdf39">01299</a>     <span class="keywordtype">int</span> <a class="code" href="structfield__info.html#a3e885cc79f0f6ddc667f29da409bdf39">nbaseclasses</a>;
<a name="l01300"></a>01300 
<a name="l01301"></a>01301     <span class="comment">/* Set if the accesibility of one of the fields is not public.  */</span>
<a name="l01302"></a><a class="code" href="structfield__info.html#a5252d305726ae0aa5594e0b1e20b61fd">01302</a>     <span class="keywordtype">int</span> <a class="code" href="structfield__info.html#a5252d305726ae0aa5594e0b1e20b61fd">non_public_fields</a>;
<a name="l01303"></a>01303 
<a name="l01304"></a>01304     <span class="comment">/* Member function fields array, entries are allocated in the order they</span>
<a name="l01305"></a>01305 <span class="comment">       are encountered in the object file.  */</span>
<a name="l01306"></a><a class="code" href="structfield__info_1_1nextfnfield.html">01306</a>     <span class="keyword">struct </span><a class="code" href="structfield__info_1_1nextfnfield.html">nextfnfield</a>
<a name="l01307"></a>01307       {
<a name="l01308"></a><a class="code" href="structfield__info_1_1nextfnfield.html#a05c547b396a327bfe99e2a9e07560252">01308</a>         <span class="keyword">struct </span><a class="code" href="structfield__info_1_1nextfnfield.html">nextfnfield</a> *<a class="code" href="structfield__info_1_1nextfnfield.html#a05c547b396a327bfe99e2a9e07560252">next</a>;
<a name="l01309"></a><a class="code" href="structfield__info_1_1nextfnfield.html#ae99e034c1809235e7d3a6842bf8e64cb">01309</a>         <span class="keyword">struct </span>fn_field <a class="code" href="structfield__info_1_1nextfnfield.html#ae99e034c1809235e7d3a6842bf8e64cb">fnfield</a>;
<a name="l01310"></a>01310       }
<a name="l01311"></a>01311      *<a class="code" href="structfield__info.html#ae7416786d36d5888e0f4ec775026caa3">fnfields</a>;
<a name="l01312"></a>01312 
<a name="l01313"></a>01313     <span class="comment">/* Member function fieldlist array, contains name of possibly overloaded</span>
<a name="l01314"></a>01314 <span class="comment">       member function, number of overloaded member functions and a pointer</span>
<a name="l01315"></a>01315 <span class="comment">       to the head of the member function field chain.  */</span>
<a name="l01316"></a><a class="code" href="structfield__info_1_1fnfieldlist.html">01316</a>     <span class="keyword">struct </span><a class="code" href="structfield__info_1_1fnfieldlist.html">fnfieldlist</a>
<a name="l01317"></a>01317       {
<a name="l01318"></a><a class="code" href="structfield__info_1_1fnfieldlist.html#ae73cbcc4c33451761041ffc02017aba2">01318</a>         <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structfield__info_1_1fnfieldlist.html#ae73cbcc4c33451761041ffc02017aba2">name</a>;
<a name="l01319"></a><a class="code" href="structfield__info_1_1fnfieldlist.html#a2d9307f9d0b422fb64084e783765f009">01319</a>         <span class="keywordtype">int</span> <a class="code" href="structfield__info_1_1fnfieldlist.html#a2d9307f9d0b422fb64084e783765f009">length</a>;
<a name="l01320"></a><a class="code" href="structfield__info_1_1fnfieldlist.html#a97561258a28548ec9ed372c4e68cbe5f">01320</a>         <span class="keyword">struct </span><a class="code" href="structfield__info_1_1nextfnfield.html">nextfnfield</a> *<a class="code" href="structfield__info_1_1fnfieldlist.html#a97561258a28548ec9ed372c4e68cbe5f">head</a>;
<a name="l01321"></a>01321       }
<a name="l01322"></a>01322      *<a class="code" href="structfield__info.html#ac4d52aeefe9db6d377a933868817d021">fnfieldlists</a>;
<a name="l01323"></a>01323 
<a name="l01324"></a>01324     <span class="comment">/* Number of entries in the fnfieldlists array.  */</span>
<a name="l01325"></a><a class="code" href="structfield__info.html#a025391eca616fef2c461bb079f422e3e">01325</a>     <span class="keywordtype">int</span> <a class="code" href="structfield__info.html#a025391eca616fef2c461bb079f422e3e">nfnfields</a>;
<a name="l01326"></a>01326 
<a name="l01327"></a>01327     <span class="comment">/* typedefs defined inside this class.  TYPEDEF_FIELD_LIST contains head of</span>
<a name="l01328"></a>01328 <span class="comment">       a NULL terminated list of TYPEDEF_FIELD_LIST_COUNT elements.  */</span>
<a name="l01329"></a><a class="code" href="structfield__info_1_1typedef__field__list.html">01329</a>     <span class="keyword">struct </span><a class="code" href="structfield__info_1_1typedef__field__list.html">typedef_field_list</a>
<a name="l01330"></a>01330       {
<a name="l01331"></a><a class="code" href="structfield__info_1_1typedef__field__list.html#acc713b1964cd17fe6b8a6025ab60d783">01331</a>         <span class="keyword">struct </span>typedef_field <a class="code" href="structfield__info_1_1typedef__field__list.html#acc713b1964cd17fe6b8a6025ab60d783">field</a>;
<a name="l01332"></a><a class="code" href="structfield__info_1_1typedef__field__list.html#a24bf090b04961658ea024d3ac16b3f7b">01332</a>         <span class="keyword">struct </span><a class="code" href="structfield__info_1_1typedef__field__list.html">typedef_field_list</a> *<a class="code" href="structfield__info_1_1typedef__field__list.html#a24bf090b04961658ea024d3ac16b3f7b">next</a>;
<a name="l01333"></a>01333       }
<a name="l01334"></a>01334     *<a class="code" href="structfield__info.html#a1861c9d86ad164a461664702e67c90d3">typedef_field_list</a>;
<a name="l01335"></a><a class="code" href="structfield__info.html#a60696c993efeb4eed00ec2ac741931f2">01335</a>     <span class="keywordtype">unsigned</span> <a class="code" href="structfield__info.html#a60696c993efeb4eed00ec2ac741931f2">typedef_field_list_count</a>;
<a name="l01336"></a>01336   };
<a name="l01337"></a>01337 
<a name="l01338"></a>01338 <span class="comment">/* One item on the queue of compilation units to read in full symbols</span>
<a name="l01339"></a>01339 <span class="comment">   for.  */</span>
<a name="l01340"></a><a class="code" href="structdwarf2__queue__item.html">01340</a> <span class="keyword">struct </span><a class="code" href="structdwarf2__queue__item.html">dwarf2_queue_item</a>
<a name="l01341"></a>01341 {
<a name="l01342"></a><a class="code" href="structdwarf2__queue__item.html#a0ff411ef5efcea7cbedd53dfc6eed639">01342</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *<a class="code" href="structdwarf2__queue__item.html#a0ff411ef5efcea7cbedd53dfc6eed639">per_cu</a>;
<a name="l01343"></a><a class="code" href="structdwarf2__queue__item.html#a69804da124a8e018b54e4f88c306c619">01343</a>   <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> <a class="code" href="structdwarf2__queue__item.html#a69804da124a8e018b54e4f88c306c619">pretend_language</a>;
<a name="l01344"></a><a class="code" href="structdwarf2__queue__item.html#a39fec37eb2c8cd48833d0b2a62cbbbc2">01344</a>   <span class="keyword">struct </span><a class="code" href="structdwarf2__queue__item.html">dwarf2_queue_item</a> *<a class="code" href="structdwarf2__queue__item.html#a39fec37eb2c8cd48833d0b2a62cbbbc2">next</a>;
<a name="l01345"></a>01345 };
<a name="l01346"></a>01346 
<a name="l01347"></a>01347 <span class="comment">/* The current queue.  */</span>
<a name="l01348"></a><a class="code" href="dwarf2read_8c.html#a77e708f0b7e4d59d7698744d4d8b2a0b">01348</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__queue__item.html">dwarf2_queue_item</a> *<a class="code" href="dwarf2read_8c.html#a67167a2d3a620a19ccff32ede1c3a2f5">dwarf2_queue</a>, *<a class="code" href="dwarf2read_8c.html#a77e708f0b7e4d59d7698744d4d8b2a0b">dwarf2_queue_tail</a>;
<a name="l01349"></a>01349 
<a name="l01350"></a>01350 <span class="comment">/* Loaded secondary compilation units are kept in memory until they</span>
<a name="l01351"></a>01351 <span class="comment">   have not been referenced for the processing of this many</span>
<a name="l01352"></a>01352 <span class="comment">   compilation units.  Set this to zero to disable caching.  Cache</span>
<a name="l01353"></a>01353 <span class="comment">   sizes of up to at least twenty will improve startup time for</span>
<a name="l01354"></a>01354 <span class="comment">   typical inter-CU-reference binaries, at an obvious memory cost.  */</span>
<a name="l01355"></a><a class="code" href="dwarf2read_8c.html#a1ebe9ac2a67f2df99ca92aacf6b25163">01355</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a1ebe9ac2a67f2df99ca92aacf6b25163">dwarf2_max_cache_age</a> = 5;
<a name="l01356"></a>01356 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01357"></a><a class="code" href="dwarf2read_8c.html#a7eec2ffafc31c744a6d30109558f32d7">01357</a> <a class="code" href="dwarf2read_8c.html#a7eec2ffafc31c744a6d30109558f32d7">show_dwarf2_max_cache_age</a> (<span class="keyword">struct</span> <a class="code" href="structui__file.html">ui_file</a> *file, <span class="keywordtype">int</span> from_tty,
<a name="l01358"></a>01358                            <span class="keyword">struct</span> <a class="code" href="structcmd__list__element.html">cmd_list_element</a> *c, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structvalue.html">value</a>)
<a name="l01359"></a>01359 {
<a name="l01360"></a>01360   <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (file, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;The upper bound on the age of cached &quot;</span>
<a name="l01361"></a>01361                             <span class="stringliteral">&quot;dwarf2 compilation units is %s.\n&quot;</span>),
<a name="l01362"></a>01362                     value);
<a name="l01363"></a>01363 }
<a name="l01364"></a>01364 
<a name="l01365"></a>01365 <span class="comment">/* local function prototypes */</span>
<a name="l01366"></a>01366 
<a name="l01367"></a>01367 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#a206c558e28b7bc7fcf8bdad145cabef1">get_section_name</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *);
<a name="l01368"></a>01368 
<a name="l01369"></a>01369 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#a1c841524fdd0bd73272dad700a7452f6">get_section_file_name</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *);
<a name="l01370"></a>01370 
<a name="l01371"></a>01371 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#accff25a253034949d9c4cfded38d2d72">dwarf2_locate_sections</a> (bfd *, asection *, <span class="keywordtype">void</span> *);
<a name="l01372"></a>01372 
<a name="l01373"></a>01373 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#af314d232c2dcff121c89ecf2ed276658">dwarf2_find_base_address</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l01374"></a>01374                                       <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01375"></a>01375 
<a name="l01376"></a>01376 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *<a class="code" href="dwarf2read_8c.html#ab4b70e57fa288b01beeda2f9526b5fde">create_partial_symtab</a>
<a name="l01377"></a>01377   (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>);
<a name="l01378"></a>01378 
<a name="l01379"></a>01379 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#aef51fb88d6ce2db82dbfed7ae8ac929e">dwarf2_build_psymtabs_hard</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l01380"></a>01380 
<a name="l01381"></a>01381 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#aeffcf90b9b19c7413fc505d0bf8e8657">scan_partial_symbols</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *,
<a name="l01382"></a>01382                                   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *,
<a name="l01383"></a>01383                                   <span class="keywordtype">int</span>, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01384"></a>01384 
<a name="l01385"></a>01385 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a46d3f288e2cd7c77113df32913e69f56">add_partial_symbol</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *,
<a name="l01386"></a>01386                                 <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01387"></a>01387 
<a name="l01388"></a>01388 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#abf35f752bbaa1439406817912d068c66">add_partial_namespace</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *pdi,
<a name="l01389"></a>01389                                    <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *lowpc, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *highpc,
<a name="l01390"></a>01390                                    <span class="keywordtype">int</span> need_pc, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01391"></a>01391 
<a name="l01392"></a>01392 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a9ec445afdbd9cf0243499e47665d0d83">add_partial_module</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *pdi, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *lowpc,
<a name="l01393"></a>01393                                 <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *highpc, <span class="keywordtype">int</span> need_pc,
<a name="l01394"></a>01394                                 <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01395"></a>01395 
<a name="l01396"></a>01396 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#abf32e648b8d904a35eb48ac91073708a">add_partial_enumeration</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *enum_pdi,
<a name="l01397"></a>01397                                      <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01398"></a>01398 
<a name="l01399"></a>01399 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a35c693a59ce32f823e31c31ab56b1d78">add_partial_subprogram</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *pdi,
<a name="l01400"></a>01400                                     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *lowpc, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *highpc,
<a name="l01401"></a>01401                                     <span class="keywordtype">int</span> need_pc, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01402"></a>01402 
<a name="l01403"></a>01403 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#ad51fcf6e9b38c802ac64c2dc6f19d167">dwarf2_read_symtab</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *,
<a name="l01404"></a>01404                                 <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l01405"></a>01405 
<a name="l01406"></a>01406 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a28d3f50615a68b574ce61a8bd85258eb">psymtab_to_symtab_1</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *);
<a name="l01407"></a>01407 
<a name="l01408"></a>01408 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a> *<a class="code" href="dwarf2read_8c.html#a320857b558736bdfe9fa88072e106841">abbrev_table_lookup_abbrev</a>
<a name="l01409"></a>01409   (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structabbrev__table.html">abbrev_table</a> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
<a name="l01410"></a>01410 
<a name="l01411"></a>01411 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structabbrev__table.html">abbrev_table</a> *<a class="code" href="dwarf2read_8c.html#a7c5fe8c826ddc3a8ecdcb9e7899912f3">abbrev_table_read_table</a>
<a name="l01412"></a>01412   (<span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *, <a class="code" href="structsect__offset.html">sect_offset</a>);
<a name="l01413"></a>01413 
<a name="l01414"></a>01414 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a657ffcf72df342d61df4a8893fc6151f">abbrev_table_free</a> (<span class="keyword">struct</span> <a class="code" href="structabbrev__table.html">abbrev_table</a> *);
<a name="l01415"></a>01415 
<a name="l01416"></a>01416 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a6c9598f51c0ca31c3f615940abb8d605">abbrev_table_free_cleanup</a> (<span class="keywordtype">void</span> *);
<a name="l01417"></a>01417 
<a name="l01418"></a>01418 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a2ab84af9aed9d7ab89a9c1389bf09944">dwarf2_read_abbrevs</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *,
<a name="l01419"></a>01419                                  <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *);
<a name="l01420"></a>01420 
<a name="l01421"></a>01421 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a966c2eb4689779cf219c72bbcda90b83">dwarf2_free_abbrev_table</a> (<span class="keywordtype">void</span> *);
<a name="l01422"></a>01422 
<a name="l01423"></a>01423 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a750ce8dd923161d4fd41793c6965ca6c">peek_abbrev_code</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *);
<a name="l01424"></a>01424 
<a name="l01425"></a>01425 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *<a class="code" href="dwarf2read_8c.html#a2bf39a75877292252ae39938c7fa6885">load_partial_dies</a>
<a name="l01426"></a>01426   (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *, <span class="keywordtype">int</span>);
<a name="l01427"></a>01427 
<a name="l01428"></a>01428 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="dwarf2read_8c.html#a288297ebd7e0b6037f0b863192d9cf8c">read_partial_die</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *,
<a name="l01429"></a>01429                                          <span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *,
<a name="l01430"></a>01430                                          <span class="keyword">struct</span> <a class="code" href="structabbrev__info.html">abbrev_info</a> *,
<a name="l01431"></a>01431                                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>,
<a name="l01432"></a>01432                                          <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *);
<a name="l01433"></a>01433 
<a name="l01434"></a>01434 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *<a class="code" href="dwarf2read_8c.html#a58e31b8772918ff152fc61303028195a">find_partial_die</a> (<a class="code" href="structsect__offset.html">sect_offset</a>, <span class="keywordtype">int</span>,
<a name="l01435"></a>01435                                                   <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01436"></a>01436 
<a name="l01437"></a>01437 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a271dd2144532648290913da6252d331b">fixup_partial_die</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *,
<a name="l01438"></a>01438                                <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01439"></a>01439 
<a name="l01440"></a>01440 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="dwarf2read_8c.html#a08e1a18f85e288f9241d3baab2ded2b0">read_attribute</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *,
<a name="l01441"></a>01441                                        <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *, <span class="keyword">struct</span> <a class="code" href="structattr__abbrev.html">attr_abbrev</a> *,
<a name="l01442"></a>01442                                        <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *);
<a name="l01443"></a>01443 
<a name="l01444"></a>01444 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *);
<a name="l01445"></a>01445 
<a name="l01446"></a>01446 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a29c46d3cfe71a70e5ba65f3cd31c3ad5">read_1_signed_byte</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *);
<a name="l01447"></a>01447 
<a name="l01448"></a>01448 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a35663eebf65b4217082f14bc1f782307">read_2_bytes</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *);
<a name="l01449"></a>01449 
<a name="l01450"></a>01450 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *);
<a name="l01451"></a>01451 
<a name="l01452"></a>01452 <span class="keyword">static</span> <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="dwarf2read_8c.html#af21c01feb67cfb3cd240c3ac803dd021">read_8_bytes</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *);
<a name="l01453"></a>01453 
<a name="l01454"></a>01454 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">read_address</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *ptr, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *,
<a name="l01455"></a>01455                                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *);
<a name="l01456"></a>01456 
<a name="l01457"></a>01457 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="dwarf2read_8c.html#a40cbc7bcde605127cf1baef337c57f9e">read_initial_length</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *);
<a name="l01458"></a>01458 
<a name="l01459"></a>01459 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="dwarf2read_8c.html#a7944620736e702f37e23ffd06e743fab">read_checked_initial_length_and_offset</a>
<a name="l01460"></a>01460   (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *,
<a name="l01461"></a>01461    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *);
<a name="l01462"></a>01462 
<a name="l01463"></a>01463 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="dwarf2read_8c.html#afd4b43dc237191df908291fb832628e5">read_offset</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *,
<a name="l01464"></a>01464                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *,
<a name="l01465"></a>01465                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *);
<a name="l01466"></a>01466 
<a name="l01467"></a>01467 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="dwarf2read_8c.html#a7d7df1bb27bd8e2cdd3b27bafd16640b">read_offset_1</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
<a name="l01468"></a>01468 
<a name="l01469"></a>01469 <span class="keyword">static</span> <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="dwarf2read_8c.html#a425a94e1261e39a64375fdca7368bca2">read_abbrev_offset</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *,
<a name="l01470"></a>01470                                        <a class="code" href="structsect__offset.html">sect_offset</a>);
<a name="l01471"></a>01471 
<a name="l01472"></a>01472 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="dwarf2read_8c.html#a7078db3bb8caab1b87567e9e8441d95f">read_n_bytes</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
<a name="l01473"></a>01473 
<a name="l01474"></a>01474 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#a5386044c6f74a934dbd3f4a3199cf5be">read_direct_string</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *);
<a name="l01475"></a>01475 
<a name="l01476"></a>01476 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#a3bafaf539b850b4e8610f36fefb1b4a2">read_indirect_string</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *,
<a name="l01477"></a>01477                                          <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *,
<a name="l01478"></a>01478                                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *);
<a name="l01479"></a>01479 
<a name="l01480"></a>01480 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#aae8af1e5be4adc81e8945968faf67e31">read_indirect_string_from_dwz</a> (<span class="keyword">struct</span> <a class="code" href="structdwz__file.html">dwz_file</a> *, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>);
<a name="l01481"></a>01481 
<a name="l01482"></a>01482 <span class="keyword">static</span> <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *);
<a name="l01483"></a>01483 
<a name="l01484"></a>01484 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="dwarf2read_8c.html#adfbc149c8807d37b14d0d217da31ada0">read_signed_leb128</a> (bfd *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *);
<a name="l01485"></a>01485 
<a name="l01486"></a>01486 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="dwarf2read_8c.html#a62579cbb3d5cf28bac5bff46f3d7ed11">read_addr_index_from_leb128</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *,
<a name="l01487"></a>01487                                               <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *,
<a name="l01488"></a>01488                                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *);
<a name="l01489"></a>01489 
<a name="l01490"></a>01490 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#a11ef1cbeffac261cacbe27fa98628253">read_str_index</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l01491"></a>01491                                    <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> str_index);
<a name="l01492"></a>01492 
<a name="l01493"></a>01493 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#abd567fd6ea120b361c1b04ce7c20ea54">set_cu_language</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01494"></a>01494 
<a name="l01495"></a>01495 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *<a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>,
<a name="l01496"></a>01496                                       <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01497"></a>01497 
<a name="l01498"></a>01498 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *<a class="code" href="dwarf2read_8c.html#a50710a3c575e046cafb61f16aaca480f">dwarf2_attr_no_follow</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *,
<a name="l01499"></a>01499                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
<a name="l01500"></a>01500 
<a name="l01501"></a>01501 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#ae71fe9211c7daaccc4d43abbe838c8dc">dwarf2_flag_true_p</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keywordtype">unsigned</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>,
<a name="l01502"></a>01502                                <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01503"></a>01503 
<a name="l01504"></a>01504 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#aa9ca23caab102417f39b86b7b2716588">die_is_declaration</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01505"></a>01505 
<a name="l01506"></a>01506 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *<a class="code" href="dwarf2read_8c.html#a86adfa4fccde4cd4c512ca520e5bb1d7">die_specification</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l01507"></a>01507                                            <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> **);
<a name="l01508"></a>01508 
<a name="l01509"></a>01509 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a2b16344b24303ef21765208ef32dfe7a">free_line_header</a> (<span class="keyword">struct</span> <a class="code" href="structline__header.html">line_header</a> *lh);
<a name="l01510"></a>01510 
<a name="l01511"></a>01511 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structline__header.html">line_header</a> *<a class="code" href="dwarf2read_8c.html#af87c579a0baccecf09b54fc18af2dea5">dwarf_decode_line_header</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>,
<a name="l01512"></a>01512                                                      <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01513"></a>01513 
<a name="l01514"></a>01514 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#af810de33caeeaf4969d37ee378ef6e06">dwarf_decode_lines</a> (<span class="keyword">struct</span> <a class="code" href="structline__header.html">line_header</a> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *,
<a name="l01515"></a>01515                                 <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *, <span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *,
<a name="l01516"></a>01516                                 <span class="keywordtype">int</span>);
<a name="l01517"></a>01517 
<a name="l01518"></a>01518 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#ad6fdb87bbae94e6e0f3b4e9f46b15182">dwarf2_start_subfile</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l01519"></a>01519 
<a name="l01520"></a>01520 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a6682d90849e89e7ce892ec7d58cf4c9c">dwarf2_start_symtab</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *,
<a name="l01521"></a>01521                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>);
<a name="l01522"></a>01522 
<a name="l01523"></a>01523 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *<a class="code" href="dwarf2read_8c.html#a4b79d225399dba2c4a3397a858440dd4">new_symbol</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l01524"></a>01524                                   <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01525"></a>01525 
<a name="l01526"></a>01526 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *<a class="code" href="dwarf2read_8c.html#a3fc581e6a60a1d1195917cf292c45234">new_symbol_full</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l01527"></a>01527                                        <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *);
<a name="l01528"></a>01528 
<a name="l01529"></a>01529 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a87cdf01457f983687ddcb8f7a377b581">dwarf2_const_value</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *,
<a name="l01530"></a>01530                                 <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01531"></a>01531 
<a name="l01532"></a>01532 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#af4c429879bd3d814ab4b878a0d4f926e">dwarf2_const_value_attr</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr,
<a name="l01533"></a>01533                                      <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>,
<a name="l01534"></a>01534                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>,
<a name="l01535"></a>01535                                      <span class="keyword">struct</span> obstack *obstack,
<a name="l01536"></a>01536                                      <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *<a class="code" href="structvalue.html">value</a>,
<a name="l01537"></a>01537                                      <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **bytes,
<a name="l01538"></a>01538                                      <span class="keyword">struct</span> <a class="code" href="structdwarf2__locexpr__baton.html">dwarf2_locexpr_baton</a> **baton);
<a name="l01539"></a>01539 
<a name="l01540"></a>01540 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01541"></a>01541 
<a name="l01542"></a>01542 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#aa6f64de62201aa04386e42862d37959c">need_gnat_info</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01543"></a>01543 
<a name="l01544"></a>01544 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="dwarf2read_8c.html#aff7b3d15e86cadcd51281c9cb07656ab">die_descriptive_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *,
<a name="l01545"></a>01545                                           <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01546"></a>01546 
<a name="l01547"></a>01547 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#abc906394dd587b9b28825cf6798d43d9">set_descriptive_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *,
<a name="l01548"></a>01548                                   <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01549"></a>01549 
<a name="l01550"></a>01550 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="dwarf2read_8c.html#a2ce2b8e439742408e8161e899d9cb67a">die_containing_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *,
<a name="l01551"></a>01551                                          <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01552"></a>01552 
<a name="l01553"></a>01553 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="dwarf2read_8c.html#af43079f3d89059ef6812c6c1ed6141c9">lookup_die_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *,
<a name="l01554"></a>01554                                      <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01555"></a>01555 
<a name="l01556"></a>01556 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01557"></a>01557 
<a name="l01558"></a>01558 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="dwarf2read_8c.html#ae16a66bf29f050e080c494d9fabf548e">read_type_die_1</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01559"></a>01559 
<a name="l01560"></a>01560 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#a2417ea09b6b125e47a255352f662e856">determine_prefix</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01561"></a>01561 
<a name="l01562"></a>01562 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#a6abe45afe642868fb22402ce7349ad7f">typename_concat</a> (<span class="keyword">struct</span> obstack *obs, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix,
<a name="l01563"></a>01563                               <span class="keyword">const</span> <span class="keywordtype">char</span> *suffix, <span class="keywordtype">int</span> physname,
<a name="l01564"></a>01564                               <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01565"></a>01565 
<a name="l01566"></a>01566 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a9126a0189849660b1db747863dafb0bf">read_file_scope</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01567"></a>01567 
<a name="l01568"></a>01568 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a40896e3030e32e5b5e08e57a5536723e">read_type_unit_scope</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01569"></a>01569 
<a name="l01570"></a>01570 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a8883e03bccc13b39a7d3f1852dc96dfd">read_func_scope</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01571"></a>01571 
<a name="l01572"></a>01572 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a1ada1c5f995cf53a504f3c9bce099fb5">read_lexical_block_scope</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01573"></a>01573 
<a name="l01574"></a>01574 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a763117964c95fb54ba4c8ebe38e2ff87">read_call_site_scope</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01575"></a>01575 
<a name="l01576"></a>01576 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a2f36d2456807d0d9528aa34b750b5b59">dwarf2_ranges_read</a> (<span class="keywordtype">unsigned</span>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *,
<a name="l01577"></a>01577                                <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *, <span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *);
<a name="l01578"></a>01578 
<a name="l01579"></a>01579 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#ad8168e871bf8c579c8dbc4a6aad6bc0a">dwarf2_get_pc_bounds</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *,
<a name="l01580"></a>01580                                  <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *,
<a name="l01581"></a>01581                                  <span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *);
<a name="l01582"></a>01582 
<a name="l01583"></a>01583 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#aa7a89cfc9f4650dde9ef152c70edbe41">get_scope_pc_bounds</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *,
<a name="l01584"></a>01584                                  <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *,
<a name="l01585"></a>01585                                  <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01586"></a>01586 
<a name="l01587"></a>01587 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#af80555d650cbaf81ef765d24905e9d3a">dwarf2_record_block_ranges</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *,
<a name="l01588"></a>01588                                         <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01589"></a>01589 
<a name="l01590"></a>01590 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a288fbd6a927a07b52e2047da8322d25e">dwarf2_add_field</a> (<span class="keyword">struct</span> <a class="code" href="structfield__info.html">field_info</a> *, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *,
<a name="l01591"></a>01591                               <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01592"></a>01592 
<a name="l01593"></a>01593 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a9c6533d3437b203af697f7b478990784">dwarf2_attach_fields_to_type</a> (<span class="keyword">struct</span> <a class="code" href="structfield__info.html">field_info</a> *,
<a name="l01594"></a>01594                                           <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01595"></a>01595 
<a name="l01596"></a>01596 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a1c6ac754036149e6eadc244c6c777c77">dwarf2_add_member_fn</a> (<span class="keyword">struct</span> <a class="code" href="structfield__info.html">field_info</a> *,
<a name="l01597"></a>01597                                   <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l01598"></a>01598                                   <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01599"></a>01599 
<a name="l01600"></a>01600 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a014e4767f6c0ac385eb4c45327b7fe94">dwarf2_attach_fn_fields_to_type</a> (<span class="keyword">struct</span> <a class="code" href="structfield__info.html">field_info</a> *,
<a name="l01601"></a>01601                                              <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l01602"></a>01602                                              <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01603"></a>01603 
<a name="l01604"></a>01604 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a0d01179d58ab2151b5a646e74f2c089f">process_structure_scope</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01605"></a>01605 
<a name="l01606"></a>01606 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#ab5a2e1c5e61bf3e7a380c7da5361549d">read_common_block</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01607"></a>01607 
<a name="l01608"></a>01608 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#aff7ad824d37fcf5d005e0db22721cdef">read_namespace</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01609"></a>01609 
<a name="l01610"></a>01610 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a9f99a9bd45327b2888e42df7832dfdab">read_module</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01611"></a>01611 
<a name="l01612"></a>01612 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a3508f14002211278d9e4e0936a70f108">read_import_statement</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01613"></a>01613 
<a name="l01614"></a>01614 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="dwarf2read_8c.html#a2d1e350c81129a2c7dc6591e4b67267e">read_module_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l01615"></a>01615                                       <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01616"></a>01616 
<a name="l01617"></a>01617 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#aa36ad06e3757cedacef0e32245045b4b">namespace_name</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l01618"></a>01618                                    <span class="keywordtype">int</span> *is_anonymous, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01619"></a>01619 
<a name="l01620"></a>01620 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#aeff5dce8be530b01d1e71bbe356f9a24">process_enumeration_scope</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01621"></a>01621 
<a name="l01622"></a>01622 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="dwarf2read_8c.html#ab042fa76d14a2a97bb1b0d6f75e60d79">decode_locdesc</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf__block.html">dwarf_block</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01623"></a>01623 
<a name="l01624"></a>01624 <span class="keyword">static</span> <span class="keyword">enum</span> dwarf_array_dim_ordering <a class="code" href="dwarf2read_8c.html#ace1105d6c48ca6ab62cfabed4bf7fa40">read_array_order</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *,
<a name="l01625"></a>01625                                                        <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01626"></a>01626 
<a name="l01627"></a>01627 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *<a class="code" href="dwarf2read_8c.html#a9a356825fcc31a825f71c8ec18206ffb">read_die_and_siblings_1</a>
<a name="l01628"></a>01628   (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **,
<a name="l01629"></a>01629    <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *);
<a name="l01630"></a>01630 
<a name="l01631"></a>01631 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *<a class="code" href="dwarf2read_8c.html#a79a10115d28e35221fb4b78c2023be76">read_die_and_siblings</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *,
<a name="l01632"></a>01632                                                <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l01633"></a>01633                                                <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **new_info_ptr,
<a name="l01634"></a>01634                                                <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *parent);
<a name="l01635"></a>01635 
<a name="l01636"></a>01636 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="dwarf2read_8c.html#a291867fdd93d43aec13a54966902d005">read_full_die_1</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *,
<a name="l01637"></a>01637                                         <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> **, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *,
<a name="l01638"></a>01638                                         <span class="keywordtype">int</span> *, <span class="keywordtype">int</span>);
<a name="l01639"></a>01639 
<a name="l01640"></a>01640 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="dwarf2read_8c.html#a80d70a70850cfc7be97670eab43c98d8">read_full_die</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *,
<a name="l01641"></a>01641                                       <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> **, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *,
<a name="l01642"></a>01642                                       <span class="keywordtype">int</span> *);
<a name="l01643"></a>01643 
<a name="l01644"></a>01644 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01645"></a>01645 
<a name="l01646"></a>01646 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#a15617623710ce00d6f31263aad9bd432">dwarf2_canonicalize_name</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *,
<a name="l01647"></a>01647                                              <span class="keyword">struct</span> obstack *);
<a name="l01648"></a>01648 
<a name="l01649"></a>01649 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01650"></a>01650 
<a name="l01651"></a>01651 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#a01de8f373799ebb39da7b5758619ec4c">dwarf2_full_name</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>,
<a name="l01652"></a>01652                                      <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l01653"></a>01653                                      <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01654"></a>01654 
<a name="l01655"></a>01655 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#a94813a9fc414b7ba920cdcee76b34d36">dwarf2_physname</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l01656"></a>01656                                     <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01657"></a>01657 
<a name="l01658"></a>01658 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *<a class="code" href="dwarf2read_8c.html#a8308114946895d0f9cb9c1ff8a92d115">dwarf2_extension</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l01659"></a>01659                                           <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> **);
<a name="l01660"></a>01660 
<a name="l01661"></a>01661 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#af80d37a7ff366081b096550409d46e45">dwarf_tag_name</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
<a name="l01662"></a>01662 
<a name="l01663"></a>01663 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#a9cf5304ec3b94ab9e1786529ad97338b">dwarf_attr_name</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
<a name="l01664"></a>01664 
<a name="l01665"></a>01665 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#a6810653c49d4b3be30290dc1bcf20c94">dwarf_form_name</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
<a name="l01666"></a>01666 
<a name="l01667"></a>01667 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#ad4ab7046a0a5b2c18a47b2e3eb36c5b6">dwarf_bool_name</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
<a name="l01668"></a>01668 
<a name="l01669"></a>01669 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#a0a45f38cd8954cc90b8f97f03e1effd3">dwarf_type_encoding_name</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
<a name="l01670"></a>01670 
<a name="l01671"></a>01671 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *<a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *);
<a name="l01672"></a>01672 
<a name="l01673"></a>01673 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a7e3db4d14d7ec766f3db21faff32e214">dump_die_shallow</a> (<span class="keyword">struct</span> <a class="code" href="structui__file.html">ui_file</a> *, <span class="keywordtype">int</span> indent, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *);
<a name="l01674"></a>01674 
<a name="l01675"></a>01675 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a6e4e3ec89be5cd344456da9d82bc20d7">dump_die_for_error</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *);
<a name="l01676"></a>01676 
<a name="l01677"></a>01677 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a9eb6c811f2245f1b4af3e337d3746c76">dump_die_1</a> (<span class="keyword">struct</span> <a class="code" href="structui__file.html">ui_file</a> *, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> max_level,
<a name="l01678"></a>01678                         <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *);
<a name="l01679"></a>01679 
<a name="l01680"></a>01680 <span class="comment">/*static*/</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#aa1e7ee43f6ccdd2c19768ae5eff4bd89">dump_die</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keywordtype">int</span> max_level);
<a name="l01681"></a>01681 
<a name="l01682"></a>01682 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a73da43858dcf4f74ace71583baadf321">store_in_ref_table</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *,
<a name="l01683"></a>01683                                 <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01684"></a>01684 
<a name="l01685"></a>01685 <span class="keyword">static</span> <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="dwarf2read_8c.html#a28e7eb63f317d51f9be16584d407c508">dwarf2_get_ref_die_offset</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *);
<a name="l01686"></a>01686 
<a name="l01687"></a>01687 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="dwarf2read_8c.html#a483ab0874bc41021a77b11c5e6d3b740">dwarf2_get_attr_constant_value</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *, <span class="keywordtype">int</span>);
<a name="l01688"></a>01688 
<a name="l01689"></a>01689 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *<a class="code" href="dwarf2read_8c.html#a468c4b93171973f8c93dd21db4de1634">follow_die_ref_or_sig</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *,
<a name="l01690"></a>01690                                                <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *,
<a name="l01691"></a>01691                                                <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> **);
<a name="l01692"></a>01692 
<a name="l01693"></a>01693 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *<a class="code" href="dwarf2read_8c.html#a079b531fef51cfc34f92ff6fde2ef8a4">follow_die_ref</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *,
<a name="l01694"></a>01694                                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *,
<a name="l01695"></a>01695                                         <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> **);
<a name="l01696"></a>01696 
<a name="l01697"></a>01697 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *<a class="code" href="dwarf2read_8c.html#add2431995750b3a2bbd9f2eeb861b57a">follow_die_sig</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *,
<a name="l01698"></a>01698                                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *,
<a name="l01699"></a>01699                                         <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> **);
<a name="l01700"></a>01700 
<a name="l01701"></a>01701 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="dwarf2read_8c.html#a743c93f0f8a0cfece75baa06b8b1f5a0">get_signatured_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a>,
<a name="l01702"></a>01702                                          <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01703"></a>01703 
<a name="l01704"></a>01704 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="dwarf2read_8c.html#ad28686b8248336c2fdf52288043a74f7">get_DW_AT_signature_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *,
<a name="l01705"></a>01705                                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *,
<a name="l01706"></a>01706                                               <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01707"></a>01707 
<a name="l01708"></a>01708 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a1d0f2204cbb2e3c2103d9e9a40b97f61">load_full_type_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu);
<a name="l01709"></a>01709 
<a name="l01710"></a>01710 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#acb79afa78ab76b39b5a27f8135e60509">read_signatured_type</a> (<span class="keyword">struct</span> <a class="code" href="structsignatured__type.html">signatured_type</a> *);
<a name="l01711"></a>01711 
<a name="l01712"></a>01712 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> *<a class="code" href="dwarf2read_8c.html#a32cdecdad4aa06e351612fb574d1c638">get_type_unit_group</a>
<a name="l01713"></a>01713     (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *);
<a name="l01714"></a>01714 
<a name="l01715"></a>01715 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#ae4869ba53444635ffb37ac46abd1a045">build_type_unit_groups</a> (<a class="code" href="dwarf2read_8c.html#a78918e349d1b0b7715599fa171aab050">die_reader_func_ftype</a> *, <span class="keywordtype">void</span> *);
<a name="l01716"></a>01716 
<a name="l01717"></a>01717 <span class="comment">/* memory allocation interface */</span>
<a name="l01718"></a>01718 
<a name="l01719"></a>01719 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwarf__block.html">dwarf_block</a> *<a class="code" href="dwarf2read_8c.html#ad90eafda28bec4d8aedfc8e1f37b210a">dwarf_alloc_block</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01720"></a>01720 
<a name="l01721"></a>01721 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *<a class="code" href="dwarf2read_8c.html#ad0de318a450615df05b9d8225925b9aa">dwarf_alloc_die</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *, <span class="keywordtype">int</span>);
<a name="l01722"></a>01722 
<a name="l01723"></a>01723 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#ab19576b4a3ebec0b3a1e723523f2e072">dwarf_decode_macros</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>,
<a name="l01724"></a>01724                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>);
<a name="l01725"></a>01725 
<a name="l01726"></a>01726 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *);
<a name="l01727"></a>01727 
<a name="l01728"></a>01728 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#aa2b54436e7d13233cd6b866f562f637e">attr_form_is_section_offset</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *);
<a name="l01729"></a>01729 
<a name="l01730"></a>01730 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a450aaabe2810df0fc34c371aae960580">attr_form_is_constant</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *);
<a name="l01731"></a>01731 
<a name="l01732"></a>01732 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a217d4eb87ed57947007169e88bb2a0f9">attr_form_is_ref</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *);
<a name="l01733"></a>01733 
<a name="l01734"></a>01734 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#ad27262e92622f057801c24c2d248593d">fill_in_loclist_baton</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l01735"></a>01735                                    <span class="keyword">struct</span> <a class="code" href="structdwarf2__loclist__baton.html">dwarf2_loclist_baton</a> *baton,
<a name="l01736"></a>01736                                    <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr);
<a name="l01737"></a>01737 
<a name="l01738"></a>01738 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a097117b0b695bca7ad085fee973f5bd1">dwarf2_symbol_mark_computed</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr,
<a name="l01739"></a>01739                                          <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym,
<a name="l01740"></a>01740                                          <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l01741"></a>01741                                          <span class="keywordtype">int</span> is_block);
<a name="l01742"></a>01742 
<a name="l01743"></a>01743 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="dwarf2read_8c.html#a2841c651fdaf6de18181efeb6746de43">skip_one_die</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l01744"></a>01744                                      <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l01745"></a>01745                                      <span class="keyword">struct</span> <a class="code" href="structabbrev__info.html">abbrev_info</a> *abbrev);
<a name="l01746"></a>01746 
<a name="l01747"></a>01747 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#ac4c57bb71ff493266c9d5a80a484dcbe">free_stack_comp_unit</a> (<span class="keywordtype">void</span> *);
<a name="l01748"></a>01748 
<a name="l01749"></a>01749 <span class="keyword">static</span> hashval_t <a class="code" href="dwarf2read_8c.html#a7206fb65e6b70f6294edf05a454c4182">partial_die_hash</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item);
<a name="l01750"></a>01750 
<a name="l01751"></a>01751 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a0e8a120392cd0ef1f19e1eb86c7b43e5">partial_die_eq</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item_lhs, <span class="keyword">const</span> <span class="keywordtype">void</span> *item_rhs);
<a name="l01752"></a>01752 
<a name="l01753"></a>01753 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *<a class="code" href="dwarf2read_8c.html#af3b37bdf179696b92b068cd2894de56d">dwarf2_find_containing_comp_unit</a>
<a name="l01754"></a>01754   (<a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset_in_dwz, <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>);
<a name="l01755"></a>01755 
<a name="l01756"></a>01756 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#abd170e25a0f34cecee142a0252b26d82">init_one_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>,
<a name="l01757"></a>01757                                 <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu);
<a name="l01758"></a>01758 
<a name="l01759"></a>01759 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a7a6cb8459a76588ce7ef6a56b19ef5c8">prepare_one_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>,
<a name="l01760"></a>01760                                    <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *comp_unit_die,
<a name="l01761"></a>01761                                    <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> pretend_language);
<a name="l01762"></a>01762 
<a name="l01763"></a>01763 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a686d2ded76f9904b6f35d4402ee17230">free_heap_comp_unit</a> (<span class="keywordtype">void</span> *);
<a name="l01764"></a>01764 
<a name="l01765"></a>01765 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a8fe96d50d88ef6a4b3ef501aada103ab">free_cached_comp_units</a> (<span class="keywordtype">void</span> *);
<a name="l01766"></a>01766 
<a name="l01767"></a>01767 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#aea3bec269cdf43d65a84eb61d8c2c48b">age_cached_comp_units</a> (<span class="keywordtype">void</span>);
<a name="l01768"></a>01768 
<a name="l01769"></a>01769 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a88ac0ca2997594c6c41d77ceeb620711">free_one_cached_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *);
<a name="l01770"></a>01770 
<a name="l01771"></a>01771 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l01772"></a>01772                                   <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01773"></a>01773 
<a name="l01774"></a>01774 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a34cc869c244a5085a0bf01a01b0961db">create_all_comp_units</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l01775"></a>01775 
<a name="l01776"></a>01776 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwarf2read_8c.html#a74edb9fb71ae3b0318ea886c49b697ef">create_all_type_units</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l01777"></a>01777 
<a name="l01778"></a>01778 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a9f845956e1dd14ace7c6471ee8c2b502">load_full_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *,
<a name="l01779"></a>01779                                  <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a>);
<a name="l01780"></a>01780 
<a name="l01781"></a>01781 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a4a43e61549842b0ddfc5d3fd23202e93">process_full_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *,
<a name="l01782"></a>01782                                     <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a>);
<a name="l01783"></a>01783 
<a name="l01784"></a>01784 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a9b0c1ef101c10aac5bb5648a03b48d14">process_full_type_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *,
<a name="l01785"></a>01785                                     <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a>);
<a name="l01786"></a>01786 
<a name="l01787"></a>01787 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a718e49c311f78a8621ba62dec3084e02">dwarf2_add_dependence</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *,
<a name="l01788"></a>01788                                    <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *);
<a name="l01789"></a>01789 
<a name="l01790"></a>01790 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a273c1412d7b59e71060bf91b333f96e9">dwarf2_mark</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *);
<a name="l01791"></a>01791 
<a name="l01792"></a>01792 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#af10d4c7106a94f43a2be645d98da2ed8">dwarf2_clear_marks</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *);
<a name="l01793"></a>01793 
<a name="l01794"></a>01794 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="dwarf2read_8c.html#ae277955c587127c2a481663cca343437">get_die_type_at_offset</a> (<a class="code" href="structsect__offset.html">sect_offset</a>,
<a name="l01795"></a>01795                                             <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *);
<a name="l01796"></a>01796 
<a name="l01797"></a>01797 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01798"></a>01798 
<a name="l01799"></a>01799 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#ace3060cbcc6a275e2260e5261c3f9dda">dwarf2_release_queue</a> (<span class="keywordtype">void</span> *<a class="code" href="go32-nat_8c.html#a36fb645a916cd19d79712e75c47b8d03">dummy</a>);
<a name="l01800"></a>01800 
<a name="l01801"></a>01801 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a756eccd342c094e5937e6ab43bf8a5a4">queue_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu,
<a name="l01802"></a>01802                              <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> pretend_language);
<a name="l01803"></a>01803 
<a name="l01804"></a>01804 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a4299d1028cbe9bbcebb435f92cf3cbda">process_queue</a> (<span class="keywordtype">void</span>);
<a name="l01805"></a>01805 
<a name="l01806"></a>01806 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a4c82b37187098b652b568563271a15a3">find_file_and_directory</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l01807"></a>01807                                      <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l01808"></a>01808                                      <span class="keyword">const</span> <span class="keywordtype">char</span> **<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> **comp_dir);
<a name="l01809"></a>01809 
<a name="l01810"></a>01810 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#a10e5b152dbd3c862a6832d5028b0d1d1">file_full_name</a> (<span class="keywordtype">int</span> file, <span class="keyword">struct</span> <a class="code" href="structline__header.html">line_header</a> *lh,
<a name="l01811"></a>01811                              <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir);
<a name="l01812"></a>01812 
<a name="l01813"></a>01813 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="dwarf2read_8c.html#ab4a5d6610652463f5cf265ddbdfb8d58">read_and_check_comp_unit_head</a>
<a name="l01814"></a>01814   (<span class="keyword">struct</span> <a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *header,
<a name="l01815"></a>01815    <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section,
<a name="l01816"></a>01816    <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *abbrev_section, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l01817"></a>01817    <span class="keywordtype">int</span> is_debug_types_section);
<a name="l01818"></a>01818 
<a name="l01819"></a>01819 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a2887b925bcf54483d1c0dc40faefdd08">init_cutu_and_read_dies</a>
<a name="l01820"></a>01820   (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu, <span class="keyword">struct</span> <a class="code" href="structabbrev__table.html">abbrev_table</a> *<a class="code" href="structabbrev__table.html">abbrev_table</a>,
<a name="l01821"></a>01821    <span class="keywordtype">int</span> use_existing_cu, <span class="keywordtype">int</span> keep,
<a name="l01822"></a>01822    <a class="code" href="dwarf2read_8c.html#a78918e349d1b0b7715599fa171aab050">die_reader_func_ftype</a> *die_reader_func, <span class="keywordtype">void</span> *data);
<a name="l01823"></a>01823 
<a name="l01824"></a>01824 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#aa76270ede1b4c1ab21e449e875a982bf">init_cutu_and_read_dies_simple</a>
<a name="l01825"></a>01825   (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu,
<a name="l01826"></a>01826    <a class="code" href="dwarf2read_8c.html#a78918e349d1b0b7715599fa171aab050">die_reader_func_ftype</a> *die_reader_func, <span class="keywordtype">void</span> *data);
<a name="l01827"></a>01827 
<a name="l01828"></a>01828 <span class="keyword">static</span> htab_t <a class="code" href="dwarf2read_8c.html#ad578387bf4a7a34a17bed7e05e8d4427">allocate_signatured_type_table</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>);
<a name="l01829"></a>01829 
<a name="l01830"></a>01830 <span class="keyword">static</span> htab_t <a class="code" href="dwarf2read_8c.html#ae4fe7bb1a521f3edafb2a10a3af6385a">allocate_dwo_unit_table</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>);
<a name="l01831"></a>01831 
<a name="l01832"></a>01832 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="dwarf2read_8c.html#a5637d18b01ed205a41181e3cac6e442c">lookup_dwo_unit_in_dwp</a>
<a name="l01833"></a>01833   (<span class="keyword">struct</span> <a class="code" href="structdwp__file.html">dwp_file</a> *<a class="code" href="structdwp__file.html">dwp_file</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir,
<a name="l01834"></a>01834    <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>, <span class="keywordtype">int</span> is_debug_types);
<a name="l01835"></a>01835 
<a name="l01836"></a>01836 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwp__file.html">dwp_file</a> *<a class="code" href="dwarf2read_8c.html#a9fc2d7d27eba883b582555229c60c32e">get_dwp_file</a> (<span class="keywordtype">void</span>);
<a name="l01837"></a>01837 
<a name="l01838"></a>01838 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="dwarf2read_8c.html#a5bc277ff9a23ec723156386e4b6cb16a">lookup_dwo_comp_unit</a>
<a name="l01839"></a>01839   (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a>);
<a name="l01840"></a>01840 
<a name="l01841"></a>01841 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="dwarf2read_8c.html#a5f81c3c5c800c9a68e91157b46e1cd8f">lookup_dwo_type_unit</a>
<a name="l01842"></a>01842   (<span class="keyword">struct</span> <a class="code" href="structsignatured__type.html">signatured_type</a> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l01843"></a>01843 
<a name="l01844"></a>01844 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a94cfe716f234c867cf44c1880aed5f2e">queue_and_load_all_dwo_tus</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *);
<a name="l01845"></a>01845 
<a name="l01846"></a>01846 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a3d1244c7c7e2daa658b3e4e49cd406bf">free_dwo_file_cleanup</a> (<span class="keywordtype">void</span> *);
<a name="l01847"></a>01847 
<a name="l01848"></a>01848 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a15521f267ec507aa6fbf4e80df678078">process_cu_includes</a> (<span class="keywordtype">void</span>);
<a name="l01849"></a>01849 
<a name="l01850"></a>01850 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwarf2read_8c.html#a41cd805d939c553f1679638639f7102b">check_producer</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu);
<a name="l01851"></a>01851 
<a name="l01852"></a>01852 <span class="comment">/* Various complaints about symbol reading that don&#39;t abort the process.  */</span>
<a name="l01853"></a>01853 
<a name="l01854"></a>01854 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01855"></a><a class="code" href="dwarf2read_8c.html#adcbf7e3dda8c8b0e06a9d4a13f9b0bbc">01855</a> <a class="code" href="dwarf2read_8c.html#adcbf7e3dda8c8b0e06a9d4a13f9b0bbc">dwarf2_statement_list_fits_in_line_number_section_complaint</a> (<span class="keywordtype">void</span>)
<a name="l01856"></a>01856 {
<a name="l01857"></a>01857   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01858"></a>01858              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;statement list doesn&#39;t fit in .debug_line section&quot;</span>));
<a name="l01859"></a>01859 }
<a name="l01860"></a>01860 
<a name="l01861"></a>01861 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01862"></a><a class="code" href="dwarf2read_8c.html#a9acddb20f4fc03ac6c460af9bd003928">01862</a> <a class="code" href="dwarf2read_8c.html#a9acddb20f4fc03ac6c460af9bd003928">dwarf2_debug_line_missing_file_complaint</a> (<span class="keywordtype">void</span>)
<a name="l01863"></a>01863 {
<a name="l01864"></a>01864   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01865"></a>01865              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;.debug_line section has line data without a file&quot;</span>));
<a name="l01866"></a>01866 }
<a name="l01867"></a>01867 
<a name="l01868"></a>01868 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01869"></a><a class="code" href="dwarf2read_8c.html#aad021e9f4b344a2b623372f88b39fbdf">01869</a> <a class="code" href="dwarf2read_8c.html#aad021e9f4b344a2b623372f88b39fbdf">dwarf2_debug_line_missing_end_sequence_complaint</a> (<span class="keywordtype">void</span>)
<a name="l01870"></a>01870 {
<a name="l01871"></a>01871   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01872"></a>01872              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;.debug_line section has line &quot;</span>
<a name="l01873"></a>01873                <span class="stringliteral">&quot;program sequence without an end&quot;</span>));
<a name="l01874"></a>01874 }
<a name="l01875"></a>01875 
<a name="l01876"></a>01876 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01877"></a><a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">01877</a> <a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">dwarf2_complex_location_expr_complaint</a> (<span class="keywordtype">void</span>)
<a name="l01878"></a>01878 {
<a name="l01879"></a>01879   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;location expression too complex&quot;</span>));
<a name="l01880"></a>01880 }
<a name="l01881"></a>01881 
<a name="l01882"></a>01882 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01883"></a><a class="code" href="dwarf2read_8c.html#a232ddfa8f3451df295d5a5bd5870f82c">01883</a> <a class="code" href="dwarf2read_8c.html#a232ddfa8f3451df295d5a5bd5870f82c">dwarf2_const_value_length_mismatch_complaint</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *arg1, <span class="keywordtype">int</span> arg2,
<a name="l01884"></a>01884                                               <span class="keywordtype">int</span> arg3)
<a name="l01885"></a>01885 {
<a name="l01886"></a>01886   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01887"></a>01887              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;const value length mismatch for &#39;%s&#39;, got %d, expected %d&quot;</span>),
<a name="l01888"></a>01888              arg1, arg2, arg3);
<a name="l01889"></a>01889 }
<a name="l01890"></a>01890 
<a name="l01891"></a>01891 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01892"></a><a class="code" href="dwarf2read_8c.html#a8bcba8ec04ffa82ae060fb69f166920b">01892</a> <a class="code" href="dwarf2read_8c.html#a8bcba8ec04ffa82ae060fb69f166920b">dwarf2_section_buffer_overflow_complaint</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *<a class="code" href="structdwo__unit.html#a808127fb35d399faddd33a3b28e5ec06">section</a>)
<a name="l01893"></a>01893 {
<a name="l01894"></a>01894   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01895"></a>01895              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;debug info runs off end of %s section&quot;</span>
<a name="l01896"></a>01896                <span class="stringliteral">&quot; [in module %s]&quot;</span>),
<a name="l01897"></a>01897              <a class="code" href="dwarf2read_8c.html#a206c558e28b7bc7fcf8bdad145cabef1">get_section_name</a> (section),
<a name="l01898"></a>01898              <a class="code" href="dwarf2read_8c.html#a1c841524fdd0bd73272dad700a7452f6">get_section_file_name</a> (section));
<a name="l01899"></a>01899 }
<a name="l01900"></a>01900 
<a name="l01901"></a>01901 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01902"></a><a class="code" href="dwarf2read_8c.html#a980629aef069b17bca95d8e60eb5f07d">01902</a> <a class="code" href="dwarf2read_8c.html#a980629aef069b17bca95d8e60eb5f07d">dwarf2_macro_malformed_definition_complaint</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *arg1)
<a name="l01903"></a>01903 {
<a name="l01904"></a>01904   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01905"></a>01905              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;macro debug info contains a &quot;</span>
<a name="l01906"></a>01906                <span class="stringliteral">&quot;malformed macro definition:\n`%s&#39;&quot;</span>),
<a name="l01907"></a>01907              arg1);
<a name="l01908"></a>01908 }
<a name="l01909"></a>01909 
<a name="l01910"></a>01910 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01911"></a><a class="code" href="dwarf2read_8c.html#a0e9c948efe625df13875d3d70d218b65">01911</a> <a class="code" href="dwarf2read_8c.html#a0e9c948efe625df13875d3d70d218b65">dwarf2_invalid_attrib_class_complaint</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *arg1, <span class="keyword">const</span> <span class="keywordtype">char</span> *arg2)
<a name="l01912"></a>01912 {
<a name="l01913"></a>01913   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01914"></a>01914              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;invalid attribute class or form for &#39;%s&#39; in &#39;%s&#39;&quot;</span>),
<a name="l01915"></a>01915              arg1, arg2);
<a name="l01916"></a>01916 }
<a name="l01917"></a>01917 
<a name="l01918"></a>01918 <span class="preprocessor">#if WORDS_BIGENDIAN</span>
<a name="l01919"></a>01919 <span class="preprocessor"></span>
<a name="l01920"></a>01920 <span class="comment">/* Convert VALUE between big- and little-endian.  */</span>
<a name="l01921"></a>01921 <span class="keyword">static</span> <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>
<a name="l01922"></a>01922 byte_swap (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> <a class="code" href="structvalue.html">value</a>)
<a name="l01923"></a>01923 {
<a name="l01924"></a>01924   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> result;
<a name="l01925"></a>01925 
<a name="l01926"></a>01926   result = (value &amp; 0xff) &lt;&lt; 24;
<a name="l01927"></a>01927   result |= (value &amp; 0xff00) &lt;&lt; 8;
<a name="l01928"></a>01928   result |= (value &amp; 0xff0000) &gt;&gt; 8;
<a name="l01929"></a>01929   result |= (value &amp; 0xff000000) &gt;&gt; 24;
<a name="l01930"></a>01930   <span class="keywordflow">return</span> result;
<a name="l01931"></a>01931 }
<a name="l01932"></a>01932 
<a name="l01933"></a>01933 <span class="preprocessor">#define MAYBE_SWAP(V)  byte_swap (V)</span>
<a name="l01934"></a>01934 <span class="preprocessor"></span>
<a name="l01935"></a>01935 <span class="preprocessor">#else</span>
<a name="l01936"></a><a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">01936</a> <span class="preprocessor"></span><span class="preprocessor">#define MAYBE_SWAP(V) (V)</span>
<a name="l01937"></a>01937 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* WORDS_BIGENDIAN */</span>
<a name="l01938"></a>01938 
<a name="l01939"></a>01939 <span class="comment">/* The suffix for an index file.  */</span>
<a name="l01940"></a><a class="code" href="dwarf2read_8c.html#a4d599eea3e3f09271468360062eb330e">01940</a> <span class="preprocessor">#define INDEX_SUFFIX &quot;.gdb-index&quot;</span>
<a name="l01941"></a>01941 <span class="preprocessor"></span>
<a name="l01942"></a>01942 <span class="comment">/* Try to locate the sections we need for DWARF 2 debugging</span>
<a name="l01943"></a>01943 <span class="comment">   information and return true if we have enough to do something.</span>
<a name="l01944"></a>01944 <span class="comment">   NAMES points to the dwarf2 section names, or is NULL if the standard</span>
<a name="l01945"></a>01945 <span class="comment">   ELF names are used.  */</span>
<a name="l01946"></a>01946 
<a name="l01947"></a>01947 <span class="keywordtype">int</span>
<a name="l01948"></a><a class="code" href="symfile_8h.html#ae12d533cf9e0cbe6905982da9e32d7fe">01948</a> <a class="code" href="dwarf2read_8c.html#ab5b2c8045e6365e6d5609a79bbd76002">dwarf2_has_info</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l01949"></a>01949                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdwarf2__debug__sections.html">dwarf2_debug_sections</a> *names)
<a name="l01950"></a>01950 {
<a name="l01951"></a>01951   dwarf2_per_objfile = objfile_data (objfile, <a class="code" href="dwarf2read_8c.html#a9fcfdd623d890b4c3b4ac0ba42e7df4b">dwarf2_objfile_data_key</a>);
<a name="l01952"></a>01952   <span class="keywordflow">if</span> (!dwarf2_per_objfile)
<a name="l01953"></a>01953     {
<a name="l01954"></a>01954       <span class="comment">/* Initialize per-objfile state.  */</span>
<a name="l01955"></a>01955       <span class="keyword">struct </span>dwarf2_per_objfile *data
<a name="l01956"></a>01956         = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, sizeof (*data));
<a name="l01957"></a>01957 
<a name="l01958"></a>01958       <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (data, 0, <span class="keyword">sizeof</span> (*data));
<a name="l01959"></a>01959       set_objfile_data (objfile, <a class="code" href="dwarf2read_8c.html#a9fcfdd623d890b4c3b4ac0ba42e7df4b">dwarf2_objfile_data_key</a>, data);
<a name="l01960"></a>01960       dwarf2_per_objfile = data;
<a name="l01961"></a>01961 
<a name="l01962"></a>01962       bfd_map_over_sections (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>, <a class="code" href="dwarf2read_8c.html#accff25a253034949d9c4cfded38d2d72">dwarf2_locate_sections</a>,
<a name="l01963"></a>01963                              (<span class="keywordtype">void</span> *) names);
<a name="l01964"></a>01964       dwarf2_per_objfile-&gt;objfile = objfile;
<a name="l01965"></a>01965     }
<a name="l01966"></a>01966   <span class="keywordflow">return</span> (!dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ac4a5ed6e3f9908d638032ba24040a0b9">info</a>.<a class="code" href="structdwarf2__section__info.html#a580140de2ff419885dd24bfc36862b48">is_virtual</a>
<a name="l01967"></a>01967           &amp;&amp; dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ac4a5ed6e3f9908d638032ba24040a0b9">info</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> != NULL
<a name="l01968"></a>01968           &amp;&amp; !dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a65f092d6a408e872a5b5f724728353de">abbrev</a>.<a class="code" href="structdwarf2__section__info.html#a580140de2ff419885dd24bfc36862b48">is_virtual</a>
<a name="l01969"></a>01969           &amp;&amp; dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a65f092d6a408e872a5b5f724728353de">abbrev</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> != NULL);
<a name="l01970"></a>01970 }
<a name="l01971"></a>01971 
<a name="l01972"></a>01972 <span class="comment">/* Return the containing section of virtual section SECTION.  */</span>
<a name="l01973"></a>01973 
<a name="l01974"></a>01974 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *
<a name="l01975"></a><a class="code" href="dwarf2read_8c.html#ae0448e717e69369933df6247fdd1a4ea">01975</a> <a class="code" href="dwarf2read_8c.html#ae0448e717e69369933df6247fdd1a4ea">get_containing_section</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section)
<a name="l01976"></a>01976 {
<a name="l01977"></a>01977   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (section-&gt;<a class="code" href="structdwarf2__section__info.html#a580140de2ff419885dd24bfc36862b48">is_virtual</a>);
<a name="l01978"></a>01978   <span class="keywordflow">return</span> section-&gt;<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a57c7432f009d2575fa1b3961bf80e912">containing_section</a>;
<a name="l01979"></a>01979 }
<a name="l01980"></a>01980 
<a name="l01981"></a>01981 <span class="comment">/* Return the bfd owner of SECTION.  */</span>
<a name="l01982"></a>01982 
<a name="l01983"></a>01983 <span class="keyword">static</span> <span class="keyword">struct </span>bfd *
<a name="l01984"></a><a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">01984</a> <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section)
<a name="l01985"></a>01985 {
<a name="l01986"></a>01986   <span class="keywordflow">if</span> (section-&gt;<a class="code" href="structdwarf2__section__info.html#a580140de2ff419885dd24bfc36862b48">is_virtual</a>)
<a name="l01987"></a>01987     {
<a name="l01988"></a>01988       section = <a class="code" href="dwarf2read_8c.html#ae0448e717e69369933df6247fdd1a4ea">get_containing_section</a> (section);
<a name="l01989"></a>01989       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!section-&gt;<a class="code" href="structdwarf2__section__info.html#a580140de2ff419885dd24bfc36862b48">is_virtual</a>);
<a name="l01990"></a>01990     }
<a name="l01991"></a>01991   <span class="keywordflow">return</span> section-&gt;<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a>-&gt;owner;
<a name="l01992"></a>01992 }
<a name="l01993"></a>01993 
<a name="l01994"></a>01994 <span class="comment">/* Return the bfd section of SECTION.</span>
<a name="l01995"></a>01995 <span class="comment">   Returns NULL if the section is not present.  */</span>
<a name="l01996"></a>01996 
<a name="l01997"></a>01997 <span class="keyword">static</span> asection *
<a name="l01998"></a><a class="code" href="dwarf2read_8c.html#a5d733de1e691ddcd3039d6f5c482fdc2">01998</a> <a class="code" href="dwarf2read_8c.html#a5d733de1e691ddcd3039d6f5c482fdc2">get_section_bfd_section</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section)
<a name="l01999"></a>01999 {
<a name="l02000"></a>02000   <span class="keywordflow">if</span> (section-&gt;<a class="code" href="structdwarf2__section__info.html#a580140de2ff419885dd24bfc36862b48">is_virtual</a>)
<a name="l02001"></a>02001     {
<a name="l02002"></a>02002       section = <a class="code" href="dwarf2read_8c.html#ae0448e717e69369933df6247fdd1a4ea">get_containing_section</a> (section);
<a name="l02003"></a>02003       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!section-&gt;<a class="code" href="structdwarf2__section__info.html#a580140de2ff419885dd24bfc36862b48">is_virtual</a>);
<a name="l02004"></a>02004     }
<a name="l02005"></a>02005   <span class="keywordflow">return</span> section-&gt;<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a>;
<a name="l02006"></a>02006 }
<a name="l02007"></a>02007 
<a name="l02008"></a>02008 <span class="comment">/* Return the name of SECTION.  */</span>
<a name="l02009"></a>02009 
<a name="l02010"></a>02010 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l02011"></a><a class="code" href="dwarf2read_8c.html#a206c558e28b7bc7fcf8bdad145cabef1">02011</a> <a class="code" href="dwarf2read_8c.html#a206c558e28b7bc7fcf8bdad145cabef1">get_section_name</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section)
<a name="l02012"></a>02012 {
<a name="l02013"></a>02013   asection *sectp = <a class="code" href="dwarf2read_8c.html#a5d733de1e691ddcd3039d6f5c482fdc2">get_section_bfd_section</a> (section);
<a name="l02014"></a>02014 
<a name="l02015"></a>02015   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sectp != NULL);
<a name="l02016"></a>02016   <span class="keywordflow">return</span> bfd_section_name (<a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section), sectp);
<a name="l02017"></a>02017 }
<a name="l02018"></a>02018 
<a name="l02019"></a>02019 <span class="comment">/* Return the name of the file SECTION is in.  */</span>
<a name="l02020"></a>02020 
<a name="l02021"></a>02021 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l02022"></a><a class="code" href="dwarf2read_8c.html#a1c841524fdd0bd73272dad700a7452f6">02022</a> <a class="code" href="dwarf2read_8c.html#a1c841524fdd0bd73272dad700a7452f6">get_section_file_name</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section)
<a name="l02023"></a>02023 {
<a name="l02024"></a>02024   bfd *abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l02025"></a>02025 
<a name="l02026"></a>02026   <span class="keywordflow">return</span> bfd_get_filename (abfd);
<a name="l02027"></a>02027 }
<a name="l02028"></a>02028 
<a name="l02029"></a>02029 <span class="comment">/* Return the id of SECTION.</span>
<a name="l02030"></a>02030 <span class="comment">   Returns 0 if SECTION doesn&#39;t exist.  */</span>
<a name="l02031"></a>02031 
<a name="l02032"></a>02032 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02033"></a><a class="code" href="dwarf2read_8c.html#a11d63fb1d7c715a9a0c0efe8602d370c">02033</a> <a class="code" href="dwarf2read_8c.html#a11d63fb1d7c715a9a0c0efe8602d370c">get_section_id</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section)
<a name="l02034"></a>02034 {
<a name="l02035"></a>02035   asection *sectp = <a class="code" href="dwarf2read_8c.html#a5d733de1e691ddcd3039d6f5c482fdc2">get_section_bfd_section</a> (section);
<a name="l02036"></a>02036 
<a name="l02037"></a>02037   <span class="keywordflow">if</span> (sectp == NULL)
<a name="l02038"></a>02038     <span class="keywordflow">return</span> 0;
<a name="l02039"></a>02039   <span class="keywordflow">return</span> sectp-&gt;id;
<a name="l02040"></a>02040 }
<a name="l02041"></a>02041 
<a name="l02042"></a>02042 <span class="comment">/* Return the flags of SECTION.</span>
<a name="l02043"></a>02043 <span class="comment">   SECTION (or containing section if this is a virtual section) must exist.  */</span>
<a name="l02044"></a>02044 
<a name="l02045"></a>02045 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02046"></a><a class="code" href="dwarf2read_8c.html#aad01030b562c064777477b1d4b85df65">02046</a> <a class="code" href="dwarf2read_8c.html#aad01030b562c064777477b1d4b85df65">get_section_flags</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section)
<a name="l02047"></a>02047 {
<a name="l02048"></a>02048   asection *sectp = <a class="code" href="dwarf2read_8c.html#a5d733de1e691ddcd3039d6f5c482fdc2">get_section_bfd_section</a> (section);
<a name="l02049"></a>02049 
<a name="l02050"></a>02050   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sectp != NULL);
<a name="l02051"></a>02051   <span class="keywordflow">return</span> bfd_get_section_flags (sectp-&gt;owner, sectp);
<a name="l02052"></a>02052 }
<a name="l02053"></a>02053 
<a name="l02054"></a>02054 <span class="comment">/* When loading sections, we look either for uncompressed section or for</span>
<a name="l02055"></a>02055 <span class="comment">   compressed section names.  */</span>
<a name="l02056"></a>02056 
<a name="l02057"></a>02057 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02058"></a><a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">02058</a> <a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *section_name,
<a name="l02059"></a>02059               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__names.html">dwarf2_section_names</a> *names)
<a name="l02060"></a>02060 {
<a name="l02061"></a>02061   <span class="keywordflow">if</span> (names-&gt;<a class="code" href="structdwarf2__section__names.html#adb80a30eea0ca7a556e95d05bcfba8b1">normal</a> != NULL
<a name="l02062"></a>02062       &amp;&amp; strcmp (section_name, names-&gt;<a class="code" href="structdwarf2__section__names.html#adb80a30eea0ca7a556e95d05bcfba8b1">normal</a>) == 0)
<a name="l02063"></a>02063     <span class="keywordflow">return</span> 1;
<a name="l02064"></a>02064   <span class="keywordflow">if</span> (names-&gt;<a class="code" href="structdwarf2__section__names.html#af5c8d8746d3b24c0c3df3a559ed2af11">compressed</a> != NULL
<a name="l02065"></a>02065       &amp;&amp; strcmp (section_name, names-&gt;<a class="code" href="structdwarf2__section__names.html#af5c8d8746d3b24c0c3df3a559ed2af11">compressed</a>) == 0)
<a name="l02066"></a>02066     <span class="keywordflow">return</span> 1;
<a name="l02067"></a>02067   <span class="keywordflow">return</span> 0;
<a name="l02068"></a>02068 }
<a name="l02069"></a>02069 
<a name="l02070"></a>02070 <span class="comment">/* This function is mapped across the sections and remembers the</span>
<a name="l02071"></a>02071 <span class="comment">   offset and size of each of the debugging sections we are interested</span>
<a name="l02072"></a>02072 <span class="comment">   in.  */</span>
<a name="l02073"></a>02073 
<a name="l02074"></a>02074 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02075"></a><a class="code" href="dwarf2read_8c.html#accff25a253034949d9c4cfded38d2d72">02075</a> <a class="code" href="dwarf2read_8c.html#accff25a253034949d9c4cfded38d2d72">dwarf2_locate_sections</a> (bfd *abfd, asection *sectp, <span class="keywordtype">void</span> *vnames)
<a name="l02076"></a>02076 {
<a name="l02077"></a>02077   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__debug__sections.html">dwarf2_debug_sections</a> *names;
<a name="l02078"></a>02078   flagword aflag = bfd_get_section_flags (abfd, sectp);
<a name="l02079"></a>02079 
<a name="l02080"></a>02080   <span class="keywordflow">if</span> (vnames == NULL)
<a name="l02081"></a>02081     names = &amp;<a class="code" href="dwarf2read_8c.html#a0fa6765b64d6d280522a4ff18e3da6f2">dwarf2_elf_names</a>;
<a name="l02082"></a>02082   <span class="keywordflow">else</span>
<a name="l02083"></a>02083     names = (<span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__debug__sections.html">dwarf2_debug_sections</a> *) vnames;
<a name="l02084"></a>02084 
<a name="l02085"></a>02085   <span class="keywordflow">if</span> ((aflag &amp; SEC_HAS_CONTENTS) == 0)
<a name="l02086"></a>02086     {
<a name="l02087"></a>02087     }
<a name="l02088"></a>02088   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwarf2__debug__sections.html#ac6109d37fa2ce4b7badff5c2b5939e93">info</a>))
<a name="l02089"></a>02089     {
<a name="l02090"></a>02090       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ac4a5ed6e3f9908d638032ba24040a0b9">info</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02091"></a>02091       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ac4a5ed6e3f9908d638032ba24040a0b9">info</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02092"></a>02092     }
<a name="l02093"></a>02093   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwarf2__debug__sections.html#af16e543e2ae1735a6e3da72421ffd8bb">abbrev</a>))
<a name="l02094"></a>02094     {
<a name="l02095"></a>02095       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a65f092d6a408e872a5b5f724728353de">abbrev</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02096"></a>02096       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a65f092d6a408e872a5b5f724728353de">abbrev</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02097"></a>02097     }
<a name="l02098"></a>02098   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwarf2__debug__sections.html#af1cc455ffe958ebb479e326c05e36e0d">line</a>))
<a name="l02099"></a>02099     {
<a name="l02100"></a>02100       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a79ce82df68fb97ec19e6860fdf9c729a">line</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02101"></a>02101       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a79ce82df68fb97ec19e6860fdf9c729a">line</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02102"></a>02102     }
<a name="l02103"></a>02103   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwarf2__debug__sections.html#a4113a2c0b112dede886c17f9e378dc11">loc</a>))
<a name="l02104"></a>02104     {
<a name="l02105"></a>02105       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a13750fe533c751c64de32245c5617623">loc</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02106"></a>02106       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a13750fe533c751c64de32245c5617623">loc</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02107"></a>02107     }
<a name="l02108"></a>02108   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwarf2__debug__sections.html#ad4c8dca61f10322d799b90b4a1d4dd09">macinfo</a>))
<a name="l02109"></a>02109     {
<a name="l02110"></a>02110       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a171eb0e6180390364c7907b187c923fc">macinfo</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02111"></a>02111       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a171eb0e6180390364c7907b187c923fc">macinfo</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02112"></a>02112     }
<a name="l02113"></a>02113   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwarf2__debug__sections.html#ac3d348cbf824355893040d207ca58e3a">macro</a>))
<a name="l02114"></a>02114     {
<a name="l02115"></a>02115       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ab96c1115af7d65e9ca3912d1dc68803d">macro</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02116"></a>02116       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ab96c1115af7d65e9ca3912d1dc68803d">macro</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02117"></a>02117     }
<a name="l02118"></a>02118   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwarf2__debug__sections.html#ac636b10f360a16d20c1cb68c316ab938">str</a>))
<a name="l02119"></a>02119     {
<a name="l02120"></a>02120       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#aa102f0528a3f536a3e96802d8e76cc6b">str</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02121"></a>02121       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#aa102f0528a3f536a3e96802d8e76cc6b">str</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02122"></a>02122     }
<a name="l02123"></a>02123   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwarf2__debug__sections.html#aae364d817fc982c758d2a8bda8283ebf">addr</a>))
<a name="l02124"></a>02124     {
<a name="l02125"></a>02125       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a51717beb2e74eb048118463e0030a16f">addr</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02126"></a>02126       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a51717beb2e74eb048118463e0030a16f">addr</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02127"></a>02127     }
<a name="l02128"></a>02128   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwarf2__debug__sections.html#a3fae3d174d82d561c6ab9d030ac74e9d">frame</a>))
<a name="l02129"></a>02129     {
<a name="l02130"></a>02130       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a4660d1b013f5514a60d8c74dd9483aa8">frame</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02131"></a>02131       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a4660d1b013f5514a60d8c74dd9483aa8">frame</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02132"></a>02132     }
<a name="l02133"></a>02133   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwarf2__debug__sections.html#a476d273a453bbeadd1f17bdf2a00f946">eh_frame</a>))
<a name="l02134"></a>02134     {
<a name="l02135"></a>02135       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a91415d7c88bb86ffe701ef532ab0525f">eh_frame</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02136"></a>02136       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a91415d7c88bb86ffe701ef532ab0525f">eh_frame</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02137"></a>02137     }
<a name="l02138"></a>02138   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwarf2__debug__sections.html#a2d61630fa28aec628d30329031110166">ranges</a>))
<a name="l02139"></a>02139     {
<a name="l02140"></a>02140       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a654a21dc8afa0f2dee30874b781462b0">ranges</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02141"></a>02141       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a654a21dc8afa0f2dee30874b781462b0">ranges</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02142"></a>02142     }
<a name="l02143"></a>02143   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwarf2__debug__sections.html#a46615428435be45b8dec4b52d6e103b0">types</a>))
<a name="l02144"></a>02144     {
<a name="l02145"></a>02145       <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> type_section;
<a name="l02146"></a>02146 
<a name="l02147"></a>02147       <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;type_section, 0, <span class="keyword">sizeof</span> (type_section));
<a name="l02148"></a>02148       type_section.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02149"></a>02149       type_section.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02150"></a>02150 
<a name="l02151"></a>02151       <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>, dwarf2_per_objfile-&gt;types,
<a name="l02152"></a>02152                      &amp;type_section);
<a name="l02153"></a>02153     }
<a name="l02154"></a>02154   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwarf2__debug__sections.html#a8ba2292e54f681a8fead72be3f4811a1">gdb_index</a>))
<a name="l02155"></a>02155     {
<a name="l02156"></a>02156       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a7dccae22ec3934fe5491ca6782d21cdd">gdb_index</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02157"></a>02157       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a7dccae22ec3934fe5491ca6782d21cdd">gdb_index</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02158"></a>02158     }
<a name="l02159"></a>02159 
<a name="l02160"></a>02160   <span class="keywordflow">if</span> ((bfd_get_section_flags (abfd, sectp) &amp; SEC_LOAD)
<a name="l02161"></a>02161       &amp;&amp; bfd_section_vma (abfd, sectp) == 0)
<a name="l02162"></a>02162     dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ab6b03c3a65fa04f04741158e8aebc895">has_section_at_zero</a> = 1;
<a name="l02163"></a>02163 }
<a name="l02164"></a>02164 
<a name="l02165"></a>02165 <span class="comment">/* A helper function that decides whether a section is empty,</span>
<a name="l02166"></a>02166 <span class="comment">   or not present.  */</span>
<a name="l02167"></a>02167 
<a name="l02168"></a>02168 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02169"></a><a class="code" href="dwarf2read_8c.html#ac9e788fb165d736559a5a07bd4cd8dc1">02169</a> <a class="code" href="dwarf2read_8c.html#ac9e788fb165d736559a5a07bd4cd8dc1">dwarf2_section_empty_p</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section)
<a name="l02170"></a>02170 {
<a name="l02171"></a>02171   <span class="keywordflow">if</span> (section-&gt;<a class="code" href="structdwarf2__section__info.html#a580140de2ff419885dd24bfc36862b48">is_virtual</a>)
<a name="l02172"></a>02172     <span class="keywordflow">return</span> section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> == 0;
<a name="l02173"></a>02173   <span class="keywordflow">return</span> section-&gt;<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> == NULL || section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> == 0;
<a name="l02174"></a>02174 }
<a name="l02175"></a>02175 
<a name="l02176"></a>02176 <span class="comment">/* Read the contents of the section INFO.</span>
<a name="l02177"></a>02177 <span class="comment">   OBJFILE is the main object file, but not necessarily the file where</span>
<a name="l02178"></a>02178 <span class="comment">   the section comes from.  E.g., for DWO files the bfd of INFO is the bfd</span>
<a name="l02179"></a>02179 <span class="comment">   of the DWO file.</span>
<a name="l02180"></a>02180 <span class="comment">   If the section is compressed, uncompress it before returning.  */</span>
<a name="l02181"></a>02181 
<a name="l02182"></a>02182 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02183"></a><a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">02183</a> <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>, <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *info)
<a name="l02184"></a>02184 {
<a name="l02185"></a>02185   <a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> *sectp;
<a name="l02186"></a>02186   bfd *abfd;
<a name="l02187"></a>02187   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf, *retbuf;
<a name="l02188"></a>02188 
<a name="l02189"></a>02189   <span class="keywordflow">if</span> (info-&gt;<a class="code" href="structdwarf2__section__info.html#ae115f99a7eba2f52b75574809537e723">readin</a>)
<a name="l02190"></a>02190     <span class="keywordflow">return</span>;
<a name="l02191"></a>02191   info-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> = NULL;
<a name="l02192"></a>02192   info-&gt;<a class="code" href="structdwarf2__section__info.html#ae115f99a7eba2f52b75574809537e723">readin</a> = 1;
<a name="l02193"></a>02193 
<a name="l02194"></a>02194   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ac9e788fb165d736559a5a07bd4cd8dc1">dwarf2_section_empty_p</a> (info))
<a name="l02195"></a>02195     <span class="keywordflow">return</span>;
<a name="l02196"></a>02196 
<a name="l02197"></a>02197   sectp = <a class="code" href="dwarf2read_8c.html#a5d733de1e691ddcd3039d6f5c482fdc2">get_section_bfd_section</a> (info);
<a name="l02198"></a>02198 
<a name="l02199"></a>02199   <span class="comment">/* If this is a virtual section we need to read in the real one first.  */</span>
<a name="l02200"></a>02200   <span class="keywordflow">if</span> (info-&gt;<a class="code" href="structdwarf2__section__info.html#a580140de2ff419885dd24bfc36862b48">is_virtual</a>)
<a name="l02201"></a>02201     {
<a name="l02202"></a>02202       <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *<a class="code" href="structdwarf2__section__info.html#a57c7432f009d2575fa1b3961bf80e912">containing_section</a> =
<a name="l02203"></a>02203         <a class="code" href="dwarf2read_8c.html#ae0448e717e69369933df6247fdd1a4ea">get_containing_section</a> (info);
<a name="l02204"></a>02204 
<a name="l02205"></a>02205       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sectp != NULL);
<a name="l02206"></a>02206       <span class="keywordflow">if</span> ((sectp-&gt;flags &amp; SEC_RELOC) != 0)
<a name="l02207"></a>02207         {
<a name="l02208"></a>02208           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: DWP format V2 with relocations is not&quot;</span>
<a name="l02209"></a>02209                    <span class="stringliteral">&quot; supported in section %s [in module %s]&quot;</span>),
<a name="l02210"></a>02210                  <a class="code" href="dwarf2read_8c.html#a206c558e28b7bc7fcf8bdad145cabef1">get_section_name</a> (info), <a class="code" href="dwarf2read_8c.html#a1c841524fdd0bd73272dad700a7452f6">get_section_file_name</a> (info));
<a name="l02211"></a>02211         }
<a name="l02212"></a>02212       <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, containing_section);
<a name="l02213"></a>02213       <span class="comment">/* Other code should have already caught virtual sections that don&#39;t</span>
<a name="l02214"></a>02214 <span class="comment">         fit.  */</span>
<a name="l02215"></a>02215       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (info-&gt;<a class="code" href="structdwarf2__section__info.html#a28b1e09df667dbfed7cc7f7a9e8f7e7e">virtual_offset</a> + info-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>
<a name="l02216"></a>02216                   &lt;= containing_section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>);
<a name="l02217"></a>02217       <span class="comment">/* If the real section is empty or there was a problem reading the</span>
<a name="l02218"></a>02218 <span class="comment">         section we shouldn&#39;t get here.  */</span>
<a name="l02219"></a>02219       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (containing_section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> != NULL);
<a name="l02220"></a>02220       info-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> = containing_section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + info-&gt;<a class="code" href="structdwarf2__section__info.html#a28b1e09df667dbfed7cc7f7a9e8f7e7e">virtual_offset</a>;
<a name="l02221"></a>02221       <span class="keywordflow">return</span>;
<a name="l02222"></a>02222     }
<a name="l02223"></a>02223 
<a name="l02224"></a>02224   <span class="comment">/* If the section has relocations, we must read it ourselves.</span>
<a name="l02225"></a>02225 <span class="comment">     Otherwise we attach it to the BFD.  */</span>
<a name="l02226"></a>02226   <span class="keywordflow">if</span> ((sectp-&gt;flags &amp; SEC_RELOC) == 0)
<a name="l02227"></a>02227     {
<a name="l02228"></a>02228       info-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> = <a class="code" href="gdb__bfd_8c.html#a89198366b3bafe347c3f85f9fb2d3458">gdb_bfd_map_section</a> (sectp, &amp;info-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>);
<a name="l02229"></a>02229       <span class="keywordflow">return</span>;
<a name="l02230"></a>02230     }
<a name="l02231"></a>02231 
<a name="l02232"></a>02232   buf = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, info-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>);
<a name="l02233"></a>02233   info-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> = buf;
<a name="l02234"></a>02234 
<a name="l02235"></a>02235   <span class="comment">/* When debugging .o files, we may need to apply relocations; see</span>
<a name="l02236"></a>02236 <span class="comment">     http://sourceware.org/ml/gdb-patches/2002-04/msg00136.html .</span>
<a name="l02237"></a>02237 <span class="comment">     We never compress sections in .o files, so we only need to</span>
<a name="l02238"></a>02238 <span class="comment">     try this when the section is not compressed.  */</span>
<a name="l02239"></a>02239   retbuf = <a class="code" href="symfile_8c.html#ad9916abf73b2eb45e16fdb860877feaf">symfile_relocate_debug_section</a> (objfile, sectp, buf);
<a name="l02240"></a>02240   <span class="keywordflow">if</span> (retbuf != NULL)
<a name="l02241"></a>02241     {
<a name="l02242"></a>02242       info-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> = retbuf;
<a name="l02243"></a>02243       <span class="keywordflow">return</span>;
<a name="l02244"></a>02244     }
<a name="l02245"></a>02245 
<a name="l02246"></a>02246   abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (info);
<a name="l02247"></a>02247   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (abfd != NULL);
<a name="l02248"></a>02248 
<a name="l02249"></a>02249   <span class="keywordflow">if</span> (bfd_seek (abfd, sectp-&gt;filepos, SEEK_SET) != 0
<a name="l02250"></a>02250       || bfd_bread (buf, info-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>, abfd) != info-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>)
<a name="l02251"></a>02251     {
<a name="l02252"></a>02252       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Can&#39;t read DWARF data&quot;</span>
<a name="l02253"></a>02253                <span class="stringliteral">&quot; in section %s [in module %s]&quot;</span>),
<a name="l02254"></a>02254              bfd_section_name (abfd, sectp), bfd_get_filename (abfd));
<a name="l02255"></a>02255     }
<a name="l02256"></a>02256 }
<a name="l02257"></a>02257 
<a name="l02258"></a>02258 <span class="comment">/* A helper function that returns the size of a section in a safe way.</span>
<a name="l02259"></a>02259 <span class="comment">   If you are positive that the section has been read before using the</span>
<a name="l02260"></a>02260 <span class="comment">   size, then it is safe to refer to the dwarf2_section_info object&#39;s</span>
<a name="l02261"></a>02261 <span class="comment">   &quot;size&quot; field directly.  In other cases, you must call this</span>
<a name="l02262"></a>02262 <span class="comment">   function, because for compressed sections the size field is not set</span>
<a name="l02263"></a>02263 <span class="comment">   correctly until the section has been read.  */</span>
<a name="l02264"></a>02264 
<a name="l02265"></a>02265 <span class="keyword">static</span> bfd_size_type
<a name="l02266"></a><a class="code" href="dwarf2read_8c.html#ab7078b0a27fb1b75f90d215b5d649771">02266</a> <a class="code" href="dwarf2read_8c.html#ab7078b0a27fb1b75f90d215b5d649771">dwarf2_section_size</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l02267"></a>02267                      <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *info)
<a name="l02268"></a>02268 {
<a name="l02269"></a>02269   <span class="keywordflow">if</span> (!info-&gt;<a class="code" href="structdwarf2__section__info.html#ae115f99a7eba2f52b75574809537e723">readin</a>)
<a name="l02270"></a>02270     <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, info);
<a name="l02271"></a>02271   <span class="keywordflow">return</span> info-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>;
<a name="l02272"></a>02272 }
<a name="l02273"></a>02273 
<a name="l02274"></a>02274 <span class="comment">/* Fill in SECTP, BUFP and SIZEP with section info, given OBJFILE and</span>
<a name="l02275"></a>02275 <span class="comment">   SECTION_NAME.  */</span>
<a name="l02276"></a>02276 
<a name="l02277"></a>02277 <span class="keywordtype">void</span>
<a name="l02278"></a><a class="code" href="symfile_8h.html#a8c4e6ec1fea3fa46413025277c56c217">02278</a> <a class="code" href="dwarf2read_8c.html#ad43134c2824bd83809a9afb35dda61d5">dwarf2_get_section_info</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l02279"></a>02279                          <span class="keyword">enum</span> <a class="code" href="symfile_8h.html#a9cfdee1fc82a2fcff93ad1b09895a316">dwarf2_section_enum</a> sect,
<a name="l02280"></a>02280                          <a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> **sectp, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **bufp,
<a name="l02281"></a>02281                          bfd_size_type *sizep)
<a name="l02282"></a>02282 {
<a name="l02283"></a>02283   <span class="keyword">struct </span>dwarf2_per_objfile *data
<a name="l02284"></a>02284     = objfile_data (objfile, <a class="code" href="dwarf2read_8c.html#a9fcfdd623d890b4c3b4ac0ba42e7df4b">dwarf2_objfile_data_key</a>);
<a name="l02285"></a>02285   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *info;
<a name="l02286"></a>02286 
<a name="l02287"></a>02287   <span class="comment">/* We may see an objfile without any DWARF, in which case we just</span>
<a name="l02288"></a>02288 <span class="comment">     return nothing.  */</span>
<a name="l02289"></a>02289   <span class="keywordflow">if</span> (data == NULL)
<a name="l02290"></a>02290     {
<a name="l02291"></a>02291       *sectp = NULL;
<a name="l02292"></a>02292       *bufp = NULL;
<a name="l02293"></a>02293       *sizep = 0;
<a name="l02294"></a>02294       <span class="keywordflow">return</span>;
<a name="l02295"></a>02295     }
<a name="l02296"></a>02296   <span class="keywordflow">switch</span> (sect)
<a name="l02297"></a>02297     {
<a name="l02298"></a>02298     <span class="keywordflow">case</span> <a class="code" href="symfile_8h.html#a9cfdee1fc82a2fcff93ad1b09895a316a76ae9ccf61e6cfc77d499f479f606ec2">DWARF2_DEBUG_FRAME</a>:
<a name="l02299"></a>02299       info = &amp;data-&gt;<a class="code" href="structdwarf2__per__objfile.html#a4660d1b013f5514a60d8c74dd9483aa8">frame</a>;
<a name="l02300"></a>02300       <span class="keywordflow">break</span>;
<a name="l02301"></a>02301     <span class="keywordflow">case</span> <a class="code" href="symfile_8h.html#a9cfdee1fc82a2fcff93ad1b09895a316a6224a207d95610aaa7a9358822a8d1ba">DWARF2_EH_FRAME</a>:
<a name="l02302"></a>02302       info = &amp;data-&gt;<a class="code" href="structdwarf2__per__objfile.html#a91415d7c88bb86ffe701ef532ab0525f">eh_frame</a>;
<a name="l02303"></a>02303       <span class="keywordflow">break</span>;
<a name="l02304"></a>02304     <span class="keywordflow">default</span>:
<a name="l02305"></a>02305       <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;unexpected section&quot;</span>);
<a name="l02306"></a>02306     }
<a name="l02307"></a>02307 
<a name="l02308"></a>02308   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, info);
<a name="l02309"></a>02309 
<a name="l02310"></a>02310   *sectp = <a class="code" href="dwarf2read_8c.html#a5d733de1e691ddcd3039d6f5c482fdc2">get_section_bfd_section</a> (info);
<a name="l02311"></a>02311   *bufp = info-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>;
<a name="l02312"></a>02312   *sizep = info-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>;
<a name="l02313"></a>02313 }
<a name="l02314"></a>02314 
<a name="l02315"></a>02315 <span class="comment">/* A helper function to find the sections for a .dwz file.  */</span>
<a name="l02316"></a>02316 
<a name="l02317"></a>02317 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02318"></a><a class="code" href="dwarf2read_8c.html#a0fc2d0794ed44e9e7f8ccbbb65464dd4">02318</a> <a class="code" href="dwarf2read_8c.html#a0fc2d0794ed44e9e7f8ccbbb65464dd4">locate_dwz_sections</a> (bfd *abfd, <a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> *sectp, <span class="keywordtype">void</span> *arg)
<a name="l02319"></a>02319 {
<a name="l02320"></a>02320   <span class="keyword">struct </span><a class="code" href="structdwz__file.html">dwz_file</a> *<a class="code" href="structdwz__file.html">dwz_file</a> = arg;
<a name="l02321"></a>02321 
<a name="l02322"></a>02322   <span class="comment">/* Note that we only support the standard ELF names, because .dwz</span>
<a name="l02323"></a>02323 <span class="comment">     is ELF-only (at the time of writing).  */</span>
<a name="l02324"></a>02324   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;dwarf2_elf_names.<a class="code" href="structdwarf2__debug__sections.html#af16e543e2ae1735a6e3da72421ffd8bb">abbrev</a>))
<a name="l02325"></a>02325     {
<a name="l02326"></a>02326       dwz_file-&gt;<a class="code" href="structdwz__file.html#a6d54052c436197e540e433c95f5361e3">abbrev</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02327"></a>02327       dwz_file-&gt;<a class="code" href="structdwz__file.html#a6d54052c436197e540e433c95f5361e3">abbrev</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02328"></a>02328     }
<a name="l02329"></a>02329   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;dwarf2_elf_names.<a class="code" href="structdwarf2__debug__sections.html#ac6109d37fa2ce4b7badff5c2b5939e93">info</a>))
<a name="l02330"></a>02330     {
<a name="l02331"></a>02331       dwz_file-&gt;<a class="code" href="structdwz__file.html#a2c4f25245be0e458f196af80a990969c">info</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02332"></a>02332       dwz_file-&gt;<a class="code" href="structdwz__file.html#a2c4f25245be0e458f196af80a990969c">info</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02333"></a>02333     }
<a name="l02334"></a>02334   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;dwarf2_elf_names.<a class="code" href="structdwarf2__debug__sections.html#ac636b10f360a16d20c1cb68c316ab938">str</a>))
<a name="l02335"></a>02335     {
<a name="l02336"></a>02336       dwz_file-&gt;<a class="code" href="structdwz__file.html#a7eb5552ada9f95eca388ad29b74c28af">str</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02337"></a>02337       dwz_file-&gt;<a class="code" href="structdwz__file.html#a7eb5552ada9f95eca388ad29b74c28af">str</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02338"></a>02338     }
<a name="l02339"></a>02339   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;dwarf2_elf_names.<a class="code" href="structdwarf2__debug__sections.html#af1cc455ffe958ebb479e326c05e36e0d">line</a>))
<a name="l02340"></a>02340     {
<a name="l02341"></a>02341       dwz_file-&gt;<a class="code" href="structdwz__file.html#ae4fcce172e64ed4d7940f70a5e5d6c32">line</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02342"></a>02342       dwz_file-&gt;<a class="code" href="structdwz__file.html#ae4fcce172e64ed4d7940f70a5e5d6c32">line</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02343"></a>02343     }
<a name="l02344"></a>02344   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;dwarf2_elf_names.<a class="code" href="structdwarf2__debug__sections.html#ac3d348cbf824355893040d207ca58e3a">macro</a>))
<a name="l02345"></a>02345     {
<a name="l02346"></a>02346       dwz_file-&gt;<a class="code" href="structdwz__file.html#a76ea7d4cb4937ee64a3383736362e123">macro</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02347"></a>02347       dwz_file-&gt;<a class="code" href="structdwz__file.html#a76ea7d4cb4937ee64a3383736362e123">macro</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02348"></a>02348     }
<a name="l02349"></a>02349   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;dwarf2_elf_names.<a class="code" href="structdwarf2__debug__sections.html#a8ba2292e54f681a8fead72be3f4811a1">gdb_index</a>))
<a name="l02350"></a>02350     {
<a name="l02351"></a>02351       dwz_file-&gt;<a class="code" href="structdwz__file.html#acc28fb02f48f40d5a1b7b454b138474d">gdb_index</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l02352"></a>02352       dwz_file-&gt;<a class="code" href="structdwz__file.html#acc28fb02f48f40d5a1b7b454b138474d">gdb_index</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l02353"></a>02353     }
<a name="l02354"></a>02354 }
<a name="l02355"></a>02355 
<a name="l02356"></a>02356 <span class="comment">/* Open the separate &#39;.dwz&#39; debug file, if needed.  Return NULL if</span>
<a name="l02357"></a>02357 <span class="comment">   there is no .gnu_debugaltlink section in the file.  Error if there</span>
<a name="l02358"></a>02358 <span class="comment">   is such a section but the file cannot be found.  */</span>
<a name="l02359"></a>02359 
<a name="l02360"></a>02360 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwz__file.html">dwz_file</a> *
<a name="l02361"></a><a class="code" href="dwarf2read_8c.html#a926306809098933a820cfda81b19864c">02361</a> <a class="code" href="dwarf2read_8c.html#a926306809098933a820cfda81b19864c">dwarf2_get_dwz_file</a> (<span class="keywordtype">void</span>)
<a name="l02362"></a>02362 {
<a name="l02363"></a>02363   bfd *<a class="code" href="structdwz__file.html#a9fc9bf241da902e55d1a4ddbaa8141eb">dwz_bfd</a>;
<a name="l02364"></a>02364   <span class="keywordtype">char</span> *data;
<a name="l02365"></a>02365   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l02366"></a>02366   <span class="keyword">const</span> <span class="keywordtype">char</span> *filename;
<a name="l02367"></a>02367   <span class="keyword">struct </span><a class="code" href="structdwz__file.html">dwz_file</a> *result;
<a name="l02368"></a>02368   bfd_size_type buildid_len_arg;
<a name="l02369"></a>02369   <span class="keywordtype">size_t</span> buildid_len;
<a name="l02370"></a>02370   bfd_byte *buildid;
<a name="l02371"></a>02371 
<a name="l02372"></a>02372   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ad4eb71f5b2a05e7cb7426df5a13cbb50">dwz_file</a> != NULL)
<a name="l02373"></a>02373     <span class="keywordflow">return</span> dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ad4eb71f5b2a05e7cb7426df5a13cbb50">dwz_file</a>;
<a name="l02374"></a>02374 
<a name="l02375"></a>02375   bfd_set_error (bfd_error_no_error);
<a name="l02376"></a>02376   data = bfd_get_alt_debug_link_info (dwarf2_per_objfile-&gt;objfile-&gt;obfd,
<a name="l02377"></a>02377                                       &amp;buildid_len_arg, &amp;buildid);
<a name="l02378"></a>02378   <span class="keywordflow">if</span> (data == NULL)
<a name="l02379"></a>02379     {
<a name="l02380"></a>02380       <span class="keywordflow">if</span> (bfd_get_error () == bfd_error_no_error)
<a name="l02381"></a>02381         <span class="keywordflow">return</span> NULL;
<a name="l02382"></a>02382       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;could not read &#39;.gnu_debugaltlink&#39; section: %s&quot;</span>),
<a name="l02383"></a>02383              bfd_errmsg (bfd_get_error ()));
<a name="l02384"></a>02384     }
<a name="l02385"></a>02385   cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, data);
<a name="l02386"></a>02386   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, buildid);
<a name="l02387"></a>02387 
<a name="l02388"></a>02388   buildid_len = (size_t) buildid_len_arg;
<a name="l02389"></a>02389 
<a name="l02390"></a>02390   filename = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) data;
<a name="l02391"></a>02391   <span class="keywordflow">if</span> (!IS_ABSOLUTE_PATH (filename))
<a name="l02392"></a>02392     {
<a name="l02393"></a>02393       <span class="keywordtype">char</span> *abs = <a class="code" href="utils_8c.html#a38e450f9b68243416d35f57e37e23e3e">gdb_realpath</a> (<a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (dwarf2_per_objfile-&gt;objfile));
<a name="l02394"></a>02394       <span class="keywordtype">char</span> *rel;
<a name="l02395"></a>02395 
<a name="l02396"></a>02396       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, abs);
<a name="l02397"></a>02397       abs = <a class="code" href="utils_8c.html#a0f0f0c3f49b0f3bcc136eaf5d30024a3">ldirname</a> (abs);
<a name="l02398"></a>02398       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, abs);
<a name="l02399"></a>02399 
<a name="l02400"></a>02400       rel = concat (abs, SLASH_STRING, filename, (<span class="keywordtype">char</span> *) NULL);
<a name="l02401"></a>02401       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, rel);
<a name="l02402"></a>02402       filename = rel;
<a name="l02403"></a>02403     }
<a name="l02404"></a>02404 
<a name="l02405"></a>02405   <span class="comment">/* First try the file name given in the section.  If that doesn&#39;t</span>
<a name="l02406"></a>02406 <span class="comment">     work, try to use the build-id instead.  */</span>
<a name="l02407"></a>02407   dwz_bfd = <a class="code" href="gdb__bfd_8c.html#a5ba645a00a78462b46b2d0c3445eb988">gdb_bfd_open</a> (filename, <a class="code" href="corefile_8c.html#aa6db5afe2b3bfa2cec356b9e68eea21d">gnutarget</a>, -1);
<a name="l02408"></a>02408   <span class="keywordflow">if</span> (dwz_bfd != NULL)
<a name="l02409"></a>02409     {
<a name="l02410"></a>02410       <span class="keywordflow">if</span> (!<a class="code" href="build-id_8c.html#a30ea2d9e8a2c309151cb0b0621a07311">build_id_verify</a> (dwz_bfd, buildid_len, buildid))
<a name="l02411"></a>02411         {
<a name="l02412"></a>02412           <a class="code" href="gdb__bfd_8c.html#a1027b59a8494f937b5760901040dc125">gdb_bfd_unref</a> (dwz_bfd);
<a name="l02413"></a>02413           dwz_bfd = NULL;
<a name="l02414"></a>02414         }
<a name="l02415"></a>02415     }
<a name="l02416"></a>02416 
<a name="l02417"></a>02417   <span class="keywordflow">if</span> (dwz_bfd == NULL)
<a name="l02418"></a>02418     dwz_bfd = <a class="code" href="build-id_8c.html#a3ad444502c260c2bac37c90e3f3a9554">build_id_to_debug_bfd</a> (buildid_len, buildid);
<a name="l02419"></a>02419 
<a name="l02420"></a>02420   <span class="keywordflow">if</span> (dwz_bfd == NULL)
<a name="l02421"></a>02421     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;could not find &#39;.gnu_debugaltlink&#39; file for %s&quot;</span>),
<a name="l02422"></a>02422            <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (dwarf2_per_objfile-&gt;objfile));
<a name="l02423"></a>02423 
<a name="l02424"></a>02424   result = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;dwarf2_per_objfile-&gt;objfile-&gt;objfile_obstack,
<a name="l02425"></a>02425                            <span class="keyword">struct</span> <a class="code" href="structdwz__file.html">dwz_file</a>);
<a name="l02426"></a>02426   result-&gt;<a class="code" href="structdwz__file.html#a9fc9bf241da902e55d1a4ddbaa8141eb">dwz_bfd</a> = <a class="code" href="structdwz__file.html#a9fc9bf241da902e55d1a4ddbaa8141eb">dwz_bfd</a>;
<a name="l02427"></a>02427 
<a name="l02428"></a>02428   bfd_map_over_sections (dwz_bfd, <a class="code" href="dwarf2read_8c.html#a0fc2d0794ed44e9e7f8ccbbb65464dd4">locate_dwz_sections</a>, result);
<a name="l02429"></a>02429 
<a name="l02430"></a>02430   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l02431"></a>02431 
<a name="l02432"></a>02432   dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ad4eb71f5b2a05e7cb7426df5a13cbb50">dwz_file</a> = result;
<a name="l02433"></a>02433   <span class="keywordflow">return</span> result;
<a name="l02434"></a>02434 }
<a name="l02435"></a>02435 
<a name="l02436"></a>02436 <span class="comment">/* DWARF quick_symbols_functions support.  */</span>
<a name="l02437"></a>02437 
<a name="l02438"></a>02438 <span class="comment">/* TUs can share .debug_line entries, and there can be a lot more TUs than</span>
<a name="l02439"></a>02439 <span class="comment">   unique line tables, so we maintain a separate table of all .debug_line</span>
<a name="l02440"></a>02440 <span class="comment">   derived entries to support the sharing.</span>
<a name="l02441"></a>02441 <span class="comment">   All the quick functions need is the list of file names.  We discard the</span>
<a name="l02442"></a>02442 <span class="comment">   line_header when we&#39;re done and don&#39;t need to record it here.  */</span>
<a name="l02443"></a><a class="code" href="structquick__file__names.html">02443</a> <span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a>
<a name="l02444"></a>02444 {
<a name="l02445"></a>02445   <span class="comment">/* The data used to construct the hash key.  */</span>
<a name="l02446"></a><a class="code" href="structquick__file__names.html#af9682d33b88a5e77ecb95e9034ea9710">02446</a>   <span class="keyword">struct </span><a class="code" href="structstmt__list__hash.html">stmt_list_hash</a> <a class="code" href="structquick__file__names.html#af9682d33b88a5e77ecb95e9034ea9710">hash</a>;
<a name="l02447"></a>02447 
<a name="l02448"></a>02448   <span class="comment">/* The number of entries in file_names, real_names.  */</span>
<a name="l02449"></a><a class="code" href="structquick__file__names.html#a534816d8c99e4e4053ca440d06c34010">02449</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structquick__file__names.html#a534816d8c99e4e4053ca440d06c34010">num_file_names</a>;
<a name="l02450"></a>02450 
<a name="l02451"></a>02451   <span class="comment">/* The file names from the line table, after being run through</span>
<a name="l02452"></a>02452 <span class="comment">     file_full_name.  */</span>
<a name="l02453"></a><a class="code" href="structquick__file__names.html#a8c6be91b4164dc5d7265602d0c77e6e7">02453</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> **<a class="code" href="structquick__file__names.html#a8c6be91b4164dc5d7265602d0c77e6e7">file_names</a>;
<a name="l02454"></a>02454 
<a name="l02455"></a>02455   <span class="comment">/* The file names from the line table after being run through</span>
<a name="l02456"></a>02456 <span class="comment">     gdb_realpath.  These are computed lazily.  */</span>
<a name="l02457"></a><a class="code" href="structquick__file__names.html#a14640cf5475332cd70384422e22a8ef5">02457</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> **<a class="code" href="structquick__file__names.html#a14640cf5475332cd70384422e22a8ef5">real_names</a>;
<a name="l02458"></a>02458 };
<a name="l02459"></a>02459 
<a name="l02460"></a>02460 <span class="comment">/* When using the index (and thus not using psymtabs), each CU has an</span>
<a name="l02461"></a>02461 <span class="comment">   object of this type.  This is used to hold information needed by</span>
<a name="l02462"></a>02462 <span class="comment">   the various &quot;quick&quot; methods.  */</span>
<a name="l02463"></a><a class="code" href="structdwarf2__per__cu__quick__data.html">02463</a> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__quick__data.html">dwarf2_per_cu_quick_data</a>
<a name="l02464"></a>02464 {
<a name="l02465"></a>02465   <span class="comment">/* The file table.  This can be NULL if there was no file table</span>
<a name="l02466"></a>02466 <span class="comment">     or it&#39;s currently not read in.</span>
<a name="l02467"></a>02467 <span class="comment">     NOTE: This points into dwarf2_per_objfile-&gt;quick_file_names_table.  */</span>
<a name="l02468"></a><a class="code" href="structdwarf2__per__cu__quick__data.html#add9a664dbc27341d6bfc03bca8bdcbe0">02468</a>   <span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a> *<a class="code" href="structdwarf2__per__cu__quick__data.html#add9a664dbc27341d6bfc03bca8bdcbe0">file_names</a>;
<a name="l02469"></a>02469 
<a name="l02470"></a>02470   <span class="comment">/* The corresponding symbol table.  This is NULL if symbols for this</span>
<a name="l02471"></a>02471 <span class="comment">     CU have not yet been read.  */</span>
<a name="l02472"></a><a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">02472</a>   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a>;
<a name="l02473"></a>02473 
<a name="l02474"></a>02474   <span class="comment">/* A temporary mark bit used when iterating over all CUs in</span>
<a name="l02475"></a>02475 <span class="comment">     expand_symtabs_matching.  */</span>
<a name="l02476"></a><a class="code" href="structdwarf2__per__cu__quick__data.html#aaf5858dc35dca5eb2593ad459b6b3689">02476</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structdwarf2__per__cu__quick__data.html#aaf5858dc35dca5eb2593ad459b6b3689">mark</a> : 1;
<a name="l02477"></a>02477 
<a name="l02478"></a>02478   <span class="comment">/* True if we&#39;ve tried to read the file table and found there isn&#39;t one.</span>
<a name="l02479"></a>02479 <span class="comment">     There will be no point in trying to read it again next time.  */</span>
<a name="l02480"></a><a class="code" href="structdwarf2__per__cu__quick__data.html#a3d2576797835daa34fa6ed75a441cf7e">02480</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structdwarf2__per__cu__quick__data.html#a3d2576797835daa34fa6ed75a441cf7e">no_file_data</a> : 1;
<a name="l02481"></a>02481 };
<a name="l02482"></a>02482 
<a name="l02483"></a>02483 <span class="comment">/* Utility hash function for a stmt_list_hash.  */</span>
<a name="l02484"></a>02484 
<a name="l02485"></a>02485 <span class="keyword">static</span> hashval_t
<a name="l02486"></a><a class="code" href="dwarf2read_8c.html#ae3cc097ac351c0e57b998b829c209d76">02486</a> <a class="code" href="dwarf2read_8c.html#ae3cc097ac351c0e57b998b829c209d76">hash_stmt_list_entry</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structstmt__list__hash.html">stmt_list_hash</a> *<a class="code" href="structstmt__list__hash.html">stmt_list_hash</a>)
<a name="l02487"></a>02487 {
<a name="l02488"></a>02488   hashval_t v = 0;
<a name="l02489"></a>02489 
<a name="l02490"></a>02490   <span class="keywordflow">if</span> (stmt_list_hash-&gt;<a class="code" href="structstmt__list__hash.html#a2372dc58554f328becda07e68d6528a8">dwo_unit</a> != NULL)
<a name="l02491"></a>02491     v += (uintptr_t) stmt_list_hash-&gt;<a class="code" href="structstmt__list__hash.html#a2372dc58554f328becda07e68d6528a8">dwo_unit</a>-&gt;<a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">dwo_file</a>;
<a name="l02492"></a>02492   v += stmt_list_hash-&gt;<a class="code" href="structstmt__list__hash.html#a9ee63f1d951d00448dd2b14430aba5fe">line_offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l02493"></a>02493   <span class="keywordflow">return</span> v;
<a name="l02494"></a>02494 }
<a name="l02495"></a>02495 
<a name="l02496"></a>02496 <span class="comment">/* Utility equality function for a stmt_list_hash.  */</span>
<a name="l02497"></a>02497 
<a name="l02498"></a>02498 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02499"></a><a class="code" href="dwarf2read_8c.html#a9a42bd39ee9332303f5be90a2f2f9b77">02499</a> <a class="code" href="dwarf2read_8c.html#a9a42bd39ee9332303f5be90a2f2f9b77">eq_stmt_list_entry</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structstmt__list__hash.html">stmt_list_hash</a> *lhs,
<a name="l02500"></a>02500                     <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structstmt__list__hash.html">stmt_list_hash</a> *rhs)
<a name="l02501"></a>02501 {
<a name="l02502"></a>02502   <span class="keywordflow">if</span> ((lhs-&gt;<a class="code" href="structstmt__list__hash.html#a2372dc58554f328becda07e68d6528a8">dwo_unit</a> != NULL) != (rhs-&gt;<a class="code" href="structstmt__list__hash.html#a2372dc58554f328becda07e68d6528a8">dwo_unit</a> != NULL))
<a name="l02503"></a>02503     <span class="keywordflow">return</span> 0;
<a name="l02504"></a>02504   <span class="keywordflow">if</span> (lhs-&gt;<a class="code" href="structstmt__list__hash.html#a2372dc58554f328becda07e68d6528a8">dwo_unit</a> != NULL
<a name="l02505"></a>02505       &amp;&amp; lhs-&gt;<a class="code" href="structstmt__list__hash.html#a2372dc58554f328becda07e68d6528a8">dwo_unit</a>-&gt;<a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">dwo_file</a> != rhs-&gt;<a class="code" href="structstmt__list__hash.html#a2372dc58554f328becda07e68d6528a8">dwo_unit</a>-&gt;<a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">dwo_file</a>)
<a name="l02506"></a>02506     <span class="keywordflow">return</span> 0;
<a name="l02507"></a>02507 
<a name="l02508"></a>02508   <span class="keywordflow">return</span> lhs-&gt;<a class="code" href="structstmt__list__hash.html#a9ee63f1d951d00448dd2b14430aba5fe">line_offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> == rhs-&gt;<a class="code" href="structstmt__list__hash.html#a9ee63f1d951d00448dd2b14430aba5fe">line_offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l02509"></a>02509 }
<a name="l02510"></a>02510 
<a name="l02511"></a>02511 <span class="comment">/* Hash function for a quick_file_names.  */</span>
<a name="l02512"></a>02512 
<a name="l02513"></a>02513 <span class="keyword">static</span> hashval_t
<a name="l02514"></a><a class="code" href="dwarf2read_8c.html#aa745cd06dbc9297edabf0b884cefe836">02514</a> <a class="code" href="dwarf2read_8c.html#aa745cd06dbc9297edabf0b884cefe836">hash_file_name_entry</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *e)
<a name="l02515"></a>02515 {
<a name="l02516"></a>02516   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a> *file_data = e;
<a name="l02517"></a>02517 
<a name="l02518"></a>02518   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#ae3cc097ac351c0e57b998b829c209d76">hash_stmt_list_entry</a> (&amp;file_data-&gt;<a class="code" href="structquick__file__names.html#af9682d33b88a5e77ecb95e9034ea9710">hash</a>);
<a name="l02519"></a>02519 }
<a name="l02520"></a>02520 
<a name="l02521"></a>02521 <span class="comment">/* Equality function for a quick_file_names.  */</span>
<a name="l02522"></a>02522 
<a name="l02523"></a>02523 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02524"></a><a class="code" href="dwarf2read_8c.html#a0ac5c74563fa648c2377648331f7f54a">02524</a> <a class="code" href="dwarf2read_8c.html#a0ac5c74563fa648c2377648331f7f54a">eq_file_name_entry</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)
<a name="l02525"></a>02525 {
<a name="l02526"></a>02526   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a> *ea = a;
<a name="l02527"></a>02527   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a> *eb = b;
<a name="l02528"></a>02528 
<a name="l02529"></a>02529   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a9a42bd39ee9332303f5be90a2f2f9b77">eq_stmt_list_entry</a> (&amp;ea-&gt;<a class="code" href="structquick__file__names.html#af9682d33b88a5e77ecb95e9034ea9710">hash</a>, &amp;eb-&gt;<a class="code" href="structquick__file__names.html#af9682d33b88a5e77ecb95e9034ea9710">hash</a>);
<a name="l02530"></a>02530 }
<a name="l02531"></a>02531 
<a name="l02532"></a>02532 <span class="comment">/* Delete function for a quick_file_names.  */</span>
<a name="l02533"></a>02533 
<a name="l02534"></a>02534 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02535"></a><a class="code" href="dwarf2read_8c.html#a86f6bf8fcb742b49c5ecaa40da15a017">02535</a> <a class="code" href="dwarf2read_8c.html#a86f6bf8fcb742b49c5ecaa40da15a017">delete_file_name_entry</a> (<span class="keywordtype">void</span> *e)
<a name="l02536"></a>02536 {
<a name="l02537"></a>02537   <span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a> *file_data = e;
<a name="l02538"></a>02538   <span class="keywordtype">int</span> i;
<a name="l02539"></a>02539 
<a name="l02540"></a>02540   <span class="keywordflow">for</span> (i = 0; i &lt; file_data-&gt;<a class="code" href="structquick__file__names.html#a534816d8c99e4e4053ca440d06c34010">num_file_names</a>; ++i)
<a name="l02541"></a>02541     {
<a name="l02542"></a>02542       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> ((<span class="keywordtype">void</span>*) file_data-&gt;<a class="code" href="structquick__file__names.html#a8c6be91b4164dc5d7265602d0c77e6e7">file_names</a>[i]);
<a name="l02543"></a>02543       <span class="keywordflow">if</span> (file_data-&gt;<a class="code" href="structquick__file__names.html#a14640cf5475332cd70384422e22a8ef5">real_names</a>)
<a name="l02544"></a>02544         <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> ((<span class="keywordtype">void</span>*) file_data-&gt;<a class="code" href="structquick__file__names.html#a14640cf5475332cd70384422e22a8ef5">real_names</a>[i]);
<a name="l02545"></a>02545     }
<a name="l02546"></a>02546 
<a name="l02547"></a>02547   <span class="comment">/* The space for the struct itself lives on objfile_obstack,</span>
<a name="l02548"></a>02548 <span class="comment">     so we don&#39;t free it here.  */</span>
<a name="l02549"></a>02549 }
<a name="l02550"></a>02550 
<a name="l02551"></a>02551 <span class="comment">/* Create a quick_file_names hash table.  */</span>
<a name="l02552"></a>02552 
<a name="l02553"></a>02553 <span class="keyword">static</span> htab_t
<a name="l02554"></a><a class="code" href="dwarf2read_8c.html#a3e3ee9237abb0774920bf5fa4edaf782">02554</a> <a class="code" href="dwarf2read_8c.html#a3e3ee9237abb0774920bf5fa4edaf782">create_quick_file_names_table</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nr_initial_entries)
<a name="l02555"></a>02555 {
<a name="l02556"></a>02556   <span class="keywordflow">return</span> htab_create_alloc (nr_initial_entries,
<a name="l02557"></a>02557                             <a class="code" href="dwarf2read_8c.html#aa745cd06dbc9297edabf0b884cefe836">hash_file_name_entry</a>, <a class="code" href="dwarf2read_8c.html#a0ac5c74563fa648c2377648331f7f54a">eq_file_name_entry</a>,
<a name="l02558"></a>02558                             <a class="code" href="dwarf2read_8c.html#a86f6bf8fcb742b49c5ecaa40da15a017">delete_file_name_entry</a>, <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a>, <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>);
<a name="l02559"></a>02559 }
<a name="l02560"></a>02560 
<a name="l02561"></a>02561 <span class="comment">/* Read in PER_CU-&gt;CU.  This function is unrelated to symtabs, symtab would</span>
<a name="l02562"></a>02562 <span class="comment">   have to be created afterwards.  You should call age_cached_comp_units after</span>
<a name="l02563"></a>02563 <span class="comment">   processing PER_CU-&gt;CU.  dw2_setup must have been already called.  */</span>
<a name="l02564"></a>02564 
<a name="l02565"></a>02565 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02566"></a><a class="code" href="dwarf2read_8c.html#a2a36765902f5385cca0fde58497b3c8b">02566</a> <a class="code" href="dwarf2read_8c.html#a2a36765902f5385cca0fde58497b3c8b">load_cu</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l02567"></a>02567 {
<a name="l02568"></a>02568   <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l02569"></a>02569     <a class="code" href="dwarf2read_8c.html#a1d0f2204cbb2e3c2103d9e9a40b97f61">load_full_type_unit</a> (per_cu);
<a name="l02570"></a>02570   <span class="keywordflow">else</span>
<a name="l02571"></a>02571     <a class="code" href="dwarf2read_8c.html#a9f845956e1dd14ace7c6471ee8c2b502">load_full_comp_unit</a> (per_cu, <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a389b59241274e837cb0d28b1909013ac">language_minimal</a>);
<a name="l02572"></a>02572 
<a name="l02573"></a>02573   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> != NULL);
<a name="l02574"></a>02574 
<a name="l02575"></a>02575   <a class="code" href="dwarf2read_8c.html#af314d232c2dcff121c89ecf2ed276658">dwarf2_find_base_address</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#abc8aaad6bb3799398e9769f989fd1692">dies</a>, per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>);
<a name="l02576"></a>02576 }
<a name="l02577"></a>02577 
<a name="l02578"></a>02578 <span class="comment">/* Read in the symbols for PER_CU.  */</span>
<a name="l02579"></a>02579 
<a name="l02580"></a>02580 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02581"></a><a class="code" href="dwarf2read_8c.html#ad7b59f87ccb0c49dacf808e1053982d8">02581</a> <a class="code" href="dwarf2read_8c.html#ad7b59f87ccb0c49dacf808e1053982d8">dw2_do_instantiate_symtab</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l02582"></a>02582 {
<a name="l02583"></a>02583   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to;
<a name="l02584"></a>02584 
<a name="l02585"></a>02585   <span class="comment">/* Skip type_unit_groups, reading the type units they contain</span>
<a name="l02586"></a>02586 <span class="comment">     is handled elsewhere.  */</span>
<a name="l02587"></a>02587   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#aa278b6364c9b859353eeea535d81221e">IS_TYPE_UNIT_GROUP</a> (per_cu))
<a name="l02588"></a>02588     <span class="keywordflow">return</span>;
<a name="l02589"></a>02589 
<a name="l02590"></a>02590   back_to = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#ace3060cbcc6a275e2260e5261c3f9dda">dwarf2_release_queue</a>, NULL);
<a name="l02591"></a>02591 
<a name="l02592"></a>02592   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a>
<a name="l02593"></a>02593       ? per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a> == NULL
<a name="l02594"></a>02594       : (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a> == NULL || !per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a>-&gt;<a class="code" href="structpartial__symtab.html#a11d8e59b962db1317c8c23f917dbed42">readin</a>))
<a name="l02595"></a>02595     {
<a name="l02596"></a>02596       <a class="code" href="dwarf2read_8c.html#a756eccd342c094e5937e6ab43bf8a5a4">queue_comp_unit</a> (per_cu, <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a389b59241274e837cb0d28b1909013ac">language_minimal</a>);
<a name="l02597"></a>02597       <a class="code" href="dwarf2read_8c.html#a2a36765902f5385cca0fde58497b3c8b">load_cu</a> (per_cu);
<a name="l02598"></a>02598 
<a name="l02599"></a>02599       <span class="comment">/* If we just loaded a CU from a DWO, and we&#39;re working with an index</span>
<a name="l02600"></a>02600 <span class="comment">         that may badly handle TUs, load all the TUs in that DWO as well.</span>
<a name="l02601"></a>02601 <span class="comment">         http://sourceware.org/bugzilla/show_bug.cgi?id=15021  */</span>
<a name="l02602"></a>02602       <span class="keywordflow">if</span> (!per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>
<a name="l02603"></a>02603           &amp;&amp; per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;dwo_unit != NULL
<a name="l02604"></a>02604           &amp;&amp; dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a1e58a614b6e77589e24dac14dfdc62e5">index_table</a> != NULL
<a name="l02605"></a>02605           &amp;&amp; dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a1e58a614b6e77589e24dac14dfdc62e5">index_table</a>-&gt;<a class="code" href="structmapped__index.html#a6204ce2b69334c8d243357d524858ccd">version</a> &lt;= 7
<a name="l02606"></a>02606           <span class="comment">/* DWP files aren&#39;t supported yet.  */</span>
<a name="l02607"></a>02607           &amp;&amp; <a class="code" href="dwarf2read_8c.html#a9fc2d7d27eba883b582555229c60c32e">get_dwp_file</a> () == NULL)
<a name="l02608"></a>02608         <a class="code" href="dwarf2read_8c.html#a94cfe716f234c867cf44c1880aed5f2e">queue_and_load_all_dwo_tus</a> (per_cu);
<a name="l02609"></a>02609     }
<a name="l02610"></a>02610 
<a name="l02611"></a>02611   <a class="code" href="dwarf2read_8c.html#a4299d1028cbe9bbcebb435f92cf3cbda">process_queue</a> ();
<a name="l02612"></a>02612 
<a name="l02613"></a>02613   <span class="comment">/* Age the cache, releasing compilation units that have not</span>
<a name="l02614"></a>02614 <span class="comment">     been used recently.  */</span>
<a name="l02615"></a>02615   <a class="code" href="dwarf2read_8c.html#aea3bec269cdf43d65a84eb61d8c2c48b">age_cached_comp_units</a> ();
<a name="l02616"></a>02616 
<a name="l02617"></a>02617   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l02618"></a>02618 }
<a name="l02619"></a>02619 
<a name="l02620"></a>02620 <span class="comment">/* Ensure that the symbols for PER_CU have been read in.  OBJFILE is</span>
<a name="l02621"></a>02621 <span class="comment">   the objfile from which this CU came.  Returns the resulting symbol</span>
<a name="l02622"></a>02622 <span class="comment">   table.  */</span>
<a name="l02623"></a>02623 
<a name="l02624"></a>02624 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *
<a name="l02625"></a><a class="code" href="dwarf2read_8c.html#a6acd40df616a0b5d96cbb15ab3690346">02625</a> <a class="code" href="dwarf2read_8c.html#a6acd40df616a0b5d96cbb15ab3690346">dw2_instantiate_symtab</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l02626"></a>02626 {
<a name="l02627"></a>02627   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a>);
<a name="l02628"></a>02628   <span class="keywordflow">if</span> (!per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a>)
<a name="l02629"></a>02629     {
<a name="l02630"></a>02630       <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#a8fe96d50d88ef6a4b3ef501aada103ab">free_cached_comp_units</a>, NULL);
<a name="l02631"></a>02631       <a class="code" href="symfile_8c.html#abdb94eda660bee43eb668a16fef021af">increment_reading_symtab</a> ();
<a name="l02632"></a>02632       <a class="code" href="dwarf2read_8c.html#ad7b59f87ccb0c49dacf808e1053982d8">dw2_do_instantiate_symtab</a> (per_cu);
<a name="l02633"></a>02633       <a class="code" href="dwarf2read_8c.html#a15521f267ec507aa6fbf4e80df678078">process_cu_includes</a> ();
<a name="l02634"></a>02634       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l02635"></a>02635     }
<a name="l02636"></a>02636   <span class="keywordflow">return</span> per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a>;
<a name="l02637"></a>02637 }
<a name="l02638"></a>02638 
<a name="l02639"></a>02639 <span class="comment">/* Return the CU given its index.</span>
<a name="l02640"></a>02640 <span class="comment"></span>
<a name="l02641"></a>02641 <span class="comment">   This is intended for loops like:</span>
<a name="l02642"></a>02642 <span class="comment"></span>
<a name="l02643"></a>02643 <span class="comment">   for (i = 0; i &lt; (dwarf2_per_objfile-&gt;n_comp_units</span>
<a name="l02644"></a>02644 <span class="comment">                    + dwarf2_per_objfile-&gt;n_type_units); ++i)</span>
<a name="l02645"></a>02645 <span class="comment">     {</span>
<a name="l02646"></a>02646 <span class="comment">       struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);</span>
<a name="l02647"></a>02647 <span class="comment"></span>
<a name="l02648"></a>02648 <span class="comment">       ...;</span>
<a name="l02649"></a>02649 <span class="comment">     }</span>
<a name="l02650"></a>02650 <span class="comment">*/</span>
<a name="l02651"></a>02651 
<a name="l02652"></a>02652 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *
<a name="l02653"></a><a class="code" href="dwarf2read_8c.html#a966b4a69ea94ca30717c495126d870c8">02653</a> <a class="code" href="dwarf2read_8c.html#a966b4a69ea94ca30717c495126d870c8">dw2_get_cu</a> (<span class="keywordtype">int</span> index)
<a name="l02654"></a>02654 {
<a name="l02655"></a>02655   <span class="keywordflow">if</span> (index &gt;= dwarf2_per_objfile-&gt;n_comp_units)
<a name="l02656"></a>02656     {
<a name="l02657"></a>02657       index -= dwarf2_per_objfile-&gt;n_comp_units;
<a name="l02658"></a>02658       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (index &lt; dwarf2_per_objfile-&gt;n_type_units);
<a name="l02659"></a>02659       <span class="keywordflow">return</span> &amp;dwarf2_per_objfile-&gt;all_type_units[index]-&gt;per_cu;
<a name="l02660"></a>02660     }
<a name="l02661"></a>02661 
<a name="l02662"></a>02662   <span class="keywordflow">return</span> dwarf2_per_objfile-&gt;all_comp_units[index];
<a name="l02663"></a>02663 }
<a name="l02664"></a>02664 
<a name="l02665"></a>02665 <span class="comment">/* Return the primary CU given its index.</span>
<a name="l02666"></a>02666 <span class="comment">   The difference between this function and dw2_get_cu is in the handling</span>
<a name="l02667"></a>02667 <span class="comment">   of type units (TUs).  Here we return the type_unit_group object.</span>
<a name="l02668"></a>02668 <span class="comment"></span>
<a name="l02669"></a>02669 <span class="comment">   This is intended for loops like:</span>
<a name="l02670"></a>02670 <span class="comment"></span>
<a name="l02671"></a>02671 <span class="comment">   for (i = 0; i &lt; (dwarf2_per_objfile-&gt;n_comp_units</span>
<a name="l02672"></a>02672 <span class="comment">                    + dwarf2_per_objfile-&gt;n_type_unit_groups); ++i)</span>
<a name="l02673"></a>02673 <span class="comment">     {</span>
<a name="l02674"></a>02674 <span class="comment">       struct dwarf2_per_cu_data *per_cu = dw2_get_primary_cu (i);</span>
<a name="l02675"></a>02675 <span class="comment"></span>
<a name="l02676"></a>02676 <span class="comment">       ...;</span>
<a name="l02677"></a>02677 <span class="comment">     }</span>
<a name="l02678"></a>02678 <span class="comment">*/</span>
<a name="l02679"></a>02679 
<a name="l02680"></a>02680 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *
<a name="l02681"></a><a class="code" href="dwarf2read_8c.html#a03d87974d046042a783bdf70e2f48083">02681</a> <a class="code" href="dwarf2read_8c.html#a03d87974d046042a783bdf70e2f48083">dw2_get_primary_cu</a> (<span class="keywordtype">int</span> index)
<a name="l02682"></a>02682 {
<a name="l02683"></a>02683   <span class="keywordflow">if</span> (index &gt;= dwarf2_per_objfile-&gt;n_comp_units)
<a name="l02684"></a>02684     {
<a name="l02685"></a>02685       index -= dwarf2_per_objfile-&gt;n_comp_units;
<a name="l02686"></a>02686       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (index &lt; dwarf2_per_objfile-&gt;n_type_unit_groups);
<a name="l02687"></a>02687       <span class="keywordflow">return</span> &amp;dwarf2_per_objfile-&gt;all_type_unit_groups[index]-&gt;per_cu;
<a name="l02688"></a>02688     }
<a name="l02689"></a>02689 
<a name="l02690"></a>02690   <span class="keywordflow">return</span> dwarf2_per_objfile-&gt;all_comp_units[index];
<a name="l02691"></a>02691 }
<a name="l02692"></a>02692 
<a name="l02693"></a>02693 <span class="comment">/* A helper for create_cus_from_index that handles a given list of</span>
<a name="l02694"></a>02694 <span class="comment">   CUs.  */</span>
<a name="l02695"></a>02695 
<a name="l02696"></a>02696 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02697"></a><a class="code" href="dwarf2read_8c.html#a1166f65d8a9b165ad803249504b3269b">02697</a> <a class="code" href="dwarf2read_8c.html#a1166f65d8a9b165ad803249504b3269b">create_cus_from_index_list</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l02698"></a>02698                             <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *cu_list, <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> n_elements,
<a name="l02699"></a>02699                             <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *<a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a>,
<a name="l02700"></a>02700                             <span class="keywordtype">int</span> <a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a>,
<a name="l02701"></a>02701                             <span class="keywordtype">int</span> base_offset)
<a name="l02702"></a>02702 {
<a name="l02703"></a>02703   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> i;
<a name="l02704"></a>02704 
<a name="l02705"></a>02705   <span class="keywordflow">for</span> (i = 0; i &lt; n_elements; i += 2)
<a name="l02706"></a>02706     {
<a name="l02707"></a>02707       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *the_cu;
<a name="l02708"></a>02708       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a>;
<a name="l02709"></a>02709 
<a name="l02710"></a>02710       <a class="code" href="gdb__assert_8h.html#a624909d860d72ccf64cd9a5896bd5faf">gdb_static_assert</a> (<span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a>) &gt;= 8);
<a name="l02711"></a>02711       offset = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (cu_list, 8, BFD_ENDIAN_LITTLE);
<a name="l02712"></a>02712       length = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (cu_list + 8, 8, BFD_ENDIAN_LITTLE);
<a name="l02713"></a>02713       cu_list += 2 * 8;
<a name="l02714"></a>02714 
<a name="l02715"></a>02715       the_cu = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l02716"></a>02716                                <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a>);
<a name="l02717"></a>02717       the_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l02718"></a>02718       the_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a> = <a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a>;
<a name="l02719"></a>02719       the_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a> = <a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>;
<a name="l02720"></a>02720       the_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a> = <a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a>;
<a name="l02721"></a>02721       the_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a> = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l02722"></a>02722                                         <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__quick__data.html">dwarf2_per_cu_quick_data</a>);
<a name="l02723"></a>02723       the_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a> = <a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a>;
<a name="l02724"></a>02724       dwarf2_per_objfile-&gt;all_comp_units[base_offset + i / 2] = the_cu;
<a name="l02725"></a>02725     }
<a name="l02726"></a>02726 }
<a name="l02727"></a>02727 
<a name="l02728"></a>02728 <span class="comment">/* Read the CU list from the mapped index, and use it to create all</span>
<a name="l02729"></a>02729 <span class="comment">   the CU objects for this objfile.  */</span>
<a name="l02730"></a>02730 
<a name="l02731"></a>02731 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02732"></a><a class="code" href="dwarf2read_8c.html#a1f315973951bb92e3508cb396904b174">02732</a> <a class="code" href="dwarf2read_8c.html#a1f315973951bb92e3508cb396904b174">create_cus_from_index</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l02733"></a>02733                        <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *cu_list, <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> cu_list_elements,
<a name="l02734"></a>02734                        <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *dwz_list, <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> dwz_elements)
<a name="l02735"></a>02735 {
<a name="l02736"></a>02736   <span class="keyword">struct </span><a class="code" href="structdwz__file.html">dwz_file</a> *dwz;
<a name="l02737"></a>02737 
<a name="l02738"></a>02738   dwarf2_per_objfile-&gt;n_comp_units = (cu_list_elements + dwz_elements) / 2;
<a name="l02739"></a>02739   dwarf2_per_objfile-&gt;all_comp_units
<a name="l02740"></a>02740     = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l02741"></a>02741                      dwarf2_per_objfile-&gt;n_comp_units
<a name="l02742"></a>02742                      * sizeof (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *));
<a name="l02743"></a>02743 
<a name="l02744"></a>02744   <a class="code" href="dwarf2read_8c.html#a1166f65d8a9b165ad803249504b3269b">create_cus_from_index_list</a> (objfile, cu_list, cu_list_elements,
<a name="l02745"></a>02745                               &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ac4a5ed6e3f9908d638032ba24040a0b9">info</a>, 0, 0);
<a name="l02746"></a>02746 
<a name="l02747"></a>02747   <span class="keywordflow">if</span> (dwz_elements == 0)
<a name="l02748"></a>02748     <span class="keywordflow">return</span>;
<a name="l02749"></a>02749 
<a name="l02750"></a>02750   dwz = <a class="code" href="dwarf2read_8c.html#a926306809098933a820cfda81b19864c">dwarf2_get_dwz_file</a> ();
<a name="l02751"></a>02751   <a class="code" href="dwarf2read_8c.html#a1166f65d8a9b165ad803249504b3269b">create_cus_from_index_list</a> (objfile, dwz_list, dwz_elements, &amp;dwz-&gt;<a class="code" href="structdwz__file.html#a2c4f25245be0e458f196af80a990969c">info</a>, 1,
<a name="l02752"></a>02752                               cu_list_elements / 2);
<a name="l02753"></a>02753 }
<a name="l02754"></a>02754 
<a name="l02755"></a>02755 <span class="comment">/* Create the signatured type hash table from the index.  */</span>
<a name="l02756"></a>02756 
<a name="l02757"></a>02757 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02758"></a><a class="code" href="dwarf2read_8c.html#acf38606882b2ef50dc10290df23cc41f">02758</a> <a class="code" href="dwarf2read_8c.html#acf38606882b2ef50dc10290df23cc41f">create_signatured_type_table_from_index</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l02759"></a>02759                                          <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section,
<a name="l02760"></a>02760                                          <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *bytes,
<a name="l02761"></a>02761                                          <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> elements)
<a name="l02762"></a>02762 {
<a name="l02763"></a>02763   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> i;
<a name="l02764"></a>02764   htab_t sig_types_hash;
<a name="l02765"></a>02765 
<a name="l02766"></a>02766   dwarf2_per_objfile-&gt;n_type_units = elements / 3;
<a name="l02767"></a>02767   dwarf2_per_objfile-&gt;all_type_units
<a name="l02768"></a>02768     = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (dwarf2_per_objfile-&gt;n_type_units
<a name="l02769"></a>02769                * sizeof (<span class="keyword">struct</span> <a class="code" href="structsignatured__type.html">signatured_type</a> *));
<a name="l02770"></a>02770 
<a name="l02771"></a>02771   sig_types_hash = <a class="code" href="dwarf2read_8c.html#ad578387bf4a7a34a17bed7e05e8d4427">allocate_signatured_type_table</a> (objfile);
<a name="l02772"></a>02772 
<a name="l02773"></a>02773   <span class="keywordflow">for</span> (i = 0; i &lt; elements; i += 3)
<a name="l02774"></a>02774     {
<a name="l02775"></a>02775       <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type;
<a name="l02776"></a>02776       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <a class="code" href="structsignatured__type.html#ab152a3e1f687ff6464b369502ce745a9">type_offset_in_tu</a>, <a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a>;
<a name="l02777"></a>02777       <span class="keywordtype">void</span> **slot;
<a name="l02778"></a>02778 
<a name="l02779"></a>02779       <a class="code" href="gdb__assert_8h.html#a624909d860d72ccf64cd9a5896bd5faf">gdb_static_assert</a> (<span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a>) &gt;= 8);
<a name="l02780"></a>02780       offset = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (bytes, 8, BFD_ENDIAN_LITTLE);
<a name="l02781"></a>02781       type_offset_in_tu = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (bytes + 8, 8,
<a name="l02782"></a>02782                                                     BFD_ENDIAN_LITTLE);
<a name="l02783"></a>02783       signature = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (bytes + 16, 8, BFD_ENDIAN_LITTLE);
<a name="l02784"></a>02784       bytes += 3 * 8;
<a name="l02785"></a>02785 
<a name="l02786"></a>02786       sig_type = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l02787"></a>02787                                  <span class="keyword">struct</span> <a class="code" href="structsignatured__type.html">signatured_type</a>);
<a name="l02788"></a>02788       sig_type-&gt;<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a> = <a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a>;
<a name="l02789"></a>02789       sig_type-&gt;<a class="code" href="structsignatured__type.html#ab152a3e1f687ff6464b369502ce745a9">type_offset_in_tu</a>.<a class="code" href="structcu__offset.html#a19224b0dc5f0bc49babd2b7701a8d63e">cu_off</a> = <a class="code" href="structsignatured__type.html#ab152a3e1f687ff6464b369502ce745a9">type_offset_in_tu</a>;
<a name="l02790"></a>02790       sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a> = 1;
<a name="l02791"></a>02791       sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a> = section;
<a name="l02792"></a>02792       sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l02793"></a>02793       sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a> = objfile;
<a name="l02794"></a>02794       sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>
<a name="l02795"></a>02795         = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l02796"></a>02796                           <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__quick__data.html">dwarf2_per_cu_quick_data</a>);
<a name="l02797"></a>02797 
<a name="l02798"></a>02798       slot = htab_find_slot (sig_types_hash, sig_type, INSERT);
<a name="l02799"></a>02799       *slot = sig_type;
<a name="l02800"></a>02800 
<a name="l02801"></a>02801       dwarf2_per_objfile-&gt;all_type_units[i / 3] = sig_type;
<a name="l02802"></a>02802     }
<a name="l02803"></a>02803 
<a name="l02804"></a>02804   dwarf2_per_objfile-&gt;signatured_types = sig_types_hash;
<a name="l02805"></a>02805 }
<a name="l02806"></a>02806 
<a name="l02807"></a>02807 <span class="comment">/* Read the address map data from the mapped index, and use it to</span>
<a name="l02808"></a>02808 <span class="comment">   populate the objfile&#39;s psymtabs_addrmap.  */</span>
<a name="l02809"></a>02809 
<a name="l02810"></a>02810 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02811"></a><a class="code" href="dwarf2read_8c.html#aec2e369e69be4134a81a27114fa98a4a">02811</a> <a class="code" href="dwarf2read_8c.html#aec2e369e69be4134a81a27114fa98a4a">create_addrmap_from_index</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>, <span class="keyword">struct</span> <a class="code" href="structmapped__index.html">mapped_index</a> *index)
<a name="l02812"></a>02812 {
<a name="l02813"></a>02813   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *iter, *end;
<a name="l02814"></a>02814   <span class="keyword">struct </span>obstack temp_obstack;
<a name="l02815"></a>02815   <span class="keyword">struct </span><a class="code" href="structaddrmap.html">addrmap</a> *mutable_map;
<a name="l02816"></a>02816   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l02817"></a>02817   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> baseaddr;
<a name="l02818"></a>02818 
<a name="l02819"></a>02819   obstack_init (&amp;temp_obstack);
<a name="l02820"></a>02820   cleanup = <a class="code" href="utils_8c.html#a8aa2f0be9d477ee015e9e9bac43c005d">make_cleanup_obstack_free</a> (&amp;temp_obstack);
<a name="l02821"></a>02821   mutable_map = <a class="code" href="addrmap_8c.html#ab00d989f53b8349b4f52a3431bdd0977">addrmap_create_mutable</a> (&amp;temp_obstack);
<a name="l02822"></a>02822 
<a name="l02823"></a>02823   iter = index-&gt;<a class="code" href="structmapped__index.html#a2de47f34aaf83fd1677f34ae9c405bdc">address_table</a>;
<a name="l02824"></a>02824   end = iter + index-&gt;<a class="code" href="structmapped__index.html#a6715a56da889a4b7d94ede0d14c1b8ba">address_table_size</a>;
<a name="l02825"></a>02825 
<a name="l02826"></a>02826   baseaddr = <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>, <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l02827"></a>02827 
<a name="l02828"></a>02828   <span class="keywordflow">while</span> (iter &lt; end)
<a name="l02829"></a>02829     {
<a name="l02830"></a>02830       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> hi, lo, cu_index;
<a name="l02831"></a>02831       lo = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (iter, 8, BFD_ENDIAN_LITTLE);
<a name="l02832"></a>02832       iter += 8;
<a name="l02833"></a>02833       hi = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (iter, 8, BFD_ENDIAN_LITTLE);
<a name="l02834"></a>02834       iter += 8;
<a name="l02835"></a>02835       cu_index = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (iter, 4, BFD_ENDIAN_LITTLE);
<a name="l02836"></a>02836       iter += 4;
<a name="l02837"></a>02837 
<a name="l02838"></a>02838       <span class="keywordflow">if</span> (lo &gt; hi)
<a name="l02839"></a>02839         {
<a name="l02840"></a>02840           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l02841"></a>02841                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;.gdb_index address table has invalid range (%s - %s)&quot;</span>),
<a name="l02842"></a>02842                      <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (lo), <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (hi));
<a name="l02843"></a>02843           <span class="keywordflow">continue</span>;
<a name="l02844"></a>02844         }
<a name="l02845"></a>02845 
<a name="l02846"></a>02846       <span class="keywordflow">if</span> (cu_index &gt;= dwarf2_per_objfile-&gt;n_comp_units)
<a name="l02847"></a>02847         {
<a name="l02848"></a>02848           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l02849"></a>02849                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;.gdb_index address table has invalid CU number %u&quot;</span>),
<a name="l02850"></a>02850                      (<span class="keywordtype">unsigned</span>) cu_index);
<a name="l02851"></a>02851           <span class="keywordflow">continue</span>;
<a name="l02852"></a>02852         }
<a name="l02853"></a>02853 
<a name="l02854"></a>02854       <a class="code" href="addrmap_8c.html#ad0decf9c15214a17313c8c9d9828205c">addrmap_set_empty</a> (mutable_map, lo + baseaddr, hi + baseaddr - 1,
<a name="l02855"></a>02855                          <a class="code" href="dwarf2read_8c.html#a966b4a69ea94ca30717c495126d870c8">dw2_get_cu</a> (cu_index));
<a name="l02856"></a>02856     }
<a name="l02857"></a>02857 
<a name="l02858"></a>02858   objfile-&gt;<a class="code" href="structobjfile.html#ae7c792f2cd4efcff86d84d7bd3e15b26">psymtabs_addrmap</a> = <a class="code" href="addrmap_8c.html#ab106965712b64408f5de3d01fb2676b5">addrmap_create_fixed</a> (mutable_map,
<a name="l02859"></a>02859                                                     &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>);
<a name="l02860"></a>02860   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l02861"></a>02861 }
<a name="l02862"></a>02862 
<a name="l02863"></a>02863 <span class="comment">/* The hash function for strings in the mapped index.  This is the same as</span>
<a name="l02864"></a>02864 <span class="comment">   SYMBOL_HASH_NEXT, but we keep a separate copy to maintain control over the</span>
<a name="l02865"></a>02865 <span class="comment">   implementation.  This is necessary because the hash function is tied to the</span>
<a name="l02866"></a>02866 <span class="comment">   format of the mapped index file.  The hash values do not have to match with</span>
<a name="l02867"></a>02867 <span class="comment">   SYMBOL_HASH_NEXT.</span>
<a name="l02868"></a>02868 <span class="comment">   </span>
<a name="l02869"></a>02869 <span class="comment">   Use INT_MAX for INDEX_VERSION if you generate the current index format.  */</span>
<a name="l02870"></a>02870 
<a name="l02871"></a>02871 <span class="keyword">static</span> hashval_t
<a name="l02872"></a><a class="code" href="dwarf2read_8c.html#afe7f6f3e89a71fc6de454dbdbc4dd7a2">02872</a> <a class="code" href="dwarf2read_8c.html#afe7f6f3e89a71fc6de454dbdbc4dd7a2">mapped_index_string_hash</a> (<span class="keywordtype">int</span> index_version, <span class="keyword">const</span> <span class="keywordtype">void</span> *p)
<a name="l02873"></a>02873 {
<a name="l02874"></a>02874   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *str = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) p;
<a name="l02875"></a>02875   hashval_t r = 0;
<a name="l02876"></a>02876   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c;
<a name="l02877"></a>02877 
<a name="l02878"></a>02878   <span class="keywordflow">while</span> ((c = *str++) != 0)
<a name="l02879"></a>02879     {
<a name="l02880"></a>02880       <span class="keywordflow">if</span> (index_version &gt;= 5)
<a name="l02881"></a>02881         c = tolower (c);
<a name="l02882"></a>02882       r = r * 67 + c - 113;
<a name="l02883"></a>02883     }
<a name="l02884"></a>02884 
<a name="l02885"></a>02885   <span class="keywordflow">return</span> r;
<a name="l02886"></a>02886 }
<a name="l02887"></a>02887 
<a name="l02888"></a>02888 <span class="comment">/* Find a slot in the mapped index INDEX for the object named NAME.</span>
<a name="l02889"></a>02889 <span class="comment">   If NAME is found, set *VEC_OUT to point to the CU vector in the</span>
<a name="l02890"></a>02890 <span class="comment">   constant pool and return 1.  If NAME cannot be found, return 0.  */</span>
<a name="l02891"></a>02891 
<a name="l02892"></a>02892 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02893"></a><a class="code" href="dwarf2read_8c.html#a592430575621b753fa041371038bff99">02893</a> <a class="code" href="dwarf2read_8c.html#a592430575621b753fa041371038bff99">find_slot_in_mapped_hash</a> (<span class="keyword">struct</span> <a class="code" href="structmapped__index.html">mapped_index</a> *index, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>,
<a name="l02894"></a>02894                           <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> **vec_out)
<a name="l02895"></a>02895 {
<a name="l02896"></a>02896   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, 0);
<a name="l02897"></a>02897   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> <a class="code" href="bcache_8c.html#a680b4550cc69a0827af4a7169fe3c372">hash</a>;
<a name="l02898"></a>02898   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> slot, step;
<a name="l02899"></a>02899   <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*cmp) (<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l02900"></a>02900 
<a name="l02901"></a>02901   <span class="keywordflow">if</span> (<a class="code" href="language_8c.html#acd2505a014a95629da9c836f8914fc79">current_language</a>-&gt;<a class="code" href="structlanguage__defn.html#a1395b7eb05a09e5798dc29257f30810a">la_language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l02902"></a>02902       || <a class="code" href="language_8c.html#acd2505a014a95629da9c836f8914fc79">current_language</a>-&gt;<a class="code" href="structlanguage__defn.html#a1395b7eb05a09e5798dc29257f30810a">la_language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>
<a name="l02903"></a>02903       || <a class="code" href="language_8c.html#acd2505a014a95629da9c836f8914fc79">current_language</a>-&gt;<a class="code" href="structlanguage__defn.html#a1395b7eb05a09e5798dc29257f30810a">la_language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>)
<a name="l02904"></a>02904     {
<a name="l02905"></a>02905       <span class="comment">/* NAME is already canonical.  Drop any qualifiers as .gdb_index does</span>
<a name="l02906"></a>02906 <span class="comment">         not contain any.  */</span>
<a name="l02907"></a>02907       <span class="keyword">const</span> <span class="keywordtype">char</span> *paren = <a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (name, <span class="charliteral">&#39;(&#39;</span>);
<a name="l02908"></a>02908 
<a name="l02909"></a>02909       <span class="keywordflow">if</span> (paren)
<a name="l02910"></a>02910         {
<a name="l02911"></a>02911           <span class="keywordtype">char</span> *dup;
<a name="l02912"></a>02912 
<a name="l02913"></a>02913           dup = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (paren - name + 1);
<a name="l02914"></a>02914           <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (dup, name, paren - name);
<a name="l02915"></a>02915           dup[paren - <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>] = 0;
<a name="l02916"></a>02916 
<a name="l02917"></a>02917           <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, dup);
<a name="l02918"></a>02918           name = dup;
<a name="l02919"></a>02919         }
<a name="l02920"></a>02920     }
<a name="l02921"></a>02921 
<a name="l02922"></a>02922   <span class="comment">/* Index version 4 did not support case insensitive searches.  But the</span>
<a name="l02923"></a>02923 <span class="comment">     indices for case insensitive languages are built in lowercase, therefore</span>
<a name="l02924"></a>02924 <span class="comment">     simulate our NAME being searched is also lowercased.  */</span>
<a name="l02925"></a>02925   hash = <a class="code" href="dwarf2read_8c.html#afe7f6f3e89a71fc6de454dbdbc4dd7a2">mapped_index_string_hash</a> ((index-&gt;<a class="code" href="structmapped__index.html#a6204ce2b69334c8d243357d524858ccd">version</a> == 4
<a name="l02926"></a>02926                                     &amp;&amp; <a class="code" href="language_8h.html#ad102f9e1a41cf77a0045e37883dd2940">case_sensitivity</a> == <a class="code" href="language_8h.html#ad102f9e1a41cf77a0045e37883dd2940aeafdb3f995ad73c5c877655272018479">case_sensitive_off</a>
<a name="l02927"></a>02927                                     ? 5 : index-&gt;<a class="code" href="structmapped__index.html#a6204ce2b69334c8d243357d524858ccd">version</a>),
<a name="l02928"></a>02928                                    name);
<a name="l02929"></a>02929 
<a name="l02930"></a>02930   slot = hash &amp; (index-&gt;<a class="code" href="structmapped__index.html#a3e01c3306b6fd1f53604a4f0856013f3">symbol_table_slots</a> - 1);
<a name="l02931"></a>02931   step = ((hash * 17) &amp; (index-&gt;<a class="code" href="structmapped__index.html#a3e01c3306b6fd1f53604a4f0856013f3">symbol_table_slots</a> - 1)) | 1;
<a name="l02932"></a>02932   cmp = (<a class="code" href="language_8h.html#ad102f9e1a41cf77a0045e37883dd2940">case_sensitivity</a> == <a class="code" href="language_8h.html#ad102f9e1a41cf77a0045e37883dd2940a236ce0a37504b1c7b4f94f8236707e36">case_sensitive_on</a> ? strcmp : strcasecmp);
<a name="l02933"></a>02933 
<a name="l02934"></a>02934   <span class="keywordflow">for</span> (;;)
<a name="l02935"></a>02935     {
<a name="l02936"></a>02936       <span class="comment">/* Convert a slot number to an offset into the table.  */</span>
<a name="l02937"></a>02937       <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> i = 2 * slot;
<a name="l02938"></a>02938       <span class="keyword">const</span> <span class="keywordtype">char</span> *str;
<a name="l02939"></a>02939       <span class="keywordflow">if</span> (index-&gt;<a class="code" href="structmapped__index.html#af7415bd86bc9cfb1ba447c40762e5045">symbol_table</a>[i] == 0 &amp;&amp; index-&gt;<a class="code" href="structmapped__index.html#af7415bd86bc9cfb1ba447c40762e5045">symbol_table</a>[i + 1] == 0)
<a name="l02940"></a>02940         {
<a name="l02941"></a>02941           <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l02942"></a>02942           <span class="keywordflow">return</span> 0;
<a name="l02943"></a>02943         }
<a name="l02944"></a>02944 
<a name="l02945"></a>02945       str = index-&gt;<a class="code" href="structmapped__index.html#a3f51d3222825ba2465d4c73f2d364cc1">constant_pool</a> + <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (index-&gt;<a class="code" href="structmapped__index.html#af7415bd86bc9cfb1ba447c40762e5045">symbol_table</a>[i]);
<a name="l02946"></a>02946       <span class="keywordflow">if</span> (!cmp (name, str))
<a name="l02947"></a>02947         {
<a name="l02948"></a>02948           *vec_out = (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> *) (index-&gt;<a class="code" href="structmapped__index.html#a3f51d3222825ba2465d4c73f2d364cc1">constant_pool</a>
<a name="l02949"></a>02949                                       + <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (index-&gt;<a class="code" href="structmapped__index.html#af7415bd86bc9cfb1ba447c40762e5045">symbol_table</a>[i + 1]));
<a name="l02950"></a>02950           <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l02951"></a>02951           <span class="keywordflow">return</span> 1;
<a name="l02952"></a>02952         }
<a name="l02953"></a>02953 
<a name="l02954"></a>02954       slot = (slot + step) &amp; (index-&gt;<a class="code" href="structmapped__index.html#a3e01c3306b6fd1f53604a4f0856013f3">symbol_table_slots</a> - 1);
<a name="l02955"></a>02955     }
<a name="l02956"></a>02956 }
<a name="l02957"></a>02957 
<a name="l02958"></a>02958 <span class="comment">/* A helper function that reads the .gdb_index from SECTION and fills</span>
<a name="l02959"></a>02959 <span class="comment">   in MAP.  FILENAME is the name of the file containing the section;</span>
<a name="l02960"></a>02960 <span class="comment">   it is used for error reporting.  DEPRECATED_OK is nonzero if it is</span>
<a name="l02961"></a>02961 <span class="comment">   ok to use deprecated sections.</span>
<a name="l02962"></a>02962 <span class="comment"></span>
<a name="l02963"></a>02963 <span class="comment">   CU_LIST, CU_LIST_ELEMENTS, TYPES_LIST, and TYPES_LIST_ELEMENTS are</span>
<a name="l02964"></a>02964 <span class="comment">   out parameters that are filled in with information about the CU and</span>
<a name="l02965"></a>02965 <span class="comment">   TU lists in the section.</span>
<a name="l02966"></a>02966 <span class="comment"></span>
<a name="l02967"></a>02967 <span class="comment">   Returns 1 if all went well, 0 otherwise.  */</span>
<a name="l02968"></a>02968 
<a name="l02969"></a>02969 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02970"></a><a class="code" href="dwarf2read_8c.html#a64b011dfc1495ffd4500ba4aa1444790">02970</a> <a class="code" href="dwarf2read_8c.html#a64b011dfc1495ffd4500ba4aa1444790">read_index_from_section</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l02971"></a>02971                          <span class="keyword">const</span> <span class="keywordtype">char</span> *filename,
<a name="l02972"></a>02972                          <span class="keywordtype">int</span> deprecated_ok,
<a name="l02973"></a>02973                          <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section,
<a name="l02974"></a>02974                          <span class="keyword">struct</span> <a class="code" href="structmapped__index.html">mapped_index</a> *map,
<a name="l02975"></a>02975                          <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **cu_list,
<a name="l02976"></a>02976                          <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> *cu_list_elements,
<a name="l02977"></a>02977                          <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **types_list,
<a name="l02978"></a>02978                          <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> *types_list_elements)
<a name="l02979"></a>02979 {
<a name="l02980"></a>02980   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *addr;
<a name="l02981"></a>02981   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> <a class="code" href="version_8h.html#ac91cf940e10a61b95cabc3258a06186b">version</a>;
<a name="l02982"></a>02982   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> *metadata;
<a name="l02983"></a>02983   <span class="keywordtype">int</span> i;
<a name="l02984"></a>02984 
<a name="l02985"></a>02985   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ac9e788fb165d736559a5a07bd4cd8dc1">dwarf2_section_empty_p</a> (section))
<a name="l02986"></a>02986     <span class="keywordflow">return</span> 0;
<a name="l02987"></a>02987 
<a name="l02988"></a>02988   <span class="comment">/* Older elfutils strip versions could keep the section in the main</span>
<a name="l02989"></a>02989 <span class="comment">     executable while splitting it for the separate debug info file.  */</span>
<a name="l02990"></a>02990   <span class="keywordflow">if</span> ((<a class="code" href="dwarf2read_8c.html#aad01030b562c064777477b1d4b85df65">get_section_flags</a> (section) &amp; SEC_HAS_CONTENTS) == 0)
<a name="l02991"></a>02991     <span class="keywordflow">return</span> 0;
<a name="l02992"></a>02992 
<a name="l02993"></a>02993   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, section);
<a name="l02994"></a>02994 
<a name="l02995"></a>02995   addr = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>;
<a name="l02996"></a>02996   <span class="comment">/* Version check.  */</span>
<a name="l02997"></a>02997   version = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (*(<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> *) addr);
<a name="l02998"></a>02998   <span class="comment">/* Versions earlier than 3 emitted every copy of a psymbol.  This</span>
<a name="l02999"></a>02999 <span class="comment">     causes the index to behave very poorly for certain requests.  Version 3</span>
<a name="l03000"></a>03000 <span class="comment">     contained incomplete addrmap.  So, it seems better to just ignore such</span>
<a name="l03001"></a>03001 <span class="comment">     indices.  */</span>
<a name="l03002"></a>03002   <span class="keywordflow">if</span> (version &lt; 4)
<a name="l03003"></a>03003     {
<a name="l03004"></a>03004       <span class="keyword">static</span> <span class="keywordtype">int</span> warning_printed = 0;
<a name="l03005"></a>03005       <span class="keywordflow">if</span> (!warning_printed)
<a name="l03006"></a>03006         {
<a name="l03007"></a>03007           <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Skipping obsolete .gdb_index section in %s.&quot;</span>),
<a name="l03008"></a>03008                    filename);
<a name="l03009"></a>03009           warning_printed = 1;
<a name="l03010"></a>03010         }
<a name="l03011"></a>03011       <span class="keywordflow">return</span> 0;
<a name="l03012"></a>03012     }
<a name="l03013"></a>03013   <span class="comment">/* Index version 4 uses a different hash function than index version</span>
<a name="l03014"></a>03014 <span class="comment">     5 and later.</span>
<a name="l03015"></a>03015 <span class="comment"></span>
<a name="l03016"></a>03016 <span class="comment">     Versions earlier than 6 did not emit psymbols for inlined</span>
<a name="l03017"></a>03017 <span class="comment">     functions.  Using these files will cause GDB not to be able to</span>
<a name="l03018"></a>03018 <span class="comment">     set breakpoints on inlined functions by name, so we ignore these</span>
<a name="l03019"></a>03019 <span class="comment">     indices unless the user has done</span>
<a name="l03020"></a>03020 <span class="comment">     &quot;set use-deprecated-index-sections on&quot;.  */</span>
<a name="l03021"></a>03021   <span class="keywordflow">if</span> (version &lt; 6 &amp;&amp; !deprecated_ok)
<a name="l03022"></a>03022     {
<a name="l03023"></a>03023       <span class="keyword">static</span> <span class="keywordtype">int</span> warning_printed = 0;
<a name="l03024"></a>03024       <span class="keywordflow">if</span> (!warning_printed)
<a name="l03025"></a>03025         {
<a name="l03026"></a>03026           <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l03027"></a>03027 <span class="stringliteral">Skipping deprecated .gdb_index section in %s.\n\</span>
<a name="l03028"></a>03028 <span class="stringliteral">Do \&quot;set use-deprecated-index-sections on\&quot; before the file is read\n\</span>
<a name="l03029"></a>03029 <span class="stringliteral">to use the section anyway.&quot;</span>),
<a name="l03030"></a>03030                    filename);
<a name="l03031"></a>03031           warning_printed = 1;
<a name="l03032"></a>03032         }
<a name="l03033"></a>03033       <span class="keywordflow">return</span> 0;
<a name="l03034"></a>03034     }
<a name="l03035"></a>03035   <span class="comment">/* Version 7 indices generated by gold refer to the CU for a symbol instead</span>
<a name="l03036"></a>03036 <span class="comment">     of the TU (for symbols coming from TUs).  It&#39;s just a performance bug, and</span>
<a name="l03037"></a>03037 <span class="comment">     we can&#39;t distinguish gdb-generated indices from gold-generated ones, so</span>
<a name="l03038"></a>03038 <span class="comment">     nothing to do here.  */</span>
<a name="l03039"></a>03039 
<a name="l03040"></a>03040   <span class="comment">/* Indexes with higher version than the one supported by GDB may be no</span>
<a name="l03041"></a>03041 <span class="comment">     longer backward compatible.  */</span>
<a name="l03042"></a>03042   <span class="keywordflow">if</span> (version &gt; 8)
<a name="l03043"></a>03043     <span class="keywordflow">return</span> 0;
<a name="l03044"></a>03044 
<a name="l03045"></a>03045   map-&gt;<a class="code" href="structmapped__index.html#a6204ce2b69334c8d243357d524858ccd">version</a> = <a class="code" href="version_8h.html#ac91cf940e10a61b95cabc3258a06186b">version</a>;
<a name="l03046"></a>03046   map-&gt;<a class="code" href="structmapped__index.html#a11c53f2d9e8ca2194ea0f0a7fd18d8f5">total_size</a> = section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>;
<a name="l03047"></a>03047 
<a name="l03048"></a>03048   metadata = (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> *) (addr + <span class="keyword">sizeof</span> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>));
<a name="l03049"></a>03049 
<a name="l03050"></a>03050   i = 0;
<a name="l03051"></a>03051   *cu_list = addr + <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (metadata[i]);
<a name="l03052"></a>03052   *cu_list_elements = ((<a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (metadata[i + 1]) - <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (metadata[i]))
<a name="l03053"></a>03053                        / 8);
<a name="l03054"></a>03054   ++i;
<a name="l03055"></a>03055 
<a name="l03056"></a>03056   *types_list = addr + <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (metadata[i]);
<a name="l03057"></a>03057   *types_list_elements = ((<a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (metadata[i + 1])
<a name="l03058"></a>03058                            - <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (metadata[i]))
<a name="l03059"></a>03059                           / 8);
<a name="l03060"></a>03060   ++i;
<a name="l03061"></a>03061 
<a name="l03062"></a>03062   map-&gt;<a class="code" href="structmapped__index.html#a2de47f34aaf83fd1677f34ae9c405bdc">address_table</a> = addr + <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (metadata[i]);
<a name="l03063"></a>03063   map-&gt;<a class="code" href="structmapped__index.html#a6715a56da889a4b7d94ede0d14c1b8ba">address_table_size</a> = (<a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (metadata[i + 1])
<a name="l03064"></a>03064                              - <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (metadata[i]));
<a name="l03065"></a>03065   ++i;
<a name="l03066"></a>03066 
<a name="l03067"></a>03067   map-&gt;<a class="code" href="structmapped__index.html#af7415bd86bc9cfb1ba447c40762e5045">symbol_table</a> = (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> *) (addr + MAYBE_SWAP (metadata[i]));
<a name="l03068"></a>03068   map-&gt;<a class="code" href="structmapped__index.html#a3e01c3306b6fd1f53604a4f0856013f3">symbol_table_slots</a> = ((<a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (metadata[i + 1])
<a name="l03069"></a>03069                               - <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (metadata[i]))
<a name="l03070"></a>03070                              / (2 * <span class="keyword">sizeof</span> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>)));
<a name="l03071"></a>03071   ++i;
<a name="l03072"></a>03072 
<a name="l03073"></a>03073   map-&gt;<a class="code" href="structmapped__index.html#a3f51d3222825ba2465d4c73f2d364cc1">constant_pool</a> = (<span class="keywordtype">char</span> *) (addr + MAYBE_SWAP (metadata[i]));
<a name="l03074"></a>03074 
<a name="l03075"></a>03075   <span class="keywordflow">return</span> 1;
<a name="l03076"></a>03076 }
<a name="l03077"></a>03077 
<a name="l03078"></a>03078 
<a name="l03079"></a>03079 <span class="comment">/* Read the index file.  If everything went ok, initialize the &quot;quick&quot;</span>
<a name="l03080"></a>03080 <span class="comment">   elements of all the CUs and return 1.  Otherwise, return 0.  */</span>
<a name="l03081"></a>03081 
<a name="l03082"></a>03082 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03083"></a><a class="code" href="dwarf2read_8c.html#a15e772cd63f184bb5f565a3aa47f378b">03083</a> <a class="code" href="dwarf2read_8c.html#a15e772cd63f184bb5f565a3aa47f378b">dwarf2_read_index</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>)
<a name="l03084"></a>03084 {
<a name="l03085"></a>03085   <span class="keyword">struct </span><a class="code" href="structmapped__index.html">mapped_index</a> local_map, *map;
<a name="l03086"></a>03086   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *cu_list, *types_list, *dwz_list = NULL;
<a name="l03087"></a>03087   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> cu_list_elements, types_list_elements, dwz_list_elements = 0;
<a name="l03088"></a>03088   <span class="keyword">struct </span><a class="code" href="structdwz__file.html">dwz_file</a> *dwz;
<a name="l03089"></a>03089 
<a name="l03090"></a>03090   <span class="keywordflow">if</span> (!<a class="code" href="dwarf2read_8c.html#a64b011dfc1495ffd4500ba4aa1444790">read_index_from_section</a> (objfile, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile),
<a name="l03091"></a>03091                                 <a class="code" href="dwarf2read_8c.html#a0a43a194f055955e1de1eb7be957096f">use_deprecated_index_sections</a>,
<a name="l03092"></a>03092                                 &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a7dccae22ec3934fe5491ca6782d21cdd">gdb_index</a>, &amp;local_map,
<a name="l03093"></a>03093                                 &amp;cu_list, &amp;cu_list_elements,
<a name="l03094"></a>03094                                 &amp;types_list, &amp;types_list_elements))
<a name="l03095"></a>03095     <span class="keywordflow">return</span> 0;
<a name="l03096"></a>03096 
<a name="l03097"></a>03097   <span class="comment">/* Don&#39;t use the index if it&#39;s empty.  */</span>
<a name="l03098"></a>03098   <span class="keywordflow">if</span> (local_map.<a class="code" href="structmapped__index.html#a3e01c3306b6fd1f53604a4f0856013f3">symbol_table_slots</a> == 0)
<a name="l03099"></a>03099     <span class="keywordflow">return</span> 0;
<a name="l03100"></a>03100 
<a name="l03101"></a>03101   <span class="comment">/* If there is a .dwz file, read it so we can get its CU list as</span>
<a name="l03102"></a>03102 <span class="comment">     well.  */</span>
<a name="l03103"></a>03103   dwz = <a class="code" href="dwarf2read_8c.html#a926306809098933a820cfda81b19864c">dwarf2_get_dwz_file</a> ();
<a name="l03104"></a>03104   <span class="keywordflow">if</span> (dwz != NULL)
<a name="l03105"></a>03105     {
<a name="l03106"></a>03106       <span class="keyword">struct </span><a class="code" href="structmapped__index.html">mapped_index</a> dwz_map;
<a name="l03107"></a>03107       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *dwz_types_ignore;
<a name="l03108"></a>03108       <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> dwz_types_elements_ignore;
<a name="l03109"></a>03109 
<a name="l03110"></a>03110       <span class="keywordflow">if</span> (!<a class="code" href="dwarf2read_8c.html#a64b011dfc1495ffd4500ba4aa1444790">read_index_from_section</a> (objfile, bfd_get_filename (dwz-&gt;<a class="code" href="structdwz__file.html#a9fc9bf241da902e55d1a4ddbaa8141eb">dwz_bfd</a>),
<a name="l03111"></a>03111                                     1,
<a name="l03112"></a>03112                                     &amp;dwz-&gt;<a class="code" href="structdwz__file.html#acc28fb02f48f40d5a1b7b454b138474d">gdb_index</a>, &amp;dwz_map,
<a name="l03113"></a>03113                                     &amp;dwz_list, &amp;dwz_list_elements,
<a name="l03114"></a>03114                                     &amp;dwz_types_ignore,
<a name="l03115"></a>03115                                     &amp;dwz_types_elements_ignore))
<a name="l03116"></a>03116         {
<a name="l03117"></a>03117           <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;could not read &#39;.gdb_index&#39; section from %s; skipping&quot;</span>),
<a name="l03118"></a>03118                    bfd_get_filename (dwz-&gt;<a class="code" href="structdwz__file.html#a9fc9bf241da902e55d1a4ddbaa8141eb">dwz_bfd</a>));
<a name="l03119"></a>03119           <span class="keywordflow">return</span> 0;
<a name="l03120"></a>03120         }
<a name="l03121"></a>03121     }
<a name="l03122"></a>03122 
<a name="l03123"></a>03123   <a class="code" href="dwarf2read_8c.html#a1f315973951bb92e3508cb396904b174">create_cus_from_index</a> (objfile, cu_list, cu_list_elements, dwz_list,
<a name="l03124"></a>03124                          dwz_list_elements);
<a name="l03125"></a>03125 
<a name="l03126"></a>03126   <span class="keywordflow">if</span> (types_list_elements)
<a name="l03127"></a>03127     {
<a name="l03128"></a>03128       <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section;
<a name="l03129"></a>03129 
<a name="l03130"></a>03130       <span class="comment">/* We can only handle a single .debug_types when we have an</span>
<a name="l03131"></a>03131 <span class="comment">         index.  */</span>
<a name="l03132"></a>03132       <span class="keywordflow">if</span> (<a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>, dwarf2_per_objfile-&gt;types) != 1)
<a name="l03133"></a>03133         <span class="keywordflow">return</span> 0;
<a name="l03134"></a>03134 
<a name="l03135"></a>03135       section = <a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>,
<a name="l03136"></a>03136                            dwarf2_per_objfile-&gt;types, 0);
<a name="l03137"></a>03137 
<a name="l03138"></a>03138       <a class="code" href="dwarf2read_8c.html#acf38606882b2ef50dc10290df23cc41f">create_signatured_type_table_from_index</a> (objfile, section, types_list,
<a name="l03139"></a>03139                                                types_list_elements);
<a name="l03140"></a>03140     }
<a name="l03141"></a>03141 
<a name="l03142"></a>03142   <a class="code" href="dwarf2read_8c.html#aec2e369e69be4134a81a27114fa98a4a">create_addrmap_from_index</a> (objfile, &amp;local_map);
<a name="l03143"></a>03143 
<a name="l03144"></a>03144   map = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, sizeof (<span class="keyword">struct</span> <a class="code" href="structmapped__index.html">mapped_index</a>));
<a name="l03145"></a>03145   *map = local_map;
<a name="l03146"></a>03146 
<a name="l03147"></a>03147   dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a1e58a614b6e77589e24dac14dfdc62e5">index_table</a> = map;
<a name="l03148"></a>03148   dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a> = 1;
<a name="l03149"></a>03149   dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#aeb96e928b0cd54363e459b10effcb0b3">quick_file_names_table</a> =
<a name="l03150"></a>03150     <a class="code" href="dwarf2read_8c.html#a3e3ee9237abb0774920bf5fa4edaf782">create_quick_file_names_table</a> (dwarf2_per_objfile-&gt;n_comp_units);
<a name="l03151"></a>03151 
<a name="l03152"></a>03152   <span class="keywordflow">return</span> 1;
<a name="l03153"></a>03153 }
<a name="l03154"></a>03154 
<a name="l03155"></a>03155 <span class="comment">/* A helper for the &quot;quick&quot; functions which sets the global</span>
<a name="l03156"></a>03156 <span class="comment">   dwarf2_per_objfile according to OBJFILE.  */</span>
<a name="l03157"></a>03157 
<a name="l03158"></a>03158 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03159"></a><a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">03159</a> <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>)
<a name="l03160"></a>03160 {
<a name="l03161"></a>03161   dwarf2_per_objfile = objfile_data (objfile, <a class="code" href="dwarf2read_8c.html#a9fcfdd623d890b4c3b4ac0ba42e7df4b">dwarf2_objfile_data_key</a>);
<a name="l03162"></a>03162   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (dwarf2_per_objfile);
<a name="l03163"></a>03163 }
<a name="l03164"></a>03164 
<a name="l03165"></a>03165 <span class="comment">/* die_reader_func for dw2_get_file_names.  */</span>
<a name="l03166"></a>03166 
<a name="l03167"></a>03167 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03168"></a><a class="code" href="dwarf2read_8c.html#a0a377f2bbdc8e2a42ef3ae6dae57817d">03168</a> <a class="code" href="dwarf2read_8c.html#a0a377f2bbdc8e2a42ef3ae6dae57817d">dw2_get_file_names_reader</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l03169"></a>03169                            <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l03170"></a>03170                            <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *comp_unit_die,
<a name="l03171"></a>03171                            <span class="keywordtype">int</span> has_children,
<a name="l03172"></a>03172                            <span class="keywordtype">void</span> *data)
<a name="l03173"></a>03173 {
<a name="l03174"></a>03174   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l03175"></a>03175   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;  
<a name="l03176"></a>03176   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a> = dwarf2_per_objfile-&gt;objfile;
<a name="l03177"></a>03177   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *lh_cu;
<a name="l03178"></a>03178   <span class="keyword">struct </span><a class="code" href="structline__header.html">line_header</a> *lh;
<a name="l03179"></a>03179   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l03180"></a>03180   <span class="keywordtype">int</span> i;
<a name="l03181"></a>03181   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, *comp_dir;
<a name="l03182"></a>03182   <span class="keywordtype">void</span> **slot;
<a name="l03183"></a>03183   <span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a> *qfn;
<a name="l03184"></a>03184   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structline__offset.html">line_offset</a>;
<a name="l03185"></a>03185 
<a name="l03186"></a>03186   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (! this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l03187"></a>03187 
<a name="l03188"></a>03188   <span class="comment">/* Our callers never want to match partial units -- instead they</span>
<a name="l03189"></a>03189 <span class="comment">     will match the enclosing full CU.  */</span>
<a name="l03190"></a>03190   <span class="keywordflow">if</span> (comp_unit_die-&gt;tag == DW_TAG_partial_unit)
<a name="l03191"></a>03191     {
<a name="l03192"></a>03192       this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a3d2576797835daa34fa6ed75a441cf7e">no_file_data</a> = 1;
<a name="l03193"></a>03193       <span class="keywordflow">return</span>;
<a name="l03194"></a>03194     }
<a name="l03195"></a>03195 
<a name="l03196"></a>03196   lh_cu = this_cu;
<a name="l03197"></a>03197   lh = NULL;
<a name="l03198"></a>03198   slot = NULL;
<a name="l03199"></a>03199   line_offset = 0;
<a name="l03200"></a>03200 
<a name="l03201"></a>03201   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (comp_unit_die, DW_AT_stmt_list, cu);
<a name="l03202"></a>03202   <span class="keywordflow">if</span> (attr)
<a name="l03203"></a>03203     {
<a name="l03204"></a>03204       <span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a> find_entry;
<a name="l03205"></a>03205 
<a name="l03206"></a>03206       line_offset = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l03207"></a>03207 
<a name="l03208"></a>03208       <span class="comment">/* We may have already read in this line header (TU line header sharing).</span>
<a name="l03209"></a>03209 <span class="comment">         If we have we&#39;re done.  */</span>
<a name="l03210"></a>03210       find_entry.<a class="code" href="structquick__file__names.html#af9682d33b88a5e77ecb95e9034ea9710">hash</a>.<a class="code" href="structstmt__list__hash.html#a2372dc58554f328becda07e68d6528a8">dwo_unit</a> = cu-&gt;dwo_unit;
<a name="l03211"></a>03211       find_entry.<a class="code" href="structquick__file__names.html#af9682d33b88a5e77ecb95e9034ea9710">hash</a>.<a class="code" href="structstmt__list__hash.html#a9ee63f1d951d00448dd2b14430aba5fe">line_offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = line_offset;
<a name="l03212"></a>03212       slot = htab_find_slot (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#aeb96e928b0cd54363e459b10effcb0b3">quick_file_names_table</a>,
<a name="l03213"></a>03213                              &amp;find_entry, INSERT);
<a name="l03214"></a>03214       <span class="keywordflow">if</span> (*slot != NULL)
<a name="l03215"></a>03215         {
<a name="l03216"></a>03216           lh_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#add9a664dbc27341d6bfc03bca8bdcbe0">file_names</a> = *slot;
<a name="l03217"></a>03217           <span class="keywordflow">return</span>;
<a name="l03218"></a>03218         }
<a name="l03219"></a>03219 
<a name="l03220"></a>03220       lh = <a class="code" href="dwarf2read_8c.html#af87c579a0baccecf09b54fc18af2dea5">dwarf_decode_line_header</a> (line_offset, cu);
<a name="l03221"></a>03221     }
<a name="l03222"></a>03222   <span class="keywordflow">if</span> (lh == NULL)
<a name="l03223"></a>03223     {
<a name="l03224"></a>03224       lh_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a3d2576797835daa34fa6ed75a441cf7e">no_file_data</a> = 1;
<a name="l03225"></a>03225       <span class="keywordflow">return</span>;
<a name="l03226"></a>03226     }
<a name="l03227"></a>03227 
<a name="l03228"></a>03228   qfn = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, sizeof (*qfn));
<a name="l03229"></a>03229   qfn-&gt;<a class="code" href="structquick__file__names.html#af9682d33b88a5e77ecb95e9034ea9710">hash</a>.<a class="code" href="structstmt__list__hash.html#a2372dc58554f328becda07e68d6528a8">dwo_unit</a> = cu-&gt;dwo_unit;
<a name="l03230"></a>03230   qfn-&gt;<a class="code" href="structquick__file__names.html#af9682d33b88a5e77ecb95e9034ea9710">hash</a>.<a class="code" href="structstmt__list__hash.html#a9ee63f1d951d00448dd2b14430aba5fe">line_offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = line_offset;
<a name="l03231"></a>03231   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (slot != NULL);
<a name="l03232"></a>03232   *slot = qfn;
<a name="l03233"></a>03233 
<a name="l03234"></a>03234   <a class="code" href="dwarf2read_8c.html#a4c82b37187098b652b568563271a15a3">find_file_and_directory</a> (comp_unit_die, cu, &amp;name, &amp;comp_dir);
<a name="l03235"></a>03235 
<a name="l03236"></a>03236   qfn-&gt;<a class="code" href="structquick__file__names.html#a534816d8c99e4e4053ca440d06c34010">num_file_names</a> = lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a>;
<a name="l03237"></a>03237   qfn-&gt;<a class="code" href="structquick__file__names.html#a8c6be91b4164dc5d7265602d0c77e6e7">file_names</a> = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l03238"></a>03238                                    lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a> * sizeof (<span class="keywordtype">char</span> *));
<a name="l03239"></a>03239   <span class="keywordflow">for</span> (i = 0; i &lt; lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a>; ++i)
<a name="l03240"></a>03240     qfn-&gt;<a class="code" href="structquick__file__names.html#a8c6be91b4164dc5d7265602d0c77e6e7">file_names</a>[i] = <a class="code" href="dwarf2read_8c.html#a10e5b152dbd3c862a6832d5028b0d1d1">file_full_name</a> (i + 1, lh, comp_dir);
<a name="l03241"></a>03241   qfn-&gt;<a class="code" href="structquick__file__names.html#a14640cf5475332cd70384422e22a8ef5">real_names</a> = NULL;
<a name="l03242"></a>03242 
<a name="l03243"></a>03243   <a class="code" href="dwarf2read_8c.html#a2b16344b24303ef21765208ef32dfe7a">free_line_header</a> (lh);
<a name="l03244"></a>03244 
<a name="l03245"></a>03245   lh_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#add9a664dbc27341d6bfc03bca8bdcbe0">file_names</a> = qfn;
<a name="l03246"></a>03246 }
<a name="l03247"></a>03247 
<a name="l03248"></a>03248 <span class="comment">/* A helper for the &quot;quick&quot; functions which attempts to read the line</span>
<a name="l03249"></a>03249 <span class="comment">   table for THIS_CU.  */</span>
<a name="l03250"></a>03250 
<a name="l03251"></a>03251 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a> *
<a name="l03252"></a><a class="code" href="dwarf2read_8c.html#a3ce00d16c1dfb75f5512312207d7f12c">03252</a> <a class="code" href="dwarf2read_8c.html#a3ce00d16c1dfb75f5512312207d7f12c">dw2_get_file_names</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu)
<a name="l03253"></a>03253 {
<a name="l03254"></a>03254   <span class="comment">/* This should never be called for TUs.  */</span>
<a name="l03255"></a>03255   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (! this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l03256"></a>03256   <span class="comment">/* Nor type unit groups.  */</span>
<a name="l03257"></a>03257   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (! <a class="code" href="dwarf2read_8c.html#aa278b6364c9b859353eeea535d81221e">IS_TYPE_UNIT_GROUP</a> (this_cu));
<a name="l03258"></a>03258 
<a name="l03259"></a>03259   <span class="keywordflow">if</span> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#add9a664dbc27341d6bfc03bca8bdcbe0">file_names</a> != NULL)
<a name="l03260"></a>03260     <span class="keywordflow">return</span> this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#add9a664dbc27341d6bfc03bca8bdcbe0">file_names</a>;
<a name="l03261"></a>03261   <span class="comment">/* If we know there is no line data, no point in looking again.  */</span>
<a name="l03262"></a>03262   <span class="keywordflow">if</span> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a3d2576797835daa34fa6ed75a441cf7e">no_file_data</a>)
<a name="l03263"></a>03263     <span class="keywordflow">return</span> NULL;
<a name="l03264"></a>03264 
<a name="l03265"></a>03265   <a class="code" href="dwarf2read_8c.html#aa76270ede1b4c1ab21e449e875a982bf">init_cutu_and_read_dies_simple</a> (this_cu, <a class="code" href="dwarf2read_8c.html#a0a377f2bbdc8e2a42ef3ae6dae57817d">dw2_get_file_names_reader</a>, NULL);
<a name="l03266"></a>03266 
<a name="l03267"></a>03267   <span class="keywordflow">if</span> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a3d2576797835daa34fa6ed75a441cf7e">no_file_data</a>)
<a name="l03268"></a>03268     <span class="keywordflow">return</span> NULL;
<a name="l03269"></a>03269   <span class="keywordflow">return</span> this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#add9a664dbc27341d6bfc03bca8bdcbe0">file_names</a>;
<a name="l03270"></a>03270 }
<a name="l03271"></a>03271 
<a name="l03272"></a>03272 <span class="comment">/* A helper for the &quot;quick&quot; functions which computes and caches the</span>
<a name="l03273"></a>03273 <span class="comment">   real path for a given file name from the line table.  */</span>
<a name="l03274"></a>03274 
<a name="l03275"></a>03275 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l03276"></a><a class="code" href="dwarf2read_8c.html#a1e35e1228b00cd44826671c3f8111482">03276</a> <a class="code" href="dwarf2read_8c.html#a1e35e1228b00cd44826671c3f8111482">dw2_get_real_path</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l03277"></a>03277                    <span class="keyword">struct</span> <a class="code" href="structquick__file__names.html">quick_file_names</a> *qfn, <span class="keywordtype">int</span> index)
<a name="l03278"></a>03278 {
<a name="l03279"></a>03279   <span class="keywordflow">if</span> (qfn-&gt;<a class="code" href="structquick__file__names.html#a14640cf5475332cd70384422e22a8ef5">real_names</a> == NULL)
<a name="l03280"></a>03280     qfn-&gt;<a class="code" href="structquick__file__names.html#a14640cf5475332cd70384422e22a8ef5">real_names</a> = <a class="code" href="gdb__obstack_8h.html#ade84d21769345a1fad382ba39d83eb90">OBSTACK_CALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l03281"></a>03281                                       qfn-&gt;<a class="code" href="structquick__file__names.html#a534816d8c99e4e4053ca440d06c34010">num_file_names</a>, sizeof (<span class="keywordtype">char</span> *));
<a name="l03282"></a>03282 
<a name="l03283"></a>03283   <span class="keywordflow">if</span> (qfn-&gt;<a class="code" href="structquick__file__names.html#a14640cf5475332cd70384422e22a8ef5">real_names</a>[index] == NULL)
<a name="l03284"></a>03284     qfn-&gt;<a class="code" href="structquick__file__names.html#a14640cf5475332cd70384422e22a8ef5">real_names</a>[index] = <a class="code" href="utils_8c.html#a38e450f9b68243416d35f57e37e23e3e">gdb_realpath</a> (qfn-&gt;<a class="code" href="structquick__file__names.html#a8c6be91b4164dc5d7265602d0c77e6e7">file_names</a>[index]);
<a name="l03285"></a>03285 
<a name="l03286"></a>03286   <span class="keywordflow">return</span> qfn-&gt;<a class="code" href="structquick__file__names.html#a14640cf5475332cd70384422e22a8ef5">real_names</a>[index];
<a name="l03287"></a>03287 }
<a name="l03288"></a>03288 
<a name="l03289"></a>03289 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *
<a name="l03290"></a><a class="code" href="dwarf2read_8c.html#adad79a4699a13cee353ff4a7f8933808">03290</a> <a class="code" href="dwarf2read_8c.html#adad79a4699a13cee353ff4a7f8933808">dw2_find_last_source_symtab</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>)
<a name="l03291"></a>03291 {
<a name="l03292"></a>03292   <span class="keywordtype">int</span> index;
<a name="l03293"></a>03293 
<a name="l03294"></a>03294   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (objfile);
<a name="l03295"></a>03295   index = dwarf2_per_objfile-&gt;n_comp_units - 1;
<a name="l03296"></a>03296   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a6acd40df616a0b5d96cbb15ab3690346">dw2_instantiate_symtab</a> (<a class="code" href="dwarf2read_8c.html#a966b4a69ea94ca30717c495126d870c8">dw2_get_cu</a> (index));
<a name="l03297"></a>03297 }
<a name="l03298"></a>03298 
<a name="l03299"></a>03299 <span class="comment">/* Traversal function for dw2_forget_cached_source_info.  */</span>
<a name="l03300"></a>03300 
<a name="l03301"></a>03301 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03302"></a><a class="code" href="dwarf2read_8c.html#ac437612e0e10d643c2fa9007f14ae926">03302</a> <a class="code" href="dwarf2read_8c.html#ac437612e0e10d643c2fa9007f14ae926">dw2_free_cached_file_names</a> (<span class="keywordtype">void</span> **slot, <span class="keywordtype">void</span> *info)
<a name="l03303"></a>03303 {
<a name="l03304"></a>03304   <span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a> *file_data = (<span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a> *) *slot;
<a name="l03305"></a>03305 
<a name="l03306"></a>03306   <span class="keywordflow">if</span> (file_data-&gt;<a class="code" href="structquick__file__names.html#a14640cf5475332cd70384422e22a8ef5">real_names</a>)
<a name="l03307"></a>03307     {
<a name="l03308"></a>03308       <span class="keywordtype">int</span> i;
<a name="l03309"></a>03309 
<a name="l03310"></a>03310       <span class="keywordflow">for</span> (i = 0; i &lt; file_data-&gt;<a class="code" href="structquick__file__names.html#a534816d8c99e4e4053ca440d06c34010">num_file_names</a>; ++i)
<a name="l03311"></a>03311         {
<a name="l03312"></a>03312           <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> ((<span class="keywordtype">void</span>*) file_data-&gt;<a class="code" href="structquick__file__names.html#a14640cf5475332cd70384422e22a8ef5">real_names</a>[i]);
<a name="l03313"></a>03313           file_data-&gt;<a class="code" href="structquick__file__names.html#a14640cf5475332cd70384422e22a8ef5">real_names</a>[i] = NULL;
<a name="l03314"></a>03314         }
<a name="l03315"></a>03315     }
<a name="l03316"></a>03316 
<a name="l03317"></a>03317   <span class="keywordflow">return</span> 1;
<a name="l03318"></a>03318 }
<a name="l03319"></a>03319 
<a name="l03320"></a>03320 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03321"></a><a class="code" href="dwarf2read_8c.html#af5935cfb14249660550e8de0a02f317a">03321</a> <a class="code" href="dwarf2read_8c.html#af5935cfb14249660550e8de0a02f317a">dw2_forget_cached_source_info</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>)
<a name="l03322"></a>03322 {
<a name="l03323"></a>03323   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (objfile);
<a name="l03324"></a>03324 
<a name="l03325"></a>03325   htab_traverse_noresize (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#aeb96e928b0cd54363e459b10effcb0b3">quick_file_names_table</a>,
<a name="l03326"></a>03326                           <a class="code" href="dwarf2read_8c.html#ac437612e0e10d643c2fa9007f14ae926">dw2_free_cached_file_names</a>, NULL);
<a name="l03327"></a>03327 }
<a name="l03328"></a>03328 
<a name="l03329"></a>03329 <span class="comment">/* Helper function for dw2_map_symtabs_matching_filename that expands</span>
<a name="l03330"></a>03330 <span class="comment">   the symtabs and calls the iterator.  */</span>
<a name="l03331"></a>03331 
<a name="l03332"></a>03332 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03333"></a><a class="code" href="dwarf2read_8c.html#ade93bd4fa306327b2cdfaa758b204578">03333</a> <a class="code" href="dwarf2read_8c.html#ade93bd4fa306327b2cdfaa758b204578">dw2_map_expand_apply</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l03334"></a>03334                       <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu,
<a name="l03335"></a>03335                       <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *real_path,
<a name="l03336"></a>03336                       <span class="keywordtype">int</span> (*callback) (<span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *, <span class="keywordtype">void</span> *),
<a name="l03337"></a>03337                       <span class="keywordtype">void</span> *data)
<a name="l03338"></a>03338 {
<a name="l03339"></a>03339   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *last_made = objfile-&gt;<a class="code" href="structobjfile.html#a7de941af61199f5f18580235feec7e8c">symtabs</a>;
<a name="l03340"></a>03340 
<a name="l03341"></a>03341   <span class="comment">/* Don&#39;t visit already-expanded CUs.  */</span>
<a name="l03342"></a>03342   <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a>)
<a name="l03343"></a>03343     <span class="keywordflow">return</span> 0;
<a name="l03344"></a>03344 
<a name="l03345"></a>03345   <span class="comment">/* This may expand more than one symtab, and we want to iterate over</span>
<a name="l03346"></a>03346 <span class="comment">     all of them.  */</span>
<a name="l03347"></a>03347   <a class="code" href="dwarf2read_8c.html#a6acd40df616a0b5d96cbb15ab3690346">dw2_instantiate_symtab</a> (per_cu);
<a name="l03348"></a>03348 
<a name="l03349"></a>03349   <span class="keywordflow">return</span> <a class="code" href="symtab_8c.html#a6aef2b41973621c0425ce4f6a39e5a99">iterate_over_some_symtabs</a> (name, real_path, callback, data,
<a name="l03350"></a>03350                                     objfile-&gt;<a class="code" href="structobjfile.html#a7de941af61199f5f18580235feec7e8c">symtabs</a>, last_made);
<a name="l03351"></a>03351 }
<a name="l03352"></a>03352 
<a name="l03353"></a>03353 <span class="comment">/* Implementation of the map_symtabs_matching_filename method.  */</span>
<a name="l03354"></a>03354 
<a name="l03355"></a>03355 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03356"></a><a class="code" href="dwarf2read_8c.html#a2da073778d348b5641f4306737a76d97">03356</a> <a class="code" href="dwarf2read_8c.html#a2da073778d348b5641f4306737a76d97">dw2_map_symtabs_matching_filename</a> (<span class="keyword">struct</span> objfile *objfile, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l03357"></a>03357                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *real_path,
<a name="l03358"></a>03358                                    <span class="keywordtype">int</span> (*callback) (<span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *, <span class="keywordtype">void</span> *),
<a name="l03359"></a>03359                                    <span class="keywordtype">void</span> *data)
<a name="l03360"></a>03360 {
<a name="l03361"></a>03361   <span class="keywordtype">int</span> i;
<a name="l03362"></a>03362   <span class="keyword">const</span> <span class="keywordtype">char</span> *name_basename = lbasename (name);
<a name="l03363"></a>03363 
<a name="l03364"></a>03364   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (objfile);
<a name="l03365"></a>03365 
<a name="l03366"></a>03366   <span class="comment">/* The rule is CUs specify all the files, including those used by</span>
<a name="l03367"></a>03367 <span class="comment">     any TU, so there&#39;s no need to scan TUs here.  */</span>
<a name="l03368"></a>03368 
<a name="l03369"></a>03369   <span class="keywordflow">for</span> (i = 0; i &lt; dwarf2_per_objfile-&gt;n_comp_units; ++i)
<a name="l03370"></a>03370     {
<a name="l03371"></a>03371       <span class="keywordtype">int</span> j;
<a name="l03372"></a>03372       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = <a class="code" href="dwarf2read_8c.html#a03d87974d046042a783bdf70e2f48083">dw2_get_primary_cu</a> (i);
<a name="l03373"></a>03373       <span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a> *file_data;
<a name="l03374"></a>03374 
<a name="l03375"></a>03375       <span class="comment">/* We only need to look at symtabs not already expanded.  */</span>
<a name="l03376"></a>03376       <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a>)
<a name="l03377"></a>03377         <span class="keywordflow">continue</span>;
<a name="l03378"></a>03378 
<a name="l03379"></a>03379       file_data = <a class="code" href="dwarf2read_8c.html#a3ce00d16c1dfb75f5512312207d7f12c">dw2_get_file_names</a> (per_cu);
<a name="l03380"></a>03380       <span class="keywordflow">if</span> (file_data == NULL)
<a name="l03381"></a>03381         <span class="keywordflow">continue</span>;
<a name="l03382"></a>03382 
<a name="l03383"></a>03383       <span class="keywordflow">for</span> (j = 0; j &lt; file_data-&gt;<a class="code" href="structquick__file__names.html#a534816d8c99e4e4053ca440d06c34010">num_file_names</a>; ++j)
<a name="l03384"></a>03384         {
<a name="l03385"></a>03385           <span class="keyword">const</span> <span class="keywordtype">char</span> *this_name = file_data-&gt;<a class="code" href="structquick__file__names.html#a8c6be91b4164dc5d7265602d0c77e6e7">file_names</a>[j];
<a name="l03386"></a>03386           <span class="keyword">const</span> <span class="keywordtype">char</span> *this_real_name;
<a name="l03387"></a>03387 
<a name="l03388"></a>03388           <span class="keywordflow">if</span> (<a class="code" href="symtab_8c.html#a1316e7f1ae237bfce71774ffee89fa1f">compare_filenames_for_search</a> (this_name, name))
<a name="l03389"></a>03389             {
<a name="l03390"></a>03390               <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ade93bd4fa306327b2cdfaa758b204578">dw2_map_expand_apply</a> (objfile, per_cu, name, real_path,
<a name="l03391"></a>03391                                         callback, data))
<a name="l03392"></a>03392                 <span class="keywordflow">return</span> 1;
<a name="l03393"></a>03393               <span class="keywordflow">continue</span>;
<a name="l03394"></a>03394             }
<a name="l03395"></a>03395 
<a name="l03396"></a>03396           <span class="comment">/* Before we invoke realpath, which can get expensive when many</span>
<a name="l03397"></a>03397 <span class="comment">             files are involved, do a quick comparison of the basenames.  */</span>
<a name="l03398"></a>03398           <span class="keywordflow">if</span> (! <a class="code" href="symtab_8c.html#af9a62a674b6767f0981034f1ceb7756a">basenames_may_differ</a>
<a name="l03399"></a>03399               &amp;&amp; FILENAME_CMP (lbasename (this_name), name_basename) != 0)
<a name="l03400"></a>03400             <span class="keywordflow">continue</span>;
<a name="l03401"></a>03401 
<a name="l03402"></a>03402           this_real_name = <a class="code" href="dwarf2read_8c.html#a1e35e1228b00cd44826671c3f8111482">dw2_get_real_path</a> (objfile, file_data, j);
<a name="l03403"></a>03403           <span class="keywordflow">if</span> (<a class="code" href="symtab_8c.html#a1316e7f1ae237bfce71774ffee89fa1f">compare_filenames_for_search</a> (this_real_name, name))
<a name="l03404"></a>03404             {
<a name="l03405"></a>03405               <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ade93bd4fa306327b2cdfaa758b204578">dw2_map_expand_apply</a> (objfile, per_cu, name, real_path,
<a name="l03406"></a>03406                                         callback, data))
<a name="l03407"></a>03407                 <span class="keywordflow">return</span> 1;
<a name="l03408"></a>03408               <span class="keywordflow">continue</span>;
<a name="l03409"></a>03409             }
<a name="l03410"></a>03410 
<a name="l03411"></a>03411           <span class="keywordflow">if</span> (real_path != NULL)
<a name="l03412"></a>03412             {
<a name="l03413"></a>03413               <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (IS_ABSOLUTE_PATH (real_path));
<a name="l03414"></a>03414               <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (IS_ABSOLUTE_PATH (name));
<a name="l03415"></a>03415               <span class="keywordflow">if</span> (this_real_name != NULL
<a name="l03416"></a>03416                   &amp;&amp; FILENAME_CMP (real_path, this_real_name) == 0)
<a name="l03417"></a>03417                 {
<a name="l03418"></a>03418                   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ade93bd4fa306327b2cdfaa758b204578">dw2_map_expand_apply</a> (objfile, per_cu, name, real_path,
<a name="l03419"></a>03419                                             callback, data))
<a name="l03420"></a>03420                     <span class="keywordflow">return</span> 1;
<a name="l03421"></a>03421                   <span class="keywordflow">continue</span>;
<a name="l03422"></a>03422                 }
<a name="l03423"></a>03423             }
<a name="l03424"></a>03424         }
<a name="l03425"></a>03425     }
<a name="l03426"></a>03426 
<a name="l03427"></a>03427   <span class="keywordflow">return</span> 0;
<a name="l03428"></a>03428 }
<a name="l03429"></a>03429 
<a name="l03430"></a>03430 <span class="comment">/* Struct used to manage iterating over all CUs looking for a symbol.  */</span>
<a name="l03431"></a>03431 
<a name="l03432"></a><a class="code" href="structdw2__symtab__iterator.html">03432</a> <span class="keyword">struct </span><a class="code" href="structdw2__symtab__iterator.html">dw2_symtab_iterator</a>
<a name="l03433"></a>03433 {
<a name="l03434"></a>03434   <span class="comment">/* The internalized form of .gdb_index.  */</span>
<a name="l03435"></a><a class="code" href="structdw2__symtab__iterator.html#a5aa9da09b78d0643240748a9666553e3">03435</a>   <span class="keyword">struct </span><a class="code" href="structmapped__index.html">mapped_index</a> *<a class="code" href="structdw2__symtab__iterator.html#a5aa9da09b78d0643240748a9666553e3">index</a>;
<a name="l03436"></a>03436   <span class="comment">/* If non-zero, only look for symbols that match BLOCK_INDEX.  */</span>
<a name="l03437"></a><a class="code" href="structdw2__symtab__iterator.html#aa94529190347a272443573d495b30ece">03437</a>   <span class="keywordtype">int</span> <a class="code" href="structdw2__symtab__iterator.html#aa94529190347a272443573d495b30ece">want_specific_block</a>;
<a name="l03438"></a>03438   <span class="comment">/* One of GLOBAL_BLOCK or STATIC_BLOCK.</span>
<a name="l03439"></a>03439 <span class="comment">     Unused if !WANT_SPECIFIC_BLOCK.  */</span>
<a name="l03440"></a><a class="code" href="structdw2__symtab__iterator.html#a2b617860dba8bdb0db8d93659b7d1913">03440</a>   <span class="keywordtype">int</span> <a class="code" href="structdw2__symtab__iterator.html#a2b617860dba8bdb0db8d93659b7d1913">block_index</a>;
<a name="l03441"></a>03441   <span class="comment">/* The kind of symbol we&#39;re looking for.  */</span>
<a name="l03442"></a><a class="code" href="structdw2__symtab__iterator.html#ad33899c3ce424a39e7e75833d7e00bbb">03442</a>   <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> <a class="code" href="structdw2__symtab__iterator.html#ad33899c3ce424a39e7e75833d7e00bbb">domain</a>;
<a name="l03443"></a>03443   <span class="comment">/* The list of CUs from the index entry of the symbol,</span>
<a name="l03444"></a>03444 <span class="comment">     or NULL if not found.  */</span>
<a name="l03445"></a><a class="code" href="structdw2__symtab__iterator.html#af7535b15a32ecd88d360b5fcdef7fe2c">03445</a>   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> *<a class="code" href="structdw2__symtab__iterator.html#af7535b15a32ecd88d360b5fcdef7fe2c">vec</a>;
<a name="l03446"></a>03446   <span class="comment">/* The next element in VEC to look at.  */</span>
<a name="l03447"></a><a class="code" href="structdw2__symtab__iterator.html#ad2eb76607a19ad13958180a52e0a0607">03447</a>   <span class="keywordtype">int</span> <a class="code" href="structdw2__symtab__iterator.html#ad2eb76607a19ad13958180a52e0a0607">next</a>;
<a name="l03448"></a>03448   <span class="comment">/* The number of elements in VEC, or zero if there is no match.  */</span>
<a name="l03449"></a><a class="code" href="structdw2__symtab__iterator.html#ae0f882534bff70ef45eeb6afe4e6f753">03449</a>   <span class="keywordtype">int</span> <a class="code" href="structdw2__symtab__iterator.html#ae0f882534bff70ef45eeb6afe4e6f753">length</a>;
<a name="l03450"></a>03450 };
<a name="l03451"></a>03451 
<a name="l03452"></a>03452 <span class="comment">/* Initialize the index symtab iterator ITER.</span>
<a name="l03453"></a>03453 <span class="comment">   If WANT_SPECIFIC_BLOCK is non-zero, only look for symbols</span>
<a name="l03454"></a>03454 <span class="comment">   in block BLOCK_INDEX.  Otherwise BLOCK_INDEX is ignored.  */</span>
<a name="l03455"></a>03455 
<a name="l03456"></a>03456 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03457"></a><a class="code" href="dwarf2read_8c.html#a28d998e6e3dbcfb7da8d018f423e7349">03457</a> <a class="code" href="dwarf2read_8c.html#a28d998e6e3dbcfb7da8d018f423e7349">dw2_symtab_iter_init</a> (<span class="keyword">struct</span> <a class="code" href="structdw2__symtab__iterator.html">dw2_symtab_iterator</a> *iter,
<a name="l03458"></a>03458                       <span class="keyword">struct</span> <a class="code" href="structmapped__index.html">mapped_index</a> *index,
<a name="l03459"></a>03459                       <span class="keywordtype">int</span> want_specific_block,
<a name="l03460"></a>03460                       <span class="keywordtype">int</span> block_index,
<a name="l03461"></a>03461                       <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> domain,
<a name="l03462"></a>03462                       <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l03463"></a>03463 {
<a name="l03464"></a>03464   iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#a5aa9da09b78d0643240748a9666553e3">index</a> = index;
<a name="l03465"></a>03465   iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#aa94529190347a272443573d495b30ece">want_specific_block</a> = want_specific_block;
<a name="l03466"></a>03466   iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#a2b617860dba8bdb0db8d93659b7d1913">block_index</a> = block_index;
<a name="l03467"></a>03467   iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#ad33899c3ce424a39e7e75833d7e00bbb">domain</a> = domain;
<a name="l03468"></a>03468   iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#ad2eb76607a19ad13958180a52e0a0607">next</a> = 0;
<a name="l03469"></a>03469 
<a name="l03470"></a>03470   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a592430575621b753fa041371038bff99">find_slot_in_mapped_hash</a> (index, name, &amp;iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#af7535b15a32ecd88d360b5fcdef7fe2c">vec</a>))
<a name="l03471"></a>03471     iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#ae0f882534bff70ef45eeb6afe4e6f753">length</a> = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (*iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#af7535b15a32ecd88d360b5fcdef7fe2c">vec</a>);
<a name="l03472"></a>03472   <span class="keywordflow">else</span>
<a name="l03473"></a>03473     {
<a name="l03474"></a>03474       iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#af7535b15a32ecd88d360b5fcdef7fe2c">vec</a> = NULL;
<a name="l03475"></a>03475       iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#ae0f882534bff70ef45eeb6afe4e6f753">length</a> = 0;
<a name="l03476"></a>03476     }
<a name="l03477"></a>03477 }
<a name="l03478"></a>03478 
<a name="l03479"></a>03479 <span class="comment">/* Return the next matching CU or NULL if there are no more.  */</span>
<a name="l03480"></a>03480 
<a name="l03481"></a>03481 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *
<a name="l03482"></a><a class="code" href="dwarf2read_8c.html#aa62ca7fdd647858537de0702070fca35">03482</a> <a class="code" href="dwarf2read_8c.html#aa62ca7fdd647858537de0702070fca35">dw2_symtab_iter_next</a> (<span class="keyword">struct</span> <a class="code" href="structdw2__symtab__iterator.html">dw2_symtab_iterator</a> *iter)
<a name="l03483"></a>03483 {
<a name="l03484"></a>03484   <span class="keywordflow">for</span> ( ; iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#ad2eb76607a19ad13958180a52e0a0607">next</a> &lt; iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#ae0f882534bff70ef45eeb6afe4e6f753">length</a>; ++iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#ad2eb76607a19ad13958180a52e0a0607">next</a>)
<a name="l03485"></a>03485     {
<a name="l03486"></a>03486       <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> cu_index_and_attrs =
<a name="l03487"></a>03487         <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#af7535b15a32ecd88d360b5fcdef7fe2c">vec</a>[iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#ad2eb76607a19ad13958180a52e0a0607">next</a> + 1]);
<a name="l03488"></a>03488       <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> cu_index = GDB_INDEX_CU_VALUE (cu_index_and_attrs);
<a name="l03489"></a>03489       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu;
<a name="l03490"></a>03490       <span class="keywordtype">int</span> want_static = iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#a2b617860dba8bdb0db8d93659b7d1913">block_index</a> != <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124a973ee91cbe4b0cee4eb7603252a29bec">GLOBAL_BLOCK</a>;
<a name="l03491"></a>03491       <span class="comment">/* This value is only valid for index versions &gt;= 7.  */</span>
<a name="l03492"></a>03492       <span class="keywordtype">int</span> is_static = GDB_INDEX_SYMBOL_STATIC_VALUE (cu_index_and_attrs);
<a name="l03493"></a>03493       gdb_index_symbol_kind <a class="code" href="dwarf2read_8c.html#a73bc3b8f484e295bdf4639f79613508f">symbol_kind</a> =
<a name="l03494"></a>03494         GDB_INDEX_SYMBOL_KIND_VALUE (cu_index_and_attrs);
<a name="l03495"></a>03495       <span class="comment">/* Only check the symbol attributes if they&#39;re present.</span>
<a name="l03496"></a>03496 <span class="comment">         Indices prior to version 7 don&#39;t record them,</span>
<a name="l03497"></a>03497 <span class="comment">         and indices &gt;= 7 may elide them for certain symbols</span>
<a name="l03498"></a>03498 <span class="comment">         (gold does this).  */</span>
<a name="l03499"></a>03499       <span class="keywordtype">int</span> attrs_valid =
<a name="l03500"></a>03500         (iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#a5aa9da09b78d0643240748a9666553e3">index</a>-&gt;<a class="code" href="structmapped__index.html#a6204ce2b69334c8d243357d524858ccd">version</a> &gt;= 7
<a name="l03501"></a>03501          &amp;&amp; symbol_kind != GDB_INDEX_SYMBOL_KIND_NONE);
<a name="l03502"></a>03502 
<a name="l03503"></a>03503       <span class="comment">/* Don&#39;t crash on bad data.  */</span>
<a name="l03504"></a>03504       <span class="keywordflow">if</span> (cu_index &gt;= (dwarf2_per_objfile-&gt;n_comp_units
<a name="l03505"></a>03505                        + dwarf2_per_objfile-&gt;n_type_units))
<a name="l03506"></a>03506         {
<a name="l03507"></a>03507           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l03508"></a>03508                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;.gdb_index entry has bad CU index&quot;</span>
<a name="l03509"></a>03509                        <span class="stringliteral">&quot; [in module %s]&quot;</span>),
<a name="l03510"></a>03510                      <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (dwarf2_per_objfile-&gt;objfile));
<a name="l03511"></a>03511           <span class="keywordflow">continue</span>;
<a name="l03512"></a>03512         }
<a name="l03513"></a>03513 
<a name="l03514"></a>03514       per_cu = <a class="code" href="dwarf2read_8c.html#a966b4a69ea94ca30717c495126d870c8">dw2_get_cu</a> (cu_index);
<a name="l03515"></a>03515 
<a name="l03516"></a>03516       <span class="comment">/* Skip if already read in.  */</span>
<a name="l03517"></a>03517       <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a>)
<a name="l03518"></a>03518         <span class="keywordflow">continue</span>;
<a name="l03519"></a>03519 
<a name="l03520"></a>03520       <span class="keywordflow">if</span> (attrs_valid
<a name="l03521"></a>03521           &amp;&amp; iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#aa94529190347a272443573d495b30ece">want_specific_block</a>
<a name="l03522"></a>03522           &amp;&amp; want_static != is_static)
<a name="l03523"></a>03523         <span class="keywordflow">continue</span>;
<a name="l03524"></a>03524 
<a name="l03525"></a>03525       <span class="comment">/* Only check the symbol&#39;s kind if it has one.  */</span>
<a name="l03526"></a>03526       <span class="keywordflow">if</span> (attrs_valid)
<a name="l03527"></a>03527         {
<a name="l03528"></a>03528           <span class="keywordflow">switch</span> (iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#ad33899c3ce424a39e7e75833d7e00bbb">domain</a>)
<a name="l03529"></a>03529             {
<a name="l03530"></a>03530             <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>:
<a name="l03531"></a>03531               <span class="keywordflow">if</span> (symbol_kind != GDB_INDEX_SYMBOL_KIND_VARIABLE
<a name="l03532"></a>03532                   &amp;&amp; symbol_kind != GDB_INDEX_SYMBOL_KIND_FUNCTION
<a name="l03533"></a>03533                   <span class="comment">/* Some types are also in VAR_DOMAIN.  */</span>
<a name="l03534"></a>03534                   &amp;&amp; symbol_kind != GDB_INDEX_SYMBOL_KIND_TYPE)
<a name="l03535"></a>03535                 <span class="keywordflow">continue</span>;
<a name="l03536"></a>03536               <span class="keywordflow">break</span>;
<a name="l03537"></a>03537             <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa1f05a16e681efd2e892974878c353f11">STRUCT_DOMAIN</a>:
<a name="l03538"></a>03538               <span class="keywordflow">if</span> (symbol_kind != GDB_INDEX_SYMBOL_KIND_TYPE)
<a name="l03539"></a>03539                 <span class="keywordflow">continue</span>;
<a name="l03540"></a>03540               <span class="keywordflow">break</span>;
<a name="l03541"></a>03541             <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa56127af42926055244b2318cbdbc8413">LABEL_DOMAIN</a>:
<a name="l03542"></a>03542               <span class="keywordflow">if</span> (symbol_kind != GDB_INDEX_SYMBOL_KIND_OTHER)
<a name="l03543"></a>03543                 <span class="keywordflow">continue</span>;
<a name="l03544"></a>03544               <span class="keywordflow">break</span>;
<a name="l03545"></a>03545             <span class="keywordflow">default</span>:
<a name="l03546"></a>03546               <span class="keywordflow">break</span>;
<a name="l03547"></a>03547             }
<a name="l03548"></a>03548         }
<a name="l03549"></a>03549 
<a name="l03550"></a>03550       ++iter-&gt;<a class="code" href="structdw2__symtab__iterator.html#ad2eb76607a19ad13958180a52e0a0607">next</a>;
<a name="l03551"></a>03551       <span class="keywordflow">return</span> per_cu;
<a name="l03552"></a>03552     }
<a name="l03553"></a>03553 
<a name="l03554"></a>03554   <span class="keywordflow">return</span> NULL;
<a name="l03555"></a>03555 }
<a name="l03556"></a>03556 
<a name="l03557"></a>03557 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *
<a name="l03558"></a><a class="code" href="dwarf2read_8c.html#a048d929b8c59528c1bff004daa51027e">03558</a> <a class="code" href="dwarf2read_8c.html#a048d929b8c59528c1bff004daa51027e">dw2_lookup_symbol</a> (<span class="keyword">struct</span> objfile *objfile, <span class="keywordtype">int</span> block_index,
<a name="l03559"></a>03559                    <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> domain)
<a name="l03560"></a>03560 {
<a name="l03561"></a>03561   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *stab_best = NULL;
<a name="l03562"></a>03562   <span class="keyword">struct </span><a class="code" href="structmapped__index.html">mapped_index</a> *index;
<a name="l03563"></a>03563 
<a name="l03564"></a>03564   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (objfile);
<a name="l03565"></a>03565 
<a name="l03566"></a>03566   index = dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a1e58a614b6e77589e24dac14dfdc62e5">index_table</a>;
<a name="l03567"></a>03567 
<a name="l03568"></a>03568   <span class="comment">/* index is NULL if OBJF_READNOW.  */</span>
<a name="l03569"></a>03569   <span class="keywordflow">if</span> (index)
<a name="l03570"></a>03570     {
<a name="l03571"></a>03571       <span class="keyword">struct </span><a class="code" href="structdw2__symtab__iterator.html">dw2_symtab_iterator</a> iter;
<a name="l03572"></a>03572       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu;
<a name="l03573"></a>03573 
<a name="l03574"></a>03574       <a class="code" href="dwarf2read_8c.html#a28d998e6e3dbcfb7da8d018f423e7349">dw2_symtab_iter_init</a> (&amp;iter, index, 1, block_index, domain, name);
<a name="l03575"></a>03575 
<a name="l03576"></a>03576       <span class="keywordflow">while</span> ((per_cu = <a class="code" href="dwarf2read_8c.html#aa62ca7fdd647858537de0702070fca35">dw2_symtab_iter_next</a> (&amp;iter)) != NULL)
<a name="l03577"></a>03577         {
<a name="l03578"></a>03578           <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym = NULL;
<a name="l03579"></a>03579           <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *stab = <a class="code" href="dwarf2read_8c.html#a6acd40df616a0b5d96cbb15ab3690346">dw2_instantiate_symtab</a> (per_cu);
<a name="l03580"></a>03580 
<a name="l03581"></a>03581           <span class="comment">/* Some caution must be observed with overloaded functions</span>
<a name="l03582"></a>03582 <span class="comment">             and methods, since the index will not contain any overload</span>
<a name="l03583"></a>03583 <span class="comment">             information (but NAME might contain it).  */</span>
<a name="l03584"></a>03584           <span class="keywordflow">if</span> (stab-&gt;<a class="code" href="structsymtab.html#ac7b1b53ffb88e931203f53942070bc7f">primary</a>)
<a name="l03585"></a>03585             {
<a name="l03586"></a>03586               <span class="keyword">struct </span><a class="code" href="structblockvector.html">blockvector</a> *bv = <a class="code" href="symtab_8h.html#a6cd84410d73680ff8006ac44b1b98a9c">BLOCKVECTOR</a> (stab);
<a name="l03587"></a>03587               <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a> = <a class="code" href="block_8h.html#a84c4a3aa7b6b4d9a127a1c018dd6a776">BLOCKVECTOR_BLOCK</a> (bv, block_index);
<a name="l03588"></a>03588 
<a name="l03589"></a>03589               sym = <a class="code" href="symtab_8c.html#a25f45a38ca9085f0fad46c8cd1394fda">lookup_block_symbol</a> (block, name, domain);
<a name="l03590"></a>03590             }
<a name="l03591"></a>03591 
<a name="l03592"></a>03592           <span class="keywordflow">if</span> (sym &amp;&amp; <a class="code" href="utils_8c.html#afe92387dbf8135978e7845a7dcf18003">strcmp_iw</a> (<a class="code" href="symtab_8h.html#a16e484ff2bd09d4f0400caf5e3f8c3eb">SYMBOL_SEARCH_NAME</a> (sym), name) == 0)
<a name="l03593"></a>03593             {
<a name="l03594"></a>03594               <span class="keywordflow">if</span> (!<a class="code" href="gdbtypes_8h.html#a69344b27f7781ba403f1843600ed386e">TYPE_IS_OPAQUE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym)))
<a name="l03595"></a>03595                 <span class="keywordflow">return</span> stab;
<a name="l03596"></a>03596 
<a name="l03597"></a>03597               stab_best = stab;
<a name="l03598"></a>03598             }
<a name="l03599"></a>03599 
<a name="l03600"></a>03600           <span class="comment">/* Keep looking through other CUs.  */</span>
<a name="l03601"></a>03601         }
<a name="l03602"></a>03602     }
<a name="l03603"></a>03603 
<a name="l03604"></a>03604   <span class="keywordflow">return</span> stab_best;
<a name="l03605"></a>03605 }
<a name="l03606"></a>03606 
<a name="l03607"></a>03607 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03608"></a><a class="code" href="dwarf2read_8c.html#ace21bb973130085dd3a90702586b92e2">03608</a> <a class="code" href="dwarf2read_8c.html#ace21bb973130085dd3a90702586b92e2">dw2_print_stats</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l03609"></a>03609 {
<a name="l03610"></a>03610   <span class="keywordtype">int</span> i, total, count;
<a name="l03611"></a>03611 
<a name="l03612"></a>03612   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (objfile);
<a name="l03613"></a>03613   total = dwarf2_per_objfile-&gt;n_comp_units + dwarf2_per_objfile-&gt;n_type_units;
<a name="l03614"></a>03614   count = 0;
<a name="l03615"></a>03615   <span class="keywordflow">for</span> (i = 0; i &lt; total; ++i)
<a name="l03616"></a>03616     {
<a name="l03617"></a>03617       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = <a class="code" href="dwarf2read_8c.html#a966b4a69ea94ca30717c495126d870c8">dw2_get_cu</a> (i);
<a name="l03618"></a>03618 
<a name="l03619"></a>03619       <span class="keywordflow">if</span> (!per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a>)
<a name="l03620"></a>03620         ++count;
<a name="l03621"></a>03621     }
<a name="l03622"></a>03622   <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;  Number of read CUs: %d\n&quot;</span>), total - count);
<a name="l03623"></a>03623   <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;  Number of unread CUs: %d\n&quot;</span>), count);
<a name="l03624"></a>03624 }
<a name="l03625"></a>03625 
<a name="l03626"></a>03626 <span class="comment">/* This dumps minimal information about the index.</span>
<a name="l03627"></a>03627 <span class="comment">   It is called via &quot;mt print objfiles&quot;.</span>
<a name="l03628"></a>03628 <span class="comment">   One use is to verify .gdb_index has been loaded by the</span>
<a name="l03629"></a>03629 <span class="comment">   gdb.dwarf2/gdb-index.exp testcase.  */</span>
<a name="l03630"></a>03630 
<a name="l03631"></a>03631 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03632"></a><a class="code" href="dwarf2read_8c.html#a29f62fb03ccada86ed4f777f1f6e60fe">03632</a> <a class="code" href="dwarf2read_8c.html#a29f62fb03ccada86ed4f777f1f6e60fe">dw2_dump</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l03633"></a>03633 {
<a name="l03634"></a>03634   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (objfile);
<a name="l03635"></a>03635   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a>);
<a name="l03636"></a>03636   <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;.gdb_index:&quot;</span>);
<a name="l03637"></a>03637   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a1e58a614b6e77589e24dac14dfdc62e5">index_table</a> != NULL)
<a name="l03638"></a>03638     {
<a name="l03639"></a>03639       <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot; version %d\n&quot;</span>,
<a name="l03640"></a>03640                        dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a1e58a614b6e77589e24dac14dfdc62e5">index_table</a>-&gt;<a class="code" href="structmapped__index.html#a6204ce2b69334c8d243357d524858ccd">version</a>);
<a name="l03641"></a>03641     }
<a name="l03642"></a>03642   <span class="keywordflow">else</span>
<a name="l03643"></a>03643     <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot; faked for \&quot;readnow\&quot;\n&quot;</span>);
<a name="l03644"></a>03644   <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03645"></a>03645 }
<a name="l03646"></a>03646 
<a name="l03647"></a>03647 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03648"></a><a class="code" href="dwarf2read_8c.html#aee004fae9da4c316785d39a89c27e1b1">03648</a> <a class="code" href="dwarf2read_8c.html#aee004fae9da4c316785d39a89c27e1b1">dw2_relocate</a> (<span class="keyword">struct</span> objfile *objfile,
<a name="l03649"></a>03649               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structsection__offsets.html">section_offsets</a> *new_offsets,
<a name="l03650"></a>03650               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structsection__offsets.html">section_offsets</a> *delta)
<a name="l03651"></a>03651 {
<a name="l03652"></a>03652   <span class="comment">/* There&#39;s nothing to relocate here.  */</span>
<a name="l03653"></a>03653 }
<a name="l03654"></a>03654 
<a name="l03655"></a>03655 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03656"></a><a class="code" href="dwarf2read_8c.html#a5eb403e02fc625690f53d7f07f7ec123">03656</a> <a class="code" href="dwarf2read_8c.html#a5eb403e02fc625690f53d7f07f7ec123">dw2_expand_symtabs_for_function</a> (<span class="keyword">struct</span> objfile *objfile,
<a name="l03657"></a>03657                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name)
<a name="l03658"></a>03658 {
<a name="l03659"></a>03659   <span class="keyword">struct </span><a class="code" href="structmapped__index.html">mapped_index</a> *index;
<a name="l03660"></a>03660 
<a name="l03661"></a>03661   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (objfile);
<a name="l03662"></a>03662 
<a name="l03663"></a>03663   index = dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a1e58a614b6e77589e24dac14dfdc62e5">index_table</a>;
<a name="l03664"></a>03664 
<a name="l03665"></a>03665   <span class="comment">/* index is NULL if OBJF_READNOW.  */</span>
<a name="l03666"></a>03666   <span class="keywordflow">if</span> (index)
<a name="l03667"></a>03667     {
<a name="l03668"></a>03668       <span class="keyword">struct </span><a class="code" href="structdw2__symtab__iterator.html">dw2_symtab_iterator</a> iter;
<a name="l03669"></a>03669       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu;
<a name="l03670"></a>03670 
<a name="l03671"></a>03671       <span class="comment">/* Note: It doesn&#39;t matter what we pass for block_index here.  */</span>
<a name="l03672"></a>03672       <a class="code" href="dwarf2read_8c.html#a28d998e6e3dbcfb7da8d018f423e7349">dw2_symtab_iter_init</a> (&amp;iter, index, 0, <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124a973ee91cbe4b0cee4eb7603252a29bec">GLOBAL_BLOCK</a>, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>,
<a name="l03673"></a>03673                             func_name);
<a name="l03674"></a>03674 
<a name="l03675"></a>03675       <span class="keywordflow">while</span> ((per_cu = <a class="code" href="dwarf2read_8c.html#aa62ca7fdd647858537de0702070fca35">dw2_symtab_iter_next</a> (&amp;iter)) != NULL)
<a name="l03676"></a>03676         <a class="code" href="dwarf2read_8c.html#a6acd40df616a0b5d96cbb15ab3690346">dw2_instantiate_symtab</a> (per_cu);
<a name="l03677"></a>03677     }
<a name="l03678"></a>03678 }
<a name="l03679"></a>03679 
<a name="l03680"></a>03680 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03681"></a><a class="code" href="dwarf2read_8c.html#accd878af02f8df46a1bf4ac805e54259">03681</a> <a class="code" href="dwarf2read_8c.html#accd878af02f8df46a1bf4ac805e54259">dw2_expand_all_symtabs</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l03682"></a>03682 {
<a name="l03683"></a>03683   <span class="keywordtype">int</span> i;
<a name="l03684"></a>03684 
<a name="l03685"></a>03685   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (objfile);
<a name="l03686"></a>03686 
<a name="l03687"></a>03687   <span class="keywordflow">for</span> (i = 0; i &lt; (dwarf2_per_objfile-&gt;n_comp_units
<a name="l03688"></a>03688                    + dwarf2_per_objfile-&gt;n_type_units); ++i)
<a name="l03689"></a>03689     {
<a name="l03690"></a>03690       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = <a class="code" href="dwarf2read_8c.html#a966b4a69ea94ca30717c495126d870c8">dw2_get_cu</a> (i);
<a name="l03691"></a>03691 
<a name="l03692"></a>03692       <a class="code" href="dwarf2read_8c.html#a6acd40df616a0b5d96cbb15ab3690346">dw2_instantiate_symtab</a> (per_cu);
<a name="l03693"></a>03693     }
<a name="l03694"></a>03694 }
<a name="l03695"></a>03695 
<a name="l03696"></a>03696 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03697"></a><a class="code" href="dwarf2read_8c.html#abac749c0da9cf37845faf3cf06929a9f">03697</a> <a class="code" href="dwarf2read_8c.html#abac749c0da9cf37845faf3cf06929a9f">dw2_expand_symtabs_with_fullname</a> (<span class="keyword">struct</span> objfile *objfile,
<a name="l03698"></a>03698                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *fullname)
<a name="l03699"></a>03699 {
<a name="l03700"></a>03700   <span class="keywordtype">int</span> i;
<a name="l03701"></a>03701 
<a name="l03702"></a>03702   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (objfile);
<a name="l03703"></a>03703 
<a name="l03704"></a>03704   <span class="comment">/* We don&#39;t need to consider type units here.</span>
<a name="l03705"></a>03705 <span class="comment">     This is only called for examining code, e.g. expand_line_sal.</span>
<a name="l03706"></a>03706 <span class="comment">     There can be an order of magnitude (or more) more type units</span>
<a name="l03707"></a>03707 <span class="comment">     than comp units, and we avoid them if we can.  */</span>
<a name="l03708"></a>03708 
<a name="l03709"></a>03709   <span class="keywordflow">for</span> (i = 0; i &lt; dwarf2_per_objfile-&gt;n_comp_units; ++i)
<a name="l03710"></a>03710     {
<a name="l03711"></a>03711       <span class="keywordtype">int</span> j;
<a name="l03712"></a>03712       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = <a class="code" href="dwarf2read_8c.html#a966b4a69ea94ca30717c495126d870c8">dw2_get_cu</a> (i);
<a name="l03713"></a>03713       <span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a> *file_data;
<a name="l03714"></a>03714 
<a name="l03715"></a>03715       <span class="comment">/* We only need to look at symtabs not already expanded.  */</span>
<a name="l03716"></a>03716       <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a>)
<a name="l03717"></a>03717         <span class="keywordflow">continue</span>;
<a name="l03718"></a>03718 
<a name="l03719"></a>03719       file_data = <a class="code" href="dwarf2read_8c.html#a3ce00d16c1dfb75f5512312207d7f12c">dw2_get_file_names</a> (per_cu);
<a name="l03720"></a>03720       <span class="keywordflow">if</span> (file_data == NULL)
<a name="l03721"></a>03721         <span class="keywordflow">continue</span>;
<a name="l03722"></a>03722 
<a name="l03723"></a>03723       <span class="keywordflow">for</span> (j = 0; j &lt; file_data-&gt;<a class="code" href="structquick__file__names.html#a534816d8c99e4e4053ca440d06c34010">num_file_names</a>; ++j)
<a name="l03724"></a>03724         {
<a name="l03725"></a>03725           <span class="keyword">const</span> <span class="keywordtype">char</span> *this_fullname = file_data-&gt;<a class="code" href="structquick__file__names.html#a8c6be91b4164dc5d7265602d0c77e6e7">file_names</a>[j];
<a name="l03726"></a>03726 
<a name="l03727"></a>03727           <span class="keywordflow">if</span> (filename_cmp (this_fullname, fullname) == 0)
<a name="l03728"></a>03728             {
<a name="l03729"></a>03729               <a class="code" href="dwarf2read_8c.html#a6acd40df616a0b5d96cbb15ab3690346">dw2_instantiate_symtab</a> (per_cu);
<a name="l03730"></a>03730               <span class="keywordflow">break</span>;
<a name="l03731"></a>03731             }
<a name="l03732"></a>03732         }
<a name="l03733"></a>03733     }
<a name="l03734"></a>03734 }
<a name="l03735"></a>03735 
<a name="l03736"></a>03736 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03737"></a><a class="code" href="dwarf2read_8c.html#a2373c9bb9bc358d2317e834f5339d809">03737</a> <a class="code" href="dwarf2read_8c.html#a2373c9bb9bc358d2317e834f5339d809">dw2_map_matching_symbols</a> (<span class="keyword">struct</span> objfile *objfile,
<a name="l03738"></a>03738                           <span class="keyword">const</span> <span class="keywordtype">char</span> * name, <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> <span class="keyword">namespace</span>,
<a name="l03739"></a>03739                           <span class="keywordtype">int</span> global,
<a name="l03740"></a>03740                           <span class="keywordtype">int</span> (*callback) (<span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *,
<a name="l03741"></a>03741                                            <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *, <span class="keywordtype">void</span> *),
<a name="l03742"></a>03742                           <span class="keywordtype">void</span> *data, <a class="code" href="symfile_8h.html#a2b98a5062928ff31e334877e5cf444bd">symbol_compare_ftype</a> *match,
<a name="l03743"></a>03743                           <a class="code" href="symfile_8h.html#a2b98a5062928ff31e334877e5cf444bd">symbol_compare_ftype</a> *ordered_compare)
<a name="l03744"></a>03744 {
<a name="l03745"></a>03745   <span class="comment">/* Currently unimplemented; used for Ada.  The function can be called if the</span>
<a name="l03746"></a>03746 <span class="comment">     current language is Ada for a non-Ada objfile using GNU index.  As Ada</span>
<a name="l03747"></a>03747 <span class="comment">     does not look for non-Ada symbols this function should just return.  */</span>
<a name="l03748"></a>03748 }
<a name="l03749"></a>03749 
<a name="l03750"></a>03750 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03751"></a>03751 <a class="code" href="dwarf2read_8c.html#a1479d715e073453254d71a1c89496c6e">dw2_expand_symtabs_matching</a>
<a name="l03752"></a><a class="code" href="dwarf2read_8c.html#a1479d715e073453254d71a1c89496c6e">03752</a>   (<span class="keyword">struct</span> objfile *objfile,
<a name="l03753"></a>03753    <span class="keywordtype">int</span> (*file_matcher) (<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">void</span> *, <span class="keywordtype">int</span> basenames),
<a name="l03754"></a>03754    <span class="keywordtype">int</span> (*name_matcher) (<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">void</span> *),
<a name="l03755"></a>03755    <span class="keyword">enum</span> <a class="code" href="symtab_8h.html#a37678171929b3b399903eec8be25dcd5">search_domain</a> kind,
<a name="l03756"></a>03756    <span class="keywordtype">void</span> *data)
<a name="l03757"></a>03757 {
<a name="l03758"></a>03758   <span class="keywordtype">int</span> i;
<a name="l03759"></a>03759   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> iter;
<a name="l03760"></a>03760   <span class="keyword">struct </span><a class="code" href="structmapped__index.html">mapped_index</a> *index;
<a name="l03761"></a>03761 
<a name="l03762"></a>03762   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (objfile);
<a name="l03763"></a>03763 
<a name="l03764"></a>03764   <span class="comment">/* index_table is NULL if OBJF_READNOW.  */</span>
<a name="l03765"></a>03765   <span class="keywordflow">if</span> (!dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a1e58a614b6e77589e24dac14dfdc62e5">index_table</a>)
<a name="l03766"></a>03766     <span class="keywordflow">return</span>;
<a name="l03767"></a>03767   index = dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a1e58a614b6e77589e24dac14dfdc62e5">index_table</a>;
<a name="l03768"></a>03768 
<a name="l03769"></a>03769   <span class="keywordflow">if</span> (file_matcher != NULL)
<a name="l03770"></a>03770     {
<a name="l03771"></a>03771       <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l03772"></a>03772       htab_t visited_found, visited_not_found;
<a name="l03773"></a>03773 
<a name="l03774"></a>03774       visited_found = htab_create_alloc (10,
<a name="l03775"></a>03775                                          htab_hash_pointer, htab_eq_pointer,
<a name="l03776"></a>03776                                          NULL, <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a>, <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>);
<a name="l03777"></a>03777       cleanup = <a class="code" href="utils_8c.html#ad5977a7d9e282b65846100111cd95c76">make_cleanup_htab_delete</a> (visited_found);
<a name="l03778"></a>03778       visited_not_found = htab_create_alloc (10,
<a name="l03779"></a>03779                                              htab_hash_pointer, htab_eq_pointer,
<a name="l03780"></a>03780                                              NULL, <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a>, <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>);
<a name="l03781"></a>03781       <a class="code" href="utils_8c.html#ad5977a7d9e282b65846100111cd95c76">make_cleanup_htab_delete</a> (visited_not_found);
<a name="l03782"></a>03782 
<a name="l03783"></a>03783       <span class="comment">/* The rule is CUs specify all the files, including those used by</span>
<a name="l03784"></a>03784 <span class="comment">         any TU, so there&#39;s no need to scan TUs here.  */</span>
<a name="l03785"></a>03785 
<a name="l03786"></a>03786       <span class="keywordflow">for</span> (i = 0; i &lt; dwarf2_per_objfile-&gt;n_comp_units; ++i)
<a name="l03787"></a>03787         {
<a name="l03788"></a>03788           <span class="keywordtype">int</span> j;
<a name="l03789"></a>03789           <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = <a class="code" href="dwarf2read_8c.html#a03d87974d046042a783bdf70e2f48083">dw2_get_primary_cu</a> (i);
<a name="l03790"></a>03790           <span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a> *file_data;
<a name="l03791"></a>03791           <span class="keywordtype">void</span> **slot;
<a name="l03792"></a>03792 
<a name="l03793"></a>03793           per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#aaf5858dc35dca5eb2593ad459b6b3689">mark</a> = 0;
<a name="l03794"></a>03794 
<a name="l03795"></a>03795           <span class="comment">/* We only need to look at symtabs not already expanded.  */</span>
<a name="l03796"></a>03796           <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a>)
<a name="l03797"></a>03797             <span class="keywordflow">continue</span>;
<a name="l03798"></a>03798 
<a name="l03799"></a>03799           file_data = <a class="code" href="dwarf2read_8c.html#a3ce00d16c1dfb75f5512312207d7f12c">dw2_get_file_names</a> (per_cu);
<a name="l03800"></a>03800           <span class="keywordflow">if</span> (file_data == NULL)
<a name="l03801"></a>03801             <span class="keywordflow">continue</span>;
<a name="l03802"></a>03802 
<a name="l03803"></a>03803           <span class="keywordflow">if</span> (htab_find (visited_not_found, file_data) != NULL)
<a name="l03804"></a>03804             <span class="keywordflow">continue</span>;
<a name="l03805"></a>03805           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (htab_find (visited_found, file_data) != NULL)
<a name="l03806"></a>03806             {
<a name="l03807"></a>03807               per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#aaf5858dc35dca5eb2593ad459b6b3689">mark</a> = 1;
<a name="l03808"></a>03808               <span class="keywordflow">continue</span>;
<a name="l03809"></a>03809             }
<a name="l03810"></a>03810 
<a name="l03811"></a>03811           <span class="keywordflow">for</span> (j = 0; j &lt; file_data-&gt;<a class="code" href="structquick__file__names.html#a534816d8c99e4e4053ca440d06c34010">num_file_names</a>; ++j)
<a name="l03812"></a>03812             {
<a name="l03813"></a>03813               <span class="keyword">const</span> <span class="keywordtype">char</span> *this_real_name;
<a name="l03814"></a>03814 
<a name="l03815"></a>03815               <span class="keywordflow">if</span> (file_matcher (file_data-&gt;<a class="code" href="structquick__file__names.html#a8c6be91b4164dc5d7265602d0c77e6e7">file_names</a>[j], data, 0))
<a name="l03816"></a>03816                 {
<a name="l03817"></a>03817                   per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#aaf5858dc35dca5eb2593ad459b6b3689">mark</a> = 1;
<a name="l03818"></a>03818                   <span class="keywordflow">break</span>;
<a name="l03819"></a>03819                 }
<a name="l03820"></a>03820 
<a name="l03821"></a>03821               <span class="comment">/* Before we invoke realpath, which can get expensive when many</span>
<a name="l03822"></a>03822 <span class="comment">                 files are involved, do a quick comparison of the basenames.  */</span>
<a name="l03823"></a>03823               <span class="keywordflow">if</span> (!<a class="code" href="symtab_8c.html#af9a62a674b6767f0981034f1ceb7756a">basenames_may_differ</a>
<a name="l03824"></a>03824                   &amp;&amp; !file_matcher (lbasename (file_data-&gt;<a class="code" href="structquick__file__names.html#a8c6be91b4164dc5d7265602d0c77e6e7">file_names</a>[j]),
<a name="l03825"></a>03825                                     data, 1))
<a name="l03826"></a>03826                 <span class="keywordflow">continue</span>;
<a name="l03827"></a>03827 
<a name="l03828"></a>03828               this_real_name = <a class="code" href="dwarf2read_8c.html#a1e35e1228b00cd44826671c3f8111482">dw2_get_real_path</a> (objfile, file_data, j);
<a name="l03829"></a>03829               <span class="keywordflow">if</span> (file_matcher (this_real_name, data, 0))
<a name="l03830"></a>03830                 {
<a name="l03831"></a>03831                   per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#aaf5858dc35dca5eb2593ad459b6b3689">mark</a> = 1;
<a name="l03832"></a>03832                   <span class="keywordflow">break</span>;
<a name="l03833"></a>03833                 }
<a name="l03834"></a>03834             }
<a name="l03835"></a>03835 
<a name="l03836"></a>03836           slot = htab_find_slot (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#aaf5858dc35dca5eb2593ad459b6b3689">mark</a>
<a name="l03837"></a>03837                                  ? visited_found
<a name="l03838"></a>03838                                  : visited_not_found,
<a name="l03839"></a>03839                                  file_data, INSERT);
<a name="l03840"></a>03840           *slot = file_data;
<a name="l03841"></a>03841         }
<a name="l03842"></a>03842 
<a name="l03843"></a>03843       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l03844"></a>03844     }
<a name="l03845"></a>03845 
<a name="l03846"></a>03846   <span class="keywordflow">for</span> (iter = 0; iter &lt; index-&gt;<a class="code" href="structmapped__index.html#a3e01c3306b6fd1f53604a4f0856013f3">symbol_table_slots</a>; ++iter)
<a name="l03847"></a>03847     {
<a name="l03848"></a>03848       <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> idx = 2 * iter;
<a name="l03849"></a>03849       <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l03850"></a>03850       <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> *vec, vec_len, vec_idx;
<a name="l03851"></a>03851 
<a name="l03852"></a>03852       <span class="keywordflow">if</span> (index-&gt;<a class="code" href="structmapped__index.html#af7415bd86bc9cfb1ba447c40762e5045">symbol_table</a>[idx] == 0 &amp;&amp; index-&gt;<a class="code" href="structmapped__index.html#af7415bd86bc9cfb1ba447c40762e5045">symbol_table</a>[idx + 1] == 0)
<a name="l03853"></a>03853         <span class="keywordflow">continue</span>;
<a name="l03854"></a>03854 
<a name="l03855"></a>03855       name = index-&gt;<a class="code" href="structmapped__index.html#a3f51d3222825ba2465d4c73f2d364cc1">constant_pool</a> + <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (index-&gt;<a class="code" href="structmapped__index.html#af7415bd86bc9cfb1ba447c40762e5045">symbol_table</a>[idx]);
<a name="l03856"></a>03856 
<a name="l03857"></a>03857       <span class="keywordflow">if</span> (! (*name_matcher) (name, data))
<a name="l03858"></a>03858         <span class="keywordflow">continue</span>;
<a name="l03859"></a>03859 
<a name="l03860"></a>03860       <span class="comment">/* The name was matched, now expand corresponding CUs that were</span>
<a name="l03861"></a>03861 <span class="comment">         marked.  */</span>
<a name="l03862"></a>03862       vec = (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> *) (index-&gt;<a class="code" href="structmapped__index.html#a3f51d3222825ba2465d4c73f2d364cc1">constant_pool</a>
<a name="l03863"></a>03863                              + <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (index-&gt;<a class="code" href="structmapped__index.html#af7415bd86bc9cfb1ba447c40762e5045">symbol_table</a>[idx + 1]));
<a name="l03864"></a>03864       vec_len = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (vec[0]);
<a name="l03865"></a>03865       <span class="keywordflow">for</span> (vec_idx = 0; vec_idx &lt; vec_len; ++vec_idx)
<a name="l03866"></a>03866         {
<a name="l03867"></a>03867           <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu;
<a name="l03868"></a>03868           <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> cu_index_and_attrs = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (vec[vec_idx + 1]);
<a name="l03869"></a>03869           gdb_index_symbol_kind <a class="code" href="dwarf2read_8c.html#a73bc3b8f484e295bdf4639f79613508f">symbol_kind</a> =
<a name="l03870"></a>03870             GDB_INDEX_SYMBOL_KIND_VALUE (cu_index_and_attrs);
<a name="l03871"></a>03871           <span class="keywordtype">int</span> cu_index = GDB_INDEX_CU_VALUE (cu_index_and_attrs);
<a name="l03872"></a>03872           <span class="comment">/* Only check the symbol attributes if they&#39;re present.</span>
<a name="l03873"></a>03873 <span class="comment">             Indices prior to version 7 don&#39;t record them,</span>
<a name="l03874"></a>03874 <span class="comment">             and indices &gt;= 7 may elide them for certain symbols</span>
<a name="l03875"></a>03875 <span class="comment">             (gold does this).  */</span>
<a name="l03876"></a>03876           <span class="keywordtype">int</span> attrs_valid =
<a name="l03877"></a>03877             (index-&gt;<a class="code" href="structmapped__index.html#a6204ce2b69334c8d243357d524858ccd">version</a> &gt;= 7
<a name="l03878"></a>03878              &amp;&amp; symbol_kind != GDB_INDEX_SYMBOL_KIND_NONE);
<a name="l03879"></a>03879 
<a name="l03880"></a>03880           <span class="comment">/* Only check the symbol&#39;s kind if it has one.  */</span>
<a name="l03881"></a>03881           <span class="keywordflow">if</span> (attrs_valid)
<a name="l03882"></a>03882             {
<a name="l03883"></a>03883               <span class="keywordflow">switch</span> (kind)
<a name="l03884"></a>03884                 {
<a name="l03885"></a>03885                 <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a37678171929b3b399903eec8be25dcd5a12470f2cb7373a9a19bd82b04cf1fe5e">VARIABLES_DOMAIN</a>:
<a name="l03886"></a>03886                   <span class="keywordflow">if</span> (symbol_kind != GDB_INDEX_SYMBOL_KIND_VARIABLE)
<a name="l03887"></a>03887                     <span class="keywordflow">continue</span>;
<a name="l03888"></a>03888                   <span class="keywordflow">break</span>;
<a name="l03889"></a>03889                 <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a37678171929b3b399903eec8be25dcd5a1f61ae1bab4f2263bf193b1260269e67">FUNCTIONS_DOMAIN</a>:
<a name="l03890"></a>03890                   <span class="keywordflow">if</span> (symbol_kind != GDB_INDEX_SYMBOL_KIND_FUNCTION)
<a name="l03891"></a>03891                     <span class="keywordflow">continue</span>;
<a name="l03892"></a>03892                   <span class="keywordflow">break</span>;
<a name="l03893"></a>03893                 <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a37678171929b3b399903eec8be25dcd5a26fe3ebdde492058eb9dc6a0116288ef">TYPES_DOMAIN</a>:
<a name="l03894"></a>03894                   <span class="keywordflow">if</span> (symbol_kind != GDB_INDEX_SYMBOL_KIND_TYPE)
<a name="l03895"></a>03895                     <span class="keywordflow">continue</span>;
<a name="l03896"></a>03896                   <span class="keywordflow">break</span>;
<a name="l03897"></a>03897                 <span class="keywordflow">default</span>:
<a name="l03898"></a>03898                   <span class="keywordflow">break</span>;
<a name="l03899"></a>03899                 }
<a name="l03900"></a>03900             }
<a name="l03901"></a>03901 
<a name="l03902"></a>03902           <span class="comment">/* Don&#39;t crash on bad data.  */</span>
<a name="l03903"></a>03903           <span class="keywordflow">if</span> (cu_index &gt;= (dwarf2_per_objfile-&gt;n_comp_units
<a name="l03904"></a>03904                            + dwarf2_per_objfile-&gt;n_type_units))
<a name="l03905"></a>03905             {
<a name="l03906"></a>03906               <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l03907"></a>03907                          <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;.gdb_index entry has bad CU index&quot;</span>
<a name="l03908"></a>03908                            <span class="stringliteral">&quot; [in module %s]&quot;</span>), <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l03909"></a>03909               <span class="keywordflow">continue</span>;
<a name="l03910"></a>03910             }
<a name="l03911"></a>03911 
<a name="l03912"></a>03912           per_cu = <a class="code" href="dwarf2read_8c.html#a966b4a69ea94ca30717c495126d870c8">dw2_get_cu</a> (cu_index);
<a name="l03913"></a>03913           <span class="keywordflow">if</span> (file_matcher == NULL || per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#aaf5858dc35dca5eb2593ad459b6b3689">mark</a>)
<a name="l03914"></a>03914             <a class="code" href="dwarf2read_8c.html#a6acd40df616a0b5d96cbb15ab3690346">dw2_instantiate_symtab</a> (per_cu);
<a name="l03915"></a>03915         }
<a name="l03916"></a>03916     }
<a name="l03917"></a>03917 }
<a name="l03918"></a>03918 
<a name="l03919"></a>03919 <span class="comment">/* A helper for dw2_find_pc_sect_symtab which finds the most specific</span>
<a name="l03920"></a>03920 <span class="comment">   symtab.  */</span>
<a name="l03921"></a>03921 
<a name="l03922"></a>03922 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *
<a name="l03923"></a><a class="code" href="dwarf2read_8c.html#a63a9a248b44d0b46e0857e152afcdc49">03923</a> <a class="code" href="dwarf2read_8c.html#a63a9a248b44d0b46e0857e152afcdc49">recursively_find_pc_sect_symtab</a> (<span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structsymtab.html">symtab</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc)
<a name="l03924"></a>03924 {
<a name="l03925"></a>03925   <span class="keywordtype">int</span> i;
<a name="l03926"></a>03926 
<a name="l03927"></a>03927   <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a6cd84410d73680ff8006ac44b1b98a9c">BLOCKVECTOR</a> (symtab) != NULL
<a name="l03928"></a>03928       &amp;&amp; <a class="code" href="block_8c.html#a6ad6562dc29d5cbeda761d811fe6d96e">blockvector_contains_pc</a> (<a class="code" href="symtab_8h.html#a6cd84410d73680ff8006ac44b1b98a9c">BLOCKVECTOR</a> (symtab), pc))
<a name="l03929"></a>03929     <span class="keywordflow">return</span> symtab;
<a name="l03930"></a>03930 
<a name="l03931"></a>03931   <span class="keywordflow">if</span> (symtab-&gt;<a class="code" href="structsymtab.html#aa9169868cbd3de0e738746827b532f16">includes</a> == NULL)
<a name="l03932"></a>03932     <span class="keywordflow">return</span> NULL;
<a name="l03933"></a>03933 
<a name="l03934"></a>03934   <span class="keywordflow">for</span> (i = 0; symtab-&gt;<a class="code" href="structsymtab.html#aa9169868cbd3de0e738746827b532f16">includes</a>[i]; ++i)
<a name="l03935"></a>03935     {
<a name="l03936"></a>03936       <span class="keyword">struct </span>symtab *s = symtab-&gt;<a class="code" href="structsymtab.html#aa9169868cbd3de0e738746827b532f16">includes</a>[i];
<a name="l03937"></a>03937 
<a name="l03938"></a>03938       s = <a class="code" href="dwarf2read_8c.html#a63a9a248b44d0b46e0857e152afcdc49">recursively_find_pc_sect_symtab</a> (s, pc);
<a name="l03939"></a>03939       <span class="keywordflow">if</span> (s != NULL)
<a name="l03940"></a>03940         <span class="keywordflow">return</span> s;
<a name="l03941"></a>03941     }
<a name="l03942"></a>03942 
<a name="l03943"></a>03943   <span class="keywordflow">return</span> NULL;
<a name="l03944"></a>03944 }
<a name="l03945"></a>03945 
<a name="l03946"></a>03946 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *
<a name="l03947"></a><a class="code" href="dwarf2read_8c.html#a66559e3486c185bf74773ec18a816818">03947</a> <a class="code" href="dwarf2read_8c.html#a66559e3486c185bf74773ec18a816818">dw2_find_pc_sect_symtab</a> (<span class="keyword">struct</span> objfile *objfile,
<a name="l03948"></a>03948                          <span class="keyword">struct</span> <a class="code" href="structminimal__symbol.html">minimal_symbol</a> *msymbol,
<a name="l03949"></a>03949                          <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc,
<a name="l03950"></a>03950                          <span class="keyword">struct</span> <a class="code" href="structobj__section.html">obj_section</a> *section,
<a name="l03951"></a>03951                          <span class="keywordtype">int</span> warn_if_readin)
<a name="l03952"></a>03952 {
<a name="l03953"></a>03953   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *data;
<a name="l03954"></a>03954   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *result;
<a name="l03955"></a>03955 
<a name="l03956"></a>03956   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (objfile);
<a name="l03957"></a>03957 
<a name="l03958"></a>03958   <span class="keywordflow">if</span> (!objfile-&gt;<a class="code" href="structobjfile.html#ae7c792f2cd4efcff86d84d7bd3e15b26">psymtabs_addrmap</a>)
<a name="l03959"></a>03959     <span class="keywordflow">return</span> NULL;
<a name="l03960"></a>03960 
<a name="l03961"></a>03961   data = <a class="code" href="addrmap_8c.html#a74b7d52b6910844e259bd1a9861a614c">addrmap_find</a> (objfile-&gt;<a class="code" href="structobjfile.html#ae7c792f2cd4efcff86d84d7bd3e15b26">psymtabs_addrmap</a>, pc);
<a name="l03962"></a>03962   <span class="keywordflow">if</span> (!data)
<a name="l03963"></a>03963     <span class="keywordflow">return</span> NULL;
<a name="l03964"></a>03964 
<a name="l03965"></a>03965   <span class="keywordflow">if</span> (warn_if_readin &amp;&amp; data-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a>)
<a name="l03966"></a>03966     <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;(Internal error: pc %s in read in CU, but not in symtab.)&quot;</span>),
<a name="l03967"></a>03967              <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (<a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile), pc));
<a name="l03968"></a>03968 
<a name="l03969"></a>03969   result = <a class="code" href="dwarf2read_8c.html#a63a9a248b44d0b46e0857e152afcdc49">recursively_find_pc_sect_symtab</a> (<a class="code" href="dwarf2read_8c.html#a6acd40df616a0b5d96cbb15ab3690346">dw2_instantiate_symtab</a> (data), pc);
<a name="l03970"></a>03970   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (result != NULL);
<a name="l03971"></a>03971   <span class="keywordflow">return</span> result;
<a name="l03972"></a>03972 }
<a name="l03973"></a>03973 
<a name="l03974"></a>03974 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03975"></a><a class="code" href="dwarf2read_8c.html#a489c892904c5aa701bbd7a56c7db37ed">03975</a> <a class="code" href="dwarf2read_8c.html#a489c892904c5aa701bbd7a56c7db37ed">dw2_map_symbol_filenames</a> (<span class="keyword">struct</span> objfile *objfile, <a class="code" href="symfile_8h.html#aa6c3550ce55c965193c4397a8583a3b8">symbol_filename_ftype</a> *fun,
<a name="l03976"></a>03976                           <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> need_fullname)
<a name="l03977"></a>03977 {
<a name="l03978"></a>03978   <span class="keywordtype">int</span> i;
<a name="l03979"></a>03979   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l03980"></a>03980   htab_t visited = htab_create_alloc (10, htab_hash_pointer, htab_eq_pointer,
<a name="l03981"></a>03981                                       NULL, <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a>, <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>);
<a name="l03982"></a>03982 
<a name="l03983"></a>03983   cleanup = <a class="code" href="utils_8c.html#ad5977a7d9e282b65846100111cd95c76">make_cleanup_htab_delete</a> (visited);
<a name="l03984"></a>03984   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (objfile);
<a name="l03985"></a>03985 
<a name="l03986"></a>03986   <span class="comment">/* The rule is CUs specify all the files, including those used by</span>
<a name="l03987"></a>03987 <span class="comment">     any TU, so there&#39;s no need to scan TUs here.</span>
<a name="l03988"></a>03988 <span class="comment">     We can ignore file names coming from already-expanded CUs.  */</span>
<a name="l03989"></a>03989 
<a name="l03990"></a>03990   <span class="keywordflow">for</span> (i = 0; i &lt; dwarf2_per_objfile-&gt;n_comp_units; ++i)
<a name="l03991"></a>03991     {
<a name="l03992"></a>03992       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = <a class="code" href="dwarf2read_8c.html#a966b4a69ea94ca30717c495126d870c8">dw2_get_cu</a> (i);
<a name="l03993"></a>03993 
<a name="l03994"></a>03994       <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a>)
<a name="l03995"></a>03995         {
<a name="l03996"></a>03996           <span class="keywordtype">void</span> **slot = htab_find_slot (visited, per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#add9a664dbc27341d6bfc03bca8bdcbe0">file_names</a>,
<a name="l03997"></a>03997                                         INSERT);
<a name="l03998"></a>03998 
<a name="l03999"></a>03999           *slot = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#add9a664dbc27341d6bfc03bca8bdcbe0">file_names</a>;
<a name="l04000"></a>04000         }
<a name="l04001"></a>04001     }
<a name="l04002"></a>04002 
<a name="l04003"></a>04003   <span class="keywordflow">for</span> (i = 0; i &lt; dwarf2_per_objfile-&gt;n_comp_units; ++i)
<a name="l04004"></a>04004     {
<a name="l04005"></a>04005       <span class="keywordtype">int</span> j;
<a name="l04006"></a>04006       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = <a class="code" href="dwarf2read_8c.html#a03d87974d046042a783bdf70e2f48083">dw2_get_primary_cu</a> (i);
<a name="l04007"></a>04007       <span class="keyword">struct </span><a class="code" href="structquick__file__names.html">quick_file_names</a> *file_data;
<a name="l04008"></a>04008       <span class="keywordtype">void</span> **slot;
<a name="l04009"></a>04009 
<a name="l04010"></a>04010       <span class="comment">/* We only need to look at symtabs not already expanded.  */</span>
<a name="l04011"></a>04011       <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a>)
<a name="l04012"></a>04012         <span class="keywordflow">continue</span>;
<a name="l04013"></a>04013 
<a name="l04014"></a>04014       file_data = <a class="code" href="dwarf2read_8c.html#a3ce00d16c1dfb75f5512312207d7f12c">dw2_get_file_names</a> (per_cu);
<a name="l04015"></a>04015       <span class="keywordflow">if</span> (file_data == NULL)
<a name="l04016"></a>04016         <span class="keywordflow">continue</span>;
<a name="l04017"></a>04017 
<a name="l04018"></a>04018       slot = htab_find_slot (visited, file_data, INSERT);
<a name="l04019"></a>04019       <span class="keywordflow">if</span> (*slot)
<a name="l04020"></a>04020         {
<a name="l04021"></a>04021           <span class="comment">/* Already visited.  */</span>
<a name="l04022"></a>04022           <span class="keywordflow">continue</span>;
<a name="l04023"></a>04023         }
<a name="l04024"></a>04024       *slot = file_data;
<a name="l04025"></a>04025 
<a name="l04026"></a>04026       <span class="keywordflow">for</span> (j = 0; j &lt; file_data-&gt;<a class="code" href="structquick__file__names.html#a534816d8c99e4e4053ca440d06c34010">num_file_names</a>; ++j)
<a name="l04027"></a>04027         {
<a name="l04028"></a>04028           <span class="keyword">const</span> <span class="keywordtype">char</span> *this_real_name;
<a name="l04029"></a>04029 
<a name="l04030"></a>04030           <span class="keywordflow">if</span> (need_fullname)
<a name="l04031"></a>04031             this_real_name = <a class="code" href="dwarf2read_8c.html#a1e35e1228b00cd44826671c3f8111482">dw2_get_real_path</a> (objfile, file_data, j);
<a name="l04032"></a>04032           <span class="keywordflow">else</span>
<a name="l04033"></a>04033             this_real_name = NULL;
<a name="l04034"></a>04034           (*fun) (file_data-&gt;<a class="code" href="structquick__file__names.html#a8c6be91b4164dc5d7265602d0c77e6e7">file_names</a>[j], this_real_name, data);
<a name="l04035"></a>04035         }
<a name="l04036"></a>04036     }
<a name="l04037"></a>04037 
<a name="l04038"></a>04038   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l04039"></a>04039 }
<a name="l04040"></a>04040 
<a name="l04041"></a>04041 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04042"></a><a class="code" href="dwarf2read_8c.html#acaf46a6b65e6704e854c7e117ee16116">04042</a> <a class="code" href="dwarf2read_8c.html#acaf46a6b65e6704e854c7e117ee16116">dw2_has_symbols</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l04043"></a>04043 {
<a name="l04044"></a>04044   <span class="keywordflow">return</span> 1;
<a name="l04045"></a>04045 }
<a name="l04046"></a>04046 
<a name="l04047"></a><a class="code" href="psymtab_8h.html#ab2816164f8177b2b1020229720fce1e2">04047</a> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structquick__symbol__functions.html">quick_symbol_functions</a> <a class="code" href="dwarf2read_8c.html#ab2816164f8177b2b1020229720fce1e2">dwarf2_gdb_index_functions</a> =
<a name="l04048"></a>04048 {
<a name="l04049"></a>04049   <a class="code" href="dwarf2read_8c.html#acaf46a6b65e6704e854c7e117ee16116">dw2_has_symbols</a>,
<a name="l04050"></a>04050   <a class="code" href="dwarf2read_8c.html#adad79a4699a13cee353ff4a7f8933808">dw2_find_last_source_symtab</a>,
<a name="l04051"></a>04051   <a class="code" href="dwarf2read_8c.html#af5935cfb14249660550e8de0a02f317a">dw2_forget_cached_source_info</a>,
<a name="l04052"></a>04052   <a class="code" href="dwarf2read_8c.html#a2da073778d348b5641f4306737a76d97">dw2_map_symtabs_matching_filename</a>,
<a name="l04053"></a>04053   <a class="code" href="dwarf2read_8c.html#a048d929b8c59528c1bff004daa51027e">dw2_lookup_symbol</a>,
<a name="l04054"></a>04054   <a class="code" href="dwarf2read_8c.html#ace21bb973130085dd3a90702586b92e2">dw2_print_stats</a>,
<a name="l04055"></a>04055   <a class="code" href="dwarf2read_8c.html#a29f62fb03ccada86ed4f777f1f6e60fe">dw2_dump</a>,
<a name="l04056"></a>04056   <a class="code" href="dwarf2read_8c.html#aee004fae9da4c316785d39a89c27e1b1">dw2_relocate</a>,
<a name="l04057"></a>04057   <a class="code" href="dwarf2read_8c.html#a5eb403e02fc625690f53d7f07f7ec123">dw2_expand_symtabs_for_function</a>,
<a name="l04058"></a>04058   <a class="code" href="dwarf2read_8c.html#accd878af02f8df46a1bf4ac805e54259">dw2_expand_all_symtabs</a>,
<a name="l04059"></a>04059   <a class="code" href="dwarf2read_8c.html#abac749c0da9cf37845faf3cf06929a9f">dw2_expand_symtabs_with_fullname</a>,
<a name="l04060"></a>04060   <a class="code" href="dwarf2read_8c.html#a2373c9bb9bc358d2317e834f5339d809">dw2_map_matching_symbols</a>,
<a name="l04061"></a>04061   <a class="code" href="dwarf2read_8c.html#a1479d715e073453254d71a1c89496c6e">dw2_expand_symtabs_matching</a>,
<a name="l04062"></a>04062   <a class="code" href="dwarf2read_8c.html#a66559e3486c185bf74773ec18a816818">dw2_find_pc_sect_symtab</a>,
<a name="l04063"></a>04063   <a class="code" href="dwarf2read_8c.html#a489c892904c5aa701bbd7a56c7db37ed">dw2_map_symbol_filenames</a>
<a name="l04064"></a>04064 };
<a name="l04065"></a>04065 
<a name="l04066"></a>04066 <span class="comment">/* Initialize for reading DWARF for this objfile.  Return 0 if this</span>
<a name="l04067"></a>04067 <span class="comment">   file will use psymtabs, or 1 if using the GNU index.  */</span>
<a name="l04068"></a>04068 
<a name="l04069"></a>04069 <span class="keywordtype">int</span>
<a name="l04070"></a><a class="code" href="symfile_8h.html#acf20fccb4eec1b3538855833a507fa61">04070</a> <a class="code" href="dwarf2read_8c.html#a43b41c104f0f58a9bbae619e89bed695">dwarf2_initialize_objfile</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l04071"></a>04071 {
<a name="l04072"></a>04072   <span class="comment">/* If we&#39;re about to read full symbols, don&#39;t bother with the</span>
<a name="l04073"></a>04073 <span class="comment">     indices.  In this case we also don&#39;t care if some other debug</span>
<a name="l04074"></a>04074 <span class="comment">     format is making psymtabs, because they are all about to be</span>
<a name="l04075"></a>04075 <span class="comment">     expanded anyway.  */</span>
<a name="l04076"></a>04076   <span class="keywordflow">if</span> ((objfile-&gt;<a class="code" href="structobjfile.html#a07578e542db3b2a277e146b24adf007e">flags</a> &amp; <a class="code" href="objfiles_8h.html#a13b0b01806a13d8b96e233e07fe70c09">OBJF_READNOW</a>))
<a name="l04077"></a>04077     {
<a name="l04078"></a>04078       <span class="keywordtype">int</span> i;
<a name="l04079"></a>04079 
<a name="l04080"></a>04080       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a> = 1;
<a name="l04081"></a>04081       <a class="code" href="dwarf2read_8c.html#a34cc869c244a5085a0bf01a01b0961db">create_all_comp_units</a> (objfile);
<a name="l04082"></a>04082       <a class="code" href="dwarf2read_8c.html#a74edb9fb71ae3b0318ea886c49b697ef">create_all_type_units</a> (objfile);
<a name="l04083"></a>04083       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#aeb96e928b0cd54363e459b10effcb0b3">quick_file_names_table</a> =
<a name="l04084"></a>04084         <a class="code" href="dwarf2read_8c.html#a3e3ee9237abb0774920bf5fa4edaf782">create_quick_file_names_table</a> (dwarf2_per_objfile-&gt;n_comp_units);
<a name="l04085"></a>04085 
<a name="l04086"></a>04086       <span class="keywordflow">for</span> (i = 0; i &lt; (dwarf2_per_objfile-&gt;n_comp_units
<a name="l04087"></a>04087                        + dwarf2_per_objfile-&gt;n_type_units); ++i)
<a name="l04088"></a>04088         {
<a name="l04089"></a>04089           <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = <a class="code" href="dwarf2read_8c.html#a966b4a69ea94ca30717c495126d870c8">dw2_get_cu</a> (i);
<a name="l04090"></a>04090 
<a name="l04091"></a>04091           per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a> = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l04092"></a>04092                                             <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__quick__data.html">dwarf2_per_cu_quick_data</a>);
<a name="l04093"></a>04093         }
<a name="l04094"></a>04094 
<a name="l04095"></a>04095       <span class="comment">/* Return 1 so that gdb sees the &quot;quick&quot; functions.  However,</span>
<a name="l04096"></a>04096 <span class="comment">         these functions will be no-ops because we will have expanded</span>
<a name="l04097"></a>04097 <span class="comment">         all symtabs.  */</span>
<a name="l04098"></a>04098       <span class="keywordflow">return</span> 1;
<a name="l04099"></a>04099     }
<a name="l04100"></a>04100 
<a name="l04101"></a>04101   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a15e772cd63f184bb5f565a3aa47f378b">dwarf2_read_index</a> (objfile))
<a name="l04102"></a>04102     <span class="keywordflow">return</span> 1;
<a name="l04103"></a>04103 
<a name="l04104"></a>04104   <span class="keywordflow">return</span> 0;
<a name="l04105"></a>04105 }
<a name="l04106"></a>04106 
<a name="l04107"></a>04107 
<a name="l04108"></a>04108 
<a name="l04109"></a>04109 <span class="comment">/* Build a partial symbol table.  */</span>
<a name="l04110"></a>04110 
<a name="l04111"></a>04111 <span class="keywordtype">void</span>
<a name="l04112"></a><a class="code" href="symfile_8h.html#a6242387622dce8faa335aa4e4475a006">04112</a> <a class="code" href="dwarf2read_8c.html#a63a783cfbadacf7115d7b1e3853710db">dwarf2_build_psymtabs</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l04113"></a>04113 {
<a name="l04114"></a>04114   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> except;
<a name="l04115"></a>04115 
<a name="l04116"></a>04116   <span class="keywordflow">if</span> (objfile-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#ad9937316024e2a8589a4e04d080e74eb">size</a> == 0 &amp;&amp; objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#ad9937316024e2a8589a4e04d080e74eb">size</a> == 0)
<a name="l04117"></a>04117     {
<a name="l04118"></a>04118       <a class="code" href="psympriv_8h.html#ae1974889fb462795c0c148c5c8bee750">init_psymbol_list</a> (objfile, 1024);
<a name="l04119"></a>04119     }
<a name="l04120"></a>04120 
<a name="l04121"></a>04121   <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l04122"></a>04122     {
<a name="l04123"></a>04123       <span class="comment">/* This isn&#39;t really ideal: all the data we allocate on the</span>
<a name="l04124"></a>04124 <span class="comment">         objfile&#39;s obstack is still uselessly kept around.  However,</span>
<a name="l04125"></a>04125 <span class="comment">         freeing it seems unsafe.  */</span>
<a name="l04126"></a>04126       <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups = <a class="code" href="psympriv_8h.html#ad507fe2563db86bee80cdb1a837268a2">make_cleanup_discard_psymtabs</a> (objfile);
<a name="l04127"></a>04127 
<a name="l04128"></a>04128       <a class="code" href="dwarf2read_8c.html#aef51fb88d6ce2db82dbfed7ae8ac929e">dwarf2_build_psymtabs_hard</a> (objfile);
<a name="l04129"></a>04129       <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (cleanups);
<a name="l04130"></a>04130     }
<a name="l04131"></a>04131   <span class="keywordflow">if</span> (except.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0)
<a name="l04132"></a>04132     <a class="code" href="exceptions_8c.html#ac90532089cc9e4b0e3c57798a13887d3">exception_print</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, except);
<a name="l04133"></a>04133 }
<a name="l04134"></a>04134 
<a name="l04135"></a>04135 <span class="comment">/* Return the total length of the CU described by HEADER.  */</span>
<a name="l04136"></a>04136 
<a name="l04137"></a>04137 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l04138"></a><a class="code" href="dwarf2read_8c.html#a64dfe5d648dc5396cd471de3540fef30">04138</a> <a class="code" href="dwarf2read_8c.html#a64dfe5d648dc5396cd471de3540fef30">get_cu_length</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *header)
<a name="l04139"></a>04139 {
<a name="l04140"></a>04140   <span class="keywordflow">return</span> header-&gt;<a class="code" href="structcomp__unit__head.html#ac7e963b953a807bdbcecd0c3dd4f1790">initial_length_size</a> + header-&gt;<a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a>;
<a name="l04141"></a>04141 }
<a name="l04142"></a>04142 
<a name="l04143"></a>04143 <span class="comment">/* Return TRUE if OFFSET is within CU_HEADER.  */</span>
<a name="l04144"></a>04144 
<a name="l04145"></a>04145 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l04146"></a><a class="code" href="dwarf2read_8c.html#a244f083f251f3bfffd839e9fd3670a9a">04146</a> <a class="code" href="dwarf2read_8c.html#a244f083f251f3bfffd839e9fd3670a9a">offset_in_cu_p</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_header, <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>)
<a name="l04147"></a>04147 {
<a name="l04148"></a>04148   <a class="code" href="structsect__offset.html">sect_offset</a> bottom = { cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> };
<a name="l04149"></a>04149   <a class="code" href="structsect__offset.html">sect_offset</a> top = { cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> + <a class="code" href="dwarf2read_8c.html#a64dfe5d648dc5396cd471de3540fef30">get_cu_length</a> (cu_header) };
<a name="l04150"></a>04150 
<a name="l04151"></a>04151   <span class="keywordflow">return</span> (offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> &gt;= bottom.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> &amp;&amp; offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> &lt; top.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l04152"></a>04152 }
<a name="l04153"></a>04153 
<a name="l04154"></a>04154 <span class="comment">/* Find the base address of the compilation unit for range lists and</span>
<a name="l04155"></a>04155 <span class="comment">   location lists.  It will normally be specified by DW_AT_low_pc.</span>
<a name="l04156"></a>04156 <span class="comment">   In DWARF-3 draft 4, the base address could be overridden by</span>
<a name="l04157"></a>04157 <span class="comment">   DW_AT_entry_pc.  It&#39;s been removed, but GCC still uses this for</span>
<a name="l04158"></a>04158 <span class="comment">   compilation units with discontinuous ranges.  */</span>
<a name="l04159"></a>04159 
<a name="l04160"></a>04160 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04161"></a><a class="code" href="dwarf2read_8c.html#af314d232c2dcff121c89ecf2ed276658">04161</a> <a class="code" href="dwarf2read_8c.html#af314d232c2dcff121c89ecf2ed276658">dwarf2_find_base_address</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l04162"></a>04162 {
<a name="l04163"></a>04163   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l04164"></a>04164 
<a name="l04165"></a>04165   cu-&gt;<a class="code" href="structdwarf2__cu.html#a119974d7d2639455e745de437261ade8">base_known</a> = 0;
<a name="l04166"></a>04166   cu-&gt;<a class="code" href="structdwarf2__cu.html#a23134f383c2bf69e7c15465e6bb7c128">base_address</a> = 0;
<a name="l04167"></a>04167 
<a name="l04168"></a>04168   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_entry_pc, cu);
<a name="l04169"></a>04169   <span class="keywordflow">if</span> (attr)
<a name="l04170"></a>04170     {
<a name="l04171"></a>04171       cu-&gt;<a class="code" href="structdwarf2__cu.html#a23134f383c2bf69e7c15465e6bb7c128">base_address</a> = <a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (attr);
<a name="l04172"></a>04172       cu-&gt;<a class="code" href="structdwarf2__cu.html#a119974d7d2639455e745de437261ade8">base_known</a> = 1;
<a name="l04173"></a>04173     }
<a name="l04174"></a>04174   <span class="keywordflow">else</span>
<a name="l04175"></a>04175     {
<a name="l04176"></a>04176       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_low_pc, cu);
<a name="l04177"></a>04177       <span class="keywordflow">if</span> (attr)
<a name="l04178"></a>04178         {
<a name="l04179"></a>04179           cu-&gt;<a class="code" href="structdwarf2__cu.html#a23134f383c2bf69e7c15465e6bb7c128">base_address</a> = <a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (attr);
<a name="l04180"></a>04180           cu-&gt;<a class="code" href="structdwarf2__cu.html#a119974d7d2639455e745de437261ade8">base_known</a> = 1;
<a name="l04181"></a>04181         }
<a name="l04182"></a>04182     }
<a name="l04183"></a>04183 }
<a name="l04184"></a>04184 
<a name="l04185"></a>04185 <span class="comment">/* Read in the comp unit header information from the debug_info at info_ptr.</span>
<a name="l04186"></a>04186 <span class="comment">   NOTE: This leaves members offset, first_die_offset to be filled in</span>
<a name="l04187"></a>04187 <span class="comment">   by the caller.  */</span>
<a name="l04188"></a>04188 
<a name="l04189"></a>04189 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l04190"></a><a class="code" href="dwarf2read_8c.html#af69b698a6799f5cd7603c38c2be1cecb">04190</a> <a class="code" href="dwarf2read_8c.html#af69b698a6799f5cd7603c38c2be1cecb">read_comp_unit_head</a> (<span class="keyword">struct</span> <a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_header,
<a name="l04191"></a>04191                      <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr, bfd *abfd)
<a name="l04192"></a>04192 {
<a name="l04193"></a>04193   <span class="keywordtype">int</span> signed_addr;
<a name="l04194"></a>04194   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l04195"></a>04195 
<a name="l04196"></a>04196   cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a> = <a class="code" href="dwarf2read_8c.html#a40cbc7bcde605127cf1baef337c57f9e">read_initial_length</a> (abfd, info_ptr, &amp;bytes_read);
<a name="l04197"></a>04197   cu_header-&gt;<a class="code" href="structcomp__unit__head.html#ac7e963b953a807bdbcecd0c3dd4f1790">initial_length_size</a> = bytes_read;
<a name="l04198"></a>04198   cu_header-&gt;<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a> = (bytes_read == 4) ? 4 : 8;
<a name="l04199"></a>04199   info_ptr += bytes_read;
<a name="l04200"></a>04200   cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a68d6c482c646af0266771ad56b73748d">version</a> = <a class="code" href="dwarf2read_8c.html#a35663eebf65b4217082f14bc1f782307">read_2_bytes</a> (abfd, info_ptr);
<a name="l04201"></a>04201   info_ptr += 2;
<a name="l04202"></a>04202   cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a5455b96122116b3881197362c7e35758">abbrev_offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = <a class="code" href="dwarf2read_8c.html#afd4b43dc237191df908291fb832628e5">read_offset</a> (abfd, info_ptr, cu_header,
<a name="l04203"></a>04203                                              &amp;bytes_read);
<a name="l04204"></a>04204   info_ptr += bytes_read;
<a name="l04205"></a>04205   cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a> = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, info_ptr);
<a name="l04206"></a>04206   info_ptr += 1;
<a name="l04207"></a>04207   signed_addr = bfd_get_sign_extend_vma (abfd);
<a name="l04208"></a>04208   <span class="keywordflow">if</span> (signed_addr &lt; 0)
<a name="l04209"></a>04209     <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l04210"></a>04210                     <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;read_comp_unit_head: dwarf from non elf file&quot;</span>));
<a name="l04211"></a>04211   cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a4dbec66bb53896b38a53f9f4c8c5e1fb">signed_addr_p</a> = signed_addr;
<a name="l04212"></a>04212 
<a name="l04213"></a>04213   <span class="keywordflow">return</span> info_ptr;
<a name="l04214"></a>04214 }
<a name="l04215"></a>04215 
<a name="l04216"></a>04216 <span class="comment">/* Helper function that returns the proper abbrev section for</span>
<a name="l04217"></a>04217 <span class="comment">   THIS_CU.  */</span>
<a name="l04218"></a>04218 
<a name="l04219"></a>04219 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *
<a name="l04220"></a><a class="code" href="dwarf2read_8c.html#a509e9fa93beee310decdddd99d011ef3">04220</a> <a class="code" href="dwarf2read_8c.html#a509e9fa93beee310decdddd99d011ef3">get_abbrev_section_for_cu</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu)
<a name="l04221"></a>04221 {
<a name="l04222"></a>04222   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *abbrev;
<a name="l04223"></a>04223 
<a name="l04224"></a>04224   <span class="keywordflow">if</span> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a>)
<a name="l04225"></a>04225     abbrev = &amp;<a class="code" href="dwarf2read_8c.html#a926306809098933a820cfda81b19864c">dwarf2_get_dwz_file</a> ()-&gt;<a class="code" href="structdwz__file.html#a6d54052c436197e540e433c95f5361e3">abbrev</a>;
<a name="l04226"></a>04226   <span class="keywordflow">else</span>
<a name="l04227"></a>04227     abbrev = &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a65f092d6a408e872a5b5f724728353de">abbrev</a>;
<a name="l04228"></a>04228 
<a name="l04229"></a>04229   <span class="keywordflow">return</span> abbrev;
<a name="l04230"></a>04230 }
<a name="l04231"></a>04231 
<a name="l04232"></a>04232 <span class="comment">/* Subroutine of read_and_check_comp_unit_head and</span>
<a name="l04233"></a>04233 <span class="comment">   read_and_check_type_unit_head to simplify them.</span>
<a name="l04234"></a>04234 <span class="comment">   Perform various error checking on the header.  */</span>
<a name="l04235"></a>04235 
<a name="l04236"></a>04236 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04237"></a><a class="code" href="dwarf2read_8c.html#aef690d08ba1f15fc120ed8687a521aa8">04237</a> <a class="code" href="dwarf2read_8c.html#aef690d08ba1f15fc120ed8687a521aa8">error_check_comp_unit_head</a> (<span class="keyword">struct</span> <a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *header,
<a name="l04238"></a>04238                             <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section,
<a name="l04239"></a>04239                             <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *abbrev_section)
<a name="l04240"></a>04240 {
<a name="l04241"></a>04241   bfd *abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l04242"></a>04242   <span class="keyword">const</span> <span class="keywordtype">char</span> *filename = <a class="code" href="dwarf2read_8c.html#a1c841524fdd0bd73272dad700a7452f6">get_section_file_name</a> (section);
<a name="l04243"></a>04243 
<a name="l04244"></a>04244   <span class="keywordflow">if</span> (header-&gt;<a class="code" href="structcomp__unit__head.html#a68d6c482c646af0266771ad56b73748d">version</a> != 2 &amp;&amp; header-&gt;<a class="code" href="structcomp__unit__head.html#a68d6c482c646af0266771ad56b73748d">version</a> != 3 &amp;&amp; header-&gt;<a class="code" href="structcomp__unit__head.html#a68d6c482c646af0266771ad56b73748d">version</a> != 4)
<a name="l04245"></a>04245     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: wrong version in compilation unit header &quot;</span>
<a name="l04246"></a>04246            <span class="stringliteral">&quot;(is %d, should be 2, 3, or 4) [in module %s]&quot;</span>), header-&gt;<a class="code" href="structcomp__unit__head.html#a68d6c482c646af0266771ad56b73748d">version</a>,
<a name="l04247"></a>04247            filename);
<a name="l04248"></a>04248 
<a name="l04249"></a>04249   <span class="keywordflow">if</span> (header-&gt;<a class="code" href="structcomp__unit__head.html#a5455b96122116b3881197362c7e35758">abbrev_offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>
<a name="l04250"></a>04250       &gt;= <a class="code" href="dwarf2read_8c.html#ab7078b0a27fb1b75f90d215b5d649771">dwarf2_section_size</a> (dwarf2_per_objfile-&gt;objfile, abbrev_section))
<a name="l04251"></a>04251     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: bad offset (0x%lx) in compilation unit header &quot;</span>
<a name="l04252"></a>04252            <span class="stringliteral">&quot;(offset 0x%lx + 6) [in module %s]&quot;</span>),
<a name="l04253"></a>04253            (<span class="keywordtype">long</span>) header-&gt;<a class="code" href="structcomp__unit__head.html#a5455b96122116b3881197362c7e35758">abbrev_offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, (<span class="keywordtype">long</span>) header-&gt;<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>,
<a name="l04254"></a>04254            filename);
<a name="l04255"></a>04255 
<a name="l04256"></a>04256   <span class="comment">/* Cast to unsigned long to use 64-bit arithmetic when possible to</span>
<a name="l04257"></a>04257 <span class="comment">     avoid potential 32-bit overflow.  */</span>
<a name="l04258"></a>04258   <span class="keywordflow">if</span> (((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) header-&gt;<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> + <a class="code" href="dwarf2read_8c.html#a64dfe5d648dc5396cd471de3540fef30">get_cu_length</a> (header))
<a name="l04259"></a>04259       &gt; section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>)
<a name="l04260"></a>04260     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: bad length (0x%lx) in compilation unit header &quot;</span>
<a name="l04261"></a>04261            <span class="stringliteral">&quot;(offset 0x%lx + 0) [in module %s]&quot;</span>),
<a name="l04262"></a>04262            (<span class="keywordtype">long</span>) header-&gt;<a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a>, (<span class="keywordtype">long</span>) header-&gt;<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>,
<a name="l04263"></a>04263            filename);
<a name="l04264"></a>04264 }
<a name="l04265"></a>04265 
<a name="l04266"></a>04266 <span class="comment">/* Read in a CU/TU header and perform some basic error checking.</span>
<a name="l04267"></a>04267 <span class="comment">   The contents of the header are stored in HEADER.</span>
<a name="l04268"></a>04268 <span class="comment">   The result is a pointer to the start of the first DIE.  */</span>
<a name="l04269"></a>04269 
<a name="l04270"></a>04270 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l04271"></a><a class="code" href="dwarf2read_8c.html#ab4a5d6610652463f5cf265ddbdfb8d58">04271</a> <a class="code" href="dwarf2read_8c.html#ab4a5d6610652463f5cf265ddbdfb8d58">read_and_check_comp_unit_head</a> (<span class="keyword">struct</span> <a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *header,
<a name="l04272"></a>04272                                <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section,
<a name="l04273"></a>04273                                <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *abbrev_section,
<a name="l04274"></a>04274                                <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l04275"></a>04275                                <span class="keywordtype">int</span> is_debug_types_section)
<a name="l04276"></a>04276 {
<a name="l04277"></a>04277   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *beg_of_comp_unit = info_ptr;
<a name="l04278"></a>04278   bfd *abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l04279"></a>04279 
<a name="l04280"></a>04280   header-&gt;<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = beg_of_comp_unit - section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>;
<a name="l04281"></a>04281 
<a name="l04282"></a>04282   info_ptr = <a class="code" href="dwarf2read_8c.html#af69b698a6799f5cd7603c38c2be1cecb">read_comp_unit_head</a> (header, info_ptr, abfd);
<a name="l04283"></a>04283 
<a name="l04284"></a>04284   <span class="comment">/* If we&#39;re reading a type unit, skip over the signature and</span>
<a name="l04285"></a>04285 <span class="comment">     type_offset fields.  */</span>
<a name="l04286"></a>04286   <span class="keywordflow">if</span> (is_debug_types_section)
<a name="l04287"></a>04287     info_ptr += 8 <span class="comment">/*signature*/</span> + header-&gt;<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>;
<a name="l04288"></a>04288 
<a name="l04289"></a>04289   header-&gt;<a class="code" href="structcomp__unit__head.html#a08a38b7787804c4cb0e7baa1280da286">first_die_offset</a>.<a class="code" href="structcu__offset.html#a19224b0dc5f0bc49babd2b7701a8d63e">cu_off</a> = info_ptr - beg_of_comp_unit;
<a name="l04290"></a>04290 
<a name="l04291"></a>04291   <a class="code" href="dwarf2read_8c.html#aef690d08ba1f15fc120ed8687a521aa8">error_check_comp_unit_head</a> (header, section, abbrev_section);
<a name="l04292"></a>04292 
<a name="l04293"></a>04293   <span class="keywordflow">return</span> info_ptr;
<a name="l04294"></a>04294 }
<a name="l04295"></a>04295 
<a name="l04296"></a>04296 <span class="comment">/* Read in the types comp unit header information from .debug_types entry at</span>
<a name="l04297"></a>04297 <span class="comment">   types_ptr.  The result is a pointer to one past the end of the header.  */</span>
<a name="l04298"></a>04298 
<a name="l04299"></a>04299 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l04300"></a><a class="code" href="dwarf2read_8c.html#a3e530db440df1aa6cf5bae99d3c49667">04300</a> <a class="code" href="dwarf2read_8c.html#a3e530db440df1aa6cf5bae99d3c49667">read_and_check_type_unit_head</a> (<span class="keyword">struct</span> <a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *header,
<a name="l04301"></a>04301                                <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section,
<a name="l04302"></a>04302                                <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *abbrev_section,
<a name="l04303"></a>04303                                <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l04304"></a>04304                                <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> *signature,
<a name="l04305"></a>04305                                <a class="code" href="structcu__offset.html">cu_offset</a> *type_offset_in_tu)
<a name="l04306"></a>04306 {
<a name="l04307"></a>04307   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *beg_of_comp_unit = info_ptr;
<a name="l04308"></a>04308   bfd *abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l04309"></a>04309 
<a name="l04310"></a>04310   header-&gt;<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = beg_of_comp_unit - section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>;
<a name="l04311"></a>04311 
<a name="l04312"></a>04312   info_ptr = <a class="code" href="dwarf2read_8c.html#af69b698a6799f5cd7603c38c2be1cecb">read_comp_unit_head</a> (header, info_ptr, abfd);
<a name="l04313"></a>04313 
<a name="l04314"></a>04314   <span class="comment">/* If we&#39;re reading a type unit, skip over the signature and</span>
<a name="l04315"></a>04315 <span class="comment">     type_offset fields.  */</span>
<a name="l04316"></a>04316   <span class="keywordflow">if</span> (signature != NULL)
<a name="l04317"></a>04317     *signature = <a class="code" href="dwarf2read_8c.html#af21c01feb67cfb3cd240c3ac803dd021">read_8_bytes</a> (abfd, info_ptr);
<a name="l04318"></a>04318   info_ptr += 8;
<a name="l04319"></a>04319   <span class="keywordflow">if</span> (type_offset_in_tu != NULL)
<a name="l04320"></a>04320     type_offset_in_tu-&gt;<a class="code" href="structcu__offset.html#a19224b0dc5f0bc49babd2b7701a8d63e">cu_off</a> = <a class="code" href="dwarf2read_8c.html#a7d7df1bb27bd8e2cdd3b27bafd16640b">read_offset_1</a> (abfd, info_ptr,
<a name="l04321"></a>04321                                                header-&gt;<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>);
<a name="l04322"></a>04322   info_ptr += header-&gt;<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>;
<a name="l04323"></a>04323 
<a name="l04324"></a>04324   header-&gt;<a class="code" href="structcomp__unit__head.html#a08a38b7787804c4cb0e7baa1280da286">first_die_offset</a>.<a class="code" href="structcu__offset.html#a19224b0dc5f0bc49babd2b7701a8d63e">cu_off</a> = info_ptr - beg_of_comp_unit;
<a name="l04325"></a>04325 
<a name="l04326"></a>04326   <a class="code" href="dwarf2read_8c.html#aef690d08ba1f15fc120ed8687a521aa8">error_check_comp_unit_head</a> (header, section, abbrev_section);
<a name="l04327"></a>04327 
<a name="l04328"></a>04328   <span class="keywordflow">return</span> info_ptr;
<a name="l04329"></a>04329 }
<a name="l04330"></a>04330 
<a name="l04331"></a>04331 <span class="comment">/* Fetch the abbreviation table offset from a comp or type unit header.  */</span>
<a name="l04332"></a>04332 
<a name="l04333"></a>04333 <span class="keyword">static</span> <a class="code" href="structsect__offset.html">sect_offset</a>
<a name="l04334"></a><a class="code" href="dwarf2read_8c.html#a425a94e1261e39a64375fdca7368bca2">04334</a> <a class="code" href="dwarf2read_8c.html#a425a94e1261e39a64375fdca7368bca2">read_abbrev_offset</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section,
<a name="l04335"></a>04335                     <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>)
<a name="l04336"></a>04336 {
<a name="l04337"></a>04337   bfd *abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l04338"></a>04338   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr;
<a name="l04339"></a>04339   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length, initial_length_size, offset_size;
<a name="l04340"></a>04340   <a class="code" href="structsect__offset.html">sect_offset</a> abbrev_offset;
<a name="l04341"></a>04341 
<a name="l04342"></a>04342   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (dwarf2_per_objfile-&gt;objfile, section);
<a name="l04343"></a>04343   info_ptr = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l04344"></a>04344   length = <a class="code" href="dwarf2read_8c.html#a40cbc7bcde605127cf1baef337c57f9e">read_initial_length</a> (abfd, info_ptr, &amp;initial_length_size);
<a name="l04345"></a>04345   offset_size = initial_length_size == 4 ? 4 : 8;
<a name="l04346"></a>04346   info_ptr += initial_length_size + 2 <span class="comment">/*version*/</span>;
<a name="l04347"></a>04347   abbrev_offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = <a class="code" href="dwarf2read_8c.html#a7d7df1bb27bd8e2cdd3b27bafd16640b">read_offset_1</a> (abfd, info_ptr, offset_size);
<a name="l04348"></a>04348   <span class="keywordflow">return</span> abbrev_offset;
<a name="l04349"></a>04349 }
<a name="l04350"></a>04350 
<a name="l04351"></a>04351 <span class="comment">/* Allocate a new partial symtab for file named NAME and mark this new</span>
<a name="l04352"></a>04352 <span class="comment">   partial symtab as being an include of PST.  */</span>
<a name="l04353"></a>04353 
<a name="l04354"></a>04354 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04355"></a><a class="code" href="dwarf2read_8c.html#a2c89367081c50c376581cfa9e6ea64cc">04355</a> <a class="code" href="dwarf2read_8c.html#a2c89367081c50c376581cfa9e6ea64cc">dwarf2_create_include_psymtab</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst,
<a name="l04356"></a>04356                                <span class="keyword">struct</span> objfile *objfile)
<a name="l04357"></a>04357 {
<a name="l04358"></a>04358   <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *subpst = <a class="code" href="psympriv_8h.html#aaab6295ffb54728aaa0817aa18c4c61c">allocate_psymtab</a> (name, objfile);
<a name="l04359"></a>04359 
<a name="l04360"></a>04360   <span class="keywordflow">if</span> (!IS_ABSOLUTE_PATH (subpst-&gt;<a class="code" href="structpartial__symtab.html#a6ea70ac87d6dbd541967bdd6dacd7321">filename</a>))
<a name="l04361"></a>04361     {
<a name="l04362"></a>04362       <span class="comment">/* It shares objfile-&gt;objfile_obstack.  */</span>
<a name="l04363"></a>04363       subpst-&gt;<a class="code" href="structpartial__symtab.html#a4861f775b1cc7a848abdf336238dbb37">dirname</a> = pst-&gt;<a class="code" href="structpartial__symtab.html#a4861f775b1cc7a848abdf336238dbb37">dirname</a>;
<a name="l04364"></a>04364     }
<a name="l04365"></a>04365 
<a name="l04366"></a>04366   subpst-&gt;<a class="code" href="structpartial__symtab.html#abdbad327cdb56a7663e18f1f14e18730">section_offsets</a> = pst-&gt;<a class="code" href="structpartial__symtab.html#abdbad327cdb56a7663e18f1f14e18730">section_offsets</a>;
<a name="l04367"></a>04367   subpst-&gt;<a class="code" href="structpartial__symtab.html#a194e7d3c21d81ce56b81d1fe02e1dbc3">textlow</a> = 0;
<a name="l04368"></a>04368   subpst-&gt;<a class="code" href="structpartial__symtab.html#aa582095c68fb326f3042ad672527a438">texthigh</a> = 0;
<a name="l04369"></a>04369 
<a name="l04370"></a>04370   subpst-&gt;<a class="code" href="structpartial__symtab.html#a0b7bd5bada02a362357552790b111c23">dependencies</a> = (<span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> **)
<a name="l04371"></a>04371     obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l04372"></a>04372                    sizeof (<span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *));
<a name="l04373"></a>04373   subpst-&gt;<a class="code" href="structpartial__symtab.html#a0b7bd5bada02a362357552790b111c23">dependencies</a>[0] = pst;
<a name="l04374"></a>04374   subpst-&gt;<a class="code" href="structpartial__symtab.html#a917b503a5e1f7c2bb60feb6ff1e3b197">number_of_dependencies</a> = 1;
<a name="l04375"></a>04375 
<a name="l04376"></a>04376   subpst-&gt;<a class="code" href="structpartial__symtab.html#ae11f1094416fd506398f4a58fe4fa405">globals_offset</a> = 0;
<a name="l04377"></a>04377   subpst-&gt;<a class="code" href="structpartial__symtab.html#ab26039959ff434afcf130049cfa8d27d">n_global_syms</a> = 0;
<a name="l04378"></a>04378   subpst-&gt;<a class="code" href="structpartial__symtab.html#a36b8c771ea2906e413b8f1fffe1f4d10">statics_offset</a> = 0;
<a name="l04379"></a>04379   subpst-&gt;<a class="code" href="structpartial__symtab.html#a0fd67e243d440beaf6cc4757a97ff9b0">n_static_syms</a> = 0;
<a name="l04380"></a>04380   subpst-&gt;<a class="code" href="structpartial__symtab.html#a1bbcf18c88d09005b43f960b6f3575f8">symtab</a> = NULL;
<a name="l04381"></a>04381   subpst-&gt;<a class="code" href="structpartial__symtab.html#a51a53dce450ff3473f03a903aa06b263">read_symtab</a> = pst-&gt;<a class="code" href="structpartial__symtab.html#a51a53dce450ff3473f03a903aa06b263">read_symtab</a>;
<a name="l04382"></a>04382   subpst-&gt;<a class="code" href="structpartial__symtab.html#a11d8e59b962db1317c8c23f917dbed42">readin</a> = 0;
<a name="l04383"></a>04383 
<a name="l04384"></a>04384   <span class="comment">/* No private part is necessary for include psymtabs.  This property</span>
<a name="l04385"></a>04385 <span class="comment">     can be used to differentiate between such include psymtabs and</span>
<a name="l04386"></a>04386 <span class="comment">     the regular ones.  */</span>
<a name="l04387"></a>04387   subpst-&gt;<a class="code" href="structpartial__symtab.html#a1d7dd223683b0ca2baeaa6bf5c3e90a3">read_symtab_private</a> = NULL;
<a name="l04388"></a>04388 }
<a name="l04389"></a>04389 
<a name="l04390"></a>04390 <span class="comment">/* Read the Line Number Program data and extract the list of files</span>
<a name="l04391"></a>04391 <span class="comment">   included by the source file represented by PST.  Build an include</span>
<a name="l04392"></a>04392 <span class="comment">   partial symtab for each of these included files.  */</span>
<a name="l04393"></a>04393 
<a name="l04394"></a>04394 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04395"></a><a class="code" href="dwarf2read_8c.html#a09cdb6c79e4ca34592ff1928d6f48113">04395</a> <a class="code" href="dwarf2read_8c.html#a09cdb6c79e4ca34592ff1928d6f48113">dwarf2_build_include_psymtabs</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l04396"></a>04396                                <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l04397"></a>04397                                <span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst)
<a name="l04398"></a>04398 {
<a name="l04399"></a>04399   <span class="keyword">struct </span><a class="code" href="structline__header.html">line_header</a> *lh = NULL;
<a name="l04400"></a>04400   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l04401"></a>04401 
<a name="l04402"></a>04402   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_stmt_list, cu);
<a name="l04403"></a>04403   <span class="keywordflow">if</span> (attr)
<a name="l04404"></a>04404     lh = <a class="code" href="dwarf2read_8c.html#af87c579a0baccecf09b54fc18af2dea5">dwarf_decode_line_header</a> (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr), cu);
<a name="l04405"></a>04405   <span class="keywordflow">if</span> (lh == NULL)
<a name="l04406"></a>04406     <span class="keywordflow">return</span>;  <span class="comment">/* No linetable, so no includes.  */</span>
<a name="l04407"></a>04407 
<a name="l04408"></a>04408   <span class="comment">/* NOTE: pst-&gt;dirname is DW_AT_comp_dir (if present).  */</span>
<a name="l04409"></a>04409   <a class="code" href="dwarf2read_8c.html#af810de33caeeaf4969d37ee378ef6e06">dwarf_decode_lines</a> (lh, pst-&gt;<a class="code" href="structpartial__symtab.html#a4861f775b1cc7a848abdf336238dbb37">dirname</a>, cu, pst, 1);
<a name="l04410"></a>04410 
<a name="l04411"></a>04411   <a class="code" href="dwarf2read_8c.html#a2b16344b24303ef21765208ef32dfe7a">free_line_header</a> (lh);
<a name="l04412"></a>04412 }
<a name="l04413"></a>04413 
<a name="l04414"></a>04414 <span class="keyword">static</span> hashval_t
<a name="l04415"></a><a class="code" href="dwarf2read_8c.html#a94ba38cd06d8e88a38a856e57eff272c">04415</a> <a class="code" href="dwarf2read_8c.html#a94ba38cd06d8e88a38a856e57eff272c">hash_signatured_type</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item)
<a name="l04416"></a>04416 {
<a name="l04417"></a>04417   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type = item;
<a name="l04418"></a>04418 
<a name="l04419"></a>04419   <span class="comment">/* This drops the top 32 bits of the signature, but is ok for a hash.  */</span>
<a name="l04420"></a>04420   <span class="keywordflow">return</span> sig_type-&gt;<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a>;
<a name="l04421"></a>04421 }
<a name="l04422"></a>04422 
<a name="l04423"></a>04423 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04424"></a><a class="code" href="dwarf2read_8c.html#a6161f1f98a45d4a8eefcced5c4b08227">04424</a> <a class="code" href="dwarf2read_8c.html#a6161f1f98a45d4a8eefcced5c4b08227">eq_signatured_type</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item_lhs, <span class="keyword">const</span> <span class="keywordtype">void</span> *item_rhs)
<a name="l04425"></a>04425 {
<a name="l04426"></a>04426   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *lhs = item_lhs;
<a name="l04427"></a>04427   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *rhs = item_rhs;
<a name="l04428"></a>04428 
<a name="l04429"></a>04429   <span class="keywordflow">return</span> lhs-&gt;<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a> == rhs-&gt;<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a>;
<a name="l04430"></a>04430 }
<a name="l04431"></a>04431 
<a name="l04432"></a>04432 <span class="comment">/* Allocate a hash table for signatured types.  */</span>
<a name="l04433"></a>04433 
<a name="l04434"></a>04434 <span class="keyword">static</span> htab_t
<a name="l04435"></a><a class="code" href="dwarf2read_8c.html#ad578387bf4a7a34a17bed7e05e8d4427">04435</a> <a class="code" href="dwarf2read_8c.html#ad578387bf4a7a34a17bed7e05e8d4427">allocate_signatured_type_table</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l04436"></a>04436 {
<a name="l04437"></a>04437   <span class="keywordflow">return</span> htab_create_alloc_ex (41,
<a name="l04438"></a>04438                                <a class="code" href="dwarf2read_8c.html#a94ba38cd06d8e88a38a856e57eff272c">hash_signatured_type</a>,
<a name="l04439"></a>04439                                <a class="code" href="dwarf2read_8c.html#a6161f1f98a45d4a8eefcced5c4b08227">eq_signatured_type</a>,
<a name="l04440"></a>04440                                NULL,
<a name="l04441"></a>04441                                &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l04442"></a>04442                                <a class="code" href="utils_8c.html#a64b0a5e317b6f45f062aa8356111644b">hashtab_obstack_allocate</a>,
<a name="l04443"></a>04443                                <a class="code" href="utils_8c.html#af32d0d55c7c49d59093e66ef695f9513">dummy_obstack_deallocate</a>);
<a name="l04444"></a>04444 }
<a name="l04445"></a>04445 
<a name="l04446"></a>04446 <span class="comment">/* A helper function to add a signatured type CU to a table.  */</span>
<a name="l04447"></a>04447 
<a name="l04448"></a>04448 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04449"></a><a class="code" href="dwarf2read_8c.html#a6492bc99f285862f30f73a3e880ee5cf">04449</a> <a class="code" href="dwarf2read_8c.html#a6492bc99f285862f30f73a3e880ee5cf">add_signatured_type_cu_to_table</a> (<span class="keywordtype">void</span> **slot, <span class="keywordtype">void</span> *datum)
<a name="l04450"></a>04450 {
<a name="l04451"></a>04451   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sigt = *slot;
<a name="l04452"></a>04452   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> ***datap = datum;
<a name="l04453"></a>04453 
<a name="l04454"></a>04454   **datap = sigt;
<a name="l04455"></a>04455   ++*datap;
<a name="l04456"></a>04456 
<a name="l04457"></a>04457   <span class="keywordflow">return</span> 1;
<a name="l04458"></a>04458 }
<a name="l04459"></a>04459 
<a name="l04460"></a>04460 <span class="comment">/* Create the hash table of all entries in the .debug_types</span>
<a name="l04461"></a>04461 <span class="comment">   (or .debug_types.dwo) section(s).</span>
<a name="l04462"></a>04462 <span class="comment">   If reading a DWO file, then DWO_FILE is a pointer to the DWO file object,</span>
<a name="l04463"></a>04463 <span class="comment">   otherwise it is NULL.</span>
<a name="l04464"></a>04464 <span class="comment"></span>
<a name="l04465"></a>04465 <span class="comment">   The result is a pointer to the hash table or NULL if there are no types.</span>
<a name="l04466"></a>04466 <span class="comment"></span>
<a name="l04467"></a>04467 <span class="comment">   Note: This function processes DWO files only, not DWP files.  */</span>
<a name="l04468"></a>04468 
<a name="l04469"></a>04469 <span class="keyword">static</span> htab_t
<a name="l04470"></a><a class="code" href="dwarf2read_8c.html#a3e7ce9c1cd2b774ed73474dd4576de01">04470</a> <a class="code" href="dwarf2read_8c.html#a3e7ce9c1cd2b774ed73474dd4576de01">create_debug_types_hash_table</a> (<span class="keyword">struct</span> <a class="code" href="structdwo__file.html">dwo_file</a> *<a class="code" href="structdwo__file.html">dwo_file</a>,
<a name="l04471"></a>04471                                <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>) *types)
<a name="l04472"></a>04472 {
<a name="l04473"></a>04473   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l04474"></a>04474   htab_t types_htab = NULL;
<a name="l04475"></a>04475   <span class="keywordtype">int</span> ix;
<a name="l04476"></a>04476   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section;
<a name="l04477"></a>04477   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *abbrev_section;
<a name="l04478"></a>04478 
<a name="l04479"></a>04479   <span class="keywordflow">if</span> (<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>, types))
<a name="l04480"></a>04480     <span class="keywordflow">return</span> NULL;
<a name="l04481"></a>04481 
<a name="l04482"></a>04482   abbrev_section = (dwo_file != NULL
<a name="l04483"></a>04483                     ? &amp;dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#a77a177199056d70f8c5379e116538cff">abbrev</a>
<a name="l04484"></a>04484                     : &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a65f092d6a408e872a5b5f724728353de">abbrev</a>);
<a name="l04485"></a>04485 
<a name="l04486"></a>04486   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l04487"></a>04487     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Reading .debug_types%s for %s:\n&quot;</span>,
<a name="l04488"></a>04488                         dwo_file ? <span class="stringliteral">&quot;.dwo&quot;</span> : <span class="stringliteral">&quot;&quot;</span>,
<a name="l04489"></a>04489                         <a class="code" href="dwarf2read_8c.html#a1c841524fdd0bd73272dad700a7452f6">get_section_file_name</a> (abbrev_section));
<a name="l04490"></a>04490 
<a name="l04491"></a>04491   <span class="keywordflow">for</span> (ix = 0;
<a name="l04492"></a>04492        <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>, types, ix, section);
<a name="l04493"></a>04493        ++ix)
<a name="l04494"></a>04494     {
<a name="l04495"></a>04495       bfd *abfd;
<a name="l04496"></a>04496       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr, *end_ptr;
<a name="l04497"></a>04497 
<a name="l04498"></a>04498       <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, section);
<a name="l04499"></a>04499       info_ptr = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>;
<a name="l04500"></a>04500 
<a name="l04501"></a>04501       <span class="keywordflow">if</span> (info_ptr == NULL)
<a name="l04502"></a>04502         <span class="keywordflow">continue</span>;
<a name="l04503"></a>04503 
<a name="l04504"></a>04504       <span class="comment">/* We can&#39;t set abfd until now because the section may be empty or</span>
<a name="l04505"></a>04505 <span class="comment">         not present, in which case the bfd is unknown.  */</span>
<a name="l04506"></a>04506       abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l04507"></a>04507 
<a name="l04508"></a>04508       <span class="comment">/* We don&#39;t use init_cutu_and_read_dies_simple, or some such, here</span>
<a name="l04509"></a>04509 <span class="comment">         because we don&#39;t need to read any dies: the signature is in the</span>
<a name="l04510"></a>04510 <span class="comment">         header.  */</span>
<a name="l04511"></a>04511 
<a name="l04512"></a>04512       end_ptr = info_ptr + section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>;
<a name="l04513"></a>04513       <span class="keywordflow">while</span> (info_ptr &lt; end_ptr)
<a name="l04514"></a>04514         {
<a name="l04515"></a>04515           <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l04516"></a>04516           <a class="code" href="structcu__offset.html">cu_offset</a> type_offset_in_tu;
<a name="l04517"></a>04517           <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> signature;
<a name="l04518"></a>04518           <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type;
<a name="l04519"></a>04519           <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *dwo_tu;
<a name="l04520"></a>04520           <span class="keywordtype">void</span> **slot;
<a name="l04521"></a>04521           <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *ptr = info_ptr;
<a name="l04522"></a>04522           <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> header;
<a name="l04523"></a>04523           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a>;
<a name="l04524"></a>04524 
<a name="l04525"></a>04525           offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = ptr - section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>;
<a name="l04526"></a>04526 
<a name="l04527"></a>04527           <span class="comment">/* We need to read the type&#39;s signature in order to build the hash</span>
<a name="l04528"></a>04528 <span class="comment">             table, but we don&#39;t need anything else just yet.  */</span>
<a name="l04529"></a>04529 
<a name="l04530"></a>04530           ptr = <a class="code" href="dwarf2read_8c.html#a3e530db440df1aa6cf5bae99d3c49667">read_and_check_type_unit_head</a> (&amp;header, section,
<a name="l04531"></a>04531                                                abbrev_section, ptr,
<a name="l04532"></a>04532                                                &amp;signature, &amp;type_offset_in_tu);
<a name="l04533"></a>04533 
<a name="l04534"></a>04534           length = <a class="code" href="dwarf2read_8c.html#a64dfe5d648dc5396cd471de3540fef30">get_cu_length</a> (&amp;header);
<a name="l04535"></a>04535 
<a name="l04536"></a>04536           <span class="comment">/* Skip dummy type units.  */</span>
<a name="l04537"></a>04537           <span class="keywordflow">if</span> (ptr &gt;= info_ptr + length
<a name="l04538"></a>04538               || <a class="code" href="dwarf2read_8c.html#a750ce8dd923161d4fd41793c6965ca6c">peek_abbrev_code</a> (abfd, ptr) == 0)
<a name="l04539"></a>04539             {
<a name="l04540"></a>04540               info_ptr += <a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a>;
<a name="l04541"></a>04541               <span class="keywordflow">continue</span>;
<a name="l04542"></a>04542             }
<a name="l04543"></a>04543 
<a name="l04544"></a>04544           <span class="keywordflow">if</span> (types_htab == NULL)
<a name="l04545"></a>04545             {
<a name="l04546"></a>04546               <span class="keywordflow">if</span> (dwo_file)
<a name="l04547"></a>04547                 types_htab = <a class="code" href="dwarf2read_8c.html#ae4fe7bb1a521f3edafb2a10a3af6385a">allocate_dwo_unit_table</a> (objfile);
<a name="l04548"></a>04548               <span class="keywordflow">else</span>
<a name="l04549"></a>04549                 types_htab = <a class="code" href="dwarf2read_8c.html#ad578387bf4a7a34a17bed7e05e8d4427">allocate_signatured_type_table</a> (objfile);
<a name="l04550"></a>04550             }
<a name="l04551"></a>04551 
<a name="l04552"></a>04552           <span class="keywordflow">if</span> (dwo_file)
<a name="l04553"></a>04553             {
<a name="l04554"></a>04554               sig_type = NULL;
<a name="l04555"></a>04555               dwo_tu = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l04556"></a>04556                                        <span class="keyword">struct</span> <a class="code" href="structdwo__unit.html">dwo_unit</a>);
<a name="l04557"></a>04557               dwo_tu-&gt;<a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">dwo_file</a> = dwo_file;
<a name="l04558"></a>04558               dwo_tu-&gt;<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a> = signature;
<a name="l04559"></a>04559               dwo_tu-&gt;<a class="code" href="structdwo__unit.html#a88b2cadfe8ed91777ee37fe16bfdc761">type_offset_in_tu</a> = type_offset_in_tu;
<a name="l04560"></a>04560               dwo_tu-&gt;<a class="code" href="structdwo__unit.html#a808127fb35d399faddd33a3b28e5ec06">section</a> = section;
<a name="l04561"></a>04561               dwo_tu-&gt;<a class="code" href="structdwo__unit.html#a39192bd18fec52ffbb9cda4fc9d631e0">offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l04562"></a>04562               dwo_tu-&gt;<a class="code" href="structdwo__unit.html#adf4afc1b8bd4d2b879762c33930ef988">length</a> = <a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a>;
<a name="l04563"></a>04563             }
<a name="l04564"></a>04564           <span class="keywordflow">else</span>
<a name="l04565"></a>04565             {
<a name="l04566"></a>04566               <span class="comment">/* N.B.: type_offset is not usable if this type uses a DWO file.</span>
<a name="l04567"></a>04567 <span class="comment">                 The real type_offset is in the DWO file.  */</span>
<a name="l04568"></a>04568               dwo_tu = NULL;
<a name="l04569"></a>04569               sig_type = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l04570"></a>04570                                          <span class="keyword">struct</span> <a class="code" href="structsignatured__type.html">signatured_type</a>);
<a name="l04571"></a>04571               sig_type-&gt;<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a> = signature;
<a name="l04572"></a>04572               sig_type-&gt;<a class="code" href="structsignatured__type.html#ab152a3e1f687ff6464b369502ce745a9">type_offset_in_tu</a> = type_offset_in_tu;
<a name="l04573"></a>04573               sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a> = objfile;
<a name="l04574"></a>04574               sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a> = 1;
<a name="l04575"></a>04575               sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a> = section;
<a name="l04576"></a>04576               sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l04577"></a>04577               sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a> = <a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a>;
<a name="l04578"></a>04578             }
<a name="l04579"></a>04579 
<a name="l04580"></a>04580           slot = htab_find_slot (types_htab,
<a name="l04581"></a>04581                                  dwo_file ? (<span class="keywordtype">void</span>*) dwo_tu : (<span class="keywordtype">void</span> *) sig_type,
<a name="l04582"></a>04582                                  INSERT);
<a name="l04583"></a>04583           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (slot != NULL);
<a name="l04584"></a>04584           <span class="keywordflow">if</span> (*slot != NULL)
<a name="l04585"></a>04585             {
<a name="l04586"></a>04586               <a class="code" href="structsect__offset.html">sect_offset</a> dup_offset;
<a name="l04587"></a>04587 
<a name="l04588"></a>04588               <span class="keywordflow">if</span> (dwo_file)
<a name="l04589"></a>04589                 {
<a name="l04590"></a>04590                   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *dup_tu = *slot;
<a name="l04591"></a>04591 
<a name="l04592"></a>04592                   dup_offset = dup_tu-&gt;<a class="code" href="structdwo__unit.html#a39192bd18fec52ffbb9cda4fc9d631e0">offset</a>;
<a name="l04593"></a>04593                 }
<a name="l04594"></a>04594               <span class="keywordflow">else</span>
<a name="l04595"></a>04595                 {
<a name="l04596"></a>04596                   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *dup_tu = *slot;
<a name="l04597"></a>04597 
<a name="l04598"></a>04598                   dup_offset = dup_tu-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>;
<a name="l04599"></a>04599                 }
<a name="l04600"></a>04600 
<a name="l04601"></a>04601               <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l04602"></a>04602                          <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;debug type entry at offset 0x%x is duplicate to&quot;</span>
<a name="l04603"></a>04603                            <span class="stringliteral">&quot; the entry at offset 0x%x, signature %s&quot;</span>),
<a name="l04604"></a>04604                          offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, dup_offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>,
<a name="l04605"></a>04605                          <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (signature));
<a name="l04606"></a>04606             }
<a name="l04607"></a>04607           *slot = dwo_file ? (<span class="keywordtype">void</span> *) dwo_tu : (<span class="keywordtype">void</span> *) sig_type;
<a name="l04608"></a>04608 
<a name="l04609"></a>04609           <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l04610"></a>04610             <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;  offset 0x%x, signature %s\n&quot;</span>,
<a name="l04611"></a>04611                                 offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>,
<a name="l04612"></a>04612                                 <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (signature));
<a name="l04613"></a>04613 
<a name="l04614"></a>04614           info_ptr += length;
<a name="l04615"></a>04615         }
<a name="l04616"></a>04616     }
<a name="l04617"></a>04617 
<a name="l04618"></a>04618   <span class="keywordflow">return</span> types_htab;
<a name="l04619"></a>04619 }
<a name="l04620"></a>04620 
<a name="l04621"></a>04621 <span class="comment">/* Create the hash table of all entries in the .debug_types section,</span>
<a name="l04622"></a>04622 <span class="comment">   and initialize all_type_units.</span>
<a name="l04623"></a>04623 <span class="comment">   The result is zero if there is an error (e.g. missing .debug_types section),</span>
<a name="l04624"></a>04624 <span class="comment">   otherwise non-zero.  */</span>
<a name="l04625"></a>04625 
<a name="l04626"></a>04626 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04627"></a><a class="code" href="dwarf2read_8c.html#a74edb9fb71ae3b0318ea886c49b697ef">04627</a> <a class="code" href="dwarf2read_8c.html#a74edb9fb71ae3b0318ea886c49b697ef">create_all_type_units</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l04628"></a>04628 {
<a name="l04629"></a>04629   htab_t types_htab;
<a name="l04630"></a>04630   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> **iter;
<a name="l04631"></a>04631 
<a name="l04632"></a>04632   types_htab = <a class="code" href="dwarf2read_8c.html#a3e7ce9c1cd2b774ed73474dd4576de01">create_debug_types_hash_table</a> (NULL, dwarf2_per_objfile-&gt;types);
<a name="l04633"></a>04633   <span class="keywordflow">if</span> (types_htab == NULL)
<a name="l04634"></a>04634     {
<a name="l04635"></a>04635       dwarf2_per_objfile-&gt;signatured_types = NULL;
<a name="l04636"></a>04636       <span class="keywordflow">return</span> 0;
<a name="l04637"></a>04637     }
<a name="l04638"></a>04638 
<a name="l04639"></a>04639   dwarf2_per_objfile-&gt;signatured_types = types_htab;
<a name="l04640"></a>04640 
<a name="l04641"></a>04641   dwarf2_per_objfile-&gt;n_type_units = htab_elements (types_htab);
<a name="l04642"></a>04642   dwarf2_per_objfile-&gt;all_type_units
<a name="l04643"></a>04643     = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (dwarf2_per_objfile-&gt;n_type_units
<a name="l04644"></a>04644                * sizeof (<span class="keyword">struct</span> <a class="code" href="structsignatured__type.html">signatured_type</a> *));
<a name="l04645"></a>04645   iter = &amp;dwarf2_per_objfile-&gt;all_type_units[0];
<a name="l04646"></a>04646   htab_traverse_noresize (types_htab, <a class="code" href="dwarf2read_8c.html#a6492bc99f285862f30f73a3e880ee5cf">add_signatured_type_cu_to_table</a>, &amp;iter);
<a name="l04647"></a>04647   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (iter - &amp;dwarf2_per_objfile-&gt;all_type_units[0]
<a name="l04648"></a>04648               == dwarf2_per_objfile-&gt;n_type_units);
<a name="l04649"></a>04649 
<a name="l04650"></a>04650   <span class="keywordflow">return</span> 1;
<a name="l04651"></a>04651 }
<a name="l04652"></a>04652 
<a name="l04653"></a>04653 <span class="comment">/* Subroutine of lookup_dwo_signatured_type and lookup_dwp_signatured_type.</span>
<a name="l04654"></a>04654 <span class="comment">   Fill in SIG_ENTRY with DWO_ENTRY.  */</span>
<a name="l04655"></a>04655 
<a name="l04656"></a>04656 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04657"></a><a class="code" href="dwarf2read_8c.html#aa71f283d4b51463801afb8bfed6f272b">04657</a> <a class="code" href="dwarf2read_8c.html#aa71f283d4b51463801afb8bfed6f272b">fill_in_sig_entry_from_dwo_entry</a> (<span class="keyword">struct</span> objfile *objfile,
<a name="l04658"></a>04658                                   <span class="keyword">struct</span> <a class="code" href="structsignatured__type.html">signatured_type</a> *sig_entry,
<a name="l04659"></a>04659                                   <span class="keyword">struct</span> <a class="code" href="structdwo__unit.html">dwo_unit</a> *dwo_entry)
<a name="l04660"></a>04660 {
<a name="l04661"></a>04661   <span class="comment">/* Make sure we&#39;re not clobbering something we don&#39;t expect to.  */</span>
<a name="l04662"></a>04662   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (! sig_entry-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a2eed1245c96a6300453e610421b98b93">queued</a>);
<a name="l04663"></a>04663   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sig_entry-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> == NULL);
<a name="l04664"></a>04664   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sig_entry-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a> != NULL);
<a name="l04665"></a>04665   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sig_entry-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a> == NULL);
<a name="l04666"></a>04666   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sig_entry-&gt;<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a> == dwo_entry-&gt;<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>);
<a name="l04667"></a>04667   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sig_entry-&gt;<a class="code" href="structsignatured__type.html#aa8e49a69ad9d6311b553b063fa0fe62d">type_offset_in_section</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> == 0);
<a name="l04668"></a>04668   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sig_entry-&gt;<a class="code" href="structsignatured__type.html#ab10f6f2df0f7691aa8ca948e28cbcf1e">type_unit_group</a> == NULL);
<a name="l04669"></a>04669   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sig_entry-&gt;<a class="code" href="structsignatured__type.html#a8b6cf2131ff9f72ef62c56047f62f9d6">dwo_unit</a> == NULL);
<a name="l04670"></a>04670 
<a name="l04671"></a>04671   sig_entry-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a> = dwo_entry-&gt;<a class="code" href="structdwo__unit.html#a808127fb35d399faddd33a3b28e5ec06">section</a>;
<a name="l04672"></a>04672   sig_entry-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a> = dwo_entry-&gt;<a class="code" href="structdwo__unit.html#a39192bd18fec52ffbb9cda4fc9d631e0">offset</a>;
<a name="l04673"></a>04673   sig_entry-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a> = dwo_entry-&gt;<a class="code" href="structdwo__unit.html#adf4afc1b8bd4d2b879762c33930ef988">length</a>;
<a name="l04674"></a>04674   sig_entry-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a3015da55655aee818845295b4bbccee5">reading_dwo_directly</a> = 1;
<a name="l04675"></a>04675   sig_entry-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a> = objfile;
<a name="l04676"></a>04676   sig_entry-&gt;<a class="code" href="structsignatured__type.html#ab152a3e1f687ff6464b369502ce745a9">type_offset_in_tu</a> = dwo_entry-&gt;<a class="code" href="structdwo__unit.html#a88b2cadfe8ed91777ee37fe16bfdc761">type_offset_in_tu</a>;
<a name="l04677"></a>04677   sig_entry-&gt;<a class="code" href="structsignatured__type.html#a8b6cf2131ff9f72ef62c56047f62f9d6">dwo_unit</a> = dwo_entry;
<a name="l04678"></a>04678 }
<a name="l04679"></a>04679 
<a name="l04680"></a>04680 <span class="comment">/* Subroutine of lookup_signatured_type.</span>
<a name="l04681"></a>04681 <span class="comment">   If we haven&#39;t read the TU yet, create the signatured_type data structure</span>
<a name="l04682"></a>04682 <span class="comment">   for a TU to be read in directly from a DWO file, bypassing the stub.</span>
<a name="l04683"></a>04683 <span class="comment">   This is the &quot;Stay in DWO Optimization&quot;: When there is no DWP file and we&#39;re</span>
<a name="l04684"></a>04684 <span class="comment">   using .gdb_index, then when reading a CU we want to stay in the DWO file</span>
<a name="l04685"></a>04685 <span class="comment">   containing that CU.  Otherwise we could end up reading several other DWO</span>
<a name="l04686"></a>04686 <span class="comment">   files (due to comdat folding) to process the transitive closure of all the</span>
<a name="l04687"></a>04687 <span class="comment">   mentioned TUs, and that can be slow.  The current DWO file will have every</span>
<a name="l04688"></a>04688 <span class="comment">   type signature that it needs.</span>
<a name="l04689"></a>04689 <span class="comment">   We only do this for .gdb_index because in the psymtab case we already have</span>
<a name="l04690"></a>04690 <span class="comment">   to read all the DWOs to build the type unit groups.  */</span>
<a name="l04691"></a>04691 
<a name="l04692"></a>04692 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *
<a name="l04693"></a><a class="code" href="dwarf2read_8c.html#a27dc24ca2503391da92c3d4e1915c9ad">04693</a> <a class="code" href="dwarf2read_8c.html#a27dc24ca2503391da92c3d4e1915c9ad">lookup_dwo_signatured_type</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> sig)
<a name="l04694"></a>04694 {
<a name="l04695"></a>04695   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l04696"></a>04696   <span class="keyword">struct </span>dwo_file *dwo_file;
<a name="l04697"></a>04697   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> find_dwo_entry, *dwo_entry;
<a name="l04698"></a>04698   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> find_sig_entry, *sig_entry;
<a name="l04699"></a>04699 
<a name="l04700"></a>04700   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (cu-&gt;dwo_unit &amp;&amp; dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a>);
<a name="l04701"></a>04701 
<a name="l04702"></a>04702   <span class="comment">/* Note: cu-&gt;dwo_unit is the dwo_unit that references this TU, not the</span>
<a name="l04703"></a>04703 <span class="comment">     dwo_unit of the TU itself.  */</span>
<a name="l04704"></a>04704   dwo_file = cu-&gt;dwo_unit-&gt;dwo_file;
<a name="l04705"></a>04705 
<a name="l04706"></a>04706   <span class="comment">/* We only ever need to read in one copy of a signatured type.</span>
<a name="l04707"></a>04707 <span class="comment">     Just use the global signatured_types array.  If this is the first time</span>
<a name="l04708"></a>04708 <span class="comment">     we&#39;re reading this type, replace the recorded data from .gdb_index with</span>
<a name="l04709"></a>04709 <span class="comment">     this TU.  */</span>
<a name="l04710"></a>04710 
<a name="l04711"></a>04711   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;signatured_types == NULL)
<a name="l04712"></a>04712     <span class="keywordflow">return</span> NULL;
<a name="l04713"></a>04713   find_sig_entry.<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a> = sig;
<a name="l04714"></a>04714   sig_entry = htab_find (dwarf2_per_objfile-&gt;signatured_types, &amp;find_sig_entry);
<a name="l04715"></a>04715   <span class="keywordflow">if</span> (sig_entry == NULL)
<a name="l04716"></a>04716     <span class="keywordflow">return</span> NULL;
<a name="l04717"></a>04717 
<a name="l04718"></a>04718   <span class="comment">/* We can get here with the TU already read, *or* in the process of being</span>
<a name="l04719"></a>04719 <span class="comment">     read.  Don&#39;t reassign it if that&#39;s the case.  Also note that if the TU is</span>
<a name="l04720"></a>04720 <span class="comment">     already being read, it may not have come from a DWO, the program may be</span>
<a name="l04721"></a>04721 <span class="comment">     a mix of Fission-compiled code and non-Fission-compiled code.  */</span>
<a name="l04722"></a>04722   <span class="comment">/* Have we already tried to read this TU?  */</span>
<a name="l04723"></a>04723   <span class="keywordflow">if</span> (sig_entry-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#ace5ce61a37eefad9502e7d9881173de8">tu_read</a>)
<a name="l04724"></a>04724     <span class="keywordflow">return</span> sig_entry;
<a name="l04725"></a>04725 
<a name="l04726"></a>04726   <span class="comment">/* Ok, this is the first time we&#39;re reading this TU.  */</span>
<a name="l04727"></a>04727   <span class="keywordflow">if</span> (dwo_file-&gt;<a class="code" href="structdwo__file.html#a6ce93a5371a6e123e009d98d81f93ab2">tus</a> == NULL)
<a name="l04728"></a>04728     <span class="keywordflow">return</span> NULL;
<a name="l04729"></a>04729   find_dwo_entry.<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a> = sig;
<a name="l04730"></a>04730   dwo_entry = htab_find (dwo_file-&gt;<a class="code" href="structdwo__file.html#a6ce93a5371a6e123e009d98d81f93ab2">tus</a>, &amp;find_dwo_entry);
<a name="l04731"></a>04731   <span class="keywordflow">if</span> (dwo_entry == NULL)
<a name="l04732"></a>04732     <span class="keywordflow">return</span> NULL;
<a name="l04733"></a>04733 
<a name="l04734"></a>04734   <a class="code" href="dwarf2read_8c.html#aa71f283d4b51463801afb8bfed6f272b">fill_in_sig_entry_from_dwo_entry</a> (objfile, sig_entry, dwo_entry);
<a name="l04735"></a>04735   sig_entry-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#ace5ce61a37eefad9502e7d9881173de8">tu_read</a> = 1;
<a name="l04736"></a>04736   <span class="keywordflow">return</span> sig_entry;
<a name="l04737"></a>04737 }
<a name="l04738"></a>04738 
<a name="l04739"></a>04739 <span class="comment">/* Subroutine of lookup_dwp_signatured_type.</span>
<a name="l04740"></a>04740 <span class="comment">   Add an entry for signature SIG to dwarf2_per_objfile-&gt;signatured_types.  */</span>
<a name="l04741"></a>04741 
<a name="l04742"></a>04742 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *
<a name="l04743"></a><a class="code" href="dwarf2read_8c.html#abfd2c77b0ae141a1250a7889d1fbec4b">04743</a> <a class="code" href="dwarf2read_8c.html#abfd2c77b0ae141a1250a7889d1fbec4b">add_type_unit</a> (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> sig)
<a name="l04744"></a>04744 {
<a name="l04745"></a>04745   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l04746"></a>04746   <span class="keywordtype">int</span> n_type_units = dwarf2_per_objfile-&gt;n_type_units;
<a name="l04747"></a>04747   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type;
<a name="l04748"></a>04748   <span class="keywordtype">void</span> **slot;
<a name="l04749"></a>04749 
<a name="l04750"></a>04750   ++n_type_units;
<a name="l04751"></a>04751   dwarf2_per_objfile-&gt;all_type_units =
<a name="l04752"></a>04752     <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (dwarf2_per_objfile-&gt;all_type_units,
<a name="l04753"></a>04753               n_type_units * sizeof (<span class="keyword">struct</span> <a class="code" href="structsignatured__type.html">signatured_type</a> *));
<a name="l04754"></a>04754   dwarf2_per_objfile-&gt;n_type_units = n_type_units;
<a name="l04755"></a>04755   sig_type = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l04756"></a>04756                              <span class="keyword">struct</span> <a class="code" href="structsignatured__type.html">signatured_type</a>);
<a name="l04757"></a>04757   dwarf2_per_objfile-&gt;all_type_units[n_type_units - 1] = sig_type;
<a name="l04758"></a>04758   sig_type-&gt;<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a> = sig;
<a name="l04759"></a>04759   sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a> = 1;
<a name="l04760"></a>04760   sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a> =
<a name="l04761"></a>04761     <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l04762"></a>04762                     <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__quick__data.html">dwarf2_per_cu_quick_data</a>);
<a name="l04763"></a>04763   slot = htab_find_slot (dwarf2_per_objfile-&gt;signatured_types,
<a name="l04764"></a>04764                          sig_type, INSERT);
<a name="l04765"></a>04765   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (*slot == NULL);
<a name="l04766"></a>04766   *slot = sig_type;
<a name="l04767"></a>04767   <span class="comment">/* The rest of sig_type must be filled in by the caller.  */</span>
<a name="l04768"></a>04768   <span class="keywordflow">return</span> sig_type;
<a name="l04769"></a>04769 }
<a name="l04770"></a>04770 
<a name="l04771"></a>04771 <span class="comment">/* Subroutine of lookup_signatured_type.</span>
<a name="l04772"></a>04772 <span class="comment">   Look up the type for signature SIG, and if we can&#39;t find SIG in .gdb_index</span>
<a name="l04773"></a>04773 <span class="comment">   then try the DWP file.</span>
<a name="l04774"></a>04774 <span class="comment">   Normally this &quot;can&#39;t happen&quot;, but if there&#39;s a bug in signature</span>
<a name="l04775"></a>04775 <span class="comment">   generation and/or the DWP file is built incorrectly, it can happen.</span>
<a name="l04776"></a>04776 <span class="comment">   Using the type directly from the DWP file means we don&#39;t have the stub</span>
<a name="l04777"></a>04777 <span class="comment">   which has some useful attributes (e.g., DW_AT_comp_dir), but they&#39;re</span>
<a name="l04778"></a>04778 <span class="comment">   not critical.  [Eventually the stub may go away for type units anyway.]  */</span>
<a name="l04779"></a>04779 
<a name="l04780"></a>04780 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *
<a name="l04781"></a><a class="code" href="dwarf2read_8c.html#a94f5636b1b5af99ba6100fc1b5a70b46">04781</a> <a class="code" href="dwarf2read_8c.html#a94f5636b1b5af99ba6100fc1b5a70b46">lookup_dwp_signatured_type</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> sig)
<a name="l04782"></a>04782 {
<a name="l04783"></a>04783   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l04784"></a>04784   <span class="keyword">struct </span><a class="code" href="structdwp__file.html">dwp_file</a> *<a class="code" href="structdwp__file.html">dwp_file</a> = <a class="code" href="dwarf2read_8c.html#a9fc2d7d27eba883b582555229c60c32e">get_dwp_file</a> ();
<a name="l04785"></a>04785   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *dwo_entry;
<a name="l04786"></a>04786   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> find_sig_entry, *sig_entry;
<a name="l04787"></a>04787 
<a name="l04788"></a>04788   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (cu-&gt;dwo_unit &amp;&amp; dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a>);
<a name="l04789"></a>04789   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (dwp_file != NULL);
<a name="l04790"></a>04790 
<a name="l04791"></a>04791   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;signatured_types != NULL)
<a name="l04792"></a>04792     {
<a name="l04793"></a>04793       find_sig_entry.<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a> = sig;
<a name="l04794"></a>04794       sig_entry = htab_find (dwarf2_per_objfile-&gt;signatured_types,
<a name="l04795"></a>04795                              &amp;find_sig_entry);
<a name="l04796"></a>04796       <span class="keywordflow">if</span> (sig_entry != NULL)
<a name="l04797"></a>04797         <span class="keywordflow">return</span> sig_entry;
<a name="l04798"></a>04798     }
<a name="l04799"></a>04799 
<a name="l04800"></a>04800   <span class="comment">/* This is the &quot;shouldn&#39;t happen&quot; case.</span>
<a name="l04801"></a>04801 <span class="comment">     Try the DWP file and hope for the best.  */</span>
<a name="l04802"></a>04802   <span class="keywordflow">if</span> (dwp_file-&gt;<a class="code" href="structdwp__file.html#a1f5edbd4eb259b9605d86511d87f117c">tus</a> == NULL)
<a name="l04803"></a>04803     <span class="keywordflow">return</span> NULL;
<a name="l04804"></a>04804   dwo_entry = <a class="code" href="dwarf2read_8c.html#a5637d18b01ed205a41181e3cac6e442c">lookup_dwo_unit_in_dwp</a> (dwp_file, NULL,
<a name="l04805"></a>04805                                       sig, 1 <span class="comment">/* is_debug_types */</span>);
<a name="l04806"></a>04806   <span class="keywordflow">if</span> (dwo_entry == NULL)
<a name="l04807"></a>04807     <span class="keywordflow">return</span> NULL;
<a name="l04808"></a>04808 
<a name="l04809"></a>04809   sig_entry = <a class="code" href="dwarf2read_8c.html#abfd2c77b0ae141a1250a7889d1fbec4b">add_type_unit</a> (sig);
<a name="l04810"></a>04810   <a class="code" href="dwarf2read_8c.html#aa71f283d4b51463801afb8bfed6f272b">fill_in_sig_entry_from_dwo_entry</a> (objfile, sig_entry, dwo_entry);
<a name="l04811"></a>04811 
<a name="l04812"></a>04812   <span class="comment">/* The caller will signal a complaint if we return NULL.</span>
<a name="l04813"></a>04813 <span class="comment">     Here we don&#39;t return NULL but we still want to complain.  */</span>
<a name="l04814"></a>04814   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l04815"></a>04815              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Bad type signature %s referenced by %s at 0x%x,&quot;</span>
<a name="l04816"></a>04816                <span class="stringliteral">&quot; coping by using copy in DWP [in module %s]&quot;</span>),
<a name="l04817"></a>04817              <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (sig),
<a name="l04818"></a>04818              cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a> ? <span class="stringliteral">&quot;TU&quot;</span> : <span class="stringliteral">&quot;CU&quot;</span>,
<a name="l04819"></a>04819              cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>,
<a name="l04820"></a>04820              <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l04821"></a>04821 
<a name="l04822"></a>04822   <span class="keywordflow">return</span> sig_entry;
<a name="l04823"></a>04823 }
<a name="l04824"></a>04824 
<a name="l04825"></a>04825 <span class="comment">/* Lookup a signature based type for DW_FORM_ref_sig8.</span>
<a name="l04826"></a>04826 <span class="comment">   Returns NULL if signature SIG is not present in the table.</span>
<a name="l04827"></a>04827 <span class="comment">   It is up to the caller to complain about this.  */</span>
<a name="l04828"></a>04828 
<a name="l04829"></a>04829 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *
<a name="l04830"></a><a class="code" href="dwarf2read_8c.html#ac5606f704cf6961d275314004161334b">04830</a> <a class="code" href="dwarf2read_8c.html#ac5606f704cf6961d275314004161334b">lookup_signatured_type</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> sig)
<a name="l04831"></a>04831 {
<a name="l04832"></a>04832   <span class="keywordflow">if</span> (cu-&gt;dwo_unit
<a name="l04833"></a>04833       &amp;&amp; dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a>)
<a name="l04834"></a>04834     {
<a name="l04835"></a>04835       <span class="comment">/* We&#39;re in a DWO/DWP file, and we&#39;re using .gdb_index.</span>
<a name="l04836"></a>04836 <span class="comment">         These cases require special processing.  */</span>
<a name="l04837"></a>04837       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a9fc2d7d27eba883b582555229c60c32e">get_dwp_file</a> () == NULL)
<a name="l04838"></a>04838         <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a27dc24ca2503391da92c3d4e1915c9ad">lookup_dwo_signatured_type</a> (cu, sig);
<a name="l04839"></a>04839       <span class="keywordflow">else</span>
<a name="l04840"></a>04840         <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a94f5636b1b5af99ba6100fc1b5a70b46">lookup_dwp_signatured_type</a> (cu, sig);
<a name="l04841"></a>04841     }
<a name="l04842"></a>04842   <span class="keywordflow">else</span>
<a name="l04843"></a>04843     {
<a name="l04844"></a>04844       <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> find_entry, *entry;
<a name="l04845"></a>04845 
<a name="l04846"></a>04846       <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;signatured_types == NULL)
<a name="l04847"></a>04847         <span class="keywordflow">return</span> NULL;
<a name="l04848"></a>04848       find_entry.<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a> = sig;
<a name="l04849"></a>04849       entry = htab_find (dwarf2_per_objfile-&gt;signatured_types, &amp;find_entry);
<a name="l04850"></a>04850       <span class="keywordflow">return</span> entry;
<a name="l04851"></a>04851     }
<a name="l04852"></a>04852 }
<a name="l04853"></a>04853 
<a name="l04854"></a>04854 <span class="comment">/* Low level DIE reading support.  */</span>
<a name="l04855"></a>04855 
<a name="l04856"></a>04856 <span class="comment">/* Initialize a die_reader_specs struct from a dwarf2_cu struct.  */</span>
<a name="l04857"></a>04857 
<a name="l04858"></a>04858 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04859"></a><a class="code" href="dwarf2read_8c.html#a06f516ef314a0f5754cc936dc16391d7">04859</a> <a class="code" href="dwarf2read_8c.html#a06f516ef314a0f5754cc936dc16391d7">init_cu_die_reader</a> (<span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l04860"></a>04860                     <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l04861"></a>04861                     <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section,
<a name="l04862"></a>04862                     <span class="keyword">struct</span> dwo_file *dwo_file)
<a name="l04863"></a>04863 {
<a name="l04864"></a>04864   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (section-&gt;<a class="code" href="structdwarf2__section__info.html#ae115f99a7eba2f52b75574809537e723">readin</a> &amp;&amp; section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> != NULL);
<a name="l04865"></a>04865   reader-&gt;<a class="code" href="structdie__reader__specs.html#a1a2ea4151d385459f3a3fb7b0dad2973">abfd</a> = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l04866"></a>04866   reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a> = cu;
<a name="l04867"></a>04867   reader-&gt;<a class="code" href="structdie__reader__specs.html#a64321aff4f42ed613b8831c4d0804c36">dwo_file</a> = dwo_file;
<a name="l04868"></a>04868   reader-&gt;<a class="code" href="structdie__reader__specs.html#a59f8ddce0966e4c55a24c4f051a1917e">die_section</a> = section;
<a name="l04869"></a>04869   reader-&gt;<a class="code" href="structdie__reader__specs.html#a923f3b4252ec94584560d5433e848dc0">buffer</a> = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>;
<a name="l04870"></a>04870   reader-&gt;<a class="code" href="structdie__reader__specs.html#ae090c8e4b75582074889118172ea9095">buffer_end</a> = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>;
<a name="l04871"></a>04871   reader-&gt;<a class="code" href="structdie__reader__specs.html#afca780af991e478e77f4915e4632102f">comp_dir</a> = NULL;
<a name="l04872"></a>04872 }
<a name="l04873"></a>04873 
<a name="l04874"></a>04874 <span class="comment">/* Subroutine of init_cutu_and_read_dies to simplify it.</span>
<a name="l04875"></a>04875 <span class="comment">   Read in the rest of a CU/TU top level DIE from DWO_UNIT.</span>
<a name="l04876"></a>04876 <span class="comment">   There&#39;s just a lot of work to do, and init_cutu_and_read_dies is big enough</span>
<a name="l04877"></a>04877 <span class="comment">   already.</span>
<a name="l04878"></a>04878 <span class="comment"></span>
<a name="l04879"></a>04879 <span class="comment">   STUB_COMP_UNIT_DIE is for the stub DIE, we copy over certain attributes</span>
<a name="l04880"></a>04880 <span class="comment">   from it to the DIE in the DWO.  If NULL we are skipping the stub.</span>
<a name="l04881"></a>04881 <span class="comment">   STUB_COMP_DIR is similar to STUB_COMP_UNIT_DIE: When reading a TU directly</span>
<a name="l04882"></a>04882 <span class="comment">   from the DWO file, bypassing the stub, it contains the DW_AT_comp_dir</span>
<a name="l04883"></a>04883 <span class="comment">   attribute of the referencing CU.  Exactly one of STUB_COMP_UNIT_DIE and</span>
<a name="l04884"></a>04884 <span class="comment">   COMP_DIR must be non-NULL.</span>
<a name="l04885"></a>04885 <span class="comment">   *RESULT_READER,*RESULT_INFO_PTR,*RESULT_COMP_UNIT_DIE,*RESULT_HAS_CHILDREN</span>
<a name="l04886"></a>04886 <span class="comment">   are filled in with the info of the DIE from the DWO file.</span>
<a name="l04887"></a>04887 <span class="comment">   ABBREV_TABLE_PROVIDED is non-zero if the caller of init_cutu_and_read_dies</span>
<a name="l04888"></a>04888 <span class="comment">   provided an abbrev table to use.</span>
<a name="l04889"></a>04889 <span class="comment">   The result is non-zero if a valid (non-dummy) DIE was found.  */</span>
<a name="l04890"></a>04890 
<a name="l04891"></a>04891 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04892"></a><a class="code" href="dwarf2read_8c.html#a4461cfd6a80b28cd6273bbfd54535392">04892</a> <a class="code" href="dwarf2read_8c.html#a4461cfd6a80b28cd6273bbfd54535392">read_cutu_die_from_dwo</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu,
<a name="l04893"></a>04893                         <span class="keyword">struct</span> <a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structdwo__unit.html">dwo_unit</a>,
<a name="l04894"></a>04894                         <span class="keywordtype">int</span> abbrev_table_provided,
<a name="l04895"></a>04895                         <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *stub_comp_unit_die,
<a name="l04896"></a>04896                         <span class="keyword">const</span> <span class="keywordtype">char</span> *stub_comp_dir,
<a name="l04897"></a>04897                         <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *result_reader,
<a name="l04898"></a>04898                         <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **result_info_ptr,
<a name="l04899"></a>04899                         <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> **result_comp_unit_die,
<a name="l04900"></a>04900                         <span class="keywordtype">int</span> *result_has_children)
<a name="l04901"></a>04901 {
<a name="l04902"></a>04902   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l04903"></a>04903   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>;
<a name="l04904"></a>04904   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section;
<a name="l04905"></a>04905   bfd *abfd;
<a name="l04906"></a>04906   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *begin_info_ptr, *info_ptr;
<a name="l04907"></a>04907   <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir_string;
<a name="l04908"></a>04908   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> signature; <span class="comment">/* Or dwo_id.  */</span>
<a name="l04909"></a>04909   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *comp_dir, *stmt_list, *low_pc, *high_pc, *ranges;
<a name="l04910"></a>04910   <span class="keywordtype">int</span> i,num_extra_attrs;
<a name="l04911"></a>04911   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *dwo_abbrev_section;
<a name="l04912"></a>04912   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l04913"></a>04913   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> comp_dir_attr;
<a name="l04914"></a>04914   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *comp_unit_die;
<a name="l04915"></a>04915 
<a name="l04916"></a>04916   <span class="comment">/* Both can&#39;t be provided.  */</span>
<a name="l04917"></a>04917   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (! (stub_comp_unit_die &amp;&amp; stub_comp_dir));
<a name="l04918"></a>04918 
<a name="l04919"></a>04919   <span class="comment">/* These attributes aren&#39;t processed until later:</span>
<a name="l04920"></a>04920 <span class="comment">     DW_AT_stmt_list, DW_AT_low_pc, DW_AT_high_pc, DW_AT_ranges.</span>
<a name="l04921"></a>04921 <span class="comment">     However, the attribute is found in the stub which we won&#39;t have later.</span>
<a name="l04922"></a>04922 <span class="comment">     In order to not impose this complication on the rest of the code,</span>
<a name="l04923"></a>04923 <span class="comment">     we read them here and copy them to the DWO CU/TU die.  */</span>
<a name="l04924"></a>04924 
<a name="l04925"></a>04925   stmt_list = NULL;
<a name="l04926"></a>04926   low_pc = NULL;
<a name="l04927"></a>04927   high_pc = NULL;
<a name="l04928"></a>04928   ranges = NULL;
<a name="l04929"></a>04929   comp_dir = NULL;
<a name="l04930"></a>04930 
<a name="l04931"></a>04931   <span class="keywordflow">if</span> (stub_comp_unit_die != NULL)
<a name="l04932"></a>04932     {
<a name="l04933"></a>04933       <span class="comment">/* For TUs in DWO files, the DW_AT_stmt_list attribute lives in the</span>
<a name="l04934"></a>04934 <span class="comment">         DWO file.  */</span>
<a name="l04935"></a>04935       <span class="keywordflow">if</span> (! this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l04936"></a>04936         stmt_list = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (stub_comp_unit_die, DW_AT_stmt_list, cu);
<a name="l04937"></a>04937       low_pc = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (stub_comp_unit_die, DW_AT_low_pc, cu);
<a name="l04938"></a>04938       high_pc = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (stub_comp_unit_die, DW_AT_high_pc, cu);
<a name="l04939"></a>04939       ranges = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (stub_comp_unit_die, DW_AT_ranges, cu);
<a name="l04940"></a>04940       comp_dir = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (stub_comp_unit_die, DW_AT_comp_dir, cu);
<a name="l04941"></a>04941 
<a name="l04942"></a>04942       <span class="comment">/* There should be a DW_AT_addr_base attribute here (if needed).</span>
<a name="l04943"></a>04943 <span class="comment">         We need the value before we can process DW_FORM_GNU_addr_index.  */</span>
<a name="l04944"></a>04944       cu-&gt;addr_base = 0;
<a name="l04945"></a>04945       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (stub_comp_unit_die, DW_AT_GNU_addr_base, cu);
<a name="l04946"></a>04946       <span class="keywordflow">if</span> (attr)
<a name="l04947"></a>04947         cu-&gt;addr_base = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l04948"></a>04948 
<a name="l04949"></a>04949       <span class="comment">/* There should be a DW_AT_ranges_base attribute here (if needed).</span>
<a name="l04950"></a>04950 <span class="comment">         We need the value before we can process DW_AT_ranges.  */</span>
<a name="l04951"></a>04951       cu-&gt;ranges_base = 0;
<a name="l04952"></a>04952       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (stub_comp_unit_die, DW_AT_GNU_ranges_base, cu);
<a name="l04953"></a>04953       <span class="keywordflow">if</span> (attr)
<a name="l04954"></a>04954         cu-&gt;ranges_base = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l04955"></a>04955     }
<a name="l04956"></a>04956   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (stub_comp_dir != NULL)
<a name="l04957"></a>04957     {
<a name="l04958"></a>04958       <span class="comment">/* Reconstruct the comp_dir attribute to simplify the code below.  */</span>
<a name="l04959"></a>04959       comp_dir = (<span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *)
<a name="l04960"></a>04960         obstack_alloc (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>, sizeof (*comp_dir));
<a name="l04961"></a>04961       comp_dir-&gt;name = DW_AT_comp_dir;
<a name="l04962"></a>04962       comp_dir-&gt;form = DW_FORM_string;
<a name="l04963"></a>04963       <a class="code" href="dwarf2read_8c.html#a307f18e0d403d80487696d1a0a5d0fd6">DW_STRING_IS_CANONICAL</a> (comp_dir) = 0;
<a name="l04964"></a>04964       <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (comp_dir) = stub_comp_dir;
<a name="l04965"></a>04965     }
<a name="l04966"></a>04966 
<a name="l04967"></a>04967   <span class="comment">/* Set up for reading the DWO CU/TU.  */</span>
<a name="l04968"></a>04968   cu-&gt;dwo_unit = dwo_unit;
<a name="l04969"></a>04969   section = dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a808127fb35d399faddd33a3b28e5ec06">section</a>;
<a name="l04970"></a>04970   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, section);
<a name="l04971"></a>04971   abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l04972"></a>04972   begin_info_ptr = info_ptr = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a39192bd18fec52ffbb9cda4fc9d631e0">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l04973"></a>04973   dwo_abbrev_section = &amp;dwo_unit-&gt;<a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">dwo_file</a>-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#a77a177199056d70f8c5379e116538cff">abbrev</a>;
<a name="l04974"></a>04974   <a class="code" href="dwarf2read_8c.html#a06f516ef314a0f5754cc936dc16391d7">init_cu_die_reader</a> (result_reader, cu, section, dwo_unit-&gt;<a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">dwo_file</a>);
<a name="l04975"></a>04975 
<a name="l04976"></a>04976   <span class="keywordflow">if</span> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l04977"></a>04977     {
<a name="l04978"></a>04978       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> header_signature;
<a name="l04979"></a>04979       <a class="code" href="structcu__offset.html">cu_offset</a> type_offset_in_tu;
<a name="l04980"></a>04980       <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type = (<span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *) this_cu;
<a name="l04981"></a>04981 
<a name="l04982"></a>04982       info_ptr = <a class="code" href="dwarf2read_8c.html#a3e530db440df1aa6cf5bae99d3c49667">read_and_check_type_unit_head</a> (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>, section,
<a name="l04983"></a>04983                                                 dwo_abbrev_section,
<a name="l04984"></a>04984                                                 info_ptr,
<a name="l04985"></a>04985                                                 &amp;header_signature,
<a name="l04986"></a>04986                                                 &amp;type_offset_in_tu);
<a name="l04987"></a>04987       <span class="comment">/* This is not an assert because it can be caused by bad debug info.  */</span>
<a name="l04988"></a>04988       <span class="keywordflow">if</span> (sig_type-&gt;<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a> != header_signature)
<a name="l04989"></a>04989         {
<a name="l04990"></a>04990           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: signature mismatch %s vs %s while reading&quot;</span>
<a name="l04991"></a>04991                    <span class="stringliteral">&quot; TU at offset 0x%x [in module %s]&quot;</span>),
<a name="l04992"></a>04992                  <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (sig_type-&gt;<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a>),
<a name="l04993"></a>04993                  <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (header_signature),
<a name="l04994"></a>04994                  dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a39192bd18fec52ffbb9cda4fc9d631e0">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>,
<a name="l04995"></a>04995                  bfd_get_filename (abfd));
<a name="l04996"></a>04996         }
<a name="l04997"></a>04997       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a39192bd18fec52ffbb9cda4fc9d631e0">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> == cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l04998"></a>04998       <span class="comment">/* For DWOs coming from DWP files, we don&#39;t know the CU length</span>
<a name="l04999"></a>04999 <span class="comment">         nor the type&#39;s offset in the TU until now.  */</span>
<a name="l05000"></a>05000       dwo_unit-&gt;<a class="code" href="structdwo__unit.html#adf4afc1b8bd4d2b879762c33930ef988">length</a> = <a class="code" href="dwarf2read_8c.html#a64dfe5d648dc5396cd471de3540fef30">get_cu_length</a> (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>);
<a name="l05001"></a>05001       dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a88b2cadfe8ed91777ee37fe16bfdc761">type_offset_in_tu</a> = <a class="code" href="structsignatured__type.html#ab152a3e1f687ff6464b369502ce745a9">type_offset_in_tu</a>;
<a name="l05002"></a>05002 
<a name="l05003"></a>05003       <span class="comment">/* Establish the type offset that can be used to lookup the type.</span>
<a name="l05004"></a>05004 <span class="comment">         For DWO files, we don&#39;t know it until now.  */</span>
<a name="l05005"></a>05005       sig_type-&gt;<a class="code" href="structsignatured__type.html#aa8e49a69ad9d6311b553b063fa0fe62d">type_offset_in_section</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> =
<a name="l05006"></a>05006         dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a39192bd18fec52ffbb9cda4fc9d631e0">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> + dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a88b2cadfe8ed91777ee37fe16bfdc761">type_offset_in_tu</a>.<a class="code" href="structcu__offset.html#a19224b0dc5f0bc49babd2b7701a8d63e">cu_off</a>;
<a name="l05007"></a>05007     }
<a name="l05008"></a>05008   <span class="keywordflow">else</span>
<a name="l05009"></a>05009     {
<a name="l05010"></a>05010       info_ptr = <a class="code" href="dwarf2read_8c.html#ab4a5d6610652463f5cf265ddbdfb8d58">read_and_check_comp_unit_head</a> (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>, section,
<a name="l05011"></a>05011                                                 dwo_abbrev_section,
<a name="l05012"></a>05012                                                 info_ptr, 0);
<a name="l05013"></a>05013       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a39192bd18fec52ffbb9cda4fc9d631e0">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> == cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l05014"></a>05014       <span class="comment">/* For DWOs coming from DWP files, we don&#39;t know the CU length</span>
<a name="l05015"></a>05015 <span class="comment">         until now.  */</span>
<a name="l05016"></a>05016       dwo_unit-&gt;<a class="code" href="structdwo__unit.html#adf4afc1b8bd4d2b879762c33930ef988">length</a> = <a class="code" href="dwarf2read_8c.html#a64dfe5d648dc5396cd471de3540fef30">get_cu_length</a> (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>);
<a name="l05017"></a>05017     }
<a name="l05018"></a>05018 
<a name="l05019"></a>05019   <span class="comment">/* Replace the CU&#39;s original abbrev table with the DWO&#39;s.</span>
<a name="l05020"></a>05020 <span class="comment">     Reminder: We can&#39;t read the abbrev table until we&#39;ve read the header.  */</span>
<a name="l05021"></a>05021   <span class="keywordflow">if</span> (abbrev_table_provided)
<a name="l05022"></a>05022     {
<a name="l05023"></a>05023       <span class="comment">/* Don&#39;t free the provided abbrev table, the caller of</span>
<a name="l05024"></a>05024 <span class="comment">         init_cutu_and_read_dies owns it.  */</span>
<a name="l05025"></a>05025       <a class="code" href="dwarf2read_8c.html#a2ab84af9aed9d7ab89a9c1389bf09944">dwarf2_read_abbrevs</a> (cu, dwo_abbrev_section);
<a name="l05026"></a>05026       <span class="comment">/* Ensure the DWO abbrev table gets freed.  */</span>
<a name="l05027"></a>05027       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#a966c2eb4689779cf219c72bbcda90b83">dwarf2_free_abbrev_table</a>, cu);
<a name="l05028"></a>05028     }
<a name="l05029"></a>05029   <span class="keywordflow">else</span>
<a name="l05030"></a>05030     {
<a name="l05031"></a>05031       <a class="code" href="dwarf2read_8c.html#a966c2eb4689779cf219c72bbcda90b83">dwarf2_free_abbrev_table</a> (cu);
<a name="l05032"></a>05032       <a class="code" href="dwarf2read_8c.html#a2ab84af9aed9d7ab89a9c1389bf09944">dwarf2_read_abbrevs</a> (cu, dwo_abbrev_section);
<a name="l05033"></a>05033       <span class="comment">/* Leave any existing abbrev table cleanup as is.  */</span>
<a name="l05034"></a>05034     }
<a name="l05035"></a>05035 
<a name="l05036"></a>05036   <span class="comment">/* Read in the die, but leave space to copy over the attributes</span>
<a name="l05037"></a>05037 <span class="comment">     from the stub.  This has the benefit of simplifying the rest of</span>
<a name="l05038"></a>05038 <span class="comment">     the code - all the work to maintain the illusion of a single</span>
<a name="l05039"></a>05039 <span class="comment">     DW_TAG_{compile,type}_unit DIE is done here.  */</span>
<a name="l05040"></a>05040   num_extra_attrs = ((stmt_list != NULL)
<a name="l05041"></a>05041                      + (low_pc != NULL)
<a name="l05042"></a>05042                      + (high_pc != NULL)
<a name="l05043"></a>05043                      + (ranges != NULL)
<a name="l05044"></a>05044                      + (comp_dir != NULL));
<a name="l05045"></a>05045   info_ptr = <a class="code" href="dwarf2read_8c.html#a291867fdd93d43aec13a54966902d005">read_full_die_1</a> (result_reader, result_comp_unit_die, info_ptr,
<a name="l05046"></a>05046                               result_has_children, num_extra_attrs);
<a name="l05047"></a>05047 
<a name="l05048"></a>05048   <span class="comment">/* Copy over the attributes from the stub to the DIE we just read in.  */</span>
<a name="l05049"></a>05049   comp_unit_die = *result_comp_unit_die;
<a name="l05050"></a>05050   i = comp_unit_die-&gt;num_attrs;
<a name="l05051"></a>05051   <span class="keywordflow">if</span> (stmt_list != NULL)
<a name="l05052"></a>05052     comp_unit_die-&gt;attrs[i++] = *stmt_list;
<a name="l05053"></a>05053   <span class="keywordflow">if</span> (low_pc != NULL)
<a name="l05054"></a>05054     comp_unit_die-&gt;attrs[i++] = *low_pc;
<a name="l05055"></a>05055   <span class="keywordflow">if</span> (high_pc != NULL)
<a name="l05056"></a>05056     comp_unit_die-&gt;attrs[i++] = *high_pc;
<a name="l05057"></a>05057   <span class="keywordflow">if</span> (ranges != NULL)
<a name="l05058"></a>05058     comp_unit_die-&gt;attrs[i++] = *ranges;
<a name="l05059"></a>05059   <span class="keywordflow">if</span> (comp_dir != NULL)
<a name="l05060"></a>05060     comp_unit_die-&gt;attrs[i++] = *comp_dir;
<a name="l05061"></a>05061   comp_unit_die-&gt;num_attrs += num_extra_attrs;
<a name="l05062"></a>05062 
<a name="l05063"></a>05063   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a1a718830b2084a029498b587ad66aeae">dwarf2_die_debug</a>)
<a name="l05064"></a>05064     {
<a name="l05065"></a>05065       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l05066"></a>05066                           <span class="stringliteral">&quot;Read die from %s@0x%x of %s:\n&quot;</span>,
<a name="l05067"></a>05067                           <a class="code" href="dwarf2read_8c.html#a206c558e28b7bc7fcf8bdad145cabef1">get_section_name</a> (section),
<a name="l05068"></a>05068                           (<span class="keywordtype">unsigned</span>) (begin_info_ptr - section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>),
<a name="l05069"></a>05069                           bfd_get_filename (abfd));
<a name="l05070"></a>05070       <a class="code" href="dwarf2read_8c.html#aa1e7ee43f6ccdd2c19768ae5eff4bd89">dump_die</a> (comp_unit_die, <a class="code" href="dwarf2read_8c.html#a1a718830b2084a029498b587ad66aeae">dwarf2_die_debug</a>);
<a name="l05071"></a>05071     }
<a name="l05072"></a>05072 
<a name="l05073"></a>05073   <span class="comment">/* Save the comp_dir attribute.  If there is no DWP file then we&#39;ll read</span>
<a name="l05074"></a>05074 <span class="comment">     TUs by skipping the stub and going directly to the entry in the DWO file.</span>
<a name="l05075"></a>05075 <span class="comment">     However, skipping the stub means we won&#39;t get DW_AT_comp_dir, so we have</span>
<a name="l05076"></a>05076 <span class="comment">     to get it via circuitous means.  Blech.  */</span>
<a name="l05077"></a>05077   <span class="keywordflow">if</span> (comp_dir != NULL)
<a name="l05078"></a>05078     result_reader-&gt;<a class="code" href="structdie__reader__specs.html#afca780af991e478e77f4915e4632102f">comp_dir</a> = <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (comp_dir);
<a name="l05079"></a>05079 
<a name="l05080"></a>05080   <span class="comment">/* Skip dummy compilation units.  */</span>
<a name="l05081"></a>05081   <span class="keywordflow">if</span> (info_ptr &gt;= begin_info_ptr + dwo_unit-&gt;<a class="code" href="structdwo__unit.html#adf4afc1b8bd4d2b879762c33930ef988">length</a>
<a name="l05082"></a>05082       || <a class="code" href="dwarf2read_8c.html#a750ce8dd923161d4fd41793c6965ca6c">peek_abbrev_code</a> (abfd, info_ptr) == 0)
<a name="l05083"></a>05083     <span class="keywordflow">return</span> 0;
<a name="l05084"></a>05084 
<a name="l05085"></a>05085   *result_info_ptr = info_ptr;
<a name="l05086"></a>05086   <span class="keywordflow">return</span> 1;
<a name="l05087"></a>05087 }
<a name="l05088"></a>05088 
<a name="l05089"></a>05089 <span class="comment">/* Subroutine of init_cutu_and_read_dies to simplify it.</span>
<a name="l05090"></a>05090 <span class="comment">   Look up the DWO unit specified by COMP_UNIT_DIE of THIS_CU.</span>
<a name="l05091"></a>05091 <span class="comment">   Returns NULL if the specified DWO unit cannot be found.  */</span>
<a name="l05092"></a>05092 
<a name="l05093"></a>05093 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *
<a name="l05094"></a><a class="code" href="dwarf2read_8c.html#a1dac520e324b3f04813ab73447dcd0c2">05094</a> <a class="code" href="dwarf2read_8c.html#a1dac520e324b3f04813ab73447dcd0c2">lookup_dwo_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu,
<a name="l05095"></a>05095                  <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *comp_unit_die)
<a name="l05096"></a>05096 {
<a name="l05097"></a>05097   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>;
<a name="l05098"></a>05098   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l05099"></a>05099   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> signature;
<a name="l05100"></a>05100   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structdwo__unit.html">dwo_unit</a>;
<a name="l05101"></a>05101   <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir, *dwo_name;
<a name="l05102"></a>05102 
<a name="l05103"></a>05103   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (cu != NULL);
<a name="l05104"></a>05104 
<a name="l05105"></a>05105   <span class="comment">/* Yeah, we look dwo_name up again, but it simplifies the code.  */</span>
<a name="l05106"></a>05106   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (comp_unit_die, DW_AT_GNU_dwo_name, cu);
<a name="l05107"></a>05107   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (attr != NULL);
<a name="l05108"></a>05108   dwo_name = <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr);
<a name="l05109"></a>05109   comp_dir = NULL;
<a name="l05110"></a>05110   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (comp_unit_die, DW_AT_comp_dir, cu);
<a name="l05111"></a>05111   <span class="keywordflow">if</span> (attr)
<a name="l05112"></a>05112     comp_dir = <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr);
<a name="l05113"></a>05113 
<a name="l05114"></a>05114   <span class="keywordflow">if</span> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l05115"></a>05115     {
<a name="l05116"></a>05116       <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type;
<a name="l05117"></a>05117 
<a name="l05118"></a>05118       <span class="comment">/* Since this_cu is the first member of struct signatured_type,</span>
<a name="l05119"></a>05119 <span class="comment">         we can go from a pointer to one to a pointer to the other.  */</span>
<a name="l05120"></a>05120       sig_type = (<span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *) this_cu;
<a name="l05121"></a>05121       signature = sig_type-&gt;<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a>;
<a name="l05122"></a>05122       dwo_unit = <a class="code" href="dwarf2read_8c.html#a5f81c3c5c800c9a68e91157b46e1cd8f">lookup_dwo_type_unit</a> (sig_type, dwo_name, comp_dir);
<a name="l05123"></a>05123     }
<a name="l05124"></a>05124   <span class="keywordflow">else</span>
<a name="l05125"></a>05125     {
<a name="l05126"></a>05126       <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l05127"></a>05127 
<a name="l05128"></a>05128       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (comp_unit_die, DW_AT_GNU_dwo_id, cu);
<a name="l05129"></a>05129       <span class="keywordflow">if</span> (! attr)
<a name="l05130"></a>05130         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: missing dwo_id for dwo_name %s&quot;</span>
<a name="l05131"></a>05131                  <span class="stringliteral">&quot; [in module %s]&quot;</span>),
<a name="l05132"></a>05132                dwo_name, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>));
<a name="l05133"></a>05133       signature = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l05134"></a>05134       dwo_unit = <a class="code" href="dwarf2read_8c.html#a5bc277ff9a23ec723156386e4b6cb16a">lookup_dwo_comp_unit</a> (this_cu, dwo_name, comp_dir,
<a name="l05135"></a>05135                                        signature);
<a name="l05136"></a>05136     }
<a name="l05137"></a>05137 
<a name="l05138"></a>05138   <span class="keywordflow">return</span> dwo_unit;
<a name="l05139"></a>05139 }
<a name="l05140"></a>05140 
<a name="l05141"></a>05141 <span class="comment">/* Subroutine of init_cutu_and_read_dies to simplify it.</span>
<a name="l05142"></a>05142 <span class="comment">   Read a TU directly from a DWO file, bypassing the stub.  */</span>
<a name="l05143"></a>05143 
<a name="l05144"></a>05144 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05145"></a><a class="code" href="dwarf2read_8c.html#a3c7b2b9b5b2d2b157bceb712a8995727">05145</a> <a class="code" href="dwarf2read_8c.html#a3c7b2b9b5b2d2b157bceb712a8995727">init_tu_and_read_dwo_dies</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu, <span class="keywordtype">int</span> keep,
<a name="l05146"></a>05146                            <a class="code" href="dwarf2read_8c.html#a78918e349d1b0b7715599fa171aab050">die_reader_func_ftype</a> *die_reader_func,
<a name="l05147"></a>05147                            <span class="keywordtype">void</span> *data)
<a name="l05148"></a>05148 {
<a name="l05149"></a>05149   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu;
<a name="l05150"></a>05150   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type;
<a name="l05151"></a>05151   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups, *free_cu_cleanup;
<a name="l05152"></a>05152   <span class="keyword">struct </span><a class="code" href="structdie__reader__specs.html">die_reader_specs</a> reader;
<a name="l05153"></a>05153   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr;
<a name="l05154"></a>05154   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *comp_unit_die;
<a name="l05155"></a>05155   <span class="keywordtype">int</span> has_children;
<a name="l05156"></a>05156 
<a name="l05157"></a>05157   <span class="comment">/* Verify we can do the following downcast, and that we have the</span>
<a name="l05158"></a>05158 <span class="comment">     data we need.  */</span>
<a name="l05159"></a>05159   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a> &amp;&amp; this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a3015da55655aee818845295b4bbccee5">reading_dwo_directly</a>);
<a name="l05160"></a>05160   sig_type = (<span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *) this_cu;
<a name="l05161"></a>05161   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sig_type-&gt;<a class="code" href="structsignatured__type.html#a8b6cf2131ff9f72ef62c56047f62f9d6">dwo_unit</a> != NULL);
<a name="l05162"></a>05162 
<a name="l05163"></a>05163   cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, NULL);
<a name="l05164"></a>05164 
<a name="l05165"></a>05165   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> == NULL);
<a name="l05166"></a>05166   cu = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (*cu));
<a name="l05167"></a>05167   <a class="code" href="dwarf2read_8c.html#abd170e25a0f34cecee142a0252b26d82">init_one_comp_unit</a> (cu, this_cu);
<a name="l05168"></a>05168   <span class="comment">/* If an error occurs while loading, release our storage.  */</span>
<a name="l05169"></a>05169   free_cu_cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#a686d2ded76f9904b6f35d4402ee17230">free_heap_comp_unit</a>, cu);
<a name="l05170"></a>05170 
<a name="l05171"></a>05171   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a4461cfd6a80b28cd6273bbfd54535392">read_cutu_die_from_dwo</a> (this_cu, sig_type-&gt;<a class="code" href="structsignatured__type.html#a8b6cf2131ff9f72ef62c56047f62f9d6">dwo_unit</a>,
<a name="l05172"></a>05172                               0 <span class="comment">/* abbrev_table_provided */</span>,
<a name="l05173"></a>05173                               NULL <span class="comment">/* stub_comp_unit_die */</span>,
<a name="l05174"></a>05174                               sig_type-&gt;<a class="code" href="structsignatured__type.html#a8b6cf2131ff9f72ef62c56047f62f9d6">dwo_unit</a>-&gt;<a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">dwo_file</a>-&gt;<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a>,
<a name="l05175"></a>05175                               &amp;reader, &amp;info_ptr,
<a name="l05176"></a>05176                               &amp;comp_unit_die, &amp;has_children) == 0)
<a name="l05177"></a>05177     {
<a name="l05178"></a>05178       <span class="comment">/* Dummy die.  */</span>
<a name="l05179"></a>05179       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l05180"></a>05180       <span class="keywordflow">return</span>;
<a name="l05181"></a>05181     }
<a name="l05182"></a>05182 
<a name="l05183"></a>05183   <span class="comment">/* All the &quot;real&quot; work is done here.  */</span>
<a name="l05184"></a>05184   die_reader_func (&amp;reader, info_ptr, comp_unit_die, has_children, data);
<a name="l05185"></a>05185 
<a name="l05186"></a>05186   <span class="comment">/* This duplicates some code in init_cutu_and_read_dies,</span>
<a name="l05187"></a>05187 <span class="comment">     but the alternative is making the latter more complex.</span>
<a name="l05188"></a>05188 <span class="comment">     This function is only for the special case of using DWO files directly:</span>
<a name="l05189"></a>05189 <span class="comment">     no point in overly complicating the general case just to handle this.  */</span>
<a name="l05190"></a>05190   <span class="keywordflow">if</span> (keep)
<a name="l05191"></a>05191     {
<a name="l05192"></a>05192       <span class="comment">/* We&#39;ve successfully allocated this compilation unit.  Let our</span>
<a name="l05193"></a>05193 <span class="comment">         caller clean it up when finished with it.  */</span>
<a name="l05194"></a>05194       <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (free_cu_cleanup);
<a name="l05195"></a>05195 
<a name="l05196"></a>05196       <span class="comment">/* We can only discard free_cu_cleanup and all subsequent cleanups.</span>
<a name="l05197"></a>05197 <span class="comment">         So we have to manually free the abbrev table.  */</span>
<a name="l05198"></a>05198       <a class="code" href="dwarf2read_8c.html#a966c2eb4689779cf219c72bbcda90b83">dwarf2_free_abbrev_table</a> (cu);
<a name="l05199"></a>05199 
<a name="l05200"></a>05200       <span class="comment">/* Link this CU into read_in_chain.  */</span>
<a name="l05201"></a>05201       this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ad4caa7a7978fa4ca2edef259dd77a8ef">read_in_chain</a> = dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a250e2511524a3122ba1489978a303221">read_in_chain</a>;
<a name="l05202"></a>05202       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a250e2511524a3122ba1489978a303221">read_in_chain</a> = this_cu;
<a name="l05203"></a>05203     }
<a name="l05204"></a>05204   <span class="keywordflow">else</span>
<a name="l05205"></a>05205     <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (free_cu_cleanup);
<a name="l05206"></a>05206 
<a name="l05207"></a>05207   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l05208"></a>05208 }
<a name="l05209"></a>05209 
<a name="l05210"></a>05210 <span class="comment">/* Initialize a CU (or TU) and read its DIEs.</span>
<a name="l05211"></a>05211 <span class="comment">   If the CU defers to a DWO file, read the DWO file as well.</span>
<a name="l05212"></a>05212 <span class="comment"></span>
<a name="l05213"></a>05213 <span class="comment">   ABBREV_TABLE, if non-NULL, is the abbreviation table to use.</span>
<a name="l05214"></a>05214 <span class="comment">   Otherwise the table specified in the comp unit header is read in and used.</span>
<a name="l05215"></a>05215 <span class="comment">   This is an optimization for when we already have the abbrev table.</span>
<a name="l05216"></a>05216 <span class="comment"></span>
<a name="l05217"></a>05217 <span class="comment">   If USE_EXISTING_CU is non-zero, and THIS_CU-&gt;cu is non-NULL, then use it.</span>
<a name="l05218"></a>05218 <span class="comment">   Otherwise, a new CU is allocated with xmalloc.</span>
<a name="l05219"></a>05219 <span class="comment"></span>
<a name="l05220"></a>05220 <span class="comment">   If KEEP is non-zero, then if we allocated a dwarf2_cu we add it to</span>
<a name="l05221"></a>05221 <span class="comment">   read_in_chain.  Otherwise the dwarf2_cu data is freed at the end.</span>
<a name="l05222"></a>05222 <span class="comment"></span>
<a name="l05223"></a>05223 <span class="comment">   WARNING: If THIS_CU is a &quot;dummy CU&quot; (used as filler by the incremental</span>
<a name="l05224"></a>05224 <span class="comment">   linker) then DIE_READER_FUNC will not get called.  */</span>
<a name="l05225"></a>05225 
<a name="l05226"></a>05226 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05227"></a><a class="code" href="dwarf2read_8c.html#a2887b925bcf54483d1c0dc40faefdd08">05227</a> <a class="code" href="dwarf2read_8c.html#a2887b925bcf54483d1c0dc40faefdd08">init_cutu_and_read_dies</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu,
<a name="l05228"></a>05228                          <span class="keyword">struct</span> <a class="code" href="structabbrev__table.html">abbrev_table</a> *<a class="code" href="structabbrev__table.html">abbrev_table</a>,
<a name="l05229"></a>05229                          <span class="keywordtype">int</span> use_existing_cu, <span class="keywordtype">int</span> keep,
<a name="l05230"></a>05230                          <a class="code" href="dwarf2read_8c.html#a78918e349d1b0b7715599fa171aab050">die_reader_func_ftype</a> *die_reader_func,
<a name="l05231"></a>05231                          <span class="keywordtype">void</span> *data)
<a name="l05232"></a>05232 {
<a name="l05233"></a>05233   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l05234"></a>05234   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section = this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a>;
<a name="l05235"></a>05235   bfd *abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l05236"></a>05236   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu;
<a name="l05237"></a>05237   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *begin_info_ptr, *info_ptr;
<a name="l05238"></a>05238   <span class="keyword">struct </span><a class="code" href="structdie__reader__specs.html">die_reader_specs</a> reader;
<a name="l05239"></a>05239   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *comp_unit_die;
<a name="l05240"></a>05240   <span class="keywordtype">int</span> has_children;
<a name="l05241"></a>05241   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l05242"></a>05242   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups, *free_cu_cleanup = NULL;
<a name="l05243"></a>05243   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type = NULL;
<a name="l05244"></a>05244   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *abbrev_section;
<a name="l05245"></a>05245   <span class="comment">/* Non-zero if CU currently points to a DWO file and we need to</span>
<a name="l05246"></a>05246 <span class="comment">     reread it.  When this happens we need to reread the skeleton die</span>
<a name="l05247"></a>05247 <span class="comment">     before we can reread the DWO file (this only applies to CUs, not TUs).  */</span>
<a name="l05248"></a>05248   <span class="keywordtype">int</span> rereading_dwo_cu = 0;
<a name="l05249"></a>05249 
<a name="l05250"></a>05250   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a1a718830b2084a029498b587ad66aeae">dwarf2_die_debug</a>)
<a name="l05251"></a>05251     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Reading %s unit at offset 0x%x\n&quot;</span>,
<a name="l05252"></a>05252                         this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a> ? <span class="stringliteral">&quot;type&quot;</span> : <span class="stringliteral">&quot;comp&quot;</span>,
<a name="l05253"></a>05253                         this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l05254"></a>05254 
<a name="l05255"></a>05255   <span class="keywordflow">if</span> (use_existing_cu)
<a name="l05256"></a>05256     <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (keep);
<a name="l05257"></a>05257 
<a name="l05258"></a>05258   <span class="comment">/* If we&#39;re reading a TU directly from a DWO file, including a virtual DWO</span>
<a name="l05259"></a>05259 <span class="comment">     file (instead of going through the stub), short-circuit all of this.  */</span>
<a name="l05260"></a>05260   <span class="keywordflow">if</span> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a3015da55655aee818845295b4bbccee5">reading_dwo_directly</a>)
<a name="l05261"></a>05261     {
<a name="l05262"></a>05262       <span class="comment">/* Narrow down the scope of possibilities to have to understand.  */</span>
<a name="l05263"></a>05263       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l05264"></a>05264       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (abbrev_table == NULL);
<a name="l05265"></a>05265       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!use_existing_cu);
<a name="l05266"></a>05266       <a class="code" href="dwarf2read_8c.html#a3c7b2b9b5b2d2b157bceb712a8995727">init_tu_and_read_dwo_dies</a> (this_cu, keep, die_reader_func, data);
<a name="l05267"></a>05267       <span class="keywordflow">return</span>;
<a name="l05268"></a>05268     }
<a name="l05269"></a>05269 
<a name="l05270"></a>05270   cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, NULL);
<a name="l05271"></a>05271 
<a name="l05272"></a>05272   <span class="comment">/* This is cheap if the section is already read in.  */</span>
<a name="l05273"></a>05273   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, section);
<a name="l05274"></a>05274 
<a name="l05275"></a>05275   begin_info_ptr = info_ptr = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l05276"></a>05276 
<a name="l05277"></a>05277   abbrev_section = <a class="code" href="dwarf2read_8c.html#a509e9fa93beee310decdddd99d011ef3">get_abbrev_section_for_cu</a> (this_cu);
<a name="l05278"></a>05278 
<a name="l05279"></a>05279   <span class="keywordflow">if</span> (use_existing_cu &amp;&amp; this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> != NULL)
<a name="l05280"></a>05280     {
<a name="l05281"></a>05281       cu = this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>;
<a name="l05282"></a>05282 
<a name="l05283"></a>05283       <span class="comment">/* If this CU is from a DWO file we need to start over, we need to</span>
<a name="l05284"></a>05284 <span class="comment">         refetch the attributes from the skeleton CU.</span>
<a name="l05285"></a>05285 <span class="comment">         This could be optimized by retrieving those attributes from when we</span>
<a name="l05286"></a>05286 <span class="comment">         were here the first time: the previous comp_unit_die was stored in</span>
<a name="l05287"></a>05287 <span class="comment">         comp_unit_obstack.  But there&#39;s no data yet that we need this</span>
<a name="l05288"></a>05288 <span class="comment">         optimization.  */</span>
<a name="l05289"></a>05289       <span class="keywordflow">if</span> (cu-&gt;dwo_unit != NULL)
<a name="l05290"></a>05290         rereading_dwo_cu = 1;
<a name="l05291"></a>05291     }
<a name="l05292"></a>05292   <span class="keywordflow">else</span>
<a name="l05293"></a>05293     {
<a name="l05294"></a>05294       <span class="comment">/* If !use_existing_cu, this_cu-&gt;cu must be NULL.  */</span>
<a name="l05295"></a>05295       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> == NULL);
<a name="l05296"></a>05296 
<a name="l05297"></a>05297       cu = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (*cu));
<a name="l05298"></a>05298       <a class="code" href="dwarf2read_8c.html#abd170e25a0f34cecee142a0252b26d82">init_one_comp_unit</a> (cu, this_cu);
<a name="l05299"></a>05299 
<a name="l05300"></a>05300       <span class="comment">/* If an error occurs while loading, release our storage.  */</span>
<a name="l05301"></a>05301       free_cu_cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#a686d2ded76f9904b6f35d4402ee17230">free_heap_comp_unit</a>, cu);
<a name="l05302"></a>05302     }
<a name="l05303"></a>05303 
<a name="l05304"></a>05304   <span class="comment">/* Get the header.  */</span>
<a name="l05305"></a>05305   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a08a38b7787804c4cb0e7baa1280da286">first_die_offset</a>.<a class="code" href="structcu__offset.html#a19224b0dc5f0bc49babd2b7701a8d63e">cu_off</a> != 0 &amp;&amp; ! rereading_dwo_cu)
<a name="l05306"></a>05306     {
<a name="l05307"></a>05307       <span class="comment">/* We already have the header, there&#39;s no need to read it in again.  */</span>
<a name="l05308"></a>05308       info_ptr += cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a08a38b7787804c4cb0e7baa1280da286">first_die_offset</a>.<a class="code" href="structcu__offset.html#a19224b0dc5f0bc49babd2b7701a8d63e">cu_off</a>;
<a name="l05309"></a>05309     }
<a name="l05310"></a>05310   <span class="keywordflow">else</span>
<a name="l05311"></a>05311     {
<a name="l05312"></a>05312       <span class="keywordflow">if</span> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l05313"></a>05313         {
<a name="l05314"></a>05314           <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> signature;
<a name="l05315"></a>05315           <a class="code" href="structcu__offset.html">cu_offset</a> type_offset_in_tu;
<a name="l05316"></a>05316 
<a name="l05317"></a>05317           info_ptr = <a class="code" href="dwarf2read_8c.html#a3e530db440df1aa6cf5bae99d3c49667">read_and_check_type_unit_head</a> (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>, section,
<a name="l05318"></a>05318                                                     abbrev_section, info_ptr,
<a name="l05319"></a>05319                                                     &amp;signature,
<a name="l05320"></a>05320                                                     &amp;type_offset_in_tu);
<a name="l05321"></a>05321 
<a name="l05322"></a>05322           <span class="comment">/* Since per_cu is the first member of struct signatured_type,</span>
<a name="l05323"></a>05323 <span class="comment">             we can go from a pointer to one to a pointer to the other.  */</span>
<a name="l05324"></a>05324           sig_type = (<span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *) this_cu;
<a name="l05325"></a>05325           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sig_type-&gt;<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a> == signature);
<a name="l05326"></a>05326           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sig_type-&gt;<a class="code" href="structsignatured__type.html#ab152a3e1f687ff6464b369502ce745a9">type_offset_in_tu</a>.<a class="code" href="structcu__offset.html#a19224b0dc5f0bc49babd2b7701a8d63e">cu_off</a>
<a name="l05327"></a>05327                       == type_offset_in_tu.<a class="code" href="structcu__offset.html#a19224b0dc5f0bc49babd2b7701a8d63e">cu_off</a>);
<a name="l05328"></a>05328           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> == cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l05329"></a>05329 
<a name="l05330"></a>05330           <span class="comment">/* LENGTH has not been set yet for type units if we&#39;re</span>
<a name="l05331"></a>05331 <span class="comment">             using .gdb_index.  */</span>
<a name="l05332"></a>05332           this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a> = <a class="code" href="dwarf2read_8c.html#a64dfe5d648dc5396cd471de3540fef30">get_cu_length</a> (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>);
<a name="l05333"></a>05333 
<a name="l05334"></a>05334           <span class="comment">/* Establish the type offset that can be used to lookup the type.  */</span>
<a name="l05335"></a>05335           sig_type-&gt;<a class="code" href="structsignatured__type.html#aa8e49a69ad9d6311b553b063fa0fe62d">type_offset_in_section</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> =
<a name="l05336"></a>05336             this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> + sig_type-&gt;<a class="code" href="structsignatured__type.html#ab152a3e1f687ff6464b369502ce745a9">type_offset_in_tu</a>.<a class="code" href="structcu__offset.html#a19224b0dc5f0bc49babd2b7701a8d63e">cu_off</a>;
<a name="l05337"></a>05337         }
<a name="l05338"></a>05338       <span class="keywordflow">else</span>
<a name="l05339"></a>05339         {
<a name="l05340"></a>05340           info_ptr = <a class="code" href="dwarf2read_8c.html#ab4a5d6610652463f5cf265ddbdfb8d58">read_and_check_comp_unit_head</a> (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>, section,
<a name="l05341"></a>05341                                                     abbrev_section,
<a name="l05342"></a>05342                                                     info_ptr, 0);
<a name="l05343"></a>05343 
<a name="l05344"></a>05344           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> == cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l05345"></a>05345           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a> == <a class="code" href="dwarf2read_8c.html#a64dfe5d648dc5396cd471de3540fef30">get_cu_length</a> (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>));
<a name="l05346"></a>05346         }
<a name="l05347"></a>05347     }
<a name="l05348"></a>05348 
<a name="l05349"></a>05349   <span class="comment">/* Skip dummy compilation units.  */</span>
<a name="l05350"></a>05350   <span class="keywordflow">if</span> (info_ptr &gt;= begin_info_ptr + this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a>
<a name="l05351"></a>05351       || <a class="code" href="dwarf2read_8c.html#a750ce8dd923161d4fd41793c6965ca6c">peek_abbrev_code</a> (abfd, info_ptr) == 0)
<a name="l05352"></a>05352     {
<a name="l05353"></a>05353       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l05354"></a>05354       <span class="keywordflow">return</span>;
<a name="l05355"></a>05355     }
<a name="l05356"></a>05356 
<a name="l05357"></a>05357   <span class="comment">/* If we don&#39;t have them yet, read the abbrevs for this compilation unit.</span>
<a name="l05358"></a>05358 <span class="comment">     And if we need to read them now, make sure they&#39;re freed when we&#39;re</span>
<a name="l05359"></a>05359 <span class="comment">     done.  Note that it&#39;s important that if the CU had an abbrev table</span>
<a name="l05360"></a>05360 <span class="comment">     on entry we don&#39;t free it when we&#39;re done: Somewhere up the call stack</span>
<a name="l05361"></a>05361 <span class="comment">     it may be in use.  */</span>
<a name="l05362"></a>05362   <span class="keywordflow">if</span> (abbrev_table != NULL)
<a name="l05363"></a>05363     {
<a name="l05364"></a>05364       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a57e9b37ae0dfd83c0e16565ca75c9781">abbrev_table</a> == NULL);
<a name="l05365"></a>05365       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a5455b96122116b3881197362c7e35758">abbrev_offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>
<a name="l05366"></a>05366                   == abbrev_table-&gt;<a class="code" href="structabbrev__table.html#a5b67ef89ee9470388052b1acd4c44b57">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l05367"></a>05367       cu-&gt;<a class="code" href="structdwarf2__cu.html#a57e9b37ae0dfd83c0e16565ca75c9781">abbrev_table</a> = abbrev_table;
<a name="l05368"></a>05368     }
<a name="l05369"></a>05369   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a57e9b37ae0dfd83c0e16565ca75c9781">abbrev_table</a> == NULL)
<a name="l05370"></a>05370     {
<a name="l05371"></a>05371       <a class="code" href="dwarf2read_8c.html#a2ab84af9aed9d7ab89a9c1389bf09944">dwarf2_read_abbrevs</a> (cu, abbrev_section);
<a name="l05372"></a>05372       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#a966c2eb4689779cf219c72bbcda90b83">dwarf2_free_abbrev_table</a>, cu);
<a name="l05373"></a>05373     }
<a name="l05374"></a>05374   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rereading_dwo_cu)
<a name="l05375"></a>05375     {
<a name="l05376"></a>05376       <a class="code" href="dwarf2read_8c.html#a966c2eb4689779cf219c72bbcda90b83">dwarf2_free_abbrev_table</a> (cu);
<a name="l05377"></a>05377       <a class="code" href="dwarf2read_8c.html#a2ab84af9aed9d7ab89a9c1389bf09944">dwarf2_read_abbrevs</a> (cu, abbrev_section);
<a name="l05378"></a>05378     }
<a name="l05379"></a>05379 
<a name="l05380"></a>05380   <span class="comment">/* Read the top level CU/TU die.  */</span>
<a name="l05381"></a>05381   <a class="code" href="dwarf2read_8c.html#a06f516ef314a0f5754cc936dc16391d7">init_cu_die_reader</a> (&amp;reader, cu, section, NULL);
<a name="l05382"></a>05382   info_ptr = <a class="code" href="dwarf2read_8c.html#a80d70a70850cfc7be97670eab43c98d8">read_full_die</a> (&amp;reader, &amp;comp_unit_die, info_ptr, &amp;has_children);
<a name="l05383"></a>05383 
<a name="l05384"></a>05384   <span class="comment">/* If we are in a DWO stub, process it and then read in the &quot;real&quot; CU/TU</span>
<a name="l05385"></a>05385 <span class="comment">     from the DWO file.</span>
<a name="l05386"></a>05386 <span class="comment">     Note that if USE_EXISTING_OK != 0, and THIS_CU-&gt;cu already contains a</span>
<a name="l05387"></a>05387 <span class="comment">     DWO CU, that this test will fail (the attribute will not be present).  */</span>
<a name="l05388"></a>05388   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (comp_unit_die, DW_AT_GNU_dwo_name, cu);
<a name="l05389"></a>05389   <span class="keywordflow">if</span> (attr)
<a name="l05390"></a>05390     {
<a name="l05391"></a>05391       <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structdwo__unit.html">dwo_unit</a>;
<a name="l05392"></a>05392       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *dwo_comp_unit_die;
<a name="l05393"></a>05393 
<a name="l05394"></a>05394       <span class="keywordflow">if</span> (has_children)
<a name="l05395"></a>05395         {
<a name="l05396"></a>05396           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l05397"></a>05397                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;compilation unit with DW_AT_GNU_dwo_name&quot;</span>
<a name="l05398"></a>05398                        <span class="stringliteral">&quot; has children (offset 0x%x) [in module %s]&quot;</span>),
<a name="l05399"></a>05399                      this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, bfd_get_filename (abfd));
<a name="l05400"></a>05400         }
<a name="l05401"></a>05401       dwo_unit = <a class="code" href="dwarf2read_8c.html#a1dac520e324b3f04813ab73447dcd0c2">lookup_dwo_unit</a> (this_cu, comp_unit_die);
<a name="l05402"></a>05402       <span class="keywordflow">if</span> (dwo_unit != NULL)
<a name="l05403"></a>05403         {
<a name="l05404"></a>05404           <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a4461cfd6a80b28cd6273bbfd54535392">read_cutu_die_from_dwo</a> (this_cu, dwo_unit,
<a name="l05405"></a>05405                                       abbrev_table != NULL,
<a name="l05406"></a>05406                                       comp_unit_die, NULL,
<a name="l05407"></a>05407                                       &amp;reader, &amp;info_ptr,
<a name="l05408"></a>05408                                       &amp;dwo_comp_unit_die, &amp;has_children) == 0)
<a name="l05409"></a>05409             {
<a name="l05410"></a>05410               <span class="comment">/* Dummy die.  */</span>
<a name="l05411"></a>05411               <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l05412"></a>05412               <span class="keywordflow">return</span>;
<a name="l05413"></a>05413             }
<a name="l05414"></a>05414           comp_unit_die = dwo_comp_unit_die;
<a name="l05415"></a>05415         }
<a name="l05416"></a>05416       <span class="keywordflow">else</span>
<a name="l05417"></a>05417         {
<a name="l05418"></a>05418           <span class="comment">/* Yikes, we couldn&#39;t find the rest of the DIE, we only have</span>
<a name="l05419"></a>05419 <span class="comment">             the stub.  A complaint has already been logged.  There&#39;s</span>
<a name="l05420"></a>05420 <span class="comment">             not much more we can do except pass on the stub DIE to</span>
<a name="l05421"></a>05421 <span class="comment">             die_reader_func.  We don&#39;t want to throw an error on bad</span>
<a name="l05422"></a>05422 <span class="comment">             debug info.  */</span>
<a name="l05423"></a>05423         }
<a name="l05424"></a>05424     }
<a name="l05425"></a>05425 
<a name="l05426"></a>05426   <span class="comment">/* All of the above is setup for this call.  Yikes.  */</span>
<a name="l05427"></a>05427   die_reader_func (&amp;reader, info_ptr, comp_unit_die, has_children, data);
<a name="l05428"></a>05428 
<a name="l05429"></a>05429   <span class="comment">/* Done, clean up.  */</span>
<a name="l05430"></a>05430   <span class="keywordflow">if</span> (free_cu_cleanup != NULL)
<a name="l05431"></a>05431     {
<a name="l05432"></a>05432       <span class="keywordflow">if</span> (keep)
<a name="l05433"></a>05433         {
<a name="l05434"></a>05434           <span class="comment">/* We&#39;ve successfully allocated this compilation unit.  Let our</span>
<a name="l05435"></a>05435 <span class="comment">             caller clean it up when finished with it.  */</span>
<a name="l05436"></a>05436           <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (free_cu_cleanup);
<a name="l05437"></a>05437 
<a name="l05438"></a>05438           <span class="comment">/* We can only discard free_cu_cleanup and all subsequent cleanups.</span>
<a name="l05439"></a>05439 <span class="comment">             So we have to manually free the abbrev table.  */</span>
<a name="l05440"></a>05440           <a class="code" href="dwarf2read_8c.html#a966c2eb4689779cf219c72bbcda90b83">dwarf2_free_abbrev_table</a> (cu);
<a name="l05441"></a>05441 
<a name="l05442"></a>05442           <span class="comment">/* Link this CU into read_in_chain.  */</span>
<a name="l05443"></a>05443           this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ad4caa7a7978fa4ca2edef259dd77a8ef">read_in_chain</a> = dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a250e2511524a3122ba1489978a303221">read_in_chain</a>;
<a name="l05444"></a>05444           dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a250e2511524a3122ba1489978a303221">read_in_chain</a> = this_cu;
<a name="l05445"></a>05445         }
<a name="l05446"></a>05446       <span class="keywordflow">else</span>
<a name="l05447"></a>05447         <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (free_cu_cleanup);
<a name="l05448"></a>05448     }
<a name="l05449"></a>05449 
<a name="l05450"></a>05450   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l05451"></a>05451 }
<a name="l05452"></a>05452 
<a name="l05453"></a>05453 <span class="comment">/* Read CU/TU THIS_CU in section SECTION,</span>
<a name="l05454"></a>05454 <span class="comment">   but do not follow DW_AT_GNU_dwo_name if present.</span>
<a name="l05455"></a>05455 <span class="comment">   DWOP_FILE, if non-NULL, is the DWO/DWP file to read (the caller is assumed</span>
<a name="l05456"></a>05456 <span class="comment">   to have already done the lookup to find the DWO/DWP file).</span>
<a name="l05457"></a>05457 <span class="comment"></span>
<a name="l05458"></a>05458 <span class="comment">   The caller is required to fill in THIS_CU-&gt;section, THIS_CU-&gt;offset, and</span>
<a name="l05459"></a>05459 <span class="comment">   THIS_CU-&gt;is_debug_types, but nothing else.</span>
<a name="l05460"></a>05460 <span class="comment"></span>
<a name="l05461"></a>05461 <span class="comment">   We fill in THIS_CU-&gt;length.</span>
<a name="l05462"></a>05462 <span class="comment"></span>
<a name="l05463"></a>05463 <span class="comment">   WARNING: If THIS_CU is a &quot;dummy CU&quot; (used as filler by the incremental</span>
<a name="l05464"></a>05464 <span class="comment">   linker) then DIE_READER_FUNC will not get called.</span>
<a name="l05465"></a>05465 <span class="comment"></span>
<a name="l05466"></a>05466 <span class="comment">   THIS_CU-&gt;cu is always freed when done.</span>
<a name="l05467"></a>05467 <span class="comment">   This is done in order to not leave THIS_CU-&gt;cu in a state where we have</span>
<a name="l05468"></a>05468 <span class="comment">   to care whether it refers to the &quot;main&quot; CU or the DWO CU.  */</span>
<a name="l05469"></a>05469 
<a name="l05470"></a>05470 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05471"></a><a class="code" href="dwarf2read_8c.html#a28ed78ebf707564f0999e64b8e3e642b">05471</a> <a class="code" href="dwarf2read_8c.html#a28ed78ebf707564f0999e64b8e3e642b">init_cutu_and_read_dies_no_follow</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu,
<a name="l05472"></a>05472                                    <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *abbrev_section,
<a name="l05473"></a>05473                                    <span class="keyword">struct</span> dwo_file *dwo_file,
<a name="l05474"></a>05474                                    <a class="code" href="dwarf2read_8c.html#a78918e349d1b0b7715599fa171aab050">die_reader_func_ftype</a> *die_reader_func,
<a name="l05475"></a>05475                                    <span class="keywordtype">void</span> *data)
<a name="l05476"></a>05476 {
<a name="l05477"></a>05477   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l05478"></a>05478   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section = this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a>;
<a name="l05479"></a>05479   bfd *abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l05480"></a>05480   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> cu;
<a name="l05481"></a>05481   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *begin_info_ptr, *info_ptr;
<a name="l05482"></a>05482   <span class="keyword">struct </span><a class="code" href="structdie__reader__specs.html">die_reader_specs</a> reader;
<a name="l05483"></a>05483   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups;
<a name="l05484"></a>05484   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *comp_unit_die;
<a name="l05485"></a>05485   <span class="keywordtype">int</span> has_children;
<a name="l05486"></a>05486 
<a name="l05487"></a>05487   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a1a718830b2084a029498b587ad66aeae">dwarf2_die_debug</a>)
<a name="l05488"></a>05488     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Reading %s unit at offset 0x%x\n&quot;</span>,
<a name="l05489"></a>05489                         this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a> ? <span class="stringliteral">&quot;type&quot;</span> : <span class="stringliteral">&quot;comp&quot;</span>,
<a name="l05490"></a>05490                         this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l05491"></a>05491 
<a name="l05492"></a>05492   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> == NULL);
<a name="l05493"></a>05493 
<a name="l05494"></a>05494   <span class="comment">/* This is cheap if the section is already read in.  */</span>
<a name="l05495"></a>05495   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, section);
<a name="l05496"></a>05496 
<a name="l05497"></a>05497   <a class="code" href="dwarf2read_8c.html#abd170e25a0f34cecee142a0252b26d82">init_one_comp_unit</a> (&amp;cu, this_cu);
<a name="l05498"></a>05498 
<a name="l05499"></a>05499   cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#ac4c57bb71ff493266c9d5a80a484dcbe">free_stack_comp_unit</a>, &amp;cu);
<a name="l05500"></a>05500 
<a name="l05501"></a>05501   begin_info_ptr = info_ptr = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l05502"></a>05502   info_ptr = <a class="code" href="dwarf2read_8c.html#ab4a5d6610652463f5cf265ddbdfb8d58">read_and_check_comp_unit_head</a> (&amp;cu.<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>, section,
<a name="l05503"></a>05503                                             abbrev_section, info_ptr,
<a name="l05504"></a>05504                                             this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l05505"></a>05505 
<a name="l05506"></a>05506   this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a> = <a class="code" href="dwarf2read_8c.html#a64dfe5d648dc5396cd471de3540fef30">get_cu_length</a> (&amp;cu.<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>);
<a name="l05507"></a>05507 
<a name="l05508"></a>05508   <span class="comment">/* Skip dummy compilation units.  */</span>
<a name="l05509"></a>05509   <span class="keywordflow">if</span> (info_ptr &gt;= begin_info_ptr + this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a>
<a name="l05510"></a>05510       || <a class="code" href="dwarf2read_8c.html#a750ce8dd923161d4fd41793c6965ca6c">peek_abbrev_code</a> (abfd, info_ptr) == 0)
<a name="l05511"></a>05511     {
<a name="l05512"></a>05512       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l05513"></a>05513       <span class="keywordflow">return</span>;
<a name="l05514"></a>05514     }
<a name="l05515"></a>05515 
<a name="l05516"></a>05516   <a class="code" href="dwarf2read_8c.html#a2ab84af9aed9d7ab89a9c1389bf09944">dwarf2_read_abbrevs</a> (&amp;cu, abbrev_section);
<a name="l05517"></a>05517   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#a966c2eb4689779cf219c72bbcda90b83">dwarf2_free_abbrev_table</a>, &amp;cu);
<a name="l05518"></a>05518 
<a name="l05519"></a>05519   <a class="code" href="dwarf2read_8c.html#a06f516ef314a0f5754cc936dc16391d7">init_cu_die_reader</a> (&amp;reader, &amp;cu, section, dwo_file);
<a name="l05520"></a>05520   info_ptr = <a class="code" href="dwarf2read_8c.html#a80d70a70850cfc7be97670eab43c98d8">read_full_die</a> (&amp;reader, &amp;comp_unit_die, info_ptr, &amp;has_children);
<a name="l05521"></a>05521 
<a name="l05522"></a>05522   die_reader_func (&amp;reader, info_ptr, comp_unit_die, has_children, data);
<a name="l05523"></a>05523 
<a name="l05524"></a>05524   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l05525"></a>05525 }
<a name="l05526"></a>05526 
<a name="l05527"></a>05527 <span class="comment">/* Read a CU/TU, except that this does not look for DW_AT_GNU_dwo_name and</span>
<a name="l05528"></a>05528 <span class="comment">   does not lookup the specified DWO file.</span>
<a name="l05529"></a>05529 <span class="comment">   This cannot be used to read DWO files.</span>
<a name="l05530"></a>05530 <span class="comment"></span>
<a name="l05531"></a>05531 <span class="comment">   THIS_CU-&gt;cu is always freed when done.</span>
<a name="l05532"></a>05532 <span class="comment">   This is done in order to not leave THIS_CU-&gt;cu in a state where we have</span>
<a name="l05533"></a>05533 <span class="comment">   to care whether it refers to the &quot;main&quot; CU or the DWO CU.</span>
<a name="l05534"></a>05534 <span class="comment">   We can revisit this if the data shows there&#39;s a performance issue.  */</span>
<a name="l05535"></a>05535 
<a name="l05536"></a>05536 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05537"></a><a class="code" href="dwarf2read_8c.html#aa76270ede1b4c1ab21e449e875a982bf">05537</a> <a class="code" href="dwarf2read_8c.html#aa76270ede1b4c1ab21e449e875a982bf">init_cutu_and_read_dies_simple</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu,
<a name="l05538"></a>05538                                 <a class="code" href="dwarf2read_8c.html#a78918e349d1b0b7715599fa171aab050">die_reader_func_ftype</a> *die_reader_func,
<a name="l05539"></a>05539                                 <span class="keywordtype">void</span> *data)
<a name="l05540"></a>05540 {
<a name="l05541"></a>05541   <a class="code" href="dwarf2read_8c.html#a28ed78ebf707564f0999e64b8e3e642b">init_cutu_and_read_dies_no_follow</a> (this_cu,
<a name="l05542"></a>05542                                      <a class="code" href="dwarf2read_8c.html#a509e9fa93beee310decdddd99d011ef3">get_abbrev_section_for_cu</a> (this_cu),
<a name="l05543"></a>05543                                      NULL,
<a name="l05544"></a>05544                                      die_reader_func, data);
<a name="l05545"></a>05545 }
<a name="l05546"></a>05546 
<a name="l05547"></a>05547 <span class="comment">/* Type Unit Groups.</span>
<a name="l05548"></a>05548 <span class="comment"></span>
<a name="l05549"></a>05549 <span class="comment">   Type Unit Groups are a way to collapse the set of all TUs (type units) into</span>
<a name="l05550"></a>05550 <span class="comment">   a more manageable set.  The grouping is done by DW_AT_stmt_list entry</span>
<a name="l05551"></a>05551 <span class="comment">   so that all types coming from the same compilation (.o file) are grouped</span>
<a name="l05552"></a>05552 <span class="comment">   together.  A future step could be to put the types in the same symtab as</span>
<a name="l05553"></a>05553 <span class="comment">   the CU the types ultimately came from.  */</span>
<a name="l05554"></a>05554 
<a name="l05555"></a>05555 <span class="keyword">static</span> hashval_t
<a name="l05556"></a><a class="code" href="dwarf2read_8c.html#a36668564084e1cecb4a97529b8b4f6d4">05556</a> <a class="code" href="dwarf2read_8c.html#a36668564084e1cecb4a97529b8b4f6d4">hash_type_unit_group</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item)
<a name="l05557"></a>05557 {
<a name="l05558"></a>05558   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> *tu_group = item;
<a name="l05559"></a>05559 
<a name="l05560"></a>05560   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#ae3cc097ac351c0e57b998b829c209d76">hash_stmt_list_entry</a> (&amp;tu_group-&gt;hash);
<a name="l05561"></a>05561 }
<a name="l05562"></a>05562 
<a name="l05563"></a>05563 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05564"></a><a class="code" href="dwarf2read_8c.html#a39acc8f38a3ab275297f095ba656f4fc">05564</a> <a class="code" href="dwarf2read_8c.html#a39acc8f38a3ab275297f095ba656f4fc">eq_type_unit_group</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item_lhs, <span class="keyword">const</span> <span class="keywordtype">void</span> *item_rhs)
<a name="l05565"></a>05565 {
<a name="l05566"></a>05566   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> *lhs = item_lhs;
<a name="l05567"></a>05567   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> *rhs = item_rhs;
<a name="l05568"></a>05568 
<a name="l05569"></a>05569   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a9a42bd39ee9332303f5be90a2f2f9b77">eq_stmt_list_entry</a> (&amp;lhs-&gt;hash, &amp;rhs-&gt;hash);
<a name="l05570"></a>05570 }
<a name="l05571"></a>05571 
<a name="l05572"></a>05572 <span class="comment">/* Allocate a hash table for type unit groups.  */</span>
<a name="l05573"></a>05573 
<a name="l05574"></a>05574 <span class="keyword">static</span> htab_t
<a name="l05575"></a><a class="code" href="dwarf2read_8c.html#a16ef447ead07715b5149c7d61a23dab6">05575</a> <a class="code" href="dwarf2read_8c.html#a16ef447ead07715b5149c7d61a23dab6">allocate_type_unit_groups_table</a> (<span class="keywordtype">void</span>)
<a name="l05576"></a>05576 {
<a name="l05577"></a>05577   <span class="keywordflow">return</span> htab_create_alloc_ex (3,
<a name="l05578"></a>05578                                <a class="code" href="dwarf2read_8c.html#a36668564084e1cecb4a97529b8b4f6d4">hash_type_unit_group</a>,
<a name="l05579"></a>05579                                <a class="code" href="dwarf2read_8c.html#a39acc8f38a3ab275297f095ba656f4fc">eq_type_unit_group</a>,
<a name="l05580"></a>05580                                NULL,
<a name="l05581"></a>05581                                &amp;dwarf2_per_objfile-&gt;objfile-&gt;objfile_obstack,
<a name="l05582"></a>05582                                <a class="code" href="utils_8c.html#a64b0a5e317b6f45f062aa8356111644b">hashtab_obstack_allocate</a>,
<a name="l05583"></a>05583                                <a class="code" href="utils_8c.html#af32d0d55c7c49d59093e66ef695f9513">dummy_obstack_deallocate</a>);
<a name="l05584"></a>05584 }
<a name="l05585"></a>05585 
<a name="l05586"></a>05586 <span class="comment">/* Type units that don&#39;t have DW_AT_stmt_list are grouped into their own</span>
<a name="l05587"></a>05587 <span class="comment">   partial symtabs.  We combine several TUs per psymtab to not let the size</span>
<a name="l05588"></a>05588 <span class="comment">   of any one psymtab grow too big.  */</span>
<a name="l05589"></a><a class="code" href="dwarf2read_8c.html#ae088f6b71386033d131bd75809a9835d">05589</a> <span class="preprocessor">#define NO_STMT_LIST_TYPE_UNIT_PSYMTAB (1 &lt;&lt; 31)</span>
<a name="l05590"></a><a class="code" href="dwarf2read_8c.html#a8633f77d87ef0907334a9c17230762a4">05590</a> <span class="preprocessor"></span><span class="preprocessor">#define NO_STMT_LIST_TYPE_UNIT_PSYMTAB_SIZE 10</span>
<a name="l05591"></a>05591 <span class="preprocessor"></span>
<a name="l05592"></a>05592 <span class="comment">/* Helper routine for get_type_unit_group.</span>
<a name="l05593"></a>05593 <span class="comment">   Create the type_unit_group object used to hold one or more TUs.  */</span>
<a name="l05594"></a>05594 
<a name="l05595"></a>05595 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> *
<a name="l05596"></a><a class="code" href="dwarf2read_8c.html#a4e9c6c10c5b5d0fdb22012f5e4b07fe0">05596</a> <a class="code" href="dwarf2read_8c.html#a4e9c6c10c5b5d0fdb22012f5e4b07fe0">create_type_unit_group</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <a class="code" href="structsect__offset.html">sect_offset</a> line_offset_struct)
<a name="l05597"></a>05597 {
<a name="l05598"></a>05598   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l05599"></a>05599   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu;
<a name="l05600"></a>05600   <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> *tu_group;
<a name="l05601"></a>05601 
<a name="l05602"></a>05602   tu_group = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l05603"></a>05603                              <span class="keyword">struct</span> <a class="code" href="structtype__unit__group.html">type_unit_group</a>);
<a name="l05604"></a>05604   per_cu = &amp;tu_group-&gt;<a class="code" href="structtype__unit__group.html#a4811e92ec66f2823829defcf2d3c9b29">per_cu</a>;
<a name="l05605"></a>05605   per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a> = objfile;
<a name="l05606"></a>05606 
<a name="l05607"></a>05607   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a>)
<a name="l05608"></a>05608     {
<a name="l05609"></a>05609       per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a> = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l05610"></a>05610                                         <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__quick__data.html">dwarf2_per_cu_quick_data</a>);
<a name="l05611"></a>05611     }
<a name="l05612"></a>05612   <span class="keywordflow">else</span>
<a name="l05613"></a>05613     {
<a name="l05614"></a>05614       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structline__offset.html">line_offset</a> = line_offset_struct.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l05615"></a>05615       <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst;
<a name="l05616"></a>05616       <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l05617"></a>05617 
<a name="l05618"></a>05618       <span class="comment">/* Give the symtab a useful name for debug purposes.  */</span>
<a name="l05619"></a>05619       <span class="keywordflow">if</span> ((line_offset &amp; <a class="code" href="dwarf2read_8c.html#ae088f6b71386033d131bd75809a9835d">NO_STMT_LIST_TYPE_UNIT_PSYMTAB</a>) != 0)
<a name="l05620"></a>05620         name = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;&lt;type_units_%d&gt;&quot;</span>,
<a name="l05621"></a>05621                            (line_offset &amp; ~NO_STMT_LIST_TYPE_UNIT_PSYMTAB));
<a name="l05622"></a>05622       <span class="keywordflow">else</span>
<a name="l05623"></a>05623         name = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;&lt;type_units_at_0x%x&gt;&quot;</span>, line_offset);
<a name="l05624"></a>05624 
<a name="l05625"></a>05625       pst = <a class="code" href="dwarf2read_8c.html#ab4b70e57fa288b01beeda2f9526b5fde">create_partial_symtab</a> (per_cu, name);
<a name="l05626"></a>05626       pst-&gt;<a class="code" href="structpartial__symtab.html#a72ab74ae49f0048cc7151d786e724235">anonymous</a> = 1;
<a name="l05627"></a>05627 
<a name="l05628"></a>05628       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (name);
<a name="l05629"></a>05629     }
<a name="l05630"></a>05630 
<a name="l05631"></a>05631   tu_group-&gt;hash.dwo_unit = cu-&gt;dwo_unit;
<a name="l05632"></a>05632   tu_group-&gt;hash.line_offset = line_offset_struct;
<a name="l05633"></a>05633 
<a name="l05634"></a>05634   <span class="keywordflow">return</span> tu_group;
<a name="l05635"></a>05635 }
<a name="l05636"></a>05636 
<a name="l05637"></a>05637 <span class="comment">/* Look up the type_unit_group for type unit CU, and create it if necessary.</span>
<a name="l05638"></a>05638 <span class="comment">   STMT_LIST is a DW_AT_stmt_list attribute.  */</span>
<a name="l05639"></a>05639 
<a name="l05640"></a>05640 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> *
<a name="l05641"></a><a class="code" href="dwarf2read_8c.html#a32cdecdad4aa06e351612fb574d1c638">05641</a> <a class="code" href="dwarf2read_8c.html#a32cdecdad4aa06e351612fb574d1c638">get_type_unit_group</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *stmt_list)
<a name="l05642"></a>05642 {
<a name="l05643"></a>05643   <span class="keyword">struct </span>tu_stats *tu_stats = &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a8400b6ac2dd6967c4652daf45c991590">tu_stats</a>;
<a name="l05644"></a>05644   <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> *tu_group;
<a name="l05645"></a>05645   <span class="keywordtype">void</span> **slot;
<a name="l05646"></a>05646   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structline__offset.html">line_offset</a>;
<a name="l05647"></a>05647   <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> type_unit_group_for_lookup;
<a name="l05648"></a>05648 
<a name="l05649"></a>05649   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;type_unit_groups == NULL)
<a name="l05650"></a>05650     {
<a name="l05651"></a>05651       dwarf2_per_objfile-&gt;type_unit_groups =
<a name="l05652"></a>05652         <a class="code" href="dwarf2read_8c.html#a16ef447ead07715b5149c7d61a23dab6">allocate_type_unit_groups_table</a> ();
<a name="l05653"></a>05653     }
<a name="l05654"></a>05654 
<a name="l05655"></a>05655   <span class="comment">/* Do we need to create a new group, or can we use an existing one?  */</span>
<a name="l05656"></a>05656 
<a name="l05657"></a>05657   <span class="keywordflow">if</span> (stmt_list)
<a name="l05658"></a>05658     {
<a name="l05659"></a>05659       line_offset = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (stmt_list);
<a name="l05660"></a>05660       ++tu_stats-&gt;nr_symtab_sharers;
<a name="l05661"></a>05661     }
<a name="l05662"></a>05662   <span class="keywordflow">else</span>
<a name="l05663"></a>05663     {
<a name="l05664"></a>05664       <span class="comment">/* Ugh, no stmt_list.  Rare, but we have to handle it.</span>
<a name="l05665"></a>05665 <span class="comment">         We can do various things here like create one group per TU or</span>
<a name="l05666"></a>05666 <span class="comment">         spread them over multiple groups to split up the expansion work.</span>
<a name="l05667"></a>05667 <span class="comment">         To avoid worst case scenarios (too many groups or too large groups)</span>
<a name="l05668"></a>05668 <span class="comment">         we, umm, group them in bunches.  */</span>
<a name="l05669"></a>05669       line_offset = (<a class="code" href="dwarf2read_8c.html#ae088f6b71386033d131bd75809a9835d">NO_STMT_LIST_TYPE_UNIT_PSYMTAB</a>
<a name="l05670"></a>05670                      | (tu_stats-&gt;nr_stmt_less_type_units
<a name="l05671"></a>05671                         / <a class="code" href="dwarf2read_8c.html#a8633f77d87ef0907334a9c17230762a4">NO_STMT_LIST_TYPE_UNIT_PSYMTAB_SIZE</a>));
<a name="l05672"></a>05672       ++tu_stats-&gt;nr_stmt_less_type_units;
<a name="l05673"></a>05673     }
<a name="l05674"></a>05674 
<a name="l05675"></a>05675   type_unit_group_for_lookup.hash.dwo_unit = cu-&gt;dwo_unit;
<a name="l05676"></a>05676   type_unit_group_for_lookup.hash.line_offset.sect_off = line_offset;
<a name="l05677"></a>05677   slot = htab_find_slot (dwarf2_per_objfile-&gt;type_unit_groups,
<a name="l05678"></a>05678                          &amp;type_unit_group_for_lookup, INSERT);
<a name="l05679"></a>05679   <span class="keywordflow">if</span> (*slot != NULL)
<a name="l05680"></a>05680     {
<a name="l05681"></a>05681       tu_group = *slot;
<a name="l05682"></a>05682       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (tu_group != NULL);
<a name="l05683"></a>05683     }
<a name="l05684"></a>05684   <span class="keywordflow">else</span>
<a name="l05685"></a>05685     {
<a name="l05686"></a>05686       <a class="code" href="structsect__offset.html">sect_offset</a> line_offset_struct;
<a name="l05687"></a>05687 
<a name="l05688"></a>05688       line_offset_struct.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = line_offset;
<a name="l05689"></a>05689       tu_group = <a class="code" href="dwarf2read_8c.html#a4e9c6c10c5b5d0fdb22012f5e4b07fe0">create_type_unit_group</a> (cu, line_offset_struct);
<a name="l05690"></a>05690       *slot = tu_group;
<a name="l05691"></a>05691       ++tu_stats-&gt;nr_symtabs;
<a name="l05692"></a>05692     }
<a name="l05693"></a>05693 
<a name="l05694"></a>05694   <span class="keywordflow">return</span> tu_group;
<a name="l05695"></a>05695 }
<a name="l05696"></a>05696 
<a name="l05697"></a>05697 <span class="comment">/* Struct used to sort TUs by their abbreviation table offset.  */</span>
<a name="l05698"></a>05698 
<a name="l05699"></a><a class="code" href="structtu__abbrev__offset.html">05699</a> <span class="keyword">struct </span><a class="code" href="structtu__abbrev__offset.html">tu_abbrev_offset</a>
<a name="l05700"></a>05700 {
<a name="l05701"></a><a class="code" href="structtu__abbrev__offset.html#a07ecbcac821e37958a344696c53cd8c8">05701</a>   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *<a class="code" href="structtu__abbrev__offset.html#a07ecbcac821e37958a344696c53cd8c8">sig_type</a>;
<a name="l05702"></a><a class="code" href="structtu__abbrev__offset.html#a88b0f1a19f77afe8701dd0d671253c16">05702</a>   <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="structtu__abbrev__offset.html#a88b0f1a19f77afe8701dd0d671253c16">abbrev_offset</a>;
<a name="l05703"></a>05703 };
<a name="l05704"></a>05704 
<a name="l05705"></a>05705 <span class="comment">/* Helper routine for build_type_unit_groups, passed to qsort.  */</span>
<a name="l05706"></a>05706 
<a name="l05707"></a>05707 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05708"></a><a class="code" href="dwarf2read_8c.html#abe98ec284e7af3a688ffd8717b4bad88">05708</a> <a class="code" href="dwarf2read_8c.html#abe98ec284e7af3a688ffd8717b4bad88">sort_tu_by_abbrev_offset</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *ap, <span class="keyword">const</span> <span class="keywordtype">void</span> *bp)
<a name="l05709"></a>05709 {
<a name="l05710"></a>05710   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structtu__abbrev__offset.html">tu_abbrev_offset</a> * <span class="keyword">const</span> *a = ap;
<a name="l05711"></a>05711   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structtu__abbrev__offset.html">tu_abbrev_offset</a> * <span class="keyword">const</span> *b = bp;
<a name="l05712"></a>05712   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> aoff = (*a)-&gt;<a class="code" href="structtu__abbrev__offset.html#a88b0f1a19f77afe8701dd0d671253c16">abbrev_offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l05713"></a>05713   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> boff = (*b)-&gt;abbrev_offset.sect_off;
<a name="l05714"></a>05714 
<a name="l05715"></a>05715   <span class="keywordflow">return</span> (aoff &gt; boff) - (aoff &lt; boff);
<a name="l05716"></a>05716 }
<a name="l05717"></a>05717 
<a name="l05718"></a>05718 <span class="comment">/* A helper function to add a type_unit_group to a table.  */</span>
<a name="l05719"></a>05719 
<a name="l05720"></a>05720 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05721"></a><a class="code" href="dwarf2read_8c.html#a430fd8196043826e1b5efc50d8d8abce">05721</a> <a class="code" href="dwarf2read_8c.html#a430fd8196043826e1b5efc50d8d8abce">add_type_unit_group_to_table</a> (<span class="keywordtype">void</span> **slot, <span class="keywordtype">void</span> *datum)
<a name="l05722"></a>05722 {
<a name="l05723"></a>05723   <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> *tu_group = *slot;
<a name="l05724"></a>05724   <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> ***datap = datum;
<a name="l05725"></a>05725 
<a name="l05726"></a>05726   **datap = tu_group;
<a name="l05727"></a>05727   ++*datap;
<a name="l05728"></a>05728 
<a name="l05729"></a>05729   <span class="keywordflow">return</span> 1;
<a name="l05730"></a>05730 }
<a name="l05731"></a>05731 
<a name="l05732"></a>05732 <span class="comment">/* Efficiently read all the type units, calling init_cutu_and_read_dies on</span>
<a name="l05733"></a>05733 <span class="comment">   each one passing FUNC,DATA.</span>
<a name="l05734"></a>05734 <span class="comment"></span>
<a name="l05735"></a>05735 <span class="comment">   The efficiency is because we sort TUs by the abbrev table they use and</span>
<a name="l05736"></a>05736 <span class="comment">   only read each abbrev table once.  In one program there are 200K TUs</span>
<a name="l05737"></a>05737 <span class="comment">   sharing 8K abbrev tables.</span>
<a name="l05738"></a>05738 <span class="comment"></span>
<a name="l05739"></a>05739 <span class="comment">   The main purpose of this function is to support building the</span>
<a name="l05740"></a>05740 <span class="comment">   dwarf2_per_objfile-&gt;type_unit_groups table.</span>
<a name="l05741"></a>05741 <span class="comment">   TUs typically share the DW_AT_stmt_list of the CU they came from, so we</span>
<a name="l05742"></a>05742 <span class="comment">   can collapse the search space by grouping them by stmt_list.</span>
<a name="l05743"></a>05743 <span class="comment">   The savings can be significant, in the same program from above the 200K TUs</span>
<a name="l05744"></a>05744 <span class="comment">   share 8K stmt_list tables.</span>
<a name="l05745"></a>05745 <span class="comment"></span>
<a name="l05746"></a>05746 <span class="comment">   FUNC is expected to call get_type_unit_group, which will create the</span>
<a name="l05747"></a>05747 <span class="comment">   struct type_unit_group if necessary and add it to</span>
<a name="l05748"></a>05748 <span class="comment">   dwarf2_per_objfile-&gt;type_unit_groups.  */</span>
<a name="l05749"></a>05749 
<a name="l05750"></a>05750 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05751"></a><a class="code" href="dwarf2read_8c.html#ae4869ba53444635ffb37ac46abd1a045">05751</a> <a class="code" href="dwarf2read_8c.html#ae4869ba53444635ffb37ac46abd1a045">build_type_unit_groups</a> (<a class="code" href="dwarf2read_8c.html#a78918e349d1b0b7715599fa171aab050">die_reader_func_ftype</a> *<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>, <span class="keywordtype">void</span> *data)
<a name="l05752"></a>05752 {
<a name="l05753"></a>05753   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l05754"></a>05754   <span class="keyword">struct </span>tu_stats *tu_stats = &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a8400b6ac2dd6967c4652daf45c991590">tu_stats</a>;
<a name="l05755"></a>05755   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups;
<a name="l05756"></a>05756   <span class="keyword">struct </span><a class="code" href="structabbrev__table.html">abbrev_table</a> *<a class="code" href="structabbrev__table.html">abbrev_table</a>;
<a name="l05757"></a>05757   <a class="code" href="structsect__offset.html">sect_offset</a> abbrev_offset;
<a name="l05758"></a>05758   <span class="keyword">struct </span><a class="code" href="structtu__abbrev__offset.html">tu_abbrev_offset</a> *sorted_by_abbrev;
<a name="l05759"></a>05759   <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> **iter;
<a name="l05760"></a>05760   <span class="keywordtype">int</span> i;
<a name="l05761"></a>05761 
<a name="l05762"></a>05762   <span class="comment">/* It&#39;s up to the caller to not call us multiple times.  */</span>
<a name="l05763"></a>05763   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (dwarf2_per_objfile-&gt;type_unit_groups == NULL);
<a name="l05764"></a>05764 
<a name="l05765"></a>05765   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;n_type_units == 0)
<a name="l05766"></a>05766     <span class="keywordflow">return</span>;
<a name="l05767"></a>05767 
<a name="l05768"></a>05768   <span class="comment">/* TUs typically share abbrev tables, and there can be way more TUs than</span>
<a name="l05769"></a>05769 <span class="comment">     abbrev tables.  Sort by abbrev table to reduce the number of times we</span>
<a name="l05770"></a>05770 <span class="comment">     read each abbrev table in.</span>
<a name="l05771"></a>05771 <span class="comment">     Alternatives are to punt or to maintain a cache of abbrev tables.</span>
<a name="l05772"></a>05772 <span class="comment">     This is simpler and efficient enough for now.</span>
<a name="l05773"></a>05773 <span class="comment"></span>
<a name="l05774"></a>05774 <span class="comment">     Later we group TUs by their DW_AT_stmt_list value (as this defines the</span>
<a name="l05775"></a>05775 <span class="comment">     symtab to use).  Typically TUs with the same abbrev offset have the same</span>
<a name="l05776"></a>05776 <span class="comment">     stmt_list value too so in practice this should work well.</span>
<a name="l05777"></a>05777 <span class="comment"></span>
<a name="l05778"></a>05778 <span class="comment">     The basic algorithm here is:</span>
<a name="l05779"></a>05779 <span class="comment"></span>
<a name="l05780"></a>05780 <span class="comment">      sort TUs by abbrev table</span>
<a name="l05781"></a>05781 <span class="comment">      for each TU with same abbrev table:</span>
<a name="l05782"></a>05782 <span class="comment">        read abbrev table if first user</span>
<a name="l05783"></a>05783 <span class="comment">        read TU top level DIE</span>
<a name="l05784"></a>05784 <span class="comment">          [IWBN if DWO skeletons had DW_AT_stmt_list]</span>
<a name="l05785"></a>05785 <span class="comment">        call FUNC  */</span>
<a name="l05786"></a>05786 
<a name="l05787"></a>05787   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l05788"></a>05788     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Building type unit groups ...\n&quot;</span>);
<a name="l05789"></a>05789 
<a name="l05790"></a>05790   <span class="comment">/* Sort in a separate table to maintain the order of all_type_units</span>
<a name="l05791"></a>05791 <span class="comment">     for .gdb_index: TU indices directly index all_type_units.  */</span>
<a name="l05792"></a>05792   sorted_by_abbrev = XNEWVEC (<span class="keyword">struct</span> <a class="code" href="structtu__abbrev__offset.html">tu_abbrev_offset</a>,
<a name="l05793"></a>05793                               dwarf2_per_objfile-&gt;n_type_units);
<a name="l05794"></a>05794   <span class="keywordflow">for</span> (i = 0; i &lt; dwarf2_per_objfile-&gt;n_type_units; ++i)
<a name="l05795"></a>05795     {
<a name="l05796"></a>05796       <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type = dwarf2_per_objfile-&gt;all_type_units[i];
<a name="l05797"></a>05797 
<a name="l05798"></a>05798       sorted_by_abbrev[i].<a class="code" href="structtu__abbrev__offset.html#a07ecbcac821e37958a344696c53cd8c8">sig_type</a> = sig_type;
<a name="l05799"></a>05799       sorted_by_abbrev[i].<a class="code" href="structtu__abbrev__offset.html#a88b0f1a19f77afe8701dd0d671253c16">abbrev_offset</a> =
<a name="l05800"></a>05800         <a class="code" href="dwarf2read_8c.html#a425a94e1261e39a64375fdca7368bca2">read_abbrev_offset</a> (sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a>,
<a name="l05801"></a>05801                             sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>);
<a name="l05802"></a>05802     }
<a name="l05803"></a>05803   cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, sorted_by_abbrev);
<a name="l05804"></a>05804   <a class="code" href="ada-exp_8c.html#a849e2297facde4d3c80dc4f45f8abbdb">qsort</a> (sorted_by_abbrev, dwarf2_per_objfile-&gt;n_type_units,
<a name="l05805"></a>05805          sizeof (<span class="keyword">struct</span> <a class="code" href="structtu__abbrev__offset.html">tu_abbrev_offset</a>), <a class="code" href="dwarf2read_8c.html#abe98ec284e7af3a688ffd8717b4bad88">sort_tu_by_abbrev_offset</a>);
<a name="l05806"></a>05806 
<a name="l05807"></a>05807   <span class="comment">/* Note: In the .gdb_index case, get_type_unit_group may have already been</span>
<a name="l05808"></a>05808 <span class="comment">     called any number of times, so we don&#39;t reset tu_stats here.  */</span>
<a name="l05809"></a>05809 
<a name="l05810"></a>05810   abbrev_offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = ~(unsigned) 0;
<a name="l05811"></a>05811   abbrev_table = NULL;
<a name="l05812"></a>05812   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#a6c9598f51c0ca31c3f615940abb8d605">abbrev_table_free_cleanup</a>, &amp;abbrev_table);
<a name="l05813"></a>05813 
<a name="l05814"></a>05814   <span class="keywordflow">for</span> (i = 0; i &lt; dwarf2_per_objfile-&gt;n_type_units; ++i)
<a name="l05815"></a>05815     {
<a name="l05816"></a>05816       <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structtu__abbrev__offset.html">tu_abbrev_offset</a> *tu = &amp;sorted_by_abbrev[i];
<a name="l05817"></a>05817 
<a name="l05818"></a>05818       <span class="comment">/* Switch to the next abbrev table if necessary.  */</span>
<a name="l05819"></a>05819       <span class="keywordflow">if</span> (abbrev_table == NULL
<a name="l05820"></a>05820           || tu-&gt;<a class="code" href="structtu__abbrev__offset.html#a88b0f1a19f77afe8701dd0d671253c16">abbrev_offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> != abbrev_offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>)
<a name="l05821"></a>05821         {
<a name="l05822"></a>05822           <span class="keywordflow">if</span> (abbrev_table != NULL)
<a name="l05823"></a>05823             {
<a name="l05824"></a>05824               <a class="code" href="dwarf2read_8c.html#a657ffcf72df342d61df4a8893fc6151f">abbrev_table_free</a> (abbrev_table);
<a name="l05825"></a>05825               <span class="comment">/* Reset to NULL in case abbrev_table_read_table throws</span>
<a name="l05826"></a>05826 <span class="comment">                 an error: abbrev_table_free_cleanup will get called.  */</span>
<a name="l05827"></a>05827               abbrev_table = NULL;
<a name="l05828"></a>05828             }
<a name="l05829"></a>05829           abbrev_offset = tu-&gt;<a class="code" href="structtu__abbrev__offset.html#a88b0f1a19f77afe8701dd0d671253c16">abbrev_offset</a>;
<a name="l05830"></a>05830           abbrev_table =
<a name="l05831"></a>05831             <a class="code" href="dwarf2read_8c.html#a7c5fe8c826ddc3a8ecdcb9e7899912f3">abbrev_table_read_table</a> (&amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a65f092d6a408e872a5b5f724728353de">abbrev</a>,
<a name="l05832"></a>05832                                      abbrev_offset);
<a name="l05833"></a>05833           ++tu_stats-&gt;nr_uniq_abbrev_tables;
<a name="l05834"></a>05834         }
<a name="l05835"></a>05835 
<a name="l05836"></a>05836       <a class="code" href="dwarf2read_8c.html#a2887b925bcf54483d1c0dc40faefdd08">init_cutu_and_read_dies</a> (&amp;tu-&gt;<a class="code" href="structtu__abbrev__offset.html#a07ecbcac821e37958a344696c53cd8c8">sig_type</a>-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>, abbrev_table, 0, 0,
<a name="l05837"></a>05837                                func, data);
<a name="l05838"></a>05838     }
<a name="l05839"></a>05839 
<a name="l05840"></a>05840   <span class="comment">/* type_unit_groups can be NULL if there is an error in the debug info.</span>
<a name="l05841"></a>05841 <span class="comment">     Just create an empty table so the rest of gdb doesn&#39;t have to watch</span>
<a name="l05842"></a>05842 <span class="comment">     for this error case.  */</span>
<a name="l05843"></a>05843   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;type_unit_groups == NULL)
<a name="l05844"></a>05844     {
<a name="l05845"></a>05845       dwarf2_per_objfile-&gt;type_unit_groups =
<a name="l05846"></a>05846         <a class="code" href="dwarf2read_8c.html#a16ef447ead07715b5149c7d61a23dab6">allocate_type_unit_groups_table</a> ();
<a name="l05847"></a>05847       dwarf2_per_objfile-&gt;n_type_unit_groups = 0;
<a name="l05848"></a>05848     }
<a name="l05849"></a>05849 
<a name="l05850"></a>05850   <span class="comment">/* Create a vector of pointers to primary type units to make it easy to</span>
<a name="l05851"></a>05851 <span class="comment">     iterate over them and CUs.  See dw2_get_primary_cu.  */</span>
<a name="l05852"></a>05852   dwarf2_per_objfile-&gt;n_type_unit_groups =
<a name="l05853"></a>05853     htab_elements (dwarf2_per_objfile-&gt;type_unit_groups);
<a name="l05854"></a>05854   dwarf2_per_objfile-&gt;all_type_unit_groups =
<a name="l05855"></a>05855     obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l05856"></a>05856                    dwarf2_per_objfile-&gt;n_type_unit_groups
<a name="l05857"></a>05857                    * sizeof (<span class="keyword">struct</span> <a class="code" href="structtype__unit__group.html">type_unit_group</a> *));
<a name="l05858"></a>05858   iter = &amp;dwarf2_per_objfile-&gt;all_type_unit_groups[0];
<a name="l05859"></a>05859   htab_traverse_noresize (dwarf2_per_objfile-&gt;type_unit_groups,
<a name="l05860"></a>05860                           <a class="code" href="dwarf2read_8c.html#a430fd8196043826e1b5efc50d8d8abce">add_type_unit_group_to_table</a>, &amp;iter);
<a name="l05861"></a>05861   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (iter - &amp;dwarf2_per_objfile-&gt;all_type_unit_groups[0]
<a name="l05862"></a>05862               == dwarf2_per_objfile-&gt;n_type_unit_groups);
<a name="l05863"></a>05863 
<a name="l05864"></a>05864   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l05865"></a>05865 
<a name="l05866"></a>05866   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l05867"></a>05867     {
<a name="l05868"></a>05868       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Done building type unit groups:\n&quot;</span>);
<a name="l05869"></a>05869       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;  %d TUs\n&quot;</span>,
<a name="l05870"></a>05870                           dwarf2_per_objfile-&gt;n_type_units);
<a name="l05871"></a>05871       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;  %d uniq abbrev tables\n&quot;</span>,
<a name="l05872"></a>05872                           tu_stats-&gt;nr_uniq_abbrev_tables);
<a name="l05873"></a>05873       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;  %d symtabs from stmt_list entries\n&quot;</span>,
<a name="l05874"></a>05874                           tu_stats-&gt;nr_symtabs);
<a name="l05875"></a>05875       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;  %d symtab sharers\n&quot;</span>,
<a name="l05876"></a>05876                           tu_stats-&gt;nr_symtab_sharers);
<a name="l05877"></a>05877       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;  %d type units without a stmt_list\n&quot;</span>,
<a name="l05878"></a>05878                           tu_stats-&gt;nr_stmt_less_type_units);
<a name="l05879"></a>05879     }
<a name="l05880"></a>05880 }
<a name="l05881"></a>05881 
<a name="l05882"></a>05882 <span class="comment">/* Partial symbol tables.  */</span>
<a name="l05883"></a>05883 
<a name="l05884"></a>05884 <span class="comment">/* Create a psymtab named NAME and assign it to PER_CU.</span>
<a name="l05885"></a>05885 <span class="comment"></span>
<a name="l05886"></a>05886 <span class="comment">   The caller must fill in the following details:</span>
<a name="l05887"></a>05887 <span class="comment">   dirname, textlow, texthigh.  */</span>
<a name="l05888"></a>05888 
<a name="l05889"></a>05889 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *
<a name="l05890"></a><a class="code" href="dwarf2read_8c.html#ab4b70e57fa288b01beeda2f9526b5fde">05890</a> <a class="code" href="dwarf2read_8c.html#ab4b70e57fa288b01beeda2f9526b5fde">create_partial_symtab</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l05891"></a>05891 {
<a name="l05892"></a>05892   <span class="keyword">struct </span>objfile *objfile = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>;
<a name="l05893"></a>05893   <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst;
<a name="l05894"></a>05894 
<a name="l05895"></a>05895   pst = <a class="code" href="psympriv_8h.html#ae1da6f85572732c205a3d0e7bfaa4898">start_psymtab_common</a> (objfile, objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>,
<a name="l05896"></a>05896                               name, 0,
<a name="l05897"></a>05897                               objfile-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#a47883420b19f6e99ee9989eb600ce6e5">next</a>,
<a name="l05898"></a>05898                               objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#a47883420b19f6e99ee9989eb600ce6e5">next</a>);
<a name="l05899"></a>05899 
<a name="l05900"></a>05900   pst-&gt;<a class="code" href="structpartial__symtab.html#aa4a6c5beadf5f2d9b39a06c04c728fa2">psymtabs_addrmap_supported</a> = 1;
<a name="l05901"></a>05901 
<a name="l05902"></a>05902   <span class="comment">/* This is the glue that links PST into GDB&#39;s symbol API.  */</span>
<a name="l05903"></a>05903   pst-&gt;<a class="code" href="structpartial__symtab.html#a1d7dd223683b0ca2baeaa6bf5c3e90a3">read_symtab_private</a> = per_cu;
<a name="l05904"></a>05904   pst-&gt;<a class="code" href="structpartial__symtab.html#a51a53dce450ff3473f03a903aa06b263">read_symtab</a> = <a class="code" href="dwarf2read_8c.html#ad51fcf6e9b38c802ac64c2dc6f19d167">dwarf2_read_symtab</a>;
<a name="l05905"></a>05905   per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a> = pst;
<a name="l05906"></a>05906 
<a name="l05907"></a>05907   <span class="keywordflow">return</span> pst;
<a name="l05908"></a>05908 }
<a name="l05909"></a>05909 
<a name="l05910"></a>05910 <span class="comment">/* The DATA object passed to process_psymtab_comp_unit_reader has this</span>
<a name="l05911"></a>05911 <span class="comment">   type.  */</span>
<a name="l05912"></a>05912 
<a name="l05913"></a><a class="code" href="structprocess__psymtab__comp__unit__data.html">05913</a> <span class="keyword">struct </span><a class="code" href="structprocess__psymtab__comp__unit__data.html">process_psymtab_comp_unit_data</a>
<a name="l05914"></a>05914 {
<a name="l05915"></a>05915   <span class="comment">/* True if we are reading a DW_TAG_partial_unit.  */</span>
<a name="l05916"></a>05916 
<a name="l05917"></a><a class="code" href="structprocess__psymtab__comp__unit__data.html#a6963a3ee73575f803aa4f608b8e22edf">05917</a>   <span class="keywordtype">int</span> <a class="code" href="structprocess__psymtab__comp__unit__data.html#a6963a3ee73575f803aa4f608b8e22edf">want_partial_unit</a>;
<a name="l05918"></a>05918 
<a name="l05919"></a>05919   <span class="comment">/* The &quot;pretend&quot; language that is used if the CU doesn&#39;t declare a</span>
<a name="l05920"></a>05920 <span class="comment">     language.  */</span>
<a name="l05921"></a>05921 
<a name="l05922"></a><a class="code" href="structprocess__psymtab__comp__unit__data.html#a989c7496e7c600274d67527264e2e2fe">05922</a>   <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> <a class="code" href="structprocess__psymtab__comp__unit__data.html#a989c7496e7c600274d67527264e2e2fe">pretend_language</a>;
<a name="l05923"></a>05923 };
<a name="l05924"></a>05924 
<a name="l05925"></a>05925 <span class="comment">/* die_reader_func for process_psymtab_comp_unit.  */</span>
<a name="l05926"></a>05926 
<a name="l05927"></a>05927 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05928"></a><a class="code" href="dwarf2read_8c.html#a045dbe9d9294a229b10a50c25c7c7bce">05928</a> <a class="code" href="dwarf2read_8c.html#a045dbe9d9294a229b10a50c25c7c7bce">process_psymtab_comp_unit_reader</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l05929"></a>05929                                   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l05930"></a>05930                                   <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *comp_unit_die,
<a name="l05931"></a>05931                                   <span class="keywordtype">int</span> has_children,
<a name="l05932"></a>05932                                   <span class="keywordtype">void</span> *data)
<a name="l05933"></a>05933 {
<a name="l05934"></a>05934   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l05935"></a>05935   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l05936"></a>05936   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;
<a name="l05937"></a>05937   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l05938"></a>05938   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> baseaddr;
<a name="l05939"></a>05939   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> best_lowpc = 0, best_highpc = 0;
<a name="l05940"></a>05940   <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst;
<a name="l05941"></a>05941   <span class="keywordtype">int</span> has_pc_info;
<a name="l05942"></a>05942   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structpartial__symtab.html#a6ea70ac87d6dbd541967bdd6dacd7321">filename</a>;
<a name="l05943"></a>05943   <span class="keyword">struct </span><a class="code" href="structprocess__psymtab__comp__unit__data.html">process_psymtab_comp_unit_data</a> *info = data;
<a name="l05944"></a>05944 
<a name="l05945"></a>05945   <span class="keywordflow">if</span> (comp_unit_die-&gt;tag == DW_TAG_partial_unit &amp;&amp; !info-&gt;<a class="code" href="structprocess__psymtab__comp__unit__data.html#a6963a3ee73575f803aa4f608b8e22edf">want_partial_unit</a>)
<a name="l05946"></a>05946     <span class="keywordflow">return</span>;
<a name="l05947"></a>05947 
<a name="l05948"></a>05948   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (! per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l05949"></a>05949 
<a name="l05950"></a>05950   <a class="code" href="dwarf2read_8c.html#a7a6cb8459a76588ce7ef6a56b19ef5c8">prepare_one_comp_unit</a> (cu, comp_unit_die, info-&gt;<a class="code" href="structprocess__psymtab__comp__unit__data.html#a989c7496e7c600274d67527264e2e2fe">pretend_language</a>);
<a name="l05951"></a>05951 
<a name="l05952"></a>05952   cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a> = &amp;<a class="code" href="buildsym_8h.html#a2d83ed7f7eeffeffeb2e00320573fd0d">file_symbols</a>;
<a name="l05953"></a>05953 
<a name="l05954"></a>05954   <span class="comment">/* Allocate a new partial symbol table structure.  */</span>
<a name="l05955"></a>05955   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (comp_unit_die, DW_AT_name, cu);
<a name="l05956"></a>05956   <span class="keywordflow">if</span> (attr == NULL || !<a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr))
<a name="l05957"></a>05957     filename = <span class="stringliteral">&quot;&quot;</span>;
<a name="l05958"></a>05958   <span class="keywordflow">else</span>
<a name="l05959"></a>05959     filename = <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr);
<a name="l05960"></a>05960 
<a name="l05961"></a>05961   pst = <a class="code" href="dwarf2read_8c.html#ab4b70e57fa288b01beeda2f9526b5fde">create_partial_symtab</a> (per_cu, filename);
<a name="l05962"></a>05962 
<a name="l05963"></a>05963   <span class="comment">/* This must be done before calling dwarf2_build_include_psymtabs.  */</span>
<a name="l05964"></a>05964   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (comp_unit_die, DW_AT_comp_dir, cu);
<a name="l05965"></a>05965   <span class="keywordflow">if</span> (attr != NULL)
<a name="l05966"></a>05966     pst-&gt;<a class="code" href="structpartial__symtab.html#a4861f775b1cc7a848abdf336238dbb37">dirname</a> = <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr);
<a name="l05967"></a>05967 
<a name="l05968"></a>05968   baseaddr = <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>, <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l05969"></a>05969 
<a name="l05970"></a>05970   <a class="code" href="dwarf2read_8c.html#af314d232c2dcff121c89ecf2ed276658">dwarf2_find_base_address</a> (comp_unit_die, cu);
<a name="l05971"></a>05971 
<a name="l05972"></a>05972   <span class="comment">/* Possibly set the default values of LOWPC and HIGHPC from</span>
<a name="l05973"></a>05973 <span class="comment">     `DW_AT_ranges&#39;.  */</span>
<a name="l05974"></a>05974   has_pc_info = <a class="code" href="dwarf2read_8c.html#ad8168e871bf8c579c8dbc4a6aad6bc0a">dwarf2_get_pc_bounds</a> (comp_unit_die, &amp;best_lowpc,
<a name="l05975"></a>05975                                       &amp;best_highpc, cu, pst);
<a name="l05976"></a>05976   <span class="keywordflow">if</span> (has_pc_info == 1 &amp;&amp; best_lowpc &lt; best_highpc)
<a name="l05977"></a>05977     <span class="comment">/* Store the contiguous range if it is not empty; it can be empty for</span>
<a name="l05978"></a>05978 <span class="comment">       CUs with no code.  */</span>
<a name="l05979"></a>05979     <a class="code" href="addrmap_8c.html#ad0decf9c15214a17313c8c9d9828205c">addrmap_set_empty</a> (objfile-&gt;<a class="code" href="structobjfile.html#ae7c792f2cd4efcff86d84d7bd3e15b26">psymtabs_addrmap</a>,
<a name="l05980"></a>05980                        best_lowpc + baseaddr,
<a name="l05981"></a>05981                        best_highpc + baseaddr - 1, pst);
<a name="l05982"></a>05982 
<a name="l05983"></a>05983   <span class="comment">/* Check if comp unit has_children.</span>
<a name="l05984"></a>05984 <span class="comment">     If so, read the rest of the partial symbols from this comp unit.</span>
<a name="l05985"></a>05985 <span class="comment">     If not, there&#39;s no more debug_info for this comp unit.  */</span>
<a name="l05986"></a>05986   <span class="keywordflow">if</span> (has_children)
<a name="l05987"></a>05987     {
<a name="l05988"></a>05988       <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *first_die;
<a name="l05989"></a>05989       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a>, <a class="code" href="structpartial__die__info.html#a958cea19f3de0168488931ed04efc700">highpc</a>;
<a name="l05990"></a>05990 
<a name="l05991"></a>05991       lowpc = ((<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) -1);
<a name="l05992"></a>05992       highpc = ((<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 0);
<a name="l05993"></a>05993 
<a name="l05994"></a>05994       first_die = <a class="code" href="dwarf2read_8c.html#a2bf39a75877292252ae39938c7fa6885">load_partial_dies</a> (reader, info_ptr, 1);
<a name="l05995"></a>05995 
<a name="l05996"></a>05996       <a class="code" href="dwarf2read_8c.html#aeffcf90b9b19c7413fc505d0bf8e8657">scan_partial_symbols</a> (first_die, &amp;lowpc, &amp;highpc,
<a name="l05997"></a>05997                             ! has_pc_info, cu);
<a name="l05998"></a>05998 
<a name="l05999"></a>05999       <span class="comment">/* If we didn&#39;t find a lowpc, set it to highpc to avoid</span>
<a name="l06000"></a>06000 <span class="comment">         complaints from `maint check&#39;.  */</span>
<a name="l06001"></a>06001       <span class="keywordflow">if</span> (lowpc == ((<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) -1))
<a name="l06002"></a>06002         lowpc = <a class="code" href="structpartial__die__info.html#a958cea19f3de0168488931ed04efc700">highpc</a>;
<a name="l06003"></a>06003 
<a name="l06004"></a>06004       <span class="comment">/* If the compilation unit didn&#39;t have an explicit address range,</span>
<a name="l06005"></a>06005 <span class="comment">         then use the information extracted from its child dies.  */</span>
<a name="l06006"></a>06006       <span class="keywordflow">if</span> (! has_pc_info)
<a name="l06007"></a>06007         {
<a name="l06008"></a>06008           best_lowpc = <a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a>;
<a name="l06009"></a>06009           best_highpc = <a class="code" href="structpartial__die__info.html#a958cea19f3de0168488931ed04efc700">highpc</a>;
<a name="l06010"></a>06010         }
<a name="l06011"></a>06011     }
<a name="l06012"></a>06012   pst-&gt;<a class="code" href="structpartial__symtab.html#a194e7d3c21d81ce56b81d1fe02e1dbc3">textlow</a> = best_lowpc + baseaddr;
<a name="l06013"></a>06013   pst-&gt;<a class="code" href="structpartial__symtab.html#aa582095c68fb326f3042ad672527a438">texthigh</a> = best_highpc + baseaddr;
<a name="l06014"></a>06014 
<a name="l06015"></a>06015   pst-&gt;<a class="code" href="structpartial__symtab.html#ab26039959ff434afcf130049cfa8d27d">n_global_syms</a> = objfile-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#a47883420b19f6e99ee9989eb600ce6e5">next</a> -
<a name="l06016"></a>06016     (objfile-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#ac618c483c3ff07162cdfe508abd6034d">list</a> + pst-&gt;<a class="code" href="structpartial__symtab.html#ae11f1094416fd506398f4a58fe4fa405">globals_offset</a>);
<a name="l06017"></a>06017   pst-&gt;<a class="code" href="structpartial__symtab.html#a0fd67e243d440beaf6cc4757a97ff9b0">n_static_syms</a> = objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#a47883420b19f6e99ee9989eb600ce6e5">next</a> -
<a name="l06018"></a>06018     (objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#ac618c483c3ff07162cdfe508abd6034d">list</a> + pst-&gt;<a class="code" href="structpartial__symtab.html#a36b8c771ea2906e413b8f1fffe1f4d10">statics_offset</a>);
<a name="l06019"></a>06019   <a class="code" href="psympriv_8h.html#a6cea36b8ce21ebe0c95e2cab2a0fc4eb">sort_pst_symbols</a> (objfile, pst);
<a name="l06020"></a>06020 
<a name="l06021"></a>06021   <span class="keywordflow">if</span> (!<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (dwarf2_per_cu_ptr, cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;imported_symtabs))
<a name="l06022"></a>06022     {
<a name="l06023"></a>06023       <span class="keywordtype">int</span> i;
<a name="l06024"></a>06024       <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a> = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (dwarf2_per_cu_ptr, cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;imported_symtabs);
<a name="l06025"></a>06025       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *iter;
<a name="l06026"></a>06026 
<a name="l06027"></a>06027       <span class="comment">/* Fill in &#39;dependencies&#39; here; we fill in &#39;users&#39; in a</span>
<a name="l06028"></a>06028 <span class="comment">         post-pass.  */</span>
<a name="l06029"></a>06029       pst-&gt;<a class="code" href="structpartial__symtab.html#a917b503a5e1f7c2bb60feb6ff1e3b197">number_of_dependencies</a> = <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l06030"></a>06030       pst-&gt;<a class="code" href="structpartial__symtab.html#a0b7bd5bada02a362357552790b111c23">dependencies</a> = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l06031"></a>06031                                          len * sizeof (<span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *));
<a name="l06032"></a>06032       <span class="keywordflow">for</span> (i = 0;
<a name="l06033"></a>06033            <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (dwarf2_per_cu_ptr, cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;imported_symtabs,
<a name="l06034"></a>06034                         i, iter);
<a name="l06035"></a>06035            ++i)
<a name="l06036"></a>06036         pst-&gt;<a class="code" href="structpartial__symtab.html#a0b7bd5bada02a362357552790b111c23">dependencies</a>[i] = iter-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a>;
<a name="l06037"></a>06037 
<a name="l06038"></a>06038       <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (dwarf2_per_cu_ptr, cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;imported_symtabs);
<a name="l06039"></a>06039     }
<a name="l06040"></a>06040 
<a name="l06041"></a>06041   <span class="comment">/* Get the list of files included in the current compilation unit,</span>
<a name="l06042"></a>06042 <span class="comment">     and build a psymtab for each of them.  */</span>
<a name="l06043"></a>06043   <a class="code" href="dwarf2read_8c.html#a09cdb6c79e4ca34592ff1928d6f48113">dwarf2_build_include_psymtabs</a> (cu, comp_unit_die, pst);
<a name="l06044"></a>06044 
<a name="l06045"></a>06045   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l06046"></a>06046     {
<a name="l06047"></a>06047       <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l06048"></a>06048 
<a name="l06049"></a>06049       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l06050"></a>06050                           <span class="stringliteral">&quot;Psymtab for %s unit @0x%x: %s - %s&quot;</span>
<a name="l06051"></a>06051                           <span class="stringliteral">&quot;, %d global, %d static syms\n&quot;</span>,
<a name="l06052"></a>06052                           per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a> ? <span class="stringliteral">&quot;type&quot;</span> : <span class="stringliteral">&quot;comp&quot;</span>,
<a name="l06053"></a>06053                           per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>,
<a name="l06054"></a>06054                           <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, pst-&gt;<a class="code" href="structpartial__symtab.html#a194e7d3c21d81ce56b81d1fe02e1dbc3">textlow</a>),
<a name="l06055"></a>06055                           <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, pst-&gt;<a class="code" href="structpartial__symtab.html#aa582095c68fb326f3042ad672527a438">texthigh</a>),
<a name="l06056"></a>06056                           pst-&gt;<a class="code" href="structpartial__symtab.html#ab26039959ff434afcf130049cfa8d27d">n_global_syms</a>, pst-&gt;<a class="code" href="structpartial__symtab.html#a0fd67e243d440beaf6cc4757a97ff9b0">n_static_syms</a>);
<a name="l06057"></a>06057     }
<a name="l06058"></a>06058 }
<a name="l06059"></a>06059 
<a name="l06060"></a>06060 <span class="comment">/* Subroutine of dwarf2_build_psymtabs_hard to simplify it.</span>
<a name="l06061"></a>06061 <span class="comment">   Process compilation unit THIS_CU for a psymtab.  */</span>
<a name="l06062"></a>06062 
<a name="l06063"></a>06063 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06064"></a><a class="code" href="dwarf2read_8c.html#aa88ea6d1e16d075f5799dfcf104a8d00">06064</a> <a class="code" href="dwarf2read_8c.html#aa88ea6d1e16d075f5799dfcf104a8d00">process_psymtab_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu,
<a name="l06065"></a>06065                            <span class="keywordtype">int</span> want_partial_unit,
<a name="l06066"></a>06066                            <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> pretend_language)
<a name="l06067"></a>06067 {
<a name="l06068"></a>06068   <span class="keyword">struct </span><a class="code" href="structprocess__psymtab__comp__unit__data.html">process_psymtab_comp_unit_data</a> info;
<a name="l06069"></a>06069 
<a name="l06070"></a>06070   <span class="comment">/* If this compilation unit was already read in, free the</span>
<a name="l06071"></a>06071 <span class="comment">     cached copy in order to read it in again.  This is</span>
<a name="l06072"></a>06072 <span class="comment">     necessary because we skipped some symbols when we first</span>
<a name="l06073"></a>06073 <span class="comment">     read in the compilation unit (see load_partial_dies).</span>
<a name="l06074"></a>06074 <span class="comment">     This problem could be avoided, but the benefit is unclear.  */</span>
<a name="l06075"></a>06075   <span class="keywordflow">if</span> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> != NULL)
<a name="l06076"></a>06076     <a class="code" href="dwarf2read_8c.html#a88ac0ca2997594c6c41d77ceeb620711">free_one_cached_comp_unit</a> (this_cu);
<a name="l06077"></a>06077 
<a name="l06078"></a>06078   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (! this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l06079"></a>06079   info.<a class="code" href="structprocess__psymtab__comp__unit__data.html#a6963a3ee73575f803aa4f608b8e22edf">want_partial_unit</a> = <a class="code" href="structprocess__psymtab__comp__unit__data.html#a6963a3ee73575f803aa4f608b8e22edf">want_partial_unit</a>;
<a name="l06080"></a>06080   info.<a class="code" href="structprocess__psymtab__comp__unit__data.html#a989c7496e7c600274d67527264e2e2fe">pretend_language</a> = <a class="code" href="structprocess__psymtab__comp__unit__data.html#a989c7496e7c600274d67527264e2e2fe">pretend_language</a>;
<a name="l06081"></a>06081   <a class="code" href="dwarf2read_8c.html#a2887b925bcf54483d1c0dc40faefdd08">init_cutu_and_read_dies</a> (this_cu, NULL, 0, 0,
<a name="l06082"></a>06082                            <a class="code" href="dwarf2read_8c.html#a045dbe9d9294a229b10a50c25c7c7bce">process_psymtab_comp_unit_reader</a>,
<a name="l06083"></a>06083                            &amp;info);
<a name="l06084"></a>06084 
<a name="l06085"></a>06085   <span class="comment">/* Age out any secondary CUs.  */</span>
<a name="l06086"></a>06086   <a class="code" href="dwarf2read_8c.html#aea3bec269cdf43d65a84eb61d8c2c48b">age_cached_comp_units</a> ();
<a name="l06087"></a>06087 }
<a name="l06088"></a>06088 
<a name="l06089"></a>06089 <span class="comment">/* Reader function for build_type_psymtabs.  */</span>
<a name="l06090"></a>06090 
<a name="l06091"></a>06091 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06092"></a><a class="code" href="dwarf2read_8c.html#a2707fd06d6d6d2b2c386606cab2e20d8">06092</a> <a class="code" href="dwarf2read_8c.html#a2707fd06d6d6d2b2c386606cab2e20d8">build_type_psymtabs_reader</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l06093"></a>06093                             <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l06094"></a>06094                             <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *type_unit_die,
<a name="l06095"></a>06095                             <span class="keywordtype">int</span> has_children,
<a name="l06096"></a>06096                             <span class="keywordtype">void</span> *data)
<a name="l06097"></a>06097 {
<a name="l06098"></a>06098   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l06099"></a>06099   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l06100"></a>06100   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;
<a name="l06101"></a>06101   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type;
<a name="l06102"></a>06102   <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> *tu_group;
<a name="l06103"></a>06103   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l06104"></a>06104   <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *first_die;
<a name="l06105"></a>06105   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a>, <a class="code" href="structpartial__die__info.html#a958cea19f3de0168488931ed04efc700">highpc</a>;
<a name="l06106"></a>06106   <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst;
<a name="l06107"></a>06107 
<a name="l06108"></a>06108   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (data == NULL);
<a name="l06109"></a>06109   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l06110"></a>06110   sig_type = (<span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *) per_cu;
<a name="l06111"></a>06111 
<a name="l06112"></a>06112   <span class="keywordflow">if</span> (! has_children)
<a name="l06113"></a>06113     <span class="keywordflow">return</span>;
<a name="l06114"></a>06114 
<a name="l06115"></a>06115   attr = <a class="code" href="dwarf2read_8c.html#a50710a3c575e046cafb61f16aaca480f">dwarf2_attr_no_follow</a> (type_unit_die, DW_AT_stmt_list);
<a name="l06116"></a>06116   tu_group = <a class="code" href="dwarf2read_8c.html#a32cdecdad4aa06e351612fb574d1c638">get_type_unit_group</a> (cu, attr);
<a name="l06117"></a>06117 
<a name="l06118"></a>06118   <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (sig_type_ptr, tu_group-&gt;tus, sig_type);
<a name="l06119"></a>06119 
<a name="l06120"></a>06120   <a class="code" href="dwarf2read_8c.html#a7a6cb8459a76588ce7ef6a56b19ef5c8">prepare_one_comp_unit</a> (cu, type_unit_die, <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a389b59241274e837cb0d28b1909013ac">language_minimal</a>);
<a name="l06121"></a>06121   cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a> = &amp;<a class="code" href="buildsym_8h.html#a2d83ed7f7eeffeffeb2e00320573fd0d">file_symbols</a>;
<a name="l06122"></a>06122   pst = <a class="code" href="dwarf2read_8c.html#ab4b70e57fa288b01beeda2f9526b5fde">create_partial_symtab</a> (per_cu, <span class="stringliteral">&quot;&quot;</span>);
<a name="l06123"></a>06123   pst-&gt;<a class="code" href="structpartial__symtab.html#a72ab74ae49f0048cc7151d786e724235">anonymous</a> = 1;
<a name="l06124"></a>06124 
<a name="l06125"></a>06125   first_die = <a class="code" href="dwarf2read_8c.html#a2bf39a75877292252ae39938c7fa6885">load_partial_dies</a> (reader, info_ptr, 1);
<a name="l06126"></a>06126 
<a name="l06127"></a>06127   lowpc = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) -1;
<a name="l06128"></a>06128   highpc = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 0;
<a name="l06129"></a>06129   <a class="code" href="dwarf2read_8c.html#aeffcf90b9b19c7413fc505d0bf8e8657">scan_partial_symbols</a> (first_die, &amp;lowpc, &amp;highpc, 0, cu);
<a name="l06130"></a>06130 
<a name="l06131"></a>06131   pst-&gt;<a class="code" href="structpartial__symtab.html#ab26039959ff434afcf130049cfa8d27d">n_global_syms</a> = objfile-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#a47883420b19f6e99ee9989eb600ce6e5">next</a> -
<a name="l06132"></a>06132     (objfile-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#ac618c483c3ff07162cdfe508abd6034d">list</a> + pst-&gt;<a class="code" href="structpartial__symtab.html#ae11f1094416fd506398f4a58fe4fa405">globals_offset</a>);
<a name="l06133"></a>06133   pst-&gt;<a class="code" href="structpartial__symtab.html#a0fd67e243d440beaf6cc4757a97ff9b0">n_static_syms</a> = objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#a47883420b19f6e99ee9989eb600ce6e5">next</a> -
<a name="l06134"></a>06134     (objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#ac618c483c3ff07162cdfe508abd6034d">list</a> + pst-&gt;<a class="code" href="structpartial__symtab.html#a36b8c771ea2906e413b8f1fffe1f4d10">statics_offset</a>);
<a name="l06135"></a>06135   <a class="code" href="psympriv_8h.html#a6cea36b8ce21ebe0c95e2cab2a0fc4eb">sort_pst_symbols</a> (objfile, pst);
<a name="l06136"></a>06136 }
<a name="l06137"></a>06137 
<a name="l06138"></a>06138 <span class="comment">/* Traversal function for build_type_psymtabs.  */</span>
<a name="l06139"></a>06139 
<a name="l06140"></a>06140 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l06141"></a><a class="code" href="dwarf2read_8c.html#a744239276f5050743848260230c25327">06141</a> <a class="code" href="dwarf2read_8c.html#a744239276f5050743848260230c25327">build_type_psymtab_dependencies</a> (<span class="keywordtype">void</span> **slot, <span class="keywordtype">void</span> *info)
<a name="l06142"></a>06142 {
<a name="l06143"></a>06143   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l06144"></a>06144   <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> *tu_group = (<span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> *) *slot;
<a name="l06145"></a>06145   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = &amp;tu_group-&gt;<a class="code" href="structtype__unit__group.html#a4811e92ec66f2823829defcf2d3c9b29">per_cu</a>;
<a name="l06146"></a>06146   <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a>;
<a name="l06147"></a>06147   <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a> = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (sig_type_ptr, tu_group-&gt;tus);
<a name="l06148"></a>06148   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *iter;
<a name="l06149"></a>06149   <span class="keywordtype">int</span> i;
<a name="l06150"></a>06150 
<a name="l06151"></a>06151   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (len &gt; 0);
<a name="l06152"></a>06152   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="dwarf2read_8c.html#aa278b6364c9b859353eeea535d81221e">IS_TYPE_UNIT_GROUP</a> (per_cu));
<a name="l06153"></a>06153 
<a name="l06154"></a>06154   pst-&gt;<a class="code" href="structpartial__symtab.html#a917b503a5e1f7c2bb60feb6ff1e3b197">number_of_dependencies</a> = <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l06155"></a>06155   pst-&gt;<a class="code" href="structpartial__symtab.html#a0b7bd5bada02a362357552790b111c23">dependencies</a> = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l06156"></a>06156                                      len * sizeof (<span class="keyword">struct</span> psymtab *));
<a name="l06157"></a>06157   <span class="keywordflow">for</span> (i = 0;
<a name="l06158"></a>06158        <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (sig_type_ptr, tu_group-&gt;tus, i, iter);
<a name="l06159"></a>06159        ++i)
<a name="l06160"></a>06160     {
<a name="l06161"></a>06161       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (iter-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l06162"></a>06162       pst-&gt;<a class="code" href="structpartial__symtab.html#a0b7bd5bada02a362357552790b111c23">dependencies</a>[i] = iter-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a>;
<a name="l06163"></a>06163       iter-&gt;<a class="code" href="structsignatured__type.html#ab10f6f2df0f7691aa8ca948e28cbcf1e">type_unit_group</a> = tu_group;
<a name="l06164"></a>06164     }
<a name="l06165"></a>06165 
<a name="l06166"></a>06166   <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (sig_type_ptr, tu_group-&gt;tus);
<a name="l06167"></a>06167 
<a name="l06168"></a>06168   <span class="keywordflow">return</span> 1;
<a name="l06169"></a>06169 }
<a name="l06170"></a>06170 
<a name="l06171"></a>06171 <span class="comment">/* Subroutine of dwarf2_build_psymtabs_hard to simplify it.</span>
<a name="l06172"></a>06172 <span class="comment">   Build partial symbol tables for the .debug_types comp-units.  */</span>
<a name="l06173"></a>06173 
<a name="l06174"></a>06174 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06175"></a><a class="code" href="dwarf2read_8c.html#a1bde781e81c01be62dd3ba98bd4bf56c">06175</a> <a class="code" href="dwarf2read_8c.html#a1bde781e81c01be62dd3ba98bd4bf56c">build_type_psymtabs</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l06176"></a>06176 {
<a name="l06177"></a>06177   <span class="keywordflow">if</span> (! <a class="code" href="dwarf2read_8c.html#a74edb9fb71ae3b0318ea886c49b697ef">create_all_type_units</a> (objfile))
<a name="l06178"></a>06178     <span class="keywordflow">return</span>;
<a name="l06179"></a>06179 
<a name="l06180"></a>06180   <a class="code" href="dwarf2read_8c.html#ae4869ba53444635ffb37ac46abd1a045">build_type_unit_groups</a> (<a class="code" href="dwarf2read_8c.html#a2707fd06d6d6d2b2c386606cab2e20d8">build_type_psymtabs_reader</a>, NULL);
<a name="l06181"></a>06181 
<a name="l06182"></a>06182   <span class="comment">/* Now that all TUs have been processed we can fill in the dependencies.  */</span>
<a name="l06183"></a>06183   htab_traverse_noresize (dwarf2_per_objfile-&gt;type_unit_groups,
<a name="l06184"></a>06184                           <a class="code" href="dwarf2read_8c.html#a744239276f5050743848260230c25327">build_type_psymtab_dependencies</a>, NULL);
<a name="l06185"></a>06185 }
<a name="l06186"></a>06186 
<a name="l06187"></a>06187 <span class="comment">/* A cleanup function that clears objfile&#39;s psymtabs_addrmap field.  */</span>
<a name="l06188"></a>06188 
<a name="l06189"></a>06189 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06190"></a><a class="code" href="dwarf2read_8c.html#a9ba27702a815fc07f24908bec51b274c">06190</a> <a class="code" href="dwarf2read_8c.html#a9ba27702a815fc07f24908bec51b274c">psymtabs_addrmap_cleanup</a> (<span class="keywordtype">void</span> *o)
<a name="l06191"></a>06191 {
<a name="l06192"></a>06192   <span class="keyword">struct </span>objfile *objfile = o;
<a name="l06193"></a>06193 
<a name="l06194"></a>06194   objfile-&gt;<a class="code" href="structobjfile.html#ae7c792f2cd4efcff86d84d7bd3e15b26">psymtabs_addrmap</a> = NULL;
<a name="l06195"></a>06195 }
<a name="l06196"></a>06196 
<a name="l06197"></a>06197 <span class="comment">/* Compute the &#39;user&#39; field for each psymtab in OBJFILE.  */</span>
<a name="l06198"></a>06198 
<a name="l06199"></a>06199 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06200"></a><a class="code" href="dwarf2read_8c.html#a6ab56063c0829b5d40ca633f4015f4d9">06200</a> <a class="code" href="dwarf2read_8c.html#a6ab56063c0829b5d40ca633f4015f4d9">set_partial_user</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l06201"></a>06201 {
<a name="l06202"></a>06202   <span class="keywordtype">int</span> i;
<a name="l06203"></a>06203 
<a name="l06204"></a>06204   <span class="keywordflow">for</span> (i = 0; i &lt; dwarf2_per_objfile-&gt;n_comp_units; ++i)
<a name="l06205"></a>06205     {
<a name="l06206"></a>06206       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = <a class="code" href="dwarf2read_8c.html#a966b4a69ea94ca30717c495126d870c8">dw2_get_cu</a> (i);
<a name="l06207"></a>06207       <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a>;
<a name="l06208"></a>06208       <span class="keywordtype">int</span> j;
<a name="l06209"></a>06209 
<a name="l06210"></a>06210       <span class="keywordflow">if</span> (pst == NULL)
<a name="l06211"></a>06211         <span class="keywordflow">continue</span>;
<a name="l06212"></a>06212 
<a name="l06213"></a>06213       <span class="keywordflow">for</span> (j = 0; j &lt; pst-&gt;<a class="code" href="structpartial__symtab.html#a917b503a5e1f7c2bb60feb6ff1e3b197">number_of_dependencies</a>; ++j)
<a name="l06214"></a>06214         {
<a name="l06215"></a>06215           <span class="comment">/* Set the &#39;user&#39; field only if it is not already set.  */</span>
<a name="l06216"></a>06216           <span class="keywordflow">if</span> (pst-&gt;<a class="code" href="structpartial__symtab.html#a0b7bd5bada02a362357552790b111c23">dependencies</a>[j]-&gt;<a class="code" href="structpartial__symtab.html#a0609b1a2e29b3419dc25520e7d7293f0">user</a> == NULL)
<a name="l06217"></a>06217             pst-&gt;<a class="code" href="structpartial__symtab.html#a0b7bd5bada02a362357552790b111c23">dependencies</a>[j]-&gt;<a class="code" href="structpartial__symtab.html#a0609b1a2e29b3419dc25520e7d7293f0">user</a> = pst;
<a name="l06218"></a>06218         }
<a name="l06219"></a>06219     }
<a name="l06220"></a>06220 }
<a name="l06221"></a>06221 
<a name="l06222"></a>06222 <span class="comment">/* Build the partial symbol table by doing a quick pass through the</span>
<a name="l06223"></a>06223 <span class="comment">   .debug_info and .debug_abbrev sections.  */</span>
<a name="l06224"></a>06224 
<a name="l06225"></a>06225 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06226"></a><a class="code" href="dwarf2read_8c.html#aef51fb88d6ce2db82dbfed7ae8ac929e">06226</a> <a class="code" href="dwarf2read_8c.html#aef51fb88d6ce2db82dbfed7ae8ac929e">dwarf2_build_psymtabs_hard</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l06227"></a>06227 {
<a name="l06228"></a>06228   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to, *addrmap_cleanup;
<a name="l06229"></a>06229   <span class="keyword">struct </span>obstack temp_obstack;
<a name="l06230"></a>06230   <span class="keywordtype">int</span> i;
<a name="l06231"></a>06231 
<a name="l06232"></a>06232   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l06233"></a>06233     {
<a name="l06234"></a>06234       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Building psymtabs of objfile %s ...\n&quot;</span>,
<a name="l06235"></a>06235                           <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l06236"></a>06236     }
<a name="l06237"></a>06237 
<a name="l06238"></a>06238   dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a91e7a3d79383661130df87b91ef1e6c9">reading_partial_symbols</a> = 1;
<a name="l06239"></a>06239 
<a name="l06240"></a>06240   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ac4a5ed6e3f9908d638032ba24040a0b9">info</a>);
<a name="l06241"></a>06241 
<a name="l06242"></a>06242   <span class="comment">/* Any cached compilation units will be linked by the per-objfile</span>
<a name="l06243"></a>06243 <span class="comment">     read_in_chain.  Make sure to free them when we&#39;re done.  */</span>
<a name="l06244"></a>06244   back_to = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#a8fe96d50d88ef6a4b3ef501aada103ab">free_cached_comp_units</a>, NULL);
<a name="l06245"></a>06245 
<a name="l06246"></a>06246   <a class="code" href="dwarf2read_8c.html#a1bde781e81c01be62dd3ba98bd4bf56c">build_type_psymtabs</a> (objfile);
<a name="l06247"></a>06247 
<a name="l06248"></a>06248   <a class="code" href="dwarf2read_8c.html#a34cc869c244a5085a0bf01a01b0961db">create_all_comp_units</a> (objfile);
<a name="l06249"></a>06249 
<a name="l06250"></a>06250   <span class="comment">/* Create a temporary address map on a temporary obstack.  We later</span>
<a name="l06251"></a>06251 <span class="comment">     copy this to the final obstack.  */</span>
<a name="l06252"></a>06252   obstack_init (&amp;temp_obstack);
<a name="l06253"></a>06253   <a class="code" href="utils_8c.html#a8aa2f0be9d477ee015e9e9bac43c005d">make_cleanup_obstack_free</a> (&amp;temp_obstack);
<a name="l06254"></a>06254   objfile-&gt;<a class="code" href="structobjfile.html#ae7c792f2cd4efcff86d84d7bd3e15b26">psymtabs_addrmap</a> = <a class="code" href="addrmap_8c.html#ab00d989f53b8349b4f52a3431bdd0977">addrmap_create_mutable</a> (&amp;temp_obstack);
<a name="l06255"></a>06255   addrmap_cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#a9ba27702a815fc07f24908bec51b274c">psymtabs_addrmap_cleanup</a>, objfile);
<a name="l06256"></a>06256 
<a name="l06257"></a>06257   <span class="keywordflow">for</span> (i = 0; i &lt; dwarf2_per_objfile-&gt;n_comp_units; ++i)
<a name="l06258"></a>06258     {
<a name="l06259"></a>06259       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = <a class="code" href="dwarf2read_8c.html#a966b4a69ea94ca30717c495126d870c8">dw2_get_cu</a> (i);
<a name="l06260"></a>06260 
<a name="l06261"></a>06261       <a class="code" href="dwarf2read_8c.html#aa88ea6d1e16d075f5799dfcf104a8d00">process_psymtab_comp_unit</a> (per_cu, 0, <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a389b59241274e837cb0d28b1909013ac">language_minimal</a>);
<a name="l06262"></a>06262     }
<a name="l06263"></a>06263 
<a name="l06264"></a>06264   <a class="code" href="dwarf2read_8c.html#a6ab56063c0829b5d40ca633f4015f4d9">set_partial_user</a> (objfile);
<a name="l06265"></a>06265 
<a name="l06266"></a>06266   objfile-&gt;<a class="code" href="structobjfile.html#ae7c792f2cd4efcff86d84d7bd3e15b26">psymtabs_addrmap</a> = <a class="code" href="addrmap_8c.html#ab106965712b64408f5de3d01fb2676b5">addrmap_create_fixed</a> (objfile-&gt;<a class="code" href="structobjfile.html#ae7c792f2cd4efcff86d84d7bd3e15b26">psymtabs_addrmap</a>,
<a name="l06267"></a>06267                                                     &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>);
<a name="l06268"></a>06268   <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (addrmap_cleanup);
<a name="l06269"></a>06269 
<a name="l06270"></a>06270   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l06271"></a>06271 
<a name="l06272"></a>06272   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l06273"></a>06273     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Done building psymtabs of %s\n&quot;</span>,
<a name="l06274"></a>06274                         <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l06275"></a>06275 }
<a name="l06276"></a>06276 
<a name="l06277"></a>06277 <span class="comment">/* die_reader_func for load_partial_comp_unit.  */</span>
<a name="l06278"></a>06278 
<a name="l06279"></a>06279 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06280"></a><a class="code" href="dwarf2read_8c.html#afd219150364149d4ce63addf96e6703e">06280</a> <a class="code" href="dwarf2read_8c.html#afd219150364149d4ce63addf96e6703e">load_partial_comp_unit_reader</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l06281"></a>06281                                <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l06282"></a>06282                                <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *comp_unit_die,
<a name="l06283"></a>06283                                <span class="keywordtype">int</span> has_children,
<a name="l06284"></a>06284                                <span class="keywordtype">void</span> *data)
<a name="l06285"></a>06285 {
<a name="l06286"></a>06286   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l06287"></a>06287 
<a name="l06288"></a>06288   <a class="code" href="dwarf2read_8c.html#a7a6cb8459a76588ce7ef6a56b19ef5c8">prepare_one_comp_unit</a> (cu, comp_unit_die, <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a389b59241274e837cb0d28b1909013ac">language_minimal</a>);
<a name="l06289"></a>06289 
<a name="l06290"></a>06290   <span class="comment">/* Check if comp unit has_children.</span>
<a name="l06291"></a>06291 <span class="comment">     If so, read the rest of the partial symbols from this comp unit.</span>
<a name="l06292"></a>06292 <span class="comment">     If not, there&#39;s no more debug_info for this comp unit.  */</span>
<a name="l06293"></a>06293   <span class="keywordflow">if</span> (has_children)
<a name="l06294"></a>06294     <a class="code" href="dwarf2read_8c.html#a2bf39a75877292252ae39938c7fa6885">load_partial_dies</a> (reader, info_ptr, 0);
<a name="l06295"></a>06295 }
<a name="l06296"></a>06296 
<a name="l06297"></a>06297 <span class="comment">/* Load the partial DIEs for a secondary CU into memory.</span>
<a name="l06298"></a>06298 <span class="comment">   This is also used when rereading a primary CU with load_all_dies.  */</span>
<a name="l06299"></a>06299 
<a name="l06300"></a>06300 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06301"></a><a class="code" href="dwarf2read_8c.html#ab25ad5cc00c575be16c01ae08b71efed">06301</a> <a class="code" href="dwarf2read_8c.html#ab25ad5cc00c575be16c01ae08b71efed">load_partial_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu)
<a name="l06302"></a>06302 {
<a name="l06303"></a>06303   <a class="code" href="dwarf2read_8c.html#a2887b925bcf54483d1c0dc40faefdd08">init_cutu_and_read_dies</a> (this_cu, NULL, 1, 1,
<a name="l06304"></a>06304                            <a class="code" href="dwarf2read_8c.html#afd219150364149d4ce63addf96e6703e">load_partial_comp_unit_reader</a>, NULL);
<a name="l06305"></a>06305 }
<a name="l06306"></a>06306 
<a name="l06307"></a>06307 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06308"></a><a class="code" href="dwarf2read_8c.html#a04f7f363dda07010550d5a4f764c384c">06308</a> <a class="code" href="dwarf2read_8c.html#a04f7f363dda07010550d5a4f764c384c">read_comp_units_from_section</a> (<span class="keyword">struct</span> objfile *objfile,
<a name="l06309"></a>06309                               <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section,
<a name="l06310"></a>06310                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_dwz,
<a name="l06311"></a>06311                               <span class="keywordtype">int</span> *n_allocated,
<a name="l06312"></a>06312                               <span class="keywordtype">int</span> *n_comp_units,
<a name="l06313"></a>06313                               <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> ***all_comp_units)
<a name="l06314"></a>06314 {
<a name="l06315"></a>06315   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr;
<a name="l06316"></a>06316   bfd *abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l06317"></a>06317 
<a name="l06318"></a>06318   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l06319"></a>06319     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Reading %s for %s\n&quot;</span>,
<a name="l06320"></a>06320                         <a class="code" href="dwarf2read_8c.html#a206c558e28b7bc7fcf8bdad145cabef1">get_section_name</a> (section),
<a name="l06321"></a>06321                         <a class="code" href="dwarf2read_8c.html#a1c841524fdd0bd73272dad700a7452f6">get_section_file_name</a> (section));
<a name="l06322"></a>06322 
<a name="l06323"></a>06323   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, section);
<a name="l06324"></a>06324 
<a name="l06325"></a>06325   info_ptr = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>;
<a name="l06326"></a>06326 
<a name="l06327"></a>06327   <span class="keywordflow">while</span> (info_ptr &lt; section-&gt;<a class="code" href="structbuffer.html">buffer</a> + section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>)
<a name="l06328"></a>06328     {
<a name="l06329"></a>06329       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length, initial_length_size;
<a name="l06330"></a>06330       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu;
<a name="l06331"></a>06331       <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l06332"></a>06332 
<a name="l06333"></a>06333       offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = info_ptr - section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>;
<a name="l06334"></a>06334 
<a name="l06335"></a>06335       <span class="comment">/* Read just enough information to find out where the next</span>
<a name="l06336"></a>06336 <span class="comment">         compilation unit is.  */</span>
<a name="l06337"></a>06337       length = <a class="code" href="dwarf2read_8c.html#a40cbc7bcde605127cf1baef337c57f9e">read_initial_length</a> (abfd, info_ptr, &amp;initial_length_size);
<a name="l06338"></a>06338 
<a name="l06339"></a>06339       <span class="comment">/* Save the compilation unit for later lookup.  */</span>
<a name="l06340"></a>06340       this_cu = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l06341"></a>06341                                sizeof (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a>));
<a name="l06342"></a>06342       <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (this_cu, 0, <span class="keyword">sizeof</span> (*this_cu));
<a name="l06343"></a>06343       this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l06344"></a>06344       this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a> = length + initial_length_size;
<a name="l06345"></a>06345       this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a> = <a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a>;
<a name="l06346"></a>06346       this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a> = <a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>;
<a name="l06347"></a>06347       this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a> = <a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a>;
<a name="l06348"></a>06348 
<a name="l06349"></a>06349       <span class="keywordflow">if</span> (*n_comp_units == *n_allocated)
<a name="l06350"></a>06350         {
<a name="l06351"></a>06351           *n_allocated *= 2;
<a name="l06352"></a>06352           *all_comp_units = <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (*all_comp_units,
<a name="l06353"></a>06353                                       *n_allocated
<a name="l06354"></a>06354                                       * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *));
<a name="l06355"></a>06355         }
<a name="l06356"></a>06356       (*all_comp_units)[*n_comp_units] = this_cu;
<a name="l06357"></a>06357       ++*n_comp_units;
<a name="l06358"></a>06358 
<a name="l06359"></a>06359       info_ptr = info_ptr + this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a>;
<a name="l06360"></a>06360     }
<a name="l06361"></a>06361 }
<a name="l06362"></a>06362 
<a name="l06363"></a>06363 <span class="comment">/* Create a list of all compilation units in OBJFILE.</span>
<a name="l06364"></a>06364 <span class="comment">   This is only done for -readnow and building partial symtabs.  */</span>
<a name="l06365"></a>06365 
<a name="l06366"></a>06366 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06367"></a><a class="code" href="dwarf2read_8c.html#a34cc869c244a5085a0bf01a01b0961db">06367</a> <a class="code" href="dwarf2read_8c.html#a34cc869c244a5085a0bf01a01b0961db">create_all_comp_units</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l06368"></a>06368 {
<a name="l06369"></a>06369   <span class="keywordtype">int</span> n_allocated;
<a name="l06370"></a>06370   <span class="keywordtype">int</span> n_comp_units;
<a name="l06371"></a>06371   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> **all_comp_units;
<a name="l06372"></a>06372   <span class="keyword">struct </span><a class="code" href="structdwz__file.html">dwz_file</a> *dwz;
<a name="l06373"></a>06373 
<a name="l06374"></a>06374   n_comp_units = 0;
<a name="l06375"></a>06375   n_allocated = 10;
<a name="l06376"></a>06376   all_comp_units = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (n_allocated
<a name="l06377"></a>06377                             * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *));
<a name="l06378"></a>06378 
<a name="l06379"></a>06379   <a class="code" href="dwarf2read_8c.html#a04f7f363dda07010550d5a4f764c384c">read_comp_units_from_section</a> (objfile, &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ac4a5ed6e3f9908d638032ba24040a0b9">info</a>, 0,
<a name="l06380"></a>06380                                 &amp;n_allocated, &amp;n_comp_units, &amp;all_comp_units);
<a name="l06381"></a>06381 
<a name="l06382"></a>06382   dwz = <a class="code" href="dwarf2read_8c.html#a926306809098933a820cfda81b19864c">dwarf2_get_dwz_file</a> ();
<a name="l06383"></a>06383   <span class="keywordflow">if</span> (dwz != NULL)
<a name="l06384"></a>06384     <a class="code" href="dwarf2read_8c.html#a04f7f363dda07010550d5a4f764c384c">read_comp_units_from_section</a> (objfile, &amp;dwz-&gt;<a class="code" href="structdwz__file.html#a2c4f25245be0e458f196af80a990969c">info</a>, 1,
<a name="l06385"></a>06385                                   &amp;n_allocated, &amp;n_comp_units,
<a name="l06386"></a>06386                                   &amp;all_comp_units);
<a name="l06387"></a>06387 
<a name="l06388"></a>06388   dwarf2_per_objfile-&gt;all_comp_units
<a name="l06389"></a>06389     = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l06390"></a>06390                      n_comp_units * sizeof (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *));
<a name="l06391"></a>06391   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (dwarf2_per_objfile-&gt;all_comp_units, all_comp_units,
<a name="l06392"></a>06392           n_comp_units * sizeof (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *));
<a name="l06393"></a>06393   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (all_comp_units);
<a name="l06394"></a>06394   dwarf2_per_objfile-&gt;n_comp_units = n_comp_units;
<a name="l06395"></a>06395 }
<a name="l06396"></a>06396 
<a name="l06397"></a>06397 <span class="comment">/* Process all loaded DIEs for compilation unit CU, starting at</span>
<a name="l06398"></a>06398 <span class="comment">   FIRST_DIE.  The caller should pass NEED_PC == 1 if the compilation</span>
<a name="l06399"></a>06399 <span class="comment">   unit DIE did not have PC info (DW_AT_low_pc and DW_AT_high_pc, or</span>
<a name="l06400"></a>06400 <span class="comment">   DW_AT_ranges).  If NEED_PC is set, then this function will set</span>
<a name="l06401"></a>06401 <span class="comment">   *LOWPC and *HIGHPC to the lowest and highest PC values found in CU</span>
<a name="l06402"></a>06402 <span class="comment">   and record the covered ranges in the addrmap.  */</span>
<a name="l06403"></a>06403 
<a name="l06404"></a>06404 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06405"></a><a class="code" href="dwarf2read_8c.html#aeffcf90b9b19c7413fc505d0bf8e8657">06405</a> <a class="code" href="dwarf2read_8c.html#aeffcf90b9b19c7413fc505d0bf8e8657">scan_partial_symbols</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *first_die, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *lowpc,
<a name="l06406"></a>06406                       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *highpc, <span class="keywordtype">int</span> need_pc, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l06407"></a>06407 {
<a name="l06408"></a>06408   <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *pdi;
<a name="l06409"></a>06409 
<a name="l06410"></a>06410   <span class="comment">/* Now, march along the PDI&#39;s, descending into ones which have</span>
<a name="l06411"></a>06411 <span class="comment">     interesting children but skipping the children of the other ones,</span>
<a name="l06412"></a>06412 <span class="comment">     until we reach the end of the compilation unit.  */</span>
<a name="l06413"></a>06413 
<a name="l06414"></a>06414   pdi = first_die;
<a name="l06415"></a>06415 
<a name="l06416"></a>06416   <span class="keywordflow">while</span> (pdi != NULL)
<a name="l06417"></a>06417     {
<a name="l06418"></a>06418       <a class="code" href="dwarf2read_8c.html#a271dd2144532648290913da6252d331b">fixup_partial_die</a> (pdi, cu);
<a name="l06419"></a>06419 
<a name="l06420"></a>06420       <span class="comment">/* Anonymous namespaces or modules have no name but have interesting</span>
<a name="l06421"></a>06421 <span class="comment">         children, so we need to look at them.  Ditto for anonymous</span>
<a name="l06422"></a>06422 <span class="comment">         enums.  */</span>
<a name="l06423"></a>06423 
<a name="l06424"></a>06424       <span class="keywordflow">if</span> (pdi-&gt;name != NULL || pdi-&gt;tag == DW_TAG_namespace
<a name="l06425"></a>06425           || pdi-&gt;tag == DW_TAG_module || pdi-&gt;tag == DW_TAG_enumeration_type
<a name="l06426"></a>06426           || pdi-&gt;tag == DW_TAG_imported_unit)
<a name="l06427"></a>06427         {
<a name="l06428"></a>06428           <span class="keywordflow">switch</span> (pdi-&gt;tag)
<a name="l06429"></a>06429             {
<a name="l06430"></a>06430             <span class="keywordflow">case</span> DW_TAG_subprogram:
<a name="l06431"></a>06431               <a class="code" href="dwarf2read_8c.html#a35c693a59ce32f823e31c31ab56b1d78">add_partial_subprogram</a> (pdi, lowpc, highpc, need_pc, cu);
<a name="l06432"></a>06432               <span class="keywordflow">break</span>;
<a name="l06433"></a>06433             <span class="keywordflow">case</span> DW_TAG_constant:
<a name="l06434"></a>06434             <span class="keywordflow">case</span> DW_TAG_variable:
<a name="l06435"></a>06435             <span class="keywordflow">case</span> DW_TAG_typedef:
<a name="l06436"></a>06436             <span class="keywordflow">case</span> DW_TAG_union_type:
<a name="l06437"></a>06437               <span class="keywordflow">if</span> (!pdi-&gt;is_declaration)
<a name="l06438"></a>06438                 {
<a name="l06439"></a>06439                   <a class="code" href="dwarf2read_8c.html#a46d3f288e2cd7c77113df32913e69f56">add_partial_symbol</a> (pdi, cu);
<a name="l06440"></a>06440                 }
<a name="l06441"></a>06441               <span class="keywordflow">break</span>;
<a name="l06442"></a>06442             <span class="keywordflow">case</span> DW_TAG_class_type:
<a name="l06443"></a>06443             <span class="keywordflow">case</span> DW_TAG_interface_type:
<a name="l06444"></a>06444             <span class="keywordflow">case</span> DW_TAG_structure_type:
<a name="l06445"></a>06445               <span class="keywordflow">if</span> (!pdi-&gt;is_declaration)
<a name="l06446"></a>06446                 {
<a name="l06447"></a>06447                   <a class="code" href="dwarf2read_8c.html#a46d3f288e2cd7c77113df32913e69f56">add_partial_symbol</a> (pdi, cu);
<a name="l06448"></a>06448                 }
<a name="l06449"></a>06449               <span class="keywordflow">break</span>;
<a name="l06450"></a>06450             <span class="keywordflow">case</span> DW_TAG_enumeration_type:
<a name="l06451"></a>06451               <span class="keywordflow">if</span> (!pdi-&gt;is_declaration)
<a name="l06452"></a>06452                 <a class="code" href="dwarf2read_8c.html#abf32e648b8d904a35eb48ac91073708a">add_partial_enumeration</a> (pdi, cu);
<a name="l06453"></a>06453               <span class="keywordflow">break</span>;
<a name="l06454"></a>06454             <span class="keywordflow">case</span> DW_TAG_base_type:
<a name="l06455"></a>06455             <span class="keywordflow">case</span> DW_TAG_subrange_type:
<a name="l06456"></a>06456               <span class="comment">/* File scope base type definitions are added to the partial</span>
<a name="l06457"></a>06457 <span class="comment">                 symbol table.  */</span>
<a name="l06458"></a>06458               <a class="code" href="dwarf2read_8c.html#a46d3f288e2cd7c77113df32913e69f56">add_partial_symbol</a> (pdi, cu);
<a name="l06459"></a>06459               <span class="keywordflow">break</span>;
<a name="l06460"></a>06460             <span class="keywordflow">case</span> DW_TAG_namespace:
<a name="l06461"></a>06461               <a class="code" href="dwarf2read_8c.html#abf35f752bbaa1439406817912d068c66">add_partial_namespace</a> (pdi, lowpc, highpc, need_pc, cu);
<a name="l06462"></a>06462               <span class="keywordflow">break</span>;
<a name="l06463"></a>06463             <span class="keywordflow">case</span> DW_TAG_module:
<a name="l06464"></a>06464               <a class="code" href="dwarf2read_8c.html#a9ec445afdbd9cf0243499e47665d0d83">add_partial_module</a> (pdi, lowpc, highpc, need_pc, cu);
<a name="l06465"></a>06465               <span class="keywordflow">break</span>;
<a name="l06466"></a>06466             <span class="keywordflow">case</span> DW_TAG_imported_unit:
<a name="l06467"></a>06467               {
<a name="l06468"></a>06468                 <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu;
<a name="l06469"></a>06469 
<a name="l06470"></a>06470                 <span class="comment">/* For now we don&#39;t handle imported units in type units.  */</span>
<a name="l06471"></a>06471                 <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l06472"></a>06472                   {
<a name="l06473"></a>06473                     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: DW_TAG_imported_unit is not&quot;</span>
<a name="l06474"></a>06474                              <span class="stringliteral">&quot; supported in type units [in module %s]&quot;</span>),
<a name="l06475"></a>06475                            <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>));
<a name="l06476"></a>06476                   }
<a name="l06477"></a>06477 
<a name="l06478"></a>06478                 per_cu = <a class="code" href="dwarf2read_8c.html#af3b37bdf179696b92b068cd2894de56d">dwarf2_find_containing_comp_unit</a> (pdi-&gt;<a class="code" href="structpartial__die__info.html#ab829867c034259d5dda8a61679232609">d</a>.offset,
<a name="l06479"></a>06479                                                            pdi-&gt;is_dwz,
<a name="l06480"></a>06480                                                            cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>);
<a name="l06481"></a>06481 
<a name="l06482"></a>06482                 <span class="comment">/* Go read the partial unit, if needed.  */</span>
<a name="l06483"></a>06483                 <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a> == NULL)
<a name="l06484"></a>06484                   <a class="code" href="dwarf2read_8c.html#aa88ea6d1e16d075f5799dfcf104a8d00">process_psymtab_comp_unit</a> (per_cu, 1, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>);
<a name="l06485"></a>06485 
<a name="l06486"></a>06486                 <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (dwarf2_per_cu_ptr,
<a name="l06487"></a>06487                                cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;imported_symtabs, per_cu);
<a name="l06488"></a>06488               }
<a name="l06489"></a>06489               <span class="keywordflow">break</span>;
<a name="l06490"></a>06490             <span class="keywordflow">default</span>:
<a name="l06491"></a>06491               <span class="keywordflow">break</span>;
<a name="l06492"></a>06492             }
<a name="l06493"></a>06493         }
<a name="l06494"></a>06494 
<a name="l06495"></a>06495       <span class="comment">/* If the die has a sibling, skip to the sibling.  */</span>
<a name="l06496"></a>06496 
<a name="l06497"></a>06497       pdi = pdi-&gt;<a class="code" href="structpartial__die__info.html#ad62d4a24f9c19d6835843c6a066fea36">die_sibling</a>;
<a name="l06498"></a>06498     }
<a name="l06499"></a>06499 }
<a name="l06500"></a>06500 
<a name="l06501"></a>06501 <span class="comment">/* Functions used to compute the fully scoped name of a partial DIE.</span>
<a name="l06502"></a>06502 <span class="comment"></span>
<a name="l06503"></a>06503 <span class="comment">   Normally, this is simple.  For C++, the parent DIE&#39;s fully scoped</span>
<a name="l06504"></a>06504 <span class="comment">   name is concatenated with &quot;::&quot; and the partial DIE&#39;s name.  For</span>
<a name="l06505"></a>06505 <span class="comment">   Java, the same thing occurs except that &quot;.&quot; is used instead of &quot;::&quot;.</span>
<a name="l06506"></a>06506 <span class="comment">   Enumerators are an exception; they use the scope of their parent</span>
<a name="l06507"></a>06507 <span class="comment">   enumeration type, i.e. the name of the enumeration type is not</span>
<a name="l06508"></a>06508 <span class="comment">   prepended to the enumerator.</span>
<a name="l06509"></a>06509 <span class="comment"></span>
<a name="l06510"></a>06510 <span class="comment">   There are two complexities.  One is DW_AT_specification; in this</span>
<a name="l06511"></a>06511 <span class="comment">   case &quot;parent&quot; means the parent of the target of the specification,</span>
<a name="l06512"></a>06512 <span class="comment">   instead of the direct parent of the DIE.  The other is compilers</span>
<a name="l06513"></a>06513 <span class="comment">   which do not emit DW_TAG_namespace; in this case we try to guess</span>
<a name="l06514"></a>06514 <span class="comment">   the fully qualified name of structure types from their members&#39;</span>
<a name="l06515"></a>06515 <span class="comment">   linkage names.  This must be done using the DIE&#39;s children rather</span>
<a name="l06516"></a>06516 <span class="comment">   than the children of any DW_AT_specification target.  We only need</span>
<a name="l06517"></a>06517 <span class="comment">   to do this for structures at the top level, i.e. if the target of</span>
<a name="l06518"></a>06518 <span class="comment">   any DW_AT_specification (if any; otherwise the DIE itself) does not</span>
<a name="l06519"></a>06519 <span class="comment">   have a parent.  */</span>
<a name="l06520"></a>06520 
<a name="l06521"></a>06521 <span class="comment">/* Compute the scope prefix associated with PDI&#39;s parent, in</span>
<a name="l06522"></a>06522 <span class="comment">   compilation unit CU.  The result will be allocated on CU&#39;s</span>
<a name="l06523"></a>06523 <span class="comment">   comp_unit_obstack, or a copy of the already allocated PDI-&gt;NAME</span>
<a name="l06524"></a>06524 <span class="comment">   field.  NULL is returned if no prefix is necessary.  */</span>
<a name="l06525"></a>06525 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l06526"></a><a class="code" href="dwarf2read_8c.html#a582e8c0ec8954e93f1085a7ee296a165">06526</a> <a class="code" href="dwarf2read_8c.html#a582e8c0ec8954e93f1085a7ee296a165">partial_die_parent_scope</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *pdi,
<a name="l06527"></a>06527                           <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>)
<a name="l06528"></a>06528 {
<a name="l06529"></a>06529   <span class="keyword">const</span> <span class="keywordtype">char</span> *grandparent_scope;
<a name="l06530"></a>06530   <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *parent, *real_pdi;
<a name="l06531"></a>06531 
<a name="l06532"></a>06532   <span class="comment">/* We need to look at our parent DIE; if we have a DW_AT_specification,</span>
<a name="l06533"></a>06533 <span class="comment">     then this means the parent of the specification DIE.  */</span>
<a name="l06534"></a>06534 
<a name="l06535"></a>06535   real_pdi = pdi;
<a name="l06536"></a>06536   <span class="keywordflow">while</span> (real_pdi-&gt;has_specification)
<a name="l06537"></a>06537     real_pdi = <a class="code" href="dwarf2read_8c.html#a58e31b8772918ff152fc61303028195a">find_partial_die</a> (real_pdi-&gt;<a class="code" href="structpartial__die__info.html#ac9faa23b0720fe4585288e1286917877">spec_offset</a>,
<a name="l06538"></a>06538                                  real_pdi-&gt;spec_is_dwz, cu);
<a name="l06539"></a>06539 
<a name="l06540"></a>06540   parent = real_pdi-&gt;<a class="code" href="structpartial__die__info.html#add5cb3fe3a136089a2cafa7027e59687">die_parent</a>;
<a name="l06541"></a>06541   <span class="keywordflow">if</span> (parent == NULL)
<a name="l06542"></a>06542     <span class="keywordflow">return</span> NULL;
<a name="l06543"></a>06543 
<a name="l06544"></a>06544   <span class="keywordflow">if</span> (parent-&gt;scope_set)
<a name="l06545"></a>06545     <span class="keywordflow">return</span> parent-&gt;scope;
<a name="l06546"></a>06546 
<a name="l06547"></a>06547   <a class="code" href="dwarf2read_8c.html#a271dd2144532648290913da6252d331b">fixup_partial_die</a> (parent, cu);
<a name="l06548"></a>06548 
<a name="l06549"></a>06549   grandparent_scope = <a class="code" href="dwarf2read_8c.html#a582e8c0ec8954e93f1085a7ee296a165">partial_die_parent_scope</a> (parent, cu);
<a name="l06550"></a>06550 
<a name="l06551"></a>06551   <span class="comment">/* GCC 4.0 and 4.1 had a bug (PR c++/28460) where they generated bogus</span>
<a name="l06552"></a>06552 <span class="comment">     DW_TAG_namespace DIEs with a name of &quot;::&quot; for the global namespace.</span>
<a name="l06553"></a>06553 <span class="comment">     Work around this problem here.  */</span>
<a name="l06554"></a>06554   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l06555"></a>06555       &amp;&amp; parent-&gt;tag == DW_TAG_namespace
<a name="l06556"></a>06556       &amp;&amp; strcmp (parent-&gt;name, <span class="stringliteral">&quot;::&quot;</span>) == 0
<a name="l06557"></a>06557       &amp;&amp; grandparent_scope == NULL)
<a name="l06558"></a>06558     {
<a name="l06559"></a>06559       parent-&gt;scope = NULL;
<a name="l06560"></a>06560       parent-&gt;scope_set = 1;
<a name="l06561"></a>06561       <span class="keywordflow">return</span> NULL;
<a name="l06562"></a>06562     }
<a name="l06563"></a>06563 
<a name="l06564"></a>06564   <span class="keywordflow">if</span> (pdi-&gt;tag == DW_TAG_enumerator)
<a name="l06565"></a>06565     <span class="comment">/* Enumerators should not get the name of the enumeration as a prefix.  */</span>
<a name="l06566"></a>06566     parent-&gt;scope = grandparent_scope;
<a name="l06567"></a>06567   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parent-&gt;tag == DW_TAG_namespace
<a name="l06568"></a>06568       || parent-&gt;tag == DW_TAG_module
<a name="l06569"></a>06569       || parent-&gt;tag == DW_TAG_structure_type
<a name="l06570"></a>06570       || parent-&gt;tag == DW_TAG_class_type
<a name="l06571"></a>06571       || parent-&gt;tag == DW_TAG_interface_type
<a name="l06572"></a>06572       || parent-&gt;tag == DW_TAG_union_type
<a name="l06573"></a>06573       || parent-&gt;tag == DW_TAG_enumeration_type)
<a name="l06574"></a>06574     {
<a name="l06575"></a>06575       <span class="keywordflow">if</span> (grandparent_scope == NULL)
<a name="l06576"></a>06576         parent-&gt;scope = parent-&gt;name;
<a name="l06577"></a>06577       <span class="keywordflow">else</span>
<a name="l06578"></a>06578         parent-&gt;scope = <a class="code" href="dwarf2read_8c.html#a6abe45afe642868fb22402ce7349ad7f">typename_concat</a> (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>,
<a name="l06579"></a>06579                                          grandparent_scope,
<a name="l06580"></a>06580                                          parent-&gt;name, 0, cu);
<a name="l06581"></a>06581     }
<a name="l06582"></a>06582   <span class="keywordflow">else</span>
<a name="l06583"></a>06583     {
<a name="l06584"></a>06584       <span class="comment">/* FIXME drow/2004-04-01: What should we be doing with</span>
<a name="l06585"></a>06585 <span class="comment">         function-local names?  For partial symbols, we should probably be</span>
<a name="l06586"></a>06586 <span class="comment">         ignoring them.  */</span>
<a name="l06587"></a>06587       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l06588"></a>06588                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unhandled containing DIE tag %d for DIE at %d&quot;</span>),
<a name="l06589"></a>06589                  parent-&gt;tag, pdi-&gt;<a class="code" href="structpartial__die__info.html#a5db48cad0baeb15b63822fdaa0136c04">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l06590"></a>06590       parent-&gt;scope = grandparent_scope;
<a name="l06591"></a>06591     }
<a name="l06592"></a>06592 
<a name="l06593"></a>06593   parent-&gt;scope_set = 1;
<a name="l06594"></a>06594   <span class="keywordflow">return</span> parent-&gt;scope;
<a name="l06595"></a>06595 }
<a name="l06596"></a>06596 
<a name="l06597"></a>06597 <span class="comment">/* Return the fully scoped name associated with PDI, from compilation unit</span>
<a name="l06598"></a>06598 <span class="comment">   CU.  The result will be allocated with malloc.  */</span>
<a name="l06599"></a>06599 
<a name="l06600"></a>06600 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l06601"></a><a class="code" href="dwarf2read_8c.html#aad56a06e4f64b510197b01238cf9a9ee">06601</a> <a class="code" href="dwarf2read_8c.html#aad56a06e4f64b510197b01238cf9a9ee">partial_die_full_name</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *pdi,
<a name="l06602"></a>06602                        <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l06603"></a>06603 {
<a name="l06604"></a>06604   <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_scope;
<a name="l06605"></a>06605 
<a name="l06606"></a>06606   <span class="comment">/* If this is a template instantiation, we can not work out the</span>
<a name="l06607"></a>06607 <span class="comment">     template arguments from partial DIEs.  So, unfortunately, we have</span>
<a name="l06608"></a>06608 <span class="comment">     to go through the full DIEs.  At least any work we do building</span>
<a name="l06609"></a>06609 <span class="comment">     types here will be reused if full symbols are loaded later.  */</span>
<a name="l06610"></a>06610   <span class="keywordflow">if</span> (pdi-&gt;has_template_arguments)
<a name="l06611"></a>06611     {
<a name="l06612"></a>06612       <a class="code" href="dwarf2read_8c.html#a271dd2144532648290913da6252d331b">fixup_partial_die</a> (pdi, cu);
<a name="l06613"></a>06613 
<a name="l06614"></a>06614       <span class="keywordflow">if</span> (pdi-&gt;name != NULL &amp;&amp; <a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (pdi-&gt;name, <span class="charliteral">&#39;&lt;&#39;</span>) == NULL)
<a name="l06615"></a>06615         {
<a name="l06616"></a>06616           <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die;
<a name="l06617"></a>06617           <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> attr;
<a name="l06618"></a>06618           <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *ref_cu = cu;
<a name="l06619"></a>06619 
<a name="l06620"></a>06620           <span class="comment">/* DW_FORM_ref_addr is using section offset.  */</span>
<a name="l06621"></a>06621           attr.name = 0;
<a name="l06622"></a>06622           attr.form = DW_FORM_ref_addr;
<a name="l06623"></a>06623           attr.<a class="code" href="structattribute.html#a615a09e185bf5cd35bc546cfd6833e5b">u</a>.unsnd = pdi-&gt;<a class="code" href="structpartial__die__info.html#a5db48cad0baeb15b63822fdaa0136c04">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l06624"></a>06624           die = <a class="code" href="dwarf2read_8c.html#a079b531fef51cfc34f92ff6fde2ef8a4">follow_die_ref</a> (NULL, &amp;attr, &amp;ref_cu);
<a name="l06625"></a>06625 
<a name="l06626"></a>06626           <span class="keywordflow">return</span> xstrdup (<a class="code" href="dwarf2read_8c.html#a01de8f373799ebb39da7b5758619ec4c">dwarf2_full_name</a> (NULL, die, ref_cu));
<a name="l06627"></a>06627         }
<a name="l06628"></a>06628     }
<a name="l06629"></a>06629 
<a name="l06630"></a>06630   parent_scope = <a class="code" href="dwarf2read_8c.html#a582e8c0ec8954e93f1085a7ee296a165">partial_die_parent_scope</a> (pdi, cu);
<a name="l06631"></a>06631   <span class="keywordflow">if</span> (parent_scope == NULL)
<a name="l06632"></a>06632     <span class="keywordflow">return</span> NULL;
<a name="l06633"></a>06633   <span class="keywordflow">else</span>
<a name="l06634"></a>06634     <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a6abe45afe642868fb22402ce7349ad7f">typename_concat</a> (NULL, parent_scope, pdi-&gt;name, 0, cu);
<a name="l06635"></a>06635 }
<a name="l06636"></a>06636 
<a name="l06637"></a>06637 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06638"></a><a class="code" href="dwarf2read_8c.html#a46d3f288e2cd7c77113df32913e69f56">06638</a> <a class="code" href="dwarf2read_8c.html#a46d3f288e2cd7c77113df32913e69f56">add_partial_symbol</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *pdi, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l06639"></a>06639 {
<a name="l06640"></a>06640   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l06641"></a>06641   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr = 0;
<a name="l06642"></a>06642   <span class="keyword">const</span> <span class="keywordtype">char</span> *actual_name = NULL;
<a name="l06643"></a>06643   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> baseaddr;
<a name="l06644"></a>06644   <span class="keywordtype">char</span> *built_actual_name;
<a name="l06645"></a>06645 
<a name="l06646"></a>06646   baseaddr = <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>, <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l06647"></a>06647 
<a name="l06648"></a>06648   built_actual_name = <a class="code" href="dwarf2read_8c.html#aad56a06e4f64b510197b01238cf9a9ee">partial_die_full_name</a> (pdi, cu);
<a name="l06649"></a>06649   <span class="keywordflow">if</span> (built_actual_name != NULL)
<a name="l06650"></a>06650     actual_name = built_actual_name;
<a name="l06651"></a>06651 
<a name="l06652"></a>06652   <span class="keywordflow">if</span> (actual_name == NULL)
<a name="l06653"></a>06653     actual_name = pdi-&gt;name;
<a name="l06654"></a>06654 
<a name="l06655"></a>06655   <span class="keywordflow">switch</span> (pdi-&gt;tag)
<a name="l06656"></a>06656     {
<a name="l06657"></a>06657     <span class="keywordflow">case</span> DW_TAG_subprogram:
<a name="l06658"></a>06658       <span class="keywordflow">if</span> (pdi-&gt;is_external || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l06659"></a>06659         {
<a name="l06660"></a>06660           <span class="comment">/* brobecker/2007-12-26: Normally, only &quot;external&quot; DIEs are part</span>
<a name="l06661"></a>06661 <span class="comment">             of the global scope.  But in Ada, we want to be able to access</span>
<a name="l06662"></a>06662 <span class="comment">             nested procedures globally.  So all Ada subprograms are stored</span>
<a name="l06663"></a>06663 <span class="comment">             in the global scope.  */</span>
<a name="l06664"></a>06664           <span class="comment">/* prim_record_minimal_symbol (actual_name, pdi-&gt;lowpc + baseaddr,</span>
<a name="l06665"></a>06665 <span class="comment">             mst_text, objfile); */</span>
<a name="l06666"></a>06666           <a class="code" href="psympriv_8h.html#a62f8da83aee3f33ec2da32c0e583260a">add_psymbol_to_list</a> (actual_name, strlen (actual_name),
<a name="l06667"></a>06667                                built_actual_name != NULL,
<a name="l06668"></a>06668                                <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>,
<a name="l06669"></a>06669                                &amp;objfile-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>,
<a name="l06670"></a>06670                                0, pdi-&gt;<a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a> + baseaddr,
<a name="l06671"></a>06671                                cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>, objfile);
<a name="l06672"></a>06672         }
<a name="l06673"></a>06673       <span class="keywordflow">else</span>
<a name="l06674"></a>06674         {
<a name="l06675"></a>06675           <span class="comment">/* prim_record_minimal_symbol (actual_name, pdi-&gt;lowpc + baseaddr,</span>
<a name="l06676"></a>06676 <span class="comment">             mst_file_text, objfile); */</span>
<a name="l06677"></a>06677           <a class="code" href="psympriv_8h.html#a62f8da83aee3f33ec2da32c0e583260a">add_psymbol_to_list</a> (actual_name, strlen (actual_name),
<a name="l06678"></a>06678                                built_actual_name != NULL,
<a name="l06679"></a>06679                                <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>,
<a name="l06680"></a>06680                                &amp;objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>,
<a name="l06681"></a>06681                                0, pdi-&gt;<a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a> + baseaddr,
<a name="l06682"></a>06682                                cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>, objfile);
<a name="l06683"></a>06683         }
<a name="l06684"></a>06684       <span class="keywordflow">break</span>;
<a name="l06685"></a>06685     <span class="keywordflow">case</span> DW_TAG_constant:
<a name="l06686"></a>06686       {
<a name="l06687"></a>06687         <span class="keyword">struct </span><a class="code" href="structpsymbol__allocation__list.html">psymbol_allocation_list</a> *<a class="code" href="structpsymbol__allocation__list.html#ac618c483c3ff07162cdfe508abd6034d">list</a>;
<a name="l06688"></a>06688 
<a name="l06689"></a>06689         <span class="keywordflow">if</span> (pdi-&gt;is_external)
<a name="l06690"></a>06690           list = &amp;objfile-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>;
<a name="l06691"></a>06691         <span class="keywordflow">else</span>
<a name="l06692"></a>06692           list = &amp;objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>;
<a name="l06693"></a>06693         <a class="code" href="psympriv_8h.html#a62f8da83aee3f33ec2da32c0e583260a">add_psymbol_to_list</a> (actual_name, strlen (actual_name),
<a name="l06694"></a>06694                              built_actual_name != NULL, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a154b256439f7acd7ec7f6257d5881a0f">LOC_STATIC</a>,
<a name="l06695"></a>06695                              list, 0, 0, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>, objfile);
<a name="l06696"></a>06696       }
<a name="l06697"></a>06697       <span class="keywordflow">break</span>;
<a name="l06698"></a>06698     <span class="keywordflow">case</span> DW_TAG_variable:
<a name="l06699"></a>06699       <span class="keywordflow">if</span> (pdi-&gt;<a class="code" href="structpartial__die__info.html#ab829867c034259d5dda8a61679232609">d</a>.locdesc)
<a name="l06700"></a>06700         addr = <a class="code" href="dwarf2read_8c.html#ab042fa76d14a2a97bb1b0d6f75e60d79">decode_locdesc</a> (pdi-&gt;<a class="code" href="structpartial__die__info.html#ab829867c034259d5dda8a61679232609">d</a>.locdesc, cu);
<a name="l06701"></a>06701 
<a name="l06702"></a>06702       <span class="keywordflow">if</span> (pdi-&gt;<a class="code" href="structpartial__die__info.html#ab829867c034259d5dda8a61679232609">d</a>.locdesc
<a name="l06703"></a>06703           &amp;&amp; addr == 0
<a name="l06704"></a>06704           &amp;&amp; !dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ab6b03c3a65fa04f04741158e8aebc895">has_section_at_zero</a>)
<a name="l06705"></a>06705         {
<a name="l06706"></a>06706           <span class="comment">/* A global or static variable may also have been stripped</span>
<a name="l06707"></a>06707 <span class="comment">             out by the linker if unused, in which case its address</span>
<a name="l06708"></a>06708 <span class="comment">             will be nullified; do not add such variables into partial</span>
<a name="l06709"></a>06709 <span class="comment">             symbol table then.  */</span>
<a name="l06710"></a>06710         }
<a name="l06711"></a>06711       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pdi-&gt;is_external)
<a name="l06712"></a>06712         {
<a name="l06713"></a>06713           <span class="comment">/* Global Variable.</span>
<a name="l06714"></a>06714 <span class="comment">             Don&#39;t enter into the minimal symbol tables as there is</span>
<a name="l06715"></a>06715 <span class="comment">             a minimal symbol table entry from the ELF symbols already.</span>
<a name="l06716"></a>06716 <span class="comment">             Enter into partial symbol table if it has a location</span>
<a name="l06717"></a>06717 <span class="comment">             descriptor or a type.</span>
<a name="l06718"></a>06718 <span class="comment">             If the location descriptor is missing, new_symbol will create</span>
<a name="l06719"></a>06719 <span class="comment">             a LOC_UNRESOLVED symbol, the address of the variable will then</span>
<a name="l06720"></a>06720 <span class="comment">             be determined from the minimal symbol table whenever the variable</span>
<a name="l06721"></a>06721 <span class="comment">             is referenced.</span>
<a name="l06722"></a>06722 <span class="comment">             The address for the partial symbol table entry is not</span>
<a name="l06723"></a>06723 <span class="comment">             used by GDB, but it comes in handy for debugging partial symbol</span>
<a name="l06724"></a>06724 <span class="comment">             table building.  */</span>
<a name="l06725"></a>06725 
<a name="l06726"></a>06726           <span class="keywordflow">if</span> (pdi-&gt;<a class="code" href="structpartial__die__info.html#ab829867c034259d5dda8a61679232609">d</a>.locdesc || pdi-&gt;has_type)
<a name="l06727"></a>06727             <a class="code" href="psympriv_8h.html#a62f8da83aee3f33ec2da32c0e583260a">add_psymbol_to_list</a> (actual_name, strlen (actual_name),
<a name="l06728"></a>06728                                  built_actual_name != NULL,
<a name="l06729"></a>06729                                  <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a154b256439f7acd7ec7f6257d5881a0f">LOC_STATIC</a>,
<a name="l06730"></a>06730                                  &amp;objfile-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>,
<a name="l06731"></a>06731                                  0, addr + baseaddr,
<a name="l06732"></a>06732                                  cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>, objfile);
<a name="l06733"></a>06733         }
<a name="l06734"></a>06734       <span class="keywordflow">else</span>
<a name="l06735"></a>06735         {
<a name="l06736"></a>06736           <span class="comment">/* Static Variable.  Skip symbols without location descriptors.  */</span>
<a name="l06737"></a>06737           <span class="keywordflow">if</span> (pdi-&gt;<a class="code" href="structpartial__die__info.html#ab829867c034259d5dda8a61679232609">d</a>.locdesc == NULL)
<a name="l06738"></a>06738             {
<a name="l06739"></a>06739               <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (built_actual_name);
<a name="l06740"></a>06740               <span class="keywordflow">return</span>;
<a name="l06741"></a>06741             }
<a name="l06742"></a>06742           <span class="comment">/* prim_record_minimal_symbol (actual_name, addr + baseaddr,</span>
<a name="l06743"></a>06743 <span class="comment">             mst_file_data, objfile); */</span>
<a name="l06744"></a>06744           <a class="code" href="psympriv_8h.html#a62f8da83aee3f33ec2da32c0e583260a">add_psymbol_to_list</a> (actual_name, strlen (actual_name),
<a name="l06745"></a>06745                                built_actual_name != NULL,
<a name="l06746"></a>06746                                <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a154b256439f7acd7ec7f6257d5881a0f">LOC_STATIC</a>,
<a name="l06747"></a>06747                                &amp;objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>,
<a name="l06748"></a>06748                                0, addr + baseaddr,
<a name="l06749"></a>06749                                cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>, objfile);
<a name="l06750"></a>06750         }
<a name="l06751"></a>06751       <span class="keywordflow">break</span>;
<a name="l06752"></a>06752     <span class="keywordflow">case</span> DW_TAG_typedef:
<a name="l06753"></a>06753     <span class="keywordflow">case</span> DW_TAG_base_type:
<a name="l06754"></a>06754     <span class="keywordflow">case</span> DW_TAG_subrange_type:
<a name="l06755"></a>06755       <a class="code" href="psympriv_8h.html#a62f8da83aee3f33ec2da32c0e583260a">add_psymbol_to_list</a> (actual_name, strlen (actual_name),
<a name="l06756"></a>06756                            built_actual_name != NULL,
<a name="l06757"></a>06757                            <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>,
<a name="l06758"></a>06758                            &amp;objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>,
<a name="l06759"></a>06759                            0, (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 0, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>, objfile);
<a name="l06760"></a>06760       <span class="keywordflow">break</span>;
<a name="l06761"></a>06761     <span class="keywordflow">case</span> DW_TAG_namespace:
<a name="l06762"></a>06762       <a class="code" href="psympriv_8h.html#a62f8da83aee3f33ec2da32c0e583260a">add_psymbol_to_list</a> (actual_name, strlen (actual_name),
<a name="l06763"></a>06763                            built_actual_name != NULL,
<a name="l06764"></a>06764                            <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>,
<a name="l06765"></a>06765                            &amp;objfile-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>,
<a name="l06766"></a>06766                            0, (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 0, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>, objfile);
<a name="l06767"></a>06767       <span class="keywordflow">break</span>;
<a name="l06768"></a>06768     <span class="keywordflow">case</span> DW_TAG_class_type:
<a name="l06769"></a>06769     <span class="keywordflow">case</span> DW_TAG_interface_type:
<a name="l06770"></a>06770     <span class="keywordflow">case</span> DW_TAG_structure_type:
<a name="l06771"></a>06771     <span class="keywordflow">case</span> DW_TAG_union_type:
<a name="l06772"></a>06772     <span class="keywordflow">case</span> DW_TAG_enumeration_type:
<a name="l06773"></a>06773       <span class="comment">/* Skip external references.  The DWARF standard says in the section</span>
<a name="l06774"></a>06774 <span class="comment">         about &quot;Structure, Union, and Class Type Entries&quot;: &quot;An incomplete</span>
<a name="l06775"></a>06775 <span class="comment">         structure, union or class type is represented by a structure,</span>
<a name="l06776"></a>06776 <span class="comment">         union or class entry that does not have a byte size attribute</span>
<a name="l06777"></a>06777 <span class="comment">         and that has a DW_AT_declaration attribute.&quot;  */</span>
<a name="l06778"></a>06778       <span class="keywordflow">if</span> (!pdi-&gt;has_byte_size &amp;&amp; pdi-&gt;is_declaration)
<a name="l06779"></a>06779         {
<a name="l06780"></a>06780           <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (built_actual_name);
<a name="l06781"></a>06781           <span class="keywordflow">return</span>;
<a name="l06782"></a>06782         }
<a name="l06783"></a>06783 
<a name="l06784"></a>06784       <span class="comment">/* NOTE: carlton/2003-10-07: See comment in new_symbol about</span>
<a name="l06785"></a>06785 <span class="comment">         static vs. global.  */</span>
<a name="l06786"></a>06786       <a class="code" href="psympriv_8h.html#a62f8da83aee3f33ec2da32c0e583260a">add_psymbol_to_list</a> (actual_name, strlen (actual_name),
<a name="l06787"></a>06787                            built_actual_name != NULL,
<a name="l06788"></a>06788                            <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa1f05a16e681efd2e892974878c353f11">STRUCT_DOMAIN</a>, <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>,
<a name="l06789"></a>06789                            (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l06790"></a>06790                             || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>)
<a name="l06791"></a>06791                            ? &amp;objfile-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>
<a name="l06792"></a>06792                            : &amp;objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>,
<a name="l06793"></a>06793                            0, (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 0, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>, objfile);
<a name="l06794"></a>06794 
<a name="l06795"></a>06795       <span class="keywordflow">break</span>;
<a name="l06796"></a>06796     <span class="keywordflow">case</span> DW_TAG_enumerator:
<a name="l06797"></a>06797       <a class="code" href="psympriv_8h.html#a62f8da83aee3f33ec2da32c0e583260a">add_psymbol_to_list</a> (actual_name, strlen (actual_name),
<a name="l06798"></a>06798                            built_actual_name != NULL,
<a name="l06799"></a>06799                            <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a5268309778a6727d08106ff9f2966e54">LOC_CONST</a>,
<a name="l06800"></a>06800                            (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l06801"></a>06801                             || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>)
<a name="l06802"></a>06802                            ? &amp;objfile-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>
<a name="l06803"></a>06803                            : &amp;objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>,
<a name="l06804"></a>06804                            0, (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 0, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>, objfile);
<a name="l06805"></a>06805       <span class="keywordflow">break</span>;
<a name="l06806"></a>06806     <span class="keywordflow">default</span>:
<a name="l06807"></a>06807       <span class="keywordflow">break</span>;
<a name="l06808"></a>06808     }
<a name="l06809"></a>06809 
<a name="l06810"></a>06810   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (built_actual_name);
<a name="l06811"></a>06811 }
<a name="l06812"></a>06812 
<a name="l06813"></a>06813 <span class="comment">/* Read a partial die corresponding to a namespace; also, add a symbol</span>
<a name="l06814"></a>06814 <span class="comment">   corresponding to that namespace to the symbol table.  NAMESPACE is</span>
<a name="l06815"></a>06815 <span class="comment">   the name of the enclosing namespace.  */</span>
<a name="l06816"></a>06816 
<a name="l06817"></a>06817 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06818"></a><a class="code" href="dwarf2read_8c.html#abf35f752bbaa1439406817912d068c66">06818</a> <a class="code" href="dwarf2read_8c.html#abf35f752bbaa1439406817912d068c66">add_partial_namespace</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *pdi,
<a name="l06819"></a>06819                        <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *lowpc, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *highpc,
<a name="l06820"></a>06820                        <span class="keywordtype">int</span> need_pc, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l06821"></a>06821 {
<a name="l06822"></a>06822   <span class="comment">/* Add a symbol for the namespace.  */</span>
<a name="l06823"></a>06823 
<a name="l06824"></a>06824   <a class="code" href="dwarf2read_8c.html#a46d3f288e2cd7c77113df32913e69f56">add_partial_symbol</a> (pdi, cu);
<a name="l06825"></a>06825 
<a name="l06826"></a>06826   <span class="comment">/* Now scan partial symbols in that namespace.  */</span>
<a name="l06827"></a>06827 
<a name="l06828"></a>06828   <span class="keywordflow">if</span> (pdi-&gt;has_children)
<a name="l06829"></a>06829     <a class="code" href="dwarf2read_8c.html#aeffcf90b9b19c7413fc505d0bf8e8657">scan_partial_symbols</a> (pdi-&gt;<a class="code" href="structpartial__die__info.html#a7761befb396a96f0d770f8b2a126291b">die_child</a>, lowpc, highpc, need_pc, cu);
<a name="l06830"></a>06830 }
<a name="l06831"></a>06831 
<a name="l06832"></a>06832 <span class="comment">/* Read a partial die corresponding to a Fortran module.  */</span>
<a name="l06833"></a>06833 
<a name="l06834"></a>06834 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06835"></a><a class="code" href="dwarf2read_8c.html#a9ec445afdbd9cf0243499e47665d0d83">06835</a> <a class="code" href="dwarf2read_8c.html#a9ec445afdbd9cf0243499e47665d0d83">add_partial_module</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *pdi, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *lowpc,
<a name="l06836"></a>06836                     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *highpc, <span class="keywordtype">int</span> need_pc, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l06837"></a>06837 {
<a name="l06838"></a>06838   <span class="comment">/* Now scan partial symbols in that module.  */</span>
<a name="l06839"></a>06839 
<a name="l06840"></a>06840   <span class="keywordflow">if</span> (pdi-&gt;has_children)
<a name="l06841"></a>06841     <a class="code" href="dwarf2read_8c.html#aeffcf90b9b19c7413fc505d0bf8e8657">scan_partial_symbols</a> (pdi-&gt;<a class="code" href="structpartial__die__info.html#a7761befb396a96f0d770f8b2a126291b">die_child</a>, lowpc, highpc, need_pc, cu);
<a name="l06842"></a>06842 }
<a name="l06843"></a>06843 
<a name="l06844"></a>06844 <span class="comment">/* Read a partial die corresponding to a subprogram and create a partial</span>
<a name="l06845"></a>06845 <span class="comment">   symbol for that subprogram.  When the CU language allows it, this</span>
<a name="l06846"></a>06846 <span class="comment">   routine also defines a partial symbol for each nested subprogram</span>
<a name="l06847"></a>06847 <span class="comment">   that this subprogram contains.</span>
<a name="l06848"></a>06848 <span class="comment"></span>
<a name="l06849"></a>06849 <span class="comment">   DIE my also be a lexical block, in which case we simply search</span>
<a name="l06850"></a>06850 <span class="comment">   recursively for suprograms defined inside that lexical block.</span>
<a name="l06851"></a>06851 <span class="comment">   Again, this is only performed when the CU language allows this</span>
<a name="l06852"></a>06852 <span class="comment">   type of definitions.  */</span>
<a name="l06853"></a>06853 
<a name="l06854"></a>06854 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06855"></a><a class="code" href="dwarf2read_8c.html#a35c693a59ce32f823e31c31ab56b1d78">06855</a> <a class="code" href="dwarf2read_8c.html#a35c693a59ce32f823e31c31ab56b1d78">add_partial_subprogram</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *pdi,
<a name="l06856"></a>06856                         <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *lowpc, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *highpc,
<a name="l06857"></a>06857                         <span class="keywordtype">int</span> need_pc, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l06858"></a>06858 {
<a name="l06859"></a>06859   <span class="keywordflow">if</span> (pdi-&gt;tag == DW_TAG_subprogram)
<a name="l06860"></a>06860     {
<a name="l06861"></a>06861       <span class="keywordflow">if</span> (pdi-&gt;has_pc_info)
<a name="l06862"></a>06862         {
<a name="l06863"></a>06863           <span class="keywordflow">if</span> (pdi-&gt;<a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a> &lt; *lowpc)
<a name="l06864"></a>06864             *lowpc = pdi-&gt;<a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a>;
<a name="l06865"></a>06865           <span class="keywordflow">if</span> (pdi-&gt;<a class="code" href="structpartial__die__info.html#a958cea19f3de0168488931ed04efc700">highpc</a> &gt; *highpc)
<a name="l06866"></a>06866             *highpc = pdi-&gt;<a class="code" href="structpartial__die__info.html#a958cea19f3de0168488931ed04efc700">highpc</a>;
<a name="l06867"></a>06867           <span class="keywordflow">if</span> (need_pc)
<a name="l06868"></a>06868             {
<a name="l06869"></a>06869               <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> baseaddr;
<a name="l06870"></a>06870               <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l06871"></a>06871 
<a name="l06872"></a>06872               baseaddr = <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>,
<a name="l06873"></a>06873                                    <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l06874"></a>06874               <a class="code" href="addrmap_8c.html#ad0decf9c15214a17313c8c9d9828205c">addrmap_set_empty</a> (objfile-&gt;<a class="code" href="structobjfile.html#ae7c792f2cd4efcff86d84d7bd3e15b26">psymtabs_addrmap</a>,
<a name="l06875"></a>06875                                  pdi-&gt;<a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a> + baseaddr,
<a name="l06876"></a>06876                                  pdi-&gt;<a class="code" href="structpartial__die__info.html#a958cea19f3de0168488931ed04efc700">highpc</a> - 1 + baseaddr,
<a name="l06877"></a>06877                                  cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a>);
<a name="l06878"></a>06878             }
<a name="l06879"></a>06879         }
<a name="l06880"></a>06880 
<a name="l06881"></a>06881       <span class="keywordflow">if</span> (pdi-&gt;has_pc_info || (!pdi-&gt;is_external &amp;&amp; pdi-&gt;may_be_inlined))
<a name="l06882"></a>06882         {
<a name="l06883"></a>06883           <span class="keywordflow">if</span> (!pdi-&gt;is_declaration)
<a name="l06884"></a>06884             <span class="comment">/* Ignore subprogram DIEs that do not have a name, they are</span>
<a name="l06885"></a>06885 <span class="comment">               illegal.  Do not emit a complaint at this point, we will</span>
<a name="l06886"></a>06886 <span class="comment">               do so when we convert this psymtab into a symtab.  */</span>
<a name="l06887"></a>06887             <span class="keywordflow">if</span> (pdi-&gt;name)
<a name="l06888"></a>06888               <a class="code" href="dwarf2read_8c.html#a46d3f288e2cd7c77113df32913e69f56">add_partial_symbol</a> (pdi, cu);
<a name="l06889"></a>06889         }
<a name="l06890"></a>06890     }
<a name="l06891"></a>06891 
<a name="l06892"></a>06892   <span class="keywordflow">if</span> (! pdi-&gt;has_children)
<a name="l06893"></a>06893     <span class="keywordflow">return</span>;
<a name="l06894"></a>06894 
<a name="l06895"></a>06895   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l06896"></a>06896     {
<a name="l06897"></a>06897       pdi = pdi-&gt;<a class="code" href="structpartial__die__info.html#a7761befb396a96f0d770f8b2a126291b">die_child</a>;
<a name="l06898"></a>06898       <span class="keywordflow">while</span> (pdi != NULL)
<a name="l06899"></a>06899         {
<a name="l06900"></a>06900           <a class="code" href="dwarf2read_8c.html#a271dd2144532648290913da6252d331b">fixup_partial_die</a> (pdi, cu);
<a name="l06901"></a>06901           <span class="keywordflow">if</span> (pdi-&gt;tag == DW_TAG_subprogram
<a name="l06902"></a>06902               || pdi-&gt;tag == DW_TAG_lexical_block)
<a name="l06903"></a>06903             <a class="code" href="dwarf2read_8c.html#a35c693a59ce32f823e31c31ab56b1d78">add_partial_subprogram</a> (pdi, lowpc, highpc, need_pc, cu);
<a name="l06904"></a>06904           pdi = pdi-&gt;<a class="code" href="structpartial__die__info.html#ad62d4a24f9c19d6835843c6a066fea36">die_sibling</a>;
<a name="l06905"></a>06905         }
<a name="l06906"></a>06906     }
<a name="l06907"></a>06907 }
<a name="l06908"></a>06908 
<a name="l06909"></a>06909 <span class="comment">/* Read a partial die corresponding to an enumeration type.  */</span>
<a name="l06910"></a>06910 
<a name="l06911"></a>06911 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l06912"></a><a class="code" href="dwarf2read_8c.html#abf32e648b8d904a35eb48ac91073708a">06912</a> <a class="code" href="dwarf2read_8c.html#abf32e648b8d904a35eb48ac91073708a">add_partial_enumeration</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *enum_pdi,
<a name="l06913"></a>06913                          <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l06914"></a>06914 {
<a name="l06915"></a>06915   <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *pdi;
<a name="l06916"></a>06916 
<a name="l06917"></a>06917   <span class="keywordflow">if</span> (enum_pdi-&gt;name != NULL)
<a name="l06918"></a>06918     <a class="code" href="dwarf2read_8c.html#a46d3f288e2cd7c77113df32913e69f56">add_partial_symbol</a> (enum_pdi, cu);
<a name="l06919"></a>06919 
<a name="l06920"></a>06920   pdi = enum_pdi-&gt;<a class="code" href="structpartial__die__info.html#a7761befb396a96f0d770f8b2a126291b">die_child</a>;
<a name="l06921"></a>06921   <span class="keywordflow">while</span> (pdi)
<a name="l06922"></a>06922     {
<a name="l06923"></a>06923       <span class="keywordflow">if</span> (pdi-&gt;tag != DW_TAG_enumerator || pdi-&gt;name == NULL)
<a name="l06924"></a>06924         <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;malformed enumerator DIE ignored&quot;</span>));
<a name="l06925"></a>06925       <span class="keywordflow">else</span>
<a name="l06926"></a>06926         <a class="code" href="dwarf2read_8c.html#a46d3f288e2cd7c77113df32913e69f56">add_partial_symbol</a> (pdi, cu);
<a name="l06927"></a>06927       pdi = pdi-&gt;<a class="code" href="structpartial__die__info.html#ad62d4a24f9c19d6835843c6a066fea36">die_sibling</a>;
<a name="l06928"></a>06928     }
<a name="l06929"></a>06929 }
<a name="l06930"></a>06930 
<a name="l06931"></a>06931 <span class="comment">/* Return the initial uleb128 in the die at INFO_PTR.  */</span>
<a name="l06932"></a>06932 
<a name="l06933"></a>06933 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l06934"></a><a class="code" href="dwarf2read_8c.html#a750ce8dd923161d4fd41793c6965ca6c">06934</a> <a class="code" href="dwarf2read_8c.html#a750ce8dd923161d4fd41793c6965ca6c">peek_abbrev_code</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr)
<a name="l06935"></a>06935 {
<a name="l06936"></a>06936   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l06937"></a>06937 
<a name="l06938"></a>06938   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, info_ptr, &amp;bytes_read);
<a name="l06939"></a>06939 }
<a name="l06940"></a>06940 
<a name="l06941"></a>06941 <span class="comment">/* Read the initial uleb128 in the die at INFO_PTR in compilation unit CU.</span>
<a name="l06942"></a>06942 <span class="comment">   Return the corresponding abbrev, or NULL if the number is zero (indicating</span>
<a name="l06943"></a>06943 <span class="comment">   an empty DIE).  In either case *BYTES_READ will be set to the length of</span>
<a name="l06944"></a>06944 <span class="comment">   the initial number.  */</span>
<a name="l06945"></a>06945 
<a name="l06946"></a>06946 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a> *
<a name="l06947"></a><a class="code" href="dwarf2read_8c.html#a1dab71c5bc62528e0736f19d3343e274">06947</a> <a class="code" href="dwarf2read_8c.html#a1dab71c5bc62528e0736f19d3343e274">peek_die_abbrev</a> (<span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *bytes_read,
<a name="l06948"></a>06948                  <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l06949"></a>06949 {
<a name="l06950"></a>06950   bfd *abfd = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>;
<a name="l06951"></a>06951   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> abbrev_number;
<a name="l06952"></a>06952   <span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a> *abbrev;
<a name="l06953"></a>06953 
<a name="l06954"></a>06954   abbrev_number = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, info_ptr, bytes_read);
<a name="l06955"></a>06955 
<a name="l06956"></a>06956   <span class="keywordflow">if</span> (abbrev_number == 0)
<a name="l06957"></a>06957     <span class="keywordflow">return</span> NULL;
<a name="l06958"></a>06958 
<a name="l06959"></a>06959   abbrev = <a class="code" href="dwarf2read_8c.html#a320857b558736bdfe9fa88072e106841">abbrev_table_lookup_abbrev</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a57e9b37ae0dfd83c0e16565ca75c9781">abbrev_table</a>, abbrev_number);
<a name="l06960"></a>06960   <span class="keywordflow">if</span> (!abbrev)
<a name="l06961"></a>06961     {
<a name="l06962"></a>06962       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Could not find abbrev number %d [in module %s]&quot;</span>),
<a name="l06963"></a>06963              abbrev_number, bfd_get_filename (abfd));
<a name="l06964"></a>06964     }
<a name="l06965"></a>06965 
<a name="l06966"></a>06966   <span class="keywordflow">return</span> abbrev;
<a name="l06967"></a>06967 }
<a name="l06968"></a>06968 
<a name="l06969"></a>06969 <span class="comment">/* Scan the debug information for CU starting at INFO_PTR in buffer BUFFER.</span>
<a name="l06970"></a>06970 <span class="comment">   Returns a pointer to the end of a series of DIEs, terminated by an empty</span>
<a name="l06971"></a>06971 <span class="comment">   DIE.  Any children of the skipped DIEs will also be skipped.  */</span>
<a name="l06972"></a>06972 
<a name="l06973"></a>06973 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l06974"></a><a class="code" href="dwarf2read_8c.html#ae8da6426d7425ee3920d4c901f3d6b5a">06974</a> <a class="code" href="dwarf2read_8c.html#ae8da6426d7425ee3920d4c901f3d6b5a">skip_children</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr)
<a name="l06975"></a>06975 {
<a name="l06976"></a>06976   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l06977"></a>06977   <span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a> *abbrev;
<a name="l06978"></a>06978   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l06979"></a>06979 
<a name="l06980"></a>06980   <span class="keywordflow">while</span> (1)
<a name="l06981"></a>06981     {
<a name="l06982"></a>06982       abbrev = <a class="code" href="dwarf2read_8c.html#a1dab71c5bc62528e0736f19d3343e274">peek_die_abbrev</a> (info_ptr, &amp;bytes_read, cu);
<a name="l06983"></a>06983       <span class="keywordflow">if</span> (abbrev == NULL)
<a name="l06984"></a>06984         <span class="keywordflow">return</span> info_ptr + bytes_read;
<a name="l06985"></a>06985       <span class="keywordflow">else</span>
<a name="l06986"></a>06986         info_ptr = <a class="code" href="dwarf2read_8c.html#a2841c651fdaf6de18181efeb6746de43">skip_one_die</a> (reader, info_ptr + bytes_read, abbrev);
<a name="l06987"></a>06987     }
<a name="l06988"></a>06988 }
<a name="l06989"></a>06989 
<a name="l06990"></a>06990 <span class="comment">/* Scan the debug information for CU starting at INFO_PTR in buffer BUFFER.</span>
<a name="l06991"></a>06991 <span class="comment">   INFO_PTR should point just after the initial uleb128 of a DIE, and the</span>
<a name="l06992"></a>06992 <span class="comment">   abbrev corresponding to that skipped uleb128 should be passed in</span>
<a name="l06993"></a>06993 <span class="comment">   ABBREV.  Returns a pointer to this DIE&#39;s sibling, skipping any</span>
<a name="l06994"></a>06994 <span class="comment">   children.  */</span>
<a name="l06995"></a>06995 
<a name="l06996"></a>06996 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l06997"></a><a class="code" href="dwarf2read_8c.html#a2841c651fdaf6de18181efeb6746de43">06997</a> <a class="code" href="dwarf2read_8c.html#a2841c651fdaf6de18181efeb6746de43">skip_one_die</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l06998"></a>06998               <span class="keyword">struct</span> <a class="code" href="structabbrev__info.html">abbrev_info</a> *abbrev)
<a name="l06999"></a>06999 {
<a name="l07000"></a>07000   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l07001"></a>07001   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> attr;
<a name="l07002"></a>07002   bfd *abfd = reader-&gt;<a class="code" href="structdie__reader__specs.html#a1a2ea4151d385459f3a3fb7b0dad2973">abfd</a>;
<a name="l07003"></a>07003   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l07004"></a>07004   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structbuffer.html">buffer</a> = reader-&gt;<a class="code" href="structdie__reader__specs.html#a923f3b4252ec94584560d5433e848dc0">buffer</a>;
<a name="l07005"></a>07005   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buffer_end = reader-&gt;<a class="code" href="structdie__reader__specs.html#ae090c8e4b75582074889118172ea9095">buffer_end</a>;
<a name="l07006"></a>07006   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *start_info_ptr = info_ptr;
<a name="l07007"></a>07007   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> form, i;
<a name="l07008"></a>07008 
<a name="l07009"></a>07009   <span class="keywordflow">for</span> (i = 0; i &lt; abbrev-&gt;<a class="code" href="structabbrev__info.html#a34d2e21fe3925a6c1613e8e42993581e">num_attrs</a>; i++)
<a name="l07010"></a>07010     {
<a name="l07011"></a>07011       <span class="comment">/* The only abbrev we care about is DW_AT_sibling.  */</span>
<a name="l07012"></a>07012       <span class="keywordflow">if</span> (abbrev-&gt;<a class="code" href="structabbrev__info.html#aa70664d01df5b3d3567c6841c9de22f2">attrs</a>[i].name == DW_AT_sibling)
<a name="l07013"></a>07013         {
<a name="l07014"></a>07014           <a class="code" href="dwarf2read_8c.html#a08e1a18f85e288f9241d3baab2ded2b0">read_attribute</a> (reader, &amp;attr, &amp;abbrev-&gt;<a class="code" href="structabbrev__info.html#aa70664d01df5b3d3567c6841c9de22f2">attrs</a>[i], info_ptr);
<a name="l07015"></a>07015           <span class="keywordflow">if</span> (attr.form == DW_FORM_ref_addr)
<a name="l07016"></a>07016             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l07017"></a>07017                        <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;ignoring absolute DW_AT_sibling&quot;</span>));
<a name="l07018"></a>07018           <span class="keywordflow">else</span>
<a name="l07019"></a>07019             <span class="keywordflow">return</span> buffer + <a class="code" href="dwarf2read_8c.html#a28e7eb63f317d51f9be16584d407c508">dwarf2_get_ref_die_offset</a> (&amp;attr).<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l07020"></a>07020         }
<a name="l07021"></a>07021 
<a name="l07022"></a>07022       <span class="comment">/* If it isn&#39;t DW_AT_sibling, skip this attribute.  */</span>
<a name="l07023"></a>07023       form = abbrev-&gt;<a class="code" href="structabbrev__info.html#aa70664d01df5b3d3567c6841c9de22f2">attrs</a>[i].form;
<a name="l07024"></a>07024     skip_attribute:
<a name="l07025"></a>07025       <span class="keywordflow">switch</span> (form)
<a name="l07026"></a>07026         {
<a name="l07027"></a>07027         <span class="keywordflow">case</span> DW_FORM_ref_addr:
<a name="l07028"></a>07028           <span class="comment">/* In DWARF 2, DW_FORM_ref_addr is address sized; in DWARF 3</span>
<a name="l07029"></a>07029 <span class="comment">             and later it is offset sized.  */</span>
<a name="l07030"></a>07030           <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a68d6c482c646af0266771ad56b73748d">version</a> == 2)
<a name="l07031"></a>07031             info_ptr += cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l07032"></a>07032           <span class="keywordflow">else</span>
<a name="l07033"></a>07033             info_ptr += cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>;
<a name="l07034"></a>07034           <span class="keywordflow">break</span>;
<a name="l07035"></a>07035         <span class="keywordflow">case</span> DW_FORM_GNU_ref_alt:
<a name="l07036"></a>07036           info_ptr += cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>;
<a name="l07037"></a>07037           <span class="keywordflow">break</span>;
<a name="l07038"></a>07038         <span class="keywordflow">case</span> DW_FORM_addr:
<a name="l07039"></a>07039           info_ptr += cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l07040"></a>07040           <span class="keywordflow">break</span>;
<a name="l07041"></a>07041         <span class="keywordflow">case</span> DW_FORM_data1:
<a name="l07042"></a>07042         <span class="keywordflow">case</span> DW_FORM_ref1:
<a name="l07043"></a>07043         <span class="keywordflow">case</span> DW_FORM_flag:
<a name="l07044"></a>07044           info_ptr += 1;
<a name="l07045"></a>07045           <span class="keywordflow">break</span>;
<a name="l07046"></a>07046         <span class="keywordflow">case</span> DW_FORM_flag_present:
<a name="l07047"></a>07047           <span class="keywordflow">break</span>;
<a name="l07048"></a>07048         <span class="keywordflow">case</span> DW_FORM_data2:
<a name="l07049"></a>07049         <span class="keywordflow">case</span> DW_FORM_ref2:
<a name="l07050"></a>07050           info_ptr += 2;
<a name="l07051"></a>07051           <span class="keywordflow">break</span>;
<a name="l07052"></a>07052         <span class="keywordflow">case</span> DW_FORM_data4:
<a name="l07053"></a>07053         <span class="keywordflow">case</span> DW_FORM_ref4:
<a name="l07054"></a>07054           info_ptr += 4;
<a name="l07055"></a>07055           <span class="keywordflow">break</span>;
<a name="l07056"></a>07056         <span class="keywordflow">case</span> DW_FORM_data8:
<a name="l07057"></a>07057         <span class="keywordflow">case</span> DW_FORM_ref8:
<a name="l07058"></a>07058         <span class="keywordflow">case</span> DW_FORM_ref_sig8:
<a name="l07059"></a>07059           info_ptr += 8;
<a name="l07060"></a>07060           <span class="keywordflow">break</span>;
<a name="l07061"></a>07061         <span class="keywordflow">case</span> DW_FORM_string:
<a name="l07062"></a>07062           <a class="code" href="dwarf2read_8c.html#a5386044c6f74a934dbd3f4a3199cf5be">read_direct_string</a> (abfd, info_ptr, &amp;bytes_read);
<a name="l07063"></a>07063           info_ptr += bytes_read;
<a name="l07064"></a>07064           <span class="keywordflow">break</span>;
<a name="l07065"></a>07065         <span class="keywordflow">case</span> DW_FORM_sec_offset:
<a name="l07066"></a>07066         <span class="keywordflow">case</span> DW_FORM_strp:
<a name="l07067"></a>07067         <span class="keywordflow">case</span> DW_FORM_GNU_strp_alt:
<a name="l07068"></a>07068           info_ptr += cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>;
<a name="l07069"></a>07069           <span class="keywordflow">break</span>;
<a name="l07070"></a>07070         <span class="keywordflow">case</span> DW_FORM_exprloc:
<a name="l07071"></a>07071         <span class="keywordflow">case</span> DW_FORM_block:
<a name="l07072"></a>07072           info_ptr += <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, info_ptr, &amp;bytes_read);
<a name="l07073"></a>07073           info_ptr += bytes_read;
<a name="l07074"></a>07074           <span class="keywordflow">break</span>;
<a name="l07075"></a>07075         <span class="keywordflow">case</span> DW_FORM_block1:
<a name="l07076"></a>07076           info_ptr += 1 + <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, info_ptr);
<a name="l07077"></a>07077           <span class="keywordflow">break</span>;
<a name="l07078"></a>07078         <span class="keywordflow">case</span> DW_FORM_block2:
<a name="l07079"></a>07079           info_ptr += 2 + <a class="code" href="dwarf2read_8c.html#a35663eebf65b4217082f14bc1f782307">read_2_bytes</a> (abfd, info_ptr);
<a name="l07080"></a>07080           <span class="keywordflow">break</span>;
<a name="l07081"></a>07081         <span class="keywordflow">case</span> DW_FORM_block4:
<a name="l07082"></a>07082           info_ptr += 4 + <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (abfd, info_ptr);
<a name="l07083"></a>07083           <span class="keywordflow">break</span>;
<a name="l07084"></a>07084         <span class="keywordflow">case</span> DW_FORM_sdata:
<a name="l07085"></a>07085         <span class="keywordflow">case</span> DW_FORM_udata:
<a name="l07086"></a>07086         <span class="keywordflow">case</span> DW_FORM_ref_udata:
<a name="l07087"></a>07087         <span class="keywordflow">case</span> DW_FORM_GNU_addr_index:
<a name="l07088"></a>07088         <span class="keywordflow">case</span> DW_FORM_GNU_str_index:
<a name="l07089"></a>07089           info_ptr = <a class="code" href="dwarf2expr_8c.html#ab1499b71bb21a54c08c8a6f9c7344f75">safe_skip_leb128</a> (info_ptr, buffer_end);
<a name="l07090"></a>07090           <span class="keywordflow">break</span>;
<a name="l07091"></a>07091         <span class="keywordflow">case</span> DW_FORM_indirect:
<a name="l07092"></a>07092           form = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, info_ptr, &amp;bytes_read);
<a name="l07093"></a>07093           info_ptr += bytes_read;
<a name="l07094"></a>07094           <span class="comment">/* We need to continue parsing from here, so just go back to</span>
<a name="l07095"></a>07095 <span class="comment">             the top.  */</span>
<a name="l07096"></a>07096           <span class="keywordflow">goto</span> skip_attribute;
<a name="l07097"></a>07097 
<a name="l07098"></a>07098         <span class="keywordflow">default</span>:
<a name="l07099"></a>07099           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Cannot handle %s &quot;</span>
<a name="l07100"></a>07100                    <span class="stringliteral">&quot;in DWARF reader [in module %s]&quot;</span>),
<a name="l07101"></a>07101                  <a class="code" href="dwarf2read_8c.html#a6810653c49d4b3be30290dc1bcf20c94">dwarf_form_name</a> (form),
<a name="l07102"></a>07102                  bfd_get_filename (abfd));
<a name="l07103"></a>07103         }
<a name="l07104"></a>07104     }
<a name="l07105"></a>07105 
<a name="l07106"></a>07106   <span class="keywordflow">if</span> (abbrev-&gt;<a class="code" href="structabbrev__info.html#ac84c5aceafdfea0a95c619f623b78de1">has_children</a>)
<a name="l07107"></a>07107     <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#ae8da6426d7425ee3920d4c901f3d6b5a">skip_children</a> (reader, info_ptr);
<a name="l07108"></a>07108   <span class="keywordflow">else</span>
<a name="l07109"></a>07109     <span class="keywordflow">return</span> info_ptr;
<a name="l07110"></a>07110 }
<a name="l07111"></a>07111 
<a name="l07112"></a>07112 <span class="comment">/* Locate ORIG_PDI&#39;s sibling.</span>
<a name="l07113"></a>07113 <span class="comment">   INFO_PTR should point to the start of the next DIE after ORIG_PDI.  */</span>
<a name="l07114"></a>07114 
<a name="l07115"></a>07115 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l07116"></a><a class="code" href="dwarf2read_8c.html#a2af2667574f99c03f3ff8f763221a47f">07116</a> <a class="code" href="dwarf2read_8c.html#a2af2667574f99c03f3ff8f763221a47f">locate_pdi_sibling</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l07117"></a>07117                     <span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *orig_pdi,
<a name="l07118"></a>07118                     <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr)
<a name="l07119"></a>07119 {
<a name="l07120"></a>07120   <span class="comment">/* Do we know the sibling already?  */</span>
<a name="l07121"></a>07121 
<a name="l07122"></a>07122   <span class="keywordflow">if</span> (orig_pdi-&gt;<a class="code" href="structpartial__die__info.html#aaf967ab6265b2f79cd8cc292ee597c49">sibling</a>)
<a name="l07123"></a>07123     <span class="keywordflow">return</span> orig_pdi-&gt;<a class="code" href="structpartial__die__info.html#aaf967ab6265b2f79cd8cc292ee597c49">sibling</a>;
<a name="l07124"></a>07124 
<a name="l07125"></a>07125   <span class="comment">/* Are there any children to deal with?  */</span>
<a name="l07126"></a>07126 
<a name="l07127"></a>07127   <span class="keywordflow">if</span> (!orig_pdi-&gt;has_children)
<a name="l07128"></a>07128     <span class="keywordflow">return</span> info_ptr;
<a name="l07129"></a>07129 
<a name="l07130"></a>07130   <span class="comment">/* Skip the children the long way.  */</span>
<a name="l07131"></a>07131 
<a name="l07132"></a>07132   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#ae8da6426d7425ee3920d4c901f3d6b5a">skip_children</a> (reader, info_ptr);
<a name="l07133"></a>07133 }
<a name="l07134"></a>07134 
<a name="l07135"></a>07135 <span class="comment">/* Expand this partial symbol table into a full symbol table.  SELF is</span>
<a name="l07136"></a>07136 <span class="comment">   not NULL.  */</span>
<a name="l07137"></a>07137 
<a name="l07138"></a>07138 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07139"></a><a class="code" href="dwarf2read_8c.html#ad51fcf6e9b38c802ac64c2dc6f19d167">07139</a> <a class="code" href="dwarf2read_8c.html#ad51fcf6e9b38c802ac64c2dc6f19d167">dwarf2_read_symtab</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *<span class="keyword">self</span>,
<a name="l07140"></a>07140                     <span class="keyword">struct</span> objfile *objfile)
<a name="l07141"></a>07141 {
<a name="l07142"></a>07142   <span class="keywordflow">if</span> (self-&gt;readin)
<a name="l07143"></a>07143     {
<a name="l07144"></a>07144       <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;bug: psymtab for %s is already read in.&quot;</span>),
<a name="l07145"></a>07145                self-&gt;filename);
<a name="l07146"></a>07146     }
<a name="l07147"></a>07147   <span class="keywordflow">else</span>
<a name="l07148"></a>07148     {
<a name="l07149"></a>07149       <span class="keywordflow">if</span> (<a class="code" href="defs_8h.html#a3f2f91ed92de5dfaa6d27fb82822f8d5">info_verbose</a>)
<a name="l07150"></a>07150         {
<a name="l07151"></a>07151           <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Reading in symbols for %s...&quot;</span>),
<a name="l07152"></a>07152                            self-&gt;filename);
<a name="l07153"></a>07153           <a class="code" href="ui-file_8c.html#a046f07b5ef1bcc35c28b4be983e39998">gdb_flush</a> (<a class="code" href="main_8c.html#a41a2b997ba5454df787d61f051dd918c">gdb_stdout</a>);
<a name="l07154"></a>07154         }
<a name="l07155"></a>07155 
<a name="l07156"></a>07156       <span class="comment">/* Restore our global data.  */</span>
<a name="l07157"></a>07157       dwarf2_per_objfile = objfile_data (objfile, <a class="code" href="dwarf2read_8c.html#a9fcfdd623d890b4c3b4ac0ba42e7df4b">dwarf2_objfile_data_key</a>);
<a name="l07158"></a>07158 
<a name="l07159"></a>07159       <span class="comment">/* If this psymtab is constructed from a debug-only objfile, the</span>
<a name="l07160"></a>07160 <span class="comment">         has_section_at_zero flag will not necessarily be correct.  We</span>
<a name="l07161"></a>07161 <span class="comment">         can get the correct value for this flag by looking at the data</span>
<a name="l07162"></a>07162 <span class="comment">         associated with the (presumably stripped) associated objfile.  */</span>
<a name="l07163"></a>07163       <span class="keywordflow">if</span> (objfile-&gt;<a class="code" href="structobjfile.html#a1ef5fed06f7a9c5864c9a0ce46a87710">separate_debug_objfile_backlink</a>)
<a name="l07164"></a>07164         {
<a name="l07165"></a>07165           <span class="keyword">struct </span>dwarf2_per_objfile *dpo_backlink
<a name="l07166"></a>07166             = objfile_data (objfile-&gt;<a class="code" href="structobjfile.html#a1ef5fed06f7a9c5864c9a0ce46a87710">separate_debug_objfile_backlink</a>,
<a name="l07167"></a>07167                             <a class="code" href="dwarf2read_8c.html#a9fcfdd623d890b4c3b4ac0ba42e7df4b">dwarf2_objfile_data_key</a>);
<a name="l07168"></a>07168 
<a name="l07169"></a>07169           dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ab6b03c3a65fa04f04741158e8aebc895">has_section_at_zero</a>
<a name="l07170"></a>07170             = dpo_backlink-&gt;<a class="code" href="structdwarf2__per__objfile.html#ab6b03c3a65fa04f04741158e8aebc895">has_section_at_zero</a>;
<a name="l07171"></a>07171         }
<a name="l07172"></a>07172 
<a name="l07173"></a>07173       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a91e7a3d79383661130df87b91ef1e6c9">reading_partial_symbols</a> = 0;
<a name="l07174"></a>07174 
<a name="l07175"></a>07175       <a class="code" href="dwarf2read_8c.html#a28d3f50615a68b574ce61a8bd85258eb">psymtab_to_symtab_1</a> (<span class="keyword">self</span>);
<a name="l07176"></a>07176 
<a name="l07177"></a>07177       <span class="comment">/* Finish up the debug error message.  */</span>
<a name="l07178"></a>07178       <span class="keywordflow">if</span> (<a class="code" href="defs_8h.html#a3f2f91ed92de5dfaa6d27fb82822f8d5">info_verbose</a>)
<a name="l07179"></a>07179         <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;done.\n&quot;</span>));
<a name="l07180"></a>07180     }
<a name="l07181"></a>07181 
<a name="l07182"></a>07182   <a class="code" href="dwarf2read_8c.html#a15521f267ec507aa6fbf4e80df678078">process_cu_includes</a> ();
<a name="l07183"></a>07183 }
<a name="l07184"></a>07184 
<a name="l07185"></a>07185 <span class="comment">/* Reading in full CUs.  */</span>
<a name="l07186"></a>07186 
<a name="l07187"></a>07187 <span class="comment">/* Add PER_CU to the queue.  */</span>
<a name="l07188"></a>07188 
<a name="l07189"></a>07189 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07190"></a><a class="code" href="dwarf2read_8c.html#a756eccd342c094e5937e6ab43bf8a5a4">07190</a> <a class="code" href="dwarf2read_8c.html#a756eccd342c094e5937e6ab43bf8a5a4">queue_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu,
<a name="l07191"></a>07191                  <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> pretend_language)
<a name="l07192"></a>07192 {
<a name="l07193"></a>07193   <span class="keyword">struct </span><a class="code" href="structdwarf2__queue__item.html">dwarf2_queue_item</a> *item;
<a name="l07194"></a>07194 
<a name="l07195"></a>07195   per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a2eed1245c96a6300453e610421b98b93">queued</a> = 1;
<a name="l07196"></a>07196   item = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (*item));
<a name="l07197"></a>07197   item-&gt;<a class="code" href="structdwarf2__queue__item.html#a0ff411ef5efcea7cbedd53dfc6eed639">per_cu</a> = <a class="code" href="structdwarf2__queue__item.html#a0ff411ef5efcea7cbedd53dfc6eed639">per_cu</a>;
<a name="l07198"></a>07198   item-&gt;<a class="code" href="structdwarf2__queue__item.html#a69804da124a8e018b54e4f88c306c619">pretend_language</a> = <a class="code" href="structdwarf2__queue__item.html#a69804da124a8e018b54e4f88c306c619">pretend_language</a>;
<a name="l07199"></a>07199   item-&gt;<a class="code" href="structdwarf2__queue__item.html#a39fec37eb2c8cd48833d0b2a62cbbbc2">next</a> = NULL;
<a name="l07200"></a>07200 
<a name="l07201"></a>07201   <span class="keywordflow">if</span> (dwarf2_queue == NULL)
<a name="l07202"></a>07202     dwarf2_queue = item;
<a name="l07203"></a>07203   <span class="keywordflow">else</span>
<a name="l07204"></a>07204     dwarf2_queue_tail-&gt;<a class="code" href="structdwarf2__queue__item.html#a39fec37eb2c8cd48833d0b2a62cbbbc2">next</a> = item;
<a name="l07205"></a>07205 
<a name="l07206"></a>07206   dwarf2_queue_tail = item;
<a name="l07207"></a>07207 }
<a name="l07208"></a>07208 
<a name="l07209"></a>07209 <span class="comment">/* If PER_CU is not yet queued, add it to the queue.</span>
<a name="l07210"></a>07210 <span class="comment">   If DEPENDENT_CU is non-NULL, it has a reference to PER_CU so add a</span>
<a name="l07211"></a>07211 <span class="comment">   dependency.</span>
<a name="l07212"></a>07212 <span class="comment">   The result is non-zero if PER_CU was queued, otherwise the result is zero</span>
<a name="l07213"></a>07213 <span class="comment">   meaning either PER_CU is already queued or it is already loaded.</span>
<a name="l07214"></a>07214 <span class="comment"></span>
<a name="l07215"></a>07215 <span class="comment">   N.B. There is an invariant here that if a CU is queued then it is loaded.</span>
<a name="l07216"></a>07216 <span class="comment">   The caller is required to load PER_CU if we return non-zero.  */</span>
<a name="l07217"></a>07217 
<a name="l07218"></a>07218 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l07219"></a><a class="code" href="dwarf2read_8c.html#ac102eb30f433a30a29425f0d30a461c2">07219</a> <a class="code" href="dwarf2read_8c.html#ac102eb30f433a30a29425f0d30a461c2">maybe_queue_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *dependent_cu,
<a name="l07220"></a>07220                        <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu,
<a name="l07221"></a>07221                        <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> <a class="code" href="structdwarf2__queue__item.html#a69804da124a8e018b54e4f88c306c619">pretend_language</a>)
<a name="l07222"></a>07222 {
<a name="l07223"></a>07223   <span class="comment">/* We may arrive here during partial symbol reading, if we need full</span>
<a name="l07224"></a>07224 <span class="comment">     DIEs to process an unusual case (e.g. template arguments).  Do</span>
<a name="l07225"></a>07225 <span class="comment">     not queue PER_CU, just tell our caller to load its DIEs.  */</span>
<a name="l07226"></a>07226   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a91e7a3d79383661130df87b91ef1e6c9">reading_partial_symbols</a>)
<a name="l07227"></a>07227     {
<a name="l07228"></a>07228       <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> == NULL || per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#abc8aaad6bb3799398e9769f989fd1692">dies</a> == NULL)
<a name="l07229"></a>07229         <span class="keywordflow">return</span> 1;
<a name="l07230"></a>07230       <span class="keywordflow">return</span> 0;
<a name="l07231"></a>07231     }
<a name="l07232"></a>07232 
<a name="l07233"></a>07233   <span class="comment">/* Mark the dependence relation so that we don&#39;t flush PER_CU</span>
<a name="l07234"></a>07234 <span class="comment">     too early.  */</span>
<a name="l07235"></a>07235   <span class="keywordflow">if</span> (dependent_cu != NULL)
<a name="l07236"></a>07236     <a class="code" href="dwarf2read_8c.html#a718e49c311f78a8621ba62dec3084e02">dwarf2_add_dependence</a> (dependent_cu, per_cu);
<a name="l07237"></a>07237 
<a name="l07238"></a>07238   <span class="comment">/* If it&#39;s already on the queue, we have nothing to do.  */</span>
<a name="l07239"></a>07239   <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a2eed1245c96a6300453e610421b98b93">queued</a>)
<a name="l07240"></a>07240     <span class="keywordflow">return</span> 0;
<a name="l07241"></a>07241 
<a name="l07242"></a>07242   <span class="comment">/* If the compilation unit is already loaded, just mark it as</span>
<a name="l07243"></a>07243 <span class="comment">     used.  */</span>
<a name="l07244"></a>07244   <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> != NULL)
<a name="l07245"></a>07245     {
<a name="l07246"></a>07246       per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ae8de3b2f422c424b62543c1ef121de02">last_used</a> = 0;
<a name="l07247"></a>07247       <span class="keywordflow">return</span> 0;
<a name="l07248"></a>07248     }
<a name="l07249"></a>07249 
<a name="l07250"></a>07250   <span class="comment">/* Add it to the queue.  */</span>
<a name="l07251"></a>07251   <a class="code" href="dwarf2read_8c.html#a756eccd342c094e5937e6ab43bf8a5a4">queue_comp_unit</a> (per_cu, pretend_language);
<a name="l07252"></a>07252 
<a name="l07253"></a>07253   <span class="keywordflow">return</span> 1;
<a name="l07254"></a>07254 }
<a name="l07255"></a>07255 
<a name="l07256"></a>07256 <span class="comment">/* Process the queue.  */</span>
<a name="l07257"></a>07257 
<a name="l07258"></a>07258 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07259"></a><a class="code" href="dwarf2read_8c.html#a4299d1028cbe9bbcebb435f92cf3cbda">07259</a> <a class="code" href="dwarf2read_8c.html#a4299d1028cbe9bbcebb435f92cf3cbda">process_queue</a> (<span class="keywordtype">void</span>)
<a name="l07260"></a>07260 {
<a name="l07261"></a>07261   <span class="keyword">struct </span><a class="code" href="structdwarf2__queue__item.html">dwarf2_queue_item</a> *item, *next_item;
<a name="l07262"></a>07262 
<a name="l07263"></a>07263   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l07264"></a>07264     {
<a name="l07265"></a>07265       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l07266"></a>07266                           <span class="stringliteral">&quot;Expanding one or more symtabs of objfile %s ...\n&quot;</span>,
<a name="l07267"></a>07267                           <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (dwarf2_per_objfile-&gt;objfile));
<a name="l07268"></a>07268     }
<a name="l07269"></a>07269 
<a name="l07270"></a>07270   <span class="comment">/* The queue starts out with one item, but following a DIE reference</span>
<a name="l07271"></a>07271 <span class="comment">     may load a new CU, adding it to the end of the queue.  */</span>
<a name="l07272"></a>07272   <span class="keywordflow">for</span> (item = dwarf2_queue; item != NULL; dwarf2_queue = item = next_item)
<a name="l07273"></a>07273     {
<a name="l07274"></a>07274       <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a>
<a name="l07275"></a>07275           ? !item-&gt;<a class="code" href="structdwarf2__queue__item.html#a0ff411ef5efcea7cbedd53dfc6eed639">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a>
<a name="l07276"></a>07276           : (item-&gt;<a class="code" href="structdwarf2__queue__item.html#a0ff411ef5efcea7cbedd53dfc6eed639">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a> &amp;&amp; !item-&gt;<a class="code" href="structdwarf2__queue__item.html#a0ff411ef5efcea7cbedd53dfc6eed639">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a>-&gt;<a class="code" href="structpartial__symtab.html#a11d8e59b962db1317c8c23f917dbed42">readin</a>))
<a name="l07277"></a>07277         {
<a name="l07278"></a>07278           <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = item-&gt;<a class="code" href="structdwarf2__queue__item.html#a0ff411ef5efcea7cbedd53dfc6eed639">per_cu</a>;
<a name="l07279"></a>07279           <span class="keywordtype">char</span> buf[100];
<a name="l07280"></a>07280 
<a name="l07281"></a>07281           <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l07282"></a>07282             {
<a name="l07283"></a>07283               <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type =
<a name="l07284"></a>07284                 (<span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *) per_cu;
<a name="l07285"></a>07285 
<a name="l07286"></a>07286               sprintf (buf, <span class="stringliteral">&quot;TU %s at offset 0x%x&quot;</span>,
<a name="l07287"></a>07287                        <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (sig_type-&gt;<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a>), per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l07288"></a>07288             }
<a name="l07289"></a>07289           <span class="keywordflow">else</span>
<a name="l07290"></a>07290             sprintf (buf, <span class="stringliteral">&quot;CU at offset 0x%x&quot;</span>, per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l07291"></a>07291 
<a name="l07292"></a>07292           <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l07293"></a>07293             <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Expanding symtab of %s\n&quot;</span>, buf);
<a name="l07294"></a>07294 
<a name="l07295"></a>07295           <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l07296"></a>07296             <a class="code" href="dwarf2read_8c.html#a9b0c1ef101c10aac5bb5648a03b48d14">process_full_type_unit</a> (per_cu, item-&gt;<a class="code" href="structdwarf2__queue__item.html#a69804da124a8e018b54e4f88c306c619">pretend_language</a>);
<a name="l07297"></a>07297           <span class="keywordflow">else</span>
<a name="l07298"></a>07298             <a class="code" href="dwarf2read_8c.html#a4a43e61549842b0ddfc5d3fd23202e93">process_full_comp_unit</a> (per_cu, item-&gt;<a class="code" href="structdwarf2__queue__item.html#a69804da124a8e018b54e4f88c306c619">pretend_language</a>);
<a name="l07299"></a>07299 
<a name="l07300"></a>07300           <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l07301"></a>07301             <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Done expanding %s\n&quot;</span>, buf);
<a name="l07302"></a>07302         }
<a name="l07303"></a>07303 
<a name="l07304"></a>07304       item-&gt;<a class="code" href="structdwarf2__queue__item.html#a0ff411ef5efcea7cbedd53dfc6eed639">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a2eed1245c96a6300453e610421b98b93">queued</a> = 0;
<a name="l07305"></a>07305       next_item = item-&gt;<a class="code" href="structdwarf2__queue__item.html#a39fec37eb2c8cd48833d0b2a62cbbbc2">next</a>;
<a name="l07306"></a>07306       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (item);
<a name="l07307"></a>07307     }
<a name="l07308"></a>07308 
<a name="l07309"></a>07309   dwarf2_queue_tail = NULL;
<a name="l07310"></a>07310 
<a name="l07311"></a>07311   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l07312"></a>07312     {
<a name="l07313"></a>07313       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Done expanding symtabs of %s.\n&quot;</span>,
<a name="l07314"></a>07314                           <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (dwarf2_per_objfile-&gt;objfile));
<a name="l07315"></a>07315     }
<a name="l07316"></a>07316 }
<a name="l07317"></a>07317 
<a name="l07318"></a>07318 <span class="comment">/* Free all allocated queue entries.  This function only releases anything if</span>
<a name="l07319"></a>07319 <span class="comment">   an error was thrown; if the queue was processed then it would have been</span>
<a name="l07320"></a>07320 <span class="comment">   freed as we went along.  */</span>
<a name="l07321"></a>07321 
<a name="l07322"></a>07322 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07323"></a><a class="code" href="dwarf2read_8c.html#ace3060cbcc6a275e2260e5261c3f9dda">07323</a> <a class="code" href="dwarf2read_8c.html#ace3060cbcc6a275e2260e5261c3f9dda">dwarf2_release_queue</a> (<span class="keywordtype">void</span> *<a class="code" href="go32-nat_8c.html#a36fb645a916cd19d79712e75c47b8d03">dummy</a>)
<a name="l07324"></a>07324 {
<a name="l07325"></a>07325   <span class="keyword">struct </span><a class="code" href="structdwarf2__queue__item.html">dwarf2_queue_item</a> *item, *last;
<a name="l07326"></a>07326 
<a name="l07327"></a>07327   item = <a class="code" href="dwarf2read_8c.html#a67167a2d3a620a19ccff32ede1c3a2f5">dwarf2_queue</a>;
<a name="l07328"></a>07328   <span class="keywordflow">while</span> (item)
<a name="l07329"></a>07329     {
<a name="l07330"></a>07330       <span class="comment">/* Anything still marked queued is likely to be in an</span>
<a name="l07331"></a>07331 <span class="comment">         inconsistent state, so discard it.  */</span>
<a name="l07332"></a>07332       <span class="keywordflow">if</span> (item-&gt;<a class="code" href="structdwarf2__queue__item.html#a0ff411ef5efcea7cbedd53dfc6eed639">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a2eed1245c96a6300453e610421b98b93">queued</a>)
<a name="l07333"></a>07333         {
<a name="l07334"></a>07334           <span class="keywordflow">if</span> (item-&gt;<a class="code" href="structdwarf2__queue__item.html#a0ff411ef5efcea7cbedd53dfc6eed639">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> != NULL)
<a name="l07335"></a>07335             <a class="code" href="dwarf2read_8c.html#a88ac0ca2997594c6c41d77ceeb620711">free_one_cached_comp_unit</a> (item-&gt;<a class="code" href="structdwarf2__queue__item.html#a0ff411ef5efcea7cbedd53dfc6eed639">per_cu</a>);
<a name="l07336"></a>07336           item-&gt;<a class="code" href="structdwarf2__queue__item.html#a0ff411ef5efcea7cbedd53dfc6eed639">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a2eed1245c96a6300453e610421b98b93">queued</a> = 0;
<a name="l07337"></a>07337         }
<a name="l07338"></a>07338 
<a name="l07339"></a>07339       last = item;
<a name="l07340"></a>07340       item = item-&gt;<a class="code" href="structdwarf2__queue__item.html#a39fec37eb2c8cd48833d0b2a62cbbbc2">next</a>;
<a name="l07341"></a>07341       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (last);
<a name="l07342"></a>07342     }
<a name="l07343"></a>07343 
<a name="l07344"></a>07344   dwarf2_queue = dwarf2_queue_tail = NULL;
<a name="l07345"></a>07345 }
<a name="l07346"></a>07346 
<a name="l07347"></a>07347 <span class="comment">/* Read in full symbols for PST, and anything it depends on.  */</span>
<a name="l07348"></a>07348 
<a name="l07349"></a>07349 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07350"></a><a class="code" href="dwarf2read_8c.html#a28d3f50615a68b574ce61a8bd85258eb">07350</a> <a class="code" href="dwarf2read_8c.html#a28d3f50615a68b574ce61a8bd85258eb">psymtab_to_symtab_1</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst)
<a name="l07351"></a>07351 {
<a name="l07352"></a>07352   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu;
<a name="l07353"></a>07353   <span class="keywordtype">int</span> i;
<a name="l07354"></a>07354 
<a name="l07355"></a>07355   <span class="keywordflow">if</span> (pst-&gt;<a class="code" href="structpartial__symtab.html#a11d8e59b962db1317c8c23f917dbed42">readin</a>)
<a name="l07356"></a>07356     <span class="keywordflow">return</span>;
<a name="l07357"></a>07357 
<a name="l07358"></a>07358   <span class="keywordflow">for</span> (i = 0; i &lt; pst-&gt;<a class="code" href="structpartial__symtab.html#a917b503a5e1f7c2bb60feb6ff1e3b197">number_of_dependencies</a>; i++)
<a name="l07359"></a>07359     <span class="keywordflow">if</span> (!pst-&gt;<a class="code" href="structpartial__symtab.html#a0b7bd5bada02a362357552790b111c23">dependencies</a>[i]-&gt;<a class="code" href="structpartial__symtab.html#a11d8e59b962db1317c8c23f917dbed42">readin</a>
<a name="l07360"></a>07360         &amp;&amp; pst-&gt;<a class="code" href="structpartial__symtab.html#a0b7bd5bada02a362357552790b111c23">dependencies</a>[i]-&gt;<a class="code" href="structpartial__symtab.html#a0609b1a2e29b3419dc25520e7d7293f0">user</a> == NULL)
<a name="l07361"></a>07361       {
<a name="l07362"></a>07362         <span class="comment">/* Inform about additional files that need to be read in.  */</span>
<a name="l07363"></a>07363         <span class="keywordflow">if</span> (<a class="code" href="defs_8h.html#a3f2f91ed92de5dfaa6d27fb82822f8d5">info_verbose</a>)
<a name="l07364"></a>07364           {
<a name="l07365"></a>07365             <span class="comment">/* FIXME: i18n: Need to make this a single string.  */</span>
<a name="l07366"></a>07366             <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot; &quot;</span>, <a class="code" href="main_8c.html#a41a2b997ba5454df787d61f051dd918c">gdb_stdout</a>);
<a name="l07367"></a>07367             <a class="code" href="utils_8c.html#a857540a17ef1cd62fef4a33cc3b6a894">wrap_here</a> (<span class="stringliteral">&quot;&quot;</span>);
<a name="l07368"></a>07368             <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot;and &quot;</span>, <a class="code" href="main_8c.html#a41a2b997ba5454df787d61f051dd918c">gdb_stdout</a>);
<a name="l07369"></a>07369             <a class="code" href="utils_8c.html#a857540a17ef1cd62fef4a33cc3b6a894">wrap_here</a> (<span class="stringliteral">&quot;&quot;</span>);
<a name="l07370"></a>07370             <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;%s...&quot;</span>, pst-&gt;<a class="code" href="structpartial__symtab.html#a0b7bd5bada02a362357552790b111c23">dependencies</a>[i]-&gt;<a class="code" href="structpartial__symtab.html#a6ea70ac87d6dbd541967bdd6dacd7321">filename</a>);
<a name="l07371"></a>07371             <a class="code" href="utils_8c.html#a857540a17ef1cd62fef4a33cc3b6a894">wrap_here</a> (<span class="stringliteral">&quot;&quot;</span>);     <span class="comment">/* Flush output.  */</span>
<a name="l07372"></a>07372             <a class="code" href="ui-file_8c.html#a046f07b5ef1bcc35c28b4be983e39998">gdb_flush</a> (<a class="code" href="main_8c.html#a41a2b997ba5454df787d61f051dd918c">gdb_stdout</a>);
<a name="l07373"></a>07373           }
<a name="l07374"></a>07374         <a class="code" href="dwarf2read_8c.html#a28d3f50615a68b574ce61a8bd85258eb">psymtab_to_symtab_1</a> (pst-&gt;<a class="code" href="structpartial__symtab.html#a0b7bd5bada02a362357552790b111c23">dependencies</a>[i]);
<a name="l07375"></a>07375       }
<a name="l07376"></a>07376 
<a name="l07377"></a>07377   per_cu = pst-&gt;<a class="code" href="structpartial__symtab.html#a1d7dd223683b0ca2baeaa6bf5c3e90a3">read_symtab_private</a>;
<a name="l07378"></a>07378 
<a name="l07379"></a>07379   <span class="keywordflow">if</span> (per_cu == NULL)
<a name="l07380"></a>07380     {
<a name="l07381"></a>07381       <span class="comment">/* It&#39;s an include file, no symbols to read for it.</span>
<a name="l07382"></a>07382 <span class="comment">         Everything is in the parent symtab.  */</span>
<a name="l07383"></a>07383       pst-&gt;<a class="code" href="structpartial__symtab.html#a11d8e59b962db1317c8c23f917dbed42">readin</a> = 1;
<a name="l07384"></a>07384       <span class="keywordflow">return</span>;
<a name="l07385"></a>07385     }
<a name="l07386"></a>07386 
<a name="l07387"></a>07387   <a class="code" href="dwarf2read_8c.html#ad7b59f87ccb0c49dacf808e1053982d8">dw2_do_instantiate_symtab</a> (per_cu);
<a name="l07388"></a>07388 }
<a name="l07389"></a>07389 
<a name="l07390"></a>07390 <span class="comment">/* Trivial hash function for die_info: the hash value of a DIE</span>
<a name="l07391"></a>07391 <span class="comment">   is its offset in .debug_info for this objfile.  */</span>
<a name="l07392"></a>07392 
<a name="l07393"></a>07393 <span class="keyword">static</span> hashval_t
<a name="l07394"></a><a class="code" href="dwarf2read_8c.html#a265b107f617db27d5a264d29218175d7">07394</a> <a class="code" href="dwarf2read_8c.html#a265b107f617db27d5a264d29218175d7">die_hash</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item)
<a name="l07395"></a>07395 {
<a name="l07396"></a>07396   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die = item;
<a name="l07397"></a>07397 
<a name="l07398"></a>07398   <span class="keywordflow">return</span> die-&gt;offset.sect_off;
<a name="l07399"></a>07399 }
<a name="l07400"></a>07400 
<a name="l07401"></a>07401 <span class="comment">/* Trivial comparison function for die_info structures: two DIEs</span>
<a name="l07402"></a>07402 <span class="comment">   are equal if they have the same offset.  */</span>
<a name="l07403"></a>07403 
<a name="l07404"></a>07404 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l07405"></a><a class="code" href="dwarf2read_8c.html#aaff47c3e3a9ffa480689aceb5a696060">07405</a> <a class="code" href="dwarf2read_8c.html#aaff47c3e3a9ffa480689aceb5a696060">die_eq</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item_lhs, <span class="keyword">const</span> <span class="keywordtype">void</span> *item_rhs)
<a name="l07406"></a>07406 {
<a name="l07407"></a>07407   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die_lhs = item_lhs;
<a name="l07408"></a>07408   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die_rhs = item_rhs;
<a name="l07409"></a>07409 
<a name="l07410"></a>07410   <span class="keywordflow">return</span> die_lhs-&gt;offset.sect_off == die_rhs-&gt;offset.sect_off;
<a name="l07411"></a>07411 }
<a name="l07412"></a>07412 
<a name="l07413"></a>07413 <span class="comment">/* die_reader_func for load_full_comp_unit.</span>
<a name="l07414"></a>07414 <span class="comment">   This is identical to read_signatured_type_reader,</span>
<a name="l07415"></a>07415 <span class="comment">   but is kept separate for now.  */</span>
<a name="l07416"></a>07416 
<a name="l07417"></a>07417 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07418"></a><a class="code" href="dwarf2read_8c.html#a93ef371f09f65885c10f9a246248659f">07418</a> <a class="code" href="dwarf2read_8c.html#a93ef371f09f65885c10f9a246248659f">load_full_comp_unit_reader</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l07419"></a>07419                             <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l07420"></a>07420                             <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *comp_unit_die,
<a name="l07421"></a>07421                             <span class="keywordtype">int</span> has_children,
<a name="l07422"></a>07422                             <span class="keywordtype">void</span> *data)
<a name="l07423"></a>07423 {
<a name="l07424"></a>07424   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l07425"></a>07425   <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> *language_ptr = data;
<a name="l07426"></a>07426 
<a name="l07427"></a>07427   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a681ffa0c8fdc7c63efa8fffb2a441f12">die_hash</a> == NULL);
<a name="l07428"></a>07428   cu-&gt;<a class="code" href="structdwarf2__cu.html#a681ffa0c8fdc7c63efa8fffb2a441f12">die_hash</a> =
<a name="l07429"></a>07429     htab_create_alloc_ex (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a> / 12,
<a name="l07430"></a>07430                           <a class="code" href="dwarf2read_8c.html#a265b107f617db27d5a264d29218175d7">die_hash</a>,
<a name="l07431"></a>07431                           <a class="code" href="dwarf2read_8c.html#aaff47c3e3a9ffa480689aceb5a696060">die_eq</a>,
<a name="l07432"></a>07432                           NULL,
<a name="l07433"></a>07433                           &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>,
<a name="l07434"></a>07434                           <a class="code" href="utils_8c.html#a64b0a5e317b6f45f062aa8356111644b">hashtab_obstack_allocate</a>,
<a name="l07435"></a>07435                           <a class="code" href="utils_8c.html#af32d0d55c7c49d59093e66ef695f9513">dummy_obstack_deallocate</a>);
<a name="l07436"></a>07436 
<a name="l07437"></a>07437   <span class="keywordflow">if</span> (has_children)
<a name="l07438"></a>07438     comp_unit_die-&gt;child = <a class="code" href="dwarf2read_8c.html#a79a10115d28e35221fb4b78c2023be76">read_die_and_siblings</a> (reader, info_ptr,
<a name="l07439"></a>07439                                                   &amp;info_ptr, comp_unit_die);
<a name="l07440"></a>07440   cu-&gt;<a class="code" href="structdwarf2__cu.html#abc8aaad6bb3799398e9769f989fd1692">dies</a> = comp_unit_die;
<a name="l07441"></a>07441   <span class="comment">/* comp_unit_die is not stored in die_hash, no need.  */</span>
<a name="l07442"></a>07442 
<a name="l07443"></a>07443   <span class="comment">/* We try not to read any attributes in this function, because not</span>
<a name="l07444"></a>07444 <span class="comment">     all CUs needed for references have been loaded yet, and symbol</span>
<a name="l07445"></a>07445 <span class="comment">     table processing isn&#39;t initialized.  But we have to set the CU language,</span>
<a name="l07446"></a>07446 <span class="comment">     or we won&#39;t be able to build types correctly.</span>
<a name="l07447"></a>07447 <span class="comment">     Similarly, if we do not read the producer, we can not apply</span>
<a name="l07448"></a>07448 <span class="comment">     producer-specific interpretation.  */</span>
<a name="l07449"></a>07449   <a class="code" href="dwarf2read_8c.html#a7a6cb8459a76588ce7ef6a56b19ef5c8">prepare_one_comp_unit</a> (cu, cu-&gt;<a class="code" href="structdwarf2__cu.html#abc8aaad6bb3799398e9769f989fd1692">dies</a>, *language_ptr);
<a name="l07450"></a>07450 }
<a name="l07451"></a>07451 
<a name="l07452"></a>07452 <span class="comment">/* Load the DIEs associated with PER_CU into memory.  */</span>
<a name="l07453"></a>07453 
<a name="l07454"></a>07454 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07455"></a><a class="code" href="dwarf2read_8c.html#a9f845956e1dd14ace7c6471ee8c2b502">07455</a> <a class="code" href="dwarf2read_8c.html#a9f845956e1dd14ace7c6471ee8c2b502">load_full_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu,
<a name="l07456"></a>07456                      <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> pretend_language)
<a name="l07457"></a>07457 {
<a name="l07458"></a>07458   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (! this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l07459"></a>07459 
<a name="l07460"></a>07460   <a class="code" href="dwarf2read_8c.html#a2887b925bcf54483d1c0dc40faefdd08">init_cutu_and_read_dies</a> (this_cu, NULL, 1, 1,
<a name="l07461"></a>07461                            <a class="code" href="dwarf2read_8c.html#a93ef371f09f65885c10f9a246248659f">load_full_comp_unit_reader</a>, &amp;pretend_language);
<a name="l07462"></a>07462 }
<a name="l07463"></a>07463 
<a name="l07464"></a>07464 <span class="comment">/* Add a DIE to the delayed physname list.  */</span>
<a name="l07465"></a>07465 
<a name="l07466"></a>07466 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07467"></a><a class="code" href="dwarf2read_8c.html#ae1004cc797a767d8f6130fab8038ddf7">07467</a> <a class="code" href="dwarf2read_8c.html#ae1004cc797a767d8f6130fab8038ddf7">add_to_method_list</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keywordtype">int</span> fnfield_index, <span class="keywordtype">int</span> index,
<a name="l07468"></a>07468                     <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l07469"></a>07469                     <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l07470"></a>07470 {
<a name="l07471"></a>07471   <span class="keyword">struct </span><a class="code" href="structdelayed__method__info.html">delayed_method_info</a> mi;
<a name="l07472"></a>07472   mi.<a class="code" href="structdelayed__method__info.html#a6d70fe3a74b112301dfc6b8a4f5f908b">type</a> = <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l07473"></a>07473   mi.<a class="code" href="structdelayed__method__info.html#a672fa3d4e9757cbb76ba478c50d13237">fnfield_index</a> = <a class="code" href="structdelayed__method__info.html#a672fa3d4e9757cbb76ba478c50d13237">fnfield_index</a>;
<a name="l07474"></a>07474   mi.<a class="code" href="structdelayed__method__info.html#ab8922c27cd39f06f1b0cc47a40837005">index</a> = <a class="code" href="structdelayed__method__info.html#ab8922c27cd39f06f1b0cc47a40837005">index</a>;
<a name="l07475"></a>07475   mi.<a class="code" href="structdelayed__method__info.html#ae73e61a20e7af5ffe8fc098dd38b2d8e">name</a> = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l07476"></a>07476   mi.<a class="code" href="structdelayed__method__info.html#a14a3fea705611cf9993ed24a45f246bd">die</a> = <a class="code" href="structdelayed__method__info.html#a14a3fea705611cf9993ed24a45f246bd">die</a>;
<a name="l07477"></a>07477   <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structdelayed__method__info.html">delayed_method_info</a>, cu-&gt;method_list, &amp;mi);
<a name="l07478"></a>07478 }
<a name="l07479"></a>07479 
<a name="l07480"></a>07480 <span class="comment">/* A cleanup for freeing the delayed method list.  */</span>
<a name="l07481"></a>07481 
<a name="l07482"></a>07482 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07483"></a><a class="code" href="dwarf2read_8c.html#a87fe2c28bbe514a5db6be8af038a9add">07483</a> <a class="code" href="dwarf2read_8c.html#a87fe2c28bbe514a5db6be8af038a9add">free_delayed_list</a> (<span class="keywordtype">void</span> *ptr)
<a name="l07484"></a>07484 {
<a name="l07485"></a>07485   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = (<span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *) ptr;
<a name="l07486"></a>07486   <span class="keywordflow">if</span> (cu-&gt;method_list != NULL)
<a name="l07487"></a>07487     {
<a name="l07488"></a>07488       <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structdelayed__method__info.html">delayed_method_info</a>, cu-&gt;method_list);
<a name="l07489"></a>07489       cu-&gt;method_list = NULL;
<a name="l07490"></a>07490     }
<a name="l07491"></a>07491 }
<a name="l07492"></a>07492 
<a name="l07493"></a>07493 <span class="comment">/* Compute the physnames of any methods on the CU&#39;s method list.</span>
<a name="l07494"></a>07494 <span class="comment"></span>
<a name="l07495"></a>07495 <span class="comment">   The computation of method physnames is delayed in order to avoid the</span>
<a name="l07496"></a>07496 <span class="comment">   (bad) condition that one of the method&#39;s formal parameters is of an as yet</span>
<a name="l07497"></a>07497 <span class="comment">   incomplete type.  */</span>
<a name="l07498"></a>07498 
<a name="l07499"></a>07499 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07500"></a><a class="code" href="dwarf2read_8c.html#a0a03c5f55a8737864c90b91d8036eac6">07500</a> <a class="code" href="dwarf2read_8c.html#a0a03c5f55a8737864c90b91d8036eac6">compute_delayed_physnames</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l07501"></a>07501 {
<a name="l07502"></a>07502   <span class="keywordtype">int</span> i;
<a name="l07503"></a>07503   <span class="keyword">struct </span><a class="code" href="structdelayed__method__info.html">delayed_method_info</a> *mi;
<a name="l07504"></a>07504   <span class="keywordflow">for</span> (i = 0; <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="structdelayed__method__info.html">delayed_method_info</a>, cu-&gt;method_list, i, mi) ; ++i)
<a name="l07505"></a>07505     {
<a name="l07506"></a>07506       <span class="keyword">const</span> <span class="keywordtype">char</span> *physname;
<a name="l07507"></a>07507       <span class="keyword">struct </span>fn_fieldlist *fn_flp
<a name="l07508"></a>07508         = &amp;<a class="code" href="gdbtypes_8h.html#a1b38036dfbb2c6f7550104b7cde4b1b1">TYPE_FN_FIELDLIST</a> (mi-&gt;<a class="code" href="structdelayed__method__info.html#a6d70fe3a74b112301dfc6b8a4f5f908b">type</a>, mi-&gt;<a class="code" href="structdelayed__method__info.html#a672fa3d4e9757cbb76ba478c50d13237">fnfield_index</a>);
<a name="l07509"></a>07509       physname = <a class="code" href="dwarf2read_8c.html#a94813a9fc414b7ba920cdcee76b34d36">dwarf2_physname</a> (mi-&gt;<a class="code" href="structdelayed__method__info.html#ae73e61a20e7af5ffe8fc098dd38b2d8e">name</a>, mi-&gt;<a class="code" href="structdelayed__method__info.html#a14a3fea705611cf9993ed24a45f246bd">die</a>, cu);
<a name="l07510"></a>07510       fn_flp-&gt;fn_fields[mi-&gt;<a class="code" href="structdelayed__method__info.html#ab8922c27cd39f06f1b0cc47a40837005">index</a>].physname = physname ? physname : <span class="stringliteral">&quot;&quot;</span>;
<a name="l07511"></a>07511     }
<a name="l07512"></a>07512 }
<a name="l07513"></a>07513 
<a name="l07514"></a>07514 <span class="comment">/* Go objects should be embedded in a DW_TAG_module DIE,</span>
<a name="l07515"></a>07515 <span class="comment">   and it&#39;s not clear if/how imported objects will appear.</span>
<a name="l07516"></a>07516 <span class="comment">   To keep Go support simple until that&#39;s worked out,</span>
<a name="l07517"></a>07517 <span class="comment">   go back through what we&#39;ve read and create something usable.</span>
<a name="l07518"></a>07518 <span class="comment">   We could do this while processing each DIE, and feels kinda cleaner,</span>
<a name="l07519"></a>07519 <span class="comment">   but that way is more invasive.</span>
<a name="l07520"></a>07520 <span class="comment">   This is to, for example, allow the user to type &quot;p var&quot; or &quot;b main&quot;</span>
<a name="l07521"></a>07521 <span class="comment">   without having to specify the package name, and allow lookups</span>
<a name="l07522"></a>07522 <span class="comment">   of module.object to work in contexts that use the expression</span>
<a name="l07523"></a>07523 <span class="comment">   parser.  */</span>
<a name="l07524"></a>07524 
<a name="l07525"></a>07525 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07526"></a><a class="code" href="dwarf2read_8c.html#a429b792665b06019c4a75d0fe7a1b5a2">07526</a> <a class="code" href="dwarf2read_8c.html#a429b792665b06019c4a75d0fe7a1b5a2">fixup_go_packaging</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l07527"></a>07527 {
<a name="l07528"></a>07528   <span class="keywordtype">char</span> *package_name = NULL;
<a name="l07529"></a>07529   <span class="keyword">struct </span><a class="code" href="structpending.html">pending</a> *list;
<a name="l07530"></a>07530   <span class="keywordtype">int</span> i;
<a name="l07531"></a>07531 
<a name="l07532"></a>07532   <span class="keywordflow">for</span> (list = <a class="code" href="buildsym_8h.html#a759a37cb08a814d2400a8241ce11387d">global_symbols</a>; list != NULL; list = list-&gt;<a class="code" href="structpending.html#aeaf41f56ecf48623bbf2ed11acb5baf8">next</a>)
<a name="l07533"></a>07533     {
<a name="l07534"></a>07534       <span class="keywordflow">for</span> (i = 0; i &lt; list-&gt;<a class="code" href="structpending.html#a1f89b726a8d3924c26ae5fd9dcd6553c">nsyms</a>; ++i)
<a name="l07535"></a>07535         {
<a name="l07536"></a>07536           <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym = list-&gt;<a class="code" href="structpending.html#a28546830406173d2953af26ff13d416b">symbol</a>[i];
<a name="l07537"></a>07537 
<a name="l07538"></a>07538           <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a82fc22e60b1007c826a5ebf7d6593e78">SYMBOL_LANGUAGE</a> (sym) == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a702bd2253975155cace46837f64a702a">language_go</a>
<a name="l07539"></a>07539               &amp;&amp; <a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>)
<a name="l07540"></a>07540             {
<a name="l07541"></a>07541               <span class="keywordtype">char</span> *this_package_name = <a class="code" href="go-lang_8c.html#afb96762a454f135b93f4facfe01c0890">go_symbol_package_name</a> (sym);
<a name="l07542"></a>07542 
<a name="l07543"></a>07543               <span class="keywordflow">if</span> (this_package_name == NULL)
<a name="l07544"></a>07544                 <span class="keywordflow">continue</span>;
<a name="l07545"></a>07545               <span class="keywordflow">if</span> (package_name == NULL)
<a name="l07546"></a>07546                 package_name = this_package_name;
<a name="l07547"></a>07547               <span class="keywordflow">else</span>
<a name="l07548"></a>07548                 {
<a name="l07549"></a>07549                   <span class="keywordflow">if</span> (strcmp (package_name, this_package_name) != 0)
<a name="l07550"></a>07550                     <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l07551"></a>07551                                <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Symtab %s has objects from two different Go packages: %s and %s&quot;</span>),
<a name="l07552"></a>07552                                (<a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (sym)
<a name="l07553"></a>07553                           ? <a class="code" href="source_8c.html#ae251616cab166301d5fed95cbdd31232">symtab_to_filename_for_display</a> (<a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (sym))
<a name="l07554"></a>07554                                 : <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>)),
<a name="l07555"></a>07555                                this_package_name, package_name);
<a name="l07556"></a>07556                   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (this_package_name);
<a name="l07557"></a>07557                 }
<a name="l07558"></a>07558             }
<a name="l07559"></a>07559         }
<a name="l07560"></a>07560     }
<a name="l07561"></a>07561 
<a name="l07562"></a>07562   <span class="keywordflow">if</span> (package_name != NULL)
<a name="l07563"></a>07563     {
<a name="l07564"></a>07564       <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l07565"></a>07565       <span class="keyword">const</span> <span class="keywordtype">char</span> *saved_package_name = obstack_copy0 (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l07566"></a>07566                                                       package_name,
<a name="l07567"></a>07567                                                       strlen (package_name));
<a name="l07568"></a>07568       <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = <a class="code" href="gdbtypes_8c.html#ac74c6d3def8258efc09a3deb8f395d64">init_type</a> (<a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a3da7187b0222a7bd83581aff68c8cd63">TYPE_CODE_MODULE</a>, 0, 0,
<a name="l07569"></a>07569                                      saved_package_name, objfile);
<a name="l07570"></a>07570       <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l07571"></a>07571 
<a name="l07572"></a>07572       <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) = <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type);
<a name="l07573"></a>07573 
<a name="l07574"></a>07574       sym = <a class="code" href="symtab_8c.html#a6a7a23ba37378ec001ecd461c5137b83">allocate_symbol</a> (objfile);
<a name="l07575"></a>07575       <a class="code" href="symtab_8h.html#add78e67f78de1edd9f8aa220f11bfd89">SYMBOL_SET_LANGUAGE</a> (sym, <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a702bd2253975155cace46837f64a702a">language_go</a>, &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>);
<a name="l07576"></a>07576       <a class="code" href="symtab_8h.html#a1f31078ca0e1d9517eb48e71fe7d53f9">SYMBOL_SET_NAMES</a> (sym, saved_package_name,
<a name="l07577"></a>07577                         strlen (saved_package_name), 0, objfile);
<a name="l07578"></a>07578       <span class="comment">/* This is not VAR_DOMAIN because we want a way to ensure a lookup of,</span>
<a name="l07579"></a>07579 <span class="comment">         e.g., &quot;main&quot; finds the &quot;main&quot; module and not C&#39;s main().  */</span>
<a name="l07580"></a>07580       <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym) = <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa1f05a16e681efd2e892974878c353f11">STRUCT_DOMAIN</a>;
<a name="l07581"></a>07581       <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>;
<a name="l07582"></a>07582       <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym) = <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l07583"></a>07583 
<a name="l07584"></a>07584       <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, &amp;<a class="code" href="buildsym_8h.html#a759a37cb08a814d2400a8241ce11387d">global_symbols</a>);
<a name="l07585"></a>07585 
<a name="l07586"></a>07586       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (package_name);
<a name="l07587"></a>07587     }
<a name="l07588"></a>07588 }
<a name="l07589"></a>07589 
<a name="l07590"></a>07590 <span class="comment">/* Return the symtab for PER_CU.  This works properly regardless of</span>
<a name="l07591"></a>07591 <span class="comment">   whether we&#39;re using the index or psymtabs.  */</span>
<a name="l07592"></a>07592 
<a name="l07593"></a>07593 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *
<a name="l07594"></a><a class="code" href="dwarf2read_8c.html#acd8b98301c771b10a05a97e2c16c6b92">07594</a> <a class="code" href="dwarf2read_8c.html#acd8b98301c771b10a05a97e2c16c6b92">get_symtab</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l07595"></a>07595 {
<a name="l07596"></a>07596   <span class="keywordflow">return</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a>
<a name="l07597"></a>07597           ? per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a>
<a name="l07598"></a>07598           : per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a>-&gt;<a class="code" href="structpartial__symtab.html#a1bbcf18c88d09005b43f960b6f3575f8">symtab</a>);
<a name="l07599"></a>07599 }
<a name="l07600"></a>07600 
<a name="l07601"></a>07601 <span class="comment">/* A helper function for computing the list of all symbol tables</span>
<a name="l07602"></a>07602 <span class="comment">   included by PER_CU.  */</span>
<a name="l07603"></a>07603 
<a name="l07604"></a>07604 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07605"></a><a class="code" href="dwarf2read_8c.html#aa50121c5ef678736139af0e3eccfc12d">07605</a> <a class="code" href="dwarf2read_8c.html#aa50121c5ef678736139af0e3eccfc12d">recursively_compute_inclusions</a> (<a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) **result,
<a name="l07606"></a>07606                                 htab_t all_children, htab_t all_type_symtabs,
<a name="l07607"></a>07607                                 <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu,
<a name="l07608"></a>07608                                 <span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *immediate_parent)
<a name="l07609"></a>07609 {
<a name="l07610"></a>07610   <span class="keywordtype">void</span> **slot;
<a name="l07611"></a>07611   <span class="keywordtype">int</span> ix;
<a name="l07612"></a>07612   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structsymtab.html">symtab</a>;
<a name="l07613"></a>07613   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *iter;
<a name="l07614"></a>07614 
<a name="l07615"></a>07615   slot = htab_find_slot (all_children, per_cu, INSERT);
<a name="l07616"></a>07616   <span class="keywordflow">if</span> (*slot != NULL)
<a name="l07617"></a>07617     {
<a name="l07618"></a>07618       <span class="comment">/* This inclusion and its children have been processed.  */</span>
<a name="l07619"></a>07619       <span class="keywordflow">return</span>;
<a name="l07620"></a>07620     }
<a name="l07621"></a>07621 
<a name="l07622"></a>07622   *slot = per_cu;
<a name="l07623"></a>07623   <span class="comment">/* Only add a CU if it has a symbol table.  */</span>
<a name="l07624"></a>07624   symtab = <a class="code" href="dwarf2read_8c.html#acd8b98301c771b10a05a97e2c16c6b92">get_symtab</a> (per_cu);
<a name="l07625"></a>07625   <span class="keywordflow">if</span> (symtab != NULL)
<a name="l07626"></a>07626     {
<a name="l07627"></a>07627       <span class="comment">/* If this is a type unit only add its symbol table if we haven&#39;t</span>
<a name="l07628"></a>07628 <span class="comment">         seen it yet (type unit per_cu&#39;s can share symtabs).  */</span>
<a name="l07629"></a>07629       <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l07630"></a>07630         {
<a name="l07631"></a>07631           slot = htab_find_slot (all_type_symtabs, symtab, INSERT);
<a name="l07632"></a>07632           <span class="keywordflow">if</span> (*slot == NULL)
<a name="l07633"></a>07633             {
<a name="l07634"></a>07634               *slot = symtab;
<a name="l07635"></a>07635               <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, *result, symtab);
<a name="l07636"></a>07636               <span class="keywordflow">if</span> (symtab-&gt;<a class="code" href="structsymtab.html#afaa298de7ccad5e7cb79ecbacbdedfbd">user</a> == NULL)
<a name="l07637"></a>07637                 symtab-&gt;<a class="code" href="structsymtab.html#afaa298de7ccad5e7cb79ecbacbdedfbd">user</a> = immediate_parent;
<a name="l07638"></a>07638             }
<a name="l07639"></a>07639         }
<a name="l07640"></a>07640       <span class="keywordflow">else</span>
<a name="l07641"></a>07641         {
<a name="l07642"></a>07642           <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, *result, symtab);
<a name="l07643"></a>07643           <span class="keywordflow">if</span> (symtab-&gt;<a class="code" href="structsymtab.html#afaa298de7ccad5e7cb79ecbacbdedfbd">user</a> == NULL)
<a name="l07644"></a>07644             symtab-&gt;<a class="code" href="structsymtab.html#afaa298de7ccad5e7cb79ecbacbdedfbd">user</a> = immediate_parent;
<a name="l07645"></a>07645         }
<a name="l07646"></a>07646     }
<a name="l07647"></a>07647 
<a name="l07648"></a>07648   <span class="keywordflow">for</span> (ix = 0;
<a name="l07649"></a>07649        <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (dwarf2_per_cu_ptr, per_cu-&gt;imported_symtabs, ix, iter);
<a name="l07650"></a>07650        ++ix)
<a name="l07651"></a>07651     {
<a name="l07652"></a>07652       <a class="code" href="dwarf2read_8c.html#aa50121c5ef678736139af0e3eccfc12d">recursively_compute_inclusions</a> (result, all_children,
<a name="l07653"></a>07653                                       all_type_symtabs, iter, symtab);
<a name="l07654"></a>07654     }
<a name="l07655"></a>07655 }
<a name="l07656"></a>07656 
<a name="l07657"></a>07657 <span class="comment">/* Compute the symtab &#39;includes&#39; fields for the symtab related to</span>
<a name="l07658"></a>07658 <span class="comment">   PER_CU.  */</span>
<a name="l07659"></a>07659 
<a name="l07660"></a>07660 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07661"></a><a class="code" href="dwarf2read_8c.html#a4339f4125a7859e90d9acf15028fce68">07661</a> <a class="code" href="dwarf2read_8c.html#a4339f4125a7859e90d9acf15028fce68">compute_symtab_includes</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l07662"></a>07662 {
<a name="l07663"></a>07663   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (! per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l07664"></a>07664 
<a name="l07665"></a>07665   <span class="keywordflow">if</span> (!<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (dwarf2_per_cu_ptr, per_cu-&gt;imported_symtabs))
<a name="l07666"></a>07666     {
<a name="l07667"></a>07667       <span class="keywordtype">int</span> ix, <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l07668"></a>07668       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu_iter;
<a name="l07669"></a>07669       <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *symtab_iter;
<a name="l07670"></a>07670       <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) *result_symtabs = NULL;
<a name="l07671"></a>07671       htab_t all_children, all_type_symtabs;
<a name="l07672"></a>07672       <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structsymtab.html">symtab</a> = <a class="code" href="dwarf2read_8c.html#acd8b98301c771b10a05a97e2c16c6b92">get_symtab</a> (per_cu);
<a name="l07673"></a>07673 
<a name="l07674"></a>07674       <span class="comment">/* If we don&#39;t have a symtab, we can just skip this case.  */</span>
<a name="l07675"></a>07675       <span class="keywordflow">if</span> (symtab == NULL)
<a name="l07676"></a>07676         <span class="keywordflow">return</span>;
<a name="l07677"></a>07677 
<a name="l07678"></a>07678       all_children = htab_create_alloc (1, htab_hash_pointer, htab_eq_pointer,
<a name="l07679"></a>07679                                         NULL, <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a>, <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>);
<a name="l07680"></a>07680       all_type_symtabs = htab_create_alloc (1, htab_hash_pointer, htab_eq_pointer,
<a name="l07681"></a>07681                                             NULL, <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a>, <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>);
<a name="l07682"></a>07682 
<a name="l07683"></a>07683       <span class="keywordflow">for</span> (ix = 0;
<a name="l07684"></a>07684            <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (dwarf2_per_cu_ptr, per_cu-&gt;imported_symtabs,
<a name="l07685"></a>07685                         ix, per_cu_iter);
<a name="l07686"></a>07686            ++ix)
<a name="l07687"></a>07687         {
<a name="l07688"></a>07688           <a class="code" href="dwarf2read_8c.html#aa50121c5ef678736139af0e3eccfc12d">recursively_compute_inclusions</a> (&amp;result_symtabs, all_children,
<a name="l07689"></a>07689                                           all_type_symtabs, per_cu_iter,
<a name="l07690"></a>07690                                           symtab);
<a name="l07691"></a>07691         }
<a name="l07692"></a>07692 
<a name="l07693"></a>07693       <span class="comment">/* Now we have a transitive closure of all the included symtabs.  */</span>
<a name="l07694"></a>07694       len = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, result_symtabs);
<a name="l07695"></a>07695       symtab-&gt;<a class="code" href="structsymtab.html#aa9169868cbd3de0e738746827b532f16">includes</a>
<a name="l07696"></a>07696         = obstack_alloc (&amp;dwarf2_per_objfile-&gt;objfile-&gt;objfile_obstack,
<a name="l07697"></a>07697                          (len + 1) * sizeof (<span class="keyword">struct</span> symtab *));
<a name="l07698"></a>07698       <span class="keywordflow">for</span> (ix = 0;
<a name="l07699"></a>07699            <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, result_symtabs, ix, symtab_iter);
<a name="l07700"></a>07700            ++ix)
<a name="l07701"></a>07701         symtab-&gt;<a class="code" href="structsymtab.html#aa9169868cbd3de0e738746827b532f16">includes</a>[ix] = symtab_iter;
<a name="l07702"></a>07702       symtab-&gt;<a class="code" href="structsymtab.html#aa9169868cbd3de0e738746827b532f16">includes</a>[len] = NULL;
<a name="l07703"></a>07703 
<a name="l07704"></a>07704       <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, result_symtabs);
<a name="l07705"></a>07705       htab_delete (all_children);
<a name="l07706"></a>07706       htab_delete (all_type_symtabs);
<a name="l07707"></a>07707     }
<a name="l07708"></a>07708 }
<a name="l07709"></a>07709 
<a name="l07710"></a>07710 <span class="comment">/* Compute the &#39;includes&#39; field for the symtabs of all the CUs we just</span>
<a name="l07711"></a>07711 <span class="comment">   read.  */</span>
<a name="l07712"></a>07712 
<a name="l07713"></a>07713 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07714"></a><a class="code" href="dwarf2read_8c.html#a15521f267ec507aa6fbf4e80df678078">07714</a> <a class="code" href="dwarf2read_8c.html#a15521f267ec507aa6fbf4e80df678078">process_cu_includes</a> (<span class="keywordtype">void</span>)
<a name="l07715"></a>07715 {
<a name="l07716"></a>07716   <span class="keywordtype">int</span> ix;
<a name="l07717"></a>07717   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *iter;
<a name="l07718"></a>07718 
<a name="l07719"></a>07719   <span class="keywordflow">for</span> (ix = 0;
<a name="l07720"></a>07720        <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (dwarf2_per_cu_ptr, dwarf2_per_objfile-&gt;just_read_cus,
<a name="l07721"></a>07721                     ix, iter);
<a name="l07722"></a>07722        ++ix)
<a name="l07723"></a>07723     {
<a name="l07724"></a>07724       <span class="keywordflow">if</span> (! iter-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l07725"></a>07725         <a class="code" href="dwarf2read_8c.html#a4339f4125a7859e90d9acf15028fce68">compute_symtab_includes</a> (iter);
<a name="l07726"></a>07726     }
<a name="l07727"></a>07727 
<a name="l07728"></a>07728   <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (dwarf2_per_cu_ptr, dwarf2_per_objfile-&gt;just_read_cus);
<a name="l07729"></a>07729 }
<a name="l07730"></a>07730 
<a name="l07731"></a>07731 <span class="comment">/* Generate full symbol information for PER_CU, whose DIEs have</span>
<a name="l07732"></a>07732 <span class="comment">   already been loaded into memory.  */</span>
<a name="l07733"></a>07733 
<a name="l07734"></a>07734 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07735"></a><a class="code" href="dwarf2read_8c.html#a4a43e61549842b0ddfc5d3fd23202e93">07735</a> <a class="code" href="dwarf2read_8c.html#a4a43e61549842b0ddfc5d3fd23202e93">process_full_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu,
<a name="l07736"></a>07736                         <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> pretend_language)
<a name="l07737"></a>07737 {
<a name="l07738"></a>07738   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>;
<a name="l07739"></a>07739   <span class="keyword">struct </span>objfile *objfile = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>;
<a name="l07740"></a>07740   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> lowpc, highpc;
<a name="l07741"></a>07741   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structsymtab.html">symtab</a>;
<a name="l07742"></a>07742   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to, *delayed_list_cleanup;
<a name="l07743"></a>07743   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> baseaddr;
<a name="l07744"></a>07744   <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *static_block;
<a name="l07745"></a>07745 
<a name="l07746"></a>07746   baseaddr = <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>, <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l07747"></a>07747 
<a name="l07748"></a>07748   <a class="code" href="buildsym_8c.html#a9dd2d1932fd59b8b98b4a64a3ef2bc1b">buildsym_init</a> ();
<a name="l07749"></a>07749   back_to = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="buildsym_8c.html#aba165f59cc70bc692a387de124302be7">really_free_pendings</a>, NULL);
<a name="l07750"></a>07750   delayed_list_cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#a87fe2c28bbe514a5db6be8af038a9add">free_delayed_list</a>, cu);
<a name="l07751"></a>07751 
<a name="l07752"></a>07752   cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a> = &amp;<a class="code" href="buildsym_8h.html#a2d83ed7f7eeffeffeb2e00320573fd0d">file_symbols</a>;
<a name="l07753"></a>07753 
<a name="l07754"></a>07754   cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = pretend_language;
<a name="l07755"></a>07755   cu-&gt;<a class="code" href="structdwarf2__cu.html#aa12f3aeef950b4457378c14f9ba16f12">language_defn</a> = <a class="code" href="language_8c.html#adba6bd079cb2f1df763354ec97abe0cd">language_def</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>);
<a name="l07756"></a>07756 
<a name="l07757"></a>07757   <span class="comment">/* Do line number decoding in read_file_scope () */</span>
<a name="l07758"></a>07758   <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#abc8aaad6bb3799398e9769f989fd1692">dies</a>, cu);
<a name="l07759"></a>07759 
<a name="l07760"></a>07760   <span class="comment">/* For now fudge the Go package.  */</span>
<a name="l07761"></a>07761   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a702bd2253975155cace46837f64a702a">language_go</a>)
<a name="l07762"></a>07762     <a class="code" href="dwarf2read_8c.html#a429b792665b06019c4a75d0fe7a1b5a2">fixup_go_packaging</a> (cu);
<a name="l07763"></a>07763 
<a name="l07764"></a>07764   <span class="comment">/* Now that we have processed all the DIEs in the CU, all the types </span>
<a name="l07765"></a>07765 <span class="comment">     should be complete, and it should now be safe to compute all of the</span>
<a name="l07766"></a>07766 <span class="comment">     physnames.  */</span>
<a name="l07767"></a>07767   <a class="code" href="dwarf2read_8c.html#a0a03c5f55a8737864c90b91d8036eac6">compute_delayed_physnames</a> (cu);
<a name="l07768"></a>07768   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (delayed_list_cleanup);
<a name="l07769"></a>07769 
<a name="l07770"></a>07770   <span class="comment">/* Some compilers don&#39;t define a DW_AT_high_pc attribute for the</span>
<a name="l07771"></a>07771 <span class="comment">     compilation unit.  If the DW_AT_high_pc is missing, synthesize</span>
<a name="l07772"></a>07772 <span class="comment">     it, by scanning the DIE&#39;s below the compilation unit.  */</span>
<a name="l07773"></a>07773   <a class="code" href="dwarf2read_8c.html#aa7a89cfc9f4650dde9ef152c70edbe41">get_scope_pc_bounds</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#abc8aaad6bb3799398e9769f989fd1692">dies</a>, &amp;lowpc, &amp;highpc, cu);
<a name="l07774"></a>07774 
<a name="l07775"></a>07775   static_block
<a name="l07776"></a>07776     = <a class="code" href="buildsym_8c.html#af2c727c573fce39eeb2144d1a2d083dc">end_symtab_get_static_block</a> (highpc + baseaddr, objfile, 0, 1);
<a name="l07777"></a>07777 
<a name="l07778"></a>07778   <span class="comment">/* If the comp unit has DW_AT_ranges, it may have discontiguous ranges.</span>
<a name="l07779"></a>07779 <span class="comment">     Also, DW_AT_ranges may record ranges not belonging to any child DIEs</span>
<a name="l07780"></a>07780 <span class="comment">     (such as virtual method tables).  Record the ranges in STATIC_BLOCK&#39;s</span>
<a name="l07781"></a>07781 <span class="comment">     addrmap to help ensure it has an accurate map of pc values belonging to</span>
<a name="l07782"></a>07782 <span class="comment">     this comp unit.  */</span>
<a name="l07783"></a>07783   <a class="code" href="dwarf2read_8c.html#af80555d650cbaf81ef765d24905e9d3a">dwarf2_record_block_ranges</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#abc8aaad6bb3799398e9769f989fd1692">dies</a>, static_block, baseaddr, cu);
<a name="l07784"></a>07784 
<a name="l07785"></a>07785   symtab = <a class="code" href="buildsym_8c.html#abe17bf95c339606c59c0abf0a9a8a698">end_symtab_from_static_block</a> (static_block, objfile,
<a name="l07786"></a>07786                                          <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile), 0);
<a name="l07787"></a>07787 
<a name="l07788"></a>07788   <span class="keywordflow">if</span> (symtab != NULL)
<a name="l07789"></a>07789     {
<a name="l07790"></a>07790       <span class="keywordtype">int</span> gcc_4_minor = <a class="code" href="utils_8c.html#aa5c0b01e8d6f2ddbbb358db4f12b9d99">producer_is_gcc_ge_4</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>);
<a name="l07791"></a>07791 
<a name="l07792"></a>07792       <span class="comment">/* Set symtab language to language from DW_AT_language.  If the</span>
<a name="l07793"></a>07793 <span class="comment">         compilation is from a C file generated by language preprocessors, do</span>
<a name="l07794"></a>07794 <span class="comment">         not set the language if it was already deduced by start_subfile.  */</span>
<a name="l07795"></a>07795       <span class="keywordflow">if</span> (!(cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202ad300f80a4c96edb04defba2280620a49">language_c</a> &amp;&amp; symtab-&gt;<a class="code" href="structsymtab.html#a26ff640a27ab8781d9e09231bd173e6c">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202ad300f80a4c96edb04defba2280620a49">language_c</a>))
<a name="l07796"></a>07796         symtab-&gt;<a class="code" href="structsymtab.html#a26ff640a27ab8781d9e09231bd173e6c">language</a> = cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>;
<a name="l07797"></a>07797 
<a name="l07798"></a>07798       <span class="comment">/* GCC-4.0 has started to support -fvar-tracking.  GCC-3.x still can</span>
<a name="l07799"></a>07799 <span class="comment">         produce DW_AT_location with location lists but it can be possibly</span>
<a name="l07800"></a>07800 <span class="comment">         invalid without -fvar-tracking.  Still up to GCC-4.4.x incl. 4.4.0</span>
<a name="l07801"></a>07801 <span class="comment">         there were bugs in prologue debug info, fixed later in GCC-4.5</span>
<a name="l07802"></a>07802 <span class="comment">         by &quot;unwind info for epilogues&quot; patch (which is not directly related).</span>
<a name="l07803"></a>07803 <span class="comment"></span>
<a name="l07804"></a>07804 <span class="comment">         For -gdwarf-4 type units LOCATIONS_VALID indication is fortunately not</span>
<a name="l07805"></a>07805 <span class="comment">         needed, it would be wrong due to missing DW_AT_producer there.</span>
<a name="l07806"></a>07806 <span class="comment"></span>
<a name="l07807"></a>07807 <span class="comment">         Still one can confuse GDB by using non-standard GCC compilation</span>
<a name="l07808"></a>07808 <span class="comment">         options - this waits on GCC PR other/32998 (-frecord-gcc-switches).</span>
<a name="l07809"></a>07809 <span class="comment">         */</span> 
<a name="l07810"></a>07810       <span class="keywordflow">if</span> (cu-&gt;has_loclist &amp;&amp; gcc_4_minor &gt;= 5)
<a name="l07811"></a>07811         symtab-&gt;<a class="code" href="structsymtab.html#abaa992ea12cfef6da23556fe4ea15c9c">locations_valid</a> = 1;
<a name="l07812"></a>07812 
<a name="l07813"></a>07813       <span class="keywordflow">if</span> (gcc_4_minor &gt;= 5)
<a name="l07814"></a>07814         symtab-&gt;<a class="code" href="structsymtab.html#a8ec559e611fa9fce466599fc4a9df09b">epilogue_unwind_valid</a> = 1;
<a name="l07815"></a>07815 
<a name="l07816"></a>07816       symtab-&gt;<a class="code" href="structsymtab.html#a8a1be4e992293bfe7adf9e8c1dafb03b">call_site_htab</a> = cu-&gt;call_site_htab;
<a name="l07817"></a>07817     }
<a name="l07818"></a>07818 
<a name="l07819"></a>07819   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a>)
<a name="l07820"></a>07820     per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a> = symtab;
<a name="l07821"></a>07821   <span class="keywordflow">else</span>
<a name="l07822"></a>07822     {
<a name="l07823"></a>07823       <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a>;
<a name="l07824"></a>07824       pst-&gt;<a class="code" href="structpartial__symtab.html#a1bbcf18c88d09005b43f960b6f3575f8">symtab</a> = <a class="code" href="structpartial__symtab.html#a1bbcf18c88d09005b43f960b6f3575f8">symtab</a>;
<a name="l07825"></a>07825       pst-&gt;<a class="code" href="structpartial__symtab.html#a11d8e59b962db1317c8c23f917dbed42">readin</a> = 1;
<a name="l07826"></a>07826     }
<a name="l07827"></a>07827 
<a name="l07828"></a>07828   <span class="comment">/* Push it for inclusion processing later.  */</span>
<a name="l07829"></a>07829   <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (dwarf2_per_cu_ptr, dwarf2_per_objfile-&gt;just_read_cus, per_cu);
<a name="l07830"></a>07830 
<a name="l07831"></a>07831   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l07832"></a>07832 }
<a name="l07833"></a>07833 
<a name="l07834"></a>07834 <span class="comment">/* Generate full symbol information for type unit PER_CU, whose DIEs have</span>
<a name="l07835"></a>07835 <span class="comment">   already been loaded into memory.  */</span>
<a name="l07836"></a>07836 
<a name="l07837"></a>07837 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07838"></a><a class="code" href="dwarf2read_8c.html#a9b0c1ef101c10aac5bb5648a03b48d14">07838</a> <a class="code" href="dwarf2read_8c.html#a9b0c1ef101c10aac5bb5648a03b48d14">process_full_type_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu,
<a name="l07839"></a>07839                         <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> pretend_language)
<a name="l07840"></a>07840 {
<a name="l07841"></a>07841   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>;
<a name="l07842"></a>07842   <span class="keyword">struct </span>objfile *objfile = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>;
<a name="l07843"></a>07843   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structsymtab.html">symtab</a>;
<a name="l07844"></a>07844   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to, *delayed_list_cleanup;
<a name="l07845"></a>07845   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type;
<a name="l07846"></a>07846 
<a name="l07847"></a>07847   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l07848"></a>07848   sig_type = (<span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *) per_cu;
<a name="l07849"></a>07849 
<a name="l07850"></a>07850   <a class="code" href="buildsym_8c.html#a9dd2d1932fd59b8b98b4a64a3ef2bc1b">buildsym_init</a> ();
<a name="l07851"></a>07851   back_to = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="buildsym_8c.html#aba165f59cc70bc692a387de124302be7">really_free_pendings</a>, NULL);
<a name="l07852"></a>07852   delayed_list_cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#a87fe2c28bbe514a5db6be8af038a9add">free_delayed_list</a>, cu);
<a name="l07853"></a>07853 
<a name="l07854"></a>07854   cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a> = &amp;<a class="code" href="buildsym_8h.html#a2d83ed7f7eeffeffeb2e00320573fd0d">file_symbols</a>;
<a name="l07855"></a>07855 
<a name="l07856"></a>07856   cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = pretend_language;
<a name="l07857"></a>07857   cu-&gt;<a class="code" href="structdwarf2__cu.html#aa12f3aeef950b4457378c14f9ba16f12">language_defn</a> = <a class="code" href="language_8c.html#adba6bd079cb2f1df763354ec97abe0cd">language_def</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>);
<a name="l07858"></a>07858 
<a name="l07859"></a>07859   <span class="comment">/* The symbol tables are set up in read_type_unit_scope.  */</span>
<a name="l07860"></a>07860   <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#abc8aaad6bb3799398e9769f989fd1692">dies</a>, cu);
<a name="l07861"></a>07861 
<a name="l07862"></a>07862   <span class="comment">/* For now fudge the Go package.  */</span>
<a name="l07863"></a>07863   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a702bd2253975155cace46837f64a702a">language_go</a>)
<a name="l07864"></a>07864     <a class="code" href="dwarf2read_8c.html#a429b792665b06019c4a75d0fe7a1b5a2">fixup_go_packaging</a> (cu);
<a name="l07865"></a>07865 
<a name="l07866"></a>07866   <span class="comment">/* Now that we have processed all the DIEs in the CU, all the types </span>
<a name="l07867"></a>07867 <span class="comment">     should be complete, and it should now be safe to compute all of the</span>
<a name="l07868"></a>07868 <span class="comment">     physnames.  */</span>
<a name="l07869"></a>07869   <a class="code" href="dwarf2read_8c.html#a0a03c5f55a8737864c90b91d8036eac6">compute_delayed_physnames</a> (cu);
<a name="l07870"></a>07870   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (delayed_list_cleanup);
<a name="l07871"></a>07871 
<a name="l07872"></a>07872   <span class="comment">/* TUs share symbol tables.</span>
<a name="l07873"></a>07873 <span class="comment">     If this is the first TU to use this symtab, complete the construction</span>
<a name="l07874"></a>07874 <span class="comment">     of it with end_expandable_symtab.  Otherwise, complete the addition of</span>
<a name="l07875"></a>07875 <span class="comment">     this TU&#39;s symbols to the existing symtab.  */</span>
<a name="l07876"></a>07876   <span class="keywordflow">if</span> (sig_type-&gt;<a class="code" href="structsignatured__type.html#ab10f6f2df0f7691aa8ca948e28cbcf1e">type_unit_group</a>-&gt;primary_symtab == NULL)
<a name="l07877"></a>07877     {
<a name="l07878"></a>07878       symtab = <a class="code" href="buildsym_8c.html#af78145d5c28d1b9f1a9960e62db816a7">end_expandable_symtab</a> (0, objfile, <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l07879"></a>07879       sig_type-&gt;<a class="code" href="structsignatured__type.html#ab10f6f2df0f7691aa8ca948e28cbcf1e">type_unit_group</a>-&gt;primary_symtab = symtab;
<a name="l07880"></a>07880 
<a name="l07881"></a>07881       <span class="keywordflow">if</span> (symtab != NULL)
<a name="l07882"></a>07882         {
<a name="l07883"></a>07883           <span class="comment">/* Set symtab language to language from DW_AT_language.  If the</span>
<a name="l07884"></a>07884 <span class="comment">             compilation is from a C file generated by language preprocessors,</span>
<a name="l07885"></a>07885 <span class="comment">             do not set the language if it was already deduced by</span>
<a name="l07886"></a>07886 <span class="comment">             start_subfile.  */</span>
<a name="l07887"></a>07887           <span class="keywordflow">if</span> (!(cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202ad300f80a4c96edb04defba2280620a49">language_c</a> &amp;&amp; symtab-&gt;<a class="code" href="structsymtab.html#a26ff640a27ab8781d9e09231bd173e6c">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202ad300f80a4c96edb04defba2280620a49">language_c</a>))
<a name="l07888"></a>07888             symtab-&gt;<a class="code" href="structsymtab.html#a26ff640a27ab8781d9e09231bd173e6c">language</a> = cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>;
<a name="l07889"></a>07889         }
<a name="l07890"></a>07890     }
<a name="l07891"></a>07891   <span class="keywordflow">else</span>
<a name="l07892"></a>07892     {
<a name="l07893"></a>07893       <a class="code" href="buildsym_8c.html#ad51bd30450c57e818c02c439060416c6">augment_type_symtab</a> (objfile,
<a name="l07894"></a>07894                            sig_type-&gt;<a class="code" href="structsignatured__type.html#ab10f6f2df0f7691aa8ca948e28cbcf1e">type_unit_group</a>-&gt;primary_symtab);
<a name="l07895"></a>07895       symtab = sig_type-&gt;<a class="code" href="structsignatured__type.html#ab10f6f2df0f7691aa8ca948e28cbcf1e">type_unit_group</a>-&gt;primary_symtab;
<a name="l07896"></a>07896     }
<a name="l07897"></a>07897 
<a name="l07898"></a>07898   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a>)
<a name="l07899"></a>07899     per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#ae74faeb49ebdd91707a88ffff630157b">quick</a>-&gt;<a class="code" href="structdwarf2__per__cu__quick__data.html#a0e5f8bc9757f946dc2b8df05ef5acbd8">symtab</a> = symtab;
<a name="l07900"></a>07900   <span class="keywordflow">else</span>
<a name="l07901"></a>07901     {
<a name="l07902"></a>07902       <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a>;
<a name="l07903"></a>07903       pst-&gt;<a class="code" href="structpartial__symtab.html#a1bbcf18c88d09005b43f960b6f3575f8">symtab</a> = <a class="code" href="structpartial__symtab.html#a1bbcf18c88d09005b43f960b6f3575f8">symtab</a>;
<a name="l07904"></a>07904       pst-&gt;<a class="code" href="structpartial__symtab.html#a11d8e59b962db1317c8c23f917dbed42">readin</a> = 1;
<a name="l07905"></a>07905     }
<a name="l07906"></a>07906 
<a name="l07907"></a>07907   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l07908"></a>07908 }
<a name="l07909"></a>07909 
<a name="l07910"></a>07910 <span class="comment">/* Process an imported unit DIE.  */</span>
<a name="l07911"></a>07911 
<a name="l07912"></a>07912 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07913"></a><a class="code" href="dwarf2read_8c.html#a902236d42c7d88b5014fda859b77817c">07913</a> <a class="code" href="dwarf2read_8c.html#a902236d42c7d88b5014fda859b77817c">process_imported_unit_die</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l07914"></a>07914 {
<a name="l07915"></a>07915   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l07916"></a>07916 
<a name="l07917"></a>07917   <span class="comment">/* For now we don&#39;t handle imported units in type units.  */</span>
<a name="l07918"></a>07918   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l07919"></a>07919     {
<a name="l07920"></a>07920       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: DW_TAG_imported_unit is not&quot;</span>
<a name="l07921"></a>07921                <span class="stringliteral">&quot; supported in type units [in module %s]&quot;</span>),
<a name="l07922"></a>07922              <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>));
<a name="l07923"></a>07923     }
<a name="l07924"></a>07924 
<a name="l07925"></a>07925   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_import, cu);
<a name="l07926"></a>07926   <span class="keywordflow">if</span> (attr != NULL)
<a name="l07927"></a>07927     {
<a name="l07928"></a>07928       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu;
<a name="l07929"></a>07929       <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *imported_symtab;
<a name="l07930"></a>07930       <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l07931"></a>07931       <span class="keywordtype">int</span> is_dwz;
<a name="l07932"></a>07932 
<a name="l07933"></a>07933       offset = <a class="code" href="dwarf2read_8c.html#a28e7eb63f317d51f9be16584d407c508">dwarf2_get_ref_die_offset</a> (attr);
<a name="l07934"></a>07934       is_dwz = (attr-&gt;form == DW_FORM_GNU_ref_alt || cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a>);
<a name="l07935"></a>07935       per_cu = <a class="code" href="dwarf2read_8c.html#af3b37bdf179696b92b068cd2894de56d">dwarf2_find_containing_comp_unit</a> (offset, is_dwz, cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>);
<a name="l07936"></a>07936 
<a name="l07937"></a>07937       <span class="comment">/* If necessary, add it to the queue and load its DIEs.  */</span>
<a name="l07938"></a>07938       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ac102eb30f433a30a29425f0d30a461c2">maybe_queue_comp_unit</a> (cu, per_cu, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>))
<a name="l07939"></a>07939         <a class="code" href="dwarf2read_8c.html#a9f845956e1dd14ace7c6471ee8c2b502">load_full_comp_unit</a> (per_cu, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>);
<a name="l07940"></a>07940 
<a name="l07941"></a>07941       <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (dwarf2_per_cu_ptr, cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;imported_symtabs,
<a name="l07942"></a>07942                      per_cu);
<a name="l07943"></a>07943     }
<a name="l07944"></a>07944 }
<a name="l07945"></a>07945 
<a name="l07946"></a>07946 <span class="comment">/* Process a die and its children.  */</span>
<a name="l07947"></a>07947 
<a name="l07948"></a>07948 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l07949"></a><a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">07949</a> <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l07950"></a>07950 {
<a name="l07951"></a>07951   <span class="keywordflow">switch</span> (die-&gt;tag)
<a name="l07952"></a>07952     {
<a name="l07953"></a>07953     <span class="keywordflow">case</span> DW_TAG_padding:
<a name="l07954"></a>07954       <span class="keywordflow">break</span>;
<a name="l07955"></a>07955     <span class="keywordflow">case</span> DW_TAG_compile_unit:
<a name="l07956"></a>07956     <span class="keywordflow">case</span> DW_TAG_partial_unit:
<a name="l07957"></a>07957       <a class="code" href="dwarf2read_8c.html#a9126a0189849660b1db747863dafb0bf">read_file_scope</a> (die, cu);
<a name="l07958"></a>07958       <span class="keywordflow">break</span>;
<a name="l07959"></a>07959     <span class="keywordflow">case</span> DW_TAG_type_unit:
<a name="l07960"></a>07960       <a class="code" href="dwarf2read_8c.html#a40896e3030e32e5b5e08e57a5536723e">read_type_unit_scope</a> (die, cu);
<a name="l07961"></a>07961       <span class="keywordflow">break</span>;
<a name="l07962"></a>07962     <span class="keywordflow">case</span> DW_TAG_subprogram:
<a name="l07963"></a>07963     <span class="keywordflow">case</span> DW_TAG_inlined_subroutine:
<a name="l07964"></a>07964       <a class="code" href="dwarf2read_8c.html#a8883e03bccc13b39a7d3f1852dc96dfd">read_func_scope</a> (die, cu);
<a name="l07965"></a>07965       <span class="keywordflow">break</span>;
<a name="l07966"></a>07966     <span class="keywordflow">case</span> DW_TAG_lexical_block:
<a name="l07967"></a>07967     <span class="keywordflow">case</span> DW_TAG_try_block:
<a name="l07968"></a>07968     <span class="keywordflow">case</span> DW_TAG_catch_block:
<a name="l07969"></a>07969       <a class="code" href="dwarf2read_8c.html#a1ada1c5f995cf53a504f3c9bce099fb5">read_lexical_block_scope</a> (die, cu);
<a name="l07970"></a>07970       <span class="keywordflow">break</span>;
<a name="l07971"></a>07971     <span class="keywordflow">case</span> DW_TAG_GNU_call_site:
<a name="l07972"></a>07972       <a class="code" href="dwarf2read_8c.html#a763117964c95fb54ba4c8ebe38e2ff87">read_call_site_scope</a> (die, cu);
<a name="l07973"></a>07973       <span class="keywordflow">break</span>;
<a name="l07974"></a>07974     <span class="keywordflow">case</span> DW_TAG_class_type:
<a name="l07975"></a>07975     <span class="keywordflow">case</span> DW_TAG_interface_type:
<a name="l07976"></a>07976     <span class="keywordflow">case</span> DW_TAG_structure_type:
<a name="l07977"></a>07977     <span class="keywordflow">case</span> DW_TAG_union_type:
<a name="l07978"></a>07978       <a class="code" href="dwarf2read_8c.html#a0d01179d58ab2151b5a646e74f2c089f">process_structure_scope</a> (die, cu);
<a name="l07979"></a>07979       <span class="keywordflow">break</span>;
<a name="l07980"></a>07980     <span class="keywordflow">case</span> DW_TAG_enumeration_type:
<a name="l07981"></a>07981       <a class="code" href="dwarf2read_8c.html#aeff5dce8be530b01d1e71bbe356f9a24">process_enumeration_scope</a> (die, cu);
<a name="l07982"></a>07982       <span class="keywordflow">break</span>;
<a name="l07983"></a>07983 
<a name="l07984"></a>07984     <span class="comment">/* These dies have a type, but processing them does not create</span>
<a name="l07985"></a>07985 <span class="comment">       a symbol or recurse to process the children.  Therefore we can</span>
<a name="l07986"></a>07986 <span class="comment">       read them on-demand through read_type_die.  */</span>
<a name="l07987"></a>07987     <span class="keywordflow">case</span> DW_TAG_subroutine_type:
<a name="l07988"></a>07988     <span class="keywordflow">case</span> DW_TAG_set_type:
<a name="l07989"></a>07989     <span class="keywordflow">case</span> DW_TAG_array_type:
<a name="l07990"></a>07990     <span class="keywordflow">case</span> DW_TAG_pointer_type:
<a name="l07991"></a>07991     <span class="keywordflow">case</span> DW_TAG_ptr_to_member_type:
<a name="l07992"></a>07992     <span class="keywordflow">case</span> DW_TAG_reference_type:
<a name="l07993"></a>07993     <span class="keywordflow">case</span> DW_TAG_string_type:
<a name="l07994"></a>07994       <span class="keywordflow">break</span>;
<a name="l07995"></a>07995 
<a name="l07996"></a>07996     <span class="keywordflow">case</span> DW_TAG_base_type:
<a name="l07997"></a>07997     <span class="keywordflow">case</span> DW_TAG_subrange_type:
<a name="l07998"></a>07998     <span class="keywordflow">case</span> DW_TAG_typedef:
<a name="l07999"></a>07999       <span class="comment">/* Add a typedef symbol for the type definition, if it has a</span>
<a name="l08000"></a>08000 <span class="comment">         DW_AT_name.  */</span>
<a name="l08001"></a>08001       <a class="code" href="dwarf2read_8c.html#a4b79d225399dba2c4a3397a858440dd4">new_symbol</a> (die, <a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (die, cu), cu);
<a name="l08002"></a>08002       <span class="keywordflow">break</span>;
<a name="l08003"></a>08003     <span class="keywordflow">case</span> DW_TAG_common_block:
<a name="l08004"></a>08004       <a class="code" href="dwarf2read_8c.html#ab5a2e1c5e61bf3e7a380c7da5361549d">read_common_block</a> (die, cu);
<a name="l08005"></a>08005       <span class="keywordflow">break</span>;
<a name="l08006"></a>08006     <span class="keywordflow">case</span> DW_TAG_common_inclusion:
<a name="l08007"></a>08007       <span class="keywordflow">break</span>;
<a name="l08008"></a>08008     <span class="keywordflow">case</span> DW_TAG_namespace:
<a name="l08009"></a>08009       cu-&gt;processing_has_namespace_info = 1;
<a name="l08010"></a>08010       <a class="code" href="dwarf2read_8c.html#aff7ad824d37fcf5d005e0db22721cdef">read_namespace</a> (die, cu);
<a name="l08011"></a>08011       <span class="keywordflow">break</span>;
<a name="l08012"></a>08012     <span class="keywordflow">case</span> DW_TAG_module:
<a name="l08013"></a>08013       cu-&gt;processing_has_namespace_info = 1;
<a name="l08014"></a>08014       <a class="code" href="dwarf2read_8c.html#a9f99a9bd45327b2888e42df7832dfdab">read_module</a> (die, cu);
<a name="l08015"></a>08015       <span class="keywordflow">break</span>;
<a name="l08016"></a>08016     <span class="keywordflow">case</span> DW_TAG_imported_declaration:
<a name="l08017"></a>08017     <span class="keywordflow">case</span> DW_TAG_imported_module:
<a name="l08018"></a>08018       cu-&gt;processing_has_namespace_info = 1;
<a name="l08019"></a>08019       <span class="keywordflow">if</span> (die-&gt;child != NULL &amp;&amp; (die-&gt;tag == DW_TAG_imported_declaration
<a name="l08020"></a>08020                                  || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>))
<a name="l08021"></a>08021         <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Tag &#39;%s&#39; has unexpected children&quot;</span>),
<a name="l08022"></a>08022                    <a class="code" href="dwarf2read_8c.html#af80d37a7ff366081b096550409d46e45">dwarf_tag_name</a> (die-&gt;tag));
<a name="l08023"></a>08023       <a class="code" href="dwarf2read_8c.html#a3508f14002211278d9e4e0936a70f108">read_import_statement</a> (die, cu);
<a name="l08024"></a>08024       <span class="keywordflow">break</span>;
<a name="l08025"></a>08025 
<a name="l08026"></a>08026     <span class="keywordflow">case</span> DW_TAG_imported_unit:
<a name="l08027"></a>08027       <a class="code" href="dwarf2read_8c.html#a902236d42c7d88b5014fda859b77817c">process_imported_unit_die</a> (die, cu);
<a name="l08028"></a>08028       <span class="keywordflow">break</span>;
<a name="l08029"></a>08029 
<a name="l08030"></a>08030     <span class="keywordflow">default</span>:
<a name="l08031"></a>08031       <a class="code" href="dwarf2read_8c.html#a4b79d225399dba2c4a3397a858440dd4">new_symbol</a> (die, NULL, cu);
<a name="l08032"></a>08032       <span class="keywordflow">break</span>;
<a name="l08033"></a>08033     }
<a name="l08034"></a>08034 }
<a name="l08035"></a>08035 
<a name="l08036"></a>08036 <span class="comment">/* DWARF name computation.  */</span>
<a name="l08037"></a>08037 
<a name="l08038"></a>08038 <span class="comment">/* A helper function for dwarf2_compute_name which determines whether DIE</span>
<a name="l08039"></a>08039 <span class="comment">   needs to have the name of the scope prepended to the name listed in the</span>
<a name="l08040"></a>08040 <span class="comment">   die.  */</span>
<a name="l08041"></a>08041 
<a name="l08042"></a>08042 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l08043"></a><a class="code" href="dwarf2read_8c.html#ad98511f088c664e1e170abf8cbe456e3">08043</a> <a class="code" href="dwarf2read_8c.html#ad98511f088c664e1e170abf8cbe456e3">die_needs_namespace</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l08044"></a>08044 {
<a name="l08045"></a>08045   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l08046"></a>08046 
<a name="l08047"></a>08047   <span class="keywordflow">switch</span> (die-&gt;tag)
<a name="l08048"></a>08048     {
<a name="l08049"></a>08049     <span class="keywordflow">case</span> DW_TAG_namespace:
<a name="l08050"></a>08050     <span class="keywordflow">case</span> DW_TAG_typedef:
<a name="l08051"></a>08051     <span class="keywordflow">case</span> DW_TAG_class_type:
<a name="l08052"></a>08052     <span class="keywordflow">case</span> DW_TAG_interface_type:
<a name="l08053"></a>08053     <span class="keywordflow">case</span> DW_TAG_structure_type:
<a name="l08054"></a>08054     <span class="keywordflow">case</span> DW_TAG_union_type:
<a name="l08055"></a>08055     <span class="keywordflow">case</span> DW_TAG_enumeration_type:
<a name="l08056"></a>08056     <span class="keywordflow">case</span> DW_TAG_enumerator:
<a name="l08057"></a>08057     <span class="keywordflow">case</span> DW_TAG_subprogram:
<a name="l08058"></a>08058     <span class="keywordflow">case</span> DW_TAG_member:
<a name="l08059"></a>08059       <span class="keywordflow">return</span> 1;
<a name="l08060"></a>08060 
<a name="l08061"></a>08061     <span class="keywordflow">case</span> DW_TAG_variable:
<a name="l08062"></a>08062     <span class="keywordflow">case</span> DW_TAG_constant:
<a name="l08063"></a>08063       <span class="comment">/* We only need to prefix &quot;globally&quot; visible variables.  These include</span>
<a name="l08064"></a>08064 <span class="comment">         any variable marked with DW_AT_external or any variable that</span>
<a name="l08065"></a>08065 <span class="comment">         lives in a namespace.  [Variables in anonymous namespaces</span>
<a name="l08066"></a>08066 <span class="comment">         require prefixing, but they are not DW_AT_external.]  */</span>
<a name="l08067"></a>08067 
<a name="l08068"></a>08068       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_specification, cu))
<a name="l08069"></a>08069         {
<a name="l08070"></a>08070           <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *spec_cu = cu;
<a name="l08071"></a>08071 
<a name="l08072"></a>08072           <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#ad98511f088c664e1e170abf8cbe456e3">die_needs_namespace</a> (<a class="code" href="dwarf2read_8c.html#a86adfa4fccde4cd4c512ca520e5bb1d7">die_specification</a> (die, &amp;spec_cu),
<a name="l08073"></a>08073                                       spec_cu);
<a name="l08074"></a>08074         }
<a name="l08075"></a>08075 
<a name="l08076"></a>08076       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_external, cu);
<a name="l08077"></a>08077       <span class="keywordflow">if</span> (attr == NULL &amp;&amp; die-&gt;parent-&gt;tag != DW_TAG_namespace
<a name="l08078"></a>08078           &amp;&amp; die-&gt;parent-&gt;tag != DW_TAG_module)
<a name="l08079"></a>08079         <span class="keywordflow">return</span> 0;
<a name="l08080"></a>08080       <span class="comment">/* A variable in a lexical block of some kind does not need a</span>
<a name="l08081"></a>08081 <span class="comment">         namespace, even though in C++ such variables may be external</span>
<a name="l08082"></a>08082 <span class="comment">         and have a mangled name.  */</span>
<a name="l08083"></a>08083       <span class="keywordflow">if</span> (die-&gt;parent-&gt;tag ==  DW_TAG_lexical_block
<a name="l08084"></a>08084           || die-&gt;parent-&gt;tag ==  DW_TAG_try_block
<a name="l08085"></a>08085           || die-&gt;parent-&gt;tag ==  DW_TAG_catch_block
<a name="l08086"></a>08086           || die-&gt;parent-&gt;tag == DW_TAG_subprogram)
<a name="l08087"></a>08087         <span class="keywordflow">return</span> 0;
<a name="l08088"></a>08088       <span class="keywordflow">return</span> 1;
<a name="l08089"></a>08089 
<a name="l08090"></a>08090     <span class="keywordflow">default</span>:
<a name="l08091"></a>08091       <span class="keywordflow">return</span> 0;
<a name="l08092"></a>08092     }
<a name="l08093"></a>08093 }
<a name="l08094"></a>08094 
<a name="l08095"></a>08095 <span class="comment">/* Retrieve the last character from a mem_file.  */</span>
<a name="l08096"></a>08096 
<a name="l08097"></a>08097 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l08098"></a><a class="code" href="dwarf2read_8c.html#a8d33e5a672dabf0ebb0e3fa0e17def02">08098</a> <a class="code" href="dwarf2read_8c.html#a8d33e5a672dabf0ebb0e3fa0e17def02">do_ui_file_peek_last</a> (<span class="keywordtype">void</span> *<span class="keywordtype">object</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structbuffer.html">buffer</a>, <span class="keywordtype">long</span> length)
<a name="l08099"></a>08099 {
<a name="l08100"></a>08100   <span class="keywordtype">char</span> *last_char_p = (<span class="keywordtype">char</span> *) <span class="keywordtype">object</span>;
<a name="l08101"></a>08101 
<a name="l08102"></a>08102   <span class="keywordflow">if</span> (length &gt; 0)
<a name="l08103"></a>08103     *last_char_p = buffer[length - 1];
<a name="l08104"></a>08104 }
<a name="l08105"></a>08105 
<a name="l08106"></a>08106 <span class="comment">/* Compute the fully qualified name of DIE in CU.  If PHYSNAME is nonzero,</span>
<a name="l08107"></a>08107 <span class="comment">   compute the physname for the object, which include a method&#39;s:</span>
<a name="l08108"></a>08108 <span class="comment">   - formal parameters (C++/Java),</span>
<a name="l08109"></a>08109 <span class="comment">   - receiver type (Go),</span>
<a name="l08110"></a>08110 <span class="comment">   - return type (Java).</span>
<a name="l08111"></a>08111 <span class="comment"></span>
<a name="l08112"></a>08112 <span class="comment">   The term &quot;physname&quot; is a bit confusing.</span>
<a name="l08113"></a>08113 <span class="comment">   For C++, for example, it is the demangled name.</span>
<a name="l08114"></a>08114 <span class="comment">   For Go, for example, it&#39;s the mangled name.</span>
<a name="l08115"></a>08115 <span class="comment"></span>
<a name="l08116"></a>08116 <span class="comment">   For Ada, return the DIE&#39;s linkage name rather than the fully qualified</span>
<a name="l08117"></a>08117 <span class="comment">   name.  PHYSNAME is ignored..</span>
<a name="l08118"></a>08118 <span class="comment"></span>
<a name="l08119"></a>08119 <span class="comment">   The result is allocated on the objfile_obstack and canonicalized.  */</span>
<a name="l08120"></a>08120 
<a name="l08121"></a>08121 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l08122"></a><a class="code" href="dwarf2read_8c.html#acec9955a884b630c43434507ebf27eff">08122</a> <a class="code" href="dwarf2read_8c.html#acec9955a884b630c43434507ebf27eff">dwarf2_compute_name</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l08123"></a>08123                      <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l08124"></a>08124                      <span class="keywordtype">int</span> physname)
<a name="l08125"></a>08125 {
<a name="l08126"></a>08126   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l08127"></a>08127 
<a name="l08128"></a>08128   <span class="keywordflow">if</span> (name == NULL)
<a name="l08129"></a>08129     name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l08130"></a>08130 
<a name="l08131"></a>08131   <span class="comment">/* For Fortran GDB prefers DW_AT_*linkage_name if present but otherwise</span>
<a name="l08132"></a>08132 <span class="comment">     compute it by typename_concat inside GDB.  */</span>
<a name="l08133"></a>08133   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>
<a name="l08134"></a>08134       || (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a> &amp;&amp; physname))
<a name="l08135"></a>08135     {
<a name="l08136"></a>08136       <span class="comment">/* For Ada unit, we prefer the linkage name over the name, as</span>
<a name="l08137"></a>08137 <span class="comment">         the former contains the exported name, which the user expects</span>
<a name="l08138"></a>08138 <span class="comment">         to be able to reference.  Ideally, we want the user to be able</span>
<a name="l08139"></a>08139 <span class="comment">         to reference this entity using either natural or linkage name,</span>
<a name="l08140"></a>08140 <span class="comment">         but we haven&#39;t started looking at this enhancement yet.  */</span>
<a name="l08141"></a>08141       <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l08142"></a>08142 
<a name="l08143"></a>08143       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_linkage_name, cu);
<a name="l08144"></a>08144       <span class="keywordflow">if</span> (attr == NULL)
<a name="l08145"></a>08145         attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_MIPS_linkage_name, cu);
<a name="l08146"></a>08146       <span class="keywordflow">if</span> (attr &amp;&amp; <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr))
<a name="l08147"></a>08147         <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr);
<a name="l08148"></a>08148     }
<a name="l08149"></a>08149 
<a name="l08150"></a>08150   <span class="comment">/* These are the only languages we know how to qualify names in.  */</span>
<a name="l08151"></a>08151   <span class="keywordflow">if</span> (name != NULL
<a name="l08152"></a>08152       &amp;&amp; (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a> || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>
<a name="l08153"></a>08153           || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>))
<a name="l08154"></a>08154     {
<a name="l08155"></a>08155       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ad98511f088c664e1e170abf8cbe456e3">die_needs_namespace</a> (die, cu))
<a name="l08156"></a>08156         {
<a name="l08157"></a>08157           <span class="keywordtype">long</span> length;
<a name="l08158"></a>08158           <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix;
<a name="l08159"></a>08159           <span class="keyword">struct </span><a class="code" href="structui__file.html">ui_file</a> *buf;
<a name="l08160"></a>08160 
<a name="l08161"></a>08161           prefix = <a class="code" href="dwarf2read_8c.html#a2417ea09b6b125e47a255352f662e856">determine_prefix</a> (die, cu);
<a name="l08162"></a>08162           buf = <a class="code" href="ui-file_8c.html#a340771735f105582d314e191a399a45c">mem_fileopen</a> ();
<a name="l08163"></a>08163           <span class="keywordflow">if</span> (*prefix != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l08164"></a>08164             {
<a name="l08165"></a>08165               <span class="keywordtype">char</span> *prefixed_name = <a class="code" href="dwarf2read_8c.html#a6abe45afe642868fb22402ce7349ad7f">typename_concat</a> (NULL, prefix, name,
<a name="l08166"></a>08166                                                      physname, cu);
<a name="l08167"></a>08167 
<a name="l08168"></a>08168               <a class="code" href="ui-file_8c.html#aae3b905f888b1dcdce586f77b9554153">fputs_unfiltered</a> (prefixed_name, buf);
<a name="l08169"></a>08169               <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (prefixed_name);
<a name="l08170"></a>08170             }
<a name="l08171"></a>08171           <span class="keywordflow">else</span>
<a name="l08172"></a>08172             <a class="code" href="ui-file_8c.html#aae3b905f888b1dcdce586f77b9554153">fputs_unfiltered</a> (name, buf);
<a name="l08173"></a>08173 
<a name="l08174"></a>08174           <span class="comment">/* Template parameters may be specified in the DIE&#39;s DW_AT_name, or</span>
<a name="l08175"></a>08175 <span class="comment">             as children with DW_TAG_template_type_param or</span>
<a name="l08176"></a>08176 <span class="comment">             DW_TAG_value_type_param.  If the latter, add them to the name</span>
<a name="l08177"></a>08177 <span class="comment">             here.  If the name already has template parameters, then</span>
<a name="l08178"></a>08178 <span class="comment">             skip this step; some versions of GCC emit both, and</span>
<a name="l08179"></a>08179 <span class="comment">             it is more efficient to use the pre-computed name.</span>
<a name="l08180"></a>08180 <span class="comment"></span>
<a name="l08181"></a>08181 <span class="comment">             Something to keep in mind about this process: it is very</span>
<a name="l08182"></a>08182 <span class="comment">             unlikely, or in some cases downright impossible, to produce</span>
<a name="l08183"></a>08183 <span class="comment">             something that will match the mangled name of a function.</span>
<a name="l08184"></a>08184 <span class="comment">             If the definition of the function has the same debug info,</span>
<a name="l08185"></a>08185 <span class="comment">             we should be able to match up with it anyway.  But fallbacks</span>
<a name="l08186"></a>08186 <span class="comment">             using the minimal symbol, for instance to find a method</span>
<a name="l08187"></a>08187 <span class="comment">             implemented in a stripped copy of libstdc++, will not work.</span>
<a name="l08188"></a>08188 <span class="comment">             If we do not have debug info for the definition, we will have to</span>
<a name="l08189"></a>08189 <span class="comment">             match them up some other way.</span>
<a name="l08190"></a>08190 <span class="comment"></span>
<a name="l08191"></a>08191 <span class="comment">             When we do name matching there is a related problem with function</span>
<a name="l08192"></a>08192 <span class="comment">             templates; two instantiated function templates are allowed to</span>
<a name="l08193"></a>08193 <span class="comment">             differ only by their return types, which we do not add here.  */</span>
<a name="l08194"></a>08194 
<a name="l08195"></a>08195           <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a> &amp;&amp; <a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (name, <span class="charliteral">&#39;&lt;&#39;</span>) == NULL)
<a name="l08196"></a>08196             {
<a name="l08197"></a>08197               <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l08198"></a>08198               <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child;
<a name="l08199"></a>08199               <span class="keywordtype">int</span> first = 1;
<a name="l08200"></a>08200 
<a name="l08201"></a>08201               die-&gt;building_fullname = 1;
<a name="l08202"></a>08202 
<a name="l08203"></a>08203               <span class="keywordflow">for</span> (child = die-&gt;child; child != NULL; child = child-&gt;sibling)
<a name="l08204"></a>08204                 {
<a name="l08205"></a>08205                   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l08206"></a>08206                   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="structvalue.html">value</a>;
<a name="l08207"></a>08207                   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *bytes;
<a name="l08208"></a>08208                   <span class="keyword">struct </span><a class="code" href="structdwarf2__locexpr__baton.html">dwarf2_locexpr_baton</a> *baton;
<a name="l08209"></a>08209                   <span class="keyword">struct </span>value *v;
<a name="l08210"></a>08210 
<a name="l08211"></a>08211                   <span class="keywordflow">if</span> (child-&gt;tag != DW_TAG_template_type_param
<a name="l08212"></a>08212                       &amp;&amp; child-&gt;tag != DW_TAG_template_value_param)
<a name="l08213"></a>08213                     <span class="keywordflow">continue</span>;
<a name="l08214"></a>08214 
<a name="l08215"></a>08215                   <span class="keywordflow">if</span> (first)
<a name="l08216"></a>08216                     {
<a name="l08217"></a>08217                       <a class="code" href="ui-file_8c.html#aae3b905f888b1dcdce586f77b9554153">fputs_unfiltered</a> (<span class="stringliteral">&quot;&lt;&quot;</span>, buf);
<a name="l08218"></a>08218                       first = 0;
<a name="l08219"></a>08219                     }
<a name="l08220"></a>08220                   <span class="keywordflow">else</span>
<a name="l08221"></a>08221                     <a class="code" href="ui-file_8c.html#aae3b905f888b1dcdce586f77b9554153">fputs_unfiltered</a> (<span class="stringliteral">&quot;, &quot;</span>, buf);
<a name="l08222"></a>08222 
<a name="l08223"></a>08223                   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (child, DW_AT_type, cu);
<a name="l08224"></a>08224                   <span class="keywordflow">if</span> (attr == NULL)
<a name="l08225"></a>08225                     {
<a name="l08226"></a>08226                       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l08227"></a>08227                                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;template parameter missing DW_AT_type&quot;</span>));
<a name="l08228"></a>08228                       <a class="code" href="ui-file_8c.html#aae3b905f888b1dcdce586f77b9554153">fputs_unfiltered</a> (<span class="stringliteral">&quot;UNKNOWN_TYPE&quot;</span>, buf);
<a name="l08229"></a>08229                       <span class="keywordflow">continue</span>;
<a name="l08230"></a>08230                     }
<a name="l08231"></a>08231                   type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (child, cu);
<a name="l08232"></a>08232 
<a name="l08233"></a>08233                   <span class="keywordflow">if</span> (child-&gt;tag == DW_TAG_template_type_param)
<a name="l08234"></a>08234                     {
<a name="l08235"></a>08235                       <a class="code" href="c-lang_8h.html#aaf84d638c9714765572c1f68880410f4">c_print_type</a> (type, <span class="stringliteral">&quot;&quot;</span>, buf, -1, 0, &amp;<a class="code" href="typeprint_8c.html#a66053927e0c2e901b62bd36fd9769296">type_print_raw_options</a>);
<a name="l08236"></a>08236                       <span class="keywordflow">continue</span>;
<a name="l08237"></a>08237                     }
<a name="l08238"></a>08238 
<a name="l08239"></a>08239                   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (child, DW_AT_const_value, cu);
<a name="l08240"></a>08240                   <span class="keywordflow">if</span> (attr == NULL)
<a name="l08241"></a>08241                     {
<a name="l08242"></a>08242                       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l08243"></a>08243                                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;template parameter missing &quot;</span>
<a name="l08244"></a>08244                                    <span class="stringliteral">&quot;DW_AT_const_value&quot;</span>));
<a name="l08245"></a>08245                       <a class="code" href="ui-file_8c.html#aae3b905f888b1dcdce586f77b9554153">fputs_unfiltered</a> (<span class="stringliteral">&quot;UNKNOWN_VALUE&quot;</span>, buf);
<a name="l08246"></a>08246                       <span class="keywordflow">continue</span>;
<a name="l08247"></a>08247                     }
<a name="l08248"></a>08248 
<a name="l08249"></a>08249                   <a class="code" href="dwarf2read_8c.html#af4c429879bd3d814ab4b878a0d4f926e">dwarf2_const_value_attr</a> (attr, type, name,
<a name="l08250"></a>08250                                            &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>, cu,
<a name="l08251"></a>08251                                            &amp;value, &amp;bytes, &amp;baton);
<a name="l08252"></a>08252 
<a name="l08253"></a>08253                   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a072c2a4284516f56accc85be90546a30">TYPE_NOSIGN</a> (type))
<a name="l08254"></a>08254                     <span class="comment">/* GDB prints characters as NUMBER &#39;CHAR&#39;.  If that&#39;s</span>
<a name="l08255"></a>08255 <span class="comment">                       changed, this can use value_print instead.  */</span>
<a name="l08256"></a>08256                     <a class="code" href="c-lang_8c.html#aea550415b0049213c5f97bc017f2ee34">c_printchar</a> (value, type, buf);
<a name="l08257"></a>08257                   <span class="keywordflow">else</span>
<a name="l08258"></a>08258                     {
<a name="l08259"></a>08259                       <span class="keyword">struct </span><a class="code" href="structvalue__print__options.html">value_print_options</a> opts;
<a name="l08260"></a>08260 
<a name="l08261"></a>08261                       <span class="keywordflow">if</span> (baton != NULL)
<a name="l08262"></a>08262                         v = <a class="code" href="dwarf2loc_8c.html#a4d6ea3d37cd48b500b41c17cd2ccfc0c">dwarf2_evaluate_loc_desc</a> (type, NULL,
<a name="l08263"></a>08263                                                       baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#a629a2d12a13c59e34ffc1f64953b5f01">data</a>,
<a name="l08264"></a>08264                                                       baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#aad393a9f0c112b45b23fb0d30c19df07">size</a>,
<a name="l08265"></a>08265                                                       baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#a4f4c2fcdbde62332afde34a8a95d91fe">per_cu</a>);
<a name="l08266"></a>08266                       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytes != NULL)
<a name="l08267"></a>08267                         {
<a name="l08268"></a>08268                           v = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (type);
<a name="l08269"></a>08269                           <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="value_8c.html#a13d7c6c06f661cae284e575c50647344">value_contents_writeable</a> (v), bytes,
<a name="l08270"></a>08270                                   <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type));
<a name="l08271"></a>08271                         }
<a name="l08272"></a>08272                       <span class="keywordflow">else</span>
<a name="l08273"></a>08273                         v = <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, value);
<a name="l08274"></a>08274 
<a name="l08275"></a>08275                       <span class="comment">/* Specify decimal so that we do not depend on</span>
<a name="l08276"></a>08276 <span class="comment">                         the radix.  */</span>
<a name="l08277"></a>08277                       <a class="code" href="valprint_8c.html#a1177f66ae5a60db2a75604f268dba57f">get_formatted_print_options</a> (&amp;opts, <span class="charliteral">&#39;d&#39;</span>);
<a name="l08278"></a>08278                       opts.<a class="code" href="structvalue__print__options.html#a906b0433c8e9bad5a42fa6430026e8cc">raw</a> = 1;
<a name="l08279"></a>08279                       <a class="code" href="valprint_8c.html#a1e41c7430a7b838beec1717ced3e9d94">value_print</a> (v, buf, &amp;opts);
<a name="l08280"></a>08280                       <a class="code" href="value_8c.html#a5a9662fcdbefec2edef0b912ba593914">release_value</a> (v);
<a name="l08281"></a>08281                       <a class="code" href="value_8c.html#a1f9b3ee232ece65ddc75c2407b97a50d">value_free</a> (v);
<a name="l08282"></a>08282                     }
<a name="l08283"></a>08283                 }
<a name="l08284"></a>08284 
<a name="l08285"></a>08285               die-&gt;building_fullname = 0;
<a name="l08286"></a>08286 
<a name="l08287"></a>08287               <span class="keywordflow">if</span> (!first)
<a name="l08288"></a>08288                 {
<a name="l08289"></a>08289                   <span class="comment">/* Close the argument list, with a space if necessary</span>
<a name="l08290"></a>08290 <span class="comment">                     (nested templates).  */</span>
<a name="l08291"></a>08291                   <span class="keywordtype">char</span> last_char = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l08292"></a>08292                   <a class="code" href="ui-file_8c.html#ac35c6b0ed687032ab402ab21535bf581">ui_file_put</a> (buf, <a class="code" href="dwarf2read_8c.html#a8d33e5a672dabf0ebb0e3fa0e17def02">do_ui_file_peek_last</a>, &amp;last_char);
<a name="l08293"></a>08293                   <span class="keywordflow">if</span> (last_char == <span class="charliteral">&#39;&gt;&#39;</span>)
<a name="l08294"></a>08294                     <a class="code" href="ui-file_8c.html#aae3b905f888b1dcdce586f77b9554153">fputs_unfiltered</a> (<span class="stringliteral">&quot; &gt;&quot;</span>, buf);
<a name="l08295"></a>08295                   <span class="keywordflow">else</span>
<a name="l08296"></a>08296                     <a class="code" href="ui-file_8c.html#aae3b905f888b1dcdce586f77b9554153">fputs_unfiltered</a> (<span class="stringliteral">&quot;&gt;&quot;</span>, buf);
<a name="l08297"></a>08297                 }
<a name="l08298"></a>08298             }
<a name="l08299"></a>08299 
<a name="l08300"></a>08300           <span class="comment">/* For Java and C++ methods, append formal parameter type</span>
<a name="l08301"></a>08301 <span class="comment">             information, if PHYSNAME.  */</span>
<a name="l08302"></a>08302 
<a name="l08303"></a>08303           <span class="keywordflow">if</span> (physname &amp;&amp; die-&gt;tag == DW_TAG_subprogram
<a name="l08304"></a>08304               &amp;&amp; (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l08305"></a>08305                   || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>))
<a name="l08306"></a>08306             {
<a name="l08307"></a>08307               <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = <a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (die, cu);
<a name="l08308"></a>08308 
<a name="l08309"></a>08309               <a class="code" href="c-typeprint_8c.html#a7893e6582a93faba583d5fda5062dd75">c_type_print_args</a> (type, buf, 1, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>,
<a name="l08310"></a>08310                                  &amp;<a class="code" href="typeprint_8c.html#a66053927e0c2e901b62bd36fd9769296">type_print_raw_options</a>);
<a name="l08311"></a>08311 
<a name="l08312"></a>08312               <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>)
<a name="l08313"></a>08313                 {
<a name="l08314"></a>08314                   <span class="comment">/* For java, we must append the return type to method</span>
<a name="l08315"></a>08315 <span class="comment">                     names.  */</span>
<a name="l08316"></a>08316                   <span class="keywordflow">if</span> (die-&gt;tag == DW_TAG_subprogram)
<a name="l08317"></a>08317                     <a class="code" href="jv-lang_8h.html#a6b8590a9d3dfce1ac3eaaa528d7b93cb">java_print_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type), <span class="stringliteral">&quot;&quot;</span>, buf,
<a name="l08318"></a>08318                                      0, 0, &amp;<a class="code" href="typeprint_8c.html#a66053927e0c2e901b62bd36fd9769296">type_print_raw_options</a>);
<a name="l08319"></a>08319                 }
<a name="l08320"></a>08320               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>)
<a name="l08321"></a>08321                 {
<a name="l08322"></a>08322                   <span class="comment">/* Assume that an artificial first parameter is</span>
<a name="l08323"></a>08323 <span class="comment">                     &quot;this&quot;, but do not crash if it is not.  RealView</span>
<a name="l08324"></a>08324 <span class="comment">                     marks unnamed (and thus unused) parameters as</span>
<a name="l08325"></a>08325 <span class="comment">                     artificial; there is no way to differentiate</span>
<a name="l08326"></a>08326 <span class="comment">                     the two cases.  */</span>
<a name="l08327"></a>08327                   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) &gt; 0
<a name="l08328"></a>08328                       &amp;&amp; <a class="code" href="gdbtypes_8h.html#aa2bb2f58f95f604830c665368481946d">TYPE_FIELD_ARTIFICIAL</a> (type, 0)
<a name="l08329"></a>08329                       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, 0)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l08330"></a>08330                       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a82b926a1727ba5c6b856145197495a34">TYPE_CONST</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type,
<a name="l08331"></a>08331                                                                         0))))
<a name="l08332"></a>08332                     <a class="code" href="ui-file_8c.html#aae3b905f888b1dcdce586f77b9554153">fputs_unfiltered</a> (<span class="stringliteral">&quot; const&quot;</span>, buf);
<a name="l08333"></a>08333                 }
<a name="l08334"></a>08334             }
<a name="l08335"></a>08335 
<a name="l08336"></a>08336           name = <a class="code" href="ui-file_8c.html#a541c31fdc6f196280a6a1447090b8488">ui_file_obsavestring</a> (buf, &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l08337"></a>08337                                        &amp;length);
<a name="l08338"></a>08338           <a class="code" href="ui-file_8c.html#a17fda20af14c0187cbda770d4eb2777b">ui_file_delete</a> (buf);
<a name="l08339"></a>08339 
<a name="l08340"></a>08340           <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>)
<a name="l08341"></a>08341             {
<a name="l08342"></a>08342               <span class="keyword">const</span> <span class="keywordtype">char</span> *cname
<a name="l08343"></a>08343                 = <a class="code" href="dwarf2read_8c.html#a15617623710ce00d6f31263aad9bd432">dwarf2_canonicalize_name</a> (name, cu,
<a name="l08344"></a>08344                                             &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>);
<a name="l08345"></a>08345 
<a name="l08346"></a>08346               <span class="keywordflow">if</span> (cname != NULL)
<a name="l08347"></a>08347                 name = cname;
<a name="l08348"></a>08348             }
<a name="l08349"></a>08349         }
<a name="l08350"></a>08350     }
<a name="l08351"></a>08351 
<a name="l08352"></a>08352   <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l08353"></a>08353 }
<a name="l08354"></a>08354 
<a name="l08355"></a>08355 <span class="comment">/* Return the fully qualified name of DIE, based on its DW_AT_name.</span>
<a name="l08356"></a>08356 <span class="comment">   If scope qualifiers are appropriate they will be added.  The result</span>
<a name="l08357"></a>08357 <span class="comment">   will be allocated on the objfile_obstack, or NULL if the DIE does</span>
<a name="l08358"></a>08358 <span class="comment">   not have a name.  NAME may either be from a previous call to</span>
<a name="l08359"></a>08359 <span class="comment">   dwarf2_name or NULL.</span>
<a name="l08360"></a>08360 <span class="comment"></span>
<a name="l08361"></a>08361 <span class="comment">   The output string will be canonicalized (if C++/Java).  */</span>
<a name="l08362"></a>08362 
<a name="l08363"></a>08363 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l08364"></a><a class="code" href="dwarf2read_8c.html#a01de8f373799ebb39da7b5758619ec4c">08364</a> <a class="code" href="dwarf2read_8c.html#a01de8f373799ebb39da7b5758619ec4c">dwarf2_full_name</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l08365"></a>08365 {
<a name="l08366"></a>08366   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#acec9955a884b630c43434507ebf27eff">dwarf2_compute_name</a> (name, die, cu, 0);
<a name="l08367"></a>08367 }
<a name="l08368"></a>08368 
<a name="l08369"></a>08369 <span class="comment">/* Construct a physname for the given DIE in CU.  NAME may either be</span>
<a name="l08370"></a>08370 <span class="comment">   from a previous call to dwarf2_name or NULL.  The result will be</span>
<a name="l08371"></a>08371 <span class="comment">   allocated on the objfile_objstack or NULL if the DIE does not have a</span>
<a name="l08372"></a>08372 <span class="comment">   name.</span>
<a name="l08373"></a>08373 <span class="comment"></span>
<a name="l08374"></a>08374 <span class="comment">   The output string will be canonicalized (if C++/Java).  */</span>
<a name="l08375"></a>08375 
<a name="l08376"></a>08376 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l08377"></a><a class="code" href="dwarf2read_8c.html#a94813a9fc414b7ba920cdcee76b34d36">08377</a> <a class="code" href="dwarf2read_8c.html#a94813a9fc414b7ba920cdcee76b34d36">dwarf2_physname</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l08378"></a>08378 {
<a name="l08379"></a>08379   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l08380"></a>08380   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l08381"></a>08381   <span class="keyword">const</span> <span class="keywordtype">char</span> *retval, *<a class="code" href="gdbtk-cmds_8c.html#a0d5e78a09c3b8256a302e447db9b2324">mangled</a> = NULL, *canon = NULL;
<a name="l08382"></a>08382   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to;
<a name="l08383"></a>08383   <span class="keywordtype">int</span> need_copy = 1;
<a name="l08384"></a>08384 
<a name="l08385"></a>08385   <span class="comment">/* In this case dwarf2_compute_name is just a shortcut not building anything</span>
<a name="l08386"></a>08386 <span class="comment">     on its own.  */</span>
<a name="l08387"></a>08387   <span class="keywordflow">if</span> (!<a class="code" href="dwarf2read_8c.html#ad98511f088c664e1e170abf8cbe456e3">die_needs_namespace</a> (die, cu))
<a name="l08388"></a>08388     <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#acec9955a884b630c43434507ebf27eff">dwarf2_compute_name</a> (name, die, cu, 1);
<a name="l08389"></a>08389 
<a name="l08390"></a>08390   back_to = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, NULL);
<a name="l08391"></a>08391 
<a name="l08392"></a>08392   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_linkage_name, cu);
<a name="l08393"></a>08393   <span class="keywordflow">if</span> (!attr)
<a name="l08394"></a>08394     attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_MIPS_linkage_name, cu);
<a name="l08395"></a>08395 
<a name="l08396"></a>08396   <span class="comment">/* DW_AT_linkage_name is missing in some cases - depend on what GDB</span>
<a name="l08397"></a>08397 <span class="comment">     has computed.  */</span>
<a name="l08398"></a>08398   <span class="keywordflow">if</span> (attr &amp;&amp; <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr))
<a name="l08399"></a>08399     {
<a name="l08400"></a>08400       <span class="keywordtype">char</span> *demangled;
<a name="l08401"></a>08401 
<a name="l08402"></a>08402       mangled = <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr);
<a name="l08403"></a>08403 
<a name="l08404"></a>08404       <span class="comment">/* Use DMGL_RET_DROP for C++ template functions to suppress their return</span>
<a name="l08405"></a>08405 <span class="comment">         type.  It is easier for GDB users to search for such functions as</span>
<a name="l08406"></a>08406 <span class="comment">         `name(params)&#39; than `long name(params)&#39;.  In such case the minimal</span>
<a name="l08407"></a>08407 <span class="comment">         symbol names do not match the full symbol names but for template</span>
<a name="l08408"></a>08408 <span class="comment">         functions there is never a need to look up their definition from their</span>
<a name="l08409"></a>08409 <span class="comment">         declaration so the only disadvantage remains the minimal symbol</span>
<a name="l08410"></a>08410 <span class="comment">         variant `long name(params)&#39; does not have the proper inferior type.</span>
<a name="l08411"></a>08411 <span class="comment">         */</span>
<a name="l08412"></a>08412 
<a name="l08413"></a>08413       <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a702bd2253975155cace46837f64a702a">language_go</a>)
<a name="l08414"></a>08414         {
<a name="l08415"></a>08415           <span class="comment">/* This is a lie, but we already lie to the caller new_symbol_full.</span>
<a name="l08416"></a>08416 <span class="comment">             new_symbol_full assumes we return the mangled name.</span>
<a name="l08417"></a>08417 <span class="comment">             This just undoes that lie until things are cleaned up.  */</span>
<a name="l08418"></a>08418           demangled = NULL;
<a name="l08419"></a>08419         }
<a name="l08420"></a>08420       <span class="keywordflow">else</span>
<a name="l08421"></a>08421         {
<a name="l08422"></a>08422           demangled = <a class="code" href="cp-support_8c.html#aa3fac1cb74e2709738e9ab3af7aac6b6">gdb_demangle</a> (mangled,
<a name="l08423"></a>08423                                     (DMGL_PARAMS | DMGL_ANSI
<a name="l08424"></a>08424                                      | (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>
<a name="l08425"></a>08425                                         ? DMGL_JAVA | DMGL_RET_POSTFIX
<a name="l08426"></a>08426                                         : DMGL_RET_DROP)));
<a name="l08427"></a>08427         }
<a name="l08428"></a>08428       <span class="keywordflow">if</span> (demangled)
<a name="l08429"></a>08429         {
<a name="l08430"></a>08430           <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, demangled);
<a name="l08431"></a>08431           canon = demangled;
<a name="l08432"></a>08432         }
<a name="l08433"></a>08433       <span class="keywordflow">else</span>
<a name="l08434"></a>08434         {
<a name="l08435"></a>08435           canon = <a class="code" href="gdbtk-cmds_8c.html#a0d5e78a09c3b8256a302e447db9b2324">mangled</a>;
<a name="l08436"></a>08436           need_copy = 0;
<a name="l08437"></a>08437         }
<a name="l08438"></a>08438     }
<a name="l08439"></a>08439 
<a name="l08440"></a>08440   <span class="keywordflow">if</span> (canon == NULL || <a class="code" href="dwarf2read_8c.html#ab19a913cb7d8473545da6cb3149bc1ad">check_physname</a>)
<a name="l08441"></a>08441     {
<a name="l08442"></a>08442       <span class="keyword">const</span> <span class="keywordtype">char</span> *physname = <a class="code" href="dwarf2read_8c.html#acec9955a884b630c43434507ebf27eff">dwarf2_compute_name</a> (name, die, cu, 1);
<a name="l08443"></a>08443 
<a name="l08444"></a>08444       <span class="keywordflow">if</span> (canon != NULL &amp;&amp; strcmp (physname, canon) != 0)
<a name="l08445"></a>08445         {
<a name="l08446"></a>08446           <span class="comment">/* It may not mean a bug in GDB.  The compiler could also</span>
<a name="l08447"></a>08447 <span class="comment">             compute DW_AT_linkage_name incorrectly.  But in such case</span>
<a name="l08448"></a>08448 <span class="comment">             GDB would need to be bug-to-bug compatible.  */</span>
<a name="l08449"></a>08449 
<a name="l08450"></a>08450           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l08451"></a>08451                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Computed physname &lt;%s&gt; does not match demangled &lt;%s&gt; &quot;</span>
<a name="l08452"></a>08452                        <span class="stringliteral">&quot;(from linkage &lt;%s&gt;) - DIE at 0x%x [in module %s]&quot;</span>),
<a name="l08453"></a>08453                      physname, canon, mangled, die-&gt;offset.sect_off,
<a name="l08454"></a>08454                      <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l08455"></a>08455 
<a name="l08456"></a>08456           <span class="comment">/* Prefer DW_AT_linkage_name (in the CANON form) - when it</span>
<a name="l08457"></a>08457 <span class="comment">             is available here - over computed PHYSNAME.  It is safer</span>
<a name="l08458"></a>08458 <span class="comment">             against both buggy GDB and buggy compilers.  */</span>
<a name="l08459"></a>08459 
<a name="l08460"></a>08460           retval = canon;
<a name="l08461"></a>08461         }
<a name="l08462"></a>08462       <span class="keywordflow">else</span>
<a name="l08463"></a>08463         {
<a name="l08464"></a>08464           retval = physname;
<a name="l08465"></a>08465           need_copy = 0;
<a name="l08466"></a>08466         }
<a name="l08467"></a>08467     }
<a name="l08468"></a>08468   <span class="keywordflow">else</span>
<a name="l08469"></a>08469     retval = canon;
<a name="l08470"></a>08470 
<a name="l08471"></a>08471   <span class="keywordflow">if</span> (need_copy)
<a name="l08472"></a>08472     retval = obstack_copy0 (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, retval, strlen (retval));
<a name="l08473"></a>08473 
<a name="l08474"></a>08474   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l08475"></a>08475   <span class="keywordflow">return</span> retval;
<a name="l08476"></a>08476 }
<a name="l08477"></a>08477 
<a name="l08478"></a>08478 <span class="comment">/* Read the import statement specified by the given die and record it.  */</span>
<a name="l08479"></a>08479 
<a name="l08480"></a>08480 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l08481"></a><a class="code" href="dwarf2read_8c.html#a3508f14002211278d9e4e0936a70f108">08481</a> <a class="code" href="dwarf2read_8c.html#a3508f14002211278d9e4e0936a70f108">read_import_statement</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l08482"></a>08482 {
<a name="l08483"></a>08483   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l08484"></a>08484   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *import_attr;
<a name="l08485"></a>08485   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *imported_die, *child_die;
<a name="l08486"></a>08486   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *imported_cu;
<a name="l08487"></a>08487   <span class="keyword">const</span> <span class="keywordtype">char</span> *imported_name;
<a name="l08488"></a>08488   <span class="keyword">const</span> <span class="keywordtype">char</span> *imported_name_prefix;
<a name="l08489"></a>08489   <span class="keyword">const</span> <span class="keywordtype">char</span> *canonical_name;
<a name="l08490"></a>08490   <span class="keyword">const</span> <span class="keywordtype">char</span> *import_alias;
<a name="l08491"></a>08491   <span class="keyword">const</span> <span class="keywordtype">char</span> *imported_declaration = NULL;
<a name="l08492"></a>08492   <span class="keyword">const</span> <span class="keywordtype">char</span> *import_prefix;
<a name="l08493"></a>08493   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>) *excludes = NULL;
<a name="l08494"></a>08494   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups;
<a name="l08495"></a>08495 
<a name="l08496"></a>08496   import_attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_import, cu);
<a name="l08497"></a>08497   <span class="keywordflow">if</span> (import_attr == NULL)
<a name="l08498"></a>08498     {
<a name="l08499"></a>08499       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Tag &#39;%s&#39; has no DW_AT_import&quot;</span>),
<a name="l08500"></a>08500                  <a class="code" href="dwarf2read_8c.html#af80d37a7ff366081b096550409d46e45">dwarf_tag_name</a> (die-&gt;tag));
<a name="l08501"></a>08501       <span class="keywordflow">return</span>;
<a name="l08502"></a>08502     }
<a name="l08503"></a>08503 
<a name="l08504"></a>08504   imported_cu = cu;
<a name="l08505"></a>08505   imported_die = <a class="code" href="dwarf2read_8c.html#a468c4b93171973f8c93dd21db4de1634">follow_die_ref_or_sig</a> (die, import_attr, &amp;imported_cu);
<a name="l08506"></a>08506   imported_name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (imported_die, imported_cu);
<a name="l08507"></a>08507   <span class="keywordflow">if</span> (imported_name == NULL)
<a name="l08508"></a>08508     {
<a name="l08509"></a>08509       <span class="comment">/* GCC bug: https://bugzilla.redhat.com/show_bug.cgi?id=506524</span>
<a name="l08510"></a>08510 <span class="comment"></span>
<a name="l08511"></a>08511 <span class="comment">        The import in the following code:</span>
<a name="l08512"></a>08512 <span class="comment">        namespace A</span>
<a name="l08513"></a>08513 <span class="comment">          {</span>
<a name="l08514"></a>08514 <span class="comment">            typedef int B;</span>
<a name="l08515"></a>08515 <span class="comment">          }</span>
<a name="l08516"></a>08516 <span class="comment"></span>
<a name="l08517"></a>08517 <span class="comment">        int main ()</span>
<a name="l08518"></a>08518 <span class="comment">          {</span>
<a name="l08519"></a>08519 <span class="comment">            using A::B;</span>
<a name="l08520"></a>08520 <span class="comment">            B b;</span>
<a name="l08521"></a>08521 <span class="comment">            return b;</span>
<a name="l08522"></a>08522 <span class="comment">          }</span>
<a name="l08523"></a>08523 <span class="comment"></span>
<a name="l08524"></a>08524 <span class="comment">        ...</span>
<a name="l08525"></a>08525 <span class="comment">         &lt;2&gt;&lt;51&gt;: Abbrev Number: 3 (DW_TAG_imported_declaration)</span>
<a name="l08526"></a>08526 <span class="comment">            &lt;52&gt;   DW_AT_decl_file   : 1</span>
<a name="l08527"></a>08527 <span class="comment">            &lt;53&gt;   DW_AT_decl_line   : 6</span>
<a name="l08528"></a>08528 <span class="comment">            &lt;54&gt;   DW_AT_import      : &lt;0x75&gt;</span>
<a name="l08529"></a>08529 <span class="comment">         &lt;2&gt;&lt;58&gt;: Abbrev Number: 4 (DW_TAG_typedef)</span>
<a name="l08530"></a>08530 <span class="comment">            &lt;59&gt;   DW_AT_name        : B</span>
<a name="l08531"></a>08531 <span class="comment">            &lt;5b&gt;   DW_AT_decl_file   : 1</span>
<a name="l08532"></a>08532 <span class="comment">            &lt;5c&gt;   DW_AT_decl_line   : 2</span>
<a name="l08533"></a>08533 <span class="comment">            &lt;5d&gt;   DW_AT_type        : &lt;0x6e&gt;</span>
<a name="l08534"></a>08534 <span class="comment">        ...</span>
<a name="l08535"></a>08535 <span class="comment">         &lt;1&gt;&lt;75&gt;: Abbrev Number: 7 (DW_TAG_base_type)</span>
<a name="l08536"></a>08536 <span class="comment">            &lt;76&gt;   DW_AT_byte_size   : 4</span>
<a name="l08537"></a>08537 <span class="comment">            &lt;77&gt;   DW_AT_encoding    : 5        (signed)</span>
<a name="l08538"></a>08538 <span class="comment"></span>
<a name="l08539"></a>08539 <span class="comment">        imports the wrong die ( 0x75 instead of 0x58 ).</span>
<a name="l08540"></a>08540 <span class="comment">        This case will be ignored until the gcc bug is fixed.  */</span>
<a name="l08541"></a>08541       <span class="keywordflow">return</span>;
<a name="l08542"></a>08542     }
<a name="l08543"></a>08543 
<a name="l08544"></a>08544   <span class="comment">/* Figure out the local name after import.  */</span>
<a name="l08545"></a>08545   import_alias = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l08546"></a>08546 
<a name="l08547"></a>08547   <span class="comment">/* Figure out where the statement is being imported to.  */</span>
<a name="l08548"></a>08548   import_prefix = <a class="code" href="dwarf2read_8c.html#a2417ea09b6b125e47a255352f662e856">determine_prefix</a> (die, cu);
<a name="l08549"></a>08549 
<a name="l08550"></a>08550   <span class="comment">/* Figure out what the scope of the imported die is and prepend it</span>
<a name="l08551"></a>08551 <span class="comment">     to the name of the imported die.  */</span>
<a name="l08552"></a>08552   imported_name_prefix = <a class="code" href="dwarf2read_8c.html#a2417ea09b6b125e47a255352f662e856">determine_prefix</a> (imported_die, imported_cu);
<a name="l08553"></a>08553 
<a name="l08554"></a>08554   <span class="keywordflow">if</span> (imported_die-&gt;tag != DW_TAG_namespace
<a name="l08555"></a>08555       &amp;&amp; imported_die-&gt;tag != DW_TAG_module)
<a name="l08556"></a>08556     {
<a name="l08557"></a>08557       imported_declaration = imported_name;
<a name="l08558"></a>08558       canonical_name = imported_name_prefix;
<a name="l08559"></a>08559     }
<a name="l08560"></a>08560   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strlen (imported_name_prefix) &gt; 0)
<a name="l08561"></a>08561     canonical_name = <a class="code" href="gdb__obstack_8c.html#acb9aae13bbc489afdf51994a923ef45a">obconcat</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l08562"></a>08562                                imported_name_prefix, <span class="stringliteral">&quot;::&quot;</span>, imported_name,
<a name="l08563"></a>08563                                (<span class="keywordtype">char</span> *) NULL);
<a name="l08564"></a>08564   <span class="keywordflow">else</span>
<a name="l08565"></a>08565     canonical_name = imported_name;
<a name="l08566"></a>08566 
<a name="l08567"></a>08567   cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="vec_8h.html#a92a6114eb727b9274e1523d0e9dd2e61">VEC_cleanup</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>), &amp;excludes);
<a name="l08568"></a>08568 
<a name="l08569"></a>08569   <span class="keywordflow">if</span> (die-&gt;tag == DW_TAG_imported_module &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>)
<a name="l08570"></a>08570     <span class="keywordflow">for</span> (child_die = die-&gt;child; child_die &amp;&amp; child_die-&gt;tag;
<a name="l08571"></a>08571          child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die))
<a name="l08572"></a>08572       {
<a name="l08573"></a>08573         <span class="comment">/* DWARF-4: A Fortran use statement with a “rename list” may be</span>
<a name="l08574"></a>08574 <span class="comment">           represented by an imported module entry with an import attribute</span>
<a name="l08575"></a>08575 <span class="comment">           referring to the module and owned entries corresponding to those</span>
<a name="l08576"></a>08576 <span class="comment">           entities that are renamed as part of being imported.  */</span>
<a name="l08577"></a>08577 
<a name="l08578"></a>08578         <span class="keywordflow">if</span> (child_die-&gt;tag != DW_TAG_imported_declaration)
<a name="l08579"></a>08579           {
<a name="l08580"></a>08580             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l08581"></a>08581                        <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;child DW_TAG_imported_declaration expected &quot;</span>
<a name="l08582"></a>08582                          <span class="stringliteral">&quot;- DIE at 0x%x [in module %s]&quot;</span>),
<a name="l08583"></a>08583                        child_die-&gt;offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l08584"></a>08584             <span class="keywordflow">continue</span>;
<a name="l08585"></a>08585           }
<a name="l08586"></a>08586 
<a name="l08587"></a>08587         import_attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (child_die, DW_AT_import, cu);
<a name="l08588"></a>08588         <span class="keywordflow">if</span> (import_attr == NULL)
<a name="l08589"></a>08589           {
<a name="l08590"></a>08590             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Tag &#39;%s&#39; has no DW_AT_import&quot;</span>),
<a name="l08591"></a>08591                        <a class="code" href="dwarf2read_8c.html#af80d37a7ff366081b096550409d46e45">dwarf_tag_name</a> (child_die-&gt;tag));
<a name="l08592"></a>08592             <span class="keywordflow">continue</span>;
<a name="l08593"></a>08593           }
<a name="l08594"></a>08594 
<a name="l08595"></a>08595         imported_cu = cu;
<a name="l08596"></a>08596         imported_die = <a class="code" href="dwarf2read_8c.html#a468c4b93171973f8c93dd21db4de1634">follow_die_ref_or_sig</a> (child_die, import_attr,
<a name="l08597"></a>08597                                               &amp;imported_cu);
<a name="l08598"></a>08598         imported_name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (imported_die, imported_cu);
<a name="l08599"></a>08599         <span class="keywordflow">if</span> (imported_name == NULL)
<a name="l08600"></a>08600           {
<a name="l08601"></a>08601             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l08602"></a>08602                        <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;child DW_TAG_imported_declaration has unknown &quot;</span>
<a name="l08603"></a>08603                          <span class="stringliteral">&quot;imported name - DIE at 0x%x [in module %s]&quot;</span>),
<a name="l08604"></a>08604                        child_die-&gt;offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l08605"></a>08605             <span class="keywordflow">continue</span>;
<a name="l08606"></a>08606           }
<a name="l08607"></a>08607 
<a name="l08608"></a>08608         <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>, excludes, imported_name);
<a name="l08609"></a>08609 
<a name="l08610"></a>08610         <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (child_die, cu);
<a name="l08611"></a>08611       }
<a name="l08612"></a>08612 
<a name="l08613"></a>08613   <a class="code" href="cp-namespace_8c.html#ae89c5f43ecc5264975c8e52ca57f58ef">cp_add_using_directive</a> (import_prefix,
<a name="l08614"></a>08614                           canonical_name,
<a name="l08615"></a>08615                           import_alias,
<a name="l08616"></a>08616                           imported_declaration,
<a name="l08617"></a>08617                           excludes,
<a name="l08618"></a>08618                           0,
<a name="l08619"></a>08619                           &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>);
<a name="l08620"></a>08620 
<a name="l08621"></a>08621   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l08622"></a>08622 }
<a name="l08623"></a>08623 
<a name="l08624"></a>08624 <span class="comment">/* Cleanup function for handle_DW_AT_stmt_list.  */</span>
<a name="l08625"></a>08625 
<a name="l08626"></a>08626 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l08627"></a><a class="code" href="dwarf2read_8c.html#ad60d01972d55938bf46efc8e388212f3">08627</a> <a class="code" href="dwarf2read_8c.html#ad60d01972d55938bf46efc8e388212f3">free_cu_line_header</a> (<span class="keywordtype">void</span> *<a class="code" href="structcleanup.html#a10b494058e88a8972633026b5fa3873f">arg</a>)
<a name="l08628"></a>08628 {
<a name="l08629"></a>08629   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = arg;
<a name="l08630"></a>08630 
<a name="l08631"></a>08631   <a class="code" href="dwarf2read_8c.html#a2b16344b24303ef21765208ef32dfe7a">free_line_header</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a94864e6f22ffa7350c883da402931b99">line_header</a>);
<a name="l08632"></a>08632   cu-&gt;<a class="code" href="structdwarf2__cu.html#a94864e6f22ffa7350c883da402931b99">line_header</a> = NULL;
<a name="l08633"></a>08633 }
<a name="l08634"></a>08634 
<a name="l08635"></a>08635 <span class="comment">/* Check for possibly missing DW_AT_comp_dir with relative .debug_line</span>
<a name="l08636"></a>08636 <span class="comment">   directory paths.  GCC SVN r127613 (new option -fdebug-prefix-map) fixed</span>
<a name="l08637"></a>08637 <span class="comment">   this, it was first present in GCC release 4.3.0.  */</span>
<a name="l08638"></a>08638 
<a name="l08639"></a>08639 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l08640"></a><a class="code" href="dwarf2read_8c.html#a9dba089a951f33a1f8bf686aaf189554">08640</a> <a class="code" href="dwarf2read_8c.html#a9dba089a951f33a1f8bf686aaf189554">producer_is_gcc_lt_4_3</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l08641"></a>08641 {
<a name="l08642"></a>08642   <span class="keywordflow">if</span> (!cu-&gt;checked_producer)
<a name="l08643"></a>08643     <a class="code" href="dwarf2read_8c.html#a41cd805d939c553f1679638639f7102b">check_producer</a> (cu);
<a name="l08644"></a>08644 
<a name="l08645"></a>08645   <span class="keywordflow">return</span> cu-&gt;producer_is_gcc_lt_4_3;
<a name="l08646"></a>08646 }
<a name="l08647"></a>08647 
<a name="l08648"></a>08648 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l08649"></a><a class="code" href="dwarf2read_8c.html#a4c82b37187098b652b568563271a15a3">08649</a> <a class="code" href="dwarf2read_8c.html#a4c82b37187098b652b568563271a15a3">find_file_and_directory</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l08650"></a>08650                          <span class="keyword">const</span> <span class="keywordtype">char</span> **name, <span class="keyword">const</span> <span class="keywordtype">char</span> **comp_dir)
<a name="l08651"></a>08651 {
<a name="l08652"></a>08652   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l08653"></a>08653 
<a name="l08654"></a>08654   *name = NULL;
<a name="l08655"></a>08655   *comp_dir = NULL;
<a name="l08656"></a>08656 
<a name="l08657"></a>08657   <span class="comment">/* Find the filename.  Do not use dwarf2_name here, since the filename</span>
<a name="l08658"></a>08658 <span class="comment">     is not a source language identifier.  */</span>
<a name="l08659"></a>08659   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_name, cu);
<a name="l08660"></a>08660   <span class="keywordflow">if</span> (attr)
<a name="l08661"></a>08661     {
<a name="l08662"></a>08662       *name = <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr);
<a name="l08663"></a>08663     }
<a name="l08664"></a>08664 
<a name="l08665"></a>08665   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_comp_dir, cu);
<a name="l08666"></a>08666   <span class="keywordflow">if</span> (attr)
<a name="l08667"></a>08667     *comp_dir = <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr);
<a name="l08668"></a>08668   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a9dba089a951f33a1f8bf686aaf189554">producer_is_gcc_lt_4_3</a> (cu) &amp;&amp; *name != NULL
<a name="l08669"></a>08669            &amp;&amp; IS_ABSOLUTE_PATH (*name))
<a name="l08670"></a>08670     {
<a name="l08671"></a>08671       <span class="keywordtype">char</span> *d = <a class="code" href="utils_8c.html#a0f0f0c3f49b0f3bcc136eaf5d30024a3">ldirname</a> (*name);
<a name="l08672"></a>08672 
<a name="l08673"></a>08673       *comp_dir = d;
<a name="l08674"></a>08674       <span class="keywordflow">if</span> (d != NULL)
<a name="l08675"></a>08675         <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, d);
<a name="l08676"></a>08676     }
<a name="l08677"></a>08677   <span class="keywordflow">if</span> (*comp_dir != NULL)
<a name="l08678"></a>08678     {
<a name="l08679"></a>08679       <span class="comment">/* Irix 6.2 native cc prepends &lt;machine&gt;.: to the compilation</span>
<a name="l08680"></a>08680 <span class="comment">         directory, get rid of it.  */</span>
<a name="l08681"></a>08681       <span class="keywordtype">char</span> *cp = <a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (*comp_dir, <span class="charliteral">&#39;:&#39;</span>);
<a name="l08682"></a>08682 
<a name="l08683"></a>08683       <span class="keywordflow">if</span> (cp &amp;&amp; cp != *comp_dir &amp;&amp; cp[-1] == <span class="charliteral">&#39;.&#39;</span> &amp;&amp; cp[1] == <span class="charliteral">&#39;/&#39;</span>)
<a name="l08684"></a>08684         *comp_dir = cp + 1;
<a name="l08685"></a>08685     }
<a name="l08686"></a>08686 
<a name="l08687"></a>08687   <span class="keywordflow">if</span> (*name == NULL)
<a name="l08688"></a>08688     *name = <span class="stringliteral">&quot;&lt;unknown&gt;&quot;</span>;
<a name="l08689"></a>08689 }
<a name="l08690"></a>08690 
<a name="l08691"></a>08691 <span class="comment">/* Handle DW_AT_stmt_list for a compilation unit.</span>
<a name="l08692"></a>08692 <span class="comment">   DIE is the DW_TAG_compile_unit die for CU.</span>
<a name="l08693"></a>08693 <span class="comment">   COMP_DIR is the compilation directory.</span>
<a name="l08694"></a>08694 <span class="comment">   WANT_LINE_INFO is non-zero if the pc/line-number mapping is needed.  */</span>
<a name="l08695"></a>08695 
<a name="l08696"></a>08696 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l08697"></a><a class="code" href="dwarf2read_8c.html#a082d0e0819f05221512997c58f41435e">08697</a> <a class="code" href="dwarf2read_8c.html#a082d0e0819f05221512997c58f41435e">handle_DW_AT_stmt_list</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l08698"></a>08698                         <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir) <span class="comment">/* ARI: editCase function */</span>
<a name="l08699"></a>08699 {
<a name="l08700"></a>08700   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l08701"></a>08701 
<a name="l08702"></a>08702   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (! cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l08703"></a>08703 
<a name="l08704"></a>08704   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_stmt_list, cu);
<a name="l08705"></a>08705   <span class="keywordflow">if</span> (attr)
<a name="l08706"></a>08706     {
<a name="l08707"></a>08707       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structline__offset.html">line_offset</a> = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l08708"></a>08708       <span class="keyword">struct </span><a class="code" href="structline__header.html">line_header</a> *<a class="code" href="structline__header.html">line_header</a>
<a name="l08709"></a>08709         = <a class="code" href="dwarf2read_8c.html#af87c579a0baccecf09b54fc18af2dea5">dwarf_decode_line_header</a> (line_offset, cu);
<a name="l08710"></a>08710 
<a name="l08711"></a>08711       <span class="keywordflow">if</span> (line_header)
<a name="l08712"></a>08712         {
<a name="l08713"></a>08713           cu-&gt;<a class="code" href="structdwarf2__cu.html#a94864e6f22ffa7350c883da402931b99">line_header</a> = line_header;
<a name="l08714"></a>08714           <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#ad60d01972d55938bf46efc8e388212f3">free_cu_line_header</a>, cu);
<a name="l08715"></a>08715           <a class="code" href="dwarf2read_8c.html#af810de33caeeaf4969d37ee378ef6e06">dwarf_decode_lines</a> (line_header, comp_dir, cu, NULL, 1);
<a name="l08716"></a>08716         }
<a name="l08717"></a>08717     }
<a name="l08718"></a>08718 }
<a name="l08719"></a>08719 
<a name="l08720"></a>08720 <span class="comment">/* Process DW_TAG_compile_unit or DW_TAG_partial_unit.  */</span>
<a name="l08721"></a>08721 
<a name="l08722"></a>08722 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l08723"></a><a class="code" href="dwarf2read_8c.html#a9126a0189849660b1db747863dafb0bf">08723</a> <a class="code" href="dwarf2read_8c.html#a9126a0189849660b1db747863dafb0bf">read_file_scope</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l08724"></a>08724 {
<a name="l08725"></a>08725   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l08726"></a>08726   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, 0);
<a name="l08727"></a>08727   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> lowpc = ((<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) -1);
<a name="l08728"></a>08728   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> highpc = ((<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 0);
<a name="l08729"></a>08729   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l08730"></a>08730   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = NULL;
<a name="l08731"></a>08731   <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir = NULL;
<a name="l08732"></a>08732   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_die;
<a name="l08733"></a>08733   bfd *abfd = objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>;
<a name="l08734"></a>08734   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> baseaddr;
<a name="l08735"></a>08735 
<a name="l08736"></a>08736   baseaddr = <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>, <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l08737"></a>08737 
<a name="l08738"></a>08738   <a class="code" href="dwarf2read_8c.html#aa7a89cfc9f4650dde9ef152c70edbe41">get_scope_pc_bounds</a> (die, &amp;lowpc, &amp;highpc, cu);
<a name="l08739"></a>08739 
<a name="l08740"></a>08740   <span class="comment">/* If we didn&#39;t find a lowpc, set it to highpc to avoid complaints</span>
<a name="l08741"></a>08741 <span class="comment">     from finish_block.  */</span>
<a name="l08742"></a>08742   <span class="keywordflow">if</span> (lowpc == ((<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) -1))
<a name="l08743"></a>08743     lowpc = highpc;
<a name="l08744"></a>08744   lowpc += baseaddr;
<a name="l08745"></a>08745   highpc += baseaddr;
<a name="l08746"></a>08746 
<a name="l08747"></a>08747   <a class="code" href="dwarf2read_8c.html#a4c82b37187098b652b568563271a15a3">find_file_and_directory</a> (die, cu, &amp;name, &amp;comp_dir);
<a name="l08748"></a>08748 
<a name="l08749"></a>08749   <a class="code" href="dwarf2read_8c.html#a7a6cb8459a76588ce7ef6a56b19ef5c8">prepare_one_comp_unit</a> (cu, die, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>);
<a name="l08750"></a>08750 
<a name="l08751"></a>08751   <span class="comment">/* The XLCL doesn&#39;t generate DW_LANG_OpenCL because this attribute is not</span>
<a name="l08752"></a>08752 <span class="comment">     standardised yet.  As a workaround for the language detection we fall</span>
<a name="l08753"></a>08753 <span class="comment">     back to the DW_AT_producer string.  */</span>
<a name="l08754"></a>08754   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a> &amp;&amp; <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>, <span class="stringliteral">&quot;IBM XL C for OpenCL&quot;</span>) != NULL)
<a name="l08755"></a>08755     cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202aa5694c5df3b3a3f33d68b2b7f7d279fb">language_opencl</a>;
<a name="l08756"></a>08756 
<a name="l08757"></a>08757   <span class="comment">/* Similar hack for Go.  */</span>
<a name="l08758"></a>08758   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a> &amp;&amp; <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>, <span class="stringliteral">&quot;GNU Go &quot;</span>) != NULL)
<a name="l08759"></a>08759     <a class="code" href="dwarf2read_8c.html#abd567fd6ea120b361c1b04ce7c20ea54">set_cu_language</a> (DW_LANG_Go, cu);
<a name="l08760"></a>08760 
<a name="l08761"></a>08761   <a class="code" href="dwarf2read_8c.html#a6682d90849e89e7ce892ec7d58cf4c9c">dwarf2_start_symtab</a> (cu, name, comp_dir, lowpc);
<a name="l08762"></a>08762 
<a name="l08763"></a>08763   <span class="comment">/* Decode line number information if present.  We do this before</span>
<a name="l08764"></a>08764 <span class="comment">     processing child DIEs, so that the line header table is available</span>
<a name="l08765"></a>08765 <span class="comment">     for DW_AT_decl_file.  */</span>
<a name="l08766"></a>08766   <a class="code" href="dwarf2read_8c.html#a082d0e0819f05221512997c58f41435e">handle_DW_AT_stmt_list</a> (die, cu, comp_dir);
<a name="l08767"></a>08767 
<a name="l08768"></a>08768   <span class="comment">/* Process all dies in compilation unit.  */</span>
<a name="l08769"></a>08769   <span class="keywordflow">if</span> (die-&gt;child != NULL)
<a name="l08770"></a>08770     {
<a name="l08771"></a>08771       child_die = die-&gt;child;
<a name="l08772"></a>08772       <span class="keywordflow">while</span> (child_die &amp;&amp; child_die-&gt;tag)
<a name="l08773"></a>08773         {
<a name="l08774"></a>08774           <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (child_die, cu);
<a name="l08775"></a>08775           child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l08776"></a>08776         }
<a name="l08777"></a>08777     }
<a name="l08778"></a>08778 
<a name="l08779"></a>08779   <span class="comment">/* Decode macro information, if present.  Dwarf 2 macro information</span>
<a name="l08780"></a>08780 <span class="comment">     refers to information in the line number info statement program</span>
<a name="l08781"></a>08781 <span class="comment">     header, so we can only read it if we&#39;ve read the header</span>
<a name="l08782"></a>08782 <span class="comment">     successfully.  */</span>
<a name="l08783"></a>08783   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_GNU_macros, cu);
<a name="l08784"></a>08784   <span class="keywordflow">if</span> (attr &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#a94864e6f22ffa7350c883da402931b99">line_header</a>)
<a name="l08785"></a>08785     {
<a name="l08786"></a>08786       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_macro_info, cu))
<a name="l08787"></a>08787         <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l08788"></a>08788                    <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;CU refers to both DW_AT_GNU_macros and DW_AT_macro_info&quot;</span>));
<a name="l08789"></a>08789 
<a name="l08790"></a>08790       <a class="code" href="dwarf2read_8c.html#ab19576b4a3ebec0b3a1e723523f2e072">dwarf_decode_macros</a> (cu, <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr), comp_dir, 1);
<a name="l08791"></a>08791     }
<a name="l08792"></a>08792   <span class="keywordflow">else</span>
<a name="l08793"></a>08793     {
<a name="l08794"></a>08794       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_macro_info, cu);
<a name="l08795"></a>08795       <span class="keywordflow">if</span> (attr &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#a94864e6f22ffa7350c883da402931b99">line_header</a>)
<a name="l08796"></a>08796         {
<a name="l08797"></a>08797           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> macro_offset = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l08798"></a>08798 
<a name="l08799"></a>08799           <a class="code" href="dwarf2read_8c.html#ab19576b4a3ebec0b3a1e723523f2e072">dwarf_decode_macros</a> (cu, macro_offset, comp_dir, 0);
<a name="l08800"></a>08800         }
<a name="l08801"></a>08801     }
<a name="l08802"></a>08802 
<a name="l08803"></a>08803   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l08804"></a>08804 }
<a name="l08805"></a>08805 
<a name="l08806"></a>08806 <span class="comment">/* TU version of handle_DW_AT_stmt_list for read_type_unit_scope.</span>
<a name="l08807"></a>08807 <span class="comment">   Create the set of symtabs used by this TU, or if this TU is sharing</span>
<a name="l08808"></a>08808 <span class="comment">   symtabs with another TU and the symtabs have already been created</span>
<a name="l08809"></a>08809 <span class="comment">   then restore those symtabs in the line header.</span>
<a name="l08810"></a>08810 <span class="comment">   We don&#39;t need the pc/line-number mapping for type units.  */</span>
<a name="l08811"></a>08811 
<a name="l08812"></a>08812 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l08813"></a><a class="code" href="dwarf2read_8c.html#ad2297a459d813fc3e726410836bf1f8e">08813</a> <a class="code" href="dwarf2read_8c.html#ad2297a459d813fc3e726410836bf1f8e">setup_type_unit_groups</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l08814"></a>08814 {
<a name="l08815"></a>08815   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l08816"></a>08816   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;
<a name="l08817"></a>08817   <span class="keyword">struct </span><a class="code" href="structtype__unit__group.html">type_unit_group</a> *tu_group;
<a name="l08818"></a>08818   <span class="keywordtype">int</span> <a class="code" href="monitor_8c.html#a2251ba55279aef307357d4b82d7cffb7">first_time</a>;
<a name="l08819"></a>08819   <span class="keyword">struct </span><a class="code" href="structline__header.html">line_header</a> *lh;
<a name="l08820"></a>08820   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l08821"></a>08821   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, <a class="code" href="structline__offset.html">line_offset</a>;
<a name="l08822"></a>08822   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type;
<a name="l08823"></a>08823 
<a name="l08824"></a>08824   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l08825"></a>08825   sig_type = (<span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *) per_cu;
<a name="l08826"></a>08826 
<a name="l08827"></a>08827   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_stmt_list, cu);
<a name="l08828"></a>08828 
<a name="l08829"></a>08829   <span class="comment">/* If we&#39;re using .gdb_index (includes -readnow) then</span>
<a name="l08830"></a>08830 <span class="comment">     per_cu-&gt;type_unit_group may not have been set up yet.  */</span>
<a name="l08831"></a>08831   <span class="keywordflow">if</span> (sig_type-&gt;<a class="code" href="structsignatured__type.html#ab10f6f2df0f7691aa8ca948e28cbcf1e">type_unit_group</a> == NULL)
<a name="l08832"></a>08832     sig_type-&gt;<a class="code" href="structsignatured__type.html#ab10f6f2df0f7691aa8ca948e28cbcf1e">type_unit_group</a> = <a class="code" href="dwarf2read_8c.html#a32cdecdad4aa06e351612fb574d1c638">get_type_unit_group</a> (cu, attr);
<a name="l08833"></a>08833   tu_group = sig_type-&gt;<a class="code" href="structsignatured__type.html#ab10f6f2df0f7691aa8ca948e28cbcf1e">type_unit_group</a>;
<a name="l08834"></a>08834 
<a name="l08835"></a>08835   <span class="comment">/* If we&#39;ve already processed this stmt_list there&#39;s no real need to</span>
<a name="l08836"></a>08836 <span class="comment">     do it again, we could fake it and just recreate the part we need</span>
<a name="l08837"></a>08837 <span class="comment">     (file name,index -&gt; symtab mapping).  If data shows this optimization</span>
<a name="l08838"></a>08838 <span class="comment">     is useful we can do it then.  */</span>
<a name="l08839"></a>08839   first_time = tu_group-&gt;primary_symtab == NULL;
<a name="l08840"></a>08840 
<a name="l08841"></a>08841   <span class="comment">/* We have to handle the case of both a missing DW_AT_stmt_list or bad</span>
<a name="l08842"></a>08842 <span class="comment">     debug info.  */</span>
<a name="l08843"></a>08843   lh = NULL;
<a name="l08844"></a>08844   <span class="keywordflow">if</span> (attr != NULL)
<a name="l08845"></a>08845     {
<a name="l08846"></a>08846       line_offset = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l08847"></a>08847       lh = <a class="code" href="dwarf2read_8c.html#af87c579a0baccecf09b54fc18af2dea5">dwarf_decode_line_header</a> (line_offset, cu);
<a name="l08848"></a>08848     }
<a name="l08849"></a>08849   <span class="keywordflow">if</span> (lh == NULL)
<a name="l08850"></a>08850     {
<a name="l08851"></a>08851       <span class="keywordflow">if</span> (first_time)
<a name="l08852"></a>08852         <a class="code" href="dwarf2read_8c.html#a6682d90849e89e7ce892ec7d58cf4c9c">dwarf2_start_symtab</a> (cu, <span class="stringliteral">&quot;&quot;</span>, NULL, 0);
<a name="l08853"></a>08853       <span class="keywordflow">else</span>
<a name="l08854"></a>08854         {
<a name="l08855"></a>08855           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (tu_group-&gt;symtabs == NULL);
<a name="l08856"></a>08856           <a class="code" href="buildsym_8c.html#a9128031efbed369335ecd5ccb0bcdbf7">restart_symtab</a> (0);
<a name="l08857"></a>08857         }
<a name="l08858"></a>08858       <span class="comment">/* Note: The primary symtab will get allocated at the end.  */</span>
<a name="l08859"></a>08859       <span class="keywordflow">return</span>;
<a name="l08860"></a>08860     }
<a name="l08861"></a>08861 
<a name="l08862"></a>08862   cu-&gt;<a class="code" href="structdwarf2__cu.html#a94864e6f22ffa7350c883da402931b99">line_header</a> = lh;
<a name="l08863"></a>08863   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#ad60d01972d55938bf46efc8e388212f3">free_cu_line_header</a>, cu);
<a name="l08864"></a>08864 
<a name="l08865"></a>08865   <span class="keywordflow">if</span> (first_time)
<a name="l08866"></a>08866     {
<a name="l08867"></a>08867       <a class="code" href="dwarf2read_8c.html#a6682d90849e89e7ce892ec7d58cf4c9c">dwarf2_start_symtab</a> (cu, <span class="stringliteral">&quot;&quot;</span>, NULL, 0);
<a name="l08868"></a>08868 
<a name="l08869"></a>08869       tu_group-&gt;num_symtabs = lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a>;
<a name="l08870"></a>08870       tu_group-&gt;symtabs = XNEWVEC (<span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *, lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a>);
<a name="l08871"></a>08871 
<a name="l08872"></a>08872       <span class="keywordflow">for</span> (i = 0; i &lt; lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a>; ++i)
<a name="l08873"></a>08873         {
<a name="l08874"></a>08874           <span class="keyword">const</span> <span class="keywordtype">char</span> *dir = NULL;
<a name="l08875"></a>08875           <span class="keyword">struct </span>file_entry *fe = &amp;lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>[i];
<a name="l08876"></a>08876 
<a name="l08877"></a>08877           <span class="keywordflow">if</span> (fe-&gt;dir_index)
<a name="l08878"></a>08878             dir = lh-&gt;<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a>[fe-&gt;dir_index - 1];
<a name="l08879"></a>08879           <a class="code" href="dwarf2read_8c.html#ad6fdb87bbae94e6e0f3b4e9f46b15182">dwarf2_start_subfile</a> (fe-&gt;name, dir, NULL);
<a name="l08880"></a>08880 
<a name="l08881"></a>08881           <span class="comment">/* Note: We don&#39;t have to watch for the main subfile here, type units</span>
<a name="l08882"></a>08882 <span class="comment">             don&#39;t have DW_AT_name.  */</span>
<a name="l08883"></a>08883 
<a name="l08884"></a>08884           <span class="keywordflow">if</span> (<a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>-&gt;<a class="code" href="structsubfile.html#ae436710af72b07723aff5356c99f2165">symtab</a> == NULL)
<a name="l08885"></a>08885             {
<a name="l08886"></a>08886               <span class="comment">/* NOTE: start_subfile will recognize when it&#39;s been passed</span>
<a name="l08887"></a>08887 <span class="comment">                 a file it has already seen.  So we can&#39;t assume there&#39;s a</span>
<a name="l08888"></a>08888 <span class="comment">                 simple mapping from lh-&gt;file_names to subfiles,</span>
<a name="l08889"></a>08889 <span class="comment">                 lh-&gt;file_names may contain dups.  */</span>
<a name="l08890"></a>08890               <a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>-&gt;<a class="code" href="structsubfile.html#ae436710af72b07723aff5356c99f2165">symtab</a> = <a class="code" href="symfile_8c.html#aafc3cce0320aaa35c9037f78fe662a7b">allocate_symtab</a> (<a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>-&gt;<a class="code" href="structsubfile.html#abeea2b58c088097522289f83a3164d77">name</a>,
<a name="l08891"></a>08891                                                          objfile);
<a name="l08892"></a>08892             }
<a name="l08893"></a>08893 
<a name="l08894"></a>08894           fe-&gt;symtab = <a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>-&gt;<a class="code" href="structsubfile.html#ae436710af72b07723aff5356c99f2165">symtab</a>;
<a name="l08895"></a>08895           tu_group-&gt;symtabs[i] = fe-&gt;symtab;
<a name="l08896"></a>08896         }
<a name="l08897"></a>08897     }
<a name="l08898"></a>08898   <span class="keywordflow">else</span>
<a name="l08899"></a>08899     {
<a name="l08900"></a>08900       <a class="code" href="buildsym_8c.html#a9128031efbed369335ecd5ccb0bcdbf7">restart_symtab</a> (0);
<a name="l08901"></a>08901 
<a name="l08902"></a>08902       <span class="keywordflow">for</span> (i = 0; i &lt; lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a>; ++i)
<a name="l08903"></a>08903         {
<a name="l08904"></a>08904           <span class="keyword">struct </span>file_entry *fe = &amp;lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>[i];
<a name="l08905"></a>08905 
<a name="l08906"></a>08906           fe-&gt;<a class="code" href="structline__header_1_1file__entry.html#af5f03277ff57c007ec3d1908999bf057">symtab</a> = tu_group-&gt;symtabs[i];
<a name="l08907"></a>08907         }
<a name="l08908"></a>08908     }
<a name="l08909"></a>08909 
<a name="l08910"></a>08910   <span class="comment">/* The main symtab is allocated last.  Type units don&#39;t have DW_AT_name</span>
<a name="l08911"></a>08911 <span class="comment">     so they don&#39;t have a &quot;real&quot; (so to speak) symtab anyway.</span>
<a name="l08912"></a>08912 <span class="comment">     There is later code that will assign the main symtab to all symbols</span>
<a name="l08913"></a>08913 <span class="comment">     that don&#39;t have one.  We need to handle the case of a symbol with a</span>
<a name="l08914"></a>08914 <span class="comment">     missing symtab (DW_AT_decl_file) anyway.  */</span>
<a name="l08915"></a>08915 }
<a name="l08916"></a>08916 
<a name="l08917"></a>08917 <span class="comment">/* Process DW_TAG_type_unit.</span>
<a name="l08918"></a>08918 <span class="comment">   For TUs we want to skip the first top level sibling if it&#39;s not the</span>
<a name="l08919"></a>08919 <span class="comment">   actual type being defined by this TU.  In this case the first top</span>
<a name="l08920"></a>08920 <span class="comment">   level sibling is there to provide context only.  */</span>
<a name="l08921"></a>08921 
<a name="l08922"></a>08922 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l08923"></a><a class="code" href="dwarf2read_8c.html#a40896e3030e32e5b5e08e57a5536723e">08923</a> <a class="code" href="dwarf2read_8c.html#a40896e3030e32e5b5e08e57a5536723e">read_type_unit_scope</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l08924"></a>08924 {
<a name="l08925"></a>08925   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_die;
<a name="l08926"></a>08926 
<a name="l08927"></a>08927   <a class="code" href="dwarf2read_8c.html#a7a6cb8459a76588ce7ef6a56b19ef5c8">prepare_one_comp_unit</a> (cu, die, <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a389b59241274e837cb0d28b1909013ac">language_minimal</a>);
<a name="l08928"></a>08928 
<a name="l08929"></a>08929   <span class="comment">/* Initialize (or reinitialize) the machinery for building symtabs.</span>
<a name="l08930"></a>08930 <span class="comment">     We do this before processing child DIEs, so that the line header table</span>
<a name="l08931"></a>08931 <span class="comment">     is available for DW_AT_decl_file.  */</span>
<a name="l08932"></a>08932   <a class="code" href="dwarf2read_8c.html#ad2297a459d813fc3e726410836bf1f8e">setup_type_unit_groups</a> (die, cu);
<a name="l08933"></a>08933 
<a name="l08934"></a>08934   <span class="keywordflow">if</span> (die-&gt;child != NULL)
<a name="l08935"></a>08935     {
<a name="l08936"></a>08936       child_die = die-&gt;child;
<a name="l08937"></a>08937       <span class="keywordflow">while</span> (child_die &amp;&amp; child_die-&gt;tag)
<a name="l08938"></a>08938         {
<a name="l08939"></a>08939           <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (child_die, cu);
<a name="l08940"></a>08940           child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l08941"></a>08941         }
<a name="l08942"></a>08942     }
<a name="l08943"></a>08943 }
<a name="l08944"></a>08944 
<a name="l08945"></a>08945 <span class="comment">/* DWO/DWP files.</span>
<a name="l08946"></a>08946 <span class="comment"></span>
<a name="l08947"></a>08947 <span class="comment">   http://gcc.gnu.org/wiki/DebugFission</span>
<a name="l08948"></a>08948 <span class="comment">   http://gcc.gnu.org/wiki/DebugFissionDWP</span>
<a name="l08949"></a>08949 <span class="comment"></span>
<a name="l08950"></a>08950 <span class="comment">   To simplify handling of both DWO files (&quot;object&quot; files with the DWARF info)</span>
<a name="l08951"></a>08951 <span class="comment">   and DWP files (a file with the DWOs packaged up into one file), we treat</span>
<a name="l08952"></a>08952 <span class="comment">   DWP files as having a collection of virtual DWO files.  */</span>
<a name="l08953"></a>08953 
<a name="l08954"></a>08954 <span class="keyword">static</span> hashval_t
<a name="l08955"></a><a class="code" href="dwarf2read_8c.html#a1527a7a128a2d6f3591acef662326129">08955</a> <a class="code" href="dwarf2read_8c.html#a1527a7a128a2d6f3591acef662326129">hash_dwo_file</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item)
<a name="l08956"></a>08956 {
<a name="l08957"></a>08957   <span class="keyword">const</span> <span class="keyword">struct </span>dwo_file *dwo_file = item;
<a name="l08958"></a>08958   hashval_t <a class="code" href="bcache_8c.html#a680b4550cc69a0827af4a7169fe3c372">hash</a>;
<a name="l08959"></a>08959 
<a name="l08960"></a>08960   hash = htab_hash_string (dwo_file-&gt;<a class="code" href="structdwo__file.html#a6df466b952ebc265d4610f244196e98a">dwo_name</a>);
<a name="l08961"></a>08961   <span class="keywordflow">if</span> (dwo_file-&gt;<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a> != NULL)
<a name="l08962"></a>08962     hash += htab_hash_string (dwo_file-&gt;<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a>);
<a name="l08963"></a>08963   <span class="keywordflow">return</span> <a class="code" href="bcache_8c.html#a680b4550cc69a0827af4a7169fe3c372">hash</a>;
<a name="l08964"></a>08964 }
<a name="l08965"></a>08965 
<a name="l08966"></a>08966 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l08967"></a><a class="code" href="dwarf2read_8c.html#a6db588efea8f1336e2d35e20cb6d2159">08967</a> <a class="code" href="dwarf2read_8c.html#a6db588efea8f1336e2d35e20cb6d2159">eq_dwo_file</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item_lhs, <span class="keyword">const</span> <span class="keywordtype">void</span> *item_rhs)
<a name="l08968"></a>08968 {
<a name="l08969"></a>08969   <span class="keyword">const</span> <span class="keyword">struct </span>dwo_file *lhs = item_lhs;
<a name="l08970"></a>08970   <span class="keyword">const</span> <span class="keyword">struct </span>dwo_file *rhs = item_rhs;
<a name="l08971"></a>08971 
<a name="l08972"></a>08972   <span class="keywordflow">if</span> (strcmp (lhs-&gt;<a class="code" href="structdwo__file.html#a6df466b952ebc265d4610f244196e98a">dwo_name</a>, rhs-&gt;<a class="code" href="structdwo__file.html#a6df466b952ebc265d4610f244196e98a">dwo_name</a>) != 0)
<a name="l08973"></a>08973     <span class="keywordflow">return</span> 0;
<a name="l08974"></a>08974   <span class="keywordflow">if</span> (lhs-&gt;<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a> == NULL || rhs-&gt;<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a> == NULL)
<a name="l08975"></a>08975     <span class="keywordflow">return</span> lhs-&gt;<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a> == rhs-&gt;<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a>;
<a name="l08976"></a>08976   <span class="keywordflow">return</span> strcmp (lhs-&gt;<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a>, rhs-&gt;<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a>) == 0;
<a name="l08977"></a>08977 }
<a name="l08978"></a>08978 
<a name="l08979"></a>08979 <span class="comment">/* Allocate a hash table for DWO files.  */</span>
<a name="l08980"></a>08980 
<a name="l08981"></a>08981 <span class="keyword">static</span> htab_t
<a name="l08982"></a><a class="code" href="dwarf2read_8c.html#a727146b9b3f0d3473b565fc20b10ea86">08982</a> <a class="code" href="dwarf2read_8c.html#a727146b9b3f0d3473b565fc20b10ea86">allocate_dwo_file_hash_table</a> (<span class="keywordtype">void</span>)
<a name="l08983"></a>08983 {
<a name="l08984"></a>08984   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l08985"></a>08985 
<a name="l08986"></a>08986   <span class="keywordflow">return</span> htab_create_alloc_ex (41,
<a name="l08987"></a>08987                                <a class="code" href="dwarf2read_8c.html#a1527a7a128a2d6f3591acef662326129">hash_dwo_file</a>,
<a name="l08988"></a>08988                                <a class="code" href="dwarf2read_8c.html#a6db588efea8f1336e2d35e20cb6d2159">eq_dwo_file</a>,
<a name="l08989"></a>08989                                NULL,
<a name="l08990"></a>08990                                &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l08991"></a>08991                                <a class="code" href="utils_8c.html#a64b0a5e317b6f45f062aa8356111644b">hashtab_obstack_allocate</a>,
<a name="l08992"></a>08992                                <a class="code" href="utils_8c.html#af32d0d55c7c49d59093e66ef695f9513">dummy_obstack_deallocate</a>);
<a name="l08993"></a>08993 }
<a name="l08994"></a>08994 
<a name="l08995"></a>08995 <span class="comment">/* Lookup DWO file DWO_NAME.  */</span>
<a name="l08996"></a>08996 
<a name="l08997"></a>08997 <span class="keyword">static</span> <span class="keywordtype">void</span> **
<a name="l08998"></a><a class="code" href="dwarf2read_8c.html#aef78329d4b39424730119060113478c7">08998</a> <a class="code" href="dwarf2read_8c.html#aef78329d4b39424730119060113478c7">lookup_dwo_file_slot</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *dwo_name, <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir)
<a name="l08999"></a>08999 {
<a name="l09000"></a>09000   <span class="keyword">struct </span>dwo_file find_entry;
<a name="l09001"></a>09001   <span class="keywordtype">void</span> **slot;
<a name="l09002"></a>09002 
<a name="l09003"></a>09003   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a647f8cdf79433f5d61ed1380e038757e">dwo_files</a> == NULL)
<a name="l09004"></a>09004     dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a647f8cdf79433f5d61ed1380e038757e">dwo_files</a> = <a class="code" href="dwarf2read_8c.html#a727146b9b3f0d3473b565fc20b10ea86">allocate_dwo_file_hash_table</a> ();
<a name="l09005"></a>09005 
<a name="l09006"></a>09006   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;find_entry, 0, <span class="keyword">sizeof</span> (find_entry));
<a name="l09007"></a>09007   find_entry.<a class="code" href="structdwo__file.html#a6df466b952ebc265d4610f244196e98a">dwo_name</a> = <a class="code" href="structdwo__file.html#a6df466b952ebc265d4610f244196e98a">dwo_name</a>;
<a name="l09008"></a>09008   find_entry.<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a> = <a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a>;
<a name="l09009"></a>09009   slot = htab_find_slot (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a647f8cdf79433f5d61ed1380e038757e">dwo_files</a>, &amp;find_entry, INSERT);
<a name="l09010"></a>09010 
<a name="l09011"></a>09011   <span class="keywordflow">return</span> slot;
<a name="l09012"></a>09012 }
<a name="l09013"></a>09013 
<a name="l09014"></a>09014 <span class="keyword">static</span> hashval_t
<a name="l09015"></a><a class="code" href="dwarf2read_8c.html#aa6c1e42f057f8439769634997f277860">09015</a> <a class="code" href="dwarf2read_8c.html#aa6c1e42f057f8439769634997f277860">hash_dwo_unit</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item)
<a name="l09016"></a>09016 {
<a name="l09017"></a>09017   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structdwo__unit.html">dwo_unit</a> = item;
<a name="l09018"></a>09018 
<a name="l09019"></a>09019   <span class="comment">/* This drops the top 32 bits of the id, but is ok for a hash.  */</span>
<a name="l09020"></a>09020   <span class="keywordflow">return</span> dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>;
<a name="l09021"></a>09021 }
<a name="l09022"></a>09022 
<a name="l09023"></a>09023 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l09024"></a><a class="code" href="dwarf2read_8c.html#a00d931696ddc69e822bebeffbe2c0248">09024</a> <a class="code" href="dwarf2read_8c.html#a00d931696ddc69e822bebeffbe2c0248">eq_dwo_unit</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item_lhs, <span class="keyword">const</span> <span class="keywordtype">void</span> *item_rhs)
<a name="l09025"></a>09025 {
<a name="l09026"></a>09026   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *lhs = item_lhs;
<a name="l09027"></a>09027   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *rhs = item_rhs;
<a name="l09028"></a>09028 
<a name="l09029"></a>09029   <span class="comment">/* The signature is assumed to be unique within the DWO file.</span>
<a name="l09030"></a>09030 <span class="comment">     So while object file CU dwo_id&#39;s always have the value zero,</span>
<a name="l09031"></a>09031 <span class="comment">     that&#39;s OK, assuming each object file DWO file has only one CU,</span>
<a name="l09032"></a>09032 <span class="comment">     and that&#39;s the rule for now.  */</span>
<a name="l09033"></a>09033   <span class="keywordflow">return</span> lhs-&gt;<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a> == rhs-&gt;<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>;
<a name="l09034"></a>09034 }
<a name="l09035"></a>09035 
<a name="l09036"></a>09036 <span class="comment">/* Allocate a hash table for DWO CUs,TUs.</span>
<a name="l09037"></a>09037 <span class="comment">   There is one of these tables for each of CUs,TUs for each DWO file.  */</span>
<a name="l09038"></a>09038 
<a name="l09039"></a>09039 <span class="keyword">static</span> htab_t
<a name="l09040"></a><a class="code" href="dwarf2read_8c.html#ae4fe7bb1a521f3edafb2a10a3af6385a">09040</a> <a class="code" href="dwarf2read_8c.html#ae4fe7bb1a521f3edafb2a10a3af6385a">allocate_dwo_unit_table</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l09041"></a>09041 {
<a name="l09042"></a>09042   <span class="comment">/* Start out with a pretty small number.</span>
<a name="l09043"></a>09043 <span class="comment">     Generally DWO files contain only one CU and maybe some TUs.  */</span>
<a name="l09044"></a>09044   <span class="keywordflow">return</span> htab_create_alloc_ex (3,
<a name="l09045"></a>09045                                <a class="code" href="dwarf2read_8c.html#aa6c1e42f057f8439769634997f277860">hash_dwo_unit</a>,
<a name="l09046"></a>09046                                <a class="code" href="dwarf2read_8c.html#a00d931696ddc69e822bebeffbe2c0248">eq_dwo_unit</a>,
<a name="l09047"></a>09047                                NULL,
<a name="l09048"></a>09048                                &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l09049"></a>09049                                <a class="code" href="utils_8c.html#a64b0a5e317b6f45f062aa8356111644b">hashtab_obstack_allocate</a>,
<a name="l09050"></a>09050                                <a class="code" href="utils_8c.html#af32d0d55c7c49d59093e66ef695f9513">dummy_obstack_deallocate</a>);
<a name="l09051"></a>09051 }
<a name="l09052"></a>09052 
<a name="l09053"></a>09053 <span class="comment">/* Structure used to pass data to create_dwo_debug_info_hash_table_reader.  */</span>
<a name="l09054"></a>09054 
<a name="l09055"></a><a class="code" href="structcreate__dwo__cu__data.html">09055</a> <span class="keyword">struct </span><a class="code" href="structcreate__dwo__cu__data.html">create_dwo_cu_data</a>
<a name="l09056"></a>09056 {
<a name="l09057"></a><a class="code" href="structcreate__dwo__cu__data.html#afd76939cc3ea511515efe1626f2d3f6c">09057</a>   <span class="keyword">struct </span>dwo_file *<a class="code" href="structcreate__dwo__cu__data.html#afd76939cc3ea511515efe1626f2d3f6c">dwo_file</a>;
<a name="l09058"></a><a class="code" href="structcreate__dwo__cu__data.html#ae0bb388781948a7b4da1a45646a8f6a0">09058</a>   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> <a class="code" href="structdwo__unit.html">dwo_unit</a>;
<a name="l09059"></a>09059 };
<a name="l09060"></a>09060 
<a name="l09061"></a>09061 <span class="comment">/* die_reader_func for create_dwo_cu.  */</span>
<a name="l09062"></a>09062 
<a name="l09063"></a>09063 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l09064"></a><a class="code" href="dwarf2read_8c.html#a2b6a6fddd27254dd4b9bec5774e4efec">09064</a> <a class="code" href="dwarf2read_8c.html#a2b6a6fddd27254dd4b9bec5774e4efec">create_dwo_cu_reader</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l09065"></a>09065                       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l09066"></a>09066                       <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *comp_unit_die,
<a name="l09067"></a>09067                       <span class="keywordtype">int</span> has_children,
<a name="l09068"></a>09068                       <span class="keywordtype">void</span> *datap)
<a name="l09069"></a>09069 {
<a name="l09070"></a>09070   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l09071"></a>09071   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l09072"></a>09072   <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a> = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>;
<a name="l09073"></a>09073   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a>;
<a name="l09074"></a>09074   <span class="keyword">struct </span><a class="code" href="structcreate__dwo__cu__data.html">create_dwo_cu_data</a> *data = datap;
<a name="l09075"></a>09075   <span class="keyword">struct </span>dwo_file *dwo_file = data-&gt;<a class="code" href="structcreate__dwo__cu__data.html#afd76939cc3ea511515efe1626f2d3f6c">dwo_file</a>;
<a name="l09076"></a>09076   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structdwo__unit.html">dwo_unit</a> = &amp;data-&gt;<a class="code" href="structcreate__dwo__cu__data.html#ae0bb388781948a7b4da1a45646a8f6a0">dwo_unit</a>;
<a name="l09077"></a>09077   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l09078"></a>09078 
<a name="l09079"></a>09079   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (comp_unit_die, DW_AT_GNU_dwo_id, cu);
<a name="l09080"></a>09080   <span class="keywordflow">if</span> (attr == NULL)
<a name="l09081"></a>09081     {
<a name="l09082"></a>09082       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l09083"></a>09083                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: debug entry at offset 0x%x is missing&quot;</span>
<a name="l09084"></a>09084                    <span class="stringliteral">&quot; its dwo_id [in module %s]&quot;</span>),
<a name="l09085"></a>09085                  offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, dwo_file-&gt;<a class="code" href="structdwo__file.html#a6df466b952ebc265d4610f244196e98a">dwo_name</a>);
<a name="l09086"></a>09086       <span class="keywordflow">return</span>;
<a name="l09087"></a>09087     }
<a name="l09088"></a>09088 
<a name="l09089"></a>09089   dwo_unit-&gt;<a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">dwo_file</a> = dwo_file;
<a name="l09090"></a>09090   dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a> = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l09091"></a>09091   dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a808127fb35d399faddd33a3b28e5ec06">section</a> = section;
<a name="l09092"></a>09092   dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a39192bd18fec52ffbb9cda4fc9d631e0">offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l09093"></a>09093   dwo_unit-&gt;<a class="code" href="structdwo__unit.html#adf4afc1b8bd4d2b879762c33930ef988">length</a> = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a>;
<a name="l09094"></a>09094 
<a name="l09095"></a>09095   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l09096"></a>09096     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;  offset 0x%x, dwo_id %s\n&quot;</span>,
<a name="l09097"></a>09097                         offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>));
<a name="l09098"></a>09098 }
<a name="l09099"></a>09099 
<a name="l09100"></a>09100 <span class="comment">/* Create the dwo_unit for the lone CU in DWO_FILE.</span>
<a name="l09101"></a>09101 <span class="comment">   Note: This function processes DWO files only, not DWP files.  */</span>
<a name="l09102"></a>09102 
<a name="l09103"></a>09103 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *
<a name="l09104"></a><a class="code" href="dwarf2read_8c.html#a956cef4fbd3cdd49fc9b80d528d56ea3">09104</a> <a class="code" href="dwarf2read_8c.html#a956cef4fbd3cdd49fc9b80d528d56ea3">create_dwo_cu</a> (<span class="keyword">struct</span> dwo_file *dwo_file)
<a name="l09105"></a>09105 {
<a name="l09106"></a>09106   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l09107"></a>09107   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section = &amp;dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#adf20047f5e83d7bbaa527ee01e0fe71a">info</a>;
<a name="l09108"></a>09108   bfd *abfd;
<a name="l09109"></a>09109   htab_t cu_htab;
<a name="l09110"></a>09110   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr, *end_ptr;
<a name="l09111"></a>09111   <span class="keyword">struct </span><a class="code" href="structcreate__dwo__cu__data.html">create_dwo_cu_data</a> create_dwo_cu_data;
<a name="l09112"></a>09112   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structdwo__unit.html">dwo_unit</a>;
<a name="l09113"></a>09113 
<a name="l09114"></a>09114   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, section);
<a name="l09115"></a>09115   info_ptr = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>;
<a name="l09116"></a>09116 
<a name="l09117"></a>09117   <span class="keywordflow">if</span> (info_ptr == NULL)
<a name="l09118"></a>09118     <span class="keywordflow">return</span> NULL;
<a name="l09119"></a>09119 
<a name="l09120"></a>09120   <span class="comment">/* We can&#39;t set abfd until now because the section may be empty or</span>
<a name="l09121"></a>09121 <span class="comment">     not present, in which case section-&gt;asection will be NULL.  */</span>
<a name="l09122"></a>09122   abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l09123"></a>09123 
<a name="l09124"></a>09124   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l09125"></a>09125     {
<a name="l09126"></a>09126       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Reading %s for %s:\n&quot;</span>,
<a name="l09127"></a>09127                           <a class="code" href="dwarf2read_8c.html#a206c558e28b7bc7fcf8bdad145cabef1">get_section_name</a> (section),
<a name="l09128"></a>09128                           <a class="code" href="dwarf2read_8c.html#a1c841524fdd0bd73272dad700a7452f6">get_section_file_name</a> (section));
<a name="l09129"></a>09129     }
<a name="l09130"></a>09130 
<a name="l09131"></a>09131   create_dwo_cu_data.<a class="code" href="structcreate__dwo__cu__data.html#afd76939cc3ea511515efe1626f2d3f6c">dwo_file</a> = <a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">dwo_file</a>;
<a name="l09132"></a>09132   dwo_unit = NULL;
<a name="l09133"></a>09133 
<a name="l09134"></a>09134   end_ptr = info_ptr + section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>;
<a name="l09135"></a>09135   <span class="keywordflow">while</span> (info_ptr &lt; end_ptr)
<a name="l09136"></a>09136     {
<a name="l09137"></a>09137       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> per_cu;
<a name="l09138"></a>09138 
<a name="l09139"></a>09139       <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;create_dwo_cu_data.<a class="code" href="structcreate__dwo__cu__data.html#ae0bb388781948a7b4da1a45646a8f6a0">dwo_unit</a>, 0,
<a name="l09140"></a>09140               sizeof (create_dwo_cu_data.<a class="code" href="structcreate__dwo__cu__data.html#ae0bb388781948a7b4da1a45646a8f6a0">dwo_unit</a>));
<a name="l09141"></a>09141       <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;per_cu, 0, <span class="keyword">sizeof</span> (per_cu));
<a name="l09142"></a>09142       per_cu.<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a> = <a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>;
<a name="l09143"></a>09143       per_cu.<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a> = 0;
<a name="l09144"></a>09144       per_cu.<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = info_ptr - section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>;
<a name="l09145"></a>09145       per_cu.<a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a> = <a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a>;
<a name="l09146"></a>09146 
<a name="l09147"></a>09147       <a class="code" href="dwarf2read_8c.html#a28ed78ebf707564f0999e64b8e3e642b">init_cutu_and_read_dies_no_follow</a> (&amp;per_cu,
<a name="l09148"></a>09148                                          &amp;dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#a77a177199056d70f8c5379e116538cff">abbrev</a>,
<a name="l09149"></a>09149                                          dwo_file,
<a name="l09150"></a>09150                                          <a class="code" href="dwarf2read_8c.html#a2b6a6fddd27254dd4b9bec5774e4efec">create_dwo_cu_reader</a>,
<a name="l09151"></a>09151                                          &amp;create_dwo_cu_data);
<a name="l09152"></a>09152 
<a name="l09153"></a>09153       <span class="keywordflow">if</span> (create_dwo_cu_data.<a class="code" href="structcreate__dwo__cu__data.html#ae0bb388781948a7b4da1a45646a8f6a0">dwo_unit</a>.<a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">dwo_file</a> != NULL)
<a name="l09154"></a>09154         {
<a name="l09155"></a>09155           <span class="comment">/* If we&#39;ve already found one, complain.  We only support one</span>
<a name="l09156"></a>09156 <span class="comment">             because having more than one requires hacking the dwo_name of</span>
<a name="l09157"></a>09157 <span class="comment">             each to match, which is highly unlikely to happen.  */</span>
<a name="l09158"></a>09158           <span class="keywordflow">if</span> (dwo_unit != NULL)
<a name="l09159"></a>09159             {
<a name="l09160"></a>09160               <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l09161"></a>09161                          <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Multiple CUs in DWO file %s [in module %s]&quot;</span>),
<a name="l09162"></a>09162                          dwo_file-&gt;<a class="code" href="structdwo__file.html#a6df466b952ebc265d4610f244196e98a">dwo_name</a>, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l09163"></a>09163               <span class="keywordflow">break</span>;
<a name="l09164"></a>09164             }
<a name="l09165"></a>09165 
<a name="l09166"></a>09166           dwo_unit = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, <span class="keyword">struct</span> dwo_unit);
<a name="l09167"></a>09167           *dwo_unit = create_dwo_cu_data.<a class="code" href="structcreate__dwo__cu__data.html#ae0bb388781948a7b4da1a45646a8f6a0">dwo_unit</a>;
<a name="l09168"></a>09168         }
<a name="l09169"></a>09169 
<a name="l09170"></a>09170       info_ptr += per_cu.<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a>;
<a name="l09171"></a>09171     }
<a name="l09172"></a>09172 
<a name="l09173"></a>09173   <span class="keywordflow">return</span> dwo_unit;
<a name="l09174"></a>09174 }
<a name="l09175"></a>09175 
<a name="l09176"></a>09176 <span class="comment">/* DWP file .debug_{cu,tu}_index section format:</span>
<a name="l09177"></a>09177 <span class="comment">   [ref: http://gcc.gnu.org/wiki/DebugFissionDWP]</span>
<a name="l09178"></a>09178 <span class="comment"></span>
<a name="l09179"></a>09179 <span class="comment">   DWP Version 1:</span>
<a name="l09180"></a>09180 <span class="comment"></span>
<a name="l09181"></a>09181 <span class="comment">   Both index sections have the same format, and serve to map a 64-bit</span>
<a name="l09182"></a>09182 <span class="comment">   signature to a set of section numbers.  Each section begins with a header,</span>
<a name="l09183"></a>09183 <span class="comment">   followed by a hash table of 64-bit signatures, a parallel table of 32-bit</span>
<a name="l09184"></a>09184 <span class="comment">   indexes, and a pool of 32-bit section numbers.  The index sections will be</span>
<a name="l09185"></a>09185 <span class="comment">   aligned at 8-byte boundaries in the file.</span>
<a name="l09186"></a>09186 <span class="comment"></span>
<a name="l09187"></a>09187 <span class="comment">   The index section header consists of:</span>
<a name="l09188"></a>09188 <span class="comment"></span>
<a name="l09189"></a>09189 <span class="comment">    V, 32 bit version number</span>
<a name="l09190"></a>09190 <span class="comment">    -, 32 bits unused</span>
<a name="l09191"></a>09191 <span class="comment">    N, 32 bit number of compilation units or type units in the index</span>
<a name="l09192"></a>09192 <span class="comment">    M, 32 bit number of slots in the hash table</span>
<a name="l09193"></a>09193 <span class="comment"></span>
<a name="l09194"></a>09194 <span class="comment">   Numbers are recorded using the byte order of the application binary.</span>
<a name="l09195"></a>09195 <span class="comment"></span>
<a name="l09196"></a>09196 <span class="comment">   The hash table begins at offset 16 in the section, and consists of an array</span>
<a name="l09197"></a>09197 <span class="comment">   of M 64-bit slots.  Each slot contains a 64-bit signature (using the byte</span>
<a name="l09198"></a>09198 <span class="comment">   order of the application binary).  Unused slots in the hash table are 0.</span>
<a name="l09199"></a>09199 <span class="comment">   (We rely on the extreme unlikeliness of a signature being exactly 0.)</span>
<a name="l09200"></a>09200 <span class="comment"></span>
<a name="l09201"></a>09201 <span class="comment">   The parallel table begins immediately after the hash table</span>
<a name="l09202"></a>09202 <span class="comment">   (at offset 16 + 8 * M from the beginning of the section), and consists of an</span>
<a name="l09203"></a>09203 <span class="comment">   array of 32-bit indexes (using the byte order of the application binary),</span>
<a name="l09204"></a>09204 <span class="comment">   corresponding 1-1 with slots in the hash table.  Each entry in the parallel</span>
<a name="l09205"></a>09205 <span class="comment">   table contains a 32-bit index into the pool of section numbers.  For unused</span>
<a name="l09206"></a>09206 <span class="comment">   hash table slots, the corresponding entry in the parallel table will be 0.</span>
<a name="l09207"></a>09207 <span class="comment"></span>
<a name="l09208"></a>09208 <span class="comment">   The pool of section numbers begins immediately following the hash table</span>
<a name="l09209"></a>09209 <span class="comment">   (at offset 16 + 12 * M from the beginning of the section).  The pool of</span>
<a name="l09210"></a>09210 <span class="comment">   section numbers consists of an array of 32-bit words (using the byte order</span>
<a name="l09211"></a>09211 <span class="comment">   of the application binary).  Each item in the array is indexed starting</span>
<a name="l09212"></a>09212 <span class="comment">   from 0.  The hash table entry provides the index of the first section</span>
<a name="l09213"></a>09213 <span class="comment">   number in the set.  Additional section numbers in the set follow, and the</span>
<a name="l09214"></a>09214 <span class="comment">   set is terminated by a 0 entry (section number 0 is not used in ELF).</span>
<a name="l09215"></a>09215 <span class="comment"></span>
<a name="l09216"></a>09216 <span class="comment">   In each set of section numbers, the .debug_info.dwo or .debug_types.dwo</span>
<a name="l09217"></a>09217 <span class="comment">   section must be the first entry in the set, and the .debug_abbrev.dwo must</span>
<a name="l09218"></a>09218 <span class="comment">   be the second entry. Other members of the set may follow in any order.</span>
<a name="l09219"></a>09219 <span class="comment"></span>
<a name="l09220"></a>09220 <span class="comment">   ---</span>
<a name="l09221"></a>09221 <span class="comment"></span>
<a name="l09222"></a>09222 <span class="comment">   DWP Version 2:</span>
<a name="l09223"></a>09223 <span class="comment"></span>
<a name="l09224"></a>09224 <span class="comment">   DWP Version 2 combines all the .debug_info, etc. sections into one,</span>
<a name="l09225"></a>09225 <span class="comment">   and the entries in the index tables are now offsets into these sections.</span>
<a name="l09226"></a>09226 <span class="comment">   CU offsets begin at 0.  TU offsets begin at the size of the .debug_info</span>
<a name="l09227"></a>09227 <span class="comment">   section.</span>
<a name="l09228"></a>09228 <span class="comment"></span>
<a name="l09229"></a>09229 <span class="comment">   Index Section Contents:</span>
<a name="l09230"></a>09230 <span class="comment">    Header</span>
<a name="l09231"></a>09231 <span class="comment">    Hash Table of Signatures   dwp_hash_table.hash_table</span>
<a name="l09232"></a>09232 <span class="comment">    Parallel Table of Indices  dwp_hash_table.unit_table</span>
<a name="l09233"></a>09233 <span class="comment">    Table of Section Offsets   dwp_hash_table.v2.{section_ids,offsets}</span>
<a name="l09234"></a>09234 <span class="comment">    Table of Section Sizes     dwp_hash_table.v2.sizes</span>
<a name="l09235"></a>09235 <span class="comment"></span>
<a name="l09236"></a>09236 <span class="comment">   The index section header consists of:</span>
<a name="l09237"></a>09237 <span class="comment"></span>
<a name="l09238"></a>09238 <span class="comment">    V, 32 bit version number</span>
<a name="l09239"></a>09239 <span class="comment">    L, 32 bit number of columns in the table of section offsets</span>
<a name="l09240"></a>09240 <span class="comment">    N, 32 bit number of compilation units or type units in the index</span>
<a name="l09241"></a>09241 <span class="comment">    M, 32 bit number of slots in the hash table</span>
<a name="l09242"></a>09242 <span class="comment"></span>
<a name="l09243"></a>09243 <span class="comment">   Numbers are recorded using the byte order of the application binary.</span>
<a name="l09244"></a>09244 <span class="comment"></span>
<a name="l09245"></a>09245 <span class="comment">   The hash table has the same format as version 1.</span>
<a name="l09246"></a>09246 <span class="comment">   The parallel table of indices has the same format as version 1,</span>
<a name="l09247"></a>09247 <span class="comment">   except that the entries are origin-1 indices into the table of sections</span>
<a name="l09248"></a>09248 <span class="comment">   offsets and the table of section sizes.</span>
<a name="l09249"></a>09249 <span class="comment"></span>
<a name="l09250"></a>09250 <span class="comment">   The table of offsets begins immediately following the parallel table</span>
<a name="l09251"></a>09251 <span class="comment">   (at offset 16 + 12 * M from the beginning of the section).  The table is</span>
<a name="l09252"></a>09252 <span class="comment">   a two-dimensional array of 32-bit words (using the byte order of the</span>
<a name="l09253"></a>09253 <span class="comment">   application binary), with L columns and N+1 rows, in row-major order.</span>
<a name="l09254"></a>09254 <span class="comment">   Each row in the array is indexed starting from 0.  The first row provides</span>
<a name="l09255"></a>09255 <span class="comment">   a key to the remaining rows: each column in this row provides an identifier</span>
<a name="l09256"></a>09256 <span class="comment">   for a debug section, and the offsets in the same column of subsequent rows</span>
<a name="l09257"></a>09257 <span class="comment">   refer to that section.  The section identifiers are:</span>
<a name="l09258"></a>09258 <span class="comment"></span>
<a name="l09259"></a>09259 <span class="comment">    DW_SECT_INFO         1  .debug_info.dwo</span>
<a name="l09260"></a>09260 <span class="comment">    DW_SECT_TYPES        2  .debug_types.dwo</span>
<a name="l09261"></a>09261 <span class="comment">    DW_SECT_ABBREV       3  .debug_abbrev.dwo</span>
<a name="l09262"></a>09262 <span class="comment">    DW_SECT_LINE         4  .debug_line.dwo</span>
<a name="l09263"></a>09263 <span class="comment">    DW_SECT_LOC          5  .debug_loc.dwo</span>
<a name="l09264"></a>09264 <span class="comment">    DW_SECT_STR_OFFSETS  6  .debug_str_offsets.dwo</span>
<a name="l09265"></a>09265 <span class="comment">    DW_SECT_MACINFO      7  .debug_macinfo.dwo</span>
<a name="l09266"></a>09266 <span class="comment">    DW_SECT_MACRO        8  .debug_macro.dwo</span>
<a name="l09267"></a>09267 <span class="comment"></span>
<a name="l09268"></a>09268 <span class="comment">   The offsets provided by the CU and TU index sections are the base offsets</span>
<a name="l09269"></a>09269 <span class="comment">   for the contributions made by each CU or TU to the corresponding section</span>
<a name="l09270"></a>09270 <span class="comment">   in the package file.  Each CU and TU header contains an abbrev_offset</span>
<a name="l09271"></a>09271 <span class="comment">   field, used to find the abbreviations table for that CU or TU within the</span>
<a name="l09272"></a>09272 <span class="comment">   contribution to the .debug_abbrev.dwo section for that CU or TU, and should</span>
<a name="l09273"></a>09273 <span class="comment">   be interpreted as relative to the base offset given in the index section.</span>
<a name="l09274"></a>09274 <span class="comment">   Likewise, offsets into .debug_line.dwo from DW_AT_stmt_list attributes</span>
<a name="l09275"></a>09275 <span class="comment">   should be interpreted as relative to the base offset for .debug_line.dwo,</span>
<a name="l09276"></a>09276 <span class="comment">   and offsets into other debug sections obtained from DWARF attributes should</span>
<a name="l09277"></a>09277 <span class="comment">   also be interpreted as relative to the corresponding base offset.</span>
<a name="l09278"></a>09278 <span class="comment"></span>
<a name="l09279"></a>09279 <span class="comment">   The table of sizes begins immediately following the table of offsets.</span>
<a name="l09280"></a>09280 <span class="comment">   Like the table of offsets, it is a two-dimensional array of 32-bit words,</span>
<a name="l09281"></a>09281 <span class="comment">   with L columns and N rows, in row-major order.  Each row in the array is</span>
<a name="l09282"></a>09282 <span class="comment">   indexed starting from 1 (row 0 is shared by the two tables).</span>
<a name="l09283"></a>09283 <span class="comment"></span>
<a name="l09284"></a>09284 <span class="comment">   ---</span>
<a name="l09285"></a>09285 <span class="comment"></span>
<a name="l09286"></a>09286 <span class="comment">   Hash table lookup is handled the same in version 1 and 2:</span>
<a name="l09287"></a>09287 <span class="comment"></span>
<a name="l09288"></a>09288 <span class="comment">   We assume that N and M will not exceed 2^32 - 1.</span>
<a name="l09289"></a>09289 <span class="comment">   The size of the hash table, M, must be 2^k such that 2^k &gt; 3*N/2.</span>
<a name="l09290"></a>09290 <span class="comment"></span>
<a name="l09291"></a>09291 <span class="comment">   Given a 64-bit compilation unit signature or a type signature S, an entry</span>
<a name="l09292"></a>09292 <span class="comment">   in the hash table is located as follows:</span>
<a name="l09293"></a>09293 <span class="comment"></span>
<a name="l09294"></a>09294 <span class="comment">   1) Calculate a primary hash H = S &amp; MASK(k), where MASK(k) is a mask with</span>
<a name="l09295"></a>09295 <span class="comment">      the low-order k bits all set to 1.</span>
<a name="l09296"></a>09296 <span class="comment"></span>
<a name="l09297"></a>09297 <span class="comment">   2) Calculate a secondary hash H&#39; = (((S &gt;&gt; 32) &amp; MASK(k)) | 1).</span>
<a name="l09298"></a>09298 <span class="comment"></span>
<a name="l09299"></a>09299 <span class="comment">   3) If the hash table entry at index H matches the signature, use that</span>
<a name="l09300"></a>09300 <span class="comment">      entry.  If the hash table entry at index H is unused (all zeroes),</span>
<a name="l09301"></a>09301 <span class="comment">      terminate the search: the signature is not present in the table.</span>
<a name="l09302"></a>09302 <span class="comment"></span>
<a name="l09303"></a>09303 <span class="comment">   4) Let H = (H + H&#39;) modulo M. Repeat at Step 3.</span>
<a name="l09304"></a>09304 <span class="comment"></span>
<a name="l09305"></a>09305 <span class="comment">   Because M &gt; N and H&#39; and M are relatively prime, the search is guaranteed</span>
<a name="l09306"></a>09306 <span class="comment">   to stop at an unused slot or find the match.  */</span>
<a name="l09307"></a>09307 
<a name="l09308"></a>09308 <span class="comment">/* Create a hash table to map DWO IDs to their CU/TU entry in</span>
<a name="l09309"></a>09309 <span class="comment">   .debug_{info,types}.dwo in DWP_FILE.</span>
<a name="l09310"></a>09310 <span class="comment">   Returns NULL if there isn&#39;t one.</span>
<a name="l09311"></a>09311 <span class="comment">   Note: This function processes DWP files only, not DWO files.  */</span>
<a name="l09312"></a>09312 
<a name="l09313"></a>09313 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwp__hash__table.html">dwp_hash_table</a> *
<a name="l09314"></a><a class="code" href="dwarf2read_8c.html#a6d6724e42513304a7c66509d698934d6">09314</a> <a class="code" href="dwarf2read_8c.html#a6d6724e42513304a7c66509d698934d6">create_dwp_hash_table</a> (<span class="keyword">struct</span> <a class="code" href="structdwp__file.html">dwp_file</a> *<a class="code" href="structdwp__file.html">dwp_file</a>, <span class="keywordtype">int</span> is_debug_types)
<a name="l09315"></a>09315 {
<a name="l09316"></a>09316   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l09317"></a>09317   bfd *dbfd = dwp_file-&gt;<a class="code" href="structdwp__file.html#adaac28c08d06f0daf3633e997b0abdb1">dbfd</a>;
<a name="l09318"></a>09318   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *index_ptr, *index_end;
<a name="l09319"></a>09319   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *index;
<a name="l09320"></a>09320   uint32_t <a class="code" href="version_8h.html#ac91cf940e10a61b95cabc3258a06186b">version</a>, nr_columns, nr_units, nr_slots;
<a name="l09321"></a>09321   <span class="keyword">struct </span><a class="code" href="structdwp__hash__table.html">dwp_hash_table</a> *htab;
<a name="l09322"></a>09322 
<a name="l09323"></a>09323   <span class="keywordflow">if</span> (is_debug_types)
<a name="l09324"></a>09324     index = &amp;dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a8d3418c9bb110b773192d2e9bb26a3db">tu_index</a>;
<a name="l09325"></a>09325   <span class="keywordflow">else</span>
<a name="l09326"></a>09326     index = &amp;dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a270bca9fb26055e71c6034c765aab8c5">cu_index</a>;
<a name="l09327"></a>09327 
<a name="l09328"></a>09328   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ac9e788fb165d736559a5a07bd4cd8dc1">dwarf2_section_empty_p</a> (index))
<a name="l09329"></a>09329     <span class="keywordflow">return</span> NULL;
<a name="l09330"></a>09330   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, index);
<a name="l09331"></a>09331 
<a name="l09332"></a>09332   index_ptr = index-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>;
<a name="l09333"></a>09333   index_end = index_ptr + index-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>;
<a name="l09334"></a>09334 
<a name="l09335"></a>09335   version = <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (dbfd, index_ptr);
<a name="l09336"></a>09336   index_ptr += 4;
<a name="l09337"></a>09337   <span class="keywordflow">if</span> (version == 2)
<a name="l09338"></a>09338     nr_columns = <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (dbfd, index_ptr);
<a name="l09339"></a>09339   <span class="keywordflow">else</span>
<a name="l09340"></a>09340     nr_columns = 0;
<a name="l09341"></a>09341   index_ptr += 4;
<a name="l09342"></a>09342   nr_units = <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (dbfd, index_ptr);
<a name="l09343"></a>09343   index_ptr += 4;
<a name="l09344"></a>09344   nr_slots = <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (dbfd, index_ptr);
<a name="l09345"></a>09345   index_ptr += 4;
<a name="l09346"></a>09346 
<a name="l09347"></a>09347   <span class="keywordflow">if</span> (version != 1 &amp;&amp; version != 2)
<a name="l09348"></a>09348     {
<a name="l09349"></a>09349       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: unsupported DWP file version (%s)&quot;</span>
<a name="l09350"></a>09350                <span class="stringliteral">&quot; [in module %s]&quot;</span>),
<a name="l09351"></a>09351              <a class="code" href="utils_8c.html#ab74ba9d12a782e5964a4af4ddc5de3ae">pulongest</a> (version), dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09352"></a>09352     }
<a name="l09353"></a>09353   <span class="keywordflow">if</span> (nr_slots != (nr_slots &amp; -nr_slots))
<a name="l09354"></a>09354     {
<a name="l09355"></a>09355       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: number of slots in DWP hash table (%s)&quot;</span>
<a name="l09356"></a>09356                <span class="stringliteral">&quot; is not power of 2 [in module %s]&quot;</span>),
<a name="l09357"></a>09357              <a class="code" href="utils_8c.html#ab74ba9d12a782e5964a4af4ddc5de3ae">pulongest</a> (nr_slots), dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09358"></a>09358     }
<a name="l09359"></a>09359 
<a name="l09360"></a>09360   htab = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, <span class="keyword">struct</span> <a class="code" href="structdwp__hash__table.html">dwp_hash_table</a>);
<a name="l09361"></a>09361   htab-&gt;<a class="code" href="structdwp__hash__table.html#ad38d9c9206bccf97bd24595df1a835f5">version</a> = <a class="code" href="version_8h.html#ac91cf940e10a61b95cabc3258a06186b">version</a>;
<a name="l09362"></a>09362   htab-&gt;<a class="code" href="structdwp__hash__table.html#ae8d2ae0d45ddf25ba7e747073fa27a75">nr_columns</a> = <a class="code" href="structdwp__hash__table.html#ae8d2ae0d45ddf25ba7e747073fa27a75">nr_columns</a>;
<a name="l09363"></a>09363   htab-&gt;<a class="code" href="structdwp__hash__table.html#a7fc7c527fef9be71ffca081ac9196176">nr_units</a> = <a class="code" href="structdwp__hash__table.html#a7fc7c527fef9be71ffca081ac9196176">nr_units</a>;
<a name="l09364"></a>09364   htab-&gt;<a class="code" href="structdwp__hash__table.html#acba74e56ea8e20a178776efb67f1f116">nr_slots</a> = <a class="code" href="structdwp__hash__table.html#acba74e56ea8e20a178776efb67f1f116">nr_slots</a>;
<a name="l09365"></a>09365   htab-&gt;<a class="code" href="structdwp__hash__table.html#a57d51c828de01425fca35da068091053">hash_table</a> = index_ptr;
<a name="l09366"></a>09366   htab-&gt;<a class="code" href="structdwp__hash__table.html#a39f54c3b62972c745b825ca208f75dc3">unit_table</a> = htab-&gt;<a class="code" href="structdwp__hash__table.html#a57d51c828de01425fca35da068091053">hash_table</a> + <span class="keyword">sizeof</span> (uint64_t) * nr_slots;
<a name="l09367"></a>09367 
<a name="l09368"></a>09368   <span class="comment">/* Exit early if the table is empty.  */</span>
<a name="l09369"></a>09369   <span class="keywordflow">if</span> (nr_slots == 0 || nr_units == 0
<a name="l09370"></a>09370       || (version == 2 &amp;&amp; nr_columns == 0))
<a name="l09371"></a>09371     {
<a name="l09372"></a>09372       <span class="comment">/* All must be zero.  */</span>
<a name="l09373"></a>09373       <span class="keywordflow">if</span> (nr_slots != 0 || nr_units != 0
<a name="l09374"></a>09374           || (version == 2 &amp;&amp; nr_columns != 0))
<a name="l09375"></a>09375         {
<a name="l09376"></a>09376           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l09377"></a>09377                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Empty DWP but nr_slots,nr_units,nr_columns not&quot;</span>
<a name="l09378"></a>09378                        <span class="stringliteral">&quot; all zero [in modules %s]&quot;</span>),
<a name="l09379"></a>09379                      dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09380"></a>09380         }
<a name="l09381"></a>09381       <span class="keywordflow">return</span> htab;
<a name="l09382"></a>09382     }
<a name="l09383"></a>09383 
<a name="l09384"></a>09384   <span class="keywordflow">if</span> (version == 1)
<a name="l09385"></a>09385     {
<a name="l09386"></a>09386       htab-&gt;<a class="code" href="structdwp__hash__table.html#a0978d29a4d56158c0aa01740e310fdfc">section_pool</a>.<a class="code" href="structdwp__hash__table.html#a26e7e69be056ca2e4f22137f854255a2">v1</a>.indices =
<a name="l09387"></a>09387         htab-&gt;<a class="code" href="structdwp__hash__table.html#a39f54c3b62972c745b825ca208f75dc3">unit_table</a> + <span class="keyword">sizeof</span> (uint32_t) * nr_slots;
<a name="l09388"></a>09388       <span class="comment">/* It&#39;s harder to decide whether the section is too small in v1.</span>
<a name="l09389"></a>09389 <span class="comment">         V1 is deprecated anyway so we punt.  */</span>
<a name="l09390"></a>09390     }
<a name="l09391"></a>09391   <span class="keywordflow">else</span>
<a name="l09392"></a>09392     {
<a name="l09393"></a>09393       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *ids_ptr = htab-&gt;<a class="code" href="structdwp__hash__table.html#a39f54c3b62972c745b825ca208f75dc3">unit_table</a> + <span class="keyword">sizeof</span> (uint32_t) * nr_slots;
<a name="l09394"></a>09394       <span class="keywordtype">int</span> *ids = htab-&gt;<a class="code" href="structdwp__hash__table.html#a0978d29a4d56158c0aa01740e310fdfc">section_pool</a>.<a class="code" href="structdwp__hash__table.html#affa91d46f63f99d33ac14a22f6b7a4ab">v2</a>.section_ids;
<a name="l09395"></a>09395       <span class="comment">/* Reverse map for error checking.  */</span>
<a name="l09396"></a>09396       <span class="keywordtype">int</span> ids_seen[DW_SECT_MAX + 1];
<a name="l09397"></a>09397       <span class="keywordtype">int</span> i;
<a name="l09398"></a>09398 
<a name="l09399"></a>09399       <span class="keywordflow">if</span> (nr_columns &lt; 2)
<a name="l09400"></a>09400         {
<a name="l09401"></a>09401           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: bad DWP hash table, too few columns&quot;</span>
<a name="l09402"></a>09402                    <span class="stringliteral">&quot; in section table [in module %s]&quot;</span>),
<a name="l09403"></a>09403                  dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09404"></a>09404         }
<a name="l09405"></a>09405       <span class="keywordflow">if</span> (nr_columns &gt; <a class="code" href="dwarf2read_8c.html#a1abfd0ab73e1d5e9a0e40c19892d67aa">MAX_NR_V2_DWO_SECTIONS</a>)
<a name="l09406"></a>09406         {
<a name="l09407"></a>09407           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: bad DWP hash table, too many columns&quot;</span>
<a name="l09408"></a>09408                    <span class="stringliteral">&quot; in section table [in module %s]&quot;</span>),
<a name="l09409"></a>09409                  dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09410"></a>09410         }
<a name="l09411"></a>09411       <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (ids, 255, (DW_SECT_MAX + 1) * <span class="keyword">sizeof</span> (int32_t));
<a name="l09412"></a>09412       <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (ids_seen, 255, (DW_SECT_MAX + 1) * <span class="keyword">sizeof</span> (int32_t));
<a name="l09413"></a>09413       <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="structdwp__hash__table.html#ae8d2ae0d45ddf25ba7e747073fa27a75">nr_columns</a>; ++i)
<a name="l09414"></a>09414         {
<a name="l09415"></a>09415           <span class="keywordtype">int</span> <span class="keywordtype">id</span> = <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (dbfd, ids_ptr + i * <span class="keyword">sizeof</span> (uint32_t));
<a name="l09416"></a>09416 
<a name="l09417"></a>09417           <span class="keywordflow">if</span> (id &lt; DW_SECT_MIN || id &gt; DW_SECT_MAX)
<a name="l09418"></a>09418             {
<a name="l09419"></a>09419               <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: bad DWP hash table, bad section id %d&quot;</span>
<a name="l09420"></a>09420                        <span class="stringliteral">&quot; in section table [in module %s]&quot;</span>),
<a name="l09421"></a>09421                      <span class="keywordtype">id</span>, dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09422"></a>09422             }
<a name="l09423"></a>09423           <span class="keywordflow">if</span> (ids_seen[<span class="keywordtype">id</span>] != -1)
<a name="l09424"></a>09424             {
<a name="l09425"></a>09425               <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: bad DWP hash table, duplicate section&quot;</span>
<a name="l09426"></a>09426                        <span class="stringliteral">&quot; id %d in section table [in module %s]&quot;</span>),
<a name="l09427"></a>09427                      <span class="keywordtype">id</span>, dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09428"></a>09428             }
<a name="l09429"></a>09429           ids_seen[id] = i;
<a name="l09430"></a>09430           ids[i] = id;
<a name="l09431"></a>09431         }
<a name="l09432"></a>09432       <span class="comment">/* Must have exactly one info or types section.  */</span>
<a name="l09433"></a>09433       <span class="keywordflow">if</span> (((ids_seen[DW_SECT_INFO] != -1)
<a name="l09434"></a>09434            + (ids_seen[DW_SECT_TYPES] != -1))
<a name="l09435"></a>09435           != 1)
<a name="l09436"></a>09436         {
<a name="l09437"></a>09437           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: bad DWP hash table, missing/duplicate&quot;</span>
<a name="l09438"></a>09438                    <span class="stringliteral">&quot; DWO info/types section [in module %s]&quot;</span>),
<a name="l09439"></a>09439                  dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09440"></a>09440         }
<a name="l09441"></a>09441       <span class="comment">/* Must have an abbrev section.  */</span>
<a name="l09442"></a>09442       <span class="keywordflow">if</span> (ids_seen[DW_SECT_ABBREV] == -1)
<a name="l09443"></a>09443         {
<a name="l09444"></a>09444           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: bad DWP hash table, missing DWO abbrev&quot;</span>
<a name="l09445"></a>09445                    <span class="stringliteral">&quot; section [in module %s]&quot;</span>),
<a name="l09446"></a>09446                  dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09447"></a>09447         }
<a name="l09448"></a>09448       htab-&gt;<a class="code" href="structdwp__hash__table.html#a0978d29a4d56158c0aa01740e310fdfc">section_pool</a>.<a class="code" href="structdwp__hash__table.html#affa91d46f63f99d33ac14a22f6b7a4ab">v2</a>.offsets = ids_ptr + <span class="keyword">sizeof</span> (uint32_t) * nr_columns;
<a name="l09449"></a>09449       htab-&gt;<a class="code" href="structdwp__hash__table.html#a0978d29a4d56158c0aa01740e310fdfc">section_pool</a>.<a class="code" href="structdwp__hash__table.html#affa91d46f63f99d33ac14a22f6b7a4ab">v2</a>.sizes =
<a name="l09450"></a>09450         htab-&gt;<a class="code" href="structdwp__hash__table.html#a0978d29a4d56158c0aa01740e310fdfc">section_pool</a>.<a class="code" href="structdwp__hash__table.html#affa91d46f63f99d33ac14a22f6b7a4ab">v2</a>.offsets + (<span class="keyword">sizeof</span> (uint32_t)
<a name="l09451"></a>09451                                          * nr_units * nr_columns);
<a name="l09452"></a>09452       <span class="keywordflow">if</span> ((htab-&gt;<a class="code" href="structdwp__hash__table.html#a0978d29a4d56158c0aa01740e310fdfc">section_pool</a>.<a class="code" href="structdwp__hash__table.html#affa91d46f63f99d33ac14a22f6b7a4ab">v2</a>.sizes + (sizeof (uint32_t)
<a name="l09453"></a>09453                                           * nr_units * <a class="code" href="structdwp__hash__table.html#ae8d2ae0d45ddf25ba7e747073fa27a75">nr_columns</a>))
<a name="l09454"></a>09454           &gt; index_end)
<a name="l09455"></a>09455         {
<a name="l09456"></a>09456           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: DWP index section is corrupt (too small)&quot;</span>
<a name="l09457"></a>09457                    <span class="stringliteral">&quot; [in module %s]&quot;</span>),
<a name="l09458"></a>09458                  dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09459"></a>09459         }
<a name="l09460"></a>09460     }
<a name="l09461"></a>09461 
<a name="l09462"></a>09462   <span class="keywordflow">return</span> htab;
<a name="l09463"></a>09463 }
<a name="l09464"></a>09464 
<a name="l09465"></a>09465 <span class="comment">/* Update SECTIONS with the data from SECTP.</span>
<a name="l09466"></a>09466 <span class="comment"></span>
<a name="l09467"></a>09467 <span class="comment">   This function is like the other &quot;locate&quot; section routines that are</span>
<a name="l09468"></a>09468 <span class="comment">   passed to bfd_map_over_sections, but in this context the sections to</span>
<a name="l09469"></a>09469 <span class="comment">   read comes from the DWP V1 hash table, not the full ELF section table.</span>
<a name="l09470"></a>09470 <span class="comment"></span>
<a name="l09471"></a>09471 <span class="comment">   The result is non-zero for success, or zero if an error was found.  */</span>
<a name="l09472"></a>09472 
<a name="l09473"></a>09473 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l09474"></a><a class="code" href="dwarf2read_8c.html#aa75515d4b83cc8a2c7f753e8d5ab0078">09474</a> <a class="code" href="dwarf2read_8c.html#aa75515d4b83cc8a2c7f753e8d5ab0078">locate_v1_virtual_dwo_sections</a> (asection *sectp,
<a name="l09475"></a>09475                                 <span class="keyword">struct</span> <a class="code" href="structvirtual__v1__dwo__sections.html">virtual_v1_dwo_sections</a> *<a class="code" href="exec_8h.html#a3e0e53a8d37c80fda131b2b35cb2a10f">sections</a>)
<a name="l09476"></a>09476 {
<a name="l09477"></a>09477   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwop__section__names.html">dwop_section_names</a> *names = &amp;<a class="code" href="dwarf2read_8c.html#ac42e1a154a138cd7f3f46ca01347cf17">dwop_section_names</a>;
<a name="l09478"></a>09478 
<a name="l09479"></a>09479   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#ae59cc2816c3829d001953c78ff8cfdf5">abbrev_dwo</a>))
<a name="l09480"></a>09480     {
<a name="l09481"></a>09481       <span class="comment">/* There can be only one.  */</span>
<a name="l09482"></a>09482       <span class="keywordflow">if</span> (sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a501b1f5e3d1cf05f8da6e8a3892e6f20">abbrev</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> != NULL)
<a name="l09483"></a>09483         <span class="keywordflow">return</span> 0;
<a name="l09484"></a>09484       sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a501b1f5e3d1cf05f8da6e8a3892e6f20">abbrev</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l09485"></a>09485       sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a501b1f5e3d1cf05f8da6e8a3892e6f20">abbrev</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l09486"></a>09486     }
<a name="l09487"></a>09487   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#abcabf332b0c04d0f422ed3011178f45e">info_dwo</a>)
<a name="l09488"></a>09488            || <a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a1648f678e86667b0a897e7c7ad1b2cc6">types_dwo</a>))
<a name="l09489"></a>09489     {
<a name="l09490"></a>09490       <span class="comment">/* There can be only one.  */</span>
<a name="l09491"></a>09491       <span class="keywordflow">if</span> (sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a28578fc14ad94d56506c10dd292c0d99">info_or_types</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> != NULL)
<a name="l09492"></a>09492         <span class="keywordflow">return</span> 0;
<a name="l09493"></a>09493       sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a28578fc14ad94d56506c10dd292c0d99">info_or_types</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l09494"></a>09494       sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a28578fc14ad94d56506c10dd292c0d99">info_or_types</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l09495"></a>09495     }
<a name="l09496"></a>09496   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a53e026523c28f96cf9ff9ce9fab9e235">line_dwo</a>))
<a name="l09497"></a>09497     {
<a name="l09498"></a>09498       <span class="comment">/* There can be only one.  */</span>
<a name="l09499"></a>09499       <span class="keywordflow">if</span> (sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#aacffb4df6e97deb27518090f70b0cfaa">line</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> != NULL)
<a name="l09500"></a>09500         <span class="keywordflow">return</span> 0;
<a name="l09501"></a>09501       sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#aacffb4df6e97deb27518090f70b0cfaa">line</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l09502"></a>09502       sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#aacffb4df6e97deb27518090f70b0cfaa">line</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l09503"></a>09503     }
<a name="l09504"></a>09504   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#adc0f06e32cbd1167e26ec1321df8e63b">loc_dwo</a>))
<a name="l09505"></a>09505     {
<a name="l09506"></a>09506       <span class="comment">/* There can be only one.  */</span>
<a name="l09507"></a>09507       <span class="keywordflow">if</span> (sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#afda0ffb4ca37375bed44774dfe162a3b">loc</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> != NULL)
<a name="l09508"></a>09508         <span class="keywordflow">return</span> 0;
<a name="l09509"></a>09509       sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#afda0ffb4ca37375bed44774dfe162a3b">loc</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l09510"></a>09510       sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#afda0ffb4ca37375bed44774dfe162a3b">loc</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l09511"></a>09511     }
<a name="l09512"></a>09512   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a8ebb4a5d32ae6414d9f9aa76b472da96">macinfo_dwo</a>))
<a name="l09513"></a>09513     {
<a name="l09514"></a>09514       <span class="comment">/* There can be only one.  */</span>
<a name="l09515"></a>09515       <span class="keywordflow">if</span> (sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a9df414f3ed733d94b08abf348e94a09e">macinfo</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> != NULL)
<a name="l09516"></a>09516         <span class="keywordflow">return</span> 0;
<a name="l09517"></a>09517       sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a9df414f3ed733d94b08abf348e94a09e">macinfo</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l09518"></a>09518       sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a9df414f3ed733d94b08abf348e94a09e">macinfo</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l09519"></a>09519     }
<a name="l09520"></a>09520   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#aced5043c2932561517e13c66aca3f238">macro_dwo</a>))
<a name="l09521"></a>09521     {
<a name="l09522"></a>09522       <span class="comment">/* There can be only one.  */</span>
<a name="l09523"></a>09523       <span class="keywordflow">if</span> (sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a77527da788781d0bde33d935df16d82c">macro</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> != NULL)
<a name="l09524"></a>09524         <span class="keywordflow">return</span> 0;
<a name="l09525"></a>09525       sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a77527da788781d0bde33d935df16d82c">macro</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l09526"></a>09526       sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a77527da788781d0bde33d935df16d82c">macro</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l09527"></a>09527     }
<a name="l09528"></a>09528   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a31b18ee25231b65438027a3134e9eb9d">str_offsets_dwo</a>))
<a name="l09529"></a>09529     {
<a name="l09530"></a>09530       <span class="comment">/* There can be only one.  */</span>
<a name="l09531"></a>09531       <span class="keywordflow">if</span> (sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a7c2a8ac2bad6195df6b195cce12fde5f">str_offsets</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> != NULL)
<a name="l09532"></a>09532         <span class="keywordflow">return</span> 0;
<a name="l09533"></a>09533       sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a7c2a8ac2bad6195df6b195cce12fde5f">str_offsets</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l09534"></a>09534       sections-&gt;<a class="code" href="structvirtual__v1__dwo__sections.html#a7c2a8ac2bad6195df6b195cce12fde5f">str_offsets</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l09535"></a>09535     }
<a name="l09536"></a>09536   <span class="keywordflow">else</span>
<a name="l09537"></a>09537     {
<a name="l09538"></a>09538       <span class="comment">/* No other kind of section is valid.  */</span>
<a name="l09539"></a>09539       <span class="keywordflow">return</span> 0;
<a name="l09540"></a>09540     }
<a name="l09541"></a>09541 
<a name="l09542"></a>09542   <span class="keywordflow">return</span> 1;
<a name="l09543"></a>09543 }
<a name="l09544"></a>09544 
<a name="l09545"></a>09545 <span class="comment">/* Create a dwo_unit object for the DWO unit with signature SIGNATURE.</span>
<a name="l09546"></a>09546 <span class="comment">   UNIT_INDEX is the index of the DWO unit in the DWP hash table.</span>
<a name="l09547"></a>09547 <span class="comment">   COMP_DIR is the DW_AT_comp_dir attribute of the referencing CU.</span>
<a name="l09548"></a>09548 <span class="comment">   This is for DWP version 1 files.  */</span>
<a name="l09549"></a>09549 
<a name="l09550"></a>09550 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *
<a name="l09551"></a><a class="code" href="dwarf2read_8c.html#a7423a58185472aaf791b45b17f8bf7ed">09551</a> <a class="code" href="dwarf2read_8c.html#a7423a58185472aaf791b45b17f8bf7ed">create_dwo_unit_in_dwp_v1</a> (<span class="keyword">struct</span> <a class="code" href="structdwp__file.html">dwp_file</a> *<a class="code" href="structdwp__file.html">dwp_file</a>,
<a name="l09552"></a>09552                            uint32_t unit_index,
<a name="l09553"></a>09553                            <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir,
<a name="l09554"></a>09554                            <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>, <span class="keywordtype">int</span> is_debug_types)
<a name="l09555"></a>09555 {
<a name="l09556"></a>09556   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l09557"></a>09557   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwp__hash__table.html">dwp_hash_table</a> *dwp_htab =
<a name="l09558"></a>09558     is_debug_types ? dwp_file-&gt;<a class="code" href="structdwp__file.html#a1f5edbd4eb259b9605d86511d87f117c">tus</a> : dwp_file-&gt;<a class="code" href="structdwp__file.html#a6539ad818bafae68a09889c2eb985780">cus</a>;
<a name="l09559"></a>09559   bfd *dbfd = dwp_file-&gt;<a class="code" href="structdwp__file.html#adaac28c08d06f0daf3633e997b0abdb1">dbfd</a>;
<a name="l09560"></a>09560   <span class="keyword">const</span> <span class="keywordtype">char</span> *kind = is_debug_types ? <span class="stringliteral">&quot;TU&quot;</span> : <span class="stringliteral">&quot;CU&quot;</span>;
<a name="l09561"></a>09561   <span class="keyword">struct </span>dwo_file *dwo_file;
<a name="l09562"></a>09562   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structdwo__unit.html">dwo_unit</a>;
<a name="l09563"></a>09563   <span class="keyword">struct </span><a class="code" href="structvirtual__v1__dwo__sections.html">virtual_v1_dwo_sections</a> sections;
<a name="l09564"></a>09564   <span class="keywordtype">void</span> **dwo_file_slot;
<a name="l09565"></a>09565   <span class="keywordtype">char</span> *virtual_dwo_name;
<a name="l09566"></a>09566   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *cutu;
<a name="l09567"></a>09567   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups;
<a name="l09568"></a>09568   <span class="keywordtype">int</span> i;
<a name="l09569"></a>09569 
<a name="l09570"></a>09570   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (dwp_file-&gt;<a class="code" href="structdwp__file.html#a140a3d3a09fc7aaf072b96eae87173fb">version</a> == 1);
<a name="l09571"></a>09571 
<a name="l09572"></a>09572   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l09573"></a>09573     {
<a name="l09574"></a>09574       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Reading %s %s/%s in DWP V1 file: %s\n&quot;</span>,
<a name="l09575"></a>09575                           kind,
<a name="l09576"></a>09576                           <a class="code" href="utils_8c.html#ab74ba9d12a782e5964a4af4ddc5de3ae">pulongest</a> (unit_index), <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (signature),
<a name="l09577"></a>09577                           dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09578"></a>09578     }
<a name="l09579"></a>09579 
<a name="l09580"></a>09580   <span class="comment">/* Fetch the sections of this DWO unit.</span>
<a name="l09581"></a>09581 <span class="comment">     Put a limit on the number of sections we look for so that bad data</span>
<a name="l09582"></a>09582 <span class="comment">     doesn&#39;t cause us to loop forever.  */</span>
<a name="l09583"></a>09583 
<a name="l09584"></a>09584 <span class="preprocessor">#define MAX_NR_V1_DWO_SECTIONS \</span>
<a name="l09585"></a>09585 <span class="preprocessor">  (1 </span><span class="comment">/* .debug_info or .debug_types */</span> \
<a name="l09586"></a>09586    + 1 <span class="comment">/* .debug_abbrev */</span> \
<a name="l09587"></a>09587    + 1 <span class="comment">/* .debug_line */</span> \
<a name="l09588"></a>09588    + 1 <span class="comment">/* .debug_loc */</span> \
<a name="l09589"></a>09589    + 1 <span class="comment">/* .debug_str_offsets */</span> \
<a name="l09590"></a>09590    + 1 <span class="comment">/* .debug_macro or .debug_macinfo */</span> \
<a name="l09591"></a>09591    + 1 <span class="comment">/* trailing zero */</span>)
<a name="l09592"></a>09592 
<a name="l09593"></a>09593   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;sections, 0, <span class="keyword">sizeof</span> (sections));
<a name="l09594"></a>09594   cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, 0);
<a name="l09595"></a>09595 
<a name="l09596"></a>09596   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="dwarf2read_8c.html#a7ee1f309e0bf0d6296c2aa03ea4a134f">MAX_NR_V1_DWO_SECTIONS</a>; ++i)
<a name="l09597"></a>09597     {
<a name="l09598"></a>09598       asection *sectp;
<a name="l09599"></a>09599       uint32_t section_nr =
<a name="l09600"></a>09600         <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (dbfd,
<a name="l09601"></a>09601                       dwp_htab-&gt;<a class="code" href="structdwp__hash__table.html#a0978d29a4d56158c0aa01740e310fdfc">section_pool</a>.<a class="code" href="structdwp__hash__table.html#a26e7e69be056ca2e4f22137f854255a2">v1</a>.indices
<a name="l09602"></a>09602                       + (unit_index + i) * sizeof (uint32_t));
<a name="l09603"></a>09603 
<a name="l09604"></a>09604       <span class="keywordflow">if</span> (section_nr == 0)
<a name="l09605"></a>09605         <span class="keywordflow">break</span>;
<a name="l09606"></a>09606       <span class="keywordflow">if</span> (section_nr &gt;= dwp_file-&gt;<a class="code" href="structdwp__file.html#a3bf1bb3c9f65550e349531242e7cafcc">num_sections</a>)
<a name="l09607"></a>09607         {
<a name="l09608"></a>09608           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: bad DWP hash table, section number too large&quot;</span>
<a name="l09609"></a>09609                    <span class="stringliteral">&quot; [in module %s]&quot;</span>),
<a name="l09610"></a>09610                  dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09611"></a>09611         }
<a name="l09612"></a>09612 
<a name="l09613"></a>09613       sectp = dwp_file-&gt;<a class="code" href="structdwp__file.html#a402f52900899dc36afb1ccabfe8b21cd">elf_sections</a>[section_nr];
<a name="l09614"></a>09614       <span class="keywordflow">if</span> (! <a class="code" href="dwarf2read_8c.html#aa75515d4b83cc8a2c7f753e8d5ab0078">locate_v1_virtual_dwo_sections</a> (sectp, &amp;sections))
<a name="l09615"></a>09615         {
<a name="l09616"></a>09616           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: bad DWP hash table, invalid section found&quot;</span>
<a name="l09617"></a>09617                    <span class="stringliteral">&quot; [in module %s]&quot;</span>),
<a name="l09618"></a>09618                  dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09619"></a>09619         }
<a name="l09620"></a>09620     }
<a name="l09621"></a>09621 
<a name="l09622"></a>09622   <span class="keywordflow">if</span> (i &lt; 2
<a name="l09623"></a>09623       || <a class="code" href="dwarf2read_8c.html#ac9e788fb165d736559a5a07bd4cd8dc1">dwarf2_section_empty_p</a> (&amp;sections.<a class="code" href="structvirtual__v1__dwo__sections.html#a28578fc14ad94d56506c10dd292c0d99">info_or_types</a>)
<a name="l09624"></a>09624       || <a class="code" href="dwarf2read_8c.html#ac9e788fb165d736559a5a07bd4cd8dc1">dwarf2_section_empty_p</a> (&amp;sections.<a class="code" href="structvirtual__v1__dwo__sections.html#a501b1f5e3d1cf05f8da6e8a3892e6f20">abbrev</a>))
<a name="l09625"></a>09625     {
<a name="l09626"></a>09626       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: bad DWP hash table, missing DWO sections&quot;</span>
<a name="l09627"></a>09627                <span class="stringliteral">&quot; [in module %s]&quot;</span>),
<a name="l09628"></a>09628              dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09629"></a>09629     }
<a name="l09630"></a>09630   <span class="keywordflow">if</span> (i == MAX_NR_V1_DWO_SECTIONS)
<a name="l09631"></a>09631     {
<a name="l09632"></a>09632       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: bad DWP hash table, too many DWO sections&quot;</span>
<a name="l09633"></a>09633                <span class="stringliteral">&quot; [in module %s]&quot;</span>),
<a name="l09634"></a>09634              dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09635"></a>09635     }
<a name="l09636"></a>09636 
<a name="l09637"></a>09637   <span class="comment">/* It&#39;s easier for the rest of the code if we fake a struct dwo_file and</span>
<a name="l09638"></a>09638 <span class="comment">     have dwo_unit &quot;live&quot; in that.  At least for now.</span>
<a name="l09639"></a>09639 <span class="comment"></span>
<a name="l09640"></a>09640 <span class="comment">     The DWP file can be made up of a random collection of CUs and TUs.</span>
<a name="l09641"></a>09641 <span class="comment">     However, for each CU + set of TUs that came from the same original DWO</span>
<a name="l09642"></a>09642 <span class="comment">     file, we can combine them back into a virtual DWO file to save space</span>
<a name="l09643"></a>09643 <span class="comment">     (fewer struct dwo_file objects to allocate).  Remember that for really</span>
<a name="l09644"></a>09644 <span class="comment">     large apps there can be on the order of 8K CUs and 200K TUs, or more.  */</span>
<a name="l09645"></a>09645 
<a name="l09646"></a>09646   virtual_dwo_name =
<a name="l09647"></a>09647     <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;virtual-dwo/%d-%d-%d-%d&quot;</span>,
<a name="l09648"></a>09648                 <a class="code" href="dwarf2read_8c.html#a11d63fb1d7c715a9a0c0efe8602d370c">get_section_id</a> (&amp;sections.<a class="code" href="structvirtual__v1__dwo__sections.html#a501b1f5e3d1cf05f8da6e8a3892e6f20">abbrev</a>),
<a name="l09649"></a>09649                 <a class="code" href="dwarf2read_8c.html#a11d63fb1d7c715a9a0c0efe8602d370c">get_section_id</a> (&amp;sections.<a class="code" href="structvirtual__v1__dwo__sections.html#aacffb4df6e97deb27518090f70b0cfaa">line</a>),
<a name="l09650"></a>09650                 <a class="code" href="dwarf2read_8c.html#a11d63fb1d7c715a9a0c0efe8602d370c">get_section_id</a> (&amp;sections.<a class="code" href="structvirtual__v1__dwo__sections.html#afda0ffb4ca37375bed44774dfe162a3b">loc</a>),
<a name="l09651"></a>09651                 <a class="code" href="dwarf2read_8c.html#a11d63fb1d7c715a9a0c0efe8602d370c">get_section_id</a> (&amp;sections.<a class="code" href="structvirtual__v1__dwo__sections.html#a7c2a8ac2bad6195df6b195cce12fde5f">str_offsets</a>));
<a name="l09652"></a>09652   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, virtual_dwo_name);
<a name="l09653"></a>09653   <span class="comment">/* Can we use an existing virtual DWO file?  */</span>
<a name="l09654"></a>09654   dwo_file_slot = <a class="code" href="dwarf2read_8c.html#aef78329d4b39424730119060113478c7">lookup_dwo_file_slot</a> (virtual_dwo_name, comp_dir);
<a name="l09655"></a>09655   <span class="comment">/* Create one if necessary.  */</span>
<a name="l09656"></a>09656   <span class="keywordflow">if</span> (*dwo_file_slot == NULL)
<a name="l09657"></a>09657     {
<a name="l09658"></a>09658       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l09659"></a>09659         {
<a name="l09660"></a>09660           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Creating virtual DWO: %s\n&quot;</span>,
<a name="l09661"></a>09661                               virtual_dwo_name);
<a name="l09662"></a>09662         }
<a name="l09663"></a>09663       dwo_file = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, <span class="keyword">struct</span> dwo_file);
<a name="l09664"></a>09664       dwo_file-&gt;<a class="code" href="structdwo__file.html#a6df466b952ebc265d4610f244196e98a">dwo_name</a> = obstack_copy0 (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l09665"></a>09665                                           virtual_dwo_name,
<a name="l09666"></a>09666                                           strlen (virtual_dwo_name));
<a name="l09667"></a>09667       dwo_file-&gt;<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a> = comp_dir;
<a name="l09668"></a>09668       dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#a77a177199056d70f8c5379e116538cff">abbrev</a> = sections.<a class="code" href="structvirtual__v1__dwo__sections.html#a501b1f5e3d1cf05f8da6e8a3892e6f20">abbrev</a>;
<a name="l09669"></a>09669       dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#af62a3f7d7e5333a93d30eb62504b3f86">line</a> = sections.<a class="code" href="structvirtual__v1__dwo__sections.html#aacffb4df6e97deb27518090f70b0cfaa">line</a>;
<a name="l09670"></a>09670       dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#ad3e9ca4610807f83ad1cc750fe465180">loc</a> = sections.<a class="code" href="structvirtual__v1__dwo__sections.html#afda0ffb4ca37375bed44774dfe162a3b">loc</a>;
<a name="l09671"></a>09671       dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#ae83c45d0e683d0deea40dd56417914e7">macinfo</a> = sections.<a class="code" href="structvirtual__v1__dwo__sections.html#a9df414f3ed733d94b08abf348e94a09e">macinfo</a>;
<a name="l09672"></a>09672       dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#ac745fa5543aa071d521f3b3f6c5829a5">macro</a> = sections.<a class="code" href="structvirtual__v1__dwo__sections.html#a77527da788781d0bde33d935df16d82c">macro</a>;
<a name="l09673"></a>09673       dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#a931377e7a734f721034972c4061af209">str_offsets</a> = sections.<a class="code" href="structvirtual__v1__dwo__sections.html#a7c2a8ac2bad6195df6b195cce12fde5f">str_offsets</a>;
<a name="l09674"></a>09674       <span class="comment">/* The &quot;str&quot; section is global to the entire DWP file.  */</span>
<a name="l09675"></a>09675       dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#ae8ef8aea284e8f15890bc43155754ce2">str</a> = dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a6c2c4c7c122c8801d7762bf918f895ba">str</a>;
<a name="l09676"></a>09676       <span class="comment">/* The info or types section is assigned below to dwo_unit,</span>
<a name="l09677"></a>09677 <span class="comment">         there&#39;s no need to record it in dwo_file.</span>
<a name="l09678"></a>09678 <span class="comment">         Also, we can&#39;t simply record type sections in dwo_file because</span>
<a name="l09679"></a>09679 <span class="comment">         we record a pointer into the vector in dwo_unit.  As we collect more</span>
<a name="l09680"></a>09680 <span class="comment">         types we&#39;ll grow the vector and eventually have to reallocate space</span>
<a name="l09681"></a>09681 <span class="comment">         for it, invalidating all copies of pointers into the previous</span>
<a name="l09682"></a>09682 <span class="comment">         contents.  */</span>
<a name="l09683"></a>09683       *dwo_file_slot = dwo_file;
<a name="l09684"></a>09684     }
<a name="l09685"></a>09685   <span class="keywordflow">else</span>
<a name="l09686"></a>09686     {
<a name="l09687"></a>09687       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l09688"></a>09688         {
<a name="l09689"></a>09689           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Using existing virtual DWO: %s\n&quot;</span>,
<a name="l09690"></a>09690                               virtual_dwo_name);
<a name="l09691"></a>09691         }
<a name="l09692"></a>09692       dwo_file = *dwo_file_slot;
<a name="l09693"></a>09693     }
<a name="l09694"></a>09694   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l09695"></a>09695 
<a name="l09696"></a>09696   dwo_unit = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, <span class="keyword">struct</span> dwo_unit);
<a name="l09697"></a>09697   dwo_unit-&gt;<a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">dwo_file</a> = dwo_file;
<a name="l09698"></a>09698   dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a> = signature;
<a name="l09699"></a>09699   dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a808127fb35d399faddd33a3b28e5ec06">section</a> = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l09700"></a>09700                                      sizeof (<span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a>));
<a name="l09701"></a>09701   *dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a808127fb35d399faddd33a3b28e5ec06">section</a> = sections.<a class="code" href="structvirtual__v1__dwo__sections.html#a28578fc14ad94d56506c10dd292c0d99">info_or_types</a>;
<a name="l09702"></a>09702   <span class="comment">/* dwo_unit-&gt;{offset,length,type_offset_in_tu} are set later.  */</span>
<a name="l09703"></a>09703 
<a name="l09704"></a>09704   <span class="keywordflow">return</span> dwo_unit;
<a name="l09705"></a>09705 }
<a name="l09706"></a>09706 
<a name="l09707"></a>09707 <span class="comment">/* Subroutine of create_dwo_unit_in_dwp_v2 to simplify it.</span>
<a name="l09708"></a>09708 <span class="comment">   Given a pointer to the containing section SECTION, and OFFSET,SIZE of the</span>
<a name="l09709"></a>09709 <span class="comment">   piece within that section used by a TU/CU, return a virtual section</span>
<a name="l09710"></a>09710 <span class="comment">   of just that piece.  */</span>
<a name="l09711"></a>09711 
<a name="l09712"></a>09712 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a>
<a name="l09713"></a><a class="code" href="dwarf2read_8c.html#a6044bf6fbfc0d7570db4cdf97d1266ee">09713</a> <a class="code" href="dwarf2read_8c.html#a6044bf6fbfc0d7570db4cdf97d1266ee">create_dwp_v2_section</a> (struct <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section,
<a name="l09714"></a>09714                        bfd_size_type <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, bfd_size_type <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>)
<a name="l09715"></a>09715 {
<a name="l09716"></a>09716   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> result;
<a name="l09717"></a>09717   <a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> *sectp;
<a name="l09718"></a>09718 
<a name="l09719"></a>09719   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (section != NULL);
<a name="l09720"></a>09720   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!section-&gt;<a class="code" href="structdwarf2__section__info.html#a580140de2ff419885dd24bfc36862b48">is_virtual</a>);
<a name="l09721"></a>09721 
<a name="l09722"></a>09722   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;result, 0, <span class="keyword">sizeof</span> (result));
<a name="l09723"></a>09723   result.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a57c7432f009d2575fa1b3961bf80e912">containing_section</a> = section;
<a name="l09724"></a>09724   result.<a class="code" href="structdwarf2__section__info.html#a580140de2ff419885dd24bfc36862b48">is_virtual</a> = 1;
<a name="l09725"></a>09725 
<a name="l09726"></a>09726   <span class="keywordflow">if</span> (<a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> == 0)
<a name="l09727"></a>09727     <span class="keywordflow">return</span> result;
<a name="l09728"></a>09728 
<a name="l09729"></a>09729   sectp = <a class="code" href="dwarf2read_8c.html#a5d733de1e691ddcd3039d6f5c482fdc2">get_section_bfd_section</a> (section);
<a name="l09730"></a>09730 
<a name="l09731"></a>09731   <span class="comment">/* Flag an error if the piece denoted by OFFSET,SIZE is outside the</span>
<a name="l09732"></a>09732 <span class="comment">     bounds of the real section.  This is a pretty-rare event, so just</span>
<a name="l09733"></a>09733 <span class="comment">     flag an error (easier) instead of a warning and trying to cope.  */</span>
<a name="l09734"></a>09734   <span class="keywordflow">if</span> (sectp == NULL
<a name="l09735"></a>09735       || offset + <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> &gt; bfd_get_section_size (sectp))
<a name="l09736"></a>09736     {
<a name="l09737"></a>09737       bfd *abfd = sectp-&gt;owner;
<a name="l09738"></a>09738 
<a name="l09739"></a>09739       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Bad DWP V2 section info, doesn&#39;t fit&quot;</span>
<a name="l09740"></a>09740                <span class="stringliteral">&quot; in section %s [in module %s]&quot;</span>),
<a name="l09741"></a>09741              sectp ? bfd_section_name (abfd, sectp) : <span class="stringliteral">&quot;&lt;unknown&gt;&quot;</span>,
<a name="l09742"></a>09742              <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (dwarf2_per_objfile-&gt;objfile));
<a name="l09743"></a>09743     }
<a name="l09744"></a>09744 
<a name="l09745"></a>09745   result.<a class="code" href="structdwarf2__section__info.html#a28b1e09df667dbfed7cc7f7a9e8f7e7e">virtual_offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l09746"></a>09746   result.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l09747"></a>09747   <span class="keywordflow">return</span> result;
<a name="l09748"></a>09748 }
<a name="l09749"></a>09749 
<a name="l09750"></a>09750 <span class="comment">/* Create a dwo_unit object for the DWO unit with signature SIGNATURE.</span>
<a name="l09751"></a>09751 <span class="comment">   UNIT_INDEX is the index of the DWO unit in the DWP hash table.</span>
<a name="l09752"></a>09752 <span class="comment">   COMP_DIR is the DW_AT_comp_dir attribute of the referencing CU.</span>
<a name="l09753"></a>09753 <span class="comment">   This is for DWP version 2 files.  */</span>
<a name="l09754"></a>09754 
<a name="l09755"></a>09755 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *
<a name="l09756"></a><a class="code" href="dwarf2read_8c.html#a6e5035962f40c8c99f5578debba7dd89">09756</a> <a class="code" href="dwarf2read_8c.html#a6e5035962f40c8c99f5578debba7dd89">create_dwo_unit_in_dwp_v2</a> (<span class="keyword">struct</span> <a class="code" href="structdwp__file.html">dwp_file</a> *<a class="code" href="structdwp__file.html">dwp_file</a>,
<a name="l09757"></a>09757                            uint32_t unit_index,
<a name="l09758"></a>09758                            <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir,
<a name="l09759"></a>09759                            <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>, <span class="keywordtype">int</span> is_debug_types)
<a name="l09760"></a>09760 {
<a name="l09761"></a>09761   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l09762"></a>09762   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwp__hash__table.html">dwp_hash_table</a> *dwp_htab =
<a name="l09763"></a>09763     is_debug_types ? dwp_file-&gt;<a class="code" href="structdwp__file.html#a1f5edbd4eb259b9605d86511d87f117c">tus</a> : dwp_file-&gt;<a class="code" href="structdwp__file.html#a6539ad818bafae68a09889c2eb985780">cus</a>;
<a name="l09764"></a>09764   bfd *dbfd = dwp_file-&gt;<a class="code" href="structdwp__file.html#adaac28c08d06f0daf3633e997b0abdb1">dbfd</a>;
<a name="l09765"></a>09765   <span class="keyword">const</span> <span class="keywordtype">char</span> *kind = is_debug_types ? <span class="stringliteral">&quot;TU&quot;</span> : <span class="stringliteral">&quot;CU&quot;</span>;
<a name="l09766"></a>09766   <span class="keyword">struct </span>dwo_file *dwo_file;
<a name="l09767"></a>09767   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structdwo__unit.html">dwo_unit</a>;
<a name="l09768"></a>09768   <span class="keyword">struct </span><a class="code" href="structvirtual__v2__dwo__sections.html">virtual_v2_dwo_sections</a> sections;
<a name="l09769"></a>09769   <span class="keywordtype">void</span> **dwo_file_slot;
<a name="l09770"></a>09770   <span class="keywordtype">char</span> *virtual_dwo_name;
<a name="l09771"></a>09771   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *cutu;
<a name="l09772"></a>09772   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups;
<a name="l09773"></a>09773   <span class="keywordtype">int</span> i;
<a name="l09774"></a>09774 
<a name="l09775"></a>09775   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (dwp_file-&gt;<a class="code" href="structdwp__file.html#a140a3d3a09fc7aaf072b96eae87173fb">version</a> == 2);
<a name="l09776"></a>09776 
<a name="l09777"></a>09777   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l09778"></a>09778     {
<a name="l09779"></a>09779       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Reading %s %s/%s in DWP V2 file: %s\n&quot;</span>,
<a name="l09780"></a>09780                           kind,
<a name="l09781"></a>09781                           <a class="code" href="utils_8c.html#ab74ba9d12a782e5964a4af4ddc5de3ae">pulongest</a> (unit_index), <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (signature),
<a name="l09782"></a>09782                           dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09783"></a>09783     }
<a name="l09784"></a>09784 
<a name="l09785"></a>09785   <span class="comment">/* Fetch the section offsets of this DWO unit.  */</span>
<a name="l09786"></a>09786 
<a name="l09787"></a>09787   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;sections, 0, <span class="keyword">sizeof</span> (sections));
<a name="l09788"></a>09788   cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, 0);
<a name="l09789"></a>09789 
<a name="l09790"></a>09790   <span class="keywordflow">for</span> (i = 0; i &lt; dwp_htab-&gt;<a class="code" href="structdwp__hash__table.html#ae8d2ae0d45ddf25ba7e747073fa27a75">nr_columns</a>; ++i)
<a name="l09791"></a>09791     {
<a name="l09792"></a>09792       uint32_t offset = <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (dbfd,
<a name="l09793"></a>09793                                       dwp_htab-&gt;<a class="code" href="structdwp__hash__table.html#a0978d29a4d56158c0aa01740e310fdfc">section_pool</a>.<a class="code" href="structdwp__hash__table.html#affa91d46f63f99d33ac14a22f6b7a4ab">v2</a>.offsets
<a name="l09794"></a>09794                                       + (((unit_index - 1) * dwp_htab-&gt;<a class="code" href="structdwp__hash__table.html#ae8d2ae0d45ddf25ba7e747073fa27a75">nr_columns</a>
<a name="l09795"></a>09795                                           + i)
<a name="l09796"></a>09796                                          * sizeof (uint32_t)));
<a name="l09797"></a>09797       uint32_t <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> = <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (dbfd,
<a name="l09798"></a>09798                                     dwp_htab-&gt;<a class="code" href="structdwp__hash__table.html#a0978d29a4d56158c0aa01740e310fdfc">section_pool</a>.<a class="code" href="structdwp__hash__table.html#affa91d46f63f99d33ac14a22f6b7a4ab">v2</a>.sizes
<a name="l09799"></a>09799                                     + (((unit_index - 1) * dwp_htab-&gt;<a class="code" href="structdwp__hash__table.html#ae8d2ae0d45ddf25ba7e747073fa27a75">nr_columns</a>
<a name="l09800"></a>09800                                         + i)
<a name="l09801"></a>09801                                        * sizeof (uint32_t)));
<a name="l09802"></a>09802 
<a name="l09803"></a>09803       <span class="keywordflow">switch</span> (dwp_htab-&gt;<a class="code" href="structdwp__hash__table.html#a0978d29a4d56158c0aa01740e310fdfc">section_pool</a>.<a class="code" href="structdwp__hash__table.html#affa91d46f63f99d33ac14a22f6b7a4ab">v2</a>.section_ids[i])
<a name="l09804"></a>09804         {
<a name="l09805"></a>09805         <span class="keywordflow">case</span> DW_SECT_INFO:
<a name="l09806"></a>09806         <span class="keywordflow">case</span> DW_SECT_TYPES:
<a name="l09807"></a>09807           sections.<a class="code" href="structvirtual__v2__dwo__sections.html#aae75ff6da59935b575990609652bdcf8">info_or_types_offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l09808"></a>09808           sections.<a class="code" href="structvirtual__v2__dwo__sections.html#af2293306baaead1763e24ad3745dc612">info_or_types_size</a> = <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l09809"></a>09809           <span class="keywordflow">break</span>;
<a name="l09810"></a>09810         <span class="keywordflow">case</span> DW_SECT_ABBREV:
<a name="l09811"></a>09811           sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a75b17e62efbe955972d07a3cff0ef896">abbrev_offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l09812"></a>09812           sections.<a class="code" href="structvirtual__v2__dwo__sections.html#aeaaf1ae665fdd244492e765ab5de6f5a">abbrev_size</a> = <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l09813"></a>09813           <span class="keywordflow">break</span>;
<a name="l09814"></a>09814         <span class="keywordflow">case</span> DW_SECT_LINE:
<a name="l09815"></a>09815           sections.<a class="code" href="structvirtual__v2__dwo__sections.html#ae66a1f7dd61c60b029ba22fb018e9d87">line_offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l09816"></a>09816           sections.<a class="code" href="structvirtual__v2__dwo__sections.html#adbfc93ddb6daaeadfcb3e3a770f95ee7">line_size</a> = <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l09817"></a>09817           <span class="keywordflow">break</span>;
<a name="l09818"></a>09818         <span class="keywordflow">case</span> DW_SECT_LOC:
<a name="l09819"></a>09819           sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a1e345f1a37dd2d3d9ffa1ef3e01e2008">loc_offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l09820"></a>09820           sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a88fcd4ca1a800e139eb19b1ad904a035">loc_size</a> = <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l09821"></a>09821           <span class="keywordflow">break</span>;
<a name="l09822"></a>09822         <span class="keywordflow">case</span> DW_SECT_STR_OFFSETS:
<a name="l09823"></a>09823           sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a6201888dd2e2c792b2670bfe2ed4fe4d">str_offsets_offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l09824"></a>09824           sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a228e439bf2ef92c0e706ae462213f94d">str_offsets_size</a> = <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l09825"></a>09825           <span class="keywordflow">break</span>;
<a name="l09826"></a>09826         <span class="keywordflow">case</span> DW_SECT_MACINFO:
<a name="l09827"></a>09827           sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a72986bbf071184450ed51f514c47d6dc">macinfo_offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l09828"></a>09828           sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a3a94835aa03fd690c88c06bb625f14a5">macinfo_size</a> = <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l09829"></a>09829           <span class="keywordflow">break</span>;
<a name="l09830"></a>09830         <span class="keywordflow">case</span> DW_SECT_MACRO:
<a name="l09831"></a>09831           sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a190f061c6507c1dc7c533d1603f6f9ac">macro_offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l09832"></a>09832           sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a036d6b6cf92d341f33ebb5591573cded">macro_size</a> = <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l09833"></a>09833           <span class="keywordflow">break</span>;
<a name="l09834"></a>09834         }
<a name="l09835"></a>09835     }
<a name="l09836"></a>09836 
<a name="l09837"></a>09837   <span class="comment">/* It&#39;s easier for the rest of the code if we fake a struct dwo_file and</span>
<a name="l09838"></a>09838 <span class="comment">     have dwo_unit &quot;live&quot; in that.  At least for now.</span>
<a name="l09839"></a>09839 <span class="comment"></span>
<a name="l09840"></a>09840 <span class="comment">     The DWP file can be made up of a random collection of CUs and TUs.</span>
<a name="l09841"></a>09841 <span class="comment">     However, for each CU + set of TUs that came from the same original DWO</span>
<a name="l09842"></a>09842 <span class="comment">     file, we can combine them back into a virtual DWO file to save space</span>
<a name="l09843"></a>09843 <span class="comment">     (fewer struct dwo_file objects to allocate).  Remember that for really</span>
<a name="l09844"></a>09844 <span class="comment">     large apps there can be on the order of 8K CUs and 200K TUs, or more.  */</span>
<a name="l09845"></a>09845 
<a name="l09846"></a>09846   virtual_dwo_name =
<a name="l09847"></a>09847     <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;virtual-dwo/%ld-%ld-%ld-%ld&quot;</span>,
<a name="l09848"></a>09848                 (<span class="keywordtype">long</span>) (sections.<a class="code" href="structvirtual__v2__dwo__sections.html#aeaaf1ae665fdd244492e765ab5de6f5a">abbrev_size</a> ? sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a75b17e62efbe955972d07a3cff0ef896">abbrev_offset</a> : 0),
<a name="l09849"></a>09849                 (<span class="keywordtype">long</span>) (sections.<a class="code" href="structvirtual__v2__dwo__sections.html#adbfc93ddb6daaeadfcb3e3a770f95ee7">line_size</a> ? sections.<a class="code" href="structvirtual__v2__dwo__sections.html#ae66a1f7dd61c60b029ba22fb018e9d87">line_offset</a> : 0),
<a name="l09850"></a>09850                 (<span class="keywordtype">long</span>) (sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a88fcd4ca1a800e139eb19b1ad904a035">loc_size</a> ? sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a1e345f1a37dd2d3d9ffa1ef3e01e2008">loc_offset</a> : 0),
<a name="l09851"></a>09851                 (<span class="keywordtype">long</span>) (sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a228e439bf2ef92c0e706ae462213f94d">str_offsets_size</a>
<a name="l09852"></a>09852                         ? sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a6201888dd2e2c792b2670bfe2ed4fe4d">str_offsets_offset</a> : 0));
<a name="l09853"></a>09853   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, virtual_dwo_name);
<a name="l09854"></a>09854   <span class="comment">/* Can we use an existing virtual DWO file?  */</span>
<a name="l09855"></a>09855   dwo_file_slot = <a class="code" href="dwarf2read_8c.html#aef78329d4b39424730119060113478c7">lookup_dwo_file_slot</a> (virtual_dwo_name, comp_dir);
<a name="l09856"></a>09856   <span class="comment">/* Create one if necessary.  */</span>
<a name="l09857"></a>09857   <span class="keywordflow">if</span> (*dwo_file_slot == NULL)
<a name="l09858"></a>09858     {
<a name="l09859"></a>09859       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l09860"></a>09860         {
<a name="l09861"></a>09861           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Creating virtual DWO: %s\n&quot;</span>,
<a name="l09862"></a>09862                               virtual_dwo_name);
<a name="l09863"></a>09863         }
<a name="l09864"></a>09864       dwo_file = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, <span class="keyword">struct</span> dwo_file);
<a name="l09865"></a>09865       dwo_file-&gt;<a class="code" href="structdwo__file.html#a6df466b952ebc265d4610f244196e98a">dwo_name</a> = obstack_copy0 (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l09866"></a>09866                                           virtual_dwo_name,
<a name="l09867"></a>09867                                           strlen (virtual_dwo_name));
<a name="l09868"></a>09868       dwo_file-&gt;<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a> = comp_dir;
<a name="l09869"></a>09869       dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#a77a177199056d70f8c5379e116538cff">abbrev</a> =
<a name="l09870"></a>09870         <a class="code" href="dwarf2read_8c.html#a6044bf6fbfc0d7570db4cdf97d1266ee">create_dwp_v2_section</a> (&amp;dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#afa0a4063d5cde27a487217518620aa1c">abbrev</a>,
<a name="l09871"></a>09871                                sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a75b17e62efbe955972d07a3cff0ef896">abbrev_offset</a>, sections.<a class="code" href="structvirtual__v2__dwo__sections.html#aeaaf1ae665fdd244492e765ab5de6f5a">abbrev_size</a>);
<a name="l09872"></a>09872       dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#af62a3f7d7e5333a93d30eb62504b3f86">line</a> =
<a name="l09873"></a>09873         <a class="code" href="dwarf2read_8c.html#a6044bf6fbfc0d7570db4cdf97d1266ee">create_dwp_v2_section</a> (&amp;dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a78f9d2149461fc3c17cf14437e5aa147">line</a>,
<a name="l09874"></a>09874                                sections.<a class="code" href="structvirtual__v2__dwo__sections.html#ae66a1f7dd61c60b029ba22fb018e9d87">line_offset</a>, sections.<a class="code" href="structvirtual__v2__dwo__sections.html#adbfc93ddb6daaeadfcb3e3a770f95ee7">line_size</a>);
<a name="l09875"></a>09875       dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#ad3e9ca4610807f83ad1cc750fe465180">loc</a> =
<a name="l09876"></a>09876         <a class="code" href="dwarf2read_8c.html#a6044bf6fbfc0d7570db4cdf97d1266ee">create_dwp_v2_section</a> (&amp;dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a20c97d6a71b1e68d9b0746eb37843dbf">loc</a>,
<a name="l09877"></a>09877                                sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a1e345f1a37dd2d3d9ffa1ef3e01e2008">loc_offset</a>, sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a88fcd4ca1a800e139eb19b1ad904a035">loc_size</a>);
<a name="l09878"></a>09878       dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#ae83c45d0e683d0deea40dd56417914e7">macinfo</a> =
<a name="l09879"></a>09879         <a class="code" href="dwarf2read_8c.html#a6044bf6fbfc0d7570db4cdf97d1266ee">create_dwp_v2_section</a> (&amp;dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#aaf6bc577681a8b83d024fb097dc13580">macinfo</a>,
<a name="l09880"></a>09880                                sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a72986bbf071184450ed51f514c47d6dc">macinfo_offset</a>, sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a3a94835aa03fd690c88c06bb625f14a5">macinfo_size</a>);
<a name="l09881"></a>09881       dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#ac745fa5543aa071d521f3b3f6c5829a5">macro</a> =
<a name="l09882"></a>09882         <a class="code" href="dwarf2read_8c.html#a6044bf6fbfc0d7570db4cdf97d1266ee">create_dwp_v2_section</a> (&amp;dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a859d4582e590abb12e969a750bac824a">macro</a>,
<a name="l09883"></a>09883                                sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a190f061c6507c1dc7c533d1603f6f9ac">macro_offset</a>, sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a036d6b6cf92d341f33ebb5591573cded">macro_size</a>);
<a name="l09884"></a>09884       dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#a931377e7a734f721034972c4061af209">str_offsets</a> =
<a name="l09885"></a>09885         <a class="code" href="dwarf2read_8c.html#a6044bf6fbfc0d7570db4cdf97d1266ee">create_dwp_v2_section</a> (&amp;dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a8ff194c59ebf0fe4c9606c21de25f5b8">str_offsets</a>,
<a name="l09886"></a>09886                                sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a6201888dd2e2c792b2670bfe2ed4fe4d">str_offsets_offset</a>,
<a name="l09887"></a>09887                                sections.<a class="code" href="structvirtual__v2__dwo__sections.html#a228e439bf2ef92c0e706ae462213f94d">str_offsets_size</a>);
<a name="l09888"></a>09888       <span class="comment">/* The &quot;str&quot; section is global to the entire DWP file.  */</span>
<a name="l09889"></a>09889       dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#ae8ef8aea284e8f15890bc43155754ce2">str</a> = dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a6c2c4c7c122c8801d7762bf918f895ba">str</a>;
<a name="l09890"></a>09890       <span class="comment">/* The info or types section is assigned below to dwo_unit,</span>
<a name="l09891"></a>09891 <span class="comment">         there&#39;s no need to record it in dwo_file.</span>
<a name="l09892"></a>09892 <span class="comment">         Also, we can&#39;t simply record type sections in dwo_file because</span>
<a name="l09893"></a>09893 <span class="comment">         we record a pointer into the vector in dwo_unit.  As we collect more</span>
<a name="l09894"></a>09894 <span class="comment">         types we&#39;ll grow the vector and eventually have to reallocate space</span>
<a name="l09895"></a>09895 <span class="comment">         for it, invalidating all copies of pointers into the previous</span>
<a name="l09896"></a>09896 <span class="comment">         contents.  */</span>
<a name="l09897"></a>09897       *dwo_file_slot = dwo_file;
<a name="l09898"></a>09898     }
<a name="l09899"></a>09899   <span class="keywordflow">else</span>
<a name="l09900"></a>09900     {
<a name="l09901"></a>09901       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l09902"></a>09902         {
<a name="l09903"></a>09903           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Using existing virtual DWO: %s\n&quot;</span>,
<a name="l09904"></a>09904                               virtual_dwo_name);
<a name="l09905"></a>09905         }
<a name="l09906"></a>09906       dwo_file = *dwo_file_slot;
<a name="l09907"></a>09907     }
<a name="l09908"></a>09908   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l09909"></a>09909 
<a name="l09910"></a>09910   dwo_unit = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, <span class="keyword">struct</span> dwo_unit);
<a name="l09911"></a>09911   dwo_unit-&gt;<a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">dwo_file</a> = dwo_file;
<a name="l09912"></a>09912   dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a> = signature;
<a name="l09913"></a>09913   dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a808127fb35d399faddd33a3b28e5ec06">section</a> = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l09914"></a>09914                                      sizeof (<span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a>));
<a name="l09915"></a>09915   *dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a808127fb35d399faddd33a3b28e5ec06">section</a> = <a class="code" href="dwarf2read_8c.html#a6044bf6fbfc0d7570db4cdf97d1266ee">create_dwp_v2_section</a> (is_debug_types
<a name="l09916"></a>09916                                               ? &amp;dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a9c5d6ccbf31f42fb4ce3c8a85b9b07d5">types</a>
<a name="l09917"></a>09917                                               : &amp;dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a7d11f4f122b19804504fb5d9957a05ee">info</a>,
<a name="l09918"></a>09918                                               sections.<a class="code" href="structvirtual__v2__dwo__sections.html#aae75ff6da59935b575990609652bdcf8">info_or_types_offset</a>,
<a name="l09919"></a>09919                                               sections.<a class="code" href="structvirtual__v2__dwo__sections.html#af2293306baaead1763e24ad3745dc612">info_or_types_size</a>);
<a name="l09920"></a>09920   <span class="comment">/* dwo_unit-&gt;{offset,length,type_offset_in_tu} are set later.  */</span>
<a name="l09921"></a>09921 
<a name="l09922"></a>09922   <span class="keywordflow">return</span> dwo_unit;
<a name="l09923"></a>09923 }
<a name="l09924"></a>09924 
<a name="l09925"></a>09925 <span class="comment">/* Lookup the DWO unit with SIGNATURE in DWP_FILE.</span>
<a name="l09926"></a>09926 <span class="comment">   Returns NULL if the signature isn&#39;t found.  */</span>
<a name="l09927"></a>09927 
<a name="l09928"></a>09928 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *
<a name="l09929"></a><a class="code" href="dwarf2read_8c.html#a5637d18b01ed205a41181e3cac6e442c">09929</a> <a class="code" href="dwarf2read_8c.html#a5637d18b01ed205a41181e3cac6e442c">lookup_dwo_unit_in_dwp</a> (<span class="keyword">struct</span> <a class="code" href="structdwp__file.html">dwp_file</a> *<a class="code" href="structdwp__file.html">dwp_file</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir,
<a name="l09930"></a>09930                         <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>, <span class="keywordtype">int</span> is_debug_types)
<a name="l09931"></a>09931 {
<a name="l09932"></a>09932   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwp__hash__table.html">dwp_hash_table</a> *dwp_htab =
<a name="l09933"></a>09933     is_debug_types ? dwp_file-&gt;<a class="code" href="structdwp__file.html#a1f5edbd4eb259b9605d86511d87f117c">tus</a> : dwp_file-&gt;<a class="code" href="structdwp__file.html#a6539ad818bafae68a09889c2eb985780">cus</a>;
<a name="l09934"></a>09934   bfd *dbfd = dwp_file-&gt;<a class="code" href="structdwp__file.html#adaac28c08d06f0daf3633e997b0abdb1">dbfd</a>;
<a name="l09935"></a>09935   uint32_t mask = dwp_htab-&gt;<a class="code" href="structdwp__hash__table.html#acba74e56ea8e20a178776efb67f1f116">nr_slots</a> - 1;
<a name="l09936"></a>09936   uint32_t <a class="code" href="bcache_8c.html#a680b4550cc69a0827af4a7169fe3c372">hash</a> = signature &amp; mask;
<a name="l09937"></a>09937   uint32_t hash2 = ((signature &gt;&gt; 32) &amp; mask) | 1;
<a name="l09938"></a>09938   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l09939"></a>09939   <span class="keywordtype">void</span> **slot;
<a name="l09940"></a>09940   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> find_dwo_cu, *dwo_cu;
<a name="l09941"></a>09941 
<a name="l09942"></a>09942   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;find_dwo_cu, 0, <span class="keyword">sizeof</span> (find_dwo_cu));
<a name="l09943"></a>09943   find_dwo_cu.<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a> = <a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>;
<a name="l09944"></a>09944   slot = htab_find_slot (is_debug_types
<a name="l09945"></a>09945                          ? dwp_file-&gt;<a class="code" href="structdwp__file.html#a9115bf303bce67f7e83c91ec1c7ffb8f">loaded_tus</a>
<a name="l09946"></a>09946                          : dwp_file-&gt;<a class="code" href="structdwp__file.html#a4a52577c25dc38801f555317f99f7731">loaded_cus</a>,
<a name="l09947"></a>09947                          &amp;find_dwo_cu, INSERT);
<a name="l09948"></a>09948 
<a name="l09949"></a>09949   <span class="keywordflow">if</span> (*slot != NULL)
<a name="l09950"></a>09950     <span class="keywordflow">return</span> *slot;
<a name="l09951"></a>09951 
<a name="l09952"></a>09952   <span class="comment">/* Use a for loop so that we don&#39;t loop forever on bad debug info.  */</span>
<a name="l09953"></a>09953   <span class="keywordflow">for</span> (i = 0; i &lt; dwp_htab-&gt;<a class="code" href="structdwp__hash__table.html#acba74e56ea8e20a178776efb67f1f116">nr_slots</a>; ++i)
<a name="l09954"></a>09954     {
<a name="l09955"></a>09955       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> signature_in_table;
<a name="l09956"></a>09956 
<a name="l09957"></a>09957       signature_in_table =
<a name="l09958"></a>09958         <a class="code" href="dwarf2read_8c.html#af21c01feb67cfb3cd240c3ac803dd021">read_8_bytes</a> (dbfd, dwp_htab-&gt;<a class="code" href="structdwp__hash__table.html#a57d51c828de01425fca35da068091053">hash_table</a> + hash * sizeof (uint64_t));
<a name="l09959"></a>09959       <span class="keywordflow">if</span> (signature_in_table == signature)
<a name="l09960"></a>09960         {
<a name="l09961"></a>09961           uint32_t unit_index =
<a name="l09962"></a>09962             <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (dbfd,
<a name="l09963"></a>09963                           dwp_htab-&gt;<a class="code" href="structdwp__hash__table.html#a39f54c3b62972c745b825ca208f75dc3">unit_table</a> + hash * sizeof (uint32_t));
<a name="l09964"></a>09964 
<a name="l09965"></a>09965           <span class="keywordflow">if</span> (dwp_file-&gt;<a class="code" href="structdwp__file.html#a140a3d3a09fc7aaf072b96eae87173fb">version</a> == 1)
<a name="l09966"></a>09966             {
<a name="l09967"></a>09967               *slot = <a class="code" href="dwarf2read_8c.html#a7423a58185472aaf791b45b17f8bf7ed">create_dwo_unit_in_dwp_v1</a> (dwp_file, unit_index,
<a name="l09968"></a>09968                                                  comp_dir, signature,
<a name="l09969"></a>09969                                                  is_debug_types);
<a name="l09970"></a>09970             }
<a name="l09971"></a>09971           <span class="keywordflow">else</span>
<a name="l09972"></a>09972             {
<a name="l09973"></a>09973               *slot = <a class="code" href="dwarf2read_8c.html#a6e5035962f40c8c99f5578debba7dd89">create_dwo_unit_in_dwp_v2</a> (dwp_file, unit_index,
<a name="l09974"></a>09974                                                  comp_dir, signature,
<a name="l09975"></a>09975                                                  is_debug_types);
<a name="l09976"></a>09976             }
<a name="l09977"></a>09977           <span class="keywordflow">return</span> *slot;
<a name="l09978"></a>09978         }
<a name="l09979"></a>09979       <span class="keywordflow">if</span> (signature_in_table == 0)
<a name="l09980"></a>09980         <span class="keywordflow">return</span> NULL;
<a name="l09981"></a>09981       hash = (hash + hash2) &amp; mask;
<a name="l09982"></a>09982     }
<a name="l09983"></a>09983 
<a name="l09984"></a>09984   <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: bad DWP hash table, lookup didn&#39;t terminate&quot;</span>
<a name="l09985"></a>09985            <span class="stringliteral">&quot; [in module %s]&quot;</span>),
<a name="l09986"></a>09986          dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l09987"></a>09987 }
<a name="l09988"></a>09988 
<a name="l09989"></a>09989 <span class="comment">/* Subroutine of open_dwo_file,open_dwp_file to simplify them.</span>
<a name="l09990"></a>09990 <span class="comment">   Open the file specified by FILE_NAME and hand it off to BFD for</span>
<a name="l09991"></a>09991 <span class="comment">   preliminary analysis.  Return a newly initialized bfd *, which</span>
<a name="l09992"></a>09992 <span class="comment">   includes a canonicalized copy of FILE_NAME.</span>
<a name="l09993"></a>09993 <span class="comment">   If IS_DWP is TRUE, we&#39;re opening a DWP file, otherwise a DWO file.</span>
<a name="l09994"></a>09994 <span class="comment">   SEARCH_CWD is true if the current directory is to be searched.</span>
<a name="l09995"></a>09995 <span class="comment">   It will be searched before debug-file-directory.</span>
<a name="l09996"></a>09996 <span class="comment">   If unable to find/open the file, return NULL.</span>
<a name="l09997"></a>09997 <span class="comment">   NOTE: This function is derived from symfile_bfd_open.  */</span>
<a name="l09998"></a>09998 
<a name="l09999"></a>09999 <span class="keyword">static</span> bfd *
<a name="l10000"></a><a class="code" href="dwarf2read_8c.html#a40b1592109b0809e619843fa99732f03">10000</a> <a class="code" href="dwarf2read_8c.html#a40b1592109b0809e619843fa99732f03">try_open_dwop_file</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *file_name, <span class="keywordtype">int</span> is_dwp, <span class="keywordtype">int</span> search_cwd)
<a name="l10001"></a>10001 {
<a name="l10002"></a>10002   bfd *sym_bfd;
<a name="l10003"></a>10003   <span class="keywordtype">int</span> desc, <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>;
<a name="l10004"></a>10004   <span class="keywordtype">char</span> *absolute_name;
<a name="l10005"></a>10005   <span class="comment">/* Blech.  OPF_TRY_CWD_FIRST also disables searching the path list if</span>
<a name="l10006"></a>10006 <span class="comment">     FILE_NAME contains a &#39;/&#39;.  So we can&#39;t use it.  Instead prepend &quot;.&quot;</span>
<a name="l10007"></a>10007 <span class="comment">     to debug_file_directory.  */</span>
<a name="l10008"></a>10008   <span class="keywordtype">char</span> *search_path;
<a name="l10009"></a>10009   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> dirname_separator_string[] = { DIRNAME_SEPARATOR, <span class="charliteral">&#39;\0&#39;</span> };
<a name="l10010"></a>10010 
<a name="l10011"></a>10011   <span class="keywordflow">if</span> (search_cwd)
<a name="l10012"></a>10012     {
<a name="l10013"></a>10013       <span class="keywordflow">if</span> (*<a class="code" href="defs_8h.html#a8c8cf5a84683f83d8b6e49a10b17473f">debug_file_directory</a> != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l10014"></a>10014         search_path = concat (<span class="stringliteral">&quot;.&quot;</span>, dirname_separator_string,
<a name="l10015"></a>10015                               <a class="code" href="defs_8h.html#a8c8cf5a84683f83d8b6e49a10b17473f">debug_file_directory</a>, NULL);
<a name="l10016"></a>10016       <span class="keywordflow">else</span>
<a name="l10017"></a>10017         search_path = xstrdup (<span class="stringliteral">&quot;.&quot;</span>);
<a name="l10018"></a>10018     }
<a name="l10019"></a>10019   <span class="keywordflow">else</span>
<a name="l10020"></a>10020     search_path = xstrdup (<a class="code" href="defs_8h.html#a8c8cf5a84683f83d8b6e49a10b17473f">debug_file_directory</a>);
<a name="l10021"></a>10021 
<a name="l10022"></a>10022   flags = <a class="code" href="defs_8h.html#aa669554d54e1c74b6654a123f95205ff">OPF_RETURN_REALPATH</a>;
<a name="l10023"></a>10023   <span class="keywordflow">if</span> (is_dwp)
<a name="l10024"></a>10024     flags |= <a class="code" href="defs_8h.html#a127eb06f9722fb25875390cbcfbaec08">OPF_SEARCH_IN_PATH</a>;
<a name="l10025"></a>10025   desc = <a class="code" href="defs_8h.html#ad1c5ec0f63e79e6293a00ca1a30de767">openp</a> (search_path, flags, file_name,
<a name="l10026"></a>10026                 O_RDONLY | O_BINARY, &amp;absolute_name);
<a name="l10027"></a>10027   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (search_path);
<a name="l10028"></a>10028   <span class="keywordflow">if</span> (desc &lt; 0)
<a name="l10029"></a>10029     <span class="keywordflow">return</span> NULL;
<a name="l10030"></a>10030 
<a name="l10031"></a>10031   sym_bfd = <a class="code" href="gdb__bfd_8c.html#a5ba645a00a78462b46b2d0c3445eb988">gdb_bfd_open</a> (absolute_name, <a class="code" href="corefile_8c.html#aa6db5afe2b3bfa2cec356b9e68eea21d">gnutarget</a>, desc);
<a name="l10032"></a>10032   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (absolute_name);
<a name="l10033"></a>10033   <span class="keywordflow">if</span> (sym_bfd == NULL)
<a name="l10034"></a>10034     <span class="keywordflow">return</span> NULL;
<a name="l10035"></a>10035   bfd_set_cacheable (sym_bfd, 1);
<a name="l10036"></a>10036 
<a name="l10037"></a>10037   <span class="keywordflow">if</span> (!bfd_check_format (sym_bfd, bfd_object))
<a name="l10038"></a>10038     {
<a name="l10039"></a>10039       <a class="code" href="gdb__bfd_8c.html#a1027b59a8494f937b5760901040dc125">gdb_bfd_unref</a> (sym_bfd); <span class="comment">/* This also closes desc.  */</span>
<a name="l10040"></a>10040       <span class="keywordflow">return</span> NULL;
<a name="l10041"></a>10041     }
<a name="l10042"></a>10042 
<a name="l10043"></a>10043   <span class="keywordflow">return</span> sym_bfd;
<a name="l10044"></a>10044 }
<a name="l10045"></a>10045 
<a name="l10046"></a>10046 <span class="comment">/* Try to open DWO file FILE_NAME.</span>
<a name="l10047"></a>10047 <span class="comment">   COMP_DIR is the DW_AT_comp_dir attribute.</span>
<a name="l10048"></a>10048 <span class="comment">   The result is the bfd handle of the file.</span>
<a name="l10049"></a>10049 <span class="comment">   If there is a problem finding or opening the file, return NULL.</span>
<a name="l10050"></a>10050 <span class="comment">   Upon success, the canonicalized path of the file is stored in the bfd,</span>
<a name="l10051"></a>10051 <span class="comment">   same as symfile_bfd_open.  */</span>
<a name="l10052"></a>10052 
<a name="l10053"></a>10053 <span class="keyword">static</span> bfd *
<a name="l10054"></a><a class="code" href="dwarf2read_8c.html#af50486fb7cc9d99172418a4173c485c1">10054</a> <a class="code" href="dwarf2read_8c.html#af50486fb7cc9d99172418a4173c485c1">open_dwo_file</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *file_name, <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir)
<a name="l10055"></a>10055 {
<a name="l10056"></a>10056   bfd *abfd;
<a name="l10057"></a>10057 
<a name="l10058"></a>10058   <span class="keywordflow">if</span> (IS_ABSOLUTE_PATH (file_name))
<a name="l10059"></a>10059     <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a40b1592109b0809e619843fa99732f03">try_open_dwop_file</a> (file_name, 0 <span class="comment">/*is_dwp*/</span>, 0 <span class="comment">/*search_cwd*/</span>);
<a name="l10060"></a>10060 
<a name="l10061"></a>10061   <span class="comment">/* Before trying the search path, try DWO_NAME in COMP_DIR.  */</span>
<a name="l10062"></a>10062 
<a name="l10063"></a>10063   <span class="keywordflow">if</span> (comp_dir != NULL)
<a name="l10064"></a>10064     {
<a name="l10065"></a>10065       <span class="keywordtype">char</span> *path_to_try = concat (comp_dir, SLASH_STRING, file_name, NULL);
<a name="l10066"></a>10066 
<a name="l10067"></a>10067       <span class="comment">/* NOTE: If comp_dir is a relative path, this will also try the</span>
<a name="l10068"></a>10068 <span class="comment">         search path, which seems useful.  */</span>
<a name="l10069"></a>10069       abfd = <a class="code" href="dwarf2read_8c.html#a40b1592109b0809e619843fa99732f03">try_open_dwop_file</a> (path_to_try, 0 <span class="comment">/*is_dwp*/</span>, 1 <span class="comment">/*search_cwd*/</span>);
<a name="l10070"></a>10070       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (path_to_try);
<a name="l10071"></a>10071       <span class="keywordflow">if</span> (abfd != NULL)
<a name="l10072"></a>10072         <span class="keywordflow">return</span> abfd;
<a name="l10073"></a>10073     }
<a name="l10074"></a>10074 
<a name="l10075"></a>10075   <span class="comment">/* That didn&#39;t work, try debug-file-directory, which, despite its name,</span>
<a name="l10076"></a>10076 <span class="comment">     is a list of paths.  */</span>
<a name="l10077"></a>10077 
<a name="l10078"></a>10078   <span class="keywordflow">if</span> (*<a class="code" href="defs_8h.html#a8c8cf5a84683f83d8b6e49a10b17473f">debug_file_directory</a> == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l10079"></a>10079     <span class="keywordflow">return</span> NULL;
<a name="l10080"></a>10080 
<a name="l10081"></a>10081   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a40b1592109b0809e619843fa99732f03">try_open_dwop_file</a> (file_name, 0 <span class="comment">/*is_dwp*/</span>, 1 <span class="comment">/*search_cwd*/</span>);
<a name="l10082"></a>10082 }
<a name="l10083"></a>10083 
<a name="l10084"></a>10084 <span class="comment">/* This function is mapped across the sections and remembers the offset and</span>
<a name="l10085"></a>10085 <span class="comment">   size of each of the DWO debugging sections we are interested in.  */</span>
<a name="l10086"></a>10086 
<a name="l10087"></a>10087 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l10088"></a><a class="code" href="dwarf2read_8c.html#a6d40411ad30be3f82a7a3806e4671992">10088</a> <a class="code" href="dwarf2read_8c.html#a6d40411ad30be3f82a7a3806e4671992">dwarf2_locate_dwo_sections</a> (bfd *abfd, asection *sectp, <span class="keywordtype">void</span> *dwo_sections_ptr)
<a name="l10089"></a>10089 {
<a name="l10090"></a>10090   <span class="keyword">struct </span><a class="code" href="structdwo__sections.html">dwo_sections</a> *<a class="code" href="structdwo__sections.html">dwo_sections</a> = dwo_sections_ptr;
<a name="l10091"></a>10091   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwop__section__names.html">dwop_section_names</a> *names = &amp;<a class="code" href="dwarf2read_8c.html#ac42e1a154a138cd7f3f46ca01347cf17">dwop_section_names</a>;
<a name="l10092"></a>10092 
<a name="l10093"></a>10093   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#ae59cc2816c3829d001953c78ff8cfdf5">abbrev_dwo</a>))
<a name="l10094"></a>10094     {
<a name="l10095"></a>10095       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#a77a177199056d70f8c5379e116538cff">abbrev</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10096"></a>10096       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#a77a177199056d70f8c5379e116538cff">abbrev</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10097"></a>10097     }
<a name="l10098"></a>10098   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#abcabf332b0c04d0f422ed3011178f45e">info_dwo</a>))
<a name="l10099"></a>10099     {
<a name="l10100"></a>10100       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#adf20047f5e83d7bbaa527ee01e0fe71a">info</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10101"></a>10101       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#adf20047f5e83d7bbaa527ee01e0fe71a">info</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10102"></a>10102     }
<a name="l10103"></a>10103   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a53e026523c28f96cf9ff9ce9fab9e235">line_dwo</a>))
<a name="l10104"></a>10104     {
<a name="l10105"></a>10105       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#af62a3f7d7e5333a93d30eb62504b3f86">line</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10106"></a>10106       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#af62a3f7d7e5333a93d30eb62504b3f86">line</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10107"></a>10107     }
<a name="l10108"></a>10108   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#adc0f06e32cbd1167e26ec1321df8e63b">loc_dwo</a>))
<a name="l10109"></a>10109     {
<a name="l10110"></a>10110       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#ad3e9ca4610807f83ad1cc750fe465180">loc</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10111"></a>10111       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#ad3e9ca4610807f83ad1cc750fe465180">loc</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10112"></a>10112     }
<a name="l10113"></a>10113   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a8ebb4a5d32ae6414d9f9aa76b472da96">macinfo_dwo</a>))
<a name="l10114"></a>10114     {
<a name="l10115"></a>10115       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#ae83c45d0e683d0deea40dd56417914e7">macinfo</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10116"></a>10116       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#ae83c45d0e683d0deea40dd56417914e7">macinfo</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10117"></a>10117     }
<a name="l10118"></a>10118   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#aced5043c2932561517e13c66aca3f238">macro_dwo</a>))
<a name="l10119"></a>10119     {
<a name="l10120"></a>10120       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#ac745fa5543aa071d521f3b3f6c5829a5">macro</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10121"></a>10121       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#ac745fa5543aa071d521f3b3f6c5829a5">macro</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10122"></a>10122     }
<a name="l10123"></a>10123   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a0b6c94a6d611e5e3faac78072091d743">str_dwo</a>))
<a name="l10124"></a>10124     {
<a name="l10125"></a>10125       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#ae8ef8aea284e8f15890bc43155754ce2">str</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10126"></a>10126       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#ae8ef8aea284e8f15890bc43155754ce2">str</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10127"></a>10127     }
<a name="l10128"></a>10128   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a31b18ee25231b65438027a3134e9eb9d">str_offsets_dwo</a>))
<a name="l10129"></a>10129     {
<a name="l10130"></a>10130       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#a931377e7a734f721034972c4061af209">str_offsets</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10131"></a>10131       dwo_sections-&gt;<a class="code" href="structdwo__sections.html#a931377e7a734f721034972c4061af209">str_offsets</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10132"></a>10132     }
<a name="l10133"></a>10133   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a1648f678e86667b0a897e7c7ad1b2cc6">types_dwo</a>))
<a name="l10134"></a>10134     {
<a name="l10135"></a>10135       <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> type_section;
<a name="l10136"></a>10136 
<a name="l10137"></a>10137       <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;type_section, 0, <span class="keyword">sizeof</span> (type_section));
<a name="l10138"></a>10138       type_section.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10139"></a>10139       type_section.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10140"></a>10140       <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>, dwo_sections-&gt;types,
<a name="l10141"></a>10141                      &amp;type_section);
<a name="l10142"></a>10142     }
<a name="l10143"></a>10143 }
<a name="l10144"></a>10144 
<a name="l10145"></a>10145 <span class="comment">/* Initialize the use of the DWO file specified by DWO_NAME and referenced</span>
<a name="l10146"></a>10146 <span class="comment">   by PER_CU.  This is for the non-DWP case.</span>
<a name="l10147"></a>10147 <span class="comment">   The result is NULL if DWO_NAME can&#39;t be found.  */</span>
<a name="l10148"></a>10148 
<a name="l10149"></a>10149 <span class="keyword">static</span> <span class="keyword">struct </span>dwo_file *
<a name="l10150"></a><a class="code" href="dwarf2read_8c.html#aa2951a909d73401ea9fb5b7afdeabbb9">10150</a> <a class="code" href="dwarf2read_8c.html#aa2951a909d73401ea9fb5b7afdeabbb9">open_and_init_dwo_file</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu,
<a name="l10151"></a>10151                         <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structdwo__file.html#a6df466b952ebc265d4610f244196e98a">dwo_name</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a>)
<a name="l10152"></a>10152 {
<a name="l10153"></a>10153   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l10154"></a>10154   <span class="keyword">struct </span>dwo_file *dwo_file;
<a name="l10155"></a>10155   bfd *<a class="code" href="structdwo__file.html#a4121c7ff5fcbf6715852bd45d8e5c6a0">dbfd</a>;
<a name="l10156"></a>10156   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups;
<a name="l10157"></a>10157 
<a name="l10158"></a>10158   dbfd = <a class="code" href="dwarf2read_8c.html#af50486fb7cc9d99172418a4173c485c1">open_dwo_file</a> (dwo_name, comp_dir);
<a name="l10159"></a>10159   <span class="keywordflow">if</span> (dbfd == NULL)
<a name="l10160"></a>10160     {
<a name="l10161"></a>10161       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l10162"></a>10162         <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;DWO file not found: %s\n&quot;</span>, dwo_name);
<a name="l10163"></a>10163       <span class="keywordflow">return</span> NULL;
<a name="l10164"></a>10164     }
<a name="l10165"></a>10165   dwo_file = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, <span class="keyword">struct</span> dwo_file);
<a name="l10166"></a>10166   dwo_file-&gt;<a class="code" href="structdwo__file.html#a6df466b952ebc265d4610f244196e98a">dwo_name</a> = dwo_name;
<a name="l10167"></a>10167   dwo_file-&gt;<a class="code" href="structdwo__file.html#a7d03dd473a2254f3155c00d6fb3a02de">comp_dir</a> = comp_dir;
<a name="l10168"></a>10168   dwo_file-&gt;<a class="code" href="structdwo__file.html#a4121c7ff5fcbf6715852bd45d8e5c6a0">dbfd</a> = dbfd;
<a name="l10169"></a>10169 
<a name="l10170"></a>10170   cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#a3d1244c7c7e2daa658b3e4e49cd406bf">free_dwo_file_cleanup</a>, dwo_file);
<a name="l10171"></a>10171 
<a name="l10172"></a>10172   bfd_map_over_sections (dbfd, <a class="code" href="dwarf2read_8c.html#a6d40411ad30be3f82a7a3806e4671992">dwarf2_locate_dwo_sections</a>, &amp;dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>);
<a name="l10173"></a>10173 
<a name="l10174"></a>10174   dwo_file-&gt;<a class="code" href="structdwo__file.html#a2da7541da154b831fe9428d4f390e932">cu</a> = <a class="code" href="dwarf2read_8c.html#a956cef4fbd3cdd49fc9b80d528d56ea3">create_dwo_cu</a> (dwo_file);
<a name="l10175"></a>10175 
<a name="l10176"></a>10176   dwo_file-&gt;<a class="code" href="structdwo__file.html#a6ce93a5371a6e123e009d98d81f93ab2">tus</a> = <a class="code" href="dwarf2read_8c.html#a3e7ce9c1cd2b774ed73474dd4576de01">create_debug_types_hash_table</a> (dwo_file,
<a name="l10177"></a>10177                                                  dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.types);
<a name="l10178"></a>10178 
<a name="l10179"></a>10179   <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (cleanups);
<a name="l10180"></a>10180 
<a name="l10181"></a>10181   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l10182"></a>10182     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;DWO file found: %s\n&quot;</span>, dwo_name);
<a name="l10183"></a>10183 
<a name="l10184"></a>10184   <span class="keywordflow">return</span> dwo_file;
<a name="l10185"></a>10185 }
<a name="l10186"></a>10186 
<a name="l10187"></a>10187 <span class="comment">/* This function is mapped across the sections and remembers the offset and</span>
<a name="l10188"></a>10188 <span class="comment">   size of each of the DWP debugging sections common to version 1 and 2 that</span>
<a name="l10189"></a>10189 <span class="comment">   we are interested in.  */</span>
<a name="l10190"></a>10190 
<a name="l10191"></a>10191 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l10192"></a><a class="code" href="dwarf2read_8c.html#a2288b0918decf7f7910a08d6e6eadfe7">10192</a> <a class="code" href="dwarf2read_8c.html#a2288b0918decf7f7910a08d6e6eadfe7">dwarf2_locate_common_dwp_sections</a> (bfd *abfd, asection *sectp,
<a name="l10193"></a>10193                                    <span class="keywordtype">void</span> *dwp_file_ptr)
<a name="l10194"></a>10194 {
<a name="l10195"></a>10195   <span class="keyword">struct </span><a class="code" href="structdwp__file.html">dwp_file</a> *<a class="code" href="structdwp__file.html">dwp_file</a> = dwp_file_ptr;
<a name="l10196"></a>10196   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwop__section__names.html">dwop_section_names</a> *names = &amp;<a class="code" href="dwarf2read_8c.html#ac42e1a154a138cd7f3f46ca01347cf17">dwop_section_names</a>;
<a name="l10197"></a>10197   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elf_section_nr = elf_section_data (sectp)-&gt;this_idx;
<a name="l10198"></a>10198 
<a name="l10199"></a>10199   <span class="comment">/* Record the ELF section number for later lookup: this is what the</span>
<a name="l10200"></a>10200 <span class="comment">     .debug_cu_index,.debug_tu_index tables use in DWP V1.  */</span>
<a name="l10201"></a>10201   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (elf_section_nr &lt; dwp_file-&gt;num_sections);
<a name="l10202"></a>10202   dwp_file-&gt;<a class="code" href="structdwp__file.html#a402f52900899dc36afb1ccabfe8b21cd">elf_sections</a>[elf_section_nr] = sectp;
<a name="l10203"></a>10203 
<a name="l10204"></a>10204   <span class="comment">/* Look for specific sections that we need.  */</span>
<a name="l10205"></a>10205   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a0b6c94a6d611e5e3faac78072091d743">str_dwo</a>))
<a name="l10206"></a>10206     {
<a name="l10207"></a>10207       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a6c2c4c7c122c8801d7762bf918f895ba">str</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10208"></a>10208       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a6c2c4c7c122c8801d7762bf918f895ba">str</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10209"></a>10209     }
<a name="l10210"></a>10210   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a59b48fe1149b9b0925a32ab6662969ba">cu_index</a>))
<a name="l10211"></a>10211     {
<a name="l10212"></a>10212       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a270bca9fb26055e71c6034c765aab8c5">cu_index</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10213"></a>10213       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a270bca9fb26055e71c6034c765aab8c5">cu_index</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10214"></a>10214     }
<a name="l10215"></a>10215   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a610f3eec837038963fdeee17997cc60b">tu_index</a>))
<a name="l10216"></a>10216     {
<a name="l10217"></a>10217       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a8d3418c9bb110b773192d2e9bb26a3db">tu_index</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10218"></a>10218       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a8d3418c9bb110b773192d2e9bb26a3db">tu_index</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10219"></a>10219     }
<a name="l10220"></a>10220 }
<a name="l10221"></a>10221 
<a name="l10222"></a>10222 <span class="comment">/* This function is mapped across the sections and remembers the offset and</span>
<a name="l10223"></a>10223 <span class="comment">   size of each of the DWP version 2 debugging sections that we are interested</span>
<a name="l10224"></a>10224 <span class="comment">   in.  This is split into a separate function because we don&#39;t know if we</span>
<a name="l10225"></a>10225 <span class="comment">   have version 1 or 2 until we parse the cu_index/tu_index sections.  */</span>
<a name="l10226"></a>10226 
<a name="l10227"></a>10227 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l10228"></a><a class="code" href="dwarf2read_8c.html#a233496a695f80ea9cc1ff73e91b0e4b7">10228</a> <a class="code" href="dwarf2read_8c.html#a233496a695f80ea9cc1ff73e91b0e4b7">dwarf2_locate_v2_dwp_sections</a> (bfd *abfd, asection *sectp, <span class="keywordtype">void</span> *dwp_file_ptr)
<a name="l10229"></a>10229 {
<a name="l10230"></a>10230   <span class="keyword">struct </span><a class="code" href="structdwp__file.html">dwp_file</a> *<a class="code" href="structdwp__file.html">dwp_file</a> = dwp_file_ptr;
<a name="l10231"></a>10231   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwop__section__names.html">dwop_section_names</a> *names = &amp;<a class="code" href="dwarf2read_8c.html#ac42e1a154a138cd7f3f46ca01347cf17">dwop_section_names</a>;
<a name="l10232"></a>10232   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elf_section_nr = elf_section_data (sectp)-&gt;this_idx;
<a name="l10233"></a>10233 
<a name="l10234"></a>10234   <span class="comment">/* Record the ELF section number for later lookup: this is what the</span>
<a name="l10235"></a>10235 <span class="comment">     .debug_cu_index,.debug_tu_index tables use in DWP V1.  */</span>
<a name="l10236"></a>10236   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (elf_section_nr &lt; dwp_file-&gt;num_sections);
<a name="l10237"></a>10237   dwp_file-&gt;<a class="code" href="structdwp__file.html#a402f52900899dc36afb1ccabfe8b21cd">elf_sections</a>[elf_section_nr] = sectp;
<a name="l10238"></a>10238 
<a name="l10239"></a>10239   <span class="comment">/* Look for specific sections that we need.  */</span>
<a name="l10240"></a>10240   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#ae59cc2816c3829d001953c78ff8cfdf5">abbrev_dwo</a>))
<a name="l10241"></a>10241     {
<a name="l10242"></a>10242       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#afa0a4063d5cde27a487217518620aa1c">abbrev</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10243"></a>10243       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#afa0a4063d5cde27a487217518620aa1c">abbrev</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10244"></a>10244     }
<a name="l10245"></a>10245   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#abcabf332b0c04d0f422ed3011178f45e">info_dwo</a>))
<a name="l10246"></a>10246     {
<a name="l10247"></a>10247       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a7d11f4f122b19804504fb5d9957a05ee">info</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10248"></a>10248       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a7d11f4f122b19804504fb5d9957a05ee">info</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10249"></a>10249     }
<a name="l10250"></a>10250   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a53e026523c28f96cf9ff9ce9fab9e235">line_dwo</a>))
<a name="l10251"></a>10251     {
<a name="l10252"></a>10252       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a78f9d2149461fc3c17cf14437e5aa147">line</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10253"></a>10253       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a78f9d2149461fc3c17cf14437e5aa147">line</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10254"></a>10254     }
<a name="l10255"></a>10255   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#adc0f06e32cbd1167e26ec1321df8e63b">loc_dwo</a>))
<a name="l10256"></a>10256     {
<a name="l10257"></a>10257       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a20c97d6a71b1e68d9b0746eb37843dbf">loc</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10258"></a>10258       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a20c97d6a71b1e68d9b0746eb37843dbf">loc</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10259"></a>10259     }
<a name="l10260"></a>10260   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a8ebb4a5d32ae6414d9f9aa76b472da96">macinfo_dwo</a>))
<a name="l10261"></a>10261     {
<a name="l10262"></a>10262       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#aaf6bc577681a8b83d024fb097dc13580">macinfo</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10263"></a>10263       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#aaf6bc577681a8b83d024fb097dc13580">macinfo</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10264"></a>10264     }
<a name="l10265"></a>10265   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#aced5043c2932561517e13c66aca3f238">macro_dwo</a>))
<a name="l10266"></a>10266     {
<a name="l10267"></a>10267       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a859d4582e590abb12e969a750bac824a">macro</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10268"></a>10268       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a859d4582e590abb12e969a750bac824a">macro</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10269"></a>10269     }
<a name="l10270"></a>10270   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a31b18ee25231b65438027a3134e9eb9d">str_offsets_dwo</a>))
<a name="l10271"></a>10271     {
<a name="l10272"></a>10272       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a8ff194c59ebf0fe4c9606c21de25f5b8">str_offsets</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10273"></a>10273       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a8ff194c59ebf0fe4c9606c21de25f5b8">str_offsets</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10274"></a>10274     }
<a name="l10275"></a>10275   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a79469ede7f93975d5e3d52a938e11197">section_is_p</a> (sectp-&gt;name, &amp;names-&gt;<a class="code" href="structdwop__section__names.html#a1648f678e86667b0a897e7c7ad1b2cc6">types_dwo</a>))
<a name="l10276"></a>10276     {
<a name="l10277"></a>10277       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a9c5d6ccbf31f42fb4ce3c8a85b9b07d5">types</a>.<a class="code" href="structdwarf2__section__info.html#a510b03f42a1c86a377855c374efb6c8c">s</a>.<a class="code" href="structdwarf2__section__info.html#a97fc8320a85a4cb26ea64efaa6addfb6">asection</a> = sectp;
<a name="l10278"></a>10278       dwp_file-&gt;<a class="code" href="structdwp__file.html#a870b1eaede63b2ce3af2e3d53ca3f52d">sections</a>.<a class="code" href="structdwp__sections.html#a9c5d6ccbf31f42fb4ce3c8a85b9b07d5">types</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> = bfd_get_section_size (sectp);
<a name="l10279"></a>10279     }
<a name="l10280"></a>10280 }
<a name="l10281"></a>10281 
<a name="l10282"></a>10282 <span class="comment">/* Hash function for dwp_file loaded CUs/TUs.  */</span>
<a name="l10283"></a>10283 
<a name="l10284"></a>10284 <span class="keyword">static</span> hashval_t
<a name="l10285"></a><a class="code" href="dwarf2read_8c.html#a29562db59d901f88222c37609c7dbb4d">10285</a> <a class="code" href="dwarf2read_8c.html#a29562db59d901f88222c37609c7dbb4d">hash_dwp_loaded_cutus</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item)
<a name="l10286"></a>10286 {
<a name="l10287"></a>10287   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structdwo__unit.html">dwo_unit</a> = item;
<a name="l10288"></a>10288 
<a name="l10289"></a>10289   <span class="comment">/* This drops the top 32 bits of the signature, but is ok for a hash.  */</span>
<a name="l10290"></a>10290   <span class="keywordflow">return</span> dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>;
<a name="l10291"></a>10291 }
<a name="l10292"></a>10292 
<a name="l10293"></a>10293 <span class="comment">/* Equality function for dwp_file loaded CUs/TUs.  */</span>
<a name="l10294"></a>10294 
<a name="l10295"></a>10295 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l10296"></a><a class="code" href="dwarf2read_8c.html#a7cad114312ff526ab0ad746e98509f23">10296</a> <a class="code" href="dwarf2read_8c.html#a7cad114312ff526ab0ad746e98509f23">eq_dwp_loaded_cutus</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)
<a name="l10297"></a>10297 {
<a name="l10298"></a>10298   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *dua = a;
<a name="l10299"></a>10299   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *dub = b;
<a name="l10300"></a>10300 
<a name="l10301"></a>10301   <span class="keywordflow">return</span> dua-&gt;<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a> == dub-&gt;<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>;
<a name="l10302"></a>10302 }
<a name="l10303"></a>10303 
<a name="l10304"></a>10304 <span class="comment">/* Allocate a hash table for dwp_file loaded CUs/TUs.  */</span>
<a name="l10305"></a>10305 
<a name="l10306"></a>10306 <span class="keyword">static</span> htab_t
<a name="l10307"></a><a class="code" href="dwarf2read_8c.html#aea2dc3b8c9a71ed416a3eac598b4b054">10307</a> <a class="code" href="dwarf2read_8c.html#aea2dc3b8c9a71ed416a3eac598b4b054">allocate_dwp_loaded_cutus_table</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l10308"></a>10308 {
<a name="l10309"></a>10309   <span class="keywordflow">return</span> htab_create_alloc_ex (3,
<a name="l10310"></a>10310                                <a class="code" href="dwarf2read_8c.html#a29562db59d901f88222c37609c7dbb4d">hash_dwp_loaded_cutus</a>,
<a name="l10311"></a>10311                                <a class="code" href="dwarf2read_8c.html#a7cad114312ff526ab0ad746e98509f23">eq_dwp_loaded_cutus</a>,
<a name="l10312"></a>10312                                NULL,
<a name="l10313"></a>10313                                &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l10314"></a>10314                                <a class="code" href="utils_8c.html#a64b0a5e317b6f45f062aa8356111644b">hashtab_obstack_allocate</a>,
<a name="l10315"></a>10315                                <a class="code" href="utils_8c.html#af32d0d55c7c49d59093e66ef695f9513">dummy_obstack_deallocate</a>);
<a name="l10316"></a>10316 }
<a name="l10317"></a>10317 
<a name="l10318"></a>10318 <span class="comment">/* Try to open DWP file FILE_NAME.</span>
<a name="l10319"></a>10319 <span class="comment">   The result is the bfd handle of the file.</span>
<a name="l10320"></a>10320 <span class="comment">   If there is a problem finding or opening the file, return NULL.</span>
<a name="l10321"></a>10321 <span class="comment">   Upon success, the canonicalized path of the file is stored in the bfd,</span>
<a name="l10322"></a>10322 <span class="comment">   same as symfile_bfd_open.  */</span>
<a name="l10323"></a>10323 
<a name="l10324"></a>10324 <span class="keyword">static</span> bfd *
<a name="l10325"></a><a class="code" href="dwarf2read_8c.html#a905ca3d2a068bd8596a24e18164685b9">10325</a> <a class="code" href="dwarf2read_8c.html#a905ca3d2a068bd8596a24e18164685b9">open_dwp_file</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *file_name)
<a name="l10326"></a>10326 {
<a name="l10327"></a>10327   bfd *abfd;
<a name="l10328"></a>10328 
<a name="l10329"></a>10329   abfd = <a class="code" href="dwarf2read_8c.html#a40b1592109b0809e619843fa99732f03">try_open_dwop_file</a> (file_name, 1 <span class="comment">/*is_dwp*/</span>, 1 <span class="comment">/*search_cwd*/</span>);
<a name="l10330"></a>10330   <span class="keywordflow">if</span> (abfd != NULL)
<a name="l10331"></a>10331     <span class="keywordflow">return</span> abfd;
<a name="l10332"></a>10332 
<a name="l10333"></a>10333   <span class="comment">/* Work around upstream bug 15652.</span>
<a name="l10334"></a>10334 <span class="comment">     http://sourceware.org/bugzilla/show_bug.cgi?id=15652</span>
<a name="l10335"></a>10335 <span class="comment">     [Whether that&#39;s a &quot;bug&quot; is debatable, but it is getting in our way.]</span>
<a name="l10336"></a>10336 <span class="comment">     We have no real idea where the dwp file is, because gdb&#39;s realpath-ing</span>
<a name="l10337"></a>10337 <span class="comment">     of the executable&#39;s path may have discarded the needed info.</span>
<a name="l10338"></a>10338 <span class="comment">     [IWBN if the dwp file name was recorded in the executable, akin to</span>
<a name="l10339"></a>10339 <span class="comment">     .gnu_debuglink, but that doesn&#39;t exist yet.]</span>
<a name="l10340"></a>10340 <span class="comment">     Strip the directory from FILE_NAME and search again.  */</span>
<a name="l10341"></a>10341   <span class="keywordflow">if</span> (*<a class="code" href="defs_8h.html#a8c8cf5a84683f83d8b6e49a10b17473f">debug_file_directory</a> != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l10342"></a>10342     {
<a name="l10343"></a>10343       <span class="comment">/* Don&#39;t implicitly search the current directory here.</span>
<a name="l10344"></a>10344 <span class="comment">         If the user wants to search &quot;.&quot; to handle this case,</span>
<a name="l10345"></a>10345 <span class="comment">         it must be added to debug-file-directory.  */</span>
<a name="l10346"></a>10346       <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a40b1592109b0809e619843fa99732f03">try_open_dwop_file</a> (lbasename (file_name), 1 <span class="comment">/*is_dwp*/</span>,
<a name="l10347"></a>10347                                  0 <span class="comment">/*search_cwd*/</span>);
<a name="l10348"></a>10348     }
<a name="l10349"></a>10349 
<a name="l10350"></a>10350   <span class="keywordflow">return</span> NULL;
<a name="l10351"></a>10351 }
<a name="l10352"></a>10352 
<a name="l10353"></a>10353 <span class="comment">/* Initialize the use of the DWP file for the current objfile.</span>
<a name="l10354"></a>10354 <span class="comment">   By convention the name of the DWP file is ${objfile}.dwp.</span>
<a name="l10355"></a>10355 <span class="comment">   The result is NULL if it can&#39;t be found.  */</span>
<a name="l10356"></a>10356 
<a name="l10357"></a>10357 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwp__file.html">dwp_file</a> *
<a name="l10358"></a><a class="code" href="dwarf2read_8c.html#ad7a354e8326aa93abdff5d2d2c311c08">10358</a> <a class="code" href="dwarf2read_8c.html#ad7a354e8326aa93abdff5d2d2c311c08">open_and_init_dwp_file</a> (<span class="keywordtype">void</span>)
<a name="l10359"></a>10359 {
<a name="l10360"></a>10360   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l10361"></a>10361   <span class="keyword">struct </span><a class="code" href="structdwp__file.html">dwp_file</a> *<a class="code" href="structdwp__file.html">dwp_file</a>;
<a name="l10362"></a>10362   <span class="keywordtype">char</span> *dwp_name;
<a name="l10363"></a>10363   bfd *<a class="code" href="structdwp__file.html#adaac28c08d06f0daf3633e997b0abdb1">dbfd</a>;
<a name="l10364"></a>10364   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups;
<a name="l10365"></a>10365 
<a name="l10366"></a>10366   <span class="comment">/* Try to find first .dwp for the binary file before any symbolic links</span>
<a name="l10367"></a>10367 <span class="comment">     resolving.  */</span>
<a name="l10368"></a>10368   dwp_name = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;%s.dwp&quot;</span>, objfile-&gt;<a class="code" href="structobjfile.html#adf7349914310f50116bc5a556d3d958b">original_name</a>);
<a name="l10369"></a>10369   cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, dwp_name);
<a name="l10370"></a>10370 
<a name="l10371"></a>10371   dbfd = <a class="code" href="dwarf2read_8c.html#a905ca3d2a068bd8596a24e18164685b9">open_dwp_file</a> (dwp_name);
<a name="l10372"></a>10372   <span class="keywordflow">if</span> (dbfd == NULL
<a name="l10373"></a>10373       &amp;&amp; strcmp (objfile-&gt;<a class="code" href="structobjfile.html#adf7349914310f50116bc5a556d3d958b">original_name</a>, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile)) != 0)
<a name="l10374"></a>10374     {
<a name="l10375"></a>10375       <span class="comment">/* Try to find .dwp for the binary file after gdb_realpath resolving.  */</span>
<a name="l10376"></a>10376       dwp_name = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;%s.dwp&quot;</span>, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l10377"></a>10377       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, dwp_name);
<a name="l10378"></a>10378       dbfd = <a class="code" href="dwarf2read_8c.html#a905ca3d2a068bd8596a24e18164685b9">open_dwp_file</a> (dwp_name);
<a name="l10379"></a>10379     }
<a name="l10380"></a>10380 
<a name="l10381"></a>10381   <span class="keywordflow">if</span> (dbfd == NULL)
<a name="l10382"></a>10382     {
<a name="l10383"></a>10383       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l10384"></a>10384         <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;DWP file not found: %s\n&quot;</span>, dwp_name);
<a name="l10385"></a>10385       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l10386"></a>10386       <span class="keywordflow">return</span> NULL;
<a name="l10387"></a>10387     }
<a name="l10388"></a>10388   dwp_file = <a class="code" href="gdb__obstack_8h.html#a3852d9feffb1b3682384631c1356ad3e">OBSTACK_ZALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, <span class="keyword">struct</span> dwp_file);
<a name="l10389"></a>10389   dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a> = bfd_get_filename (dbfd);
<a name="l10390"></a>10390   dwp_file-&gt;<a class="code" href="structdwp__file.html#adaac28c08d06f0daf3633e997b0abdb1">dbfd</a> = dbfd;
<a name="l10391"></a>10391   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l10392"></a>10392 
<a name="l10393"></a>10393   <span class="comment">/* +1: section 0 is unused */</span>
<a name="l10394"></a>10394   dwp_file-&gt;<a class="code" href="structdwp__file.html#a3bf1bb3c9f65550e349531242e7cafcc">num_sections</a> = bfd_count_sections (dbfd) + 1;
<a name="l10395"></a>10395   dwp_file-&gt;<a class="code" href="structdwp__file.html#a402f52900899dc36afb1ccabfe8b21cd">elf_sections</a> =
<a name="l10396"></a>10396     <a class="code" href="gdb__obstack_8h.html#ade84d21769345a1fad382ba39d83eb90">OBSTACK_CALLOC</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l10397"></a>10397                     dwp_file-&gt;<a class="code" href="structdwp__file.html#a3bf1bb3c9f65550e349531242e7cafcc">num_sections</a>, asection *);
<a name="l10398"></a>10398 
<a name="l10399"></a>10399   bfd_map_over_sections (dbfd, <a class="code" href="dwarf2read_8c.html#a2288b0918decf7f7910a08d6e6eadfe7">dwarf2_locate_common_dwp_sections</a>, dwp_file);
<a name="l10400"></a>10400 
<a name="l10401"></a>10401   dwp_file-&gt;<a class="code" href="structdwp__file.html#a6539ad818bafae68a09889c2eb985780">cus</a> = <a class="code" href="dwarf2read_8c.html#a6d6724e42513304a7c66509d698934d6">create_dwp_hash_table</a> (dwp_file, 0);
<a name="l10402"></a>10402 
<a name="l10403"></a>10403   dwp_file-&gt;<a class="code" href="structdwp__file.html#a1f5edbd4eb259b9605d86511d87f117c">tus</a> = <a class="code" href="dwarf2read_8c.html#a6d6724e42513304a7c66509d698934d6">create_dwp_hash_table</a> (dwp_file, 1);
<a name="l10404"></a>10404 
<a name="l10405"></a>10405   <span class="comment">/* The DWP file version is stored in the hash table.  Oh well.  */</span>
<a name="l10406"></a>10406   <span class="keywordflow">if</span> (dwp_file-&gt;<a class="code" href="structdwp__file.html#a6539ad818bafae68a09889c2eb985780">cus</a>-&gt;<a class="code" href="structdwp__hash__table.html#ad38d9c9206bccf97bd24595df1a835f5">version</a> != dwp_file-&gt;<a class="code" href="structdwp__file.html#a1f5edbd4eb259b9605d86511d87f117c">tus</a>-&gt;<a class="code" href="structdwp__hash__table.html#ad38d9c9206bccf97bd24595df1a835f5">version</a>)
<a name="l10407"></a>10407     {
<a name="l10408"></a>10408       <span class="comment">/* Technically speaking, we should try to limp along, but this is</span>
<a name="l10409"></a>10409 <span class="comment">         pretty bizarre.  */</span>
<a name="l10410"></a>10410       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: DWP file CU version %d doesn&#39;t match&quot;</span>
<a name="l10411"></a>10411                <span class="stringliteral">&quot; TU version %d [in DWP file %s]&quot;</span>),
<a name="l10412"></a>10412              dwp_file-&gt;<a class="code" href="structdwp__file.html#a6539ad818bafae68a09889c2eb985780">cus</a>-&gt;<a class="code" href="structdwp__hash__table.html#ad38d9c9206bccf97bd24595df1a835f5">version</a>, dwp_file-&gt;<a class="code" href="structdwp__file.html#a1f5edbd4eb259b9605d86511d87f117c">tus</a>-&gt;<a class="code" href="structdwp__hash__table.html#ad38d9c9206bccf97bd24595df1a835f5">version</a>, dwp_name);
<a name="l10413"></a>10413     }
<a name="l10414"></a>10414   dwp_file-&gt;<a class="code" href="structdwp__file.html#a140a3d3a09fc7aaf072b96eae87173fb">version</a> = dwp_file-&gt;<a class="code" href="structdwp__file.html#a6539ad818bafae68a09889c2eb985780">cus</a>-&gt;<a class="code" href="structdwp__hash__table.html#ad38d9c9206bccf97bd24595df1a835f5">version</a>;
<a name="l10415"></a>10415 
<a name="l10416"></a>10416   <span class="keywordflow">if</span> (dwp_file-&gt;<a class="code" href="structdwp__file.html#a140a3d3a09fc7aaf072b96eae87173fb">version</a> == 2)
<a name="l10417"></a>10417     bfd_map_over_sections (dbfd, <a class="code" href="dwarf2read_8c.html#a233496a695f80ea9cc1ff73e91b0e4b7">dwarf2_locate_v2_dwp_sections</a>, dwp_file);
<a name="l10418"></a>10418 
<a name="l10419"></a>10419   dwp_file-&gt;<a class="code" href="structdwp__file.html#a4a52577c25dc38801f555317f99f7731">loaded_cus</a> = <a class="code" href="dwarf2read_8c.html#aea2dc3b8c9a71ed416a3eac598b4b054">allocate_dwp_loaded_cutus_table</a> (objfile);
<a name="l10420"></a>10420   dwp_file-&gt;<a class="code" href="structdwp__file.html#a9115bf303bce67f7e83c91ec1c7ffb8f">loaded_tus</a> = <a class="code" href="dwarf2read_8c.html#aea2dc3b8c9a71ed416a3eac598b4b054">allocate_dwp_loaded_cutus_table</a> (objfile);
<a name="l10421"></a>10421 
<a name="l10422"></a>10422   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l10423"></a>10423     {
<a name="l10424"></a>10424       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;DWP file found: %s\n&quot;</span>, dwp_file-&gt;<a class="code" href="structdwp__file.html#a89cf235bca021b231cf42d3245a45f02">name</a>);
<a name="l10425"></a>10425       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l10426"></a>10426                           <span class="stringliteral">&quot;    %s CUs, %s TUs\n&quot;</span>,
<a name="l10427"></a>10427                           <a class="code" href="utils_8c.html#ab74ba9d12a782e5964a4af4ddc5de3ae">pulongest</a> (dwp_file-&gt;<a class="code" href="structdwp__file.html#a6539ad818bafae68a09889c2eb985780">cus</a> ? dwp_file-&gt;<a class="code" href="structdwp__file.html#a6539ad818bafae68a09889c2eb985780">cus</a>-&gt;<a class="code" href="structdwp__hash__table.html#a7fc7c527fef9be71ffca081ac9196176">nr_units</a> : 0),
<a name="l10428"></a>10428                           <a class="code" href="utils_8c.html#ab74ba9d12a782e5964a4af4ddc5de3ae">pulongest</a> (dwp_file-&gt;<a class="code" href="structdwp__file.html#a1f5edbd4eb259b9605d86511d87f117c">tus</a> ? dwp_file-&gt;<a class="code" href="structdwp__file.html#a1f5edbd4eb259b9605d86511d87f117c">tus</a>-&gt;<a class="code" href="structdwp__hash__table.html#a7fc7c527fef9be71ffca081ac9196176">nr_units</a> : 0));
<a name="l10429"></a>10429     }
<a name="l10430"></a>10430 
<a name="l10431"></a>10431   <span class="keywordflow">return</span> dwp_file;
<a name="l10432"></a>10432 }
<a name="l10433"></a>10433 
<a name="l10434"></a>10434 <span class="comment">/* Wrapper around open_and_init_dwp_file, only open it once.  */</span>
<a name="l10435"></a>10435 
<a name="l10436"></a>10436 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwp__file.html">dwp_file</a> *
<a name="l10437"></a><a class="code" href="dwarf2read_8c.html#a9fc2d7d27eba883b582555229c60c32e">10437</a> <a class="code" href="dwarf2read_8c.html#a9fc2d7d27eba883b582555229c60c32e">get_dwp_file</a> (<span class="keywordtype">void</span>)
<a name="l10438"></a>10438 {
<a name="l10439"></a>10439   <span class="keywordflow">if</span> (! dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#af1cad9a614ed37e4fa3d55aaa8f08de3">dwp_checked</a>)
<a name="l10440"></a>10440     {
<a name="l10441"></a>10441       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ad0c5cd80616059507d792e8648026317">dwp_file</a> = <a class="code" href="dwarf2read_8c.html#ad7a354e8326aa93abdff5d2d2c311c08">open_and_init_dwp_file</a> ();
<a name="l10442"></a>10442       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#af1cad9a614ed37e4fa3d55aaa8f08de3">dwp_checked</a> = 1;
<a name="l10443"></a>10443     }
<a name="l10444"></a>10444   <span class="keywordflow">return</span> dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ad0c5cd80616059507d792e8648026317">dwp_file</a>;
<a name="l10445"></a>10445 }
<a name="l10446"></a>10446 
<a name="l10447"></a>10447 <span class="comment">/* Subroutine of lookup_dwo_comp_unit, lookup_dwo_type_unit.</span>
<a name="l10448"></a>10448 <span class="comment">   Look up the CU/TU with signature SIGNATURE, either in DWO file DWO_NAME</span>
<a name="l10449"></a>10449 <span class="comment">   or in the DWP file for the objfile, referenced by THIS_UNIT.</span>
<a name="l10450"></a>10450 <span class="comment">   If non-NULL, comp_dir is the DW_AT_comp_dir attribute.</span>
<a name="l10451"></a>10451 <span class="comment">   IS_DEBUG_TYPES is non-zero if reading a TU, otherwise read a CU.</span>
<a name="l10452"></a>10452 <span class="comment"></span>
<a name="l10453"></a>10453 <span class="comment">   This is called, for example, when wanting to read a variable with a</span>
<a name="l10454"></a>10454 <span class="comment">   complex location.  Therefore we don&#39;t want to do file i/o for every call.</span>
<a name="l10455"></a>10455 <span class="comment">   Therefore we don&#39;t want to look for a DWO file on every call.</span>
<a name="l10456"></a>10456 <span class="comment">   Therefore we first see if we&#39;ve already seen SIGNATURE in a DWP file,</span>
<a name="l10457"></a>10457 <span class="comment">   then we check if we&#39;ve already seen DWO_NAME, and only THEN do we check</span>
<a name="l10458"></a>10458 <span class="comment">   for a DWO file.</span>
<a name="l10459"></a>10459 <span class="comment"></span>
<a name="l10460"></a>10460 <span class="comment">   The result is a pointer to the dwo_unit object or NULL if we didn&#39;t find it</span>
<a name="l10461"></a>10461 <span class="comment">   (dwo_id mismatch or couldn&#39;t find the DWO/DWP file).  */</span>
<a name="l10462"></a>10462 
<a name="l10463"></a>10463 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *
<a name="l10464"></a><a class="code" href="dwarf2read_8c.html#a2deb59da818033352f433fc0d2a2bde3">10464</a> <a class="code" href="dwarf2read_8c.html#a2deb59da818033352f433fc0d2a2bde3">lookup_dwo_cutu</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_unit,
<a name="l10465"></a>10465                  <span class="keyword">const</span> <span class="keywordtype">char</span> *dwo_name, <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir,
<a name="l10466"></a>10466                  <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>, <span class="keywordtype">int</span> is_debug_types)
<a name="l10467"></a>10467 {
<a name="l10468"></a>10468   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l10469"></a>10469   <span class="keyword">const</span> <span class="keywordtype">char</span> *kind = is_debug_types ? <span class="stringliteral">&quot;TU&quot;</span> : <span class="stringliteral">&quot;CU&quot;</span>;
<a name="l10470"></a>10470   <span class="keywordtype">void</span> **dwo_file_slot;
<a name="l10471"></a>10471   <span class="keyword">struct </span>dwo_file *dwo_file;
<a name="l10472"></a>10472   <span class="keyword">struct </span><a class="code" href="structdwp__file.html">dwp_file</a> *<a class="code" href="structdwp__file.html">dwp_file</a>;
<a name="l10473"></a>10473 
<a name="l10474"></a>10474   <span class="comment">/* First see if there&#39;s a DWP file.</span>
<a name="l10475"></a>10475 <span class="comment">     If we have a DWP file but didn&#39;t find the DWO inside it, don&#39;t</span>
<a name="l10476"></a>10476 <span class="comment">     look for the original DWO file.  It makes gdb behave differently</span>
<a name="l10477"></a>10477 <span class="comment">     depending on whether one is debugging in the build tree.  */</span>
<a name="l10478"></a>10478 
<a name="l10479"></a>10479   dwp_file = <a class="code" href="dwarf2read_8c.html#a9fc2d7d27eba883b582555229c60c32e">get_dwp_file</a> ();
<a name="l10480"></a>10480   <span class="keywordflow">if</span> (dwp_file != NULL)
<a name="l10481"></a>10481     {
<a name="l10482"></a>10482       <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwp__hash__table.html">dwp_hash_table</a> *dwp_htab =
<a name="l10483"></a>10483         is_debug_types ? dwp_file-&gt;<a class="code" href="structdwp__file.html#a1f5edbd4eb259b9605d86511d87f117c">tus</a> : dwp_file-&gt;<a class="code" href="structdwp__file.html#a6539ad818bafae68a09889c2eb985780">cus</a>;
<a name="l10484"></a>10484 
<a name="l10485"></a>10485       <span class="keywordflow">if</span> (dwp_htab != NULL)
<a name="l10486"></a>10486         {
<a name="l10487"></a>10487           <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *dwo_cutu =
<a name="l10488"></a>10488             <a class="code" href="dwarf2read_8c.html#a5637d18b01ed205a41181e3cac6e442c">lookup_dwo_unit_in_dwp</a> (dwp_file, comp_dir,
<a name="l10489"></a>10489                                     signature, is_debug_types);
<a name="l10490"></a>10490 
<a name="l10491"></a>10491           <span class="keywordflow">if</span> (dwo_cutu != NULL)
<a name="l10492"></a>10492             {
<a name="l10493"></a>10493               <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l10494"></a>10494                 {
<a name="l10495"></a>10495                   <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l10496"></a>10496                                       <span class="stringliteral">&quot;Virtual DWO %s %s found: @%s\n&quot;</span>,
<a name="l10497"></a>10497                                       kind, <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (signature),
<a name="l10498"></a>10498                                       <a class="code" href="utils_8c.html#ac166db325056a01e8babd984f8ba2b98">host_address_to_string</a> (dwo_cutu));
<a name="l10499"></a>10499                 }
<a name="l10500"></a>10500               <span class="keywordflow">return</span> dwo_cutu;
<a name="l10501"></a>10501             }
<a name="l10502"></a>10502         }
<a name="l10503"></a>10503     }
<a name="l10504"></a>10504   <span class="keywordflow">else</span>
<a name="l10505"></a>10505     {
<a name="l10506"></a>10506       <span class="comment">/* No DWP file, look for the DWO file.  */</span>
<a name="l10507"></a>10507 
<a name="l10508"></a>10508       dwo_file_slot = <a class="code" href="dwarf2read_8c.html#aef78329d4b39424730119060113478c7">lookup_dwo_file_slot</a> (dwo_name, comp_dir);
<a name="l10509"></a>10509       <span class="keywordflow">if</span> (*dwo_file_slot == NULL)
<a name="l10510"></a>10510         {
<a name="l10511"></a>10511           <span class="comment">/* Read in the file and build a table of the CUs/TUs it contains.  */</span>
<a name="l10512"></a>10512           *dwo_file_slot = <a class="code" href="dwarf2read_8c.html#aa2951a909d73401ea9fb5b7afdeabbb9">open_and_init_dwo_file</a> (this_unit, dwo_name, comp_dir);
<a name="l10513"></a>10513         }
<a name="l10514"></a>10514       <span class="comment">/* NOTE: This will be NULL if unable to open the file.  */</span>
<a name="l10515"></a>10515       dwo_file = *dwo_file_slot;
<a name="l10516"></a>10516 
<a name="l10517"></a>10517       <span class="keywordflow">if</span> (dwo_file != NULL)
<a name="l10518"></a>10518         {
<a name="l10519"></a>10519           <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *dwo_cutu = NULL;
<a name="l10520"></a>10520 
<a name="l10521"></a>10521           <span class="keywordflow">if</span> (is_debug_types &amp;&amp; dwo_file-&gt;<a class="code" href="structdwo__file.html#a6ce93a5371a6e123e009d98d81f93ab2">tus</a>)
<a name="l10522"></a>10522             {
<a name="l10523"></a>10523               <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> find_dwo_cutu;
<a name="l10524"></a>10524 
<a name="l10525"></a>10525               <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;find_dwo_cutu, 0, <span class="keyword">sizeof</span> (find_dwo_cutu));
<a name="l10526"></a>10526               find_dwo_cutu.<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a> = <a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>;
<a name="l10527"></a>10527               dwo_cutu = htab_find (dwo_file-&gt;<a class="code" href="structdwo__file.html#a6ce93a5371a6e123e009d98d81f93ab2">tus</a>, &amp;find_dwo_cutu);
<a name="l10528"></a>10528             }
<a name="l10529"></a>10529           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!is_debug_types &amp;&amp; dwo_file-&gt;<a class="code" href="structdwo__file.html#a2da7541da154b831fe9428d4f390e932">cu</a>)
<a name="l10530"></a>10530             {
<a name="l10531"></a>10531               <span class="keywordflow">if</span> (signature == dwo_file-&gt;<a class="code" href="structdwo__file.html#a2da7541da154b831fe9428d4f390e932">cu</a>-&gt;<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>)
<a name="l10532"></a>10532                 dwo_cutu = dwo_file-&gt;<a class="code" href="structdwo__file.html#a2da7541da154b831fe9428d4f390e932">cu</a>;
<a name="l10533"></a>10533             }
<a name="l10534"></a>10534 
<a name="l10535"></a>10535           <span class="keywordflow">if</span> (dwo_cutu != NULL)
<a name="l10536"></a>10536             {
<a name="l10537"></a>10537               <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l10538"></a>10538                 {
<a name="l10539"></a>10539                   <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;DWO %s %s(%s) found: @%s\n&quot;</span>,
<a name="l10540"></a>10540                                       kind, dwo_name, <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (signature),
<a name="l10541"></a>10541                                       <a class="code" href="utils_8c.html#ac166db325056a01e8babd984f8ba2b98">host_address_to_string</a> (dwo_cutu));
<a name="l10542"></a>10542                 }
<a name="l10543"></a>10543               <span class="keywordflow">return</span> dwo_cutu;
<a name="l10544"></a>10544             }
<a name="l10545"></a>10545         }
<a name="l10546"></a>10546     }
<a name="l10547"></a>10547 
<a name="l10548"></a>10548   <span class="comment">/* We didn&#39;t find it.  This could mean a dwo_id mismatch, or</span>
<a name="l10549"></a>10549 <span class="comment">     someone deleted the DWO/DWP file, or the search path isn&#39;t set up</span>
<a name="l10550"></a>10550 <span class="comment">     correctly to find the file.  */</span>
<a name="l10551"></a>10551 
<a name="l10552"></a>10552   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>)
<a name="l10553"></a>10553     {
<a name="l10554"></a>10554       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;DWO %s %s(%s) not found\n&quot;</span>,
<a name="l10555"></a>10555                           kind, dwo_name, <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (signature));
<a name="l10556"></a>10556     }
<a name="l10557"></a>10557 
<a name="l10558"></a>10558   <span class="comment">/* This is a warning and not a complaint because it can be caused by</span>
<a name="l10559"></a>10559 <span class="comment">     pilot error (e.g., user accidentally deleting the DWO).  */</span>
<a name="l10560"></a>10560   <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Could not find DWO %s %s(%s) referenced by %s at offset 0x%x&quot;</span>
<a name="l10561"></a>10561              <span class="stringliteral">&quot; [in module %s]&quot;</span>),
<a name="l10562"></a>10562            kind, dwo_name, <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (signature),
<a name="l10563"></a>10563            this_unit-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a> ? <span class="stringliteral">&quot;TU&quot;</span> : <span class="stringliteral">&quot;CU&quot;</span>,
<a name="l10564"></a>10564            this_unit-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l10565"></a>10565   <span class="keywordflow">return</span> NULL;
<a name="l10566"></a>10566 }
<a name="l10567"></a>10567 
<a name="l10568"></a>10568 <span class="comment">/* Lookup the DWO CU DWO_NAME/SIGNATURE referenced from THIS_CU.</span>
<a name="l10569"></a>10569 <span class="comment">   See lookup_dwo_cutu_unit for details.  */</span>
<a name="l10570"></a>10570 
<a name="l10571"></a>10571 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *
<a name="l10572"></a><a class="code" href="dwarf2read_8c.html#a5bc277ff9a23ec723156386e4b6cb16a">10572</a> <a class="code" href="dwarf2read_8c.html#a5bc277ff9a23ec723156386e4b6cb16a">lookup_dwo_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu,
<a name="l10573"></a>10573                       <span class="keyword">const</span> <span class="keywordtype">char</span> *dwo_name, <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir,
<a name="l10574"></a>10574                       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>)
<a name="l10575"></a>10575 {
<a name="l10576"></a>10576   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a2deb59da818033352f433fc0d2a2bde3">lookup_dwo_cutu</a> (this_cu, dwo_name, comp_dir, signature, 0);
<a name="l10577"></a>10577 }
<a name="l10578"></a>10578 
<a name="l10579"></a>10579 <span class="comment">/* Lookup the DWO TU DWO_NAME/SIGNATURE referenced from THIS_TU.</span>
<a name="l10580"></a>10580 <span class="comment">   See lookup_dwo_cutu_unit for details.  */</span>
<a name="l10581"></a>10581 
<a name="l10582"></a>10582 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *
<a name="l10583"></a><a class="code" href="dwarf2read_8c.html#a5f81c3c5c800c9a68e91157b46e1cd8f">10583</a> <a class="code" href="dwarf2read_8c.html#a5f81c3c5c800c9a68e91157b46e1cd8f">lookup_dwo_type_unit</a> (<span class="keyword">struct</span> <a class="code" href="structsignatured__type.html">signatured_type</a> *this_tu,
<a name="l10584"></a>10584                       <span class="keyword">const</span> <span class="keywordtype">char</span> *dwo_name, <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir)
<a name="l10585"></a>10585 {
<a name="l10586"></a>10586   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a2deb59da818033352f433fc0d2a2bde3">lookup_dwo_cutu</a> (&amp;this_tu-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>, dwo_name, comp_dir, this_tu-&gt;<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a>, 1);
<a name="l10587"></a>10587 }
<a name="l10588"></a>10588 
<a name="l10589"></a>10589 <span class="comment">/* Traversal function for queue_and_load_all_dwo_tus.  */</span>
<a name="l10590"></a>10590 
<a name="l10591"></a>10591 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l10592"></a><a class="code" href="dwarf2read_8c.html#a099b3ec1af317755b19d48cf8f9269e0">10592</a> <a class="code" href="dwarf2read_8c.html#a099b3ec1af317755b19d48cf8f9269e0">queue_and_load_dwo_tu</a> (<span class="keywordtype">void</span> **slot, <span class="keywordtype">void</span> *info)
<a name="l10593"></a>10593 {
<a name="l10594"></a>10594   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structdwo__unit.html">dwo_unit</a> = (<span class="keyword">struct </span>dwo_unit *) *slot;
<a name="l10595"></a>10595   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = (<span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *) info;
<a name="l10596"></a>10596   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> signature = dwo_unit-&gt;<a class="code" href="structdwo__unit.html#a2adcb00385c78e48fd35f6b1f4767f5c">signature</a>;
<a name="l10597"></a>10597   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type =
<a name="l10598"></a>10598     <a class="code" href="dwarf2read_8c.html#a27dc24ca2503391da92c3d4e1915c9ad">lookup_dwo_signatured_type</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>, signature);
<a name="l10599"></a>10599 
<a name="l10600"></a>10600   <span class="keywordflow">if</span> (sig_type != NULL)
<a name="l10601"></a>10601     {
<a name="l10602"></a>10602       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *sig_cu = &amp;sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>;
<a name="l10603"></a>10603 
<a name="l10604"></a>10604       <span class="comment">/* We pass NULL for DEPENDENT_CU because we don&#39;t yet know if there&#39;s</span>
<a name="l10605"></a>10605 <span class="comment">         a real dependency of PER_CU on SIG_TYPE.  That is detected later</span>
<a name="l10606"></a>10606 <span class="comment">         while processing PER_CU.  */</span>
<a name="l10607"></a>10607       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ac102eb30f433a30a29425f0d30a461c2">maybe_queue_comp_unit</a> (NULL, sig_cu, per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>))
<a name="l10608"></a>10608         <a class="code" href="dwarf2read_8c.html#a1d0f2204cbb2e3c2103d9e9a40b97f61">load_full_type_unit</a> (sig_cu);
<a name="l10609"></a>10609       <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (dwarf2_per_cu_ptr, per_cu-&gt;imported_symtabs, sig_cu);
<a name="l10610"></a>10610     }
<a name="l10611"></a>10611 
<a name="l10612"></a>10612   <span class="keywordflow">return</span> 1;
<a name="l10613"></a>10613 }
<a name="l10614"></a>10614 
<a name="l10615"></a>10615 <span class="comment">/* Queue all TUs contained in the DWO of PER_CU to be read in.</span>
<a name="l10616"></a>10616 <span class="comment">   The DWO may have the only definition of the type, though it may not be</span>
<a name="l10617"></a>10617 <span class="comment">   referenced anywhere in PER_CU.  Thus we have to load *all* its TUs.</span>
<a name="l10618"></a>10618 <span class="comment">   http://sourceware.org/bugzilla/show_bug.cgi?id=15021  */</span>
<a name="l10619"></a>10619 
<a name="l10620"></a>10620 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l10621"></a><a class="code" href="dwarf2read_8c.html#a94cfe716f234c867cf44c1880aed5f2e">10621</a> <a class="code" href="dwarf2read_8c.html#a94cfe716f234c867cf44c1880aed5f2e">queue_and_load_all_dwo_tus</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l10622"></a>10622 {
<a name="l10623"></a>10623   <span class="keyword">struct </span><a class="code" href="structdwo__unit.html">dwo_unit</a> *<a class="code" href="structdwo__unit.html">dwo_unit</a>;
<a name="l10624"></a>10624   <span class="keyword">struct </span>dwo_file *dwo_file;
<a name="l10625"></a>10625 
<a name="l10626"></a>10626   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l10627"></a>10627   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="dwarf2read_8c.html#a9fc2d7d27eba883b582555229c60c32e">get_dwp_file</a> () == NULL);
<a name="l10628"></a>10628   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> != NULL);
<a name="l10629"></a>10629 
<a name="l10630"></a>10630   dwo_unit = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;dwo_unit;
<a name="l10631"></a>10631   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (dwo_unit != NULL);
<a name="l10632"></a>10632 
<a name="l10633"></a>10633   dwo_file = dwo_unit-&gt;<a class="code" href="structdwo__unit.html#aad6cdba4df2c87535e876e58702f92f7">dwo_file</a>;
<a name="l10634"></a>10634   <span class="keywordflow">if</span> (dwo_file-&gt;<a class="code" href="structdwo__file.html#a6ce93a5371a6e123e009d98d81f93ab2">tus</a> != NULL)
<a name="l10635"></a>10635     htab_traverse_noresize (dwo_file-&gt;<a class="code" href="structdwo__file.html#a6ce93a5371a6e123e009d98d81f93ab2">tus</a>, <a class="code" href="dwarf2read_8c.html#a099b3ec1af317755b19d48cf8f9269e0">queue_and_load_dwo_tu</a>, per_cu);
<a name="l10636"></a>10636 }
<a name="l10637"></a>10637 
<a name="l10638"></a>10638 <span class="comment">/* Free all resources associated with DWO_FILE.</span>
<a name="l10639"></a>10639 <span class="comment">   Close the DWO file and munmap the sections.</span>
<a name="l10640"></a>10640 <span class="comment">   All memory should be on the objfile obstack.  */</span>
<a name="l10641"></a>10641 
<a name="l10642"></a>10642 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l10643"></a><a class="code" href="dwarf2read_8c.html#a188151aff6d01278d23ee7ffda070f31">10643</a> <a class="code" href="dwarf2read_8c.html#a188151aff6d01278d23ee7ffda070f31">free_dwo_file</a> (<span class="keyword">struct</span> dwo_file *dwo_file, <span class="keyword">struct</span> objfile *objfile)
<a name="l10644"></a>10644 {
<a name="l10645"></a>10645   <span class="keywordtype">int</span> ix;
<a name="l10646"></a>10646   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section;
<a name="l10647"></a>10647 
<a name="l10648"></a>10648   <span class="comment">/* Note: dbfd is NULL for virtual DWO files.  */</span>
<a name="l10649"></a>10649   <a class="code" href="gdb__bfd_8c.html#a1027b59a8494f937b5760901040dc125">gdb_bfd_unref</a> (dwo_file-&gt;<a class="code" href="structdwo__file.html#a4121c7ff5fcbf6715852bd45d8e5c6a0">dbfd</a>);
<a name="l10650"></a>10650 
<a name="l10651"></a>10651   <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>, dwo_file-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.types);
<a name="l10652"></a>10652 }
<a name="l10653"></a>10653 
<a name="l10654"></a>10654 <span class="comment">/* Wrapper for free_dwo_file for use in cleanups.  */</span>
<a name="l10655"></a>10655 
<a name="l10656"></a>10656 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l10657"></a><a class="code" href="dwarf2read_8c.html#a3d1244c7c7e2daa658b3e4e49cd406bf">10657</a> <a class="code" href="dwarf2read_8c.html#a3d1244c7c7e2daa658b3e4e49cd406bf">free_dwo_file_cleanup</a> (<span class="keywordtype">void</span> *arg)
<a name="l10658"></a>10658 {
<a name="l10659"></a>10659   <span class="keyword">struct </span>dwo_file *dwo_file = (<span class="keyword">struct </span>dwo_file *) arg;
<a name="l10660"></a>10660   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l10661"></a>10661 
<a name="l10662"></a>10662   <a class="code" href="dwarf2read_8c.html#a188151aff6d01278d23ee7ffda070f31">free_dwo_file</a> (dwo_file, objfile);
<a name="l10663"></a>10663 }
<a name="l10664"></a>10664 
<a name="l10665"></a>10665 <span class="comment">/* Traversal function for free_dwo_files.  */</span>
<a name="l10666"></a>10666 
<a name="l10667"></a>10667 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l10668"></a><a class="code" href="dwarf2read_8c.html#a6143bff91ccddffc581afe091ed41142">10668</a> <a class="code" href="dwarf2read_8c.html#a6143bff91ccddffc581afe091ed41142">free_dwo_file_from_slot</a> (<span class="keywordtype">void</span> **slot, <span class="keywordtype">void</span> *info)
<a name="l10669"></a>10669 {
<a name="l10670"></a>10670   <span class="keyword">struct </span>dwo_file *dwo_file = (<span class="keyword">struct </span>dwo_file *) *slot;
<a name="l10671"></a>10671   <span class="keyword">struct </span>objfile *objfile = (<span class="keyword">struct </span>objfile *) info;
<a name="l10672"></a>10672 
<a name="l10673"></a>10673   <a class="code" href="dwarf2read_8c.html#a188151aff6d01278d23ee7ffda070f31">free_dwo_file</a> (dwo_file, objfile);
<a name="l10674"></a>10674 
<a name="l10675"></a>10675   <span class="keywordflow">return</span> 1;
<a name="l10676"></a>10676 }
<a name="l10677"></a>10677 
<a name="l10678"></a>10678 <span class="comment">/* Free all resources associated with DWO_FILES.  */</span>
<a name="l10679"></a>10679 
<a name="l10680"></a>10680 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l10681"></a><a class="code" href="dwarf2read_8c.html#a0099c774dedaf3ab2fd3a5393ef2021d">10681</a> <a class="code" href="dwarf2read_8c.html#a0099c774dedaf3ab2fd3a5393ef2021d">free_dwo_files</a> (htab_t dwo_files, <span class="keyword">struct</span> objfile *objfile)
<a name="l10682"></a>10682 {
<a name="l10683"></a>10683   htab_traverse_noresize (dwo_files, <a class="code" href="dwarf2read_8c.html#a6143bff91ccddffc581afe091ed41142">free_dwo_file_from_slot</a>, objfile);
<a name="l10684"></a>10684 }
<a name="l10685"></a>10685 
<a name="l10686"></a>10686 <span class="comment">/* Read in various DIEs.  */</span>
<a name="l10687"></a>10687 
<a name="l10688"></a>10688 <span class="comment">/* qsort helper for inherit_abstract_dies.  */</span>
<a name="l10689"></a>10689 
<a name="l10690"></a>10690 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l10691"></a><a class="code" href="dwarf2read_8c.html#a04678d6bb56ee3dafb694da954df3a86">10691</a> <a class="code" href="dwarf2read_8c.html#a04678d6bb56ee3dafb694da954df3a86">unsigned_int_compar</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *ap, <span class="keyword">const</span> <span class="keywordtype">void</span> *bp)
<a name="l10692"></a>10692 {
<a name="l10693"></a>10693   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> a = *(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *) ap;
<a name="l10694"></a>10694   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b = *(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *) bp;
<a name="l10695"></a>10695 
<a name="l10696"></a>10696   <span class="keywordflow">return</span> (a &gt; b) - (b &gt; a);
<a name="l10697"></a>10697 }
<a name="l10698"></a>10698 
<a name="l10699"></a>10699 <span class="comment">/* DW_AT_abstract_origin inherits whole DIEs (not just their attributes).</span>
<a name="l10700"></a>10700 <span class="comment">   Inherit only the children of the DW_AT_abstract_origin DIE not being</span>
<a name="l10701"></a>10701 <span class="comment">   already referenced by DW_AT_abstract_origin from the children of the</span>
<a name="l10702"></a>10702 <span class="comment">   current DIE.  */</span>
<a name="l10703"></a>10703 
<a name="l10704"></a>10704 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l10705"></a><a class="code" href="dwarf2read_8c.html#a3a6d1d01c1c42dbeb58ec934b497290c">10705</a> <a class="code" href="dwarf2read_8c.html#a3a6d1d01c1c42dbeb58ec934b497290c">inherit_abstract_dies</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l10706"></a>10706 {
<a name="l10707"></a>10707   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_die;
<a name="l10708"></a>10708   <span class="keywordtype">unsigned</span> die_children_count;
<a name="l10709"></a>10709   <span class="comment">/* CU offsets which were referenced by children of the current DIE.  */</span>
<a name="l10710"></a>10710   <a class="code" href="structsect__offset.html">sect_offset</a> *offsets;
<a name="l10711"></a>10711   <a class="code" href="structsect__offset.html">sect_offset</a> *offsets_end, *offsetp;
<a name="l10712"></a>10712   <span class="comment">/* Parent of DIE - referenced by DW_AT_abstract_origin.  */</span>
<a name="l10713"></a>10713   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *origin_die;
<a name="l10714"></a>10714   <span class="comment">/* Iterator of the ORIGIN_DIE children.  */</span>
<a name="l10715"></a>10715   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *origin_child_die;
<a name="l10716"></a>10716   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups;
<a name="l10717"></a>10717   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l10718"></a>10718   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *origin_cu;
<a name="l10719"></a>10719   <span class="keyword">struct </span><a class="code" href="structpending.html">pending</a> **origin_previous_list_in_scope;
<a name="l10720"></a>10720 
<a name="l10721"></a>10721   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_abstract_origin, cu);
<a name="l10722"></a>10722   <span class="keywordflow">if</span> (!attr)
<a name="l10723"></a>10723     <span class="keywordflow">return</span>;
<a name="l10724"></a>10724 
<a name="l10725"></a>10725   <span class="comment">/* Note that following die references may follow to a die in a</span>
<a name="l10726"></a>10726 <span class="comment">     different cu.  */</span>
<a name="l10727"></a>10727 
<a name="l10728"></a>10728   origin_cu = cu;
<a name="l10729"></a>10729   origin_die = <a class="code" href="dwarf2read_8c.html#a079b531fef51cfc34f92ff6fde2ef8a4">follow_die_ref</a> (die, attr, &amp;origin_cu);
<a name="l10730"></a>10730 
<a name="l10731"></a>10731   <span class="comment">/* We&#39;re inheriting ORIGIN&#39;s children into the scope we&#39;d put DIE&#39;s</span>
<a name="l10732"></a>10732 <span class="comment">     symbols in.  */</span>
<a name="l10733"></a>10733   origin_previous_list_in_scope = origin_cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>;
<a name="l10734"></a>10734   origin_cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a> = cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>;
<a name="l10735"></a>10735 
<a name="l10736"></a>10736   <span class="keywordflow">if</span> (die-&gt;tag != origin_die-&gt;tag
<a name="l10737"></a>10737       &amp;&amp; !(die-&gt;tag == DW_TAG_inlined_subroutine
<a name="l10738"></a>10738            &amp;&amp; origin_die-&gt;tag == DW_TAG_subprogram))
<a name="l10739"></a>10739     <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l10740"></a>10740                <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DIE 0x%x and its abstract origin 0x%x have different tags&quot;</span>),
<a name="l10741"></a>10741                die-&gt;offset.sect_off, origin_die-&gt;offset.sect_off);
<a name="l10742"></a>10742 
<a name="l10743"></a>10743   child_die = die-&gt;child;
<a name="l10744"></a>10744   die_children_count = 0;
<a name="l10745"></a>10745   <span class="keywordflow">while</span> (child_die &amp;&amp; child_die-&gt;tag)
<a name="l10746"></a>10746     {
<a name="l10747"></a>10747       child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l10748"></a>10748       die_children_count++;
<a name="l10749"></a>10749     }
<a name="l10750"></a>10750   offsets = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (*offsets) * die_children_count);
<a name="l10751"></a>10751   cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, offsets);
<a name="l10752"></a>10752 
<a name="l10753"></a>10753   offsets_end = offsets;
<a name="l10754"></a>10754   child_die = die-&gt;child;
<a name="l10755"></a>10755   <span class="keywordflow">while</span> (child_die &amp;&amp; child_die-&gt;tag)
<a name="l10756"></a>10756     {
<a name="l10757"></a>10757       <span class="comment">/* For each CHILD_DIE, find the corresponding child of</span>
<a name="l10758"></a>10758 <span class="comment">         ORIGIN_DIE.  If there is more than one layer of</span>
<a name="l10759"></a>10759 <span class="comment">         DW_AT_abstract_origin, follow them all; there shouldn&#39;t be,</span>
<a name="l10760"></a>10760 <span class="comment">         but GCC versions at least through 4.4 generate this (GCC PR</span>
<a name="l10761"></a>10761 <span class="comment">         40573).  */</span>
<a name="l10762"></a>10762       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_origin_die = child_die;
<a name="l10763"></a>10763       <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *child_origin_cu = cu;
<a name="l10764"></a>10764 
<a name="l10765"></a>10765       <span class="keywordflow">while</span> (1)
<a name="l10766"></a>10766         {
<a name="l10767"></a>10767           attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (child_origin_die, DW_AT_abstract_origin,
<a name="l10768"></a>10768                               child_origin_cu);
<a name="l10769"></a>10769           <span class="keywordflow">if</span> (attr == NULL)
<a name="l10770"></a>10770             <span class="keywordflow">break</span>;
<a name="l10771"></a>10771           child_origin_die = <a class="code" href="dwarf2read_8c.html#a079b531fef51cfc34f92ff6fde2ef8a4">follow_die_ref</a> (child_origin_die, attr,
<a name="l10772"></a>10772                                              &amp;child_origin_cu);
<a name="l10773"></a>10773         }
<a name="l10774"></a>10774 
<a name="l10775"></a>10775       <span class="comment">/* According to DWARF3 3.3.8.2 #3 new entries without their abstract</span>
<a name="l10776"></a>10776 <span class="comment">         counterpart may exist.  */</span>
<a name="l10777"></a>10777       <span class="keywordflow">if</span> (child_origin_die != child_die)
<a name="l10778"></a>10778         {
<a name="l10779"></a>10779           <span class="keywordflow">if</span> (child_die-&gt;tag != child_origin_die-&gt;tag
<a name="l10780"></a>10780               &amp;&amp; !(child_die-&gt;tag == DW_TAG_inlined_subroutine
<a name="l10781"></a>10781                    &amp;&amp; child_origin_die-&gt;tag == DW_TAG_subprogram))
<a name="l10782"></a>10782             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l10783"></a>10783                        <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Child DIE 0x%x and its abstract origin 0x%x have &quot;</span>
<a name="l10784"></a>10784                          <span class="stringliteral">&quot;different tags&quot;</span>), child_die-&gt;offset.sect_off,
<a name="l10785"></a>10785                        child_origin_die-&gt;offset.sect_off);
<a name="l10786"></a>10786           <span class="keywordflow">if</span> (child_origin_die-&gt;parent != origin_die)
<a name="l10787"></a>10787             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l10788"></a>10788                        <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Child DIE 0x%x and its abstract origin 0x%x have &quot;</span>
<a name="l10789"></a>10789                          <span class="stringliteral">&quot;different parents&quot;</span>), child_die-&gt;offset.sect_off,
<a name="l10790"></a>10790                        child_origin_die-&gt;offset.sect_off);
<a name="l10791"></a>10791           <span class="keywordflow">else</span>
<a name="l10792"></a>10792             *offsets_end++ = child_origin_die-&gt;offset;
<a name="l10793"></a>10793         }
<a name="l10794"></a>10794       child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l10795"></a>10795     }
<a name="l10796"></a>10796   <a class="code" href="ada-exp_8c.html#a849e2297facde4d3c80dc4f45f8abbdb">qsort</a> (offsets, offsets_end - offsets, <span class="keyword">sizeof</span> (*offsets),
<a name="l10797"></a>10797          <a class="code" href="dwarf2read_8c.html#a04678d6bb56ee3dafb694da954df3a86">unsigned_int_compar</a>);
<a name="l10798"></a>10798   <span class="keywordflow">for</span> (offsetp = offsets + 1; offsetp &lt; offsets_end; offsetp++)
<a name="l10799"></a>10799     <span class="keywordflow">if</span> (offsetp[-1].sect_off == offsetp-&gt;<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>)
<a name="l10800"></a>10800       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l10801"></a>10801                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Multiple children of DIE 0x%x refer &quot;</span>
<a name="l10802"></a>10802                    <span class="stringliteral">&quot;to DIE 0x%x as their abstract origin&quot;</span>),
<a name="l10803"></a>10803                  die-&gt;offset.sect_off, offsetp-&gt;<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l10804"></a>10804 
<a name="l10805"></a>10805   offsetp = offsets;
<a name="l10806"></a>10806   origin_child_die = origin_die-&gt;child;
<a name="l10807"></a>10807   <span class="keywordflow">while</span> (origin_child_die &amp;&amp; origin_child_die-&gt;tag)
<a name="l10808"></a>10808     {
<a name="l10809"></a>10809       <span class="comment">/* Is ORIGIN_CHILD_DIE referenced by any of the DIE children?  */</span>
<a name="l10810"></a>10810       <span class="keywordflow">while</span> (offsetp &lt; offsets_end
<a name="l10811"></a>10811              &amp;&amp; offsetp-&gt;<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> &lt; origin_child_die-&gt;offset.sect_off)
<a name="l10812"></a>10812         offsetp++;
<a name="l10813"></a>10813       <span class="keywordflow">if</span> (offsetp &gt;= offsets_end
<a name="l10814"></a>10814           || offsetp-&gt;<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> &gt; origin_child_die-&gt;offset.sect_off)
<a name="l10815"></a>10815         {
<a name="l10816"></a>10816           <span class="comment">/* Found that ORIGIN_CHILD_DIE is really not referenced.  */</span>
<a name="l10817"></a>10817           <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (origin_child_die, origin_cu);
<a name="l10818"></a>10818         }
<a name="l10819"></a>10819       origin_child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (origin_child_die);
<a name="l10820"></a>10820     }
<a name="l10821"></a>10821   origin_cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a> = origin_previous_list_in_scope;
<a name="l10822"></a>10822 
<a name="l10823"></a>10823   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l10824"></a>10824 }
<a name="l10825"></a>10825 
<a name="l10826"></a>10826 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l10827"></a><a class="code" href="dwarf2read_8c.html#a8883e03bccc13b39a7d3f1852dc96dfd">10827</a> <a class="code" href="dwarf2read_8c.html#a8883e03bccc13b39a7d3f1852dc96dfd">read_func_scope</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l10828"></a>10828 {
<a name="l10829"></a>10829   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l10830"></a>10830   <span class="keyword">struct </span><a class="code" href="structcontext__stack.html">context_stack</a> *<span class="keyword">new</span>;
<a name="l10831"></a>10831   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> lowpc;
<a name="l10832"></a>10832   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> highpc;
<a name="l10833"></a>10833   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_die;
<a name="l10834"></a>10834   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr, *call_line, *call_file;
<a name="l10835"></a>10835   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l10836"></a>10836   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> baseaddr;
<a name="l10837"></a>10837   <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>;
<a name="l10838"></a>10838   <span class="keywordtype">int</span> inlined_func = (die-&gt;tag == DW_TAG_inlined_subroutine);
<a name="l10839"></a>10839   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) *template_args = NULL;
<a name="l10840"></a>10840   <span class="keyword">struct </span><a class="code" href="structtemplate__symbol.html">template_symbol</a> *templ_func = NULL;
<a name="l10841"></a>10841 
<a name="l10842"></a>10842   <span class="keywordflow">if</span> (inlined_func)
<a name="l10843"></a>10843     {
<a name="l10844"></a>10844       <span class="comment">/* If we do not have call site information, we can&#39;t show the</span>
<a name="l10845"></a>10845 <span class="comment">         caller of this inlined function.  That&#39;s too confusing, so</span>
<a name="l10846"></a>10846 <span class="comment">         only use the scope for local variables.  */</span>
<a name="l10847"></a>10847       call_line = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_call_line, cu);
<a name="l10848"></a>10848       call_file = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_call_file, cu);
<a name="l10849"></a>10849       <span class="keywordflow">if</span> (call_line == NULL || call_file == NULL)
<a name="l10850"></a>10850         {
<a name="l10851"></a>10851           <a class="code" href="dwarf2read_8c.html#a1ada1c5f995cf53a504f3c9bce099fb5">read_lexical_block_scope</a> (die, cu);
<a name="l10852"></a>10852           <span class="keywordflow">return</span>;
<a name="l10853"></a>10853         }
<a name="l10854"></a>10854     }
<a name="l10855"></a>10855 
<a name="l10856"></a>10856   baseaddr = <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>, <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l10857"></a>10857 
<a name="l10858"></a>10858   name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l10859"></a>10859 
<a name="l10860"></a>10860   <span class="comment">/* Ignore functions with missing or empty names.  These are actually</span>
<a name="l10861"></a>10861 <span class="comment">     illegal according to the DWARF standard.  */</span>
<a name="l10862"></a>10862   <span class="keywordflow">if</span> (name == NULL)
<a name="l10863"></a>10863     {
<a name="l10864"></a>10864       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l10865"></a>10865                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;missing name for subprogram DIE at %d&quot;</span>),
<a name="l10866"></a>10866                  die-&gt;offset.sect_off);
<a name="l10867"></a>10867       <span class="keywordflow">return</span>;
<a name="l10868"></a>10868     }
<a name="l10869"></a>10869 
<a name="l10870"></a>10870   <span class="comment">/* Ignore functions with missing or invalid low and high pc attributes.  */</span>
<a name="l10871"></a>10871   <span class="keywordflow">if</span> (!<a class="code" href="dwarf2read_8c.html#ad8168e871bf8c579c8dbc4a6aad6bc0a">dwarf2_get_pc_bounds</a> (die, &amp;lowpc, &amp;highpc, cu, NULL))
<a name="l10872"></a>10872     {
<a name="l10873"></a>10873       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_external, cu);
<a name="l10874"></a>10874       <span class="keywordflow">if</span> (!attr || !<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr))
<a name="l10875"></a>10875         <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l10876"></a>10876                    <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot get low and high bounds &quot;</span>
<a name="l10877"></a>10877                      <span class="stringliteral">&quot;for subprogram DIE at %d&quot;</span>),
<a name="l10878"></a>10878                    die-&gt;offset.sect_off);
<a name="l10879"></a>10879       <span class="keywordflow">return</span>;
<a name="l10880"></a>10880     }
<a name="l10881"></a>10881 
<a name="l10882"></a>10882   lowpc += baseaddr;
<a name="l10883"></a>10883   highpc += baseaddr;
<a name="l10884"></a>10884 
<a name="l10885"></a>10885   <span class="comment">/* If we have any template arguments, then we must allocate a</span>
<a name="l10886"></a>10886 <span class="comment">     different sort of symbol.  */</span>
<a name="l10887"></a>10887   <span class="keywordflow">for</span> (child_die = die-&gt;child; child_die; child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die))
<a name="l10888"></a>10888     {
<a name="l10889"></a>10889       <span class="keywordflow">if</span> (child_die-&gt;tag == DW_TAG_template_type_param
<a name="l10890"></a>10890           || child_die-&gt;tag == DW_TAG_template_value_param)
<a name="l10891"></a>10891         {
<a name="l10892"></a>10892           templ_func = <a class="code" href="symtab_8c.html#a866f76f7f94b12d6e6f096f0258675c8">allocate_template_symbol</a> (objfile);
<a name="l10893"></a>10893           templ_func-&gt;<a class="code" href="structtemplate__symbol.html#a17c4aff620f991b31c87332ef816abf0">base</a>.<a class="code" href="structsymbol.html#a92cfb26fa780591e899445b27f8b44f3">is_cplus_template_function</a> = 1;
<a name="l10894"></a>10894           <span class="keywordflow">break</span>;
<a name="l10895"></a>10895         }
<a name="l10896"></a>10896     }
<a name="l10897"></a>10897 
<a name="l10898"></a>10898   <span class="keyword">new</span> = <a class="code" href="buildsym_8c.html#a10dcfe3c3dde25ce70e98261945cadd0">push_context</a> (0, lowpc);
<a name="l10899"></a>10899   <span class="keyword">new</span>-&gt;name = <a class="code" href="dwarf2read_8c.html#a3fc581e6a60a1d1195917cf292c45234">new_symbol_full</a> (die, <a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (die, cu), cu,
<a name="l10900"></a>10900                                (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *) templ_func);
<a name="l10901"></a>10901 
<a name="l10902"></a>10902   <span class="comment">/* If there is a location expression for DW_AT_frame_base, record</span>
<a name="l10903"></a>10903 <span class="comment">     it.  */</span>
<a name="l10904"></a>10904   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_frame_base, cu);
<a name="l10905"></a>10905   <span class="keywordflow">if</span> (attr)
<a name="l10906"></a>10906     <a class="code" href="dwarf2read_8c.html#a097117b0b695bca7ad085fee973f5bd1">dwarf2_symbol_mark_computed</a> (attr, new-&gt;name, cu, 1);
<a name="l10907"></a>10907 
<a name="l10908"></a>10908   cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a> = &amp;<a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a>;
<a name="l10909"></a>10909 
<a name="l10910"></a>10910   <span class="keywordflow">if</span> (die-&gt;child != NULL)
<a name="l10911"></a>10911     {
<a name="l10912"></a>10912       child_die = die-&gt;child;
<a name="l10913"></a>10913       <span class="keywordflow">while</span> (child_die &amp;&amp; child_die-&gt;tag)
<a name="l10914"></a>10914         {
<a name="l10915"></a>10915           <span class="keywordflow">if</span> (child_die-&gt;tag == DW_TAG_template_type_param
<a name="l10916"></a>10916               || child_die-&gt;tag == DW_TAG_template_value_param)
<a name="l10917"></a>10917             {
<a name="l10918"></a>10918               <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *arg = <a class="code" href="dwarf2read_8c.html#a4b79d225399dba2c4a3397a858440dd4">new_symbol</a> (child_die, NULL, cu);
<a name="l10919"></a>10919 
<a name="l10920"></a>10920               <span class="keywordflow">if</span> (arg != NULL)
<a name="l10921"></a>10921                 <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (symbolp, template_args, arg);
<a name="l10922"></a>10922             }
<a name="l10923"></a>10923           <span class="keywordflow">else</span>
<a name="l10924"></a>10924             <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (child_die, cu);
<a name="l10925"></a>10925           child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l10926"></a>10926         }
<a name="l10927"></a>10927     }
<a name="l10928"></a>10928 
<a name="l10929"></a>10929   <a class="code" href="dwarf2read_8c.html#a3a6d1d01c1c42dbeb58ec934b497290c">inherit_abstract_dies</a> (die, cu);
<a name="l10930"></a>10930 
<a name="l10931"></a>10931   <span class="comment">/* If we have a DW_AT_specification, we might need to import using</span>
<a name="l10932"></a>10932 <span class="comment">     directives from the context of the specification DIE.  See the</span>
<a name="l10933"></a>10933 <span class="comment">     comment in determine_prefix.  */</span>
<a name="l10934"></a>10934   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l10935"></a>10935       &amp;&amp; <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_specification, cu))
<a name="l10936"></a>10936     {
<a name="l10937"></a>10937       <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *spec_cu = cu;
<a name="l10938"></a>10938       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *spec_die = <a class="code" href="dwarf2read_8c.html#a86adfa4fccde4cd4c512ca520e5bb1d7">die_specification</a> (die, &amp;spec_cu);
<a name="l10939"></a>10939 
<a name="l10940"></a>10940       <span class="keywordflow">while</span> (spec_die)
<a name="l10941"></a>10941         {
<a name="l10942"></a>10942           child_die = spec_die-&gt;child;
<a name="l10943"></a>10943           <span class="keywordflow">while</span> (child_die &amp;&amp; child_die-&gt;tag)
<a name="l10944"></a>10944             {
<a name="l10945"></a>10945               <span class="keywordflow">if</span> (child_die-&gt;tag == DW_TAG_imported_module)
<a name="l10946"></a>10946                 <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (child_die, spec_cu);
<a name="l10947"></a>10947               child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l10948"></a>10948             }
<a name="l10949"></a>10949 
<a name="l10950"></a>10950           <span class="comment">/* In some cases, GCC generates specification DIEs that</span>
<a name="l10951"></a>10951 <span class="comment">             themselves contain DW_AT_specification attributes.  */</span>
<a name="l10952"></a>10952           spec_die = <a class="code" href="dwarf2read_8c.html#a86adfa4fccde4cd4c512ca520e5bb1d7">die_specification</a> (spec_die, &amp;spec_cu);
<a name="l10953"></a>10953         }
<a name="l10954"></a>10954     }
<a name="l10955"></a>10955 
<a name="l10956"></a>10956   <span class="keyword">new</span> = <a class="code" href="buildsym_8c.html#ae9abe41b6e678c647893e79758b4f0a5">pop_context</a> ();
<a name="l10957"></a>10957   <span class="comment">/* Make a block for the local symbols within.  */</span>
<a name="l10958"></a>10958   block = <a class="code" href="buildsym_8c.html#a382d9deb73200062937f3974c8d82cba">finish_block</a> (new-&gt;name, &amp;<a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a>, new-&gt;old_blocks,
<a name="l10959"></a>10959                         lowpc, highpc, objfile);
<a name="l10960"></a>10960 
<a name="l10961"></a>10961   <span class="comment">/* For C++, set the block&#39;s scope.  */</span>
<a name="l10962"></a>10962   <span class="keywordflow">if</span> ((cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a> || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>)
<a name="l10963"></a>10963       &amp;&amp; cu-&gt;processing_has_namespace_info)
<a name="l10964"></a>10964     <a class="code" href="block_8c.html#a64e037112ce9ee2a8f671db3c5f0d14e">block_set_scope</a> (block, <a class="code" href="dwarf2read_8c.html#a2417ea09b6b125e47a255352f662e856">determine_prefix</a> (die, cu),
<a name="l10965"></a>10965                      &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>);
<a name="l10966"></a>10966 
<a name="l10967"></a>10967   <span class="comment">/* If we have address ranges, record them.  */</span>
<a name="l10968"></a>10968   <a class="code" href="dwarf2read_8c.html#af80555d650cbaf81ef765d24905e9d3a">dwarf2_record_block_ranges</a> (die, block, baseaddr, cu);
<a name="l10969"></a>10969 
<a name="l10970"></a>10970   <span class="comment">/* Attach template arguments to function.  */</span>
<a name="l10971"></a>10971   <span class="keywordflow">if</span> (! <a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (symbolp, template_args))
<a name="l10972"></a>10972     {
<a name="l10973"></a>10973       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (templ_func != NULL);
<a name="l10974"></a>10974 
<a name="l10975"></a>10975       templ_func-&gt;n_template_arguments = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (symbolp, template_args);
<a name="l10976"></a>10976       templ_func-&gt;template_arguments
<a name="l10977"></a>10977         = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l10978"></a>10978                          (templ_func-&gt;n_template_arguments
<a name="l10979"></a>10979                           * sizeof (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *)));
<a name="l10980"></a>10980       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (templ_func-&gt;template_arguments,
<a name="l10981"></a>10981               <a class="code" href="vec_8h.html#a99adc2006a668acc675e3758d9375ad5">VEC_address</a> (symbolp, template_args),
<a name="l10982"></a>10982               (templ_func-&gt;n_template_arguments * sizeof (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *)));
<a name="l10983"></a>10983       <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (symbolp, template_args);
<a name="l10984"></a>10984     }
<a name="l10985"></a>10985 
<a name="l10986"></a>10986   <span class="comment">/* In C++, we can have functions nested inside functions (e.g., when</span>
<a name="l10987"></a>10987 <span class="comment">     a function declares a class that has methods).  This means that</span>
<a name="l10988"></a>10988 <span class="comment">     when we finish processing a function scope, we may need to go</span>
<a name="l10989"></a>10989 <span class="comment">     back to building a containing block&#39;s symbol lists.  */</span>
<a name="l10990"></a>10990   <a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a> = <span class="keyword">new</span>-&gt;locals;
<a name="l10991"></a>10991   <a class="code" href="buildsym_8h.html#a3ee358908ce462753b1da4ca1d9e8d81">using_directives</a> = <span class="keyword">new</span>-&gt;using_directives;
<a name="l10992"></a>10992 
<a name="l10993"></a>10993   <span class="comment">/* If we&#39;ve finished processing a top-level function, subsequent</span>
<a name="l10994"></a>10994 <span class="comment">     symbols go in the file symbol list.  */</span>
<a name="l10995"></a>10995   <span class="keywordflow">if</span> (<a class="code" href="buildsym_8h.html#a257134c61c6d23eb19f373ff25668806">outermost_context_p</a> ())
<a name="l10996"></a>10996     cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a> = &amp;<a class="code" href="buildsym_8h.html#a2d83ed7f7eeffeffeb2e00320573fd0d">file_symbols</a>;
<a name="l10997"></a>10997 }
<a name="l10998"></a>10998 
<a name="l10999"></a>10999 <span class="comment">/* Process all the DIES contained within a lexical block scope.  Start</span>
<a name="l11000"></a>11000 <span class="comment">   a new scope, process the dies, and then close the scope.  */</span>
<a name="l11001"></a>11001 
<a name="l11002"></a>11002 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11003"></a><a class="code" href="dwarf2read_8c.html#a1ada1c5f995cf53a504f3c9bce099fb5">11003</a> <a class="code" href="dwarf2read_8c.html#a1ada1c5f995cf53a504f3c9bce099fb5">read_lexical_block_scope</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l11004"></a>11004 {
<a name="l11005"></a>11005   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l11006"></a>11006   <span class="keyword">struct </span><a class="code" href="structcontext__stack.html">context_stack</a> *<span class="keyword">new</span>;
<a name="l11007"></a>11007   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> lowpc, highpc;
<a name="l11008"></a>11008   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_die;
<a name="l11009"></a>11009   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> baseaddr;
<a name="l11010"></a>11010 
<a name="l11011"></a>11011   baseaddr = <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>, <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l11012"></a>11012 
<a name="l11013"></a>11013   <span class="comment">/* Ignore blocks with missing or invalid low and high pc attributes.  */</span>
<a name="l11014"></a>11014   <span class="comment">/* ??? Perhaps consider discontiguous blocks defined by DW_AT_ranges</span>
<a name="l11015"></a>11015 <span class="comment">     as multiple lexical blocks?  Handling children in a sane way would</span>
<a name="l11016"></a>11016 <span class="comment">     be nasty.  Might be easier to properly extend generic blocks to</span>
<a name="l11017"></a>11017 <span class="comment">     describe ranges.  */</span>
<a name="l11018"></a>11018   <span class="keywordflow">if</span> (!<a class="code" href="dwarf2read_8c.html#ad8168e871bf8c579c8dbc4a6aad6bc0a">dwarf2_get_pc_bounds</a> (die, &amp;lowpc, &amp;highpc, cu, NULL))
<a name="l11019"></a>11019     <span class="keywordflow">return</span>;
<a name="l11020"></a>11020   lowpc += baseaddr;
<a name="l11021"></a>11021   highpc += baseaddr;
<a name="l11022"></a>11022 
<a name="l11023"></a>11023   <a class="code" href="buildsym_8c.html#a10dcfe3c3dde25ce70e98261945cadd0">push_context</a> (0, lowpc);
<a name="l11024"></a>11024   <span class="keywordflow">if</span> (die-&gt;child != NULL)
<a name="l11025"></a>11025     {
<a name="l11026"></a>11026       child_die = die-&gt;child;
<a name="l11027"></a>11027       <span class="keywordflow">while</span> (child_die &amp;&amp; child_die-&gt;tag)
<a name="l11028"></a>11028         {
<a name="l11029"></a>11029           <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (child_die, cu);
<a name="l11030"></a>11030           child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l11031"></a>11031         }
<a name="l11032"></a>11032     }
<a name="l11033"></a>11033   <span class="keyword">new</span> = <a class="code" href="buildsym_8c.html#ae9abe41b6e678c647893e79758b4f0a5">pop_context</a> ();
<a name="l11034"></a>11034 
<a name="l11035"></a>11035   <span class="keywordflow">if</span> (<a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a> != NULL || <a class="code" href="buildsym_8h.html#a3ee358908ce462753b1da4ca1d9e8d81">using_directives</a> != NULL)
<a name="l11036"></a>11036     {
<a name="l11037"></a>11037       <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>
<a name="l11038"></a>11038         = <a class="code" href="buildsym_8c.html#a382d9deb73200062937f3974c8d82cba">finish_block</a> (0, &amp;<a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a>, new-&gt;old_blocks, new-&gt;start_addr,
<a name="l11039"></a>11039                         highpc, objfile);
<a name="l11040"></a>11040 
<a name="l11041"></a>11041       <span class="comment">/* Note that recording ranges after traversing children, as we</span>
<a name="l11042"></a>11042 <span class="comment">         do here, means that recording a parent&#39;s ranges entails</span>
<a name="l11043"></a>11043 <span class="comment">         walking across all its children&#39;s ranges as they appear in</span>
<a name="l11044"></a>11044 <span class="comment">         the address map, which is quadratic behavior.</span>
<a name="l11045"></a>11045 <span class="comment"></span>
<a name="l11046"></a>11046 <span class="comment">         It would be nicer to record the parent&#39;s ranges before</span>
<a name="l11047"></a>11047 <span class="comment">         traversing its children, simply overriding whatever you find</span>
<a name="l11048"></a>11048 <span class="comment">         there.  But since we don&#39;t even decide whether to create a</span>
<a name="l11049"></a>11049 <span class="comment">         block until after we&#39;ve traversed its children, that&#39;s hard</span>
<a name="l11050"></a>11050 <span class="comment">         to do.  */</span>
<a name="l11051"></a>11051       <a class="code" href="dwarf2read_8c.html#af80555d650cbaf81ef765d24905e9d3a">dwarf2_record_block_ranges</a> (die, block, baseaddr, cu);
<a name="l11052"></a>11052     }
<a name="l11053"></a>11053   <a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a> = <span class="keyword">new</span>-&gt;locals;
<a name="l11054"></a>11054   <a class="code" href="buildsym_8h.html#a3ee358908ce462753b1da4ca1d9e8d81">using_directives</a> = <span class="keyword">new</span>-&gt;using_directives;
<a name="l11055"></a>11055 }
<a name="l11056"></a>11056 
<a name="l11057"></a>11057 <span class="comment">/* Read in DW_TAG_GNU_call_site and insert it to CU-&gt;call_site_htab.  */</span>
<a name="l11058"></a>11058 
<a name="l11059"></a>11059 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11060"></a><a class="code" href="dwarf2read_8c.html#a763117964c95fb54ba4c8ebe38e2ff87">11060</a> <a class="code" href="dwarf2read_8c.html#a763117964c95fb54ba4c8ebe38e2ff87">read_call_site_scope</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l11061"></a>11061 {
<a name="l11062"></a>11062   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l11063"></a>11063   <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l11064"></a>11064   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc, baseaddr;
<a name="l11065"></a>11065   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l11066"></a>11066   <span class="keyword">struct </span><a class="code" href="structcall__site.html">call_site</a> *<a class="code" href="structcall__site.html">call_site</a>, call_site_local;
<a name="l11067"></a>11067   <span class="keywordtype">void</span> **slot;
<a name="l11068"></a>11068   <span class="keywordtype">int</span> nparams;
<a name="l11069"></a>11069   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_die;
<a name="l11070"></a>11070 
<a name="l11071"></a>11071   baseaddr = <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>, <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l11072"></a>11072 
<a name="l11073"></a>11073   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_low_pc, cu);
<a name="l11074"></a>11074   <span class="keywordflow">if</span> (!attr)
<a name="l11075"></a>11075     {
<a name="l11076"></a>11076       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11077"></a>11077                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;missing DW_AT_low_pc for DW_TAG_GNU_call_site &quot;</span>
<a name="l11078"></a>11078                    <span class="stringliteral">&quot;DIE 0x%x [in module %s]&quot;</span>),
<a name="l11079"></a>11079                  die-&gt;offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l11080"></a>11080       <span class="keywordflow">return</span>;
<a name="l11081"></a>11081     }
<a name="l11082"></a>11082   pc = <a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (attr) + baseaddr;
<a name="l11083"></a>11083 
<a name="l11084"></a>11084   <span class="keywordflow">if</span> (cu-&gt;call_site_htab == NULL)
<a name="l11085"></a>11085     cu-&gt;call_site_htab = htab_create_alloc_ex (16, <a class="code" href="utils_8c.html#ae35efe09250f405fd2c94693eb10f754">core_addr_hash</a>, <a class="code" href="utils_8c.html#a0a0c3e1f4590aec88cb5d47d8cebe479">core_addr_eq</a>,
<a name="l11086"></a>11086                                                NULL, &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l11087"></a>11087                                                <a class="code" href="utils_8c.html#a64b0a5e317b6f45f062aa8356111644b">hashtab_obstack_allocate</a>, NULL);
<a name="l11088"></a>11088   call_site_local.<a class="code" href="structcall__site.html#ae6f3db49fe991fa24591a0185f3ffa01">pc</a> = pc;
<a name="l11089"></a>11089   slot = htab_find_slot (cu-&gt;call_site_htab, &amp;call_site_local, INSERT);
<a name="l11090"></a>11090   <span class="keywordflow">if</span> (*slot != NULL)
<a name="l11091"></a>11091     {
<a name="l11092"></a>11092       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11093"></a>11093                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Duplicate PC %s for DW_TAG_GNU_call_site &quot;</span>
<a name="l11094"></a>11094                    <span class="stringliteral">&quot;DIE 0x%x [in module %s]&quot;</span>),
<a name="l11095"></a>11095                  <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, pc), die-&gt;offset.sect_off,
<a name="l11096"></a>11096                  <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l11097"></a>11097       <span class="keywordflow">return</span>;
<a name="l11098"></a>11098     }
<a name="l11099"></a>11099 
<a name="l11100"></a>11100   <span class="comment">/* Count parameters at the caller.  */</span>
<a name="l11101"></a>11101 
<a name="l11102"></a>11102   nparams = 0;
<a name="l11103"></a>11103   <span class="keywordflow">for</span> (child_die = die-&gt;child; child_die &amp;&amp; child_die-&gt;tag;
<a name="l11104"></a>11104        child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die))
<a name="l11105"></a>11105     {
<a name="l11106"></a>11106       <span class="keywordflow">if</span> (child_die-&gt;tag != DW_TAG_GNU_call_site_parameter)
<a name="l11107"></a>11107         {
<a name="l11108"></a>11108           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11109"></a>11109                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Tag %d is not DW_TAG_GNU_call_site_parameter in &quot;</span>
<a name="l11110"></a>11110                        <span class="stringliteral">&quot;DW_TAG_GNU_call_site child DIE 0x%x [in module %s]&quot;</span>),
<a name="l11111"></a>11111                      child_die-&gt;tag, child_die-&gt;offset.sect_off,
<a name="l11112"></a>11112                      <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l11113"></a>11113           <span class="keywordflow">continue</span>;
<a name="l11114"></a>11114         }
<a name="l11115"></a>11115 
<a name="l11116"></a>11116       nparams++;
<a name="l11117"></a>11117     }
<a name="l11118"></a>11118 
<a name="l11119"></a>11119   call_site = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l11120"></a>11120                              (sizeof (*call_site)
<a name="l11121"></a>11121                               + (<span class="keyword">sizeof</span> (*call_site-&gt;<a class="code" href="structcall__site.html#a206493b317c8ba6b4918d7faaf87c88a">parameter</a>)
<a name="l11122"></a>11122                                  * (nparams - 1))));
<a name="l11123"></a>11123   *slot = call_site;
<a name="l11124"></a>11124   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (call_site, 0, <span class="keyword">sizeof</span> (*call_site) - <span class="keyword">sizeof</span> (*call_site-&gt;<a class="code" href="structcall__site.html#a206493b317c8ba6b4918d7faaf87c88a">parameter</a>));
<a name="l11125"></a>11125   call_site-&gt;<a class="code" href="structcall__site.html#ae6f3db49fe991fa24591a0185f3ffa01">pc</a> = pc;
<a name="l11126"></a>11126 
<a name="l11127"></a>11127   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ae71fe9211c7daaccc4d43abbe838c8dc">dwarf2_flag_true_p</a> (die, DW_AT_GNU_tail_call, cu))
<a name="l11128"></a>11128     {
<a name="l11129"></a>11129       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *func_die;
<a name="l11130"></a>11130 
<a name="l11131"></a>11131       <span class="comment">/* Skip also over DW_TAG_inlined_subroutine.  */</span>
<a name="l11132"></a>11132       <span class="keywordflow">for</span> (func_die = die-&gt;parent;
<a name="l11133"></a>11133            func_die &amp;&amp; func_die-&gt;tag != DW_TAG_subprogram
<a name="l11134"></a>11134            &amp;&amp; func_die-&gt;tag != DW_TAG_subroutine_type;
<a name="l11135"></a>11135            func_die = func_die-&gt;parent);
<a name="l11136"></a>11136 
<a name="l11137"></a>11137       <span class="comment">/* DW_AT_GNU_all_call_sites is a superset</span>
<a name="l11138"></a>11138 <span class="comment">         of DW_AT_GNU_all_tail_call_sites.  */</span>
<a name="l11139"></a>11139       <span class="keywordflow">if</span> (func_die
<a name="l11140"></a>11140           &amp;&amp; !<a class="code" href="dwarf2read_8c.html#ae71fe9211c7daaccc4d43abbe838c8dc">dwarf2_flag_true_p</a> (func_die, DW_AT_GNU_all_call_sites, cu)
<a name="l11141"></a>11141           &amp;&amp; !<a class="code" href="dwarf2read_8c.html#ae71fe9211c7daaccc4d43abbe838c8dc">dwarf2_flag_true_p</a> (func_die, DW_AT_GNU_all_tail_call_sites, cu))
<a name="l11142"></a>11142         {
<a name="l11143"></a>11143           <span class="comment">/* TYPE_TAIL_CALL_LIST is not interesting in functions where it is</span>
<a name="l11144"></a>11144 <span class="comment">             not complete.  But keep CALL_SITE for look ups via call_site_htab,</span>
<a name="l11145"></a>11145 <span class="comment">             both the initial caller containing the real return address PC and</span>
<a name="l11146"></a>11146 <span class="comment">             the final callee containing the current PC of a chain of tail</span>
<a name="l11147"></a>11147 <span class="comment">             calls do not need to have the tail call list complete.  But any</span>
<a name="l11148"></a>11148 <span class="comment">             function candidate for a virtual tail call frame searched via</span>
<a name="l11149"></a>11149 <span class="comment">             TYPE_TAIL_CALL_LIST must have the tail call list complete to be</span>
<a name="l11150"></a>11150 <span class="comment">             determined unambiguously.  */</span>
<a name="l11151"></a>11151         }
<a name="l11152"></a>11152       <span class="keywordflow">else</span>
<a name="l11153"></a>11153         {
<a name="l11154"></a>11154           <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structfunc__type.html">func_type</a> = NULL;
<a name="l11155"></a>11155 
<a name="l11156"></a>11156           <span class="keywordflow">if</span> (func_die)
<a name="l11157"></a>11157             func_type = <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (func_die, cu);
<a name="l11158"></a>11158           <span class="keywordflow">if</span> (func_type != NULL)
<a name="l11159"></a>11159             {
<a name="l11160"></a>11160               <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (func_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>);
<a name="l11161"></a>11161 
<a name="l11162"></a>11162               <span class="comment">/* Enlist this call site to the function.  */</span>
<a name="l11163"></a>11163               call_site-&gt;<a class="code" href="structcall__site.html#ac7b21bc370832490b6dbacd76894c1a1">tail_call_next</a> = <a class="code" href="gdbtypes_8h.html#aa506d232b2c4c0710d012b6844b73662">TYPE_TAIL_CALL_LIST</a> (func_type);
<a name="l11164"></a>11164               <a class="code" href="gdbtypes_8h.html#aa506d232b2c4c0710d012b6844b73662">TYPE_TAIL_CALL_LIST</a> (func_type) = call_site;
<a name="l11165"></a>11165             }
<a name="l11166"></a>11166           <span class="keywordflow">else</span>
<a name="l11167"></a>11167             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11168"></a>11168                        <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot find function owning DW_TAG_GNU_call_site &quot;</span>
<a name="l11169"></a>11169                          <span class="stringliteral">&quot;DIE 0x%x [in module %s]&quot;</span>),
<a name="l11170"></a>11170                        die-&gt;offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l11171"></a>11171         }
<a name="l11172"></a>11172     }
<a name="l11173"></a>11173 
<a name="l11174"></a>11174   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_GNU_call_site_target, cu);
<a name="l11175"></a>11175   <span class="keywordflow">if</span> (attr == NULL)
<a name="l11176"></a>11176     attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_abstract_origin, cu);
<a name="l11177"></a>11177   <a class="code" href="gdbtypes_8h.html#aaceadec4e6dcef3346f0156294873b6d">SET_FIELD_DWARF_BLOCK</a> (call_site-&gt;<a class="code" href="structcall__site.html#a1072897f4beb09ea7e45911eb1e562af">target</a>, NULL);
<a name="l11178"></a>11178   <span class="keywordflow">if</span> (!attr || (<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (attr) &amp;&amp; <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;<a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> == 0))
<a name="l11179"></a>11179     <span class="comment">/* Keep NULL DWARF_BLOCK.  */</span>;
<a name="l11180"></a>11180   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (attr))
<a name="l11181"></a>11181     {
<a name="l11182"></a>11182       <span class="keyword">struct </span><a class="code" href="structdwarf2__locexpr__baton.html">dwarf2_locexpr_baton</a> *dlbaton;
<a name="l11183"></a>11183 
<a name="l11184"></a>11184       dlbaton = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, sizeof (*dlbaton));
<a name="l11185"></a>11185       dlbaton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#a629a2d12a13c59e34ffc1f64953b5f01">data</a> = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data;
<a name="l11186"></a>11186       dlbaton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#aad393a9f0c112b45b23fb0d30c19df07">size</a> = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;size;
<a name="l11187"></a>11187       dlbaton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#a4f4c2fcdbde62332afde34a8a95d91fe">per_cu</a> = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;
<a name="l11188"></a>11188 
<a name="l11189"></a>11189       <a class="code" href="gdbtypes_8h.html#aaceadec4e6dcef3346f0156294873b6d">SET_FIELD_DWARF_BLOCK</a> (call_site-&gt;<a class="code" href="structcall__site.html#a1072897f4beb09ea7e45911eb1e562af">target</a>, dlbaton);
<a name="l11190"></a>11190     }
<a name="l11191"></a>11191   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a217d4eb87ed57947007169e88bb2a0f9">attr_form_is_ref</a> (attr))
<a name="l11192"></a>11192     {
<a name="l11193"></a>11193       <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *target_cu = cu;
<a name="l11194"></a>11194       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *target_die;
<a name="l11195"></a>11195 
<a name="l11196"></a>11196       target_die = <a class="code" href="dwarf2read_8c.html#a079b531fef51cfc34f92ff6fde2ef8a4">follow_die_ref</a> (die, attr, &amp;target_cu);
<a name="l11197"></a>11197       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (target_cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a> == objfile);
<a name="l11198"></a>11198       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#aa9ca23caab102417f39b86b7b2716588">die_is_declaration</a> (target_die, target_cu))
<a name="l11199"></a>11199         {
<a name="l11200"></a>11200           <span class="keyword">const</span> <span class="keywordtype">char</span> *target_physname = NULL;
<a name="l11201"></a>11201           <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *target_attr;
<a name="l11202"></a>11202 
<a name="l11203"></a>11203           <span class="comment">/* Prefer the mangled name; otherwise compute the demangled one.  */</span>
<a name="l11204"></a>11204           target_attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (target_die, DW_AT_linkage_name, target_cu);
<a name="l11205"></a>11205           <span class="keywordflow">if</span> (target_attr == NULL)
<a name="l11206"></a>11206             target_attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (target_die, DW_AT_MIPS_linkage_name,
<a name="l11207"></a>11207                                        target_cu);
<a name="l11208"></a>11208           <span class="keywordflow">if</span> (target_attr != NULL &amp;&amp; <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (target_attr) != NULL)
<a name="l11209"></a>11209             target_physname = <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (target_attr);
<a name="l11210"></a>11210           <span class="keywordflow">else</span>
<a name="l11211"></a>11211             target_physname = <a class="code" href="dwarf2read_8c.html#a94813a9fc414b7ba920cdcee76b34d36">dwarf2_physname</a> (NULL, target_die, target_cu);
<a name="l11212"></a>11212           <span class="keywordflow">if</span> (target_physname == NULL)
<a name="l11213"></a>11213             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11214"></a>11214                        <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_AT_GNU_call_site_target target DIE has invalid &quot;</span>
<a name="l11215"></a>11215                          <span class="stringliteral">&quot;physname, for referencing DIE 0x%x [in module %s]&quot;</span>),
<a name="l11216"></a>11216                        die-&gt;offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l11217"></a>11217           <span class="keywordflow">else</span>
<a name="l11218"></a>11218             <a class="code" href="gdbtypes_8h.html#a07a65b002f15d09d0b4ddec1f778e8b3">SET_FIELD_PHYSNAME</a> (call_site-&gt;<a class="code" href="structcall__site.html#a1072897f4beb09ea7e45911eb1e562af">target</a>, target_physname);
<a name="l11219"></a>11219         }
<a name="l11220"></a>11220       <span class="keywordflow">else</span>
<a name="l11221"></a>11221         {
<a name="l11222"></a>11222           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> lowpc;
<a name="l11223"></a>11223 
<a name="l11224"></a>11224           <span class="comment">/* DW_AT_entry_pc should be preferred.  */</span>
<a name="l11225"></a>11225           <span class="keywordflow">if</span> (!<a class="code" href="dwarf2read_8c.html#ad8168e871bf8c579c8dbc4a6aad6bc0a">dwarf2_get_pc_bounds</a> (target_die, &amp;lowpc, NULL, target_cu, NULL))
<a name="l11226"></a>11226             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11227"></a>11227                        <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_AT_GNU_call_site_target target DIE has invalid &quot;</span>
<a name="l11228"></a>11228                          <span class="stringliteral">&quot;low pc, for referencing DIE 0x%x [in module %s]&quot;</span>),
<a name="l11229"></a>11229                        die-&gt;offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l11230"></a>11230           <span class="keywordflow">else</span>
<a name="l11231"></a>11231             <a class="code" href="gdbtypes_8h.html#a7832aca28f8cb43c7e307c6a67e472ba">SET_FIELD_PHYSADDR</a> (call_site-&gt;<a class="code" href="structcall__site.html#a1072897f4beb09ea7e45911eb1e562af">target</a>, lowpc + baseaddr);
<a name="l11232"></a>11232         }
<a name="l11233"></a>11233     }
<a name="l11234"></a>11234   <span class="keywordflow">else</span>
<a name="l11235"></a>11235     <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11236"></a>11236                <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_TAG_GNU_call_site DW_AT_GNU_call_site_target is neither &quot;</span>
<a name="l11237"></a>11237                  <span class="stringliteral">&quot;block nor reference, for DIE 0x%x [in module %s]&quot;</span>),
<a name="l11238"></a>11238                die-&gt;offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l11239"></a>11239 
<a name="l11240"></a>11240   call_site-&gt;<a class="code" href="structcall__site.html#ab1b6ca82dfc73d704a961f0617883bc7">per_cu</a> = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;
<a name="l11241"></a>11241 
<a name="l11242"></a>11242   <span class="keywordflow">for</span> (child_die = die-&gt;child;
<a name="l11243"></a>11243        child_die &amp;&amp; child_die-&gt;tag;
<a name="l11244"></a>11244        child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die))
<a name="l11245"></a>11245     {
<a name="l11246"></a>11246       <span class="keyword">struct </span>call_site_parameter *parameter;
<a name="l11247"></a>11247       <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *loc, *origin;
<a name="l11248"></a>11248 
<a name="l11249"></a>11249       <span class="keywordflow">if</span> (child_die-&gt;tag != DW_TAG_GNU_call_site_parameter)
<a name="l11250"></a>11250         {
<a name="l11251"></a>11251           <span class="comment">/* Already printed the complaint above.  */</span>
<a name="l11252"></a>11252           <span class="keywordflow">continue</span>;
<a name="l11253"></a>11253         }
<a name="l11254"></a>11254 
<a name="l11255"></a>11255       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (call_site-&gt;<a class="code" href="structcall__site.html#a13d30c155964d25c96863e9046d443b3">parameter_count</a> &lt; nparams);
<a name="l11256"></a>11256       parameter = &amp;call_site-&gt;<a class="code" href="structcall__site.html#a206493b317c8ba6b4918d7faaf87c88a">parameter</a>[call_site-&gt;<a class="code" href="structcall__site.html#a13d30c155964d25c96863e9046d443b3">parameter_count</a>];
<a name="l11257"></a>11257 
<a name="l11258"></a>11258       <span class="comment">/* DW_AT_location specifies the register number or DW_AT_abstract_origin</span>
<a name="l11259"></a>11259 <span class="comment">         specifies DW_TAG_formal_parameter.  Value of the data assumed for the</span>
<a name="l11260"></a>11260 <span class="comment">         register is contained in DW_AT_GNU_call_site_value.  */</span>
<a name="l11261"></a>11261 
<a name="l11262"></a>11262       loc = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (child_die, DW_AT_location, cu);
<a name="l11263"></a>11263       origin = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (child_die, DW_AT_abstract_origin, cu);
<a name="l11264"></a>11264       <span class="keywordflow">if</span> (loc == NULL &amp;&amp; origin != NULL &amp;&amp; <a class="code" href="dwarf2read_8c.html#a217d4eb87ed57947007169e88bb2a0f9">attr_form_is_ref</a> (origin))
<a name="l11265"></a>11265         {
<a name="l11266"></a>11266           <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l11267"></a>11267 
<a name="l11268"></a>11268           parameter-&gt;kind = <a class="code" href="gdbtypes_8h.html#abc3720e18b62534187c1c6b6e4677a28adc3c86b822ec65d2d128ac78af3113df">CALL_SITE_PARAMETER_PARAM_OFFSET</a>;
<a name="l11269"></a>11269           offset = <a class="code" href="dwarf2read_8c.html#a28e7eb63f317d51f9be16584d407c508">dwarf2_get_ref_die_offset</a> (origin);
<a name="l11270"></a>11270           <span class="keywordflow">if</span> (!<a class="code" href="dwarf2read_8c.html#a244f083f251f3bfffd839e9fd3670a9a">offset_in_cu_p</a> (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>, offset))
<a name="l11271"></a>11271             {
<a name="l11272"></a>11272               <span class="comment">/* As DW_OP_GNU_parameter_ref uses CU-relative offset this</span>
<a name="l11273"></a>11273 <span class="comment">                 binding can be done only inside one CU.  Such referenced DIE</span>
<a name="l11274"></a>11274 <span class="comment">                 therefore cannot be even moved to DW_TAG_partial_unit.  */</span>
<a name="l11275"></a>11275               <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11276"></a>11276                          <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_AT_abstract_origin offset is not in CU for &quot;</span>
<a name="l11277"></a>11277                            <span class="stringliteral">&quot;DW_TAG_GNU_call_site child DIE 0x%x &quot;</span>
<a name="l11278"></a>11278                            <span class="stringliteral">&quot;[in module %s]&quot;</span>),
<a name="l11279"></a>11279                          child_die-&gt;offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l11280"></a>11280               <span class="keywordflow">continue</span>;
<a name="l11281"></a>11281             }
<a name="l11282"></a>11282           parameter-&gt;u.param_offset.cu_off = (offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>
<a name="l11283"></a>11283                                               - cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l11284"></a>11284         }
<a name="l11285"></a>11285       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (loc == NULL || origin != NULL || !<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (loc))
<a name="l11286"></a>11286         {
<a name="l11287"></a>11287           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11288"></a>11288                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No DW_FORM_block* DW_AT_location for &quot;</span>
<a name="l11289"></a>11289                        <span class="stringliteral">&quot;DW_TAG_GNU_call_site child DIE 0x%x [in module %s]&quot;</span>),
<a name="l11290"></a>11290                      child_die-&gt;offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l11291"></a>11291           <span class="keywordflow">continue</span>;
<a name="l11292"></a>11292         }
<a name="l11293"></a>11293       <span class="keywordflow">else</span>
<a name="l11294"></a>11294         {
<a name="l11295"></a>11295           parameter-&gt;u.dwarf_reg = <a class="code" href="dwarf2expr_8c.html#aeca82aaa184aaef984b5d4ca30c9a7eb">dwarf_block_to_dwarf_reg</a>
<a name="l11296"></a>11296             (<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (loc)-&gt;data, &amp;<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (loc)-&gt;data[<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (loc)-&gt;<a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>]);
<a name="l11297"></a>11297           <span class="keywordflow">if</span> (parameter-&gt;u.dwarf_reg != -1)
<a name="l11298"></a>11298             parameter-&gt;kind = <a class="code" href="gdbtypes_8h.html#abc3720e18b62534187c1c6b6e4677a28ac7ee57235687368b997a828d75a1699a">CALL_SITE_PARAMETER_DWARF_REG</a>;
<a name="l11299"></a>11299           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2expr_8c.html#abd504ecbadba374bd915d96646559b9f">dwarf_block_to_sp_offset</a> (gdbarch, <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (loc)-&gt;data,
<a name="l11300"></a>11300                                     &amp;<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (loc)-&gt;data[<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (loc)-&gt;<a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>],
<a name="l11301"></a>11301                                              &amp;parameter-&gt;u.fb_offset))
<a name="l11302"></a>11302             parameter-&gt;kind = <a class="code" href="gdbtypes_8h.html#abc3720e18b62534187c1c6b6e4677a28a1269dcc44cae916985c5bebc6780b0be">CALL_SITE_PARAMETER_FB_OFFSET</a>;
<a name="l11303"></a>11303           <span class="keywordflow">else</span>
<a name="l11304"></a>11304             {
<a name="l11305"></a>11305               <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11306"></a>11306                          <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Only single DW_OP_reg or DW_OP_fbreg is supported &quot;</span>
<a name="l11307"></a>11307                            <span class="stringliteral">&quot;for DW_FORM_block* DW_AT_location is supported for &quot;</span>
<a name="l11308"></a>11308                            <span class="stringliteral">&quot;DW_TAG_GNU_call_site child DIE 0x%x &quot;</span>
<a name="l11309"></a>11309                            <span class="stringliteral">&quot;[in module %s]&quot;</span>),
<a name="l11310"></a>11310                          child_die-&gt;offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l11311"></a>11311               <span class="keywordflow">continue</span>;
<a name="l11312"></a>11312             }
<a name="l11313"></a>11313         }
<a name="l11314"></a>11314 
<a name="l11315"></a>11315       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (child_die, DW_AT_GNU_call_site_value, cu);
<a name="l11316"></a>11316       <span class="keywordflow">if</span> (!<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (attr))
<a name="l11317"></a>11317         {
<a name="l11318"></a>11318           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11319"></a>11319                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No DW_FORM_block* DW_AT_GNU_call_site_value for &quot;</span>
<a name="l11320"></a>11320                        <span class="stringliteral">&quot;DW_TAG_GNU_call_site child DIE 0x%x [in module %s]&quot;</span>),
<a name="l11321"></a>11321                      child_die-&gt;offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l11322"></a>11322           <span class="keywordflow">continue</span>;
<a name="l11323"></a>11323         }
<a name="l11324"></a>11324       parameter-&gt;value = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data;
<a name="l11325"></a>11325       parameter-&gt;value_size = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;size;
<a name="l11326"></a>11326 
<a name="l11327"></a>11327       <span class="comment">/* Parameters are not pre-cleared by memset above.  */</span>
<a name="l11328"></a>11328       parameter-&gt;data_value = NULL;
<a name="l11329"></a>11329       parameter-&gt;data_value_size = 0;
<a name="l11330"></a>11330       call_site-&gt;<a class="code" href="structcall__site.html#a13d30c155964d25c96863e9046d443b3">parameter_count</a>++;
<a name="l11331"></a>11331 
<a name="l11332"></a>11332       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (child_die, DW_AT_GNU_call_site_data_value, cu);
<a name="l11333"></a>11333       <span class="keywordflow">if</span> (attr)
<a name="l11334"></a>11334         {
<a name="l11335"></a>11335           <span class="keywordflow">if</span> (!<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (attr))
<a name="l11336"></a>11336             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11337"></a>11337                        <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No DW_FORM_block* DW_AT_GNU_call_site_data_value for &quot;</span>
<a name="l11338"></a>11338                          <span class="stringliteral">&quot;DW_TAG_GNU_call_site child DIE 0x%x [in module %s]&quot;</span>),
<a name="l11339"></a>11339                        child_die-&gt;offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l11340"></a>11340           <span class="keywordflow">else</span>
<a name="l11341"></a>11341             {
<a name="l11342"></a>11342               parameter-&gt;data_value = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data;
<a name="l11343"></a>11343               parameter-&gt;data_value_size = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;size;
<a name="l11344"></a>11344             }
<a name="l11345"></a>11345         }
<a name="l11346"></a>11346     }
<a name="l11347"></a>11347 }
<a name="l11348"></a>11348 
<a name="l11349"></a>11349 <span class="comment">/* Get low and high pc attributes from DW_AT_ranges attribute value OFFSET.</span>
<a name="l11350"></a>11350 <span class="comment">   Return 1 if the attributes are present and valid, otherwise, return 0.</span>
<a name="l11351"></a>11351 <span class="comment">   If RANGES_PST is not NULL we should setup `objfile-&gt;psymtabs_addrmap&#39;.  */</span>
<a name="l11352"></a>11352 
<a name="l11353"></a>11353 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l11354"></a><a class="code" href="dwarf2read_8c.html#a2f36d2456807d0d9528aa34b750b5b59">11354</a> <a class="code" href="dwarf2read_8c.html#a2f36d2456807d0d9528aa34b750b5b59">dwarf2_ranges_read</a> (<span class="keywordtype">unsigned</span> offset, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *low_return,
<a name="l11355"></a>11355                     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *high_return, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l11356"></a>11356                     <span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *ranges_pst)
<a name="l11357"></a>11357 {
<a name="l11358"></a>11358   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l11359"></a>11359   <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_header = &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>;
<a name="l11360"></a>11360   bfd *obfd = objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>;
<a name="l11361"></a>11361   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a> = cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l11362"></a>11362   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> mask = ~(~(<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>)1 &lt;&lt; (addr_size * 8 - 1));
<a name="l11363"></a>11363   <span class="comment">/* Base address selection entry.  */</span>
<a name="l11364"></a>11364   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> base;
<a name="l11365"></a>11365   <span class="keywordtype">int</span> found_base;
<a name="l11366"></a>11366   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a36fb645a916cd19d79712e75c47b8d03">dummy</a>;
<a name="l11367"></a>11367   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structbuffer.html">buffer</a>;
<a name="l11368"></a>11368   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> marker;
<a name="l11369"></a>11369   <span class="keywordtype">int</span> low_set;
<a name="l11370"></a>11370   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> low = 0;
<a name="l11371"></a>11371   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> high = 0;
<a name="l11372"></a>11372   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> baseaddr;
<a name="l11373"></a>11373 
<a name="l11374"></a>11374   found_base = cu-&gt;<a class="code" href="structdwarf2__cu.html#a119974d7d2639455e745de437261ade8">base_known</a>;
<a name="l11375"></a>11375   base = cu-&gt;<a class="code" href="structdwarf2__cu.html#a23134f383c2bf69e7c15465e6bb7c128">base_address</a>;
<a name="l11376"></a>11376 
<a name="l11377"></a>11377   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a654a21dc8afa0f2dee30874b781462b0">ranges</a>);
<a name="l11378"></a>11378   <span class="keywordflow">if</span> (offset &gt;= dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a654a21dc8afa0f2dee30874b781462b0">ranges</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>)
<a name="l11379"></a>11379     {
<a name="l11380"></a>11380       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11381"></a>11381                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Offset %d out of bounds for DW_AT_ranges attribute&quot;</span>),
<a name="l11382"></a>11382                  offset);
<a name="l11383"></a>11383       <span class="keywordflow">return</span> 0;
<a name="l11384"></a>11384     }
<a name="l11385"></a>11385   buffer = dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a654a21dc8afa0f2dee30874b781462b0">ranges</a>.<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l11386"></a>11386 
<a name="l11387"></a>11387   <span class="comment">/* Read in the largest possible address.  */</span>
<a name="l11388"></a>11388   marker = <a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">read_address</a> (obfd, buffer, cu, &amp;dummy);
<a name="l11389"></a>11389   <span class="keywordflow">if</span> ((marker &amp; mask) == mask)
<a name="l11390"></a>11390     {
<a name="l11391"></a>11391       <span class="comment">/* If we found the largest possible address, then</span>
<a name="l11392"></a>11392 <span class="comment">         read the base address.  */</span>
<a name="l11393"></a>11393       base = <a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">read_address</a> (obfd, buffer + addr_size, cu, &amp;dummy);
<a name="l11394"></a>11394       buffer += 2 * <a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l11395"></a>11395       offset += 2 * <a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l11396"></a>11396       found_base = 1;
<a name="l11397"></a>11397     }
<a name="l11398"></a>11398 
<a name="l11399"></a>11399   low_set = 0;
<a name="l11400"></a>11400 
<a name="l11401"></a>11401   baseaddr = <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>, <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l11402"></a>11402 
<a name="l11403"></a>11403   <span class="keywordflow">while</span> (1)
<a name="l11404"></a>11404     {
<a name="l11405"></a>11405       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> range_beginning, range_end;
<a name="l11406"></a>11406 
<a name="l11407"></a>11407       range_beginning = <a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">read_address</a> (obfd, buffer, cu, &amp;dummy);
<a name="l11408"></a>11408       buffer += <a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l11409"></a>11409       range_end = <a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">read_address</a> (obfd, buffer, cu, &amp;dummy);
<a name="l11410"></a>11410       buffer += <a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l11411"></a>11411       offset += 2 * <a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l11412"></a>11412 
<a name="l11413"></a>11413       <span class="comment">/* An end of list marker is a pair of zero addresses.  */</span>
<a name="l11414"></a>11414       <span class="keywordflow">if</span> (range_beginning == 0 &amp;&amp; range_end == 0)
<a name="l11415"></a>11415         <span class="comment">/* Found the end of list entry.  */</span>
<a name="l11416"></a>11416         <span class="keywordflow">break</span>;
<a name="l11417"></a>11417 
<a name="l11418"></a>11418       <span class="comment">/* Each base address selection entry is a pair of 2 values.</span>
<a name="l11419"></a>11419 <span class="comment">         The first is the largest possible address, the second is</span>
<a name="l11420"></a>11420 <span class="comment">         the base address.  Check for a base address here.  */</span>
<a name="l11421"></a>11421       <span class="keywordflow">if</span> ((range_beginning &amp; mask) == mask)
<a name="l11422"></a>11422         {
<a name="l11423"></a>11423           <span class="comment">/* If we found the largest possible address, then</span>
<a name="l11424"></a>11424 <span class="comment">             read the base address.  */</span>
<a name="l11425"></a>11425           base = <a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">read_address</a> (obfd, buffer + addr_size, cu, &amp;dummy);
<a name="l11426"></a>11426           found_base = 1;
<a name="l11427"></a>11427           <span class="keywordflow">continue</span>;
<a name="l11428"></a>11428         }
<a name="l11429"></a>11429 
<a name="l11430"></a>11430       <span class="keywordflow">if</span> (!found_base)
<a name="l11431"></a>11431         {
<a name="l11432"></a>11432           <span class="comment">/* We have no valid base address for the ranges</span>
<a name="l11433"></a>11433 <span class="comment">             data.  */</span>
<a name="l11434"></a>11434           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11435"></a>11435                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Invalid .debug_ranges data (no base address)&quot;</span>));
<a name="l11436"></a>11436           <span class="keywordflow">return</span> 0;
<a name="l11437"></a>11437         }
<a name="l11438"></a>11438 
<a name="l11439"></a>11439       <span class="keywordflow">if</span> (range_beginning &gt; range_end)
<a name="l11440"></a>11440         {
<a name="l11441"></a>11441           <span class="comment">/* Inverted range entries are invalid.  */</span>
<a name="l11442"></a>11442           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11443"></a>11443                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Invalid .debug_ranges data (inverted range)&quot;</span>));
<a name="l11444"></a>11444           <span class="keywordflow">return</span> 0;
<a name="l11445"></a>11445         }
<a name="l11446"></a>11446 
<a name="l11447"></a>11447       <span class="comment">/* Empty range entries have no effect.  */</span>
<a name="l11448"></a>11448       <span class="keywordflow">if</span> (range_beginning == range_end)
<a name="l11449"></a>11449         <span class="keywordflow">continue</span>;
<a name="l11450"></a>11450 
<a name="l11451"></a>11451       range_beginning += base;
<a name="l11452"></a>11452       range_end += base;
<a name="l11453"></a>11453 
<a name="l11454"></a>11454       <span class="comment">/* A not-uncommon case of bad debug info.</span>
<a name="l11455"></a>11455 <span class="comment">         Don&#39;t pollute the addrmap with bad data.  */</span>
<a name="l11456"></a>11456       <span class="keywordflow">if</span> (range_beginning + baseaddr == 0
<a name="l11457"></a>11457           &amp;&amp; !dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ab6b03c3a65fa04f04741158e8aebc895">has_section_at_zero</a>)
<a name="l11458"></a>11458         {
<a name="l11459"></a>11459           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11460"></a>11460                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;.debug_ranges entry has start address of zero&quot;</span>
<a name="l11461"></a>11461                        <span class="stringliteral">&quot; [in module %s]&quot;</span>), <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l11462"></a>11462           <span class="keywordflow">continue</span>;
<a name="l11463"></a>11463         }
<a name="l11464"></a>11464 
<a name="l11465"></a>11465       <span class="keywordflow">if</span> (ranges_pst != NULL)
<a name="l11466"></a>11466         <a class="code" href="addrmap_8c.html#ad0decf9c15214a17313c8c9d9828205c">addrmap_set_empty</a> (objfile-&gt;<a class="code" href="structobjfile.html#ae7c792f2cd4efcff86d84d7bd3e15b26">psymtabs_addrmap</a>,
<a name="l11467"></a>11467                            range_beginning + baseaddr,
<a name="l11468"></a>11468                            range_end - 1 + baseaddr,
<a name="l11469"></a>11469                            ranges_pst);
<a name="l11470"></a>11470 
<a name="l11471"></a>11471       <span class="comment">/* FIXME: This is recording everything as a low-high</span>
<a name="l11472"></a>11472 <span class="comment">         segment of consecutive addresses.  We should have a</span>
<a name="l11473"></a>11473 <span class="comment">         data structure for discontiguous block ranges</span>
<a name="l11474"></a>11474 <span class="comment">         instead.  */</span>
<a name="l11475"></a>11475       <span class="keywordflow">if</span> (! low_set)
<a name="l11476"></a>11476         {
<a name="l11477"></a>11477           low = range_beginning;
<a name="l11478"></a>11478           high = range_end;
<a name="l11479"></a>11479           low_set = 1;
<a name="l11480"></a>11480         }
<a name="l11481"></a>11481       <span class="keywordflow">else</span>
<a name="l11482"></a>11482         {
<a name="l11483"></a>11483           <span class="keywordflow">if</span> (range_beginning &lt; low)
<a name="l11484"></a>11484             low = range_beginning;
<a name="l11485"></a>11485           <span class="keywordflow">if</span> (range_end &gt; high)
<a name="l11486"></a>11486             high = range_end;
<a name="l11487"></a>11487         }
<a name="l11488"></a>11488     }
<a name="l11489"></a>11489 
<a name="l11490"></a>11490   <span class="keywordflow">if</span> (! low_set)
<a name="l11491"></a>11491     <span class="comment">/* If the first entry is an end-of-list marker, the range</span>
<a name="l11492"></a>11492 <span class="comment">       describes an empty scope, i.e. no instructions.  */</span>
<a name="l11493"></a>11493     <span class="keywordflow">return</span> 0;
<a name="l11494"></a>11494 
<a name="l11495"></a>11495   <span class="keywordflow">if</span> (low_return)
<a name="l11496"></a>11496     *low_return = low;
<a name="l11497"></a>11497   <span class="keywordflow">if</span> (high_return)
<a name="l11498"></a>11498     *high_return = high;
<a name="l11499"></a>11499   <span class="keywordflow">return</span> 1;
<a name="l11500"></a>11500 }
<a name="l11501"></a>11501 
<a name="l11502"></a>11502 <span class="comment">/* Get low and high pc attributes from a die.  Return 1 if the attributes</span>
<a name="l11503"></a>11503 <span class="comment">   are present and valid, otherwise, return 0.  Return -1 if the range is</span>
<a name="l11504"></a>11504 <span class="comment">   discontinuous, i.e. derived from DW_AT_ranges information.  */</span>
<a name="l11505"></a>11505 
<a name="l11506"></a>11506 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l11507"></a><a class="code" href="dwarf2read_8c.html#ad8168e871bf8c579c8dbc4a6aad6bc0a">11507</a> <a class="code" href="dwarf2read_8c.html#ad8168e871bf8c579c8dbc4a6aad6bc0a">dwarf2_get_pc_bounds</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *lowpc,
<a name="l11508"></a>11508                       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *highpc, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l11509"></a>11509                       <span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst)
<a name="l11510"></a>11510 {
<a name="l11511"></a>11511   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l11512"></a>11512   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr_high;
<a name="l11513"></a>11513   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> low = 0;
<a name="l11514"></a>11514   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> high = 0;
<a name="l11515"></a>11515   <span class="keywordtype">int</span> ret = 0;
<a name="l11516"></a>11516 
<a name="l11517"></a>11517   attr_high = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_high_pc, cu);
<a name="l11518"></a>11518   <span class="keywordflow">if</span> (attr_high)
<a name="l11519"></a>11519     {
<a name="l11520"></a>11520       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_low_pc, cu);
<a name="l11521"></a>11521       <span class="keywordflow">if</span> (attr)
<a name="l11522"></a>11522         {
<a name="l11523"></a>11523           low = <a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (attr);
<a name="l11524"></a>11524           <span class="keywordflow">if</span> (attr_high-&gt;form == DW_FORM_addr
<a name="l11525"></a>11525               || attr_high-&gt;form == DW_FORM_GNU_addr_index)
<a name="l11526"></a>11526             high = <a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (attr_high);
<a name="l11527"></a>11527           <span class="keywordflow">else</span>
<a name="l11528"></a>11528             high = low + <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr_high);
<a name="l11529"></a>11529         }
<a name="l11530"></a>11530       <span class="keywordflow">else</span>
<a name="l11531"></a>11531         <span class="comment">/* Found high w/o low attribute.  */</span>
<a name="l11532"></a>11532         <span class="keywordflow">return</span> 0;
<a name="l11533"></a>11533 
<a name="l11534"></a>11534       <span class="comment">/* Found consecutive range of addresses.  */</span>
<a name="l11535"></a>11535       ret = 1;
<a name="l11536"></a>11536     }
<a name="l11537"></a>11537   <span class="keywordflow">else</span>
<a name="l11538"></a>11538     {
<a name="l11539"></a>11539       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_ranges, cu);
<a name="l11540"></a>11540       <span class="keywordflow">if</span> (attr != NULL)
<a name="l11541"></a>11541         {
<a name="l11542"></a>11542           <span class="comment">/* DW_AT_ranges_base does not apply to DIEs from the DWO skeleton.</span>
<a name="l11543"></a>11543 <span class="comment">             We take advantage of the fact that DW_AT_ranges does not appear</span>
<a name="l11544"></a>11544 <span class="comment">             in DW_TAG_compile_unit of DWO files.  */</span>
<a name="l11545"></a>11545           <span class="keywordtype">int</span> need_ranges_base = die-&gt;tag != DW_TAG_compile_unit;
<a name="l11546"></a>11546           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ranges_offset = (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr)
<a name="l11547"></a>11547                                         + (need_ranges_base
<a name="l11548"></a>11548                                            ? cu-&gt;ranges_base
<a name="l11549"></a>11549                                            : 0));
<a name="l11550"></a>11550 
<a name="l11551"></a>11551           <span class="comment">/* Value of the DW_AT_ranges attribute is the offset in the</span>
<a name="l11552"></a>11552 <span class="comment">             .debug_ranges section.  */</span>
<a name="l11553"></a>11553           <span class="keywordflow">if</span> (!<a class="code" href="dwarf2read_8c.html#a2f36d2456807d0d9528aa34b750b5b59">dwarf2_ranges_read</a> (ranges_offset, &amp;low, &amp;high, cu, pst))
<a name="l11554"></a>11554             <span class="keywordflow">return</span> 0;
<a name="l11555"></a>11555           <span class="comment">/* Found discontinuous range of addresses.  */</span>
<a name="l11556"></a>11556           ret = -1;
<a name="l11557"></a>11557         }
<a name="l11558"></a>11558     }
<a name="l11559"></a>11559 
<a name="l11560"></a>11560   <span class="comment">/* read_partial_die has also the strict LOW &lt; HIGH requirement.  */</span>
<a name="l11561"></a>11561   <span class="keywordflow">if</span> (high &lt;= low)
<a name="l11562"></a>11562     <span class="keywordflow">return</span> 0;
<a name="l11563"></a>11563 
<a name="l11564"></a>11564   <span class="comment">/* When using the GNU linker, .gnu.linkonce. sections are used to</span>
<a name="l11565"></a>11565 <span class="comment">     eliminate duplicate copies of functions and vtables and such.</span>
<a name="l11566"></a>11566 <span class="comment">     The linker will arbitrarily choose one and discard the others.</span>
<a name="l11567"></a>11567 <span class="comment">     The AT_*_pc values for such functions refer to local labels in</span>
<a name="l11568"></a>11568 <span class="comment">     these sections.  If the section from that file was discarded, the</span>
<a name="l11569"></a>11569 <span class="comment">     labels are not in the output, so the relocs get a value of 0.</span>
<a name="l11570"></a>11570 <span class="comment">     If this is a discarded function, mark the pc bounds as invalid,</span>
<a name="l11571"></a>11571 <span class="comment">     so that GDB will ignore it.  */</span>
<a name="l11572"></a>11572   <span class="keywordflow">if</span> (low == 0 &amp;&amp; !dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ab6b03c3a65fa04f04741158e8aebc895">has_section_at_zero</a>)
<a name="l11573"></a>11573     <span class="keywordflow">return</span> 0;
<a name="l11574"></a>11574 
<a name="l11575"></a>11575   *lowpc = low;
<a name="l11576"></a>11576   <span class="keywordflow">if</span> (highpc)
<a name="l11577"></a>11577     *highpc = high;
<a name="l11578"></a>11578   <span class="keywordflow">return</span> ret;
<a name="l11579"></a>11579 }
<a name="l11580"></a>11580 
<a name="l11581"></a>11581 <span class="comment">/* Assuming that DIE represents a subprogram DIE or a lexical block, get</span>
<a name="l11582"></a>11582 <span class="comment">   its low and high PC addresses.  Do nothing if these addresses could not</span>
<a name="l11583"></a>11583 <span class="comment">   be determined.  Otherwise, set LOWPC to the low address if it is smaller,</span>
<a name="l11584"></a>11584 <span class="comment">   and HIGHPC to the high address if greater than HIGHPC.  */</span>
<a name="l11585"></a>11585 
<a name="l11586"></a>11586 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11587"></a><a class="code" href="dwarf2read_8c.html#a0978bdf23681a8926d42c2ffac84073c">11587</a> <a class="code" href="dwarf2read_8c.html#a0978bdf23681a8926d42c2ffac84073c">dwarf2_get_subprogram_pc_bounds</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l11588"></a>11588                                  <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *lowpc, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *highpc,
<a name="l11589"></a>11589                                  <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l11590"></a>11590 {
<a name="l11591"></a>11591   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> low, high;
<a name="l11592"></a>11592   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child = die-&gt;child;
<a name="l11593"></a>11593 
<a name="l11594"></a>11594   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ad8168e871bf8c579c8dbc4a6aad6bc0a">dwarf2_get_pc_bounds</a> (die, &amp;low, &amp;high, cu, NULL))
<a name="l11595"></a>11595     {
<a name="l11596"></a>11596       *lowpc = <a class="code" href="environ_8c.html#ac6afabdc09a49a433ee19d8a9486056d">min</a> (*lowpc, low);
<a name="l11597"></a>11597       *highpc = <a class="code" href="environ_8c.html#affe776513b24d84b39af8ab0930fef7f">max</a> (*highpc, high);
<a name="l11598"></a>11598     }
<a name="l11599"></a>11599 
<a name="l11600"></a>11600   <span class="comment">/* If the language does not allow nested subprograms (either inside</span>
<a name="l11601"></a>11601 <span class="comment">     subprograms or lexical blocks), we&#39;re done.  */</span>
<a name="l11602"></a>11602   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l11603"></a>11603     <span class="keywordflow">return</span>;
<a name="l11604"></a>11604 
<a name="l11605"></a>11605   <span class="comment">/* Check all the children of the given DIE.  If it contains nested</span>
<a name="l11606"></a>11606 <span class="comment">     subprograms, then check their pc bounds.  Likewise, we need to</span>
<a name="l11607"></a>11607 <span class="comment">     check lexical blocks as well, as they may also contain subprogram</span>
<a name="l11608"></a>11608 <span class="comment">     definitions.  */</span>
<a name="l11609"></a>11609   <span class="keywordflow">while</span> (child &amp;&amp; child-&gt;tag)
<a name="l11610"></a>11610     {
<a name="l11611"></a>11611       <span class="keywordflow">if</span> (child-&gt;tag == DW_TAG_subprogram
<a name="l11612"></a>11612           || child-&gt;tag == DW_TAG_lexical_block)
<a name="l11613"></a>11613         <a class="code" href="dwarf2read_8c.html#a0978bdf23681a8926d42c2ffac84073c">dwarf2_get_subprogram_pc_bounds</a> (child, lowpc, highpc, cu);
<a name="l11614"></a>11614       child = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child);
<a name="l11615"></a>11615     }
<a name="l11616"></a>11616 }
<a name="l11617"></a>11617 
<a name="l11618"></a>11618 <span class="comment">/* Get the low and high pc&#39;s represented by the scope DIE, and store</span>
<a name="l11619"></a>11619 <span class="comment">   them in *LOWPC and *HIGHPC.  If the correct values can&#39;t be</span>
<a name="l11620"></a>11620 <span class="comment">   determined, set *LOWPC to -1 and *HIGHPC to 0.  */</span>
<a name="l11621"></a>11621 
<a name="l11622"></a>11622 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11623"></a><a class="code" href="dwarf2read_8c.html#aa7a89cfc9f4650dde9ef152c70edbe41">11623</a> <a class="code" href="dwarf2read_8c.html#aa7a89cfc9f4650dde9ef152c70edbe41">get_scope_pc_bounds</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l11624"></a>11624                      <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *lowpc, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *highpc,
<a name="l11625"></a>11625                      <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l11626"></a>11626 {
<a name="l11627"></a>11627   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> best_low = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) -1;
<a name="l11628"></a>11628   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> best_high = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 0;
<a name="l11629"></a>11629   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> current_low, current_high;
<a name="l11630"></a>11630 
<a name="l11631"></a>11631   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ad8168e871bf8c579c8dbc4a6aad6bc0a">dwarf2_get_pc_bounds</a> (die, &amp;current_low, &amp;current_high, cu, NULL))
<a name="l11632"></a>11632     {
<a name="l11633"></a>11633       best_low = current_low;
<a name="l11634"></a>11634       best_high = current_high;
<a name="l11635"></a>11635     }
<a name="l11636"></a>11636   <span class="keywordflow">else</span>
<a name="l11637"></a>11637     {
<a name="l11638"></a>11638       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child = die-&gt;child;
<a name="l11639"></a>11639 
<a name="l11640"></a>11640       <span class="keywordflow">while</span> (child &amp;&amp; child-&gt;tag)
<a name="l11641"></a>11641         {
<a name="l11642"></a>11642           <span class="keywordflow">switch</span> (child-&gt;tag) {
<a name="l11643"></a>11643           <span class="keywordflow">case</span> DW_TAG_subprogram:
<a name="l11644"></a>11644             <a class="code" href="dwarf2read_8c.html#a0978bdf23681a8926d42c2ffac84073c">dwarf2_get_subprogram_pc_bounds</a> (child, &amp;best_low, &amp;best_high, cu);
<a name="l11645"></a>11645             <span class="keywordflow">break</span>;
<a name="l11646"></a>11646           <span class="keywordflow">case</span> DW_TAG_namespace:
<a name="l11647"></a>11647           <span class="keywordflow">case</span> DW_TAG_module:
<a name="l11648"></a>11648             <span class="comment">/* FIXME: carlton/2004-01-16: Should we do this for</span>
<a name="l11649"></a>11649 <span class="comment">               DW_TAG_class_type/DW_TAG_structure_type, too?  I think</span>
<a name="l11650"></a>11650 <span class="comment">               that current GCC&#39;s always emit the DIEs corresponding</span>
<a name="l11651"></a>11651 <span class="comment">               to definitions of methods of classes as children of a</span>
<a name="l11652"></a>11652 <span class="comment">               DW_TAG_compile_unit or DW_TAG_namespace (as opposed to</span>
<a name="l11653"></a>11653 <span class="comment">               the DIEs giving the declarations, which could be</span>
<a name="l11654"></a>11654 <span class="comment">               anywhere).  But I don&#39;t see any reason why the</span>
<a name="l11655"></a>11655 <span class="comment">               standards says that they have to be there.  */</span>
<a name="l11656"></a>11656             <a class="code" href="dwarf2read_8c.html#aa7a89cfc9f4650dde9ef152c70edbe41">get_scope_pc_bounds</a> (child, &amp;current_low, &amp;current_high, cu);
<a name="l11657"></a>11657 
<a name="l11658"></a>11658             <span class="keywordflow">if</span> (current_low != ((<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) -1))
<a name="l11659"></a>11659               {
<a name="l11660"></a>11660                 best_low = <a class="code" href="environ_8c.html#ac6afabdc09a49a433ee19d8a9486056d">min</a> (best_low, current_low);
<a name="l11661"></a>11661                 best_high = <a class="code" href="environ_8c.html#affe776513b24d84b39af8ab0930fef7f">max</a> (best_high, current_high);
<a name="l11662"></a>11662               }
<a name="l11663"></a>11663             <span class="keywordflow">break</span>;
<a name="l11664"></a>11664           <span class="keywordflow">default</span>:
<a name="l11665"></a>11665             <span class="comment">/* Ignore.  */</span>
<a name="l11666"></a>11666             <span class="keywordflow">break</span>;
<a name="l11667"></a>11667           }
<a name="l11668"></a>11668 
<a name="l11669"></a>11669           child = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child);
<a name="l11670"></a>11670         }
<a name="l11671"></a>11671     }
<a name="l11672"></a>11672 
<a name="l11673"></a>11673   *lowpc = best_low;
<a name="l11674"></a>11674   *highpc = best_high;
<a name="l11675"></a>11675 }
<a name="l11676"></a>11676 
<a name="l11677"></a>11677 <span class="comment">/* Record the address ranges for BLOCK, offset by BASEADDR, as given</span>
<a name="l11678"></a>11678 <span class="comment">   in DIE.  */</span>
<a name="l11679"></a>11679 
<a name="l11680"></a>11680 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11681"></a><a class="code" href="dwarf2read_8c.html#af80555d650cbaf81ef765d24905e9d3a">11681</a> <a class="code" href="dwarf2read_8c.html#af80555d650cbaf81ef765d24905e9d3a">dwarf2_record_block_ranges</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>,
<a name="l11682"></a>11682                             <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> baseaddr, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l11683"></a>11683 {
<a name="l11684"></a>11684   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l11685"></a>11685   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l11686"></a>11686   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr_high;
<a name="l11687"></a>11687 
<a name="l11688"></a>11688   attr_high = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_high_pc, cu);
<a name="l11689"></a>11689   <span class="keywordflow">if</span> (attr_high)
<a name="l11690"></a>11690     {
<a name="l11691"></a>11691       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_low_pc, cu);
<a name="l11692"></a>11692       <span class="keywordflow">if</span> (attr)
<a name="l11693"></a>11693         {
<a name="l11694"></a>11694           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> low = <a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (attr);
<a name="l11695"></a>11695           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> high;
<a name="l11696"></a>11696           <span class="keywordflow">if</span> (attr_high-&gt;form == DW_FORM_addr
<a name="l11697"></a>11697               || attr_high-&gt;form == DW_FORM_GNU_addr_index)
<a name="l11698"></a>11698             high = <a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (attr_high);
<a name="l11699"></a>11699           <span class="keywordflow">else</span>
<a name="l11700"></a>11700             high = low + <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr_high);
<a name="l11701"></a>11701 
<a name="l11702"></a>11702           <a class="code" href="buildsym_8c.html#af741de313ae265df7edffbfff0a80cf7">record_block_range</a> (block, baseaddr + low, baseaddr + high - 1);
<a name="l11703"></a>11703         }
<a name="l11704"></a>11704     }
<a name="l11705"></a>11705 
<a name="l11706"></a>11706   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_ranges, cu);
<a name="l11707"></a>11707   <span class="keywordflow">if</span> (attr)
<a name="l11708"></a>11708     {
<a name="l11709"></a>11709       bfd *obfd = objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>;
<a name="l11710"></a>11710       <span class="comment">/* DW_AT_ranges_base does not apply to DIEs from the DWO skeleton.</span>
<a name="l11711"></a>11711 <span class="comment">         We take advantage of the fact that DW_AT_ranges does not appear</span>
<a name="l11712"></a>11712 <span class="comment">         in DW_TAG_compile_unit of DWO files.  */</span>
<a name="l11713"></a>11713       <span class="keywordtype">int</span> need_ranges_base = die-&gt;tag != DW_TAG_compile_unit;
<a name="l11714"></a>11714 
<a name="l11715"></a>11715       <span class="comment">/* The value of the DW_AT_ranges attribute is the offset of the</span>
<a name="l11716"></a>11716 <span class="comment">         address range list in the .debug_ranges section.  */</span>
<a name="l11717"></a>11717       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> offset = (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr)
<a name="l11718"></a>11718                               + (need_ranges_base ? cu-&gt;ranges_base : 0));
<a name="l11719"></a>11719       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structbuffer.html">buffer</a>;
<a name="l11720"></a>11720 
<a name="l11721"></a>11721       <span class="comment">/* For some target architectures, but not others, the</span>
<a name="l11722"></a>11722 <span class="comment">         read_address function sign-extends the addresses it returns.</span>
<a name="l11723"></a>11723 <span class="comment">         To recognize base address selection entries, we need a</span>
<a name="l11724"></a>11724 <span class="comment">         mask.  */</span>
<a name="l11725"></a>11725       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> addr_size = cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l11726"></a>11726       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> base_select_mask = ~(~(<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>)1 &lt;&lt; (addr_size * 8 - 1));
<a name="l11727"></a>11727 
<a name="l11728"></a>11728       <span class="comment">/* The base address, to which the next pair is relative.  Note</span>
<a name="l11729"></a>11729 <span class="comment">         that this &#39;base&#39; is a DWARF concept: most entries in a range</span>
<a name="l11730"></a>11730 <span class="comment">         list are relative, to reduce the number of relocs against the</span>
<a name="l11731"></a>11731 <span class="comment">         debugging information.  This is separate from this function&#39;s</span>
<a name="l11732"></a>11732 <span class="comment">         &#39;baseaddr&#39; argument, which GDB uses to relocate debugging</span>
<a name="l11733"></a>11733 <span class="comment">         information from a shared library based on the address at</span>
<a name="l11734"></a>11734 <span class="comment">         which the library was loaded.  */</span>
<a name="l11735"></a>11735       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> base = cu-&gt;<a class="code" href="structdwarf2__cu.html#a23134f383c2bf69e7c15465e6bb7c128">base_address</a>;
<a name="l11736"></a>11736       <span class="keywordtype">int</span> base_known = cu-&gt;<a class="code" href="structdwarf2__cu.html#a119974d7d2639455e745de437261ade8">base_known</a>;
<a name="l11737"></a>11737 
<a name="l11738"></a>11738       <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a654a21dc8afa0f2dee30874b781462b0">ranges</a>);
<a name="l11739"></a>11739       <span class="keywordflow">if</span> (offset &gt;= dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a654a21dc8afa0f2dee30874b781462b0">ranges</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>)
<a name="l11740"></a>11740         {
<a name="l11741"></a>11741           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11742"></a>11742                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Offset %lu out of bounds for DW_AT_ranges attribute&quot;</span>),
<a name="l11743"></a>11743                      offset);
<a name="l11744"></a>11744           <span class="keywordflow">return</span>;
<a name="l11745"></a>11745         }
<a name="l11746"></a>11746       buffer = dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a654a21dc8afa0f2dee30874b781462b0">ranges</a>.<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l11747"></a>11747 
<a name="l11748"></a>11748       <span class="keywordflow">for</span> (;;)
<a name="l11749"></a>11749         {
<a name="l11750"></a>11750           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l11751"></a>11751           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start, end;
<a name="l11752"></a>11752 
<a name="l11753"></a>11753           start = <a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">read_address</a> (obfd, buffer, cu, &amp;bytes_read);
<a name="l11754"></a>11754           buffer += bytes_read;
<a name="l11755"></a>11755           end = <a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">read_address</a> (obfd, buffer, cu, &amp;bytes_read);
<a name="l11756"></a>11756           buffer += bytes_read;
<a name="l11757"></a>11757 
<a name="l11758"></a>11758           <span class="comment">/* Did we find the end of the range list?  */</span>
<a name="l11759"></a>11759           <span class="keywordflow">if</span> (start == 0 &amp;&amp; end == 0)
<a name="l11760"></a>11760             <span class="keywordflow">break</span>;
<a name="l11761"></a>11761 
<a name="l11762"></a>11762           <span class="comment">/* Did we find a base address selection entry?  */</span>
<a name="l11763"></a>11763           <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((start &amp; base_select_mask) == base_select_mask)
<a name="l11764"></a>11764             {
<a name="l11765"></a>11765               base = end;
<a name="l11766"></a>11766               base_known = 1;
<a name="l11767"></a>11767             }
<a name="l11768"></a>11768 
<a name="l11769"></a>11769           <span class="comment">/* We found an ordinary address range.  */</span>
<a name="l11770"></a>11770           <span class="keywordflow">else</span>
<a name="l11771"></a>11771             {
<a name="l11772"></a>11772               <span class="keywordflow">if</span> (!base_known)
<a name="l11773"></a>11773                 {
<a name="l11774"></a>11774                   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11775"></a>11775                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Invalid .debug_ranges data &quot;</span>
<a name="l11776"></a>11776                                <span class="stringliteral">&quot;(no base address)&quot;</span>));
<a name="l11777"></a>11777                   <span class="keywordflow">return</span>;
<a name="l11778"></a>11778                 }
<a name="l11779"></a>11779 
<a name="l11780"></a>11780               <span class="keywordflow">if</span> (start &gt; end)
<a name="l11781"></a>11781                 {
<a name="l11782"></a>11782                   <span class="comment">/* Inverted range entries are invalid.  */</span>
<a name="l11783"></a>11783                   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11784"></a>11784                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Invalid .debug_ranges data &quot;</span>
<a name="l11785"></a>11785                                <span class="stringliteral">&quot;(inverted range)&quot;</span>));
<a name="l11786"></a>11786                   <span class="keywordflow">return</span>;
<a name="l11787"></a>11787                 }
<a name="l11788"></a>11788 
<a name="l11789"></a>11789               <span class="comment">/* Empty range entries have no effect.  */</span>
<a name="l11790"></a>11790               <span class="keywordflow">if</span> (start == end)
<a name="l11791"></a>11791                 <span class="keywordflow">continue</span>;
<a name="l11792"></a>11792 
<a name="l11793"></a>11793               start += base + baseaddr;
<a name="l11794"></a>11794               end += base + baseaddr;
<a name="l11795"></a>11795 
<a name="l11796"></a>11796               <span class="comment">/* A not-uncommon case of bad debug info.</span>
<a name="l11797"></a>11797 <span class="comment">                 Don&#39;t pollute the addrmap with bad data.  */</span>
<a name="l11798"></a>11798               <span class="keywordflow">if</span> (start == 0 &amp;&amp; !dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ab6b03c3a65fa04f04741158e8aebc895">has_section_at_zero</a>)
<a name="l11799"></a>11799                 {
<a name="l11800"></a>11800                   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l11801"></a>11801                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;.debug_ranges entry has start address of zero&quot;</span>
<a name="l11802"></a>11802                                <span class="stringliteral">&quot; [in module %s]&quot;</span>), <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l11803"></a>11803                   <span class="keywordflow">continue</span>;
<a name="l11804"></a>11804                 }
<a name="l11805"></a>11805 
<a name="l11806"></a>11806               <a class="code" href="buildsym_8c.html#af741de313ae265df7edffbfff0a80cf7">record_block_range</a> (block, start, end - 1);
<a name="l11807"></a>11807             }
<a name="l11808"></a>11808         }
<a name="l11809"></a>11809     }
<a name="l11810"></a>11810 }
<a name="l11811"></a>11811 
<a name="l11812"></a>11812 <span class="comment">/* Check whether the producer field indicates either of GCC &lt; 4.6, or the</span>
<a name="l11813"></a>11813 <span class="comment">   Intel C/C++ compiler, and cache the result in CU.  */</span>
<a name="l11814"></a>11814 
<a name="l11815"></a>11815 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11816"></a><a class="code" href="dwarf2read_8c.html#a41cd805d939c553f1679638639f7102b">11816</a> <a class="code" href="dwarf2read_8c.html#a41cd805d939c553f1679638639f7102b">check_producer</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l11817"></a>11817 {
<a name="l11818"></a>11818   <span class="keyword">const</span> <span class="keywordtype">char</span> *cs;
<a name="l11819"></a>11819   <span class="keywordtype">int</span> major, minor, release;
<a name="l11820"></a>11820 
<a name="l11821"></a>11821   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a> == NULL)
<a name="l11822"></a>11822     {
<a name="l11823"></a>11823       <span class="comment">/* For unknown compilers expect their behavior is DWARF version</span>
<a name="l11824"></a>11824 <span class="comment">         compliant.</span>
<a name="l11825"></a>11825 <span class="comment"></span>
<a name="l11826"></a>11826 <span class="comment">         GCC started to support .debug_types sections by -gdwarf-4 since</span>
<a name="l11827"></a>11827 <span class="comment">         gcc-4.5.x.  As the .debug_types sections are missing DW_AT_producer</span>
<a name="l11828"></a>11828 <span class="comment">         for their space efficiency GDB cannot workaround gcc-4.5.x -gdwarf-4</span>
<a name="l11829"></a>11829 <span class="comment">         combination.  gcc-4.5.x -gdwarf-4 binaries have DW_AT_accessibility</span>
<a name="l11830"></a>11830 <span class="comment">         interpreted incorrectly by GDB now - GCC PR debug/48229.  */</span>
<a name="l11831"></a>11831     }
<a name="l11832"></a>11832   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>, <span class="stringliteral">&quot;GNU &quot;</span>, strlen (<span class="stringliteral">&quot;GNU &quot;</span>)) == 0)
<a name="l11833"></a>11833     {
<a name="l11834"></a>11834       <span class="comment">/* Skip any identifier after &quot;GNU &quot; - such as &quot;C++&quot; or &quot;Java&quot;.  */</span>
<a name="l11835"></a>11835 
<a name="l11836"></a>11836       cs = &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>[strlen (<span class="stringliteral">&quot;GNU &quot;</span>)];
<a name="l11837"></a>11837       <span class="keywordflow">while</span> (*cs &amp;&amp; !isdigit (*cs))
<a name="l11838"></a>11838         cs++;
<a name="l11839"></a>11839       <span class="keywordflow">if</span> (sscanf (cs, <span class="stringliteral">&quot;%d.%d.%d&quot;</span>, &amp;major, &amp;minor, &amp;release) != 3)
<a name="l11840"></a>11840         {
<a name="l11841"></a>11841           <span class="comment">/* Not recognized as GCC.  */</span>
<a name="l11842"></a>11842         }
<a name="l11843"></a>11843       <span class="keywordflow">else</span>
<a name="l11844"></a>11844         {
<a name="l11845"></a>11845           cu-&gt;producer_is_gxx_lt_4_6 = major &lt; 4 || (major == 4 &amp;&amp; minor &lt; 6);
<a name="l11846"></a>11846           cu-&gt;producer_is_gcc_lt_4_3 = major &lt; 4 || (major == 4 &amp;&amp; minor &lt; 3);
<a name="l11847"></a>11847         }
<a name="l11848"></a>11848     }
<a name="l11849"></a>11849   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>, <span class="stringliteral">&quot;Intel(R) C&quot;</span>, strlen (<span class="stringliteral">&quot;Intel(R) C&quot;</span>)) == 0)
<a name="l11850"></a>11850     cu-&gt;producer_is_icc = 1;
<a name="l11851"></a>11851   <span class="keywordflow">else</span>
<a name="l11852"></a>11852     {
<a name="l11853"></a>11853       <span class="comment">/* For other non-GCC compilers, expect their behavior is DWARF version</span>
<a name="l11854"></a>11854 <span class="comment">         compliant.  */</span>
<a name="l11855"></a>11855     }
<a name="l11856"></a>11856 
<a name="l11857"></a>11857   cu-&gt;checked_producer = 1;
<a name="l11858"></a>11858 }
<a name="l11859"></a>11859 
<a name="l11860"></a>11860 <span class="comment">/* Check for GCC PR debug/45124 fix which is not present in any G++ version up</span>
<a name="l11861"></a>11861 <span class="comment">   to 4.5.any while it is present already in G++ 4.6.0 - the PR has been fixed</span>
<a name="l11862"></a>11862 <span class="comment">   during 4.6.0 experimental.  */</span>
<a name="l11863"></a>11863 
<a name="l11864"></a>11864 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l11865"></a><a class="code" href="dwarf2read_8c.html#aec4c30ddd1859273c792893367bf3bfa">11865</a> <a class="code" href="dwarf2read_8c.html#aec4c30ddd1859273c792893367bf3bfa">producer_is_gxx_lt_4_6</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l11866"></a>11866 {
<a name="l11867"></a>11867   <span class="keywordflow">if</span> (!cu-&gt;checked_producer)
<a name="l11868"></a>11868     <a class="code" href="dwarf2read_8c.html#a41cd805d939c553f1679638639f7102b">check_producer</a> (cu);
<a name="l11869"></a>11869 
<a name="l11870"></a>11870   <span class="keywordflow">return</span> cu-&gt;producer_is_gxx_lt_4_6;
<a name="l11871"></a>11871 }
<a name="l11872"></a>11872 
<a name="l11873"></a>11873 <span class="comment">/* Return the default accessibility type if it is not overriden by</span>
<a name="l11874"></a>11874 <span class="comment">   DW_AT_accessibility.  */</span>
<a name="l11875"></a>11875 
<a name="l11876"></a>11876 <span class="keyword">static</span> <span class="keyword">enum</span> dwarf_access_attribute
<a name="l11877"></a><a class="code" href="dwarf2read_8c.html#a9add1be50dbaa1a705935188b5e8edc7">11877</a> <a class="code" href="dwarf2read_8c.html#a9add1be50dbaa1a705935188b5e8edc7">dwarf2_default_access_attribute</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l11878"></a>11878 {
<a name="l11879"></a>11879   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a68d6c482c646af0266771ad56b73748d">version</a> &lt; 3 || <a class="code" href="dwarf2read_8c.html#aec4c30ddd1859273c792893367bf3bfa">producer_is_gxx_lt_4_6</a> (cu))
<a name="l11880"></a>11880     {
<a name="l11881"></a>11881       <span class="comment">/* The default DWARF 2 accessibility for members is public, the default</span>
<a name="l11882"></a>11882 <span class="comment">         accessibility for inheritance is private.  */</span>
<a name="l11883"></a>11883 
<a name="l11884"></a>11884       <span class="keywordflow">if</span> (die-&gt;tag != DW_TAG_inheritance)
<a name="l11885"></a>11885         <span class="keywordflow">return</span> DW_ACCESS_public;
<a name="l11886"></a>11886       <span class="keywordflow">else</span>
<a name="l11887"></a>11887         <span class="keywordflow">return</span> DW_ACCESS_private;
<a name="l11888"></a>11888     }
<a name="l11889"></a>11889   <span class="keywordflow">else</span>
<a name="l11890"></a>11890     {
<a name="l11891"></a>11891       <span class="comment">/* DWARF 3+ defines the default accessibility a different way.  The same</span>
<a name="l11892"></a>11892 <span class="comment">         rules apply now for DW_TAG_inheritance as for the members and it only</span>
<a name="l11893"></a>11893 <span class="comment">         depends on the container kind.  */</span>
<a name="l11894"></a>11894 
<a name="l11895"></a>11895       <span class="keywordflow">if</span> (die-&gt;parent-&gt;tag == DW_TAG_class_type)
<a name="l11896"></a>11896         <span class="keywordflow">return</span> DW_ACCESS_private;
<a name="l11897"></a>11897       <span class="keywordflow">else</span>
<a name="l11898"></a>11898         <span class="keywordflow">return</span> DW_ACCESS_public;
<a name="l11899"></a>11899     }
<a name="l11900"></a>11900 }
<a name="l11901"></a>11901 
<a name="l11902"></a>11902 <span class="comment">/* Look for DW_AT_data_member_location.  Set *OFFSET to the byte</span>
<a name="l11903"></a>11903 <span class="comment">   offset.  If the attribute was not found return 0, otherwise return</span>
<a name="l11904"></a>11904 <span class="comment">   1.  If it was found but could not properly be handled, set *OFFSET</span>
<a name="l11905"></a>11905 <span class="comment">   to 0.  */</span>
<a name="l11906"></a>11906 
<a name="l11907"></a>11907 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l11908"></a><a class="code" href="dwarf2read_8c.html#acd7a170bf304b7b354b5b8b65e715a16">11908</a> <a class="code" href="dwarf2read_8c.html#acd7a170bf304b7b354b5b8b65e715a16">handle_data_member_location</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l11909"></a>11909                              <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *offset)
<a name="l11910"></a>11910 {
<a name="l11911"></a>11911   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l11912"></a>11912 
<a name="l11913"></a>11913   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_data_member_location, cu);
<a name="l11914"></a>11914   <span class="keywordflow">if</span> (attr != NULL)
<a name="l11915"></a>11915     {
<a name="l11916"></a>11916       *offset = 0;
<a name="l11917"></a>11917 
<a name="l11918"></a>11918       <span class="comment">/* Note that we do not check for a section offset first here.</span>
<a name="l11919"></a>11919 <span class="comment">         This is because DW_AT_data_member_location is new in DWARF 4,</span>
<a name="l11920"></a>11920 <span class="comment">         so if we see it, we can assume that a constant form is really</span>
<a name="l11921"></a>11921 <span class="comment">         a constant and not a section offset.  */</span>
<a name="l11922"></a>11922       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a450aaabe2810df0fc34c371aae960580">attr_form_is_constant</a> (attr))
<a name="l11923"></a>11923         *offset = <a class="code" href="dwarf2read_8c.html#a483ab0874bc41021a77b11c5e6d3b740">dwarf2_get_attr_constant_value</a> (attr, 0);
<a name="l11924"></a>11924       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#aa2b54436e7d13233cd6b866f562f637e">attr_form_is_section_offset</a> (attr))
<a name="l11925"></a>11925         <a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">dwarf2_complex_location_expr_complaint</a> ();
<a name="l11926"></a>11926       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (attr))
<a name="l11927"></a>11927         *offset = <a class="code" href="dwarf2read_8c.html#ab042fa76d14a2a97bb1b0d6f75e60d79">decode_locdesc</a> (<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr), cu);
<a name="l11928"></a>11928       <span class="keywordflow">else</span>
<a name="l11929"></a>11929         <a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">dwarf2_complex_location_expr_complaint</a> ();
<a name="l11930"></a>11930 
<a name="l11931"></a>11931       <span class="keywordflow">return</span> 1;
<a name="l11932"></a>11932     }
<a name="l11933"></a>11933 
<a name="l11934"></a>11934   <span class="keywordflow">return</span> 0;
<a name="l11935"></a>11935 }
<a name="l11936"></a>11936 
<a name="l11937"></a>11937 <span class="comment">/* Add an aggregate field to the field list.  */</span>
<a name="l11938"></a>11938 
<a name="l11939"></a>11939 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11940"></a><a class="code" href="dwarf2read_8c.html#a288fbd6a927a07b52e2047da8322d25e">11940</a> <a class="code" href="dwarf2read_8c.html#a288fbd6a927a07b52e2047da8322d25e">dwarf2_add_field</a> (<span class="keyword">struct</span> <a class="code" href="structfield__info.html">field_info</a> *fip, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l11941"></a>11941                   <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l11942"></a>11942 {
<a name="l11943"></a>11943   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l11944"></a>11944   <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l11945"></a>11945   <span class="keyword">struct </span>nextfield *new_field;
<a name="l11946"></a>11946   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l11947"></a>11947   <span class="keyword">struct </span>field *fp;
<a name="l11948"></a>11948   <span class="keyword">const</span> <span class="keywordtype">char</span> *fieldname = <span class="stringliteral">&quot;&quot;</span>;
<a name="l11949"></a>11949 
<a name="l11950"></a>11950   <span class="comment">/* Allocate a new field list entry and link it in.  */</span>
<a name="l11951"></a>11951   new_field = (<span class="keyword">struct </span>nextfield *) <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> nextfield));
<a name="l11952"></a>11952   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, new_field);
<a name="l11953"></a>11953   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (new_field, 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> nextfield));
<a name="l11954"></a>11954 
<a name="l11955"></a>11955   <span class="keywordflow">if</span> (die-&gt;tag == DW_TAG_inheritance)
<a name="l11956"></a>11956     {
<a name="l11957"></a>11957       new_field-&gt;next = fip-&gt;<a class="code" href="structfield__info.html#aacf7e4f83f9b1ef0b30c69ea61c67e14">baseclasses</a>;
<a name="l11958"></a>11958       fip-&gt;<a class="code" href="structfield__info.html#aacf7e4f83f9b1ef0b30c69ea61c67e14">baseclasses</a> = new_field;
<a name="l11959"></a>11959     }
<a name="l11960"></a>11960   <span class="keywordflow">else</span>
<a name="l11961"></a>11961     {
<a name="l11962"></a>11962       new_field-&gt;<a class="code" href="structfield__info_1_1nextfield.html#a1010bef865819b3dc9609941d15f3000">next</a> = fip-&gt;<a class="code" href="structfield__info.html#a2a3a9b900c54be57557e694dfd9281e2">fields</a>;
<a name="l11963"></a>11963       fip-&gt;<a class="code" href="structfield__info.html#a2a3a9b900c54be57557e694dfd9281e2">fields</a> = new_field;
<a name="l11964"></a>11964     }
<a name="l11965"></a>11965   fip-&gt;<a class="code" href="structfield__info.html#a09bd04c8bcdb22c9bc1ce43df30aac8d">nfields</a>++;
<a name="l11966"></a>11966 
<a name="l11967"></a>11967   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_accessibility, cu);
<a name="l11968"></a>11968   <span class="keywordflow">if</span> (attr)
<a name="l11969"></a>11969     new_field-&gt;accessibility = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l11970"></a>11970   <span class="keywordflow">else</span>
<a name="l11971"></a>11971     new_field-&gt;accessibility = <a class="code" href="dwarf2read_8c.html#a9add1be50dbaa1a705935188b5e8edc7">dwarf2_default_access_attribute</a> (die, cu);
<a name="l11972"></a>11972   <span class="keywordflow">if</span> (new_field-&gt;accessibility != DW_ACCESS_public)
<a name="l11973"></a>11973     fip-&gt;<a class="code" href="structfield__info.html#a5252d305726ae0aa5594e0b1e20b61fd">non_public_fields</a> = 1;
<a name="l11974"></a>11974 
<a name="l11975"></a>11975   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_virtuality, cu);
<a name="l11976"></a>11976   <span class="keywordflow">if</span> (attr)
<a name="l11977"></a>11977     new_field-&gt;virtuality = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l11978"></a>11978   <span class="keywordflow">else</span>
<a name="l11979"></a>11979     new_field-&gt;virtuality = DW_VIRTUALITY_none;
<a name="l11980"></a>11980 
<a name="l11981"></a>11981   fp = &amp;new_field-&gt;field;
<a name="l11982"></a>11982 
<a name="l11983"></a>11983   <span class="keywordflow">if</span> (die-&gt;tag == DW_TAG_member &amp;&amp; ! <a class="code" href="dwarf2read_8c.html#aa9ca23caab102417f39b86b7b2716588">die_is_declaration</a> (die, cu))
<a name="l11984"></a>11984     {
<a name="l11985"></a>11985       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l11986"></a>11986 
<a name="l11987"></a>11987       <span class="comment">/* Data member other than a C++ static data member.  */</span>
<a name="l11988"></a>11988 
<a name="l11989"></a>11989       <span class="comment">/* Get type of field.  */</span>
<a name="l11990"></a>11990       fp-&gt;type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l11991"></a>11991 
<a name="l11992"></a>11992       <a class="code" href="gdbtypes_8h.html#a3b785c6047f2bce21ac78987ab5a4b48">SET_FIELD_BITPOS</a> (*fp, 0);
<a name="l11993"></a>11993 
<a name="l11994"></a>11994       <span class="comment">/* Get bit size of field (zero if none).  */</span>
<a name="l11995"></a>11995       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_bit_size, cu);
<a name="l11996"></a>11996       <span class="keywordflow">if</span> (attr)
<a name="l11997"></a>11997         {
<a name="l11998"></a>11998           <a class="code" href="gdbtypes_8h.html#af6b82d1dbebd01aa271ea0273efb0958">FIELD_BITSIZE</a> (*fp) = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l11999"></a>11999         }
<a name="l12000"></a>12000       <span class="keywordflow">else</span>
<a name="l12001"></a>12001         {
<a name="l12002"></a>12002           <a class="code" href="gdbtypes_8h.html#af6b82d1dbebd01aa271ea0273efb0958">FIELD_BITSIZE</a> (*fp) = 0;
<a name="l12003"></a>12003         }
<a name="l12004"></a>12004 
<a name="l12005"></a>12005       <span class="comment">/* Get bit offset of field.  */</span>
<a name="l12006"></a>12006       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#acd7a170bf304b7b354b5b8b65e715a16">handle_data_member_location</a> (die, cu, &amp;offset))
<a name="l12007"></a>12007         <a class="code" href="gdbtypes_8h.html#a3b785c6047f2bce21ac78987ab5a4b48">SET_FIELD_BITPOS</a> (*fp, offset * <a class="code" href="dwarf2read_8c.html#aa777b588c12ad10add04077214f1c976">bits_per_byte</a>);
<a name="l12008"></a>12008       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_bit_offset, cu);
<a name="l12009"></a>12009       <span class="keywordflow">if</span> (attr)
<a name="l12010"></a>12010         {
<a name="l12011"></a>12011           <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#afb14c978ec22423f831b98d7ac768382">gdbarch_bits_big_endian</a> (gdbarch))
<a name="l12012"></a>12012             {
<a name="l12013"></a>12013               <span class="comment">/* For big endian bits, the DW_AT_bit_offset gives the</span>
<a name="l12014"></a>12014 <span class="comment">                 additional bit offset from the MSB of the containing</span>
<a name="l12015"></a>12015 <span class="comment">                 anonymous object to the MSB of the field.  We don&#39;t</span>
<a name="l12016"></a>12016 <span class="comment">                 have to do anything special since we don&#39;t need to</span>
<a name="l12017"></a>12017 <span class="comment">                 know the size of the anonymous object.  */</span>
<a name="l12018"></a>12018               <a class="code" href="gdbtypes_8h.html#a3b785c6047f2bce21ac78987ab5a4b48">SET_FIELD_BITPOS</a> (*fp, <a class="code" href="gdbtypes_8h.html#acd937b9429ab865041b5a88eb54e183c">FIELD_BITPOS</a> (*fp) + <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr));
<a name="l12019"></a>12019             }
<a name="l12020"></a>12020           <span class="keywordflow">else</span>
<a name="l12021"></a>12021             {
<a name="l12022"></a>12022               <span class="comment">/* For little endian bits, compute the bit offset to the</span>
<a name="l12023"></a>12023 <span class="comment">                 MSB of the anonymous object, subtract off the number of</span>
<a name="l12024"></a>12024 <span class="comment">                 bits from the MSB of the field to the MSB of the</span>
<a name="l12025"></a>12025 <span class="comment">                 object, and then subtract off the number of bits of</span>
<a name="l12026"></a>12026 <span class="comment">                 the field itself.  The result is the bit offset of</span>
<a name="l12027"></a>12027 <span class="comment">                 the LSB of the field.  */</span>
<a name="l12028"></a>12028               <span class="keywordtype">int</span> anonymous_size;
<a name="l12029"></a>12029               <span class="keywordtype">int</span> bit_offset = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l12030"></a>12030 
<a name="l12031"></a>12031               attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_byte_size, cu);
<a name="l12032"></a>12032               <span class="keywordflow">if</span> (attr)
<a name="l12033"></a>12033                 {
<a name="l12034"></a>12034                   <span class="comment">/* The size of the anonymous object containing</span>
<a name="l12035"></a>12035 <span class="comment">                     the bit field is explicit, so use the</span>
<a name="l12036"></a>12036 <span class="comment">                     indicated size (in bytes).  */</span>
<a name="l12037"></a>12037                   anonymous_size = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l12038"></a>12038                 }
<a name="l12039"></a>12039               <span class="keywordflow">else</span>
<a name="l12040"></a>12040                 {
<a name="l12041"></a>12041                   <span class="comment">/* The size of the anonymous object containing</span>
<a name="l12042"></a>12042 <span class="comment">                     the bit field must be inferred from the type</span>
<a name="l12043"></a>12043 <span class="comment">                     attribute of the data member containing the</span>
<a name="l12044"></a>12044 <span class="comment">                     bit field.  */</span>
<a name="l12045"></a>12045                   anonymous_size = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (fp-&gt;type);
<a name="l12046"></a>12046                 }
<a name="l12047"></a>12047               <a class="code" href="gdbtypes_8h.html#a3b785c6047f2bce21ac78987ab5a4b48">SET_FIELD_BITPOS</a> (*fp,
<a name="l12048"></a>12048                                 (<a class="code" href="gdbtypes_8h.html#acd937b9429ab865041b5a88eb54e183c">FIELD_BITPOS</a> (*fp)
<a name="l12049"></a>12049                                  + anonymous_size * bits_per_byte
<a name="l12050"></a>12050                                  - bit_offset - <a class="code" href="gdbtypes_8h.html#af6b82d1dbebd01aa271ea0273efb0958">FIELD_BITSIZE</a> (*fp)));
<a name="l12051"></a>12051             }
<a name="l12052"></a>12052         }
<a name="l12053"></a>12053 
<a name="l12054"></a>12054       <span class="comment">/* Get name of field.  */</span>
<a name="l12055"></a>12055       fieldname = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l12056"></a>12056       <span class="keywordflow">if</span> (fieldname == NULL)
<a name="l12057"></a>12057         fieldname = <span class="stringliteral">&quot;&quot;</span>;
<a name="l12058"></a>12058 
<a name="l12059"></a>12059       <span class="comment">/* The name is already allocated along with this objfile, so we don&#39;t</span>
<a name="l12060"></a>12060 <span class="comment">         need to duplicate it for the type.  */</span>
<a name="l12061"></a>12061       fp-&gt;name = fieldname;
<a name="l12062"></a>12062 
<a name="l12063"></a>12063       <span class="comment">/* Change accessibility for artificial fields (e.g. virtual table</span>
<a name="l12064"></a>12064 <span class="comment">         pointer or virtual base class pointer) to private.  */</span>
<a name="l12065"></a>12065       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_artificial, cu))
<a name="l12066"></a>12066         {
<a name="l12067"></a>12067           <a class="code" href="gdbtypes_8h.html#a5632e7a6760a5aa372c2393ea18c4975">FIELD_ARTIFICIAL</a> (*fp) = 1;
<a name="l12068"></a>12068           new_field-&gt;accessibility = DW_ACCESS_private;
<a name="l12069"></a>12069           fip-&gt;<a class="code" href="structfield__info.html#a5252d305726ae0aa5594e0b1e20b61fd">non_public_fields</a> = 1;
<a name="l12070"></a>12070         }
<a name="l12071"></a>12071     }
<a name="l12072"></a>12072   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (die-&gt;tag == DW_TAG_member || die-&gt;tag == DW_TAG_variable)
<a name="l12073"></a>12073     {
<a name="l12074"></a>12074       <span class="comment">/* C++ static member.  */</span>
<a name="l12075"></a>12075 
<a name="l12076"></a>12076       <span class="comment">/* NOTE: carlton/2002-11-05: It should be a DW_TAG_member that</span>
<a name="l12077"></a>12077 <span class="comment">         is a declaration, but all versions of G++ as of this writing</span>
<a name="l12078"></a>12078 <span class="comment">         (so through at least 3.2.1) incorrectly generate</span>
<a name="l12079"></a>12079 <span class="comment">         DW_TAG_variable tags.  */</span>
<a name="l12080"></a>12080 
<a name="l12081"></a>12081       <span class="keyword">const</span> <span class="keywordtype">char</span> *physname;
<a name="l12082"></a>12082 
<a name="l12083"></a>12083       <span class="comment">/* Get name of field.  */</span>
<a name="l12084"></a>12084       fieldname = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l12085"></a>12085       <span class="keywordflow">if</span> (fieldname == NULL)
<a name="l12086"></a>12086         <span class="keywordflow">return</span>;
<a name="l12087"></a>12087 
<a name="l12088"></a>12088       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_const_value, cu);
<a name="l12089"></a>12089       <span class="keywordflow">if</span> (attr
<a name="l12090"></a>12090           <span class="comment">/* Only create a symbol if this is an external value.</span>
<a name="l12091"></a>12091 <span class="comment">             new_symbol checks this and puts the value in the global symbol</span>
<a name="l12092"></a>12092 <span class="comment">             table, which we want.  If it is not external, new_symbol</span>
<a name="l12093"></a>12093 <span class="comment">             will try to put the value in cu-&gt;list_in_scope which is wrong.  */</span>
<a name="l12094"></a>12094           &amp;&amp; <a class="code" href="dwarf2read_8c.html#ae71fe9211c7daaccc4d43abbe838c8dc">dwarf2_flag_true_p</a> (die, DW_AT_external, cu))
<a name="l12095"></a>12095         {
<a name="l12096"></a>12096           <span class="comment">/* A static const member, not much different than an enum as far as</span>
<a name="l12097"></a>12097 <span class="comment">             we&#39;re concerned, except that we can support more types.  */</span>
<a name="l12098"></a>12098           <a class="code" href="dwarf2read_8c.html#a4b79d225399dba2c4a3397a858440dd4">new_symbol</a> (die, NULL, cu);
<a name="l12099"></a>12099         }
<a name="l12100"></a>12100 
<a name="l12101"></a>12101       <span class="comment">/* Get physical name.  */</span>
<a name="l12102"></a>12102       physname = <a class="code" href="dwarf2read_8c.html#a94813a9fc414b7ba920cdcee76b34d36">dwarf2_physname</a> (fieldname, die, cu);
<a name="l12103"></a>12103 
<a name="l12104"></a>12104       <span class="comment">/* The name is already allocated along with this objfile, so we don&#39;t</span>
<a name="l12105"></a>12105 <span class="comment">         need to duplicate it for the type.  */</span>
<a name="l12106"></a>12106       <a class="code" href="gdbtypes_8h.html#a07a65b002f15d09d0b4ddec1f778e8b3">SET_FIELD_PHYSNAME</a> (*fp, physname ? physname : <span class="stringliteral">&quot;&quot;</span>);
<a name="l12107"></a>12107       <a class="code" href="gdbtypes_8h.html#ae88bb60de05efe94bc1cbafee6fa3985">FIELD_TYPE</a> (*fp) = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l12108"></a>12108       <a class="code" href="gdbtypes_8h.html#aeaff087d79e6871070384c25cf886da7">FIELD_NAME</a> (*fp) = fieldname;
<a name="l12109"></a>12109     }
<a name="l12110"></a>12110   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (die-&gt;tag == DW_TAG_inheritance)
<a name="l12111"></a>12111     {
<a name="l12112"></a>12112       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l12113"></a>12113 
<a name="l12114"></a>12114       <span class="comment">/* C++ base class field.  */</span>
<a name="l12115"></a>12115       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#acd7a170bf304b7b354b5b8b65e715a16">handle_data_member_location</a> (die, cu, &amp;offset))
<a name="l12116"></a>12116         <a class="code" href="gdbtypes_8h.html#a3b785c6047f2bce21ac78987ab5a4b48">SET_FIELD_BITPOS</a> (*fp, offset * <a class="code" href="dwarf2read_8c.html#aa777b588c12ad10add04077214f1c976">bits_per_byte</a>);
<a name="l12117"></a>12117       <a class="code" href="gdbtypes_8h.html#af6b82d1dbebd01aa271ea0273efb0958">FIELD_BITSIZE</a> (*fp) = 0;
<a name="l12118"></a>12118       <a class="code" href="gdbtypes_8h.html#ae88bb60de05efe94bc1cbafee6fa3985">FIELD_TYPE</a> (*fp) = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l12119"></a>12119       <a class="code" href="gdbtypes_8h.html#aeaff087d79e6871070384c25cf886da7">FIELD_NAME</a> (*fp) = <a class="code" href="gdbtypes_8c.html#a1bce8398d8a46f3d37bfc7e618ab9e9d">type_name_no_tag</a> (fp-&gt;type);
<a name="l12120"></a>12120       fip-&gt;<a class="code" href="structfield__info.html#a3e885cc79f0f6ddc667f29da409bdf39">nbaseclasses</a>++;
<a name="l12121"></a>12121     }
<a name="l12122"></a>12122 }
<a name="l12123"></a>12123 
<a name="l12124"></a>12124 <span class="comment">/* Add a typedef defined in the scope of the FIP&#39;s class.  */</span>
<a name="l12125"></a>12125 
<a name="l12126"></a>12126 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12127"></a><a class="code" href="dwarf2read_8c.html#a6df3d7a72109489d1d00c8c8c7d37c87">12127</a> <a class="code" href="dwarf2read_8c.html#a6df3d7a72109489d1d00c8c8c7d37c87">dwarf2_add_typedef</a> (<span class="keyword">struct</span> <a class="code" href="structfield__info.html">field_info</a> *fip, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l12128"></a>12128                     <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l12129"></a>12129 {
<a name="l12130"></a>12130   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l12131"></a>12131   <span class="keyword">struct </span>typedef_field_list *new_field;
<a name="l12132"></a>12132   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l12133"></a>12133   <span class="keyword">struct </span>typedef_field *fp;
<a name="l12134"></a>12134   <span class="keywordtype">char</span> *fieldname = <span class="stringliteral">&quot;&quot;</span>;
<a name="l12135"></a>12135 
<a name="l12136"></a>12136   <span class="comment">/* Allocate a new field list entry and link it in.  */</span>
<a name="l12137"></a>12137   new_field = <a class="code" href="common-utils_8c.html#ad7ead2fc5daad78a7f124e173863b16e">xzalloc</a> (<span class="keyword">sizeof</span> (*new_field));
<a name="l12138"></a>12138   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, new_field);
<a name="l12139"></a>12139 
<a name="l12140"></a>12140   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (die-&gt;tag == DW_TAG_typedef);
<a name="l12141"></a>12141 
<a name="l12142"></a>12142   fp = &amp;new_field-&gt;field;
<a name="l12143"></a>12143 
<a name="l12144"></a>12144   <span class="comment">/* Get name of field.  */</span>
<a name="l12145"></a>12145   fp-&gt;name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l12146"></a>12146   <span class="keywordflow">if</span> (fp-&gt;name == NULL)
<a name="l12147"></a>12147     <span class="keywordflow">return</span>;
<a name="l12148"></a>12148 
<a name="l12149"></a>12149   fp-&gt;type = <a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (die, cu);
<a name="l12150"></a>12150 
<a name="l12151"></a>12151   new_field-&gt;next = fip-&gt;<a class="code" href="structfield__info.html#a1861c9d86ad164a461664702e67c90d3">typedef_field_list</a>;
<a name="l12152"></a>12152   fip-&gt;<a class="code" href="structfield__info.html#a1861c9d86ad164a461664702e67c90d3">typedef_field_list</a> = new_field;
<a name="l12153"></a>12153   fip-&gt;<a class="code" href="structfield__info.html#a60696c993efeb4eed00ec2ac741931f2">typedef_field_list_count</a>++;
<a name="l12154"></a>12154 }
<a name="l12155"></a>12155 
<a name="l12156"></a>12156 <span class="comment">/* Create the vector of fields, and attach it to the type.  */</span>
<a name="l12157"></a>12157 
<a name="l12158"></a>12158 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12159"></a><a class="code" href="dwarf2read_8c.html#a9c6533d3437b203af697f7b478990784">12159</a> <a class="code" href="dwarf2read_8c.html#a9c6533d3437b203af697f7b478990784">dwarf2_attach_fields_to_type</a> (<span class="keyword">struct</span> <a class="code" href="structfield__info.html">field_info</a> *fip, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>,
<a name="l12160"></a>12160                               <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l12161"></a>12161 {
<a name="l12162"></a>12162   <span class="keywordtype">int</span> nfields = fip-&gt;<a class="code" href="structfield__info.html#a09bd04c8bcdb22c9bc1ce43df30aac8d">nfields</a>;
<a name="l12163"></a>12163 
<a name="l12164"></a>12164   <span class="comment">/* Record the field count, allocate space for the array of fields,</span>
<a name="l12165"></a>12165 <span class="comment">     and create blank accessibility bitfields if necessary.  */</span>
<a name="l12166"></a>12166   <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) = nfields;
<a name="l12167"></a>12167   <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (type) = (<span class="keyword">struct </span>field *)
<a name="l12168"></a>12168     <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (type, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> field) * nfields);
<a name="l12169"></a>12169   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (<a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (type), 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> field) * nfields);
<a name="l12170"></a>12170 
<a name="l12171"></a>12171   <span class="keywordflow">if</span> (fip-&gt;<a class="code" href="structfield__info.html#a5252d305726ae0aa5594e0b1e20b61fd">non_public_fields</a> &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l12172"></a>12172     {
<a name="l12173"></a>12173       <a class="code" href="gdbtypes_8h.html#a39116f69533c29b08fc5504b4d6986c0">ALLOCATE_CPLUS_STRUCT_TYPE</a> (type);
<a name="l12174"></a>12174 
<a name="l12175"></a>12175       <a class="code" href="gdbtypes_8h.html#a3ddf1eec48821311d6e1284d2a399dd7">TYPE_FIELD_PRIVATE_BITS</a> (type) =
<a name="l12176"></a>12176         (<a class="code" href="gdbtypes_8h.html#a4a576bae886fea0085ee73676f852bb8">B_TYPE</a> *) <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (type, <a class="code" href="gdbtypes_8h.html#a35237d59cbade1ff0de8adb7f45d8d18">B_BYTES</a> (nfields));
<a name="l12177"></a>12177       <a class="code" href="gdbtypes_8h.html#a4a5774aee98a1f89f90d9dd1d800bca1">B_CLRALL</a> (<a class="code" href="gdbtypes_8h.html#a3ddf1eec48821311d6e1284d2a399dd7">TYPE_FIELD_PRIVATE_BITS</a> (type), nfields);
<a name="l12178"></a>12178 
<a name="l12179"></a>12179       <a class="code" href="gdbtypes_8h.html#ad4b9af0bc40d948a0c89eccb1f10094d">TYPE_FIELD_PROTECTED_BITS</a> (type) =
<a name="l12180"></a>12180         (<a class="code" href="gdbtypes_8h.html#a4a576bae886fea0085ee73676f852bb8">B_TYPE</a> *) <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (type, <a class="code" href="gdbtypes_8h.html#a35237d59cbade1ff0de8adb7f45d8d18">B_BYTES</a> (nfields));
<a name="l12181"></a>12181       <a class="code" href="gdbtypes_8h.html#a4a5774aee98a1f89f90d9dd1d800bca1">B_CLRALL</a> (<a class="code" href="gdbtypes_8h.html#ad4b9af0bc40d948a0c89eccb1f10094d">TYPE_FIELD_PROTECTED_BITS</a> (type), nfields);
<a name="l12182"></a>12182 
<a name="l12183"></a>12183       <a class="code" href="gdbtypes_8h.html#aecf17b6fd9577f479e5d9e9aad7b0006">TYPE_FIELD_IGNORE_BITS</a> (type) =
<a name="l12184"></a>12184         (<a class="code" href="gdbtypes_8h.html#a4a576bae886fea0085ee73676f852bb8">B_TYPE</a> *) <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (type, <a class="code" href="gdbtypes_8h.html#a35237d59cbade1ff0de8adb7f45d8d18">B_BYTES</a> (nfields));
<a name="l12185"></a>12185       <a class="code" href="gdbtypes_8h.html#a4a5774aee98a1f89f90d9dd1d800bca1">B_CLRALL</a> (<a class="code" href="gdbtypes_8h.html#aecf17b6fd9577f479e5d9e9aad7b0006">TYPE_FIELD_IGNORE_BITS</a> (type), nfields);
<a name="l12186"></a>12186     }
<a name="l12187"></a>12187 
<a name="l12188"></a>12188   <span class="comment">/* If the type has baseclasses, allocate and clear a bit vector for</span>
<a name="l12189"></a>12189 <span class="comment">     TYPE_FIELD_VIRTUAL_BITS.  */</span>
<a name="l12190"></a>12190   <span class="keywordflow">if</span> (fip-&gt;<a class="code" href="structfield__info.html#a3e885cc79f0f6ddc667f29da409bdf39">nbaseclasses</a> &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l12191"></a>12191     {
<a name="l12192"></a>12192       <span class="keywordtype">int</span> num_bytes = <a class="code" href="gdbtypes_8h.html#a35237d59cbade1ff0de8adb7f45d8d18">B_BYTES</a> (fip-&gt;<a class="code" href="structfield__info.html#a3e885cc79f0f6ddc667f29da409bdf39">nbaseclasses</a>);
<a name="l12193"></a>12193       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pointer;
<a name="l12194"></a>12194 
<a name="l12195"></a>12195       <a class="code" href="gdbtypes_8h.html#a39116f69533c29b08fc5504b4d6986c0">ALLOCATE_CPLUS_STRUCT_TYPE</a> (type);
<a name="l12196"></a>12196       pointer = <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (type, num_bytes);
<a name="l12197"></a>12197       <a class="code" href="gdbtypes_8h.html#a37857baeb6b538bd7591df423cfa2f66">TYPE_FIELD_VIRTUAL_BITS</a> (type) = pointer;
<a name="l12198"></a>12198       <a class="code" href="gdbtypes_8h.html#a4a5774aee98a1f89f90d9dd1d800bca1">B_CLRALL</a> (<a class="code" href="gdbtypes_8h.html#a37857baeb6b538bd7591df423cfa2f66">TYPE_FIELD_VIRTUAL_BITS</a> (type), fip-&gt;<a class="code" href="structfield__info.html#a3e885cc79f0f6ddc667f29da409bdf39">nbaseclasses</a>);
<a name="l12199"></a>12199       <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (type) = fip-&gt;<a class="code" href="structfield__info.html#a3e885cc79f0f6ddc667f29da409bdf39">nbaseclasses</a>;
<a name="l12200"></a>12200     }
<a name="l12201"></a>12201 
<a name="l12202"></a>12202   <span class="comment">/* Copy the saved-up fields into the field vector.  Start from the head of</span>
<a name="l12203"></a>12203 <span class="comment">     the list, adding to the tail of the field array, so that they end up in</span>
<a name="l12204"></a>12204 <span class="comment">     the same order in the array in which they were added to the list.  */</span>
<a name="l12205"></a>12205   <span class="keywordflow">while</span> (nfields-- &gt; 0)
<a name="l12206"></a>12206     {
<a name="l12207"></a>12207       <span class="keyword">struct </span>nextfield *fieldp;
<a name="l12208"></a>12208 
<a name="l12209"></a>12209       <span class="keywordflow">if</span> (fip-&gt;<a class="code" href="structfield__info.html#a2a3a9b900c54be57557e694dfd9281e2">fields</a>)
<a name="l12210"></a>12210         {
<a name="l12211"></a>12211           fieldp = fip-&gt;<a class="code" href="structfield__info.html#a2a3a9b900c54be57557e694dfd9281e2">fields</a>;
<a name="l12212"></a>12212           fip-&gt;<a class="code" href="structfield__info.html#a2a3a9b900c54be57557e694dfd9281e2">fields</a> = fieldp-&gt;<a class="code" href="structfield__info_1_1nextfield.html#a1010bef865819b3dc9609941d15f3000">next</a>;
<a name="l12213"></a>12213         }
<a name="l12214"></a>12214       <span class="keywordflow">else</span>
<a name="l12215"></a>12215         {
<a name="l12216"></a>12216           fieldp = fip-&gt;<a class="code" href="structfield__info.html#aacf7e4f83f9b1ef0b30c69ea61c67e14">baseclasses</a>;
<a name="l12217"></a>12217           fip-&gt;<a class="code" href="structfield__info.html#aacf7e4f83f9b1ef0b30c69ea61c67e14">baseclasses</a> = fieldp-&gt;<a class="code" href="structfield__info_1_1nextfield.html#a1010bef865819b3dc9609941d15f3000">next</a>;
<a name="l12218"></a>12218         }
<a name="l12219"></a>12219 
<a name="l12220"></a>12220       <a class="code" href="gdbtypes_8h.html#a8beaef20f443a0d98c7b445bbcfcf031">TYPE_FIELD</a> (type, nfields) = fieldp-&gt;field;
<a name="l12221"></a>12221       <span class="keywordflow">switch</span> (fieldp-&gt;accessibility)
<a name="l12222"></a>12222         {
<a name="l12223"></a>12223         <span class="keywordflow">case</span> DW_ACCESS_private:
<a name="l12224"></a>12224           <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l12225"></a>12225             <a class="code" href="gdbtypes_8h.html#ae049a27d3991cb2c41905234fa551b3e">SET_TYPE_FIELD_PRIVATE</a> (type, nfields);
<a name="l12226"></a>12226           <span class="keywordflow">break</span>;
<a name="l12227"></a>12227 
<a name="l12228"></a>12228         <span class="keywordflow">case</span> DW_ACCESS_protected:
<a name="l12229"></a>12229           <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l12230"></a>12230             <a class="code" href="gdbtypes_8h.html#a46c997f1679b1e86240a034ab3e56f0a">SET_TYPE_FIELD_PROTECTED</a> (type, nfields);
<a name="l12231"></a>12231           <span class="keywordflow">break</span>;
<a name="l12232"></a>12232 
<a name="l12233"></a>12233         <span class="keywordflow">case</span> DW_ACCESS_public:
<a name="l12234"></a>12234           <span class="keywordflow">break</span>;
<a name="l12235"></a>12235 
<a name="l12236"></a>12236         <span class="keywordflow">default</span>:
<a name="l12237"></a>12237           <span class="comment">/* Unknown accessibility.  Complain and treat it as public.  */</span>
<a name="l12238"></a>12238           {
<a name="l12239"></a>12239             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unsupported accessibility %d&quot;</span>),
<a name="l12240"></a>12240                        fieldp-&gt;accessibility);
<a name="l12241"></a>12241           }
<a name="l12242"></a>12242           <span class="keywordflow">break</span>;
<a name="l12243"></a>12243         }
<a name="l12244"></a>12244       <span class="keywordflow">if</span> (nfields &lt; fip-&gt;nbaseclasses)
<a name="l12245"></a>12245         {
<a name="l12246"></a>12246           <span class="keywordflow">switch</span> (fieldp-&gt;virtuality)
<a name="l12247"></a>12247             {
<a name="l12248"></a>12248             <span class="keywordflow">case</span> DW_VIRTUALITY_virtual:
<a name="l12249"></a>12249             <span class="keywordflow">case</span> DW_VIRTUALITY_pure_virtual:
<a name="l12250"></a>12250               <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l12251"></a>12251                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unexpected virtuality in component of Ada type&quot;</span>));
<a name="l12252"></a>12252               <a class="code" href="gdbtypes_8h.html#aec7868fff6efc6c214eb2b4e2443d167">SET_TYPE_FIELD_VIRTUAL</a> (type, nfields);
<a name="l12253"></a>12253               <span class="keywordflow">break</span>;
<a name="l12254"></a>12254             }
<a name="l12255"></a>12255         }
<a name="l12256"></a>12256     }
<a name="l12257"></a>12257 }
<a name="l12258"></a>12258 
<a name="l12259"></a>12259 <span class="comment">/* Return true if this member function is a constructor, false</span>
<a name="l12260"></a>12260 <span class="comment">   otherwise.  */</span>
<a name="l12261"></a>12261 
<a name="l12262"></a>12262 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l12263"></a><a class="code" href="dwarf2read_8c.html#ad32c712cfcd1ea300dddbd6f88265c5f">12263</a> <a class="code" href="dwarf2read_8c.html#ad32c712cfcd1ea300dddbd6f88265c5f">dwarf2_is_constructor</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l12264"></a>12264 {
<a name="l12265"></a>12265   <span class="keyword">const</span> <span class="keywordtype">char</span> *fieldname;
<a name="l12266"></a>12266   <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">typename</span>;
<a name="l12267"></a>12267   <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l12268"></a>12268 
<a name="l12269"></a>12269   <span class="keywordflow">if</span> (die-&gt;parent == NULL)
<a name="l12270"></a>12270     <span class="keywordflow">return</span> 0;
<a name="l12271"></a>12271 
<a name="l12272"></a>12272   <span class="keywordflow">if</span> (die-&gt;parent-&gt;tag != DW_TAG_structure_type
<a name="l12273"></a>12273       &amp;&amp; die-&gt;parent-&gt;tag != DW_TAG_union_type
<a name="l12274"></a>12274       &amp;&amp; die-&gt;parent-&gt;tag != DW_TAG_class_type)
<a name="l12275"></a>12275     <span class="keywordflow">return</span> 0;
<a name="l12276"></a>12276 
<a name="l12277"></a>12277   fieldname = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l12278"></a>12278   <span class="keyword">typename</span> = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die-&gt;parent, cu);
<a name="l12279"></a>12279   <span class="keywordflow">if</span> (fieldname == NULL || <span class="keyword">typename</span> == NULL)
<a name="l12280"></a>12280     <span class="keywordflow">return</span> 0;
<a name="l12281"></a>12281 
<a name="l12282"></a>12282   len = strlen (fieldname);
<a name="l12283"></a>12283   <span class="keywordflow">return</span> (strncmp (fieldname, <span class="keyword">typename</span>, len) == 0
<a name="l12284"></a>12284           &amp;&amp; (<span class="keyword">typename</span>[len] == <span class="charliteral">&#39;\0&#39;</span> || <span class="keyword">typename</span>[len] == <span class="charliteral">&#39;&lt;&#39;</span>));
<a name="l12285"></a>12285 }
<a name="l12286"></a>12286 
<a name="l12287"></a>12287 <span class="comment">/* Add a member function to the proper fieldlist.  */</span>
<a name="l12288"></a>12288 
<a name="l12289"></a>12289 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12290"></a><a class="code" href="dwarf2read_8c.html#a1c6ac754036149e6eadc244c6c777c77">12290</a> <a class="code" href="dwarf2read_8c.html#a1c6ac754036149e6eadc244c6c777c77">dwarf2_add_member_fn</a> (<span class="keyword">struct</span> <a class="code" href="structfield__info.html">field_info</a> *fip, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l12291"></a>12291                       <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l12292"></a>12292 {
<a name="l12293"></a>12293   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l12294"></a>12294   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l12295"></a>12295   <span class="keyword">struct </span>fnfieldlist *flp;
<a name="l12296"></a>12296   <span class="keywordtype">int</span> i;
<a name="l12297"></a>12297   <span class="keyword">struct </span>fn_field *fnp;
<a name="l12298"></a>12298   <span class="keyword">const</span> <span class="keywordtype">char</span> *fieldname;
<a name="l12299"></a>12299   <span class="keyword">struct </span>nextfnfield *new_fnfield;
<a name="l12300"></a>12300   <span class="keyword">struct </span>type *this_type;
<a name="l12301"></a>12301   <span class="keyword">enum</span> dwarf_access_attribute <a class="code" href="varobj_8c.html#aae8d404a2a5336a8518d8bbe132a8caf">accessibility</a>;
<a name="l12302"></a>12302 
<a name="l12303"></a>12303   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l12304"></a>12304     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unexpected member function in Ada type&quot;</span>));
<a name="l12305"></a>12305 
<a name="l12306"></a>12306   <span class="comment">/* Get name of member function.  */</span>
<a name="l12307"></a>12307   fieldname = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l12308"></a>12308   <span class="keywordflow">if</span> (fieldname == NULL)
<a name="l12309"></a>12309     <span class="keywordflow">return</span>;
<a name="l12310"></a>12310 
<a name="l12311"></a>12311   <span class="comment">/* Look up member function name in fieldlist.  */</span>
<a name="l12312"></a>12312   <span class="keywordflow">for</span> (i = 0; i &lt; fip-&gt;<a class="code" href="structfield__info.html#a025391eca616fef2c461bb079f422e3e">nfnfields</a>; i++)
<a name="l12313"></a>12313     {
<a name="l12314"></a>12314       <span class="keywordflow">if</span> (strcmp (fip-&gt;<a class="code" href="structfield__info.html#ac4d52aeefe9db6d377a933868817d021">fnfieldlists</a>[i].<a class="code" href="structfield__info_1_1fnfieldlist.html#ae73cbcc4c33451761041ffc02017aba2">name</a>, fieldname) == 0)
<a name="l12315"></a>12315         <span class="keywordflow">break</span>;
<a name="l12316"></a>12316     }
<a name="l12317"></a>12317 
<a name="l12318"></a>12318   <span class="comment">/* Create new list element if necessary.  */</span>
<a name="l12319"></a>12319   <span class="keywordflow">if</span> (i &lt; fip-&gt;nfnfields)
<a name="l12320"></a>12320     flp = &amp;fip-&gt;<a class="code" href="structfield__info.html#ac4d52aeefe9db6d377a933868817d021">fnfieldlists</a>[i];
<a name="l12321"></a>12321   <span class="keywordflow">else</span>
<a name="l12322"></a>12322     {
<a name="l12323"></a>12323       <span class="keywordflow">if</span> ((fip-&gt;<a class="code" href="structfield__info.html#a025391eca616fef2c461bb079f422e3e">nfnfields</a> % <a class="code" href="dwarf2read_8c.html#aa40456d31b1edb968e39e63c9a8dd42b">DW_FIELD_ALLOC_CHUNK</a>) == 0)
<a name="l12324"></a>12324         {
<a name="l12325"></a>12325           fip-&gt;<a class="code" href="structfield__info.html#ac4d52aeefe9db6d377a933868817d021">fnfieldlists</a> = (<span class="keyword">struct </span>fnfieldlist *)
<a name="l12326"></a>12326             <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (fip-&gt;<a class="code" href="structfield__info.html#ac4d52aeefe9db6d377a933868817d021">fnfieldlists</a>,
<a name="l12327"></a>12327                       (fip-&gt;<a class="code" href="structfield__info.html#a025391eca616fef2c461bb079f422e3e">nfnfields</a> + <a class="code" href="dwarf2read_8c.html#aa40456d31b1edb968e39e63c9a8dd42b">DW_FIELD_ALLOC_CHUNK</a>)
<a name="l12328"></a>12328                       * <span class="keyword">sizeof</span> (<span class="keyword">struct </span>fnfieldlist));
<a name="l12329"></a>12329           <span class="keywordflow">if</span> (fip-&gt;<a class="code" href="structfield__info.html#a025391eca616fef2c461bb079f422e3e">nfnfields</a> == 0)
<a name="l12330"></a>12330             <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="utils_8c.html#a6d8c21606d3f67a431a7bfbb1f47d12e">free_current_contents</a>, &amp;fip-&gt;<a class="code" href="structfield__info.html#ac4d52aeefe9db6d377a933868817d021">fnfieldlists</a>);
<a name="l12331"></a>12331         }
<a name="l12332"></a>12332       flp = &amp;fip-&gt;<a class="code" href="structfield__info.html#ac4d52aeefe9db6d377a933868817d021">fnfieldlists</a>[fip-&gt;<a class="code" href="structfield__info.html#a025391eca616fef2c461bb079f422e3e">nfnfields</a>];
<a name="l12333"></a>12333       flp-&gt;<a class="code" href="structfield__info_1_1fnfieldlist.html#ae73cbcc4c33451761041ffc02017aba2">name</a> = fieldname;
<a name="l12334"></a>12334       flp-&gt;length = 0;
<a name="l12335"></a>12335       flp-&gt;head = NULL;
<a name="l12336"></a>12336       i = fip-&gt;<a class="code" href="structfield__info.html#a025391eca616fef2c461bb079f422e3e">nfnfields</a>++;
<a name="l12337"></a>12337     }
<a name="l12338"></a>12338 
<a name="l12339"></a>12339   <span class="comment">/* Create a new member function field and chain it to the field list</span>
<a name="l12340"></a>12340 <span class="comment">     entry.  */</span>
<a name="l12341"></a>12341   new_fnfield = (<span class="keyword">struct </span>nextfnfield *) <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> nextfnfield));
<a name="l12342"></a>12342   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, new_fnfield);
<a name="l12343"></a>12343   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (new_fnfield, 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> nextfnfield));
<a name="l12344"></a>12344   new_fnfield-&gt;next = flp-&gt;head;
<a name="l12345"></a>12345   flp-&gt;head = new_fnfield;
<a name="l12346"></a>12346   flp-&gt;length++;
<a name="l12347"></a>12347 
<a name="l12348"></a>12348   <span class="comment">/* Fill in the member function field info.  */</span>
<a name="l12349"></a>12349   fnp = &amp;new_fnfield-&gt;fnfield;
<a name="l12350"></a>12350 
<a name="l12351"></a>12351   <span class="comment">/* Delay processing of the physname until later.  */</span>
<a name="l12352"></a>12352   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a> || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>)
<a name="l12353"></a>12353     {
<a name="l12354"></a>12354       <a class="code" href="dwarf2read_8c.html#ae1004cc797a767d8f6130fab8038ddf7">add_to_method_list</a> (type, i, flp-&gt;<a class="code" href="structtype.html#a73598608f0395a10828a7f69cb843d70">length</a> - 1, fieldname,
<a name="l12355"></a>12355                           die, cu);
<a name="l12356"></a>12356     }
<a name="l12357"></a>12357   <span class="keywordflow">else</span>
<a name="l12358"></a>12358     {
<a name="l12359"></a>12359       <span class="keyword">const</span> <span class="keywordtype">char</span> *physname = <a class="code" href="dwarf2read_8c.html#a94813a9fc414b7ba920cdcee76b34d36">dwarf2_physname</a> (fieldname, die, cu);
<a name="l12360"></a>12360       fnp-&gt;physname = physname ? physname : <span class="stringliteral">&quot;&quot;</span>;
<a name="l12361"></a>12361     }
<a name="l12362"></a>12362 
<a name="l12363"></a>12363   fnp-&gt;type = <a class="code" href="gdbtypes_8c.html#a0929c0c96b083ea88998926b06d62d01">alloc_type</a> (objfile);
<a name="l12364"></a>12364   this_type = <a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (die, cu);
<a name="l12365"></a>12365   <span class="keywordflow">if</span> (this_type &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (this_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>)
<a name="l12366"></a>12366     {
<a name="l12367"></a>12367       <span class="keywordtype">int</span> nparams = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (this_type);
<a name="l12368"></a>12368 
<a name="l12369"></a>12369       <span class="comment">/* TYPE is the domain of this method, and THIS_TYPE is the type</span>
<a name="l12370"></a>12370 <span class="comment">           of the method itself (TYPE_CODE_METHOD).  */</span>
<a name="l12371"></a>12371       <a class="code" href="gdbtypes_8c.html#afae62bb1c2fdb5c6e6dafdbf7d5f935f">smash_to_method_type</a> (fnp-&gt;type, type,
<a name="l12372"></a>12372                             <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (this_type),
<a name="l12373"></a>12373                             <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (this_type),
<a name="l12374"></a>12374                             <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (this_type),
<a name="l12375"></a>12375                             <a class="code" href="gdbtypes_8h.html#ac64534be7706a7ed40f5b2de42df4371">TYPE_VARARGS</a> (this_type));
<a name="l12376"></a>12376 
<a name="l12377"></a>12377       <span class="comment">/* Handle static member functions.</span>
<a name="l12378"></a>12378 <span class="comment">         Dwarf2 has no clean way to discern C++ static and non-static</span>
<a name="l12379"></a>12379 <span class="comment">         member functions.  G++ helps GDB by marking the first</span>
<a name="l12380"></a>12380 <span class="comment">         parameter for non-static member functions (which is the this</span>
<a name="l12381"></a>12381 <span class="comment">         pointer) as artificial.  We obtain this information from</span>
<a name="l12382"></a>12382 <span class="comment">         read_subroutine_type via TYPE_FIELD_ARTIFICIAL.  */</span>
<a name="l12383"></a>12383       <span class="keywordflow">if</span> (nparams == 0 || <a class="code" href="gdbtypes_8h.html#aa2bb2f58f95f604830c665368481946d">TYPE_FIELD_ARTIFICIAL</a> (this_type, 0) == 0)
<a name="l12384"></a>12384         fnp-&gt;voffset = <a class="code" href="gdbtypes_8h.html#a85e928e0e3afd7fddf0557087312c663">VOFFSET_STATIC</a>;
<a name="l12385"></a>12385     }
<a name="l12386"></a>12386   <span class="keywordflow">else</span>
<a name="l12387"></a>12387     <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;member function type missing for &#39;%s&#39;&quot;</span>),
<a name="l12388"></a>12388                <a class="code" href="dwarf2read_8c.html#a01de8f373799ebb39da7b5758619ec4c">dwarf2_full_name</a> (fieldname, die, cu));
<a name="l12389"></a>12389 
<a name="l12390"></a>12390   <span class="comment">/* Get fcontext from DW_AT_containing_type if present.  */</span>
<a name="l12391"></a>12391   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_containing_type, cu) != NULL)
<a name="l12392"></a>12392     fnp-&gt;fcontext = <a class="code" href="dwarf2read_8c.html#a2ce2b8e439742408e8161e899d9cb67a">die_containing_type</a> (die, cu);
<a name="l12393"></a>12393 
<a name="l12394"></a>12394   <span class="comment">/* dwarf2 doesn&#39;t have stubbed physical names, so the setting of is_const and</span>
<a name="l12395"></a>12395 <span class="comment">     is_volatile is irrelevant, as it is needed by gdb_mangle_name only.  */</span>
<a name="l12396"></a>12396 
<a name="l12397"></a>12397   <span class="comment">/* Get accessibility.  */</span>
<a name="l12398"></a>12398   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_accessibility, cu);
<a name="l12399"></a>12399   <span class="keywordflow">if</span> (attr)
<a name="l12400"></a>12400     accessibility = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l12401"></a>12401   <span class="keywordflow">else</span>
<a name="l12402"></a>12402     accessibility = <a class="code" href="dwarf2read_8c.html#a9add1be50dbaa1a705935188b5e8edc7">dwarf2_default_access_attribute</a> (die, cu);
<a name="l12403"></a>12403   <span class="keywordflow">switch</span> (accessibility)
<a name="l12404"></a>12404     {
<a name="l12405"></a>12405     <span class="keywordflow">case</span> DW_ACCESS_private:
<a name="l12406"></a>12406       fnp-&gt;is_private = 1;
<a name="l12407"></a>12407       <span class="keywordflow">break</span>;
<a name="l12408"></a>12408     <span class="keywordflow">case</span> DW_ACCESS_protected:
<a name="l12409"></a>12409       fnp-&gt;is_protected = 1;
<a name="l12410"></a>12410       <span class="keywordflow">break</span>;
<a name="l12411"></a>12411     }
<a name="l12412"></a>12412 
<a name="l12413"></a>12413   <span class="comment">/* Check for artificial methods.  */</span>
<a name="l12414"></a>12414   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_artificial, cu);
<a name="l12415"></a>12415   <span class="keywordflow">if</span> (attr &amp;&amp; <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) != 0)
<a name="l12416"></a>12416     fnp-&gt;is_artificial = 1;
<a name="l12417"></a>12417 
<a name="l12418"></a>12418   fnp-&gt;is_constructor = <a class="code" href="dwarf2read_8c.html#ad32c712cfcd1ea300dddbd6f88265c5f">dwarf2_is_constructor</a> (die, cu);
<a name="l12419"></a>12419 
<a name="l12420"></a>12420   <span class="comment">/* Get index in virtual function table if it is a virtual member</span>
<a name="l12421"></a>12421 <span class="comment">     function.  For older versions of GCC, this is an offset in the</span>
<a name="l12422"></a>12422 <span class="comment">     appropriate virtual table, as specified by DW_AT_containing_type.</span>
<a name="l12423"></a>12423 <span class="comment">     For everyone else, it is an expression to be evaluated relative</span>
<a name="l12424"></a>12424 <span class="comment">     to the object address.  */</span>
<a name="l12425"></a>12425 
<a name="l12426"></a>12426   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_vtable_elem_location, cu);
<a name="l12427"></a>12427   <span class="keywordflow">if</span> (attr)
<a name="l12428"></a>12428     {
<a name="l12429"></a>12429       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (attr) &amp;&amp; <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;<a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> &gt; 0)
<a name="l12430"></a>12430         {
<a name="l12431"></a>12431           <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data[0] == DW_OP_constu)
<a name="l12432"></a>12432             {
<a name="l12433"></a>12433               <span class="comment">/* Old-style GCC.  */</span>
<a name="l12434"></a>12434               fnp-&gt;voffset = <a class="code" href="dwarf2read_8c.html#ab042fa76d14a2a97bb1b0d6f75e60d79">decode_locdesc</a> (<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr), cu) + 2;
<a name="l12435"></a>12435             }
<a name="l12436"></a>12436           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data[0] == DW_OP_deref
<a name="l12437"></a>12437                    || (<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;<a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> &gt; 1
<a name="l12438"></a>12438                        &amp;&amp; <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data[0] == DW_OP_deref_size
<a name="l12439"></a>12439                        &amp;&amp; <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data[1] == cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>))
<a name="l12440"></a>12440             {
<a name="l12441"></a>12441               <span class="keyword">struct </span><a class="code" href="structdwarf__block.html">dwarf_block</a> blk;
<a name="l12442"></a>12442               <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l12443"></a>12443 
<a name="l12444"></a>12444               offset = (<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data[0] == DW_OP_deref
<a name="l12445"></a>12445                         ? 1 : 2);
<a name="l12446"></a>12446               blk.<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a> = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;size - <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l12447"></a>12447               blk.<a class="code" href="structdwarf__block.html#af3a8e3eb0d783b103b0078662dbdc211">data</a> = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data + <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l12448"></a>12448               fnp-&gt;voffset = <a class="code" href="dwarf2read_8c.html#ab042fa76d14a2a97bb1b0d6f75e60d79">decode_locdesc</a> (<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr), cu);
<a name="l12449"></a>12449               <span class="keywordflow">if</span> ((fnp-&gt;voffset % cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>) != 0)
<a name="l12450"></a>12450                 <a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">dwarf2_complex_location_expr_complaint</a> ();
<a name="l12451"></a>12451               <span class="keywordflow">else</span>
<a name="l12452"></a>12452                 fnp-&gt;voffset /= cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l12453"></a>12453               fnp-&gt;voffset += 2;
<a name="l12454"></a>12454             }
<a name="l12455"></a>12455           <span class="keywordflow">else</span>
<a name="l12456"></a>12456             <a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">dwarf2_complex_location_expr_complaint</a> ();
<a name="l12457"></a>12457 
<a name="l12458"></a>12458           <span class="keywordflow">if</span> (!fnp-&gt;fcontext)
<a name="l12459"></a>12459             fnp-&gt;fcontext = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (this_type, 0));
<a name="l12460"></a>12460         }
<a name="l12461"></a>12461       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#aa2b54436e7d13233cd6b866f562f637e">attr_form_is_section_offset</a> (attr))
<a name="l12462"></a>12462         {
<a name="l12463"></a>12463           <a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">dwarf2_complex_location_expr_complaint</a> ();
<a name="l12464"></a>12464         }
<a name="l12465"></a>12465       <span class="keywordflow">else</span>
<a name="l12466"></a>12466         {
<a name="l12467"></a>12467           <a class="code" href="dwarf2read_8c.html#a0e9c948efe625df13875d3d70d218b65">dwarf2_invalid_attrib_class_complaint</a> (<span class="stringliteral">&quot;DW_AT_vtable_elem_location&quot;</span>,
<a name="l12468"></a>12468                                                  fieldname);
<a name="l12469"></a>12469         }
<a name="l12470"></a>12470     }
<a name="l12471"></a>12471   <span class="keywordflow">else</span>
<a name="l12472"></a>12472     {
<a name="l12473"></a>12473       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_virtuality, cu);
<a name="l12474"></a>12474       <span class="keywordflow">if</span> (attr &amp;&amp; <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr))
<a name="l12475"></a>12475         {
<a name="l12476"></a>12476           <span class="comment">/* GCC does this, as of 2008-08-25; PR debug/37237.  */</span>
<a name="l12477"></a>12477           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l12478"></a>12478                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Member function \&quot;%s\&quot; (offset %d) is virtual &quot;</span>
<a name="l12479"></a>12479                        <span class="stringliteral">&quot;but the vtable offset is not specified&quot;</span>),
<a name="l12480"></a>12480                      fieldname, die-&gt;offset.sect_off);
<a name="l12481"></a>12481           <a class="code" href="gdbtypes_8h.html#a39116f69533c29b08fc5504b4d6986c0">ALLOCATE_CPLUS_STRUCT_TYPE</a> (type);
<a name="l12482"></a>12482           <a class="code" href="gdbtypes_8h.html#a074995818010740f86e96d95a93e2cb1">TYPE_CPLUS_DYNAMIC</a> (type) = 1;
<a name="l12483"></a>12483         }
<a name="l12484"></a>12484     }
<a name="l12485"></a>12485 }
<a name="l12486"></a>12486 
<a name="l12487"></a>12487 <span class="comment">/* Create the vector of member function fields, and attach it to the type.  */</span>
<a name="l12488"></a>12488 
<a name="l12489"></a>12489 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12490"></a><a class="code" href="dwarf2read_8c.html#a014e4767f6c0ac385eb4c45327b7fe94">12490</a> <a class="code" href="dwarf2read_8c.html#a014e4767f6c0ac385eb4c45327b7fe94">dwarf2_attach_fn_fields_to_type</a> (<span class="keyword">struct</span> <a class="code" href="structfield__info.html">field_info</a> *fip, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>,
<a name="l12491"></a>12491                                  <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l12492"></a>12492 {
<a name="l12493"></a>12493   <span class="keyword">struct </span>fnfieldlist *flp;
<a name="l12494"></a>12494   <span class="keywordtype">int</span> i;
<a name="l12495"></a>12495 
<a name="l12496"></a>12496   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l12497"></a>12497     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unexpected member functions in Ada type&quot;</span>));
<a name="l12498"></a>12498 
<a name="l12499"></a>12499   <a class="code" href="gdbtypes_8h.html#a39116f69533c29b08fc5504b4d6986c0">ALLOCATE_CPLUS_STRUCT_TYPE</a> (type);
<a name="l12500"></a>12500   <a class="code" href="gdbtypes_8h.html#a62d757a5b33e46ec18d2f92b66a948f0">TYPE_FN_FIELDLISTS</a> (type) = (<span class="keyword">struct </span>fn_fieldlist *)
<a name="l12501"></a>12501     <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (type, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> fn_fieldlist) * fip-&gt;<a class="code" href="structfield__info.html#a025391eca616fef2c461bb079f422e3e">nfnfields</a>);
<a name="l12502"></a>12502 
<a name="l12503"></a>12503   <span class="keywordflow">for</span> (i = 0, flp = fip-&gt;<a class="code" href="structfield__info.html#ac4d52aeefe9db6d377a933868817d021">fnfieldlists</a>; i &lt; fip-&gt;nfnfields; i++, flp++)
<a name="l12504"></a>12504     {
<a name="l12505"></a>12505       <span class="keyword">struct </span>nextfnfield *nfp = flp-&gt;head;
<a name="l12506"></a>12506       <span class="keyword">struct </span>fn_fieldlist *fn_flp = &amp;<a class="code" href="gdbtypes_8h.html#a1b38036dfbb2c6f7550104b7cde4b1b1">TYPE_FN_FIELDLIST</a> (type, i);
<a name="l12507"></a>12507       <span class="keywordtype">int</span> k;
<a name="l12508"></a>12508 
<a name="l12509"></a>12509       <a class="code" href="gdbtypes_8h.html#ad06fe1d1555d89ce87344fa6825e5642">TYPE_FN_FIELDLIST_NAME</a> (type, i) = flp-&gt;name;
<a name="l12510"></a>12510       <a class="code" href="gdbtypes_8h.html#a93f192829a3feec903de135b4d53981e">TYPE_FN_FIELDLIST_LENGTH</a> (type, i) = flp-&gt;length;
<a name="l12511"></a>12511       fn_flp-&gt;fn_fields = (<span class="keyword">struct </span>fn_field *)
<a name="l12512"></a>12512         <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (type, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> fn_field) * flp-&gt;<a class="code" href="structtype.html#a73598608f0395a10828a7f69cb843d70">length</a>);
<a name="l12513"></a>12513       <span class="keywordflow">for</span> (k = flp-&gt;length; (k--, nfp); nfp = nfp-&gt;next)
<a name="l12514"></a>12514         fn_flp-&gt;fn_fields[k] = nfp-&gt;fnfield;
<a name="l12515"></a>12515     }
<a name="l12516"></a>12516 
<a name="l12517"></a>12517   <a class="code" href="gdbtypes_8h.html#a04c1a1616329be52b9a9706ddc102bd1">TYPE_NFN_FIELDS</a> (type) = fip-&gt;<a class="code" href="structfield__info.html#a025391eca616fef2c461bb079f422e3e">nfnfields</a>;
<a name="l12518"></a>12518 }
<a name="l12519"></a>12519 
<a name="l12520"></a>12520 <span class="comment">/* Returns non-zero if NAME is the name of a vtable member in CU&#39;s</span>
<a name="l12521"></a>12521 <span class="comment">   language, zero otherwise.  */</span>
<a name="l12522"></a>12522 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l12523"></a><a class="code" href="dwarf2read_8c.html#aaef944e0d9e692774db69fabd5f31d98">12523</a> <a class="code" href="cp-abi_8c.html#aca37f8abeac319d80fa2115a3780a7e3">is_vtable_name</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l12524"></a>12524 {
<a name="l12525"></a>12525   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> vptr[] = <span class="stringliteral">&quot;_vptr&quot;</span>;
<a name="l12526"></a>12526   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> vtable[] = <span class="stringliteral">&quot;vtable&quot;</span>;
<a name="l12527"></a>12527 
<a name="l12528"></a>12528   <span class="comment">/* Look for the C++ and Java forms of the vtable.  */</span>
<a name="l12529"></a>12529   <span class="keywordflow">if</span> ((cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>
<a name="l12530"></a>12530        &amp;&amp; strncmp (name, vtable, <span class="keyword">sizeof</span> (vtable) - 1) == 0)
<a name="l12531"></a>12531        || (strncmp (name, vptr, <span class="keyword">sizeof</span> (vptr) - 1) == 0
<a name="l12532"></a>12532        &amp;&amp; <a class="code" href="demangle_8c.html#ac258afd478a6af5004bb3cc5212a53b8">is_cplus_marker</a> (name[<span class="keyword">sizeof</span> (vptr) - 1])))
<a name="l12533"></a>12533     <span class="keywordflow">return</span> 1;
<a name="l12534"></a>12534 
<a name="l12535"></a>12535   <span class="keywordflow">return</span> 0;
<a name="l12536"></a>12536 }
<a name="l12537"></a>12537 
<a name="l12538"></a>12538 <span class="comment">/* GCC outputs unnamed structures that are really pointers to member</span>
<a name="l12539"></a>12539 <span class="comment">   functions, with the ABI-specified layout.  If TYPE describes</span>
<a name="l12540"></a>12540 <span class="comment">   such a structure, smash it into a member function type.</span>
<a name="l12541"></a>12541 <span class="comment"></span>
<a name="l12542"></a>12542 <span class="comment">   GCC shouldn&#39;t do this; it should just output pointer to member DIEs.</span>
<a name="l12543"></a>12543 <span class="comment">   This is GCC PR debug/28767.  */</span>
<a name="l12544"></a>12544 
<a name="l12545"></a>12545 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12546"></a><a class="code" href="dwarf2read_8c.html#adff61f837ec0e9ea2e9357962bff9680">12546</a> <a class="code" href="dwarf2read_8c.html#adff61f837ec0e9ea2e9357962bff9680">quirk_gcc_member_function_pointer</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> objfile *objfile)
<a name="l12547"></a>12547 {
<a name="l12548"></a>12548   <span class="keyword">struct </span>type *pfn_type, *domain_type, *<a class="code" href="mdebugread_8c.html#ab1ece714ac6020a52b26279dfc1b20d7">new_type</a>;
<a name="l12549"></a>12549 
<a name="l12550"></a>12550   <span class="comment">/* Check for a structure with no name and two children.  */</span>
<a name="l12551"></a>12551   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a> || <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) != 2)
<a name="l12552"></a>12552     <span class="keywordflow">return</span>;
<a name="l12553"></a>12553 
<a name="l12554"></a>12554   <span class="comment">/* Check for __pfn and __delta members.  */</span>
<a name="l12555"></a>12555   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, 0) == NULL
<a name="l12556"></a>12556       || strcmp (<a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, 0), <span class="stringliteral">&quot;__pfn&quot;</span>) != 0
<a name="l12557"></a>12557       || <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, 1) == NULL
<a name="l12558"></a>12558       || strcmp (<a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, 1), <span class="stringliteral">&quot;__delta&quot;</span>) != 0)
<a name="l12559"></a>12559     <span class="keywordflow">return</span>;
<a name="l12560"></a>12560 
<a name="l12561"></a>12561   <span class="comment">/* Find the type of the method.  */</span>
<a name="l12562"></a>12562   pfn_type = <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, 0);
<a name="l12563"></a>12563   <span class="keywordflow">if</span> (pfn_type == NULL
<a name="l12564"></a>12564       || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (pfn_type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l12565"></a>12565       || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (pfn_type)) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>)
<a name="l12566"></a>12566     <span class="keywordflow">return</span>;
<a name="l12567"></a>12567 
<a name="l12568"></a>12568   <span class="comment">/* Look for the &quot;this&quot; argument.  */</span>
<a name="l12569"></a>12569   pfn_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (pfn_type);
<a name="l12570"></a>12570   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (pfn_type) == 0
<a name="l12571"></a>12571       <span class="comment">/* || TYPE_FIELD_TYPE (pfn_type, 0) == NULL */</span>
<a name="l12572"></a>12572       || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (pfn_type, 0)) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l12573"></a>12573     <span class="keywordflow">return</span>;
<a name="l12574"></a>12574 
<a name="l12575"></a>12575   domain_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (pfn_type, 0));
<a name="l12576"></a>12576   new_type = <a class="code" href="gdbtypes_8c.html#a0929c0c96b083ea88998926b06d62d01">alloc_type</a> (objfile);
<a name="l12577"></a>12577   <a class="code" href="gdbtypes_8c.html#afae62bb1c2fdb5c6e6dafdbf7d5f935f">smash_to_method_type</a> (new_type, domain_type, <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (pfn_type),
<a name="l12578"></a>12578                         <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (pfn_type), <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (pfn_type),
<a name="l12579"></a>12579                         <a class="code" href="gdbtypes_8h.html#ac64534be7706a7ed40f5b2de42df4371">TYPE_VARARGS</a> (pfn_type));
<a name="l12580"></a>12580   <a class="code" href="gdbtypes_8c.html#a9ab5ed967338b8c238f568f75097ad53">smash_to_methodptr_type</a> (type, new_type);
<a name="l12581"></a>12581 }
<a name="l12582"></a>12582 
<a name="l12583"></a>12583 <span class="comment">/* Return non-zero if the CU&#39;s PRODUCER string matches the Intel C/C++ compiler</span>
<a name="l12584"></a>12584 <span class="comment">   (icc).  */</span>
<a name="l12585"></a>12585 
<a name="l12586"></a>12586 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l12587"></a><a class="code" href="dwarf2read_8c.html#a068e3816917d348ffb951c6369e057f0">12587</a> <a class="code" href="dwarf2read_8c.html#a068e3816917d348ffb951c6369e057f0">producer_is_icc</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l12588"></a>12588 {
<a name="l12589"></a>12589   <span class="keywordflow">if</span> (!cu-&gt;checked_producer)
<a name="l12590"></a>12590     <a class="code" href="dwarf2read_8c.html#a41cd805d939c553f1679638639f7102b">check_producer</a> (cu);
<a name="l12591"></a>12591 
<a name="l12592"></a>12592   <span class="keywordflow">return</span> cu-&gt;producer_is_icc;
<a name="l12593"></a>12593 }
<a name="l12594"></a>12594 
<a name="l12595"></a>12595 <span class="comment">/* Called when we find the DIE that starts a structure or union scope</span>
<a name="l12596"></a>12596 <span class="comment">   (definition) to create a type for the structure or union.  Fill in</span>
<a name="l12597"></a>12597 <span class="comment">   the type&#39;s name and general properties; the members will not be</span>
<a name="l12598"></a>12598 <span class="comment">   processed until process_structure_scope.</span>
<a name="l12599"></a>12599 <span class="comment"></span>
<a name="l12600"></a>12600 <span class="comment">   NOTE: we need to call these functions regardless of whether or not the</span>
<a name="l12601"></a>12601 <span class="comment">   DIE has a DW_AT_name attribute, since it might be an anonymous</span>
<a name="l12602"></a>12602 <span class="comment">   structure or union.  This gets the type entered into our set of</span>
<a name="l12603"></a>12603 <span class="comment">   user defined types.</span>
<a name="l12604"></a>12604 <span class="comment"></span>
<a name="l12605"></a>12605 <span class="comment">   However, if the structure is incomplete (an opaque struct/union)</span>
<a name="l12606"></a>12606 <span class="comment">   then suppress creating a symbol table entry for it since gdb only</span>
<a name="l12607"></a>12607 <span class="comment">   wants to find the one with the complete definition.  Note that if</span>
<a name="l12608"></a>12608 <span class="comment">   it is complete, we just call new_symbol, which does it&#39;s own</span>
<a name="l12609"></a>12609 <span class="comment">   checking about whether the struct/union is anonymous or not (and</span>
<a name="l12610"></a>12610 <span class="comment">   suppresses creating a symbol table entry itself).  */</span>
<a name="l12611"></a>12611 
<a name="l12612"></a>12612 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l12613"></a><a class="code" href="dwarf2read_8c.html#a8a81f5037ce9ef3a37c692027a511e68">12613</a> <a class="code" href="dwarf2read_8c.html#a8a81f5037ce9ef3a37c692027a511e68">read_structure_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l12614"></a>12614 {
<a name="l12615"></a>12615   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l12616"></a>12616   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l12617"></a>12617   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l12618"></a>12618   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l12619"></a>12619 
<a name="l12620"></a>12620   <span class="comment">/* If the definition of this type lives in .debug_types, read that type.</span>
<a name="l12621"></a>12621 <span class="comment">     Don&#39;t follow DW_AT_specification though, that will take us back up</span>
<a name="l12622"></a>12622 <span class="comment">     the chain and we want to go down.  */</span>
<a name="l12623"></a>12623   attr = <a class="code" href="dwarf2read_8c.html#a50710a3c575e046cafb61f16aaca480f">dwarf2_attr_no_follow</a> (die, DW_AT_signature);
<a name="l12624"></a>12624   <span class="keywordflow">if</span> (attr)
<a name="l12625"></a>12625     {
<a name="l12626"></a>12626       type = <a class="code" href="dwarf2read_8c.html#ad28686b8248336c2fdf52288043a74f7">get_DW_AT_signature_type</a> (die, attr, cu);
<a name="l12627"></a>12627 
<a name="l12628"></a>12628       <span class="comment">/* The type&#39;s CU may not be the same as CU.</span>
<a name="l12629"></a>12629 <span class="comment">         Ensure TYPE is recorded with CU in die_type_hash.  */</span>
<a name="l12630"></a>12630       <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l12631"></a>12631     }
<a name="l12632"></a>12632 
<a name="l12633"></a>12633   type = <a class="code" href="gdbtypes_8c.html#a0929c0c96b083ea88998926b06d62d01">alloc_type</a> (objfile);
<a name="l12634"></a>12634   <a class="code" href="gdbtypes_8h.html#abce922c83265a58f62b491513b7a5aea">INIT_CPLUS_SPECIFIC</a> (type);
<a name="l12635"></a>12635 
<a name="l12636"></a>12636   name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l12637"></a>12637   <span class="keywordflow">if</span> (name != NULL)
<a name="l12638"></a>12638     {
<a name="l12639"></a>12639       <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l12640"></a>12640           || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>)
<a name="l12641"></a>12641         {
<a name="l12642"></a>12642           <span class="keyword">const</span> <span class="keywordtype">char</span> *full_name = <a class="code" href="dwarf2read_8c.html#a01de8f373799ebb39da7b5758619ec4c">dwarf2_full_name</a> (name, die, cu);
<a name="l12643"></a>12643 
<a name="l12644"></a>12644           <span class="comment">/* dwarf2_full_name might have already finished building the DIE&#39;s</span>
<a name="l12645"></a>12645 <span class="comment">             type.  If so, there is no need to continue.  */</span>
<a name="l12646"></a>12646           <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu) != NULL)
<a name="l12647"></a>12647             <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu);
<a name="l12648"></a>12648 
<a name="l12649"></a>12649           <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) = full_name;
<a name="l12650"></a>12650           <span class="keywordflow">if</span> (die-&gt;tag == DW_TAG_structure_type
<a name="l12651"></a>12651               || die-&gt;tag == DW_TAG_class_type)
<a name="l12652"></a>12652             <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) = <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type);
<a name="l12653"></a>12653         }
<a name="l12654"></a>12654       <span class="keywordflow">else</span>
<a name="l12655"></a>12655         {
<a name="l12656"></a>12656           <span class="comment">/* The name is already allocated along with this objfile, so</span>
<a name="l12657"></a>12657 <span class="comment">             we don&#39;t need to duplicate it for the type.  */</span>
<a name="l12658"></a>12658           <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l12659"></a>12659           <span class="keywordflow">if</span> (die-&gt;tag == DW_TAG_class_type)
<a name="l12660"></a>12660             <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) = <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type);
<a name="l12661"></a>12661         }
<a name="l12662"></a>12662     }
<a name="l12663"></a>12663 
<a name="l12664"></a>12664   <span class="keywordflow">if</span> (die-&gt;tag == DW_TAG_structure_type)
<a name="l12665"></a>12665     {
<a name="l12666"></a>12666       <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>;
<a name="l12667"></a>12667     }
<a name="l12668"></a>12668   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (die-&gt;tag == DW_TAG_union_type)
<a name="l12669"></a>12669     {
<a name="l12670"></a>12670       <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>;
<a name="l12671"></a>12671     }
<a name="l12672"></a>12672   <span class="keywordflow">else</span>
<a name="l12673"></a>12673     {
<a name="l12674"></a>12674       <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) = <a class="code" href="gdbtypes_8h.html#a9f70b67b4d14548a879667f544eab4ef">TYPE_CODE_CLASS</a>;
<a name="l12675"></a>12675     }
<a name="l12676"></a>12676 
<a name="l12677"></a>12677   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a> &amp;&amp; die-&gt;tag == DW_TAG_class_type)
<a name="l12678"></a>12678     <a class="code" href="gdbtypes_8h.html#a2e97f1db4e928a613e3526dfb0346922">TYPE_DECLARED_CLASS</a> (type) = 1;
<a name="l12679"></a>12679 
<a name="l12680"></a>12680   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_byte_size, cu);
<a name="l12681"></a>12681   <span class="keywordflow">if</span> (attr)
<a name="l12682"></a>12682     {
<a name="l12683"></a>12683       <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l12684"></a>12684     }
<a name="l12685"></a>12685   <span class="keywordflow">else</span>
<a name="l12686"></a>12686     {
<a name="l12687"></a>12687       <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = 0;
<a name="l12688"></a>12688     }
<a name="l12689"></a>12689 
<a name="l12690"></a>12690   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a068e3816917d348ffb951c6369e057f0">producer_is_icc</a> (cu))
<a name="l12691"></a>12691     {
<a name="l12692"></a>12692       <span class="comment">/* ICC does not output the required DW_AT_declaration</span>
<a name="l12693"></a>12693 <span class="comment">         on incomplete types, but gives them a size of zero.  */</span>
<a name="l12694"></a>12694     }
<a name="l12695"></a>12695   <span class="keywordflow">else</span>
<a name="l12696"></a>12696     <a class="code" href="gdbtypes_8h.html#aac7e4f35d6b06664e65106ffd57b31ad">TYPE_STUB_SUPPORTED</a> (type) = 1;
<a name="l12697"></a>12697 
<a name="l12698"></a>12698   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#aa9ca23caab102417f39b86b7b2716588">die_is_declaration</a> (die, cu))
<a name="l12699"></a>12699     <a class="code" href="gdbtypes_8h.html#aec5d0569d60af8ecfc5d2c7edae87d9c">TYPE_STUB</a> (type) = 1;
<a name="l12700"></a>12700   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attr == NULL &amp;&amp; die-&gt;child == NULL
<a name="l12701"></a>12701            &amp;&amp; <a class="code" href="symtab_8c.html#a2b65c6025d0b21b20632a0d5d0b81b31">producer_is_realview</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>))
<a name="l12702"></a>12702     <span class="comment">/* RealView does not output the required DW_AT_declaration</span>
<a name="l12703"></a>12703 <span class="comment">       on incomplete types.  */</span>
<a name="l12704"></a>12704     <a class="code" href="gdbtypes_8h.html#aec5d0569d60af8ecfc5d2c7edae87d9c">TYPE_STUB</a> (type) = 1;
<a name="l12705"></a>12705 
<a name="l12706"></a>12706   <span class="comment">/* We need to add the type field to the die immediately so we don&#39;t</span>
<a name="l12707"></a>12707 <span class="comment">     infinitely recurse when dealing with pointers to the structure</span>
<a name="l12708"></a>12708 <span class="comment">     type within the structure itself.  */</span>
<a name="l12709"></a>12709   <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l12710"></a>12710 
<a name="l12711"></a>12711   <span class="comment">/* set_die_type should be already done.  */</span>
<a name="l12712"></a>12712   <a class="code" href="dwarf2read_8c.html#abc906394dd587b9b28825cf6798d43d9">set_descriptive_type</a> (type, die, cu);
<a name="l12713"></a>12713 
<a name="l12714"></a>12714   <span class="keywordflow">return</span> <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l12715"></a>12715 }
<a name="l12716"></a>12716 
<a name="l12717"></a>12717 <span class="comment">/* Finish creating a structure or union type, including filling in</span>
<a name="l12718"></a>12718 <span class="comment">   its members and creating a symbol for it.  */</span>
<a name="l12719"></a>12719 
<a name="l12720"></a>12720 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12721"></a><a class="code" href="dwarf2read_8c.html#a0d01179d58ab2151b5a646e74f2c089f">12721</a> <a class="code" href="dwarf2read_8c.html#a0d01179d58ab2151b5a646e74f2c089f">process_structure_scope</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l12722"></a>12722 {
<a name="l12723"></a>12723   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l12724"></a>12724   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_die = die-&gt;child;
<a name="l12725"></a>12725   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l12726"></a>12726 
<a name="l12727"></a>12727   type = <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu);
<a name="l12728"></a>12728   <span class="keywordflow">if</span> (type == NULL)
<a name="l12729"></a>12729     type = <a class="code" href="dwarf2read_8c.html#a8a81f5037ce9ef3a37c692027a511e68">read_structure_type</a> (die, cu);
<a name="l12730"></a>12730 
<a name="l12731"></a>12731   <span class="keywordflow">if</span> (die-&gt;child != NULL &amp;&amp; ! <a class="code" href="dwarf2read_8c.html#aa9ca23caab102417f39b86b7b2716588">die_is_declaration</a> (die, cu))
<a name="l12732"></a>12732     {
<a name="l12733"></a>12733       <span class="keyword">struct </span><a class="code" href="structfield__info.html">field_info</a> fi;
<a name="l12734"></a>12734       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_die;
<a name="l12735"></a>12735       <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) *template_args = NULL;
<a name="l12736"></a>12736       <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, 0);
<a name="l12737"></a>12737 
<a name="l12738"></a>12738       <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;fi, 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structfield__info.html">field_info</a>));
<a name="l12739"></a>12739 
<a name="l12740"></a>12740       child_die = die-&gt;child;
<a name="l12741"></a>12741 
<a name="l12742"></a>12742       <span class="keywordflow">while</span> (child_die &amp;&amp; child_die-&gt;tag)
<a name="l12743"></a>12743         {
<a name="l12744"></a>12744           <span class="keywordflow">if</span> (child_die-&gt;tag == DW_TAG_member
<a name="l12745"></a>12745               || child_die-&gt;tag == DW_TAG_variable)
<a name="l12746"></a>12746             {
<a name="l12747"></a>12747               <span class="comment">/* NOTE: carlton/2002-11-05: A C++ static data member</span>
<a name="l12748"></a>12748 <span class="comment">                 should be a DW_TAG_member that is a declaration, but</span>
<a name="l12749"></a>12749 <span class="comment">                 all versions of G++ as of this writing (so through at</span>
<a name="l12750"></a>12750 <span class="comment">                 least 3.2.1) incorrectly generate DW_TAG_variable</span>
<a name="l12751"></a>12751 <span class="comment">                 tags for them instead.  */</span>
<a name="l12752"></a>12752               <a class="code" href="dwarf2read_8c.html#a288fbd6a927a07b52e2047da8322d25e">dwarf2_add_field</a> (&amp;fi, child_die, cu);
<a name="l12753"></a>12753             }
<a name="l12754"></a>12754           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (child_die-&gt;tag == DW_TAG_subprogram)
<a name="l12755"></a>12755             {
<a name="l12756"></a>12756               <span class="comment">/* C++ member function.  */</span>
<a name="l12757"></a>12757               <a class="code" href="dwarf2read_8c.html#a1c6ac754036149e6eadc244c6c777c77">dwarf2_add_member_fn</a> (&amp;fi, child_die, type, cu);
<a name="l12758"></a>12758             }
<a name="l12759"></a>12759           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (child_die-&gt;tag == DW_TAG_inheritance)
<a name="l12760"></a>12760             {
<a name="l12761"></a>12761               <span class="comment">/* C++ base class field.  */</span>
<a name="l12762"></a>12762               <a class="code" href="dwarf2read_8c.html#a288fbd6a927a07b52e2047da8322d25e">dwarf2_add_field</a> (&amp;fi, child_die, cu);
<a name="l12763"></a>12763             }
<a name="l12764"></a>12764           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (child_die-&gt;tag == DW_TAG_typedef)
<a name="l12765"></a>12765             <a class="code" href="dwarf2read_8c.html#a6df3d7a72109489d1d00c8c8c7d37c87">dwarf2_add_typedef</a> (&amp;fi, child_die, cu);
<a name="l12766"></a>12766           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (child_die-&gt;tag == DW_TAG_template_type_param
<a name="l12767"></a>12767                    || child_die-&gt;tag == DW_TAG_template_value_param)
<a name="l12768"></a>12768             {
<a name="l12769"></a>12769               <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *arg = <a class="code" href="dwarf2read_8c.html#a4b79d225399dba2c4a3397a858440dd4">new_symbol</a> (child_die, NULL, cu);
<a name="l12770"></a>12770 
<a name="l12771"></a>12771               <span class="keywordflow">if</span> (arg != NULL)
<a name="l12772"></a>12772                 <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (symbolp, template_args, arg);
<a name="l12773"></a>12773             }
<a name="l12774"></a>12774 
<a name="l12775"></a>12775           child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l12776"></a>12776         }
<a name="l12777"></a>12777 
<a name="l12778"></a>12778       <span class="comment">/* Attach template arguments to type.  */</span>
<a name="l12779"></a>12779       <span class="keywordflow">if</span> (! <a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (symbolp, template_args))
<a name="l12780"></a>12780         {
<a name="l12781"></a>12781           <a class="code" href="gdbtypes_8h.html#a39116f69533c29b08fc5504b4d6986c0">ALLOCATE_CPLUS_STRUCT_TYPE</a> (type);
<a name="l12782"></a>12782           <a class="code" href="gdbtypes_8h.html#a9bac56587d93fbab70301eed2bd4a0bd">TYPE_N_TEMPLATE_ARGUMENTS</a> (type)
<a name="l12783"></a>12783             = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (symbolp, template_args);
<a name="l12784"></a>12784           <a class="code" href="gdbtypes_8h.html#a29de819362b24f0269c86b8975d25c2e">TYPE_TEMPLATE_ARGUMENTS</a> (type)
<a name="l12785"></a>12785             = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l12786"></a>12786                              (<a class="code" href="gdbtypes_8h.html#a9bac56587d93fbab70301eed2bd4a0bd">TYPE_N_TEMPLATE_ARGUMENTS</a> (type)
<a name="l12787"></a>12787                               * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *)));
<a name="l12788"></a>12788           <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="gdbtypes_8h.html#a29de819362b24f0269c86b8975d25c2e">TYPE_TEMPLATE_ARGUMENTS</a> (type),
<a name="l12789"></a>12789                   <a class="code" href="vec_8h.html#a99adc2006a668acc675e3758d9375ad5">VEC_address</a> (symbolp, template_args),
<a name="l12790"></a>12790                   (<a class="code" href="gdbtypes_8h.html#a9bac56587d93fbab70301eed2bd4a0bd">TYPE_N_TEMPLATE_ARGUMENTS</a> (type)
<a name="l12791"></a>12791                    * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *)));
<a name="l12792"></a>12792           <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (symbolp, template_args);
<a name="l12793"></a>12793         }
<a name="l12794"></a>12794 
<a name="l12795"></a>12795       <span class="comment">/* Attach fields and member functions to the type.  */</span>
<a name="l12796"></a>12796       <span class="keywordflow">if</span> (fi.<a class="code" href="structfield__info.html#a09bd04c8bcdb22c9bc1ce43df30aac8d">nfields</a>)
<a name="l12797"></a>12797         <a class="code" href="dwarf2read_8c.html#a9c6533d3437b203af697f7b478990784">dwarf2_attach_fields_to_type</a> (&amp;fi, type, cu);
<a name="l12798"></a>12798       <span class="keywordflow">if</span> (fi.<a class="code" href="structfield__info.html#a025391eca616fef2c461bb079f422e3e">nfnfields</a>)
<a name="l12799"></a>12799         {
<a name="l12800"></a>12800           <a class="code" href="dwarf2read_8c.html#a014e4767f6c0ac385eb4c45327b7fe94">dwarf2_attach_fn_fields_to_type</a> (&amp;fi, type, cu);
<a name="l12801"></a>12801 
<a name="l12802"></a>12802           <span class="comment">/* Get the type which refers to the base class (possibly this</span>
<a name="l12803"></a>12803 <span class="comment">             class itself) which contains the vtable pointer for the current</span>
<a name="l12804"></a>12804 <span class="comment">             class from the DW_AT_containing_type attribute.  This use of</span>
<a name="l12805"></a>12805 <span class="comment">             DW_AT_containing_type is a GNU extension.  */</span>
<a name="l12806"></a>12806 
<a name="l12807"></a>12807           <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_containing_type, cu) != NULL)
<a name="l12808"></a>12808             {
<a name="l12809"></a>12809               <span class="keyword">struct </span>type *t = <a class="code" href="dwarf2read_8c.html#a2ce2b8e439742408e8161e899d9cb67a">die_containing_type</a> (die, cu);
<a name="l12810"></a>12810 
<a name="l12811"></a>12811               <a class="code" href="gdbtypes_8h.html#a128fd92e71469aa5f55704a1f0814fb3">TYPE_VPTR_BASETYPE</a> (type) = t;
<a name="l12812"></a>12812               <span class="keywordflow">if</span> (type == t)
<a name="l12813"></a>12813                 {
<a name="l12814"></a>12814                   <span class="keywordtype">int</span> i;
<a name="l12815"></a>12815 
<a name="l12816"></a>12816                   <span class="comment">/* Our own class provides vtbl ptr.  */</span>
<a name="l12817"></a>12817                   <span class="keywordflow">for</span> (i = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (t) - 1;
<a name="l12818"></a>12818                        i &gt;= <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (t);
<a name="l12819"></a>12819                        --i)
<a name="l12820"></a>12820                     {
<a name="l12821"></a>12821                       <span class="keyword">const</span> <span class="keywordtype">char</span> *fieldname = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (t, i);
<a name="l12822"></a>12822 
<a name="l12823"></a>12823                       <span class="keywordflow">if</span> (<a class="code" href="cp-abi_8c.html#aca37f8abeac319d80fa2115a3780a7e3">is_vtable_name</a> (fieldname, cu))
<a name="l12824"></a>12824                         {
<a name="l12825"></a>12825                           <a class="code" href="gdbtypes_8h.html#aa20a30a8f11029649bea0e356e9dc140">TYPE_VPTR_FIELDNO</a> (type) = i;
<a name="l12826"></a>12826                           <span class="keywordflow">break</span>;
<a name="l12827"></a>12827                         }
<a name="l12828"></a>12828                     }
<a name="l12829"></a>12829 
<a name="l12830"></a>12830                   <span class="comment">/* Complain if virtual function table field not found.  */</span>
<a name="l12831"></a>12831                   <span class="keywordflow">if</span> (i &lt; <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (t))
<a name="l12832"></a>12832                     <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l12833"></a>12833                                <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;virtual function table pointer &quot;</span>
<a name="l12834"></a>12834                                  <span class="stringliteral">&quot;not found when defining class &#39;%s&#39;&quot;</span>),
<a name="l12835"></a>12835                                <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) ? <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) :
<a name="l12836"></a>12836                                <span class="stringliteral">&quot;&quot;</span>);
<a name="l12837"></a>12837                 }
<a name="l12838"></a>12838               <span class="keywordflow">else</span>
<a name="l12839"></a>12839                 {
<a name="l12840"></a>12840                   <a class="code" href="gdbtypes_8h.html#aa20a30a8f11029649bea0e356e9dc140">TYPE_VPTR_FIELDNO</a> (type) = <a class="code" href="gdbtypes_8h.html#aa20a30a8f11029649bea0e356e9dc140">TYPE_VPTR_FIELDNO</a> (t);
<a name="l12841"></a>12841                 }
<a name="l12842"></a>12842             }
<a name="l12843"></a>12843           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>
<a name="l12844"></a>12844                    &amp;&amp; strncmp (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>,
<a name="l12845"></a>12845                                <span class="stringliteral">&quot;IBM(R) XL C/C++ Advanced Edition&quot;</span>, 32) == 0)
<a name="l12846"></a>12846             {
<a name="l12847"></a>12847               <span class="comment">/* The IBM XLC compiler does not provide direct indication</span>
<a name="l12848"></a>12848 <span class="comment">                 of the containing type, but the vtable pointer is</span>
<a name="l12849"></a>12849 <span class="comment">                 always named __vfp.  */</span>
<a name="l12850"></a>12850 
<a name="l12851"></a>12851               <span class="keywordtype">int</span> i;
<a name="l12852"></a>12852 
<a name="l12853"></a>12853               <span class="keywordflow">for</span> (i = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) - 1;
<a name="l12854"></a>12854                    i &gt;= <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (type);
<a name="l12855"></a>12855                    --i)
<a name="l12856"></a>12856                 {
<a name="l12857"></a>12857                   <span class="keywordflow">if</span> (strcmp (<a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, i), <span class="stringliteral">&quot;__vfp&quot;</span>) == 0)
<a name="l12858"></a>12858                     {
<a name="l12859"></a>12859                       <a class="code" href="gdbtypes_8h.html#aa20a30a8f11029649bea0e356e9dc140">TYPE_VPTR_FIELDNO</a> (type) = i;
<a name="l12860"></a>12860                       <a class="code" href="gdbtypes_8h.html#a128fd92e71469aa5f55704a1f0814fb3">TYPE_VPTR_BASETYPE</a> (type) = <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l12861"></a>12861                       <span class="keywordflow">break</span>;
<a name="l12862"></a>12862                     }
<a name="l12863"></a>12863                 }
<a name="l12864"></a>12864             }
<a name="l12865"></a>12865         }
<a name="l12866"></a>12866 
<a name="l12867"></a>12867       <span class="comment">/* Copy fi.typedef_field_list linked list elements content into the</span>
<a name="l12868"></a>12868 <span class="comment">         allocated array TYPE_TYPEDEF_FIELD_ARRAY (type).  */</span>
<a name="l12869"></a>12869       <span class="keywordflow">if</span> (fi.<a class="code" href="structfield__info.html#a1861c9d86ad164a461664702e67c90d3">typedef_field_list</a>)
<a name="l12870"></a>12870         {
<a name="l12871"></a>12871           <span class="keywordtype">int</span> i = fi.<a class="code" href="structfield__info.html#a60696c993efeb4eed00ec2ac741931f2">typedef_field_list_count</a>;
<a name="l12872"></a>12872 
<a name="l12873"></a>12873           <a class="code" href="gdbtypes_8h.html#a39116f69533c29b08fc5504b4d6986c0">ALLOCATE_CPLUS_STRUCT_TYPE</a> (type);
<a name="l12874"></a>12874           <a class="code" href="gdbtypes_8h.html#adcb871b5d18a459cac4d7e4c6cf76320">TYPE_TYPEDEF_FIELD_ARRAY</a> (type)
<a name="l12875"></a>12875             = <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (type, <span class="keyword">sizeof</span> (<a class="code" href="gdbtypes_8h.html#ab7e7ca6cf80f9833f648e4bae4e2b6ad">TYPE_TYPEDEF_FIELD</a> (type, 0)) * i);
<a name="l12876"></a>12876           <a class="code" href="gdbtypes_8h.html#ac34451cdc1f0b073c3866b901aa8a460">TYPE_TYPEDEF_FIELD_COUNT</a> (type) = i;
<a name="l12877"></a>12877 
<a name="l12878"></a>12878           <span class="comment">/* Reverse the list order to keep the debug info elements order.  */</span>
<a name="l12879"></a>12879           <span class="keywordflow">while</span> (--i &gt;= 0)
<a name="l12880"></a>12880             {
<a name="l12881"></a>12881               <span class="keyword">struct </span>typedef_field *dest, *src;
<a name="l12882"></a>12882 
<a name="l12883"></a>12883               dest = &amp;<a class="code" href="gdbtypes_8h.html#ab7e7ca6cf80f9833f648e4bae4e2b6ad">TYPE_TYPEDEF_FIELD</a> (type, i);
<a name="l12884"></a>12884               src = &amp;fi.<a class="code" href="structfield__info.html#a1861c9d86ad164a461664702e67c90d3">typedef_field_list</a>-&gt;<a class="code" href="structfield__info_1_1typedef__field__list.html#acc713b1964cd17fe6b8a6025ab60d783">field</a>;
<a name="l12885"></a>12885               fi.<a class="code" href="structfield__info.html#a1861c9d86ad164a461664702e67c90d3">typedef_field_list</a> = fi.<a class="code" href="structfield__info.html#a1861c9d86ad164a461664702e67c90d3">typedef_field_list</a>-&gt;<a class="code" href="structfield__info_1_1typedef__field__list.html#a24bf090b04961658ea024d3ac16b3f7b">next</a>;
<a name="l12886"></a>12886               *dest = *src;
<a name="l12887"></a>12887             }
<a name="l12888"></a>12888         }
<a name="l12889"></a>12889 
<a name="l12890"></a>12890       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l12891"></a>12891 
<a name="l12892"></a>12892       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aa057ef3e6916cbe12060099547c3f76a">HAVE_CPLUS_STRUCT</a> (type))
<a name="l12893"></a>12893         <a class="code" href="gdbtypes_8h.html#a7fb5e879fed7a38eaa1756aa5d0e658b">TYPE_CPLUS_REALLY_JAVA</a> (type) = cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>;
<a name="l12894"></a>12894     }
<a name="l12895"></a>12895 
<a name="l12896"></a>12896   <a class="code" href="dwarf2read_8c.html#adff61f837ec0e9ea2e9357962bff9680">quirk_gcc_member_function_pointer</a> (type, objfile);
<a name="l12897"></a>12897 
<a name="l12898"></a>12898   <span class="comment">/* NOTE: carlton/2004-03-16: GCC 3.4 (or at least one of its</span>
<a name="l12899"></a>12899 <span class="comment">     snapshots) has been known to create a die giving a declaration</span>
<a name="l12900"></a>12900 <span class="comment">     for a class that has, as a child, a die giving a definition for a</span>
<a name="l12901"></a>12901 <span class="comment">     nested class.  So we have to process our children even if the</span>
<a name="l12902"></a>12902 <span class="comment">     current die is a declaration.  Normally, of course, a declaration</span>
<a name="l12903"></a>12903 <span class="comment">     won&#39;t have any children at all.  */</span>
<a name="l12904"></a>12904 
<a name="l12905"></a>12905   <span class="keywordflow">while</span> (child_die != NULL &amp;&amp; child_die-&gt;tag)
<a name="l12906"></a>12906     {
<a name="l12907"></a>12907       <span class="keywordflow">if</span> (child_die-&gt;tag == DW_TAG_member
<a name="l12908"></a>12908           || child_die-&gt;tag == DW_TAG_variable
<a name="l12909"></a>12909           || child_die-&gt;tag == DW_TAG_inheritance
<a name="l12910"></a>12910           || child_die-&gt;tag == DW_TAG_template_value_param
<a name="l12911"></a>12911           || child_die-&gt;tag == DW_TAG_template_type_param)
<a name="l12912"></a>12912         {
<a name="l12913"></a>12913           <span class="comment">/* Do nothing.  */</span>
<a name="l12914"></a>12914         }
<a name="l12915"></a>12915       <span class="keywordflow">else</span>
<a name="l12916"></a>12916         <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (child_die, cu);
<a name="l12917"></a>12917 
<a name="l12918"></a>12918       child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l12919"></a>12919     }
<a name="l12920"></a>12920 
<a name="l12921"></a>12921   <span class="comment">/* Do not consider external references.  According to the DWARF standard,</span>
<a name="l12922"></a>12922 <span class="comment">     these DIEs are identified by the fact that they have no byte_size</span>
<a name="l12923"></a>12923 <span class="comment">     attribute, and a declaration attribute.  */</span>
<a name="l12924"></a>12924   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_byte_size, cu) != NULL
<a name="l12925"></a>12925       || !<a class="code" href="dwarf2read_8c.html#aa9ca23caab102417f39b86b7b2716588">die_is_declaration</a> (die, cu))
<a name="l12926"></a>12926     <a class="code" href="dwarf2read_8c.html#a4b79d225399dba2c4a3397a858440dd4">new_symbol</a> (die, type, cu);
<a name="l12927"></a>12927 }
<a name="l12928"></a>12928 
<a name="l12929"></a>12929 <span class="comment">/* Given a DW_AT_enumeration_type die, set its type.  We do not</span>
<a name="l12930"></a>12930 <span class="comment">   complete the type&#39;s fields yet, or create any symbols.  */</span>
<a name="l12931"></a>12931 
<a name="l12932"></a>12932 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l12933"></a><a class="code" href="dwarf2read_8c.html#abdeef1b6d889ebd38830b6ba38d05f37">12933</a> <a class="code" href="dwarf2read_8c.html#abdeef1b6d889ebd38830b6ba38d05f37">read_enumeration_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l12934"></a>12934 {
<a name="l12935"></a>12935   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l12936"></a>12936   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l12937"></a>12937   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l12938"></a>12938   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l12939"></a>12939 
<a name="l12940"></a>12940   <span class="comment">/* If the definition of this type lives in .debug_types, read that type.</span>
<a name="l12941"></a>12941 <span class="comment">     Don&#39;t follow DW_AT_specification though, that will take us back up</span>
<a name="l12942"></a>12942 <span class="comment">     the chain and we want to go down.  */</span>
<a name="l12943"></a>12943   attr = <a class="code" href="dwarf2read_8c.html#a50710a3c575e046cafb61f16aaca480f">dwarf2_attr_no_follow</a> (die, DW_AT_signature);
<a name="l12944"></a>12944   <span class="keywordflow">if</span> (attr)
<a name="l12945"></a>12945     {
<a name="l12946"></a>12946       type = <a class="code" href="dwarf2read_8c.html#ad28686b8248336c2fdf52288043a74f7">get_DW_AT_signature_type</a> (die, attr, cu);
<a name="l12947"></a>12947 
<a name="l12948"></a>12948       <span class="comment">/* The type&#39;s CU may not be the same as CU.</span>
<a name="l12949"></a>12949 <span class="comment">         Ensure TYPE is recorded with CU in die_type_hash.  */</span>
<a name="l12950"></a>12950       <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l12951"></a>12951     }
<a name="l12952"></a>12952 
<a name="l12953"></a>12953   type = <a class="code" href="gdbtypes_8c.html#a0929c0c96b083ea88998926b06d62d01">alloc_type</a> (objfile);
<a name="l12954"></a>12954 
<a name="l12955"></a>12955   <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>;
<a name="l12956"></a>12956   name = <a class="code" href="dwarf2read_8c.html#a01de8f373799ebb39da7b5758619ec4c">dwarf2_full_name</a> (NULL, die, cu);
<a name="l12957"></a>12957   <span class="keywordflow">if</span> (name != NULL)
<a name="l12958"></a>12958     <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l12959"></a>12959 
<a name="l12960"></a>12960   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_byte_size, cu);
<a name="l12961"></a>12961   <span class="keywordflow">if</span> (attr)
<a name="l12962"></a>12962     {
<a name="l12963"></a>12963       <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l12964"></a>12964     }
<a name="l12965"></a>12965   <span class="keywordflow">else</span>
<a name="l12966"></a>12966     {
<a name="l12967"></a>12967       <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = 0;
<a name="l12968"></a>12968     }
<a name="l12969"></a>12969 
<a name="l12970"></a>12970   <span class="comment">/* The enumeration DIE can be incomplete.  In Ada, any type can be</span>
<a name="l12971"></a>12971 <span class="comment">     declared as private in the package spec, and then defined only</span>
<a name="l12972"></a>12972 <span class="comment">     inside the package body.  Such types are known as Taft Amendment</span>
<a name="l12973"></a>12973 <span class="comment">     Types.  When another package uses such a type, an incomplete DIE</span>
<a name="l12974"></a>12974 <span class="comment">     may be generated by the compiler.  */</span>
<a name="l12975"></a>12975   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#aa9ca23caab102417f39b86b7b2716588">die_is_declaration</a> (die, cu))
<a name="l12976"></a>12976     <a class="code" href="gdbtypes_8h.html#aec5d0569d60af8ecfc5d2c7edae87d9c">TYPE_STUB</a> (type) = 1;
<a name="l12977"></a>12977 
<a name="l12978"></a>12978   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l12979"></a>12979 }
<a name="l12980"></a>12980 
<a name="l12981"></a>12981 <span class="comment">/* Given a pointer to a die which begins an enumeration, process all</span>
<a name="l12982"></a>12982 <span class="comment">   the dies that define the members of the enumeration, and create the</span>
<a name="l12983"></a>12983 <span class="comment">   symbol for the enumeration type.</span>
<a name="l12984"></a>12984 <span class="comment"></span>
<a name="l12985"></a>12985 <span class="comment">   NOTE: We reverse the order of the element list.  */</span>
<a name="l12986"></a>12986 
<a name="l12987"></a>12987 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12988"></a><a class="code" href="dwarf2read_8c.html#aeff5dce8be530b01d1e71bbe356f9a24">12988</a> <a class="code" href="dwarf2read_8c.html#aeff5dce8be530b01d1e71bbe356f9a24">process_enumeration_scope</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l12989"></a>12989 {
<a name="l12990"></a>12990   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *this_type;
<a name="l12991"></a>12991 
<a name="l12992"></a>12992   this_type = <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu);
<a name="l12993"></a>12993   <span class="keywordflow">if</span> (this_type == NULL)
<a name="l12994"></a>12994     this_type = <a class="code" href="dwarf2read_8c.html#abdeef1b6d889ebd38830b6ba38d05f37">read_enumeration_type</a> (die, cu);
<a name="l12995"></a>12995 
<a name="l12996"></a>12996   <span class="keywordflow">if</span> (die-&gt;child != NULL)
<a name="l12997"></a>12997     {
<a name="l12998"></a>12998       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_die;
<a name="l12999"></a>12999       <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l13000"></a>13000       <span class="keyword">struct </span>field *fields = NULL;
<a name="l13001"></a>13001       <span class="keywordtype">int</span> num_fields = 0;
<a name="l13002"></a>13002       <span class="keywordtype">int</span> unsigned_enum = 1;
<a name="l13003"></a>13003       <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l13004"></a>13004       <span class="keywordtype">int</span> flag_enum = 1;
<a name="l13005"></a>13005       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> mask = 0;
<a name="l13006"></a>13006 
<a name="l13007"></a>13007       child_die = die-&gt;child;
<a name="l13008"></a>13008       <span class="keywordflow">while</span> (child_die &amp;&amp; child_die-&gt;tag)
<a name="l13009"></a>13009         {
<a name="l13010"></a>13010           <span class="keywordflow">if</span> (child_die-&gt;tag != DW_TAG_enumerator)
<a name="l13011"></a>13011             {
<a name="l13012"></a>13012               <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (child_die, cu);
<a name="l13013"></a>13013             }
<a name="l13014"></a>13014           <span class="keywordflow">else</span>
<a name="l13015"></a>13015             {
<a name="l13016"></a>13016               name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (child_die, cu);
<a name="l13017"></a>13017               <span class="keywordflow">if</span> (name)
<a name="l13018"></a>13018                 {
<a name="l13019"></a>13019                   sym = <a class="code" href="dwarf2read_8c.html#a4b79d225399dba2c4a3397a858440dd4">new_symbol</a> (child_die, this_type, cu);
<a name="l13020"></a>13020                   <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (sym) &lt; 0)
<a name="l13021"></a>13021                     {
<a name="l13022"></a>13022                       unsigned_enum = 0;
<a name="l13023"></a>13023                       flag_enum = 0;
<a name="l13024"></a>13024                     }
<a name="l13025"></a>13025                   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((mask &amp; <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (sym)) != 0)
<a name="l13026"></a>13026                     flag_enum = 0;
<a name="l13027"></a>13027                   <span class="keywordflow">else</span>
<a name="l13028"></a>13028                     mask |= <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (sym);
<a name="l13029"></a>13029 
<a name="l13030"></a>13030                   <span class="keywordflow">if</span> ((num_fields % <a class="code" href="dwarf2read_8c.html#aa40456d31b1edb968e39e63c9a8dd42b">DW_FIELD_ALLOC_CHUNK</a>) == 0)
<a name="l13031"></a>13031                     {
<a name="l13032"></a>13032                       fields = (<span class="keyword">struct </span>field *)
<a name="l13033"></a>13033                         <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (fields,
<a name="l13034"></a>13034                                   (num_fields + DW_FIELD_ALLOC_CHUNK)
<a name="l13035"></a>13035                                   * <span class="keyword">sizeof</span> (<span class="keyword">struct </span>field));
<a name="l13036"></a>13036                     }
<a name="l13037"></a>13037 
<a name="l13038"></a>13038                   <a class="code" href="gdbtypes_8h.html#aeaff087d79e6871070384c25cf886da7">FIELD_NAME</a> (fields[num_fields]) = <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym);
<a name="l13039"></a>13039                   <a class="code" href="gdbtypes_8h.html#ae88bb60de05efe94bc1cbafee6fa3985">FIELD_TYPE</a> (fields[num_fields]) = NULL;
<a name="l13040"></a>13040                   <a class="code" href="gdbtypes_8h.html#a7c5d158b14cf4880b850a7dcd791582f">SET_FIELD_ENUMVAL</a> (fields[num_fields], <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (sym));
<a name="l13041"></a>13041                   <a class="code" href="gdbtypes_8h.html#af6b82d1dbebd01aa271ea0273efb0958">FIELD_BITSIZE</a> (fields[num_fields]) = 0;
<a name="l13042"></a>13042 
<a name="l13043"></a>13043                   num_fields++;
<a name="l13044"></a>13044                 }
<a name="l13045"></a>13045             }
<a name="l13046"></a>13046 
<a name="l13047"></a>13047           child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l13048"></a>13048         }
<a name="l13049"></a>13049 
<a name="l13050"></a>13050       <span class="keywordflow">if</span> (num_fields)
<a name="l13051"></a>13051         {
<a name="l13052"></a>13052           <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (this_type) = num_fields;
<a name="l13053"></a>13053           <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (this_type) = (<span class="keyword">struct </span>field *)
<a name="l13054"></a>13054             <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (this_type, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> field) * num_fields);
<a name="l13055"></a>13055           <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (this_type), fields,
<a name="l13056"></a>13056                   <span class="keyword">sizeof</span> (<span class="keyword">struct</span> field) * num_fields);
<a name="l13057"></a>13057           <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (fields);
<a name="l13058"></a>13058         }
<a name="l13059"></a>13059       <span class="keywordflow">if</span> (unsigned_enum)
<a name="l13060"></a>13060         <a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">TYPE_UNSIGNED</a> (this_type) = 1;
<a name="l13061"></a>13061       <span class="keywordflow">if</span> (flag_enum)
<a name="l13062"></a>13062         <a class="code" href="gdbtypes_8h.html#aa20f304bcdb858552e049e0fdfd04bac">TYPE_FLAG_ENUM</a> (this_type) = 1;
<a name="l13063"></a>13063     }
<a name="l13064"></a>13064 
<a name="l13065"></a>13065   <span class="comment">/* If we are reading an enum from a .debug_types unit, and the enum</span>
<a name="l13066"></a>13066 <span class="comment">     is a declaration, and the enum is not the signatured type in the</span>
<a name="l13067"></a>13067 <span class="comment">     unit, then we do not want to add a symbol for it.  Adding a</span>
<a name="l13068"></a>13068 <span class="comment">     symbol would in some cases obscure the true definition of the</span>
<a name="l13069"></a>13069 <span class="comment">     enum, giving users an incomplete type when the definition is</span>
<a name="l13070"></a>13070 <span class="comment">     actually available.  Note that we do not want to do this for all</span>
<a name="l13071"></a>13071 <span class="comment">     enums which are just declarations, because C++0x allows forward</span>
<a name="l13072"></a>13072 <span class="comment">     enum declarations.  */</span>
<a name="l13073"></a>13073   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>
<a name="l13074"></a>13074       &amp;&amp; <a class="code" href="dwarf2read_8c.html#aa9ca23caab102417f39b86b7b2716588">die_is_declaration</a> (die, cu))
<a name="l13075"></a>13075     {
<a name="l13076"></a>13076       <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type;
<a name="l13077"></a>13077 
<a name="l13078"></a>13078       sig_type = (<span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *) cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;
<a name="l13079"></a>13079       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sig_type-&gt;<a class="code" href="structsignatured__type.html#aa8e49a69ad9d6311b553b063fa0fe62d">type_offset_in_section</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> != 0);
<a name="l13080"></a>13080       <span class="keywordflow">if</span> (sig_type-&gt;<a class="code" href="structsignatured__type.html#aa8e49a69ad9d6311b553b063fa0fe62d">type_offset_in_section</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> != die-&gt;offset.sect_off)
<a name="l13081"></a>13081         <span class="keywordflow">return</span>;
<a name="l13082"></a>13082     }
<a name="l13083"></a>13083 
<a name="l13084"></a>13084   <a class="code" href="dwarf2read_8c.html#a4b79d225399dba2c4a3397a858440dd4">new_symbol</a> (die, this_type, cu);
<a name="l13085"></a>13085 }
<a name="l13086"></a>13086 
<a name="l13087"></a>13087 <span class="comment">/* Extract all information from a DW_TAG_array_type DIE and put it in</span>
<a name="l13088"></a>13088 <span class="comment">   the DIE&#39;s type field.  For now, this only handles one dimensional</span>
<a name="l13089"></a>13089 <span class="comment">   arrays.  */</span>
<a name="l13090"></a>13090 
<a name="l13091"></a>13091 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l13092"></a><a class="code" href="dwarf2read_8c.html#acd2768b4f079f42297c0946fd77225b5">13092</a> <a class="code" href="dwarf2read_8c.html#acd2768b4f079f42297c0946fd77225b5">read_array_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13093"></a>13093 {
<a name="l13094"></a>13094   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l13095"></a>13095   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_die;
<a name="l13096"></a>13096   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l13097"></a>13097   <span class="keyword">struct </span>type *element_type, *range_type, *index_type;
<a name="l13098"></a>13098   <span class="keyword">struct </span>type **range_types = NULL;
<a name="l13099"></a>13099   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l13100"></a>13100   <span class="keywordtype">int</span> ndim = 0;
<a name="l13101"></a>13101   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to;
<a name="l13102"></a>13102   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l13103"></a>13103 
<a name="l13104"></a>13104   element_type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l13105"></a>13105 
<a name="l13106"></a>13106   <span class="comment">/* The die_type call above may have already set the type for this DIE.  */</span>
<a name="l13107"></a>13107   type = <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu);
<a name="l13108"></a>13108   <span class="keywordflow">if</span> (type)
<a name="l13109"></a>13109     <span class="keywordflow">return</span> <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l13110"></a>13110 
<a name="l13111"></a>13111   <span class="comment">/* Irix 6.2 native cc creates array types without children for</span>
<a name="l13112"></a>13112 <span class="comment">     arrays with unspecified length.  */</span>
<a name="l13113"></a>13113   <span class="keywordflow">if</span> (die-&gt;child == NULL)
<a name="l13114"></a>13114     {
<a name="l13115"></a>13115       index_type = <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a2c06bc9a1e779eb8f0936d386382da9a">builtin_int</a>;
<a name="l13116"></a>13116       range_type = <a class="code" href="gdbtypes_8c.html#ab0885fdae181c47ff3f958bcba70b82d">create_range_type</a> (NULL, index_type, 0, -1);
<a name="l13117"></a>13117       type = <a class="code" href="gdbtypes_8c.html#a779bbebb8202264a73344b49b22d774e">create_array_type</a> (NULL, element_type, range_type);
<a name="l13118"></a>13118       <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l13119"></a>13119     }
<a name="l13120"></a>13120 
<a name="l13121"></a>13121   back_to = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, NULL);
<a name="l13122"></a>13122   child_die = die-&gt;child;
<a name="l13123"></a>13123   <span class="keywordflow">while</span> (child_die &amp;&amp; child_die-&gt;tag)
<a name="l13124"></a>13124     {
<a name="l13125"></a>13125       <span class="keywordflow">if</span> (child_die-&gt;tag == DW_TAG_subrange_type)
<a name="l13126"></a>13126         {
<a name="l13127"></a>13127           <span class="keyword">struct </span>type *child_type = <a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (child_die, cu);
<a name="l13128"></a>13128 
<a name="l13129"></a>13129           <span class="keywordflow">if</span> (child_type != NULL)
<a name="l13130"></a>13130             {
<a name="l13131"></a>13131               <span class="comment">/* The range type was succesfully read.  Save it for the</span>
<a name="l13132"></a>13132 <span class="comment">                 array type creation.  */</span>
<a name="l13133"></a>13133               <span class="keywordflow">if</span> ((ndim % <a class="code" href="dwarf2read_8c.html#aa40456d31b1edb968e39e63c9a8dd42b">DW_FIELD_ALLOC_CHUNK</a>) == 0)
<a name="l13134"></a>13134                 {
<a name="l13135"></a>13135                   range_types = (<span class="keyword">struct </span>type **)
<a name="l13136"></a>13136                     <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (range_types, (ndim + DW_FIELD_ALLOC_CHUNK)
<a name="l13137"></a>13137                               * <span class="keyword">sizeof</span> (<span class="keyword">struct </span>type *));
<a name="l13138"></a>13138                   <span class="keywordflow">if</span> (ndim == 0)
<a name="l13139"></a>13139                     <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="utils_8c.html#a6d8c21606d3f67a431a7bfbb1f47d12e">free_current_contents</a>, &amp;range_types);
<a name="l13140"></a>13140                 }
<a name="l13141"></a>13141               range_types[ndim++] = child_type;
<a name="l13142"></a>13142             }
<a name="l13143"></a>13143         }
<a name="l13144"></a>13144       child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l13145"></a>13145     }
<a name="l13146"></a>13146 
<a name="l13147"></a>13147   <span class="comment">/* Dwarf2 dimensions are output from left to right, create the</span>
<a name="l13148"></a>13148 <span class="comment">     necessary array types in backwards order.  */</span>
<a name="l13149"></a>13149 
<a name="l13150"></a>13150   type = element_type;
<a name="l13151"></a>13151 
<a name="l13152"></a>13152   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ace1105d6c48ca6ab62cfabed4bf7fa40">read_array_order</a> (die, cu) == DW_ORD_col_major)
<a name="l13153"></a>13153     {
<a name="l13154"></a>13154       <span class="keywordtype">int</span> i = 0;
<a name="l13155"></a>13155 
<a name="l13156"></a>13156       <span class="keywordflow">while</span> (i &lt; ndim)
<a name="l13157"></a>13157         type = <a class="code" href="gdbtypes_8c.html#a779bbebb8202264a73344b49b22d774e">create_array_type</a> (NULL, type, range_types[i++]);
<a name="l13158"></a>13158     }
<a name="l13159"></a>13159   <span class="keywordflow">else</span>
<a name="l13160"></a>13160     {
<a name="l13161"></a>13161       <span class="keywordflow">while</span> (ndim-- &gt; 0)
<a name="l13162"></a>13162         type = <a class="code" href="gdbtypes_8c.html#a779bbebb8202264a73344b49b22d774e">create_array_type</a> (NULL, type, range_types[ndim]);
<a name="l13163"></a>13163     }
<a name="l13164"></a>13164 
<a name="l13165"></a>13165   <span class="comment">/* Understand Dwarf2 support for vector types (like they occur on</span>
<a name="l13166"></a>13166 <span class="comment">     the PowerPC w/ AltiVec).  Gcc just adds another attribute to the</span>
<a name="l13167"></a>13167 <span class="comment">     array type.  This is not part of the Dwarf2/3 standard yet, but a</span>
<a name="l13168"></a>13168 <span class="comment">     custom vendor extension.  The main difference between a regular</span>
<a name="l13169"></a>13169 <span class="comment">     array and the vector variant is that vectors are passed by value</span>
<a name="l13170"></a>13170 <span class="comment">     to functions.  */</span>
<a name="l13171"></a>13171   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_GNU_vector, cu);
<a name="l13172"></a>13172   <span class="keywordflow">if</span> (attr)
<a name="l13173"></a>13173     <a class="code" href="gdbtypes_8c.html#af80dd4539475753c833d2a7df64e3060">make_vector_type</a> (type);
<a name="l13174"></a>13174 
<a name="l13175"></a>13175   <span class="comment">/* The DIE may have DW_AT_byte_size set.  For example an OpenCL</span>
<a name="l13176"></a>13176 <span class="comment">     implementation may choose to implement triple vectors using this</span>
<a name="l13177"></a>13177 <span class="comment">     attribute.  */</span>
<a name="l13178"></a>13178   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_byte_size, cu);
<a name="l13179"></a>13179   <span class="keywordflow">if</span> (attr)
<a name="l13180"></a>13180     {
<a name="l13181"></a>13181       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) &gt;= <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type))
<a name="l13182"></a>13182         <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l13183"></a>13183       <span class="keywordflow">else</span>
<a name="l13184"></a>13184         <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l13185"></a>13185                    <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_AT_byte_size for array type smaller &quot;</span>
<a name="l13186"></a>13186                      <span class="stringliteral">&quot;than the total size of elements&quot;</span>));
<a name="l13187"></a>13187     }
<a name="l13188"></a>13188 
<a name="l13189"></a>13189   name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l13190"></a>13190   <span class="keywordflow">if</span> (name)
<a name="l13191"></a>13191     <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l13192"></a>13192 
<a name="l13193"></a>13193   <span class="comment">/* Install the type in the die.  */</span>
<a name="l13194"></a>13194   <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l13195"></a>13195 
<a name="l13196"></a>13196   <span class="comment">/* set_die_type should be already done.  */</span>
<a name="l13197"></a>13197   <a class="code" href="dwarf2read_8c.html#abc906394dd587b9b28825cf6798d43d9">set_descriptive_type</a> (type, die, cu);
<a name="l13198"></a>13198 
<a name="l13199"></a>13199   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l13200"></a>13200 
<a name="l13201"></a>13201   <span class="keywordflow">return</span> <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l13202"></a>13202 }
<a name="l13203"></a>13203 
<a name="l13204"></a>13204 <span class="keyword">static</span> <span class="keyword">enum</span> dwarf_array_dim_ordering
<a name="l13205"></a><a class="code" href="dwarf2read_8c.html#ace1105d6c48ca6ab62cfabed4bf7fa40">13205</a> <a class="code" href="dwarf2read_8c.html#ace1105d6c48ca6ab62cfabed4bf7fa40">read_array_order</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13206"></a>13206 {
<a name="l13207"></a>13207   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l13208"></a>13208 
<a name="l13209"></a>13209   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_ordering, cu);
<a name="l13210"></a>13210 
<a name="l13211"></a>13211   <span class="keywordflow">if</span> (attr) <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a66159661f7b11878469288def232a3e4">DW_SND</a> (attr);
<a name="l13212"></a>13212 
<a name="l13213"></a>13213   <span class="comment">/* GNU F77 is a special case, as at 08/2004 array type info is the</span>
<a name="l13214"></a>13214 <span class="comment">     opposite order to the dwarf2 specification, but data is still</span>
<a name="l13215"></a>13215 <span class="comment">     laid out as per normal fortran.</span>
<a name="l13216"></a>13216 <span class="comment"></span>
<a name="l13217"></a>13217 <span class="comment">     FIXME: dsl/2004-8-20: If G77 is ever fixed, this will also need</span>
<a name="l13218"></a>13218 <span class="comment">     version checking.  */</span>
<a name="l13219"></a>13219 
<a name="l13220"></a>13220   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>
<a name="l13221"></a>13221       &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a> &amp;&amp; <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>, <span class="stringliteral">&quot;GNU F77&quot;</span>))
<a name="l13222"></a>13222     {
<a name="l13223"></a>13223       <span class="keywordflow">return</span> DW_ORD_row_major;
<a name="l13224"></a>13224     }
<a name="l13225"></a>13225 
<a name="l13226"></a>13226   <span class="keywordflow">switch</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa12f3aeef950b4457378c14f9ba16f12">language_defn</a>-&gt;<a class="code" href="structlanguage__defn.html#a77db3625e34c58f90b4b2c67858c309b">la_array_ordering</a>)
<a name="l13227"></a>13227     {
<a name="l13228"></a>13228     <span class="keywordflow">case</span> <a class="code" href="language_8h.html#a01793f9b076697670fa7f9c07d925315af5238ae3d6e0bfcc73a9711051c03a3f">array_column_major</a>:
<a name="l13229"></a>13229       <span class="keywordflow">return</span> DW_ORD_col_major;
<a name="l13230"></a>13230     <span class="keywordflow">case</span> <a class="code" href="language_8h.html#a01793f9b076697670fa7f9c07d925315a8a2dbbdfa4f6850059d3d27c26258d4a">array_row_major</a>:
<a name="l13231"></a>13231     <span class="keywordflow">default</span>:
<a name="l13232"></a>13232       <span class="keywordflow">return</span> DW_ORD_row_major;
<a name="l13233"></a>13233     };
<a name="l13234"></a>13234 }
<a name="l13235"></a>13235 
<a name="l13236"></a>13236 <span class="comment">/* Extract all information from a DW_TAG_set_type DIE and put it in</span>
<a name="l13237"></a>13237 <span class="comment">   the DIE&#39;s type field.  */</span>
<a name="l13238"></a>13238 
<a name="l13239"></a>13239 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l13240"></a><a class="code" href="dwarf2read_8c.html#acedddf0d654aa0b435d336a819051c37">13240</a> <a class="code" href="dwarf2read_8c.html#acedddf0d654aa0b435d336a819051c37">read_set_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13241"></a>13241 {
<a name="l13242"></a>13242   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *domain_type, *<a class="code" href="py-type_8c.html#a9f01c5d05188e8d87ccde0e1f5e4bb34">set_type</a>;
<a name="l13243"></a>13243   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l13244"></a>13244 
<a name="l13245"></a>13245   domain_type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l13246"></a>13246 
<a name="l13247"></a>13247   <span class="comment">/* The die_type call above may have already set the type for this DIE.  */</span>
<a name="l13248"></a>13248   set_type = <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu);
<a name="l13249"></a>13249   <span class="keywordflow">if</span> (set_type)
<a name="l13250"></a>13250     <span class="keywordflow">return</span> <a class="code" href="py-type_8c.html#a9f01c5d05188e8d87ccde0e1f5e4bb34">set_type</a>;
<a name="l13251"></a>13251 
<a name="l13252"></a>13252   set_type = <a class="code" href="gdbtypes_8c.html#a9b379f0366f139b0c80be4898b1f0f7b">create_set_type</a> (NULL, domain_type);
<a name="l13253"></a>13253 
<a name="l13254"></a>13254   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_byte_size, cu);
<a name="l13255"></a>13255   <span class="keywordflow">if</span> (attr)
<a name="l13256"></a>13256     <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (set_type) = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l13257"></a>13257 
<a name="l13258"></a>13258   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, set_type, cu);
<a name="l13259"></a>13259 }
<a name="l13260"></a>13260 
<a name="l13261"></a>13261 <span class="comment">/* A helper for read_common_block that creates a locexpr baton.</span>
<a name="l13262"></a>13262 <span class="comment">   SYM is the symbol which we are marking as computed.</span>
<a name="l13263"></a>13263 <span class="comment">   COMMON_DIE is the DIE for the common block.</span>
<a name="l13264"></a>13264 <span class="comment">   COMMON_LOC is the location expression attribute for the common</span>
<a name="l13265"></a>13265 <span class="comment">   block itself.</span>
<a name="l13266"></a>13266 <span class="comment">   MEMBER_LOC is the location expression attribute for the particular</span>
<a name="l13267"></a>13267 <span class="comment">   member of the common block that we are processing.</span>
<a name="l13268"></a>13268 <span class="comment">   CU is the CU from which the above come.  */</span>
<a name="l13269"></a>13269 
<a name="l13270"></a>13270 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l13271"></a><a class="code" href="dwarf2read_8c.html#a7f0cc4ee3da7c2ce244027d68ce524e1">13271</a> <a class="code" href="dwarf2read_8c.html#a7f0cc4ee3da7c2ce244027d68ce524e1">mark_common_block_symbol_computed</a> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym,
<a name="l13272"></a>13272                                    <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *common_die,
<a name="l13273"></a>13273                                    <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *common_loc,
<a name="l13274"></a>13274                                    <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *member_loc,
<a name="l13275"></a>13275                                    <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13276"></a>13276 {
<a name="l13277"></a>13277   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l13278"></a>13278   <span class="keyword">struct </span><a class="code" href="structdwarf2__locexpr__baton.html">dwarf2_locexpr_baton</a> *baton;
<a name="l13279"></a>13279   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *ptr;
<a name="l13280"></a>13280   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cu_off;
<a name="l13281"></a>13281   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (<a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile));
<a name="l13282"></a>13282   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> offset = 0;
<a name="l13283"></a>13283 
<a name="l13284"></a>13284   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (common_loc &amp;&amp; member_loc);
<a name="l13285"></a>13285   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (common_loc));
<a name="l13286"></a>13286   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (member_loc)
<a name="l13287"></a>13287               || <a class="code" href="dwarf2read_8c.html#a450aaabe2810df0fc34c371aae960580">attr_form_is_constant</a> (member_loc));
<a name="l13288"></a>13288 
<a name="l13289"></a>13289   baton = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l13290"></a>13290                          sizeof (<span class="keyword">struct</span> <a class="code" href="structdwarf2__locexpr__baton.html">dwarf2_locexpr_baton</a>));
<a name="l13291"></a>13291   baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#a4f4c2fcdbde62332afde34a8a95d91fe">per_cu</a> = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;
<a name="l13292"></a>13292   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#a4f4c2fcdbde62332afde34a8a95d91fe">per_cu</a>);
<a name="l13293"></a>13293 
<a name="l13294"></a>13294   baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#aad393a9f0c112b45b23fb0d30c19df07">size</a> = 5 <span class="comment">/* DW_OP_call4 */</span> + 1 <span class="comment">/* DW_OP_plus */</span>;
<a name="l13295"></a>13295 
<a name="l13296"></a>13296   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a450aaabe2810df0fc34c371aae960580">attr_form_is_constant</a> (member_loc))
<a name="l13297"></a>13297     {
<a name="l13298"></a>13298       offset = <a class="code" href="dwarf2read_8c.html#a483ab0874bc41021a77b11c5e6d3b740">dwarf2_get_attr_constant_value</a> (member_loc, 0);
<a name="l13299"></a>13299       baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#aad393a9f0c112b45b23fb0d30c19df07">size</a> += 1 <span class="comment">/* DW_OP_addr */</span> + cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l13300"></a>13300     }
<a name="l13301"></a>13301   <span class="keywordflow">else</span>
<a name="l13302"></a>13302     baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#aad393a9f0c112b45b23fb0d30c19df07">size</a> += <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (member_loc)-&gt;size;
<a name="l13303"></a>13303 
<a name="l13304"></a>13304   ptr = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#aad393a9f0c112b45b23fb0d30c19df07">size</a>);
<a name="l13305"></a>13305   baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#a629a2d12a13c59e34ffc1f64953b5f01">data</a> = ptr;
<a name="l13306"></a>13306 
<a name="l13307"></a>13307   *ptr++ = DW_OP_call4;
<a name="l13308"></a>13308   cu_off = common_die-&gt;offset.sect_off - cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l13309"></a>13309   <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (ptr, 4, byte_order, cu_off);
<a name="l13310"></a>13310   ptr += 4;
<a name="l13311"></a>13311 
<a name="l13312"></a>13312   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a450aaabe2810df0fc34c371aae960580">attr_form_is_constant</a> (member_loc))
<a name="l13313"></a>13313     {
<a name="l13314"></a>13314       *ptr++ = DW_OP_addr;
<a name="l13315"></a>13315       <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (ptr, cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>, byte_order, offset);
<a name="l13316"></a>13316       ptr += cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l13317"></a>13317     }
<a name="l13318"></a>13318   <span class="keywordflow">else</span>
<a name="l13319"></a>13319     {
<a name="l13320"></a>13320       <span class="comment">/* We have to copy the data here, because DW_OP_call4 will only</span>
<a name="l13321"></a>13321 <span class="comment">         use a DW_AT_location attribute.  */</span>
<a name="l13322"></a>13322       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (ptr, <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (member_loc)-&gt;data, <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (member_loc)-&gt;<a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>);
<a name="l13323"></a>13323       ptr += <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (member_loc)-&gt;size;
<a name="l13324"></a>13324     }
<a name="l13325"></a>13325 
<a name="l13326"></a>13326   *ptr++ = DW_OP_plus;
<a name="l13327"></a>13327   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (ptr - baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#a629a2d12a13c59e34ffc1f64953b5f01">data</a> == baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#aad393a9f0c112b45b23fb0d30c19df07">size</a>);
<a name="l13328"></a>13328 
<a name="l13329"></a>13329   <a class="code" href="symtab_8h.html#adf0a8c62c6a593ba1462bc338b95dadf">SYMBOL_LOCATION_BATON</a> (sym) = baton;
<a name="l13330"></a>13330   <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="dwarf2read_8c.html#a52b4c75a920c1e0dbff24148745bc8ca">dwarf2_locexpr_index</a>;
<a name="l13331"></a>13331 }
<a name="l13332"></a>13332 
<a name="l13333"></a>13333 <span class="comment">/* Create appropriate locally-scoped variables for all the</span>
<a name="l13334"></a>13334 <span class="comment">   DW_TAG_common_block entries.  Also create a struct common_block</span>
<a name="l13335"></a>13335 <span class="comment">   listing all such variables for `info common&#39;.  COMMON_BLOCK_DOMAIN</span>
<a name="l13336"></a>13336 <span class="comment">   is used to sepate the common blocks name namespace from regular</span>
<a name="l13337"></a>13337 <span class="comment">   variable names.  */</span>
<a name="l13338"></a>13338 
<a name="l13339"></a>13339 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l13340"></a><a class="code" href="dwarf2read_8c.html#ab5a2e1c5e61bf3e7a380c7da5361549d">13340</a> <a class="code" href="dwarf2read_8c.html#ab5a2e1c5e61bf3e7a380c7da5361549d">read_common_block</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13341"></a>13341 {
<a name="l13342"></a>13342   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l13343"></a>13343 
<a name="l13344"></a>13344   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_location, cu);
<a name="l13345"></a>13345   <span class="keywordflow">if</span> (attr)
<a name="l13346"></a>13346     {
<a name="l13347"></a>13347       <span class="comment">/* Support the .debug_loc offsets.  */</span>
<a name="l13348"></a>13348       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (attr))
<a name="l13349"></a>13349         {
<a name="l13350"></a>13350           <span class="comment">/* Ok.  */</span>
<a name="l13351"></a>13351         }
<a name="l13352"></a>13352       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#aa2b54436e7d13233cd6b866f562f637e">attr_form_is_section_offset</a> (attr))
<a name="l13353"></a>13353         {
<a name="l13354"></a>13354           <a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">dwarf2_complex_location_expr_complaint</a> ();
<a name="l13355"></a>13355           attr = NULL;
<a name="l13356"></a>13356         }
<a name="l13357"></a>13357       <span class="keywordflow">else</span>
<a name="l13358"></a>13358         {
<a name="l13359"></a>13359           <a class="code" href="dwarf2read_8c.html#a0e9c948efe625df13875d3d70d218b65">dwarf2_invalid_attrib_class_complaint</a> (<span class="stringliteral">&quot;DW_AT_location&quot;</span>,
<a name="l13360"></a>13360                                                  <span class="stringliteral">&quot;common block member&quot;</span>);
<a name="l13361"></a>13361           attr = NULL;
<a name="l13362"></a>13362         }
<a name="l13363"></a>13363     }
<a name="l13364"></a>13364 
<a name="l13365"></a>13365   <span class="keywordflow">if</span> (die-&gt;child != NULL)
<a name="l13366"></a>13366     {
<a name="l13367"></a>13367       <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l13368"></a>13368       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_die;
<a name="l13369"></a>13369       <span class="keywordtype">size_t</span> n_entries = 0, <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l13370"></a>13370       <span class="keyword">struct </span><a class="code" href="structcommon__block.html">common_block</a> *<a class="code" href="stabsread_8c.html#a6a85ac610d501f320cf8199406e5b03e">common_block</a>;
<a name="l13371"></a>13371       <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l13372"></a>13372 
<a name="l13373"></a>13373       <span class="keywordflow">for</span> (child_die = die-&gt;child;
<a name="l13374"></a>13374            child_die &amp;&amp; child_die-&gt;tag;
<a name="l13375"></a>13375            child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die))
<a name="l13376"></a>13376         ++n_entries;
<a name="l13377"></a>13377 
<a name="l13378"></a>13378       <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> = (<span class="keyword">sizeof</span> (<span class="keyword">struct </span>common_block)
<a name="l13379"></a>13379               + (n_entries - 1) * <span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *));
<a name="l13380"></a>13380       common_block = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>);
<a name="l13381"></a>13381       <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (common_block-&gt;<a class="code" href="structcommon__block.html#a581a6faf9a8c17a5e28a5f42e666c81c">contents</a>, 0, n_entries * sizeof (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *));
<a name="l13382"></a>13382       common_block-&gt;<a class="code" href="structcommon__block.html#a646db4cf1a782b5f2b53c5e6b6e13d13">n_entries</a> = 0;
<a name="l13383"></a>13383 
<a name="l13384"></a>13384       <span class="keywordflow">for</span> (child_die = die-&gt;child;
<a name="l13385"></a>13385            child_die &amp;&amp; child_die-&gt;tag;
<a name="l13386"></a>13386            child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die))
<a name="l13387"></a>13387         {
<a name="l13388"></a>13388           <span class="comment">/* Create the symbol in the DW_TAG_common_block block in the current</span>
<a name="l13389"></a>13389 <span class="comment">             symbol scope.  */</span>
<a name="l13390"></a>13390           sym = <a class="code" href="dwarf2read_8c.html#a4b79d225399dba2c4a3397a858440dd4">new_symbol</a> (child_die, NULL, cu);
<a name="l13391"></a>13391           <span class="keywordflow">if</span> (sym != NULL)
<a name="l13392"></a>13392             {
<a name="l13393"></a>13393               <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *member_loc;
<a name="l13394"></a>13394 
<a name="l13395"></a>13395               common_block-&gt;<a class="code" href="structcommon__block.html#a581a6faf9a8c17a5e28a5f42e666c81c">contents</a>[common_block-&gt;<a class="code" href="structcommon__block.html#a646db4cf1a782b5f2b53c5e6b6e13d13">n_entries</a>++] = sym;
<a name="l13396"></a>13396 
<a name="l13397"></a>13397               member_loc = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (child_die, DW_AT_data_member_location,
<a name="l13398"></a>13398                                         cu);
<a name="l13399"></a>13399               <span class="keywordflow">if</span> (member_loc)
<a name="l13400"></a>13400                 {
<a name="l13401"></a>13401                   <span class="comment">/* GDB has handled this for a long time, but it is</span>
<a name="l13402"></a>13402 <span class="comment">                     not specified by DWARF.  It seems to have been</span>
<a name="l13403"></a>13403 <span class="comment">                     emitted by gfortran at least as recently as:</span>
<a name="l13404"></a>13404 <span class="comment">                     http://gcc.gnu.org/bugzilla/show_bug.cgi?id=23057.  */</span>
<a name="l13405"></a>13405                   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l13406"></a>13406                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Variable in common block has &quot;</span>
<a name="l13407"></a>13407                                <span class="stringliteral">&quot;DW_AT_data_member_location &quot;</span>
<a name="l13408"></a>13408                                <span class="stringliteral">&quot;- DIE at 0x%x [in module %s]&quot;</span>),
<a name="l13409"></a>13409                              child_die-&gt;offset.sect_off,
<a name="l13410"></a>13410                              <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>));
<a name="l13411"></a>13411 
<a name="l13412"></a>13412                   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#aa2b54436e7d13233cd6b866f562f637e">attr_form_is_section_offset</a> (member_loc))
<a name="l13413"></a>13413                     <a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">dwarf2_complex_location_expr_complaint</a> ();
<a name="l13414"></a>13414                   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a450aaabe2810df0fc34c371aae960580">attr_form_is_constant</a> (member_loc)
<a name="l13415"></a>13415                            || <a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (member_loc))
<a name="l13416"></a>13416                     {
<a name="l13417"></a>13417                       <span class="keywordflow">if</span> (attr)
<a name="l13418"></a>13418                         <a class="code" href="dwarf2read_8c.html#a7f0cc4ee3da7c2ce244027d68ce524e1">mark_common_block_symbol_computed</a> (sym, die, attr,
<a name="l13419"></a>13419                                                            member_loc, cu);
<a name="l13420"></a>13420                     }
<a name="l13421"></a>13421                   <span class="keywordflow">else</span>
<a name="l13422"></a>13422                     <a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">dwarf2_complex_location_expr_complaint</a> ();
<a name="l13423"></a>13423                 }
<a name="l13424"></a>13424             }
<a name="l13425"></a>13425         }
<a name="l13426"></a>13426 
<a name="l13427"></a>13427       sym = <a class="code" href="dwarf2read_8c.html#a4b79d225399dba2c4a3397a858440dd4">new_symbol</a> (die, <a class="code" href="structobjfile__type.html">objfile_type</a> (objfile)-&gt;builtin_void, cu);
<a name="l13428"></a>13428       <a class="code" href="symtab_8h.html#aea3423bbb1edc17982a830972916abcd">SYMBOL_VALUE_COMMON_BLOCK</a> (sym) = <a class="code" href="stabsread_8c.html#a6a85ac610d501f320cf8199406e5b03e">common_block</a>;
<a name="l13429"></a>13429     }
<a name="l13430"></a>13430 }
<a name="l13431"></a>13431 
<a name="l13432"></a>13432 <span class="comment">/* Create a type for a C++ namespace.  */</span>
<a name="l13433"></a>13433 
<a name="l13434"></a>13434 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l13435"></a><a class="code" href="dwarf2read_8c.html#ada8cae48662eacbf63c43ee01bc7933b">13435</a> <a class="code" href="dwarf2read_8c.html#ada8cae48662eacbf63c43ee01bc7933b">read_namespace_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13436"></a>13436 {
<a name="l13437"></a>13437   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l13438"></a>13438   <span class="keyword">const</span> <span class="keywordtype">char</span> *previous_prefix, *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l13439"></a>13439   <span class="keywordtype">int</span> is_anonymous;
<a name="l13440"></a>13440   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l13441"></a>13441 
<a name="l13442"></a>13442   <span class="comment">/* For extensions, reuse the type of the original namespace.  */</span>
<a name="l13443"></a>13443   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_extension, cu) != NULL)
<a name="l13444"></a>13444     {
<a name="l13445"></a>13445       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *ext_die;
<a name="l13446"></a>13446       <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *ext_cu = cu;
<a name="l13447"></a>13447 
<a name="l13448"></a>13448       ext_die = <a class="code" href="dwarf2read_8c.html#a8308114946895d0f9cb9c1ff8a92d115">dwarf2_extension</a> (die, &amp;ext_cu);
<a name="l13449"></a>13449       type = <a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (ext_die, ext_cu);
<a name="l13450"></a>13450 
<a name="l13451"></a>13451       <span class="comment">/* EXT_CU may not be the same as CU.</span>
<a name="l13452"></a>13452 <span class="comment">         Ensure TYPE is recorded with CU in die_type_hash.  */</span>
<a name="l13453"></a>13453       <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l13454"></a>13454     }
<a name="l13455"></a>13455 
<a name="l13456"></a>13456   name = <a class="code" href="dwarf2read_8c.html#aa36ad06e3757cedacef0e32245045b4b">namespace_name</a> (die, &amp;is_anonymous, cu);
<a name="l13457"></a>13457 
<a name="l13458"></a>13458   <span class="comment">/* Now build the name of the current namespace.  */</span>
<a name="l13459"></a>13459 
<a name="l13460"></a>13460   previous_prefix = <a class="code" href="dwarf2read_8c.html#a2417ea09b6b125e47a255352f662e856">determine_prefix</a> (die, cu);
<a name="l13461"></a>13461   <span class="keywordflow">if</span> (previous_prefix[0] != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l13462"></a>13462     name = <a class="code" href="dwarf2read_8c.html#a6abe45afe642868fb22402ce7349ad7f">typename_concat</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l13463"></a>13463                             previous_prefix, name, 0, cu);
<a name="l13464"></a>13464 
<a name="l13465"></a>13465   <span class="comment">/* Create the type.  */</span>
<a name="l13466"></a>13466   type = <a class="code" href="gdbtypes_8c.html#ac74c6d3def8258efc09a3deb8f395d64">init_type</a> (<a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae5cdf73186d3029211503380f64949b6">TYPE_CODE_NAMESPACE</a>, 0, 0, NULL,
<a name="l13467"></a>13467                     objfile);
<a name="l13468"></a>13468   <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l13469"></a>13469   <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) = <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type);
<a name="l13470"></a>13470 
<a name="l13471"></a>13471   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l13472"></a>13472 }
<a name="l13473"></a>13473 
<a name="l13474"></a>13474 <span class="comment">/* Read a C++ namespace.  */</span>
<a name="l13475"></a>13475 
<a name="l13476"></a>13476 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l13477"></a><a class="code" href="dwarf2read_8c.html#aff7ad824d37fcf5d005e0db22721cdef">13477</a> <a class="code" href="dwarf2read_8c.html#aff7ad824d37fcf5d005e0db22721cdef">read_namespace</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13478"></a>13478 {
<a name="l13479"></a>13479   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l13480"></a>13480   <span class="keywordtype">int</span> is_anonymous;
<a name="l13481"></a>13481 
<a name="l13482"></a>13482   <span class="comment">/* Add a symbol associated to this if we haven&#39;t seen the namespace</span>
<a name="l13483"></a>13483 <span class="comment">     before.  Also, add a using directive if it&#39;s an anonymous</span>
<a name="l13484"></a>13484 <span class="comment">     namespace.  */</span>
<a name="l13485"></a>13485 
<a name="l13486"></a>13486   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_extension, cu) == NULL)
<a name="l13487"></a>13487     {
<a name="l13488"></a>13488       <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l13489"></a>13489 
<a name="l13490"></a>13490       type = <a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (die, cu);
<a name="l13491"></a>13491       <a class="code" href="dwarf2read_8c.html#a4b79d225399dba2c4a3397a858440dd4">new_symbol</a> (die, type, cu);
<a name="l13492"></a>13492 
<a name="l13493"></a>13493       <a class="code" href="dwarf2read_8c.html#aa36ad06e3757cedacef0e32245045b4b">namespace_name</a> (die, &amp;is_anonymous, cu);
<a name="l13494"></a>13494       <span class="keywordflow">if</span> (is_anonymous)
<a name="l13495"></a>13495         {
<a name="l13496"></a>13496           <span class="keyword">const</span> <span class="keywordtype">char</span> *previous_prefix = <a class="code" href="dwarf2read_8c.html#a2417ea09b6b125e47a255352f662e856">determine_prefix</a> (die, cu);
<a name="l13497"></a>13497 
<a name="l13498"></a>13498           <a class="code" href="cp-namespace_8c.html#ae89c5f43ecc5264975c8e52ca57f58ef">cp_add_using_directive</a> (previous_prefix, <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type), NULL,
<a name="l13499"></a>13499                                   NULL, NULL, 0, &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>);
<a name="l13500"></a>13500         }
<a name="l13501"></a>13501     }
<a name="l13502"></a>13502 
<a name="l13503"></a>13503   <span class="keywordflow">if</span> (die-&gt;child != NULL)
<a name="l13504"></a>13504     {
<a name="l13505"></a>13505       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_die = die-&gt;child;
<a name="l13506"></a>13506 
<a name="l13507"></a>13507       <span class="keywordflow">while</span> (child_die &amp;&amp; child_die-&gt;tag)
<a name="l13508"></a>13508         {
<a name="l13509"></a>13509           <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (child_die, cu);
<a name="l13510"></a>13510           child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l13511"></a>13511         }
<a name="l13512"></a>13512     }
<a name="l13513"></a>13513 }
<a name="l13514"></a>13514 
<a name="l13515"></a>13515 <span class="comment">/* Read a Fortran module as type.  This DIE can be only a declaration used for</span>
<a name="l13516"></a>13516 <span class="comment">   imported module.  Still we need that type as local Fortran &quot;use ... only&quot;</span>
<a name="l13517"></a>13517 <span class="comment">   declaration imports depend on the created type in determine_prefix.  */</span>
<a name="l13518"></a>13518 
<a name="l13519"></a>13519 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l13520"></a><a class="code" href="dwarf2read_8c.html#a2d1e350c81129a2c7dc6591e4b67267e">13520</a> <a class="code" href="dwarf2read_8c.html#a2d1e350c81129a2c7dc6591e4b67267e">read_module_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13521"></a>13521 {
<a name="l13522"></a>13522   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l13523"></a>13523   <span class="keyword">const</span> <span class="keywordtype">char</span> *module_name;
<a name="l13524"></a>13524   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l13525"></a>13525 
<a name="l13526"></a>13526   module_name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l13527"></a>13527   <span class="keywordflow">if</span> (!module_name)
<a name="l13528"></a>13528     <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l13529"></a>13529                <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_TAG_module has no name, offset 0x%x&quot;</span>),
<a name="l13530"></a>13530                die-&gt;offset.sect_off);
<a name="l13531"></a>13531   type = <a class="code" href="gdbtypes_8c.html#ac74c6d3def8258efc09a3deb8f395d64">init_type</a> (<a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a3da7187b0222a7bd83581aff68c8cd63">TYPE_CODE_MODULE</a>, 0, 0, module_name, objfile);
<a name="l13532"></a>13532 
<a name="l13533"></a>13533   <span class="comment">/* determine_prefix uses TYPE_TAG_NAME.  */</span>
<a name="l13534"></a>13534   <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) = <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type);
<a name="l13535"></a>13535 
<a name="l13536"></a>13536   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l13537"></a>13537 }
<a name="l13538"></a>13538 
<a name="l13539"></a>13539 <span class="comment">/* Read a Fortran module.  */</span>
<a name="l13540"></a>13540 
<a name="l13541"></a>13541 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l13542"></a><a class="code" href="dwarf2read_8c.html#a9f99a9bd45327b2888e42df7832dfdab">13542</a> <a class="code" href="dwarf2read_8c.html#a9f99a9bd45327b2888e42df7832dfdab">read_module</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13543"></a>13543 {
<a name="l13544"></a>13544   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_die = die-&gt;child;
<a name="l13545"></a>13545 
<a name="l13546"></a>13546   <span class="keywordflow">while</span> (child_die &amp;&amp; child_die-&gt;tag)
<a name="l13547"></a>13547     {
<a name="l13548"></a>13548       <a class="code" href="dwarf2read_8c.html#a0e06a4784c643532182fdc78bdda0dda">process_die</a> (child_die, cu);
<a name="l13549"></a>13549       child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l13550"></a>13550     }
<a name="l13551"></a>13551 }
<a name="l13552"></a>13552 
<a name="l13553"></a>13553 <span class="comment">/* Return the name of the namespace represented by DIE.  Set</span>
<a name="l13554"></a>13554 <span class="comment">   *IS_ANONYMOUS to tell whether or not the namespace is an anonymous</span>
<a name="l13555"></a>13555 <span class="comment">   namespace.  */</span>
<a name="l13556"></a>13556 
<a name="l13557"></a>13557 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l13558"></a><a class="code" href="dwarf2read_8c.html#aa36ad06e3757cedacef0e32245045b4b">13558</a> <a class="code" href="dwarf2read_8c.html#aa36ad06e3757cedacef0e32245045b4b">namespace_name</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keywordtype">int</span> *is_anonymous, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13559"></a>13559 {
<a name="l13560"></a>13560   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *current_die;
<a name="l13561"></a>13561   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = NULL;
<a name="l13562"></a>13562 
<a name="l13563"></a>13563   <span class="comment">/* Loop through the extensions until we find a name.  */</span>
<a name="l13564"></a>13564 
<a name="l13565"></a>13565   <span class="keywordflow">for</span> (current_die = die;
<a name="l13566"></a>13566        current_die != NULL;
<a name="l13567"></a>13567        current_die = <a class="code" href="dwarf2read_8c.html#a8308114946895d0f9cb9c1ff8a92d115">dwarf2_extension</a> (die, &amp;cu))
<a name="l13568"></a>13568     {
<a name="l13569"></a>13569       name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (current_die, cu);
<a name="l13570"></a>13570       <span class="keywordflow">if</span> (name != NULL)
<a name="l13571"></a>13571         <span class="keywordflow">break</span>;
<a name="l13572"></a>13572     }
<a name="l13573"></a>13573 
<a name="l13574"></a>13574   <span class="comment">/* Is it an anonymous namespace?  */</span>
<a name="l13575"></a>13575 
<a name="l13576"></a>13576   *is_anonymous = (name == NULL);
<a name="l13577"></a>13577   <span class="keywordflow">if</span> (*is_anonymous)
<a name="l13578"></a>13578     name = <a class="code" href="cp-support_8h.html#a9d4961125aae81ae81b8fbf88512786d">CP_ANONYMOUS_NAMESPACE_STR</a>;
<a name="l13579"></a>13579 
<a name="l13580"></a>13580   <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l13581"></a>13581 }
<a name="l13582"></a>13582 
<a name="l13583"></a>13583 <span class="comment">/* Extract all information from a DW_TAG_pointer_type DIE and add to</span>
<a name="l13584"></a>13584 <span class="comment">   the user defined type vector.  */</span>
<a name="l13585"></a>13585 
<a name="l13586"></a>13586 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l13587"></a><a class="code" href="dwarf2read_8c.html#a129b8da76768577ac923c37c5032d5b3">13587</a> <a class="code" href="dwarf2read_8c.html#a129b8da76768577ac923c37c5032d5b3">read_tag_pointer_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13588"></a>13588 {
<a name="l13589"></a>13589   <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>);
<a name="l13590"></a>13590   <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_header = &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>;
<a name="l13591"></a>13591   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l13592"></a>13592   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr_byte_size;
<a name="l13593"></a>13593   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr_address_class;
<a name="l13594"></a>13594   <span class="keywordtype">int</span> byte_size, addr_class;
<a name="l13595"></a>13595   <span class="keyword">struct </span>type *target_type;
<a name="l13596"></a>13596 
<a name="l13597"></a>13597   target_type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l13598"></a>13598 
<a name="l13599"></a>13599   <span class="comment">/* The die_type call above may have already set the type for this DIE.  */</span>
<a name="l13600"></a>13600   type = <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu);
<a name="l13601"></a>13601   <span class="keywordflow">if</span> (type)
<a name="l13602"></a>13602     <span class="keywordflow">return</span> <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l13603"></a>13603 
<a name="l13604"></a>13604   type = <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (target_type);
<a name="l13605"></a>13605 
<a name="l13606"></a>13606   attr_byte_size = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_byte_size, cu);
<a name="l13607"></a>13607   <span class="keywordflow">if</span> (attr_byte_size)
<a name="l13608"></a>13608     byte_size = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr_byte_size);
<a name="l13609"></a>13609   <span class="keywordflow">else</span>
<a name="l13610"></a>13610     byte_size = cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l13611"></a>13611 
<a name="l13612"></a>13612   attr_address_class = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_address_class, cu);
<a name="l13613"></a>13613   <span class="keywordflow">if</span> (attr_address_class)
<a name="l13614"></a>13614     addr_class = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr_address_class);
<a name="l13615"></a>13615   <span class="keywordflow">else</span>
<a name="l13616"></a>13616     addr_class = DW_ADDR_none;
<a name="l13617"></a>13617 
<a name="l13618"></a>13618   <span class="comment">/* If the pointer size or address class is different than the</span>
<a name="l13619"></a>13619 <span class="comment">     default, create a type variant marked as such and set the</span>
<a name="l13620"></a>13620 <span class="comment">     length accordingly.  */</span>
<a name="l13621"></a>13621   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) != byte_size || addr_class != DW_ADDR_none)
<a name="l13622"></a>13622     {
<a name="l13623"></a>13623       <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#adb85966bf87b7af2a8e1902bc2698fac">gdbarch_address_class_type_flags_p</a> (gdbarch))
<a name="l13624"></a>13624         {
<a name="l13625"></a>13625           <span class="keywordtype">int</span> type_flags;
<a name="l13626"></a>13626 
<a name="l13627"></a>13627           type_flags = <a class="code" href="gdbarch_8c.html#ac6ccefd1f52236b745d06eaa1fd9aae6">gdbarch_address_class_type_flags</a>
<a name="l13628"></a>13628                          (gdbarch, byte_size, addr_class);
<a name="l13629"></a>13629           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> ((type_flags &amp; ~<a class="code" href="gdbtypes_8h.html#a4b64ded0184f9920f572a0f4636e9883">TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL</a>)
<a name="l13630"></a>13630                       == 0);
<a name="l13631"></a>13631           type = <a class="code" href="gdbtypes_8c.html#aad73132bd29e0c9552b8ecf04473241d">make_type_with_address_space</a> (type, type_flags);
<a name="l13632"></a>13632         }
<a name="l13633"></a>13633       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) != byte_size)
<a name="l13634"></a>13634         {
<a name="l13635"></a>13635           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l13636"></a>13636                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;invalid pointer size %d&quot;</span>), byte_size);
<a name="l13637"></a>13637         }
<a name="l13638"></a>13638       <span class="keywordflow">else</span>
<a name="l13639"></a>13639         {
<a name="l13640"></a>13640           <span class="comment">/* Should we also complain about unhandled address classes?  */</span>
<a name="l13641"></a>13641         }
<a name="l13642"></a>13642     }
<a name="l13643"></a>13643 
<a name="l13644"></a>13644   <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = byte_size;
<a name="l13645"></a>13645   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l13646"></a>13646 }
<a name="l13647"></a>13647 
<a name="l13648"></a>13648 <span class="comment">/* Extract all information from a DW_TAG_ptr_to_member_type DIE and add to</span>
<a name="l13649"></a>13649 <span class="comment">   the user defined type vector.  */</span>
<a name="l13650"></a>13650 
<a name="l13651"></a>13651 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l13652"></a><a class="code" href="dwarf2read_8c.html#a7e75df1461a49fb5cbeb691d29d32f84">13652</a> <a class="code" href="dwarf2read_8c.html#a7e75df1461a49fb5cbeb691d29d32f84">read_tag_ptr_to_member_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13653"></a>13653 {
<a name="l13654"></a>13654   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l13655"></a>13655   <span class="keyword">struct </span>type *to_type;
<a name="l13656"></a>13656   <span class="keyword">struct </span>type *domain;
<a name="l13657"></a>13657 
<a name="l13658"></a>13658   to_type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l13659"></a>13659   domain = <a class="code" href="dwarf2read_8c.html#a2ce2b8e439742408e8161e899d9cb67a">die_containing_type</a> (die, cu);
<a name="l13660"></a>13660 
<a name="l13661"></a>13661   <span class="comment">/* The calls above may have already set the type for this DIE.  */</span>
<a name="l13662"></a>13662   type = <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu);
<a name="l13663"></a>13663   <span class="keywordflow">if</span> (type)
<a name="l13664"></a>13664     <span class="keywordflow">return</span> <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l13665"></a>13665 
<a name="l13666"></a>13666   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (to_type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a581771a1410949e8b505dd51426949e9">TYPE_CODE_METHOD</a>)
<a name="l13667"></a>13667     type = <a class="code" href="gdbtypes_8c.html#abe0e31f80a8f4e227727ea42ce596dd9">lookup_methodptr_type</a> (to_type);
<a name="l13668"></a>13668   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (to_type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>)
<a name="l13669"></a>13669     {
<a name="l13670"></a>13670       <span class="keyword">struct </span>type *<a class="code" href="mdebugread_8c.html#ab1ece714ac6020a52b26279dfc1b20d7">new_type</a> = <a class="code" href="gdbtypes_8c.html#a0929c0c96b083ea88998926b06d62d01">alloc_type</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>);
<a name="l13671"></a>13671 
<a name="l13672"></a>13672       <a class="code" href="gdbtypes_8c.html#afae62bb1c2fdb5c6e6dafdbf7d5f935f">smash_to_method_type</a> (new_type, domain, <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (to_type),
<a name="l13673"></a>13673                             <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (to_type), <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (to_type),
<a name="l13674"></a>13674                             <a class="code" href="gdbtypes_8h.html#ac64534be7706a7ed40f5b2de42df4371">TYPE_VARARGS</a> (to_type));
<a name="l13675"></a>13675       type = <a class="code" href="gdbtypes_8c.html#abe0e31f80a8f4e227727ea42ce596dd9">lookup_methodptr_type</a> (new_type);
<a name="l13676"></a>13676     }
<a name="l13677"></a>13677   <span class="keywordflow">else</span>
<a name="l13678"></a>13678     type = <a class="code" href="gdbtypes_8c.html#a133dbb915fedac068ac437460da3d13b">lookup_memberptr_type</a> (to_type, domain);
<a name="l13679"></a>13679 
<a name="l13680"></a>13680   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l13681"></a>13681 }
<a name="l13682"></a>13682 
<a name="l13683"></a>13683 <span class="comment">/* Extract all information from a DW_TAG_reference_type DIE and add to</span>
<a name="l13684"></a>13684 <span class="comment">   the user defined type vector.  */</span>
<a name="l13685"></a>13685 
<a name="l13686"></a>13686 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l13687"></a><a class="code" href="dwarf2read_8c.html#adafa7d9319e91244bbebff956f725617">13687</a> <a class="code" href="dwarf2read_8c.html#adafa7d9319e91244bbebff956f725617">read_tag_reference_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13688"></a>13688 {
<a name="l13689"></a>13689   <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_header = &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>;
<a name="l13690"></a>13690   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>, *target_type;
<a name="l13691"></a>13691   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l13692"></a>13692 
<a name="l13693"></a>13693   target_type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l13694"></a>13694 
<a name="l13695"></a>13695   <span class="comment">/* The die_type call above may have already set the type for this DIE.  */</span>
<a name="l13696"></a>13696   type = <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu);
<a name="l13697"></a>13697   <span class="keywordflow">if</span> (type)
<a name="l13698"></a>13698     <span class="keywordflow">return</span> <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l13699"></a>13699 
<a name="l13700"></a>13700   type = <a class="code" href="gdbtypes_8c.html#afa9bb6a94856e413a9932abea7356e22">lookup_reference_type</a> (target_type);
<a name="l13701"></a>13701   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_byte_size, cu);
<a name="l13702"></a>13702   <span class="keywordflow">if</span> (attr)
<a name="l13703"></a>13703     {
<a name="l13704"></a>13704       <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l13705"></a>13705     }
<a name="l13706"></a>13706   <span class="keywordflow">else</span>
<a name="l13707"></a>13707     {
<a name="l13708"></a>13708       <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l13709"></a>13709     }
<a name="l13710"></a>13710   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l13711"></a>13711 }
<a name="l13712"></a>13712 
<a name="l13713"></a>13713 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l13714"></a><a class="code" href="dwarf2read_8c.html#acb16fe8bbe51e3eafac738ee28c31443">13714</a> <a class="code" href="dwarf2read_8c.html#acb16fe8bbe51e3eafac738ee28c31443">read_tag_const_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13715"></a>13715 {
<a name="l13716"></a>13716   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *base_type, *cv_type;
<a name="l13717"></a>13717 
<a name="l13718"></a>13718   base_type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l13719"></a>13719 
<a name="l13720"></a>13720   <span class="comment">/* The die_type call above may have already set the type for this DIE.  */</span>
<a name="l13721"></a>13721   cv_type = <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu);
<a name="l13722"></a>13722   <span class="keywordflow">if</span> (cv_type)
<a name="l13723"></a>13723     <span class="keywordflow">return</span> cv_type;
<a name="l13724"></a>13724 
<a name="l13725"></a>13725   <span class="comment">/* In case the const qualifier is applied to an array type, the element type</span>
<a name="l13726"></a>13726 <span class="comment">     is so qualified, not the array type (section 6.7.3 of C99).  */</span>
<a name="l13727"></a>13727   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (base_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l13728"></a>13728     {
<a name="l13729"></a>13729       <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *el_type, *inner_array;
<a name="l13730"></a>13730 
<a name="l13731"></a>13731       base_type = <a class="code" href="gdbtypes_8c.html#a73be1910eae6da9c7ec226a3d38beeac">copy_type</a> (base_type);
<a name="l13732"></a>13732       inner_array = base_type;
<a name="l13733"></a>13733 
<a name="l13734"></a>13734       <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (inner_array)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l13735"></a>13735         {
<a name="l13736"></a>13736           <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (inner_array) =
<a name="l13737"></a>13737             <a class="code" href="gdbtypes_8c.html#a73be1910eae6da9c7ec226a3d38beeac">copy_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (inner_array));
<a name="l13738"></a>13738           inner_array = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (inner_array);
<a name="l13739"></a>13739         }
<a name="l13740"></a>13740 
<a name="l13741"></a>13741       el_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (inner_array);
<a name="l13742"></a>13742       <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (inner_array) =
<a name="l13743"></a>13743         <a class="code" href="gdbtypes_8c.html#ab5e31dbb249efdac4f48d4871290bf46">make_cv_type</a> (1, <a class="code" href="gdbtypes_8h.html#a85371642c55e599b0d13fc95d0108ad1">TYPE_VOLATILE</a> (el_type), el_type, NULL);
<a name="l13744"></a>13744 
<a name="l13745"></a>13745       <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, base_type, cu);
<a name="l13746"></a>13746     }
<a name="l13747"></a>13747 
<a name="l13748"></a>13748   cv_type = <a class="code" href="gdbtypes_8c.html#ab5e31dbb249efdac4f48d4871290bf46">make_cv_type</a> (1, <a class="code" href="gdbtypes_8h.html#a85371642c55e599b0d13fc95d0108ad1">TYPE_VOLATILE</a> (base_type), base_type, 0);
<a name="l13749"></a>13749   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, cv_type, cu);
<a name="l13750"></a>13750 }
<a name="l13751"></a>13751 
<a name="l13752"></a>13752 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l13753"></a><a class="code" href="dwarf2read_8c.html#a5276cd2ff93de6b77fcb7120719f84ea">13753</a> <a class="code" href="dwarf2read_8c.html#a5276cd2ff93de6b77fcb7120719f84ea">read_tag_volatile_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13754"></a>13754 {
<a name="l13755"></a>13755   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *base_type, *cv_type;
<a name="l13756"></a>13756 
<a name="l13757"></a>13757   base_type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l13758"></a>13758 
<a name="l13759"></a>13759   <span class="comment">/* The die_type call above may have already set the type for this DIE.  */</span>
<a name="l13760"></a>13760   cv_type = <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu);
<a name="l13761"></a>13761   <span class="keywordflow">if</span> (cv_type)
<a name="l13762"></a>13762     <span class="keywordflow">return</span> cv_type;
<a name="l13763"></a>13763 
<a name="l13764"></a>13764   cv_type = <a class="code" href="gdbtypes_8c.html#ab5e31dbb249efdac4f48d4871290bf46">make_cv_type</a> (<a class="code" href="gdbtypes_8h.html#a82b926a1727ba5c6b856145197495a34">TYPE_CONST</a> (base_type), 1, base_type, 0);
<a name="l13765"></a>13765   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, cv_type, cu);
<a name="l13766"></a>13766 }
<a name="l13767"></a>13767 
<a name="l13768"></a>13768 <span class="comment">/* Handle DW_TAG_restrict_type.  */</span>
<a name="l13769"></a>13769 
<a name="l13770"></a>13770 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l13771"></a><a class="code" href="dwarf2read_8c.html#a391d058296d6101d946a79a6fca703dc">13771</a> <a class="code" href="dwarf2read_8c.html#a391d058296d6101d946a79a6fca703dc">read_tag_restrict_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13772"></a>13772 {
<a name="l13773"></a>13773   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *base_type, *cv_type;
<a name="l13774"></a>13774 
<a name="l13775"></a>13775   base_type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l13776"></a>13776 
<a name="l13777"></a>13777   <span class="comment">/* The die_type call above may have already set the type for this DIE.  */</span>
<a name="l13778"></a>13778   cv_type = <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu);
<a name="l13779"></a>13779   <span class="keywordflow">if</span> (cv_type)
<a name="l13780"></a>13780     <span class="keywordflow">return</span> cv_type;
<a name="l13781"></a>13781 
<a name="l13782"></a>13782   cv_type = <a class="code" href="gdbtypes_8c.html#ae14549e9e4d111171b30b21aa35fa048">make_restrict_type</a> (base_type);
<a name="l13783"></a>13783   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, cv_type, cu);
<a name="l13784"></a>13784 }
<a name="l13785"></a>13785 
<a name="l13786"></a>13786 <span class="comment">/* Extract all information from a DW_TAG_string_type DIE and add to</span>
<a name="l13787"></a>13787 <span class="comment">   the user defined type vector.  It isn&#39;t really a user defined type,</span>
<a name="l13788"></a>13788 <span class="comment">   but it behaves like one, with other DIE&#39;s using an AT_user_def_type</span>
<a name="l13789"></a>13789 <span class="comment">   attribute to reference it.  */</span>
<a name="l13790"></a>13790 
<a name="l13791"></a>13791 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l13792"></a><a class="code" href="dwarf2read_8c.html#a12c451dc793da3bff47faf4f826f8d84">13792</a> <a class="code" href="dwarf2read_8c.html#a12c451dc793da3bff47faf4f826f8d84">read_tag_string_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13793"></a>13793 {
<a name="l13794"></a>13794   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l13795"></a>13795   <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l13796"></a>13796   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>, *range_type, *index_type, *char_type;
<a name="l13797"></a>13797   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l13798"></a>13798   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length;
<a name="l13799"></a>13799 
<a name="l13800"></a>13800   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_string_length, cu);
<a name="l13801"></a>13801   <span class="keywordflow">if</span> (attr)
<a name="l13802"></a>13802     {
<a name="l13803"></a>13803       length = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l13804"></a>13804     }
<a name="l13805"></a>13805   <span class="keywordflow">else</span>
<a name="l13806"></a>13806     {
<a name="l13807"></a>13807       <span class="comment">/* Check for the DW_AT_byte_size attribute.  */</span>
<a name="l13808"></a>13808       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_byte_size, cu);
<a name="l13809"></a>13809       <span class="keywordflow">if</span> (attr)
<a name="l13810"></a>13810         {
<a name="l13811"></a>13811           length = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l13812"></a>13812         }
<a name="l13813"></a>13813       <span class="keywordflow">else</span>
<a name="l13814"></a>13814         {
<a name="l13815"></a>13815           length = 1;
<a name="l13816"></a>13816         }
<a name="l13817"></a>13817     }
<a name="l13818"></a>13818 
<a name="l13819"></a>13819   index_type = <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a2c06bc9a1e779eb8f0936d386382da9a">builtin_int</a>;
<a name="l13820"></a>13820   range_type = <a class="code" href="gdbtypes_8c.html#ab0885fdae181c47ff3f958bcba70b82d">create_range_type</a> (NULL, index_type, 1, length);
<a name="l13821"></a>13821   char_type = <a class="code" href="language_8c.html#ae45e50b29a5a7ba054e3c4b48be7c890">language_string_char_type</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa12f3aeef950b4457378c14f9ba16f12">language_defn</a>, gdbarch);
<a name="l13822"></a>13822   type = <a class="code" href="gdbtypes_8c.html#a02305c2213c2302683719ce68acf0f7e">create_string_type</a> (NULL, char_type, range_type);
<a name="l13823"></a>13823 
<a name="l13824"></a>13824   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l13825"></a>13825 }
<a name="l13826"></a>13826 
<a name="l13827"></a>13827 <span class="comment">/* Assuming that DIE corresponds to a function, returns nonzero</span>
<a name="l13828"></a>13828 <span class="comment">   if the function is prototyped.  */</span>
<a name="l13829"></a>13829 
<a name="l13830"></a>13830 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l13831"></a><a class="code" href="dwarf2read_8c.html#abe8b029b3457442fedacb5e59fc1597b">13831</a> <a class="code" href="dwarf2read_8c.html#abe8b029b3457442fedacb5e59fc1597b">prototyped_function_p</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13832"></a>13832 {
<a name="l13833"></a>13833   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l13834"></a>13834 
<a name="l13835"></a>13835   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_prototyped, cu);
<a name="l13836"></a>13836   <span class="keywordflow">if</span> (attr &amp;&amp; (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) != 0))
<a name="l13837"></a>13837     <span class="keywordflow">return</span> 1;
<a name="l13838"></a>13838 
<a name="l13839"></a>13839   <span class="comment">/* The DWARF standard implies that the DW_AT_prototyped attribute</span>
<a name="l13840"></a>13840 <span class="comment">     is only meaninful for C, but the concept also extends to other</span>
<a name="l13841"></a>13841 <span class="comment">     languages that allow unprototyped functions (Eg: Objective C).</span>
<a name="l13842"></a>13842 <span class="comment">     For all other languages, assume that functions are always</span>
<a name="l13843"></a>13843 <span class="comment">     prototyped.  */</span>
<a name="l13844"></a>13844   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202ad300f80a4c96edb04defba2280620a49">language_c</a>
<a name="l13845"></a>13845       &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202af970f874c431c7404837e92fe971e813">language_objc</a>
<a name="l13846"></a>13846       &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202aa5694c5df3b3a3f33d68b2b7f7d279fb">language_opencl</a>)
<a name="l13847"></a>13847     <span class="keywordflow">return</span> 1;
<a name="l13848"></a>13848 
<a name="l13849"></a>13849   <span class="comment">/* RealView does not emit DW_AT_prototyped.  We can not distinguish</span>
<a name="l13850"></a>13850 <span class="comment">     prototyped and unprototyped functions; default to prototyped,</span>
<a name="l13851"></a>13851 <span class="comment">     since that is more common in modern code (and RealView warns</span>
<a name="l13852"></a>13852 <span class="comment">     about unprototyped functions).  */</span>
<a name="l13853"></a>13853   <span class="keywordflow">if</span> (<a class="code" href="symtab_8c.html#a2b65c6025d0b21b20632a0d5d0b81b31">producer_is_realview</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>))
<a name="l13854"></a>13854     <span class="keywordflow">return</span> 1;
<a name="l13855"></a>13855 
<a name="l13856"></a>13856   <span class="keywordflow">return</span> 0;
<a name="l13857"></a>13857 }
<a name="l13858"></a>13858 
<a name="l13859"></a>13859 <span class="comment">/* Handle DIES due to C code like:</span>
<a name="l13860"></a>13860 <span class="comment"></span>
<a name="l13861"></a>13861 <span class="comment">   struct foo</span>
<a name="l13862"></a>13862 <span class="comment">   {</span>
<a name="l13863"></a>13863 <span class="comment">   int (*funcp)(int a, long l);</span>
<a name="l13864"></a>13864 <span class="comment">   int b;</span>
<a name="l13865"></a>13865 <span class="comment">   };</span>
<a name="l13866"></a>13866 <span class="comment"></span>
<a name="l13867"></a>13867 <span class="comment">   (&#39;funcp&#39; generates a DW_TAG_subroutine_type DIE).  */</span>
<a name="l13868"></a>13868 
<a name="l13869"></a>13869 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l13870"></a><a class="code" href="dwarf2read_8c.html#a036db2ec5896a2ab6de7ceac5a444be1">13870</a> <a class="code" href="dwarf2read_8c.html#a036db2ec5896a2ab6de7ceac5a444be1">read_subroutine_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l13871"></a>13871 {
<a name="l13872"></a>13872   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l13873"></a>13873   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;            <span class="comment">/* Type that this function returns.  */</span>
<a name="l13874"></a>13874   <span class="keyword">struct </span>type *ftype;           <span class="comment">/* Function that returns above type.  */</span>
<a name="l13875"></a>13875   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l13876"></a>13876 
<a name="l13877"></a>13877   type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l13878"></a>13878 
<a name="l13879"></a>13879   <span class="comment">/* The die_type call above may have already set the type for this DIE.  */</span>
<a name="l13880"></a>13880   ftype = <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu);
<a name="l13881"></a>13881   <span class="keywordflow">if</span> (ftype)
<a name="l13882"></a>13882     <span class="keywordflow">return</span> ftype;
<a name="l13883"></a>13883 
<a name="l13884"></a>13884   ftype = <a class="code" href="gdbtypes_8c.html#ab21dd6531306fba2a7078534017df6fb">lookup_function_type</a> (type);
<a name="l13885"></a>13885 
<a name="l13886"></a>13886   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#abe8b029b3457442fedacb5e59fc1597b">prototyped_function_p</a> (die, cu))
<a name="l13887"></a>13887     <a class="code" href="gdbtypes_8h.html#a5d2347eac0eaeab1f00b01beaeb65d2d">TYPE_PROTOTYPED</a> (ftype) = 1;
<a name="l13888"></a>13888 
<a name="l13889"></a>13889   <span class="comment">/* Store the calling convention in the type if it&#39;s available in</span>
<a name="l13890"></a>13890 <span class="comment">     the subroutine die.  Otherwise set the calling convention to</span>
<a name="l13891"></a>13891 <span class="comment">     the default value DW_CC_normal.  */</span>
<a name="l13892"></a>13892   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_calling_convention, cu);
<a name="l13893"></a>13893   <span class="keywordflow">if</span> (attr)
<a name="l13894"></a>13894     <a class="code" href="gdbtypes_8h.html#a80f847a96456b925bec1116fe39f69dc">TYPE_CALLING_CONVENTION</a> (ftype) = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l13895"></a>13895   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a> &amp;&amp; <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>, <span class="stringliteral">&quot;IBM XL C for OpenCL&quot;</span>))
<a name="l13896"></a>13896     <a class="code" href="gdbtypes_8h.html#a80f847a96456b925bec1116fe39f69dc">TYPE_CALLING_CONVENTION</a> (ftype) = DW_CC_GDB_IBM_OpenCL;
<a name="l13897"></a>13897   <span class="keywordflow">else</span>
<a name="l13898"></a>13898     <a class="code" href="gdbtypes_8h.html#a80f847a96456b925bec1116fe39f69dc">TYPE_CALLING_CONVENTION</a> (ftype) = DW_CC_normal;
<a name="l13899"></a>13899 
<a name="l13900"></a>13900   <span class="comment">/* We need to add the subroutine type to the die immediately so</span>
<a name="l13901"></a>13901 <span class="comment">     we don&#39;t infinitely recurse when dealing with parameters</span>
<a name="l13902"></a>13902 <span class="comment">     declared as the same subroutine type.  */</span>
<a name="l13903"></a>13903   <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, ftype, cu);
<a name="l13904"></a>13904 
<a name="l13905"></a>13905   <span class="keywordflow">if</span> (die-&gt;child != NULL)
<a name="l13906"></a>13906     {
<a name="l13907"></a>13907       <span class="keyword">struct </span>type *void_type = <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a4143df3933c553aa6f862ea7d3140151">builtin_void</a>;
<a name="l13908"></a>13908       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child_die;
<a name="l13909"></a>13909       <span class="keywordtype">int</span> nparams, iparams;
<a name="l13910"></a>13910 
<a name="l13911"></a>13911       <span class="comment">/* Count the number of parameters.</span>
<a name="l13912"></a>13912 <span class="comment">         FIXME: GDB currently ignores vararg functions, but knows about</span>
<a name="l13913"></a>13913 <span class="comment">         vararg member functions.  */</span>
<a name="l13914"></a>13914       nparams = 0;
<a name="l13915"></a>13915       child_die = die-&gt;child;
<a name="l13916"></a>13916       <span class="keywordflow">while</span> (child_die &amp;&amp; child_die-&gt;tag)
<a name="l13917"></a>13917         {
<a name="l13918"></a>13918           <span class="keywordflow">if</span> (child_die-&gt;tag == DW_TAG_formal_parameter)
<a name="l13919"></a>13919             nparams++;
<a name="l13920"></a>13920           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (child_die-&gt;tag == DW_TAG_unspecified_parameters)
<a name="l13921"></a>13921             <a class="code" href="gdbtypes_8h.html#ac64534be7706a7ed40f5b2de42df4371">TYPE_VARARGS</a> (ftype) = 1;
<a name="l13922"></a>13922           child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l13923"></a>13923         }
<a name="l13924"></a>13924 
<a name="l13925"></a>13925       <span class="comment">/* Allocate storage for parameters and fill them in.  */</span>
<a name="l13926"></a>13926       <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (ftype) = nparams;
<a name="l13927"></a>13927       <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (ftype) = (<span class="keyword">struct </span>field *)
<a name="l13928"></a>13928         <a class="code" href="gdbtypes_8h.html#a01507b6808623c0c49a222acac6f841c">TYPE_ZALLOC</a> (ftype, nparams * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> field));
<a name="l13929"></a>13929 
<a name="l13930"></a>13930       <span class="comment">/* TYPE_FIELD_TYPE must never be NULL.  Pre-fill the array to ensure it</span>
<a name="l13931"></a>13931 <span class="comment">         even if we error out during the parameters reading below.  */</span>
<a name="l13932"></a>13932       <span class="keywordflow">for</span> (iparams = 0; iparams &lt; nparams; iparams++)
<a name="l13933"></a>13933         <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (ftype, iparams) = void_type;
<a name="l13934"></a>13934 
<a name="l13935"></a>13935       iparams = 0;
<a name="l13936"></a>13936       child_die = die-&gt;child;
<a name="l13937"></a>13937       <span class="keywordflow">while</span> (child_die &amp;&amp; child_die-&gt;tag)
<a name="l13938"></a>13938         {
<a name="l13939"></a>13939           <span class="keywordflow">if</span> (child_die-&gt;tag == DW_TAG_formal_parameter)
<a name="l13940"></a>13940             {
<a name="l13941"></a>13941               <span class="keyword">struct </span>type *arg_type;
<a name="l13942"></a>13942 
<a name="l13943"></a>13943               <span class="comment">/* DWARF version 2 has no clean way to discern C++</span>
<a name="l13944"></a>13944 <span class="comment">                 static and non-static member functions.  G++ helps</span>
<a name="l13945"></a>13945 <span class="comment">                 GDB by marking the first parameter for non-static</span>
<a name="l13946"></a>13946 <span class="comment">                 member functions (which is the this pointer) as</span>
<a name="l13947"></a>13947 <span class="comment">                 artificial.  We pass this information to</span>
<a name="l13948"></a>13948 <span class="comment">                 dwarf2_add_member_fn via TYPE_FIELD_ARTIFICIAL.</span>
<a name="l13949"></a>13949 <span class="comment"></span>
<a name="l13950"></a>13950 <span class="comment">                 DWARF version 3 added DW_AT_object_pointer, which GCC</span>
<a name="l13951"></a>13951 <span class="comment">                 4.5 does not yet generate.  */</span>
<a name="l13952"></a>13952               attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (child_die, DW_AT_artificial, cu);
<a name="l13953"></a>13953               <span class="keywordflow">if</span> (attr)
<a name="l13954"></a>13954                 <a class="code" href="gdbtypes_8h.html#aa2bb2f58f95f604830c665368481946d">TYPE_FIELD_ARTIFICIAL</a> (ftype, iparams) = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l13955"></a>13955               <span class="keywordflow">else</span>
<a name="l13956"></a>13956                 {
<a name="l13957"></a>13957                   <a class="code" href="gdbtypes_8h.html#aa2bb2f58f95f604830c665368481946d">TYPE_FIELD_ARTIFICIAL</a> (ftype, iparams) = 0;
<a name="l13958"></a>13958 
<a name="l13959"></a>13959                   <span class="comment">/* GCC/43521: In java, the formal parameter</span>
<a name="l13960"></a>13960 <span class="comment">                     &quot;this&quot; is sometimes not marked with DW_AT_artificial.  */</span>
<a name="l13961"></a>13961                   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>)
<a name="l13962"></a>13962                     {
<a name="l13963"></a>13963                       <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (child_die, cu);
<a name="l13964"></a>13964 
<a name="l13965"></a>13965                       <span class="keywordflow">if</span> (name &amp;&amp; !strcmp (name, <span class="stringliteral">&quot;this&quot;</span>))
<a name="l13966"></a>13966                         <a class="code" href="gdbtypes_8h.html#aa2bb2f58f95f604830c665368481946d">TYPE_FIELD_ARTIFICIAL</a> (ftype, iparams) = 1;
<a name="l13967"></a>13967                     }
<a name="l13968"></a>13968                 }
<a name="l13969"></a>13969               arg_type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (child_die, cu);
<a name="l13970"></a>13970 
<a name="l13971"></a>13971               <span class="comment">/* RealView does not mark THIS as const, which the testsuite</span>
<a name="l13972"></a>13972 <span class="comment">                 expects.  GCC marks THIS as const in method definitions,</span>
<a name="l13973"></a>13973 <span class="comment">                 but not in the class specifications (GCC PR 43053).  */</span>
<a name="l13974"></a>13974               <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a> &amp;&amp; !<a class="code" href="gdbtypes_8h.html#a82b926a1727ba5c6b856145197495a34">TYPE_CONST</a> (arg_type)
<a name="l13975"></a>13975                   &amp;&amp; <a class="code" href="gdbtypes_8h.html#aa2bb2f58f95f604830c665368481946d">TYPE_FIELD_ARTIFICIAL</a> (ftype, iparams))
<a name="l13976"></a>13976                 {
<a name="l13977"></a>13977                   <span class="keywordtype">int</span> is_this = 0;
<a name="l13978"></a>13978                   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *arg_cu = cu;
<a name="l13979"></a>13979                   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (child_die, cu);
<a name="l13980"></a>13980 
<a name="l13981"></a>13981                   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_object_pointer, cu);
<a name="l13982"></a>13982                   <span class="keywordflow">if</span> (attr)
<a name="l13983"></a>13983                     {
<a name="l13984"></a>13984                       <span class="comment">/* If the compiler emits this, use it.  */</span>
<a name="l13985"></a>13985                       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a079b531fef51cfc34f92ff6fde2ef8a4">follow_die_ref</a> (die, attr, &amp;arg_cu) == child_die)
<a name="l13986"></a>13986                         is_this = 1;
<a name="l13987"></a>13987                     }
<a name="l13988"></a>13988                   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name &amp;&amp; strcmp (name, <span class="stringliteral">&quot;this&quot;</span>) == 0)
<a name="l13989"></a>13989                     <span class="comment">/* Function definitions will have the argument names.  */</span>
<a name="l13990"></a>13990                     is_this = 1;
<a name="l13991"></a>13991                   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == NULL &amp;&amp; iparams == 0)
<a name="l13992"></a>13992                     <span class="comment">/* Declarations may not have the names, so like</span>
<a name="l13993"></a>13993 <span class="comment">                       elsewhere in GDB, assume an artificial first</span>
<a name="l13994"></a>13994 <span class="comment">                       argument is &quot;this&quot;.  */</span>
<a name="l13995"></a>13995                     is_this = 1;
<a name="l13996"></a>13996 
<a name="l13997"></a>13997                   <span class="keywordflow">if</span> (is_this)
<a name="l13998"></a>13998                     arg_type = <a class="code" href="gdbtypes_8c.html#ab5e31dbb249efdac4f48d4871290bf46">make_cv_type</a> (1, <a class="code" href="gdbtypes_8h.html#a85371642c55e599b0d13fc95d0108ad1">TYPE_VOLATILE</a> (arg_type),
<a name="l13999"></a>13999                                              arg_type, 0);
<a name="l14000"></a>14000                 }
<a name="l14001"></a>14001 
<a name="l14002"></a>14002               <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (ftype, iparams) = arg_type;
<a name="l14003"></a>14003               iparams++;
<a name="l14004"></a>14004             }
<a name="l14005"></a>14005           child_die = <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (child_die);
<a name="l14006"></a>14006         }
<a name="l14007"></a>14007     }
<a name="l14008"></a>14008 
<a name="l14009"></a>14009   <span class="keywordflow">return</span> ftype;
<a name="l14010"></a>14010 }
<a name="l14011"></a>14011 
<a name="l14012"></a>14012 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l14013"></a><a class="code" href="dwarf2read_8c.html#a26cc54e0bf4355982c4039050812f08c">14013</a> <a class="code" href="dwarf2read_8c.html#a26cc54e0bf4355982c4039050812f08c">read_typedef</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l14014"></a>14014 {
<a name="l14015"></a>14015   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l14016"></a>14016   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = NULL;
<a name="l14017"></a>14017   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *this_type, *target_type;
<a name="l14018"></a>14018 
<a name="l14019"></a>14019   name = <a class="code" href="dwarf2read_8c.html#a01de8f373799ebb39da7b5758619ec4c">dwarf2_full_name</a> (NULL, die, cu);
<a name="l14020"></a>14020   this_type = <a class="code" href="gdbtypes_8c.html#ac74c6d3def8258efc09a3deb8f395d64">init_type</a> (<a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>, 0,
<a name="l14021"></a>14021                          <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a8b821aa79807aa1534d00eb24e37fdc6">TYPE_FLAG_TARGET_STUB</a>, NULL, objfile);
<a name="l14022"></a>14022   <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (this_type) = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l14023"></a>14023   <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, this_type, cu);
<a name="l14024"></a>14024   target_type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l14025"></a>14025   <span class="keywordflow">if</span> (target_type != this_type)
<a name="l14026"></a>14026     <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (this_type) = target_type;
<a name="l14027"></a>14027   <span class="keywordflow">else</span>
<a name="l14028"></a>14028     {
<a name="l14029"></a>14029       <span class="comment">/* Self-referential typedefs are, it seems, not allowed by the DWARF</span>
<a name="l14030"></a>14030 <span class="comment">         spec and cause infinite loops in GDB.  */</span>
<a name="l14031"></a>14031       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l14032"></a>14032                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Self-referential DW_TAG_typedef &quot;</span>
<a name="l14033"></a>14033                    <span class="stringliteral">&quot;- DIE at 0x%x [in module %s]&quot;</span>),
<a name="l14034"></a>14034                  die-&gt;offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l14035"></a>14035       <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (this_type) = NULL;
<a name="l14036"></a>14036     }
<a name="l14037"></a>14037   <span class="keywordflow">return</span> this_type;
<a name="l14038"></a>14038 }
<a name="l14039"></a>14039 
<a name="l14040"></a>14040 <span class="comment">/* Find a representation of a given base type and install</span>
<a name="l14041"></a>14041 <span class="comment">   it in the TYPE field of the die.  */</span>
<a name="l14042"></a>14042 
<a name="l14043"></a>14043 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l14044"></a><a class="code" href="dwarf2read_8c.html#a869473b2da0ab4c33c5b185c316b6bc9">14044</a> <a class="code" href="dwarf2read_8c.html#a869473b2da0ab4c33c5b185c316b6bc9">read_base_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l14045"></a>14045 {
<a name="l14046"></a>14046   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l14047"></a>14047   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l14048"></a>14048   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l14049"></a>14049   <span class="keywordtype">int</span> <a class="code" href="remote-mips_8c.html#a6054357a716d1736062d17be60d31a02">encoding</a> = 0, <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> = 0;
<a name="l14050"></a>14050   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l14051"></a>14051   <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> <a class="code" href="ser-unix_8c.html#a45a5b7c00a796a23f01673cef1dbe0a9">code</a> = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>;
<a name="l14052"></a>14052   <span class="keywordtype">int</span> type_flags = 0;
<a name="l14053"></a>14053   <span class="keyword">struct </span>type *target_type = NULL;
<a name="l14054"></a>14054 
<a name="l14055"></a>14055   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_encoding, cu);
<a name="l14056"></a>14056   <span class="keywordflow">if</span> (attr)
<a name="l14057"></a>14057     {
<a name="l14058"></a>14058       encoding = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l14059"></a>14059     }
<a name="l14060"></a>14060   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_byte_size, cu);
<a name="l14061"></a>14061   <span class="keywordflow">if</span> (attr)
<a name="l14062"></a>14062     {
<a name="l14063"></a>14063       <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l14064"></a>14064     }
<a name="l14065"></a>14065   name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l14066"></a>14066   <span class="keywordflow">if</span> (!name)
<a name="l14067"></a>14067     {
<a name="l14068"></a>14068       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l14069"></a>14069                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_AT_name missing from DW_TAG_base_type&quot;</span>));
<a name="l14070"></a>14070     }
<a name="l14071"></a>14071 
<a name="l14072"></a>14072   <span class="keywordflow">switch</span> (encoding)
<a name="l14073"></a>14073     {
<a name="l14074"></a>14074       <span class="keywordflow">case</span> DW_ATE_address:
<a name="l14075"></a>14075         <span class="comment">/* Turn DW_ATE_address into a void * pointer.  */</span>
<a name="l14076"></a>14076         code = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>;
<a name="l14077"></a>14077         type_flags |= <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9aa6b8e0a7b0ed2628130fd531fe22d596">TYPE_FLAG_UNSIGNED</a>;
<a name="l14078"></a>14078         target_type = <a class="code" href="gdbtypes_8c.html#ac74c6d3def8258efc09a3deb8f395d64">init_type</a> (<a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>, 1, 0, NULL, objfile);
<a name="l14079"></a>14079         <span class="keywordflow">break</span>;
<a name="l14080"></a>14080       <span class="keywordflow">case</span> DW_ATE_boolean:
<a name="l14081"></a>14081         code = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462afbf0aa0241df408e1017ae7ff8e6798c">TYPE_CODE_BOOL</a>;
<a name="l14082"></a>14082         type_flags |= <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9aa6b8e0a7b0ed2628130fd531fe22d596">TYPE_FLAG_UNSIGNED</a>;
<a name="l14083"></a>14083         <span class="keywordflow">break</span>;
<a name="l14084"></a>14084       <span class="keywordflow">case</span> DW_ATE_complex_float:
<a name="l14085"></a>14085         code = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad8de4d143b624cd2bcab740a51a04658">TYPE_CODE_COMPLEX</a>;
<a name="l14086"></a>14086         target_type = <a class="code" href="gdbtypes_8c.html#ac74c6d3def8258efc09a3deb8f395d64">init_type</a> (<a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>, <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> / 2, 0, NULL, objfile);
<a name="l14087"></a>14087         <span class="keywordflow">break</span>;
<a name="l14088"></a>14088       <span class="keywordflow">case</span> DW_ATE_decimal_float:
<a name="l14089"></a>14089         code = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ace4e1a5aff0ea601f04c6f25eb8ed47b">TYPE_CODE_DECFLOAT</a>;
<a name="l14090"></a>14090         <span class="keywordflow">break</span>;
<a name="l14091"></a>14091       <span class="keywordflow">case</span> DW_ATE_float:
<a name="l14092"></a>14092         code = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>;
<a name="l14093"></a>14093         <span class="keywordflow">break</span>;
<a name="l14094"></a>14094       <span class="keywordflow">case</span> DW_ATE_signed:
<a name="l14095"></a>14095         <span class="keywordflow">break</span>;
<a name="l14096"></a>14096       <span class="keywordflow">case</span> DW_ATE_unsigned:
<a name="l14097"></a>14097         type_flags |= <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9aa6b8e0a7b0ed2628130fd531fe22d596">TYPE_FLAG_UNSIGNED</a>;
<a name="l14098"></a>14098         <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>
<a name="l14099"></a>14099             &amp;&amp; name
<a name="l14100"></a>14100             &amp;&amp; strncmp (name, <span class="stringliteral">&quot;character(&quot;</span>, <span class="keyword">sizeof</span> (<span class="stringliteral">&quot;character(&quot;</span>) - 1) == 0)
<a name="l14101"></a>14101           code = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae991dd7ea70631f3e1b67a1a75020b5f">TYPE_CODE_CHAR</a>;
<a name="l14102"></a>14102         <span class="keywordflow">break</span>;
<a name="l14103"></a>14103       <span class="keywordflow">case</span> DW_ATE_signed_char:
<a name="l14104"></a>14104         <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a> || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a24814ec1696c6cf0b223224d0f54b2a7">language_m2</a>
<a name="l14105"></a>14105             || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202aabc6aaebbfda1ac216522364b89db30c">language_pascal</a>
<a name="l14106"></a>14106             || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>)
<a name="l14107"></a>14107           code = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae991dd7ea70631f3e1b67a1a75020b5f">TYPE_CODE_CHAR</a>;
<a name="l14108"></a>14108         <span class="keywordflow">break</span>;
<a name="l14109"></a>14109       <span class="keywordflow">case</span> DW_ATE_unsigned_char:
<a name="l14110"></a>14110         <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a> || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a24814ec1696c6cf0b223224d0f54b2a7">language_m2</a>
<a name="l14111"></a>14111             || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202aabc6aaebbfda1ac216522364b89db30c">language_pascal</a>
<a name="l14112"></a>14112             || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>)
<a name="l14113"></a>14113           code = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae991dd7ea70631f3e1b67a1a75020b5f">TYPE_CODE_CHAR</a>;
<a name="l14114"></a>14114         type_flags |= <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9aa6b8e0a7b0ed2628130fd531fe22d596">TYPE_FLAG_UNSIGNED</a>;
<a name="l14115"></a>14115         <span class="keywordflow">break</span>;
<a name="l14116"></a>14116       <span class="keywordflow">case</span> DW_ATE_UTF:
<a name="l14117"></a>14117         <span class="comment">/* We just treat this as an integer and then recognize the</span>
<a name="l14118"></a>14118 <span class="comment">           type by name elsewhere.  */</span>
<a name="l14119"></a>14119         <span class="keywordflow">break</span>;
<a name="l14120"></a>14120 
<a name="l14121"></a>14121       <span class="keywordflow">default</span>:
<a name="l14122"></a>14122         <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unsupported DW_AT_encoding: &#39;%s&#39;&quot;</span>),
<a name="l14123"></a>14123                    <a class="code" href="dwarf2read_8c.html#a0a45f38cd8954cc90b8f97f03e1effd3">dwarf_type_encoding_name</a> (encoding));
<a name="l14124"></a>14124         <span class="keywordflow">break</span>;
<a name="l14125"></a>14125     }
<a name="l14126"></a>14126 
<a name="l14127"></a>14127   type = <a class="code" href="gdbtypes_8c.html#ac74c6d3def8258efc09a3deb8f395d64">init_type</a> (code, <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>, type_flags, NULL, objfile);
<a name="l14128"></a>14128   <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l14129"></a>14129   <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type) = target_type;
<a name="l14130"></a>14130 
<a name="l14131"></a>14131   <span class="keywordflow">if</span> (name &amp;&amp; strcmp (name, <span class="stringliteral">&quot;char&quot;</span>) == 0)
<a name="l14132"></a>14132     <a class="code" href="gdbtypes_8h.html#a072c2a4284516f56accc85be90546a30">TYPE_NOSIGN</a> (type) = 1;
<a name="l14133"></a>14133 
<a name="l14134"></a>14134   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l14135"></a>14135 }
<a name="l14136"></a>14136 
<a name="l14137"></a>14137 <span class="comment">/* Read the given DW_AT_subrange DIE.  */</span>
<a name="l14138"></a>14138 
<a name="l14139"></a>14139 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l14140"></a><a class="code" href="dwarf2read_8c.html#a8749190a8e238fcc0fb7cb25f8d0f2ce">14140</a> <a class="code" href="dwarf2read_8c.html#a8749190a8e238fcc0fb7cb25f8d0f2ce">read_subrange_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l14141"></a>14141 {
<a name="l14142"></a>14142   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *base_type, *orig_base_type;
<a name="l14143"></a>14143   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *range_type;
<a name="l14144"></a>14144   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l14145"></a>14145   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> low, high;
<a name="l14146"></a>14146   <span class="keywordtype">int</span> low_default_is_valid;
<a name="l14147"></a>14147   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l14148"></a>14148   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> negative_mask;
<a name="l14149"></a>14149 
<a name="l14150"></a>14150   orig_base_type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l14151"></a>14151   <span class="comment">/* If ORIG_BASE_TYPE is a typedef, it will not be TYPE_UNSIGNED,</span>
<a name="l14152"></a>14152 <span class="comment">     whereas the real type might be.  So, we use ORIG_BASE_TYPE when</span>
<a name="l14153"></a>14153 <span class="comment">     creating the range type, but we use the result of check_typedef</span>
<a name="l14154"></a>14154 <span class="comment">     when examining properties of the type.  */</span>
<a name="l14155"></a>14155   base_type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (orig_base_type);
<a name="l14156"></a>14156 
<a name="l14157"></a>14157   <span class="comment">/* The die_type call above may have already set the type for this DIE.  */</span>
<a name="l14158"></a>14158   range_type = <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu);
<a name="l14159"></a>14159   <span class="keywordflow">if</span> (range_type)
<a name="l14160"></a>14160     <span class="keywordflow">return</span> range_type;
<a name="l14161"></a>14161 
<a name="l14162"></a>14162   <span class="comment">/* Set LOW_DEFAULT_IS_VALID if current language and DWARF version allow</span>
<a name="l14163"></a>14163 <span class="comment">     omitting DW_AT_lower_bound.  */</span>
<a name="l14164"></a>14164   <span class="keywordflow">switch</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>)
<a name="l14165"></a>14165     {
<a name="l14166"></a>14166     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202ad300f80a4c96edb04defba2280620a49">language_c</a>:
<a name="l14167"></a>14167     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>:
<a name="l14168"></a>14168       low = 0;
<a name="l14169"></a>14169       low_default_is_valid = 1;
<a name="l14170"></a>14170       <span class="keywordflow">break</span>;
<a name="l14171"></a>14171     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>:
<a name="l14172"></a>14172       low = 1;
<a name="l14173"></a>14173       low_default_is_valid = 1;
<a name="l14174"></a>14174       <span class="keywordflow">break</span>;
<a name="l14175"></a>14175     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202ad3b00d43bb1174a9e66b236f872514f9">language_d</a>:
<a name="l14176"></a>14176     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>:
<a name="l14177"></a>14177     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202af970f874c431c7404837e92fe971e813">language_objc</a>:
<a name="l14178"></a>14178       low = 0;
<a name="l14179"></a>14179       low_default_is_valid = (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a68d6c482c646af0266771ad56b73748d">version</a> &gt;= 4);
<a name="l14180"></a>14180       <span class="keywordflow">break</span>;
<a name="l14181"></a>14181     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>:
<a name="l14182"></a>14182     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a24814ec1696c6cf0b223224d0f54b2a7">language_m2</a>:
<a name="l14183"></a>14183     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202aabc6aaebbfda1ac216522364b89db30c">language_pascal</a>:
<a name="l14184"></a>14184       low = 1;
<a name="l14185"></a>14185       low_default_is_valid = (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a68d6c482c646af0266771ad56b73748d">version</a> &gt;= 4);
<a name="l14186"></a>14186       <span class="keywordflow">break</span>;
<a name="l14187"></a>14187     <span class="keywordflow">default</span>:
<a name="l14188"></a>14188       low = 0;
<a name="l14189"></a>14189       low_default_is_valid = 0;
<a name="l14190"></a>14190       <span class="keywordflow">break</span>;
<a name="l14191"></a>14191     }
<a name="l14192"></a>14192 
<a name="l14193"></a>14193   <span class="comment">/* FIXME: For variable sized arrays either of these could be</span>
<a name="l14194"></a>14194 <span class="comment">     a variable rather than a constant value.  We&#39;ll allow it,</span>
<a name="l14195"></a>14195 <span class="comment">     but we don&#39;t know how to handle it.  */</span>
<a name="l14196"></a>14196   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_lower_bound, cu);
<a name="l14197"></a>14197   <span class="keywordflow">if</span> (attr)
<a name="l14198"></a>14198     low = <a class="code" href="dwarf2read_8c.html#a483ab0874bc41021a77b11c5e6d3b740">dwarf2_get_attr_constant_value</a> (attr, low);
<a name="l14199"></a>14199   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!low_default_is_valid)
<a name="l14200"></a>14200     <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Missing DW_AT_lower_bound &quot;</span>
<a name="l14201"></a>14201                                       <span class="stringliteral">&quot;- DIE at 0x%x [in module %s]&quot;</span>),
<a name="l14202"></a>14202                die-&gt;offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>));
<a name="l14203"></a>14203 
<a name="l14204"></a>14204   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_upper_bound, cu);
<a name="l14205"></a>14205   <span class="keywordflow">if</span> (attr)
<a name="l14206"></a>14206     {
<a name="l14207"></a>14207       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (attr) || <a class="code" href="dwarf2read_8c.html#a217d4eb87ed57947007169e88bb2a0f9">attr_form_is_ref</a> (attr))
<a name="l14208"></a>14208         {
<a name="l14209"></a>14209           <span class="comment">/* GCC encodes arrays with unspecified or dynamic length</span>
<a name="l14210"></a>14210 <span class="comment">             with a DW_FORM_block1 attribute or a reference attribute.</span>
<a name="l14211"></a>14211 <span class="comment">             FIXME: GDB does not yet know how to handle dynamic</span>
<a name="l14212"></a>14212 <span class="comment">             arrays properly, treat them as arrays with unspecified</span>
<a name="l14213"></a>14213 <span class="comment">             length for now.</span>
<a name="l14214"></a>14214 <span class="comment"></span>
<a name="l14215"></a>14215 <span class="comment">             FIXME: jimb/2003-09-22: GDB does not really know</span>
<a name="l14216"></a>14216 <span class="comment">             how to handle arrays of unspecified length</span>
<a name="l14217"></a>14217 <span class="comment">             either; we just represent them as zero-length</span>
<a name="l14218"></a>14218 <span class="comment">             arrays.  Choose an appropriate upper bound given</span>
<a name="l14219"></a>14219 <span class="comment">             the lower bound we&#39;ve computed above.  */</span>
<a name="l14220"></a>14220           high = low - 1;
<a name="l14221"></a>14221         }
<a name="l14222"></a>14222       <span class="keywordflow">else</span>
<a name="l14223"></a>14223         high = <a class="code" href="dwarf2read_8c.html#a483ab0874bc41021a77b11c5e6d3b740">dwarf2_get_attr_constant_value</a> (attr, 1);
<a name="l14224"></a>14224     }
<a name="l14225"></a>14225   <span class="keywordflow">else</span>
<a name="l14226"></a>14226     {
<a name="l14227"></a>14227       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_count, cu);
<a name="l14228"></a>14228       <span class="keywordflow">if</span> (attr)
<a name="l14229"></a>14229         {
<a name="l14230"></a>14230           <span class="keywordtype">int</span> count = <a class="code" href="dwarf2read_8c.html#a483ab0874bc41021a77b11c5e6d3b740">dwarf2_get_attr_constant_value</a> (attr, 1);
<a name="l14231"></a>14231           high = low + count - 1;
<a name="l14232"></a>14232         }
<a name="l14233"></a>14233       <span class="keywordflow">else</span>
<a name="l14234"></a>14234         {
<a name="l14235"></a>14235           <span class="comment">/* Unspecified array length.  */</span>
<a name="l14236"></a>14236           high = low - 1;
<a name="l14237"></a>14237         }
<a name="l14238"></a>14238     }
<a name="l14239"></a>14239 
<a name="l14240"></a>14240   <span class="comment">/* Dwarf-2 specifications explicitly allows to create subrange types</span>
<a name="l14241"></a>14241 <span class="comment">     without specifying a base type.</span>
<a name="l14242"></a>14242 <span class="comment">     In that case, the base type must be set to the type of</span>
<a name="l14243"></a>14243 <span class="comment">     the lower bound, upper bound or count, in that order, if any of these</span>
<a name="l14244"></a>14244 <span class="comment">     three attributes references an object that has a type.</span>
<a name="l14245"></a>14245 <span class="comment">     If no base type is found, the Dwarf-2 specifications say that</span>
<a name="l14246"></a>14246 <span class="comment">     a signed integer type of size equal to the size of an address should</span>
<a name="l14247"></a>14247 <span class="comment">     be used.</span>
<a name="l14248"></a>14248 <span class="comment">     For the following C code: `extern char gdb_int [];&#39;</span>
<a name="l14249"></a>14249 <span class="comment">     GCC produces an empty range DIE.</span>
<a name="l14250"></a>14250 <span class="comment">     FIXME: muller/2010-05-28: Possible references to object for low bound,</span>
<a name="l14251"></a>14251 <span class="comment">     high bound or count are not yet handled by this code.  */</span>
<a name="l14252"></a>14252   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (base_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>)
<a name="l14253"></a>14253     {
<a name="l14254"></a>14254       <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l14255"></a>14255       <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l14256"></a>14256       <span class="keywordtype">int</span> addr_size = <a class="code" href="gdbarch_8c.html#a3ee335ac98782b6633ab7fc235182cc9">gdbarch_addr_bit</a> (gdbarch) /8;
<a name="l14257"></a>14257       <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *int_type = <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a2c06bc9a1e779eb8f0936d386382da9a">builtin_int</a>;
<a name="l14258"></a>14258 
<a name="l14259"></a>14259       <span class="comment">/* Test &quot;int&quot;, &quot;long int&quot;, and &quot;long long int&quot; objfile types,</span>
<a name="l14260"></a>14260 <span class="comment">         and select the first one having a size above or equal to the</span>
<a name="l14261"></a>14261 <span class="comment">         architecture address size.  */</span>
<a name="l14262"></a>14262       <span class="keywordflow">if</span> (int_type &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (int_type) &gt;= addr_size)
<a name="l14263"></a>14263         base_type = int_type;
<a name="l14264"></a>14264       <span class="keywordflow">else</span>
<a name="l14265"></a>14265         {
<a name="l14266"></a>14266           int_type = <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a31625148de3baf58086a0fb73c365d80">builtin_long</a>;
<a name="l14267"></a>14267           <span class="keywordflow">if</span> (int_type &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (int_type) &gt;= addr_size)
<a name="l14268"></a>14268             base_type = int_type;
<a name="l14269"></a>14269           <span class="keywordflow">else</span>
<a name="l14270"></a>14270             {
<a name="l14271"></a>14271               int_type = <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a6dc46bf069ce3bf8c351ee4ff89d2793">builtin_long_long</a>;
<a name="l14272"></a>14272               <span class="keywordflow">if</span> (int_type &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (int_type) &gt;= addr_size)
<a name="l14273"></a>14273                 base_type = int_type;
<a name="l14274"></a>14274             }
<a name="l14275"></a>14275         }
<a name="l14276"></a>14276     }
<a name="l14277"></a>14277 
<a name="l14278"></a>14278   negative_mask =
<a name="l14279"></a>14279     (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) -1 &lt;&lt; (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (base_type) * TARGET_CHAR_BIT - 1);
<a name="l14280"></a>14280   <span class="keywordflow">if</span> (!<a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">TYPE_UNSIGNED</a> (base_type) &amp;&amp; (low &amp; negative_mask))
<a name="l14281"></a>14281     low |= negative_mask;
<a name="l14282"></a>14282   <span class="keywordflow">if</span> (!<a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">TYPE_UNSIGNED</a> (base_type) &amp;&amp; (high &amp; negative_mask))
<a name="l14283"></a>14283     high |= negative_mask;
<a name="l14284"></a>14284 
<a name="l14285"></a>14285   range_type = <a class="code" href="gdbtypes_8c.html#ab0885fdae181c47ff3f958bcba70b82d">create_range_type</a> (NULL, orig_base_type, low, high);
<a name="l14286"></a>14286 
<a name="l14287"></a>14287   <span class="comment">/* Mark arrays with dynamic length at least as an array of unspecified</span>
<a name="l14288"></a>14288 <span class="comment">     length.  GDB could check the boundary but before it gets implemented at</span>
<a name="l14289"></a>14289 <span class="comment">     least allow accessing the array elements.  */</span>
<a name="l14290"></a>14290   <span class="keywordflow">if</span> (attr &amp;&amp; <a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (attr))
<a name="l14291"></a>14291     <a class="code" href="gdbtypes_8h.html#a0edde51aec176e3e7cb65849d4d78329">TYPE_HIGH_BOUND_UNDEFINED</a> (range_type) = 1;
<a name="l14292"></a>14292 
<a name="l14293"></a>14293   <span class="comment">/* Ada expects an empty array on no boundary attributes.  */</span>
<a name="l14294"></a>14294   <span class="keywordflow">if</span> (attr == NULL &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l14295"></a>14295     <a class="code" href="gdbtypes_8h.html#a0edde51aec176e3e7cb65849d4d78329">TYPE_HIGH_BOUND_UNDEFINED</a> (range_type) = 1;
<a name="l14296"></a>14296 
<a name="l14297"></a>14297   name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l14298"></a>14298   <span class="keywordflow">if</span> (name)
<a name="l14299"></a>14299     <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (range_type) = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l14300"></a>14300 
<a name="l14301"></a>14301   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_byte_size, cu);
<a name="l14302"></a>14302   <span class="keywordflow">if</span> (attr)
<a name="l14303"></a>14303     <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (range_type) = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l14304"></a>14304 
<a name="l14305"></a>14305   <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, range_type, cu);
<a name="l14306"></a>14306 
<a name="l14307"></a>14307   <span class="comment">/* set_die_type should be already done.  */</span>
<a name="l14308"></a>14308   <a class="code" href="dwarf2read_8c.html#abc906394dd587b9b28825cf6798d43d9">set_descriptive_type</a> (range_type, die, cu);
<a name="l14309"></a>14309 
<a name="l14310"></a>14310   <span class="keywordflow">return</span> range_type;
<a name="l14311"></a>14311 }
<a name="l14312"></a>14312 
<a name="l14313"></a>14313 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l14314"></a><a class="code" href="dwarf2read_8c.html#a206b3e0c61cd6d9d6d16b325dd73e602">14314</a> <a class="code" href="dwarf2read_8c.html#a206b3e0c61cd6d9d6d16b325dd73e602">read_unspecified_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l14315"></a>14315 {
<a name="l14316"></a>14316   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l14317"></a>14317 
<a name="l14318"></a>14318   <span class="comment">/* For now, we only support the C meaning of an unspecified type: void.  */</span>
<a name="l14319"></a>14319 
<a name="l14320"></a>14320   type = <a class="code" href="gdbtypes_8c.html#ac74c6d3def8258efc09a3deb8f395d64">init_type</a> (<a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>, 0, 0, NULL, cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>);
<a name="l14321"></a>14321   <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l14322"></a>14322 
<a name="l14323"></a>14323   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (die, type, cu);
<a name="l14324"></a>14324 }
<a name="l14325"></a>14325 
<a name="l14326"></a>14326 <span class="comment">/* Read a single die and all its descendents.  Set the die&#39;s sibling</span>
<a name="l14327"></a>14327 <span class="comment">   field to NULL; set other fields in the die correctly, and set all</span>
<a name="l14328"></a>14328 <span class="comment">   of the descendents&#39; fields correctly.  Set *NEW_INFO_PTR to the</span>
<a name="l14329"></a>14329 <span class="comment">   location of the info_ptr after reading all of those dies.  PARENT</span>
<a name="l14330"></a>14330 <span class="comment">   is the parent of the die in question.  */</span>
<a name="l14331"></a>14331 
<a name="l14332"></a>14332 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *
<a name="l14333"></a><a class="code" href="dwarf2read_8c.html#ab171a3b79a444ad212cefaa3dcc6b23f">14333</a> <a class="code" href="dwarf2read_8c.html#ab171a3b79a444ad212cefaa3dcc6b23f">read_die_and_children</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l14334"></a>14334                        <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l14335"></a>14335                        <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **new_info_ptr,
<a name="l14336"></a>14336                        <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *parent)
<a name="l14337"></a>14337 {
<a name="l14338"></a>14338   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die;
<a name="l14339"></a>14339   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *cur_ptr;
<a name="l14340"></a>14340   <span class="keywordtype">int</span> has_children;
<a name="l14341"></a>14341 
<a name="l14342"></a>14342   cur_ptr = <a class="code" href="dwarf2read_8c.html#a291867fdd93d43aec13a54966902d005">read_full_die_1</a> (reader, &amp;die, info_ptr, &amp;has_children, 0);
<a name="l14343"></a>14343   <span class="keywordflow">if</span> (die == NULL)
<a name="l14344"></a>14344     {
<a name="l14345"></a>14345       *new_info_ptr = cur_ptr;
<a name="l14346"></a>14346       <span class="keywordflow">return</span> NULL;
<a name="l14347"></a>14347     }
<a name="l14348"></a>14348   <a class="code" href="dwarf2read_8c.html#a73da43858dcf4f74ace71583baadf321">store_in_ref_table</a> (die, reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>);
<a name="l14349"></a>14349 
<a name="l14350"></a>14350   <span class="keywordflow">if</span> (has_children)
<a name="l14351"></a>14351     die-&gt;child = <a class="code" href="dwarf2read_8c.html#a9a356825fcc31a825f71c8ec18206ffb">read_die_and_siblings_1</a> (reader, cur_ptr, new_info_ptr, die);
<a name="l14352"></a>14352   <span class="keywordflow">else</span>
<a name="l14353"></a>14353     {
<a name="l14354"></a>14354       die-&gt;child = NULL;
<a name="l14355"></a>14355       *new_info_ptr = cur_ptr;
<a name="l14356"></a>14356     }
<a name="l14357"></a>14357 
<a name="l14358"></a>14358   die-&gt;sibling = NULL;
<a name="l14359"></a>14359   die-&gt;parent = parent;
<a name="l14360"></a>14360   <span class="keywordflow">return</span> die;
<a name="l14361"></a>14361 }
<a name="l14362"></a>14362 
<a name="l14363"></a>14363 <span class="comment">/* Read a die, all of its descendents, and all of its siblings; set</span>
<a name="l14364"></a>14364 <span class="comment">   all of the fields of all of the dies correctly.  Arguments are as</span>
<a name="l14365"></a>14365 <span class="comment">   in read_die_and_children.  */</span>
<a name="l14366"></a>14366 
<a name="l14367"></a>14367 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *
<a name="l14368"></a><a class="code" href="dwarf2read_8c.html#a9a356825fcc31a825f71c8ec18206ffb">14368</a> <a class="code" href="dwarf2read_8c.html#a9a356825fcc31a825f71c8ec18206ffb">read_die_and_siblings_1</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l14369"></a>14369                          <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l14370"></a>14370                          <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **new_info_ptr,
<a name="l14371"></a>14371                          <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *parent)
<a name="l14372"></a>14372 {
<a name="l14373"></a>14373   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *first_die, *last_sibling;
<a name="l14374"></a>14374   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *cur_ptr;
<a name="l14375"></a>14375 
<a name="l14376"></a>14376   cur_ptr = info_ptr;
<a name="l14377"></a>14377   first_die = last_sibling = NULL;
<a name="l14378"></a>14378 
<a name="l14379"></a>14379   <span class="keywordflow">while</span> (1)
<a name="l14380"></a>14380     {
<a name="l14381"></a>14381       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die
<a name="l14382"></a>14382         = <a class="code" href="dwarf2read_8c.html#ab171a3b79a444ad212cefaa3dcc6b23f">read_die_and_children</a> (reader, cur_ptr, &amp;cur_ptr, parent);
<a name="l14383"></a>14383 
<a name="l14384"></a>14384       <span class="keywordflow">if</span> (die == NULL)
<a name="l14385"></a>14385         {
<a name="l14386"></a>14386           *new_info_ptr = cur_ptr;
<a name="l14387"></a>14387           <span class="keywordflow">return</span> first_die;
<a name="l14388"></a>14388         }
<a name="l14389"></a>14389 
<a name="l14390"></a>14390       <span class="keywordflow">if</span> (!first_die)
<a name="l14391"></a>14391         first_die = die;
<a name="l14392"></a>14392       <span class="keywordflow">else</span>
<a name="l14393"></a>14393         last_sibling-&gt;sibling = die;
<a name="l14394"></a>14394 
<a name="l14395"></a>14395       last_sibling = die;
<a name="l14396"></a>14396     }
<a name="l14397"></a>14397 }
<a name="l14398"></a>14398 
<a name="l14399"></a>14399 <span class="comment">/* Read a die, all of its descendents, and all of its siblings; set</span>
<a name="l14400"></a>14400 <span class="comment">   all of the fields of all of the dies correctly.  Arguments are as</span>
<a name="l14401"></a>14401 <span class="comment">   in read_die_and_children.</span>
<a name="l14402"></a>14402 <span class="comment">   This the main entry point for reading a DIE and all its children.  */</span>
<a name="l14403"></a>14403 
<a name="l14404"></a>14404 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *
<a name="l14405"></a><a class="code" href="dwarf2read_8c.html#a79a10115d28e35221fb4b78c2023be76">14405</a> <a class="code" href="dwarf2read_8c.html#a79a10115d28e35221fb4b78c2023be76">read_die_and_siblings</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l14406"></a>14406                        <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l14407"></a>14407                        <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **new_info_ptr,
<a name="l14408"></a>14408                        <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *parent)
<a name="l14409"></a>14409 {
<a name="l14410"></a>14410   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die = <a class="code" href="dwarf2read_8c.html#a9a356825fcc31a825f71c8ec18206ffb">read_die_and_siblings_1</a> (reader, info_ptr,
<a name="l14411"></a>14411                                                   new_info_ptr, parent);
<a name="l14412"></a>14412 
<a name="l14413"></a>14413   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a1a718830b2084a029498b587ad66aeae">dwarf2_die_debug</a>)
<a name="l14414"></a>14414     {
<a name="l14415"></a>14415       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l14416"></a>14416                           <span class="stringliteral">&quot;Read die from %s@0x%x of %s:\n&quot;</span>,
<a name="l14417"></a>14417                           <a class="code" href="dwarf2read_8c.html#a206c558e28b7bc7fcf8bdad145cabef1">get_section_name</a> (reader-&gt;<a class="code" href="structdie__reader__specs.html#a59f8ddce0966e4c55a24c4f051a1917e">die_section</a>),
<a name="l14418"></a>14418                           (<span class="keywordtype">unsigned</span>) (info_ptr - reader-&gt;<a class="code" href="structdie__reader__specs.html#a59f8ddce0966e4c55a24c4f051a1917e">die_section</a>-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>),
<a name="l14419"></a>14419                           bfd_get_filename (reader-&gt;<a class="code" href="structdie__reader__specs.html#a1a2ea4151d385459f3a3fb7b0dad2973">abfd</a>));
<a name="l14420"></a>14420       <a class="code" href="dwarf2read_8c.html#aa1e7ee43f6ccdd2c19768ae5eff4bd89">dump_die</a> (die, <a class="code" href="dwarf2read_8c.html#a1a718830b2084a029498b587ad66aeae">dwarf2_die_debug</a>);
<a name="l14421"></a>14421     }
<a name="l14422"></a>14422 
<a name="l14423"></a>14423   <span class="keywordflow">return</span> die;
<a name="l14424"></a>14424 }
<a name="l14425"></a>14425 
<a name="l14426"></a>14426 <span class="comment">/* Read a die and all its attributes, leave space for NUM_EXTRA_ATTRS</span>
<a name="l14427"></a>14427 <span class="comment">   attributes.</span>
<a name="l14428"></a>14428 <span class="comment">   The caller is responsible for filling in the extra attributes</span>
<a name="l14429"></a>14429 <span class="comment">   and updating (*DIEP)-&gt;num_attrs.</span>
<a name="l14430"></a>14430 <span class="comment">   Set DIEP to point to a newly allocated die with its information,</span>
<a name="l14431"></a>14431 <span class="comment">   except for its child, sibling, and parent fields.</span>
<a name="l14432"></a>14432 <span class="comment">   Set HAS_CHILDREN to tell whether the die has children or not.  */</span>
<a name="l14433"></a>14433 
<a name="l14434"></a>14434 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l14435"></a><a class="code" href="dwarf2read_8c.html#a291867fdd93d43aec13a54966902d005">14435</a> <a class="code" href="dwarf2read_8c.html#a291867fdd93d43aec13a54966902d005">read_full_die_1</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l14436"></a>14436                  <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> **diep, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l14437"></a>14437                  <span class="keywordtype">int</span> *has_children, <span class="keywordtype">int</span> num_extra_attrs)
<a name="l14438"></a>14438 {
<a name="l14439"></a>14439   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> abbrev_number, bytes_read, i;
<a name="l14440"></a>14440   <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l14441"></a>14441   <span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a> *abbrev;
<a name="l14442"></a>14442   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die;
<a name="l14443"></a>14443   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l14444"></a>14444   bfd *abfd = reader-&gt;<a class="code" href="structdie__reader__specs.html#a1a2ea4151d385459f3a3fb7b0dad2973">abfd</a>;
<a name="l14445"></a>14445 
<a name="l14446"></a>14446   offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = info_ptr - reader-&gt;<a class="code" href="structdie__reader__specs.html#a923f3b4252ec94584560d5433e848dc0">buffer</a>;
<a name="l14447"></a>14447   abbrev_number = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, info_ptr, &amp;bytes_read);
<a name="l14448"></a>14448   info_ptr += bytes_read;
<a name="l14449"></a>14449   <span class="keywordflow">if</span> (!abbrev_number)
<a name="l14450"></a>14450     {
<a name="l14451"></a>14451       *diep = NULL;
<a name="l14452"></a>14452       *has_children = 0;
<a name="l14453"></a>14453       <span class="keywordflow">return</span> info_ptr;
<a name="l14454"></a>14454     }
<a name="l14455"></a>14455 
<a name="l14456"></a>14456   abbrev = <a class="code" href="dwarf2read_8c.html#a320857b558736bdfe9fa88072e106841">abbrev_table_lookup_abbrev</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a57e9b37ae0dfd83c0e16565ca75c9781">abbrev_table</a>, abbrev_number);
<a name="l14457"></a>14457   <span class="keywordflow">if</span> (!abbrev)
<a name="l14458"></a>14458     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: could not find abbrev number %d [in module %s]&quot;</span>),
<a name="l14459"></a>14459            abbrev_number,
<a name="l14460"></a>14460            bfd_get_filename (abfd));
<a name="l14461"></a>14461 
<a name="l14462"></a>14462   die = <a class="code" href="dwarf2read_8c.html#ad0de318a450615df05b9d8225925b9aa">dwarf_alloc_die</a> (cu, abbrev-&gt;<a class="code" href="structabbrev__info.html#a34d2e21fe3925a6c1613e8e42993581e">num_attrs</a> + num_extra_attrs);
<a name="l14463"></a>14463   die-&gt;offset = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l14464"></a>14464   die-&gt;tag = abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a>;
<a name="l14465"></a>14465   die-&gt;abbrev = abbrev_number;
<a name="l14466"></a>14466 
<a name="l14467"></a>14467   <span class="comment">/* Make the result usable.</span>
<a name="l14468"></a>14468 <span class="comment">     The caller needs to update num_attrs after adding the extra</span>
<a name="l14469"></a>14469 <span class="comment">     attributes.  */</span>
<a name="l14470"></a>14470   die-&gt;num_attrs = abbrev-&gt;<a class="code" href="structabbrev__info.html#a34d2e21fe3925a6c1613e8e42993581e">num_attrs</a>;
<a name="l14471"></a>14471 
<a name="l14472"></a>14472   <span class="keywordflow">for</span> (i = 0; i &lt; abbrev-&gt;<a class="code" href="structabbrev__info.html#a34d2e21fe3925a6c1613e8e42993581e">num_attrs</a>; ++i)
<a name="l14473"></a>14473     info_ptr = <a class="code" href="dwarf2read_8c.html#a08e1a18f85e288f9241d3baab2ded2b0">read_attribute</a> (reader, &amp;die-&gt;attrs[i], &amp;abbrev-&gt;<a class="code" href="structabbrev__info.html#aa70664d01df5b3d3567c6841c9de22f2">attrs</a>[i],
<a name="l14474"></a>14474                                info_ptr);
<a name="l14475"></a>14475 
<a name="l14476"></a>14476   *diep = die;
<a name="l14477"></a>14477   *has_children = abbrev-&gt;<a class="code" href="structabbrev__info.html#ac84c5aceafdfea0a95c619f623b78de1">has_children</a>;
<a name="l14478"></a>14478   <span class="keywordflow">return</span> info_ptr;
<a name="l14479"></a>14479 }
<a name="l14480"></a>14480 
<a name="l14481"></a>14481 <span class="comment">/* Read a die and all its attributes.</span>
<a name="l14482"></a>14482 <span class="comment">   Set DIEP to point to a newly allocated die with its information,</span>
<a name="l14483"></a>14483 <span class="comment">   except for its child, sibling, and parent fields.</span>
<a name="l14484"></a>14484 <span class="comment">   Set HAS_CHILDREN to tell whether the die has children or not.  */</span>
<a name="l14485"></a>14485 
<a name="l14486"></a>14486 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l14487"></a><a class="code" href="dwarf2read_8c.html#a80d70a70850cfc7be97670eab43c98d8">14487</a> <a class="code" href="dwarf2read_8c.html#a80d70a70850cfc7be97670eab43c98d8">read_full_die</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l14488"></a>14488                <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> **diep, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l14489"></a>14489                <span class="keywordtype">int</span> *has_children)
<a name="l14490"></a>14490 {
<a name="l14491"></a>14491   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *result;
<a name="l14492"></a>14492 
<a name="l14493"></a>14493   result = <a class="code" href="dwarf2read_8c.html#a291867fdd93d43aec13a54966902d005">read_full_die_1</a> (reader, diep, info_ptr, has_children, 0);
<a name="l14494"></a>14494 
<a name="l14495"></a>14495   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a1a718830b2084a029498b587ad66aeae">dwarf2_die_debug</a>)
<a name="l14496"></a>14496     {
<a name="l14497"></a>14497       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l14498"></a>14498                           <span class="stringliteral">&quot;Read die from %s@0x%x of %s:\n&quot;</span>,
<a name="l14499"></a>14499                           <a class="code" href="dwarf2read_8c.html#a206c558e28b7bc7fcf8bdad145cabef1">get_section_name</a> (reader-&gt;<a class="code" href="structdie__reader__specs.html#a59f8ddce0966e4c55a24c4f051a1917e">die_section</a>),
<a name="l14500"></a>14500                           (<span class="keywordtype">unsigned</span>) (info_ptr - reader-&gt;<a class="code" href="structdie__reader__specs.html#a59f8ddce0966e4c55a24c4f051a1917e">die_section</a>-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>),
<a name="l14501"></a>14501                           bfd_get_filename (reader-&gt;<a class="code" href="structdie__reader__specs.html#a1a2ea4151d385459f3a3fb7b0dad2973">abfd</a>));
<a name="l14502"></a>14502       <a class="code" href="dwarf2read_8c.html#aa1e7ee43f6ccdd2c19768ae5eff4bd89">dump_die</a> (*diep, <a class="code" href="dwarf2read_8c.html#a1a718830b2084a029498b587ad66aeae">dwarf2_die_debug</a>);
<a name="l14503"></a>14503     }
<a name="l14504"></a>14504 
<a name="l14505"></a>14505   <span class="keywordflow">return</span> result;
<a name="l14506"></a>14506 }
<a name="l14507"></a>14507 
<a name="l14508"></a>14508 <span class="comment">/* Abbreviation tables.</span>
<a name="l14509"></a>14509 <span class="comment"></span>
<a name="l14510"></a>14510 <span class="comment">   In DWARF version 2, the description of the debugging information is</span>
<a name="l14511"></a>14511 <span class="comment">   stored in a separate .debug_abbrev section.  Before we read any</span>
<a name="l14512"></a>14512 <span class="comment">   dies from a section we read in all abbreviations and install them</span>
<a name="l14513"></a>14513 <span class="comment">   in a hash table.  */</span>
<a name="l14514"></a>14514 
<a name="l14515"></a>14515 <span class="comment">/* Allocate space for a struct abbrev_info object in ABBREV_TABLE.  */</span>
<a name="l14516"></a>14516 
<a name="l14517"></a>14517 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a> *
<a name="l14518"></a><a class="code" href="dwarf2read_8c.html#a7d3f545b59087c167b789f8d7b282fb7">14518</a> <a class="code" href="dwarf2read_8c.html#a7d3f545b59087c167b789f8d7b282fb7">abbrev_table_alloc_abbrev</a> (<span class="keyword">struct</span> <a class="code" href="structabbrev__table.html">abbrev_table</a> *<a class="code" href="structabbrev__table.html">abbrev_table</a>)
<a name="l14519"></a>14519 {
<a name="l14520"></a>14520   <span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a> *abbrev;
<a name="l14521"></a>14521 
<a name="l14522"></a>14522   abbrev = (<span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a> *)
<a name="l14523"></a>14523     obstack_alloc (&amp;abbrev_table-&gt;<a class="code" href="structabbrev__table.html#a557aeda40bed392d106012843a4bf8e8">abbrev_obstack</a>, sizeof (<span class="keyword">struct</span> <a class="code" href="structabbrev__info.html">abbrev_info</a>));
<a name="l14524"></a>14524   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (abbrev, 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structabbrev__info.html">abbrev_info</a>));
<a name="l14525"></a>14525   <span class="keywordflow">return</span> abbrev;
<a name="l14526"></a>14526 }
<a name="l14527"></a>14527 
<a name="l14528"></a>14528 <span class="comment">/* Add an abbreviation to the table.  */</span>
<a name="l14529"></a>14529 
<a name="l14530"></a>14530 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l14531"></a><a class="code" href="dwarf2read_8c.html#a80b16e7a8c609023e5ce9bf394709807">14531</a> <a class="code" href="dwarf2read_8c.html#a80b16e7a8c609023e5ce9bf394709807">abbrev_table_add_abbrev</a> (<span class="keyword">struct</span> <a class="code" href="structabbrev__table.html">abbrev_table</a> *<a class="code" href="structabbrev__table.html">abbrev_table</a>,
<a name="l14532"></a>14532                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> abbrev_number,
<a name="l14533"></a>14533                          <span class="keyword">struct</span> <a class="code" href="structabbrev__info.html">abbrev_info</a> *abbrev)
<a name="l14534"></a>14534 {
<a name="l14535"></a>14535   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash_number;
<a name="l14536"></a>14536 
<a name="l14537"></a>14537   hash_number = abbrev_number % <a class="code" href="dwarf2read_8c.html#a7b47d7d684ec59e2a7c822a58883362d">ABBREV_HASH_SIZE</a>;
<a name="l14538"></a>14538   abbrev-&gt;<a class="code" href="structabbrev__info.html#ad6b9b79c292fe4b7c9f7367e1464fe33">next</a> = abbrev_table-&gt;<a class="code" href="structabbrev__table.html#a1d499a87c6d8a864be99c0c245c9f64d">abbrevs</a>[hash_number];
<a name="l14539"></a>14539   abbrev_table-&gt;<a class="code" href="structabbrev__table.html#a1d499a87c6d8a864be99c0c245c9f64d">abbrevs</a>[hash_number] = abbrev;
<a name="l14540"></a>14540 }
<a name="l14541"></a>14541 
<a name="l14542"></a>14542 <span class="comment">/* Look up an abbrev in the table.</span>
<a name="l14543"></a>14543 <span class="comment">   Returns NULL if the abbrev is not found.  */</span>
<a name="l14544"></a>14544 
<a name="l14545"></a>14545 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a> *
<a name="l14546"></a><a class="code" href="dwarf2read_8c.html#a320857b558736bdfe9fa88072e106841">14546</a> <a class="code" href="dwarf2read_8c.html#a320857b558736bdfe9fa88072e106841">abbrev_table_lookup_abbrev</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structabbrev__table.html">abbrev_table</a> *<a class="code" href="structabbrev__table.html">abbrev_table</a>,
<a name="l14547"></a>14547                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> abbrev_number)
<a name="l14548"></a>14548 {
<a name="l14549"></a>14549   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash_number;
<a name="l14550"></a>14550   <span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a> *abbrev;
<a name="l14551"></a>14551 
<a name="l14552"></a>14552   hash_number = abbrev_number % <a class="code" href="dwarf2read_8c.html#a7b47d7d684ec59e2a7c822a58883362d">ABBREV_HASH_SIZE</a>;
<a name="l14553"></a>14553   abbrev = abbrev_table-&gt;<a class="code" href="structabbrev__table.html#a1d499a87c6d8a864be99c0c245c9f64d">abbrevs</a>[hash_number];
<a name="l14554"></a>14554 
<a name="l14555"></a>14555   <span class="keywordflow">while</span> (abbrev)
<a name="l14556"></a>14556     {
<a name="l14557"></a>14557       <span class="keywordflow">if</span> (abbrev-&gt;<a class="code" href="structabbrev__info.html#ac7dcce6d183c93d3af481347ba841eae">number</a> == abbrev_number)
<a name="l14558"></a>14558         <span class="keywordflow">return</span> abbrev;
<a name="l14559"></a>14559       abbrev = abbrev-&gt;<a class="code" href="structabbrev__info.html#ad6b9b79c292fe4b7c9f7367e1464fe33">next</a>;
<a name="l14560"></a>14560     }
<a name="l14561"></a>14561   <span class="keywordflow">return</span> NULL;
<a name="l14562"></a>14562 }
<a name="l14563"></a>14563 
<a name="l14564"></a>14564 <span class="comment">/* Read in an abbrev table.  */</span>
<a name="l14565"></a>14565 
<a name="l14566"></a>14566 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structabbrev__table.html">abbrev_table</a> *
<a name="l14567"></a><a class="code" href="dwarf2read_8c.html#a7c5fe8c826ddc3a8ecdcb9e7899912f3">14567</a> <a class="code" href="dwarf2read_8c.html#a7c5fe8c826ddc3a8ecdcb9e7899912f3">abbrev_table_read_table</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section,
<a name="l14568"></a>14568                          <a class="code" href="structsect__offset.html">sect_offset</a> offset)
<a name="l14569"></a>14569 {
<a name="l14570"></a>14570   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l14571"></a>14571   bfd *abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l14572"></a>14572   <span class="keyword">struct </span><a class="code" href="structabbrev__table.html">abbrev_table</a> *<a class="code" href="structabbrev__table.html">abbrev_table</a>;
<a name="l14573"></a>14573   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *abbrev_ptr;
<a name="l14574"></a>14574   <span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a> *cur_abbrev;
<a name="l14575"></a>14575   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> abbrev_number, bytes_read, abbrev_name;
<a name="l14576"></a>14576   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> abbrev_form;
<a name="l14577"></a>14577   <span class="keyword">struct </span><a class="code" href="structattr__abbrev.html">attr_abbrev</a> *cur_attrs;
<a name="l14578"></a>14578   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> allocated_attrs;
<a name="l14579"></a>14579 
<a name="l14580"></a>14580   abbrev_table = <a class="code" href="defs_8h.html#ab6751cea794fc22fa3696fe15df3139b">XMALLOC</a> (<span class="keyword">struct</span> abbrev_table);
<a name="l14581"></a>14581   abbrev_table-&gt;<a class="code" href="structabbrev__table.html#a5b67ef89ee9470388052b1acd4c44b57">offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l14582"></a>14582   obstack_init (&amp;abbrev_table-&gt;<a class="code" href="structabbrev__table.html#a557aeda40bed392d106012843a4bf8e8">abbrev_obstack</a>);
<a name="l14583"></a>14583   abbrev_table-&gt;<a class="code" href="structabbrev__table.html#a1d499a87c6d8a864be99c0c245c9f64d">abbrevs</a> = obstack_alloc (&amp;abbrev_table-&gt;<a class="code" href="structabbrev__table.html#a557aeda40bed392d106012843a4bf8e8">abbrev_obstack</a>,
<a name="l14584"></a>14584                                          (<a class="code" href="dwarf2read_8c.html#a7b47d7d684ec59e2a7c822a58883362d">ABBREV_HASH_SIZE</a>
<a name="l14585"></a>14585                                           * sizeof (<span class="keyword">struct</span> <a class="code" href="structabbrev__info.html">abbrev_info</a> *)));
<a name="l14586"></a>14586   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (abbrev_table-&gt;<a class="code" href="structabbrev__table.html#a1d499a87c6d8a864be99c0c245c9f64d">abbrevs</a>, 0,
<a name="l14587"></a>14587           <a class="code" href="dwarf2read_8c.html#a7b47d7d684ec59e2a7c822a58883362d">ABBREV_HASH_SIZE</a> * sizeof (<span class="keyword">struct</span> <a class="code" href="structabbrev__info.html">abbrev_info</a> *));
<a name="l14588"></a>14588 
<a name="l14589"></a>14589   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, section);
<a name="l14590"></a>14590   abbrev_ptr = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l14591"></a>14591   abbrev_number = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, abbrev_ptr, &amp;bytes_read);
<a name="l14592"></a>14592   abbrev_ptr += bytes_read;
<a name="l14593"></a>14593 
<a name="l14594"></a>14594   allocated_attrs = <a class="code" href="dwarf2read_8c.html#a7539803265b0574cb2c4ac0d58c3841e">ATTR_ALLOC_CHUNK</a>;
<a name="l14595"></a>14595   cur_attrs = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (allocated_attrs * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structattr__abbrev.html">attr_abbrev</a>));
<a name="l14596"></a>14596 
<a name="l14597"></a>14597   <span class="comment">/* Loop until we reach an abbrev number of 0.  */</span>
<a name="l14598"></a>14598   <span class="keywordflow">while</span> (abbrev_number)
<a name="l14599"></a>14599     {
<a name="l14600"></a>14600       cur_abbrev = <a class="code" href="dwarf2read_8c.html#a7d3f545b59087c167b789f8d7b282fb7">abbrev_table_alloc_abbrev</a> (abbrev_table);
<a name="l14601"></a>14601 
<a name="l14602"></a>14602       <span class="comment">/* read in abbrev header */</span>
<a name="l14603"></a>14603       cur_abbrev-&gt;<a class="code" href="structabbrev__info.html#ac7dcce6d183c93d3af481347ba841eae">number</a> = abbrev_number;
<a name="l14604"></a>14604       cur_abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, abbrev_ptr, &amp;bytes_read);
<a name="l14605"></a>14605       abbrev_ptr += bytes_read;
<a name="l14606"></a>14606       cur_abbrev-&gt;<a class="code" href="structabbrev__info.html#ac84c5aceafdfea0a95c619f623b78de1">has_children</a> = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, abbrev_ptr);
<a name="l14607"></a>14607       abbrev_ptr += 1;
<a name="l14608"></a>14608 
<a name="l14609"></a>14609       <span class="comment">/* now read in declarations */</span>
<a name="l14610"></a>14610       abbrev_name = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, abbrev_ptr, &amp;bytes_read);
<a name="l14611"></a>14611       abbrev_ptr += bytes_read;
<a name="l14612"></a>14612       abbrev_form = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, abbrev_ptr, &amp;bytes_read);
<a name="l14613"></a>14613       abbrev_ptr += bytes_read;
<a name="l14614"></a>14614       <span class="keywordflow">while</span> (abbrev_name)
<a name="l14615"></a>14615         {
<a name="l14616"></a>14616           <span class="keywordflow">if</span> (cur_abbrev-&gt;<a class="code" href="structabbrev__info.html#a34d2e21fe3925a6c1613e8e42993581e">num_attrs</a> == allocated_attrs)
<a name="l14617"></a>14617             {
<a name="l14618"></a>14618               allocated_attrs += <a class="code" href="dwarf2read_8c.html#a7539803265b0574cb2c4ac0d58c3841e">ATTR_ALLOC_CHUNK</a>;
<a name="l14619"></a>14619               cur_attrs
<a name="l14620"></a>14620                 = <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (cur_attrs, (allocated_attrs
<a name="l14621"></a>14621                                         * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structattr__abbrev.html">attr_abbrev</a>)));
<a name="l14622"></a>14622             }
<a name="l14623"></a>14623 
<a name="l14624"></a>14624           cur_attrs[cur_abbrev-&gt;<a class="code" href="structabbrev__info.html#a34d2e21fe3925a6c1613e8e42993581e">num_attrs</a>].name = abbrev_name;
<a name="l14625"></a>14625           cur_attrs[cur_abbrev-&gt;<a class="code" href="structabbrev__info.html#a34d2e21fe3925a6c1613e8e42993581e">num_attrs</a>++].form = abbrev_form;
<a name="l14626"></a>14626           abbrev_name = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, abbrev_ptr, &amp;bytes_read);
<a name="l14627"></a>14627           abbrev_ptr += bytes_read;
<a name="l14628"></a>14628           abbrev_form = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, abbrev_ptr, &amp;bytes_read);
<a name="l14629"></a>14629           abbrev_ptr += bytes_read;
<a name="l14630"></a>14630         }
<a name="l14631"></a>14631 
<a name="l14632"></a>14632       cur_abbrev-&gt;<a class="code" href="structabbrev__info.html#aa70664d01df5b3d3567c6841c9de22f2">attrs</a> = obstack_alloc (&amp;abbrev_table-&gt;<a class="code" href="structabbrev__table.html#a557aeda40bed392d106012843a4bf8e8">abbrev_obstack</a>,
<a name="l14633"></a>14633                                          (cur_abbrev-&gt;<a class="code" href="structabbrev__info.html#a34d2e21fe3925a6c1613e8e42993581e">num_attrs</a>
<a name="l14634"></a>14634                                           * sizeof (<span class="keyword">struct</span> <a class="code" href="structattr__abbrev.html">attr_abbrev</a>)));
<a name="l14635"></a>14635       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (cur_abbrev-&gt;<a class="code" href="structabbrev__info.html#aa70664d01df5b3d3567c6841c9de22f2">attrs</a>, cur_attrs,
<a name="l14636"></a>14636               cur_abbrev-&gt;<a class="code" href="structabbrev__info.html#a34d2e21fe3925a6c1613e8e42993581e">num_attrs</a> * sizeof (<span class="keyword">struct</span> <a class="code" href="structattr__abbrev.html">attr_abbrev</a>));
<a name="l14637"></a>14637 
<a name="l14638"></a>14638       <a class="code" href="dwarf2read_8c.html#a80b16e7a8c609023e5ce9bf394709807">abbrev_table_add_abbrev</a> (abbrev_table, abbrev_number, cur_abbrev);
<a name="l14639"></a>14639 
<a name="l14640"></a>14640       <span class="comment">/* Get next abbreviation.</span>
<a name="l14641"></a>14641 <span class="comment">         Under Irix6 the abbreviations for a compilation unit are not</span>
<a name="l14642"></a>14642 <span class="comment">         always properly terminated with an abbrev number of 0.</span>
<a name="l14643"></a>14643 <span class="comment">         Exit loop if we encounter an abbreviation which we have</span>
<a name="l14644"></a>14644 <span class="comment">         already read (which means we are about to read the abbreviations</span>
<a name="l14645"></a>14645 <span class="comment">         for the next compile unit) or if the end of the abbreviation</span>
<a name="l14646"></a>14646 <span class="comment">         table is reached.  */</span>
<a name="l14647"></a>14647       <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (abbrev_ptr - section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>) &gt;= section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>)
<a name="l14648"></a>14648         <span class="keywordflow">break</span>;
<a name="l14649"></a>14649       abbrev_number = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, abbrev_ptr, &amp;bytes_read);
<a name="l14650"></a>14650       abbrev_ptr += bytes_read;
<a name="l14651"></a>14651       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a320857b558736bdfe9fa88072e106841">abbrev_table_lookup_abbrev</a> (abbrev_table, abbrev_number) != NULL)
<a name="l14652"></a>14652         <span class="keywordflow">break</span>;
<a name="l14653"></a>14653     }
<a name="l14654"></a>14654 
<a name="l14655"></a>14655   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (cur_attrs);
<a name="l14656"></a>14656   <span class="keywordflow">return</span> abbrev_table;
<a name="l14657"></a>14657 }
<a name="l14658"></a>14658 
<a name="l14659"></a>14659 <span class="comment">/* Free the resources held by ABBREV_TABLE.  */</span>
<a name="l14660"></a>14660 
<a name="l14661"></a>14661 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l14662"></a><a class="code" href="dwarf2read_8c.html#a657ffcf72df342d61df4a8893fc6151f">14662</a> <a class="code" href="dwarf2read_8c.html#a657ffcf72df342d61df4a8893fc6151f">abbrev_table_free</a> (<span class="keyword">struct</span> <a class="code" href="structabbrev__table.html">abbrev_table</a> *<a class="code" href="structabbrev__table.html">abbrev_table</a>)
<a name="l14663"></a>14663 {
<a name="l14664"></a>14664   obstack_free (&amp;abbrev_table-&gt;<a class="code" href="structabbrev__table.html#a557aeda40bed392d106012843a4bf8e8">abbrev_obstack</a>, NULL);
<a name="l14665"></a>14665   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (abbrev_table);
<a name="l14666"></a>14666 }
<a name="l14667"></a>14667 
<a name="l14668"></a>14668 <span class="comment">/* Same as abbrev_table_free but as a cleanup.</span>
<a name="l14669"></a>14669 <span class="comment">   We pass in a pointer to the pointer to the table so that we can</span>
<a name="l14670"></a>14670 <span class="comment">   set the pointer to NULL when we&#39;re done.  It also simplifies</span>
<a name="l14671"></a>14671 <span class="comment">   build_type_unit_groups.  */</span>
<a name="l14672"></a>14672 
<a name="l14673"></a>14673 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l14674"></a><a class="code" href="dwarf2read_8c.html#a6c9598f51c0ca31c3f615940abb8d605">14674</a> <a class="code" href="dwarf2read_8c.html#a6c9598f51c0ca31c3f615940abb8d605">abbrev_table_free_cleanup</a> (<span class="keywordtype">void</span> *table_ptr)
<a name="l14675"></a>14675 {
<a name="l14676"></a>14676   <span class="keyword">struct </span><a class="code" href="structabbrev__table.html">abbrev_table</a> **abbrev_table_ptr = table_ptr;
<a name="l14677"></a>14677 
<a name="l14678"></a>14678   <span class="keywordflow">if</span> (*abbrev_table_ptr != NULL)
<a name="l14679"></a>14679     <a class="code" href="dwarf2read_8c.html#a657ffcf72df342d61df4a8893fc6151f">abbrev_table_free</a> (*abbrev_table_ptr);
<a name="l14680"></a>14680   *abbrev_table_ptr = NULL;
<a name="l14681"></a>14681 }
<a name="l14682"></a>14682 
<a name="l14683"></a>14683 <span class="comment">/* Read the abbrev table for CU from ABBREV_SECTION.  */</span>
<a name="l14684"></a>14684 
<a name="l14685"></a>14685 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l14686"></a><a class="code" href="dwarf2read_8c.html#a2ab84af9aed9d7ab89a9c1389bf09944">14686</a> <a class="code" href="dwarf2read_8c.html#a2ab84af9aed9d7ab89a9c1389bf09944">dwarf2_read_abbrevs</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l14687"></a>14687                      <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *abbrev_section)
<a name="l14688"></a>14688 {
<a name="l14689"></a>14689   cu-&gt;<a class="code" href="structdwarf2__cu.html#a57e9b37ae0dfd83c0e16565ca75c9781">abbrev_table</a> =
<a name="l14690"></a>14690     <a class="code" href="dwarf2read_8c.html#a7c5fe8c826ddc3a8ecdcb9e7899912f3">abbrev_table_read_table</a> (abbrev_section, cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a5455b96122116b3881197362c7e35758">abbrev_offset</a>);
<a name="l14691"></a>14691 }
<a name="l14692"></a>14692 
<a name="l14693"></a>14693 <span class="comment">/* Release the memory used by the abbrev table for a compilation unit.  */</span>
<a name="l14694"></a>14694 
<a name="l14695"></a>14695 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l14696"></a><a class="code" href="dwarf2read_8c.html#a966c2eb4689779cf219c72bbcda90b83">14696</a> <a class="code" href="dwarf2read_8c.html#a966c2eb4689779cf219c72bbcda90b83">dwarf2_free_abbrev_table</a> (<span class="keywordtype">void</span> *ptr_to_cu)
<a name="l14697"></a>14697 {
<a name="l14698"></a>14698   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = ptr_to_cu;
<a name="l14699"></a>14699 
<a name="l14700"></a>14700   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a57e9b37ae0dfd83c0e16565ca75c9781">abbrev_table</a> != NULL)
<a name="l14701"></a>14701     <a class="code" href="dwarf2read_8c.html#a657ffcf72df342d61df4a8893fc6151f">abbrev_table_free</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a57e9b37ae0dfd83c0e16565ca75c9781">abbrev_table</a>);
<a name="l14702"></a>14702   <span class="comment">/* Set this to NULL so that we SEGV if we try to read it later,</span>
<a name="l14703"></a>14703 <span class="comment">     and also because free_comp_unit verifies this is NULL.  */</span>
<a name="l14704"></a>14704   cu-&gt;<a class="code" href="structdwarf2__cu.html#a57e9b37ae0dfd83c0e16565ca75c9781">abbrev_table</a> = NULL;
<a name="l14705"></a>14705 }
<a name="l14706"></a>14706 
<a name="l14707"></a>14707 <span class="comment">/* Returns nonzero if TAG represents a type that we might generate a partial</span>
<a name="l14708"></a>14708 <span class="comment">   symbol for.  */</span>
<a name="l14709"></a>14709 
<a name="l14710"></a>14710 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l14711"></a><a class="code" href="dwarf2read_8c.html#a8992a97e70fdd0a77874d941fa428f86">14711</a> <a class="code" href="dwarf2read_8c.html#a8992a97e70fdd0a77874d941fa428f86">is_type_tag_for_partial</a> (<span class="keywordtype">int</span> tag)
<a name="l14712"></a>14712 {
<a name="l14713"></a>14713   <span class="keywordflow">switch</span> (tag)
<a name="l14714"></a>14714     {
<a name="l14715"></a>14715 <span class="preprocessor">#if 0</span>
<a name="l14716"></a>14716 <span class="preprocessor"></span>    <span class="comment">/* Some types that would be reasonable to generate partial symbols for,</span>
<a name="l14717"></a>14717 <span class="comment">       that we don&#39;t at present.  */</span>
<a name="l14718"></a>14718     <span class="keywordflow">case</span> DW_TAG_array_type:
<a name="l14719"></a>14719     <span class="keywordflow">case</span> DW_TAG_file_type:
<a name="l14720"></a>14720     <span class="keywordflow">case</span> DW_TAG_ptr_to_member_type:
<a name="l14721"></a>14721     <span class="keywordflow">case</span> DW_TAG_set_type:
<a name="l14722"></a>14722     <span class="keywordflow">case</span> DW_TAG_string_type:
<a name="l14723"></a>14723     <span class="keywordflow">case</span> DW_TAG_subroutine_type:
<a name="l14724"></a>14724 <span class="preprocessor">#endif</span>
<a name="l14725"></a>14725 <span class="preprocessor"></span>    <span class="keywordflow">case</span> DW_TAG_base_type:
<a name="l14726"></a>14726     <span class="keywordflow">case</span> DW_TAG_class_type:
<a name="l14727"></a>14727     <span class="keywordflow">case</span> DW_TAG_interface_type:
<a name="l14728"></a>14728     <span class="keywordflow">case</span> DW_TAG_enumeration_type:
<a name="l14729"></a>14729     <span class="keywordflow">case</span> DW_TAG_structure_type:
<a name="l14730"></a>14730     <span class="keywordflow">case</span> DW_TAG_subrange_type:
<a name="l14731"></a>14731     <span class="keywordflow">case</span> DW_TAG_typedef:
<a name="l14732"></a>14732     <span class="keywordflow">case</span> DW_TAG_union_type:
<a name="l14733"></a>14733       <span class="keywordflow">return</span> 1;
<a name="l14734"></a>14734     <span class="keywordflow">default</span>:
<a name="l14735"></a>14735       <span class="keywordflow">return</span> 0;
<a name="l14736"></a>14736     }
<a name="l14737"></a>14737 }
<a name="l14738"></a>14738 
<a name="l14739"></a>14739 <span class="comment">/* Load all DIEs that are interesting for partial symbols into memory.  */</span>
<a name="l14740"></a>14740 
<a name="l14741"></a>14741 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *
<a name="l14742"></a><a class="code" href="dwarf2read_8c.html#a2bf39a75877292252ae39938c7fa6885">14742</a> <a class="code" href="dwarf2read_8c.html#a2bf39a75877292252ae39938c7fa6885">load_partial_dies</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l14743"></a>14743                    <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr, <span class="keywordtype">int</span> building_psymtab)
<a name="l14744"></a>14744 {
<a name="l14745"></a>14745   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l14746"></a>14746   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l14747"></a>14747   <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *part_die;
<a name="l14748"></a>14748   <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *parent_die, *last_die, *first_die = NULL;
<a name="l14749"></a>14749   <span class="keyword">struct </span><a class="code" href="structabbrev__info.html">abbrev_info</a> *abbrev;
<a name="l14750"></a>14750   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l14751"></a>14751   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> load_all = 0;
<a name="l14752"></a>14752   <span class="keywordtype">int</span> nesting_level = 1;
<a name="l14753"></a>14753 
<a name="l14754"></a>14754   parent_die = NULL;
<a name="l14755"></a>14755   last_die = NULL;
<a name="l14756"></a>14756 
<a name="l14757"></a>14757   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a> != NULL);
<a name="l14758"></a>14758   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a86105edb17badc0d1b99c4e4427d2911">load_all_dies</a>)
<a name="l14759"></a>14759     load_all = 1;
<a name="l14760"></a>14760 
<a name="l14761"></a>14761   cu-&gt;<a class="code" href="structdwarf2__cu.html#a1e821881f894272409a466d336a88b1f">partial_dies</a>
<a name="l14762"></a>14762     = htab_create_alloc_ex (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a> / 12,
<a name="l14763"></a>14763                             <a class="code" href="dwarf2read_8c.html#a7206fb65e6b70f6294edf05a454c4182">partial_die_hash</a>,
<a name="l14764"></a>14764                             <a class="code" href="dwarf2read_8c.html#a0e8a120392cd0ef1f19e1eb86c7b43e5">partial_die_eq</a>,
<a name="l14765"></a>14765                             NULL,
<a name="l14766"></a>14766                             &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>,
<a name="l14767"></a>14767                             <a class="code" href="utils_8c.html#a64b0a5e317b6f45f062aa8356111644b">hashtab_obstack_allocate</a>,
<a name="l14768"></a>14768                             <a class="code" href="utils_8c.html#af32d0d55c7c49d59093e66ef695f9513">dummy_obstack_deallocate</a>);
<a name="l14769"></a>14769 
<a name="l14770"></a>14770   part_die = obstack_alloc (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>,
<a name="l14771"></a>14771                             sizeof (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a>));
<a name="l14772"></a>14772 
<a name="l14773"></a>14773   <span class="keywordflow">while</span> (1)
<a name="l14774"></a>14774     {
<a name="l14775"></a>14775       abbrev = <a class="code" href="dwarf2read_8c.html#a1dab71c5bc62528e0736f19d3343e274">peek_die_abbrev</a> (info_ptr, &amp;bytes_read, cu);
<a name="l14776"></a>14776 
<a name="l14777"></a>14777       <span class="comment">/* A NULL abbrev means the end of a series of children.  */</span>
<a name="l14778"></a>14778       <span class="keywordflow">if</span> (abbrev == NULL)
<a name="l14779"></a>14779         {
<a name="l14780"></a>14780           <span class="keywordflow">if</span> (--nesting_level == 0)
<a name="l14781"></a>14781             {
<a name="l14782"></a>14782               <span class="comment">/* PART_DIE was probably the last thing allocated on the</span>
<a name="l14783"></a>14783 <span class="comment">                 comp_unit_obstack, so we could call obstack_free</span>
<a name="l14784"></a>14784 <span class="comment">                 here.  We don&#39;t do that because the waste is small,</span>
<a name="l14785"></a>14785 <span class="comment">                 and will be cleaned up when we&#39;re done with this</span>
<a name="l14786"></a>14786 <span class="comment">                 compilation unit.  This way, we&#39;re also more robust</span>
<a name="l14787"></a>14787 <span class="comment">                 against other users of the comp_unit_obstack.  */</span>
<a name="l14788"></a>14788               <span class="keywordflow">return</span> first_die;
<a name="l14789"></a>14789             }
<a name="l14790"></a>14790           info_ptr += bytes_read;
<a name="l14791"></a>14791           last_die = parent_die;
<a name="l14792"></a>14792           parent_die = parent_die-&gt;<a class="code" href="structpartial__die__info.html#add5cb3fe3a136089a2cafa7027e59687">die_parent</a>;
<a name="l14793"></a>14793           <span class="keywordflow">continue</span>;
<a name="l14794"></a>14794         }
<a name="l14795"></a>14795 
<a name="l14796"></a>14796       <span class="comment">/* Check for template arguments.  We never save these; if</span>
<a name="l14797"></a>14797 <span class="comment">         they&#39;re seen, we just mark the parent, and go on our way.  */</span>
<a name="l14798"></a>14798       <span class="keywordflow">if</span> (parent_die != NULL
<a name="l14799"></a>14799           &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l14800"></a>14800           &amp;&amp; (abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> == DW_TAG_template_type_param
<a name="l14801"></a>14801               || abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> == DW_TAG_template_value_param))
<a name="l14802"></a>14802         {
<a name="l14803"></a>14803           parent_die-&gt;has_template_arguments = 1;
<a name="l14804"></a>14804 
<a name="l14805"></a>14805           <span class="keywordflow">if</span> (!load_all)
<a name="l14806"></a>14806             {
<a name="l14807"></a>14807               <span class="comment">/* We don&#39;t need a partial DIE for the template argument.  */</span>
<a name="l14808"></a>14808               info_ptr = <a class="code" href="dwarf2read_8c.html#a2841c651fdaf6de18181efeb6746de43">skip_one_die</a> (reader, info_ptr + bytes_read, abbrev);
<a name="l14809"></a>14809               <span class="keywordflow">continue</span>;
<a name="l14810"></a>14810             }
<a name="l14811"></a>14811         }
<a name="l14812"></a>14812 
<a name="l14813"></a>14813       <span class="comment">/* We only recurse into c++ subprograms looking for template arguments.</span>
<a name="l14814"></a>14814 <span class="comment">         Skip their other children.  */</span>
<a name="l14815"></a>14815       <span class="keywordflow">if</span> (!load_all
<a name="l14816"></a>14816           &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l14817"></a>14817           &amp;&amp; parent_die != NULL
<a name="l14818"></a>14818           &amp;&amp; parent_die-&gt;tag == DW_TAG_subprogram)
<a name="l14819"></a>14819         {
<a name="l14820"></a>14820           info_ptr = <a class="code" href="dwarf2read_8c.html#a2841c651fdaf6de18181efeb6746de43">skip_one_die</a> (reader, info_ptr + bytes_read, abbrev);
<a name="l14821"></a>14821           <span class="keywordflow">continue</span>;
<a name="l14822"></a>14822         }
<a name="l14823"></a>14823 
<a name="l14824"></a>14824       <span class="comment">/* Check whether this DIE is interesting enough to save.  Normally</span>
<a name="l14825"></a>14825 <span class="comment">         we would not be interested in members here, but there may be</span>
<a name="l14826"></a>14826 <span class="comment">         later variables referencing them via DW_AT_specification (for</span>
<a name="l14827"></a>14827 <span class="comment">         static members).  */</span>
<a name="l14828"></a>14828       <span class="keywordflow">if</span> (!load_all
<a name="l14829"></a>14829           &amp;&amp; !<a class="code" href="dwarf2read_8c.html#a8992a97e70fdd0a77874d941fa428f86">is_type_tag_for_partial</a> (abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a>)
<a name="l14830"></a>14830           &amp;&amp; abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> != DW_TAG_constant
<a name="l14831"></a>14831           &amp;&amp; abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> != DW_TAG_enumerator
<a name="l14832"></a>14832           &amp;&amp; abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> != DW_TAG_subprogram
<a name="l14833"></a>14833           &amp;&amp; abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> != DW_TAG_lexical_block
<a name="l14834"></a>14834           &amp;&amp; abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> != DW_TAG_variable
<a name="l14835"></a>14835           &amp;&amp; abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> != DW_TAG_namespace
<a name="l14836"></a>14836           &amp;&amp; abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> != DW_TAG_module
<a name="l14837"></a>14837           &amp;&amp; abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> != DW_TAG_member
<a name="l14838"></a>14838           &amp;&amp; abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> != DW_TAG_imported_unit)
<a name="l14839"></a>14839         {
<a name="l14840"></a>14840           <span class="comment">/* Otherwise we skip to the next sibling, if any.  */</span>
<a name="l14841"></a>14841           info_ptr = <a class="code" href="dwarf2read_8c.html#a2841c651fdaf6de18181efeb6746de43">skip_one_die</a> (reader, info_ptr + bytes_read, abbrev);
<a name="l14842"></a>14842           <span class="keywordflow">continue</span>;
<a name="l14843"></a>14843         }
<a name="l14844"></a>14844 
<a name="l14845"></a>14845       info_ptr = <a class="code" href="dwarf2read_8c.html#a288297ebd7e0b6037f0b863192d9cf8c">read_partial_die</a> (reader, part_die, abbrev, bytes_read,
<a name="l14846"></a>14846                                    info_ptr);
<a name="l14847"></a>14847 
<a name="l14848"></a>14848       <span class="comment">/* This two-pass algorithm for processing partial symbols has a</span>
<a name="l14849"></a>14849 <span class="comment">         high cost in cache pressure.  Thus, handle some simple cases</span>
<a name="l14850"></a>14850 <span class="comment">         here which cover the majority of C partial symbols.  DIEs</span>
<a name="l14851"></a>14851 <span class="comment">         which neither have specification tags in them, nor could have</span>
<a name="l14852"></a>14852 <span class="comment">         specification tags elsewhere pointing at them, can simply be</span>
<a name="l14853"></a>14853 <span class="comment">         processed and discarded.</span>
<a name="l14854"></a>14854 <span class="comment"></span>
<a name="l14855"></a>14855 <span class="comment">         This segment is also optional; scan_partial_symbols and</span>
<a name="l14856"></a>14856 <span class="comment">         add_partial_symbol will handle these DIEs if we chain</span>
<a name="l14857"></a>14857 <span class="comment">         them in normally.  When compilers which do not emit large</span>
<a name="l14858"></a>14858 <span class="comment">         quantities of duplicate debug information are more common,</span>
<a name="l14859"></a>14859 <span class="comment">         this code can probably be removed.  */</span>
<a name="l14860"></a>14860 
<a name="l14861"></a>14861       <span class="comment">/* Any complete simple types at the top level (pretty much all</span>
<a name="l14862"></a>14862 <span class="comment">         of them, for a language without namespaces), can be processed</span>
<a name="l14863"></a>14863 <span class="comment">         directly.  */</span>
<a name="l14864"></a>14864       <span class="keywordflow">if</span> (parent_die == NULL
<a name="l14865"></a>14865           &amp;&amp; part_die-&gt;has_specification == 0
<a name="l14866"></a>14866           &amp;&amp; part_die-&gt;is_declaration == 0
<a name="l14867"></a>14867           &amp;&amp; ((part_die-&gt;tag == DW_TAG_typedef &amp;&amp; !part_die-&gt;has_children)
<a name="l14868"></a>14868               || part_die-&gt;tag == DW_TAG_base_type
<a name="l14869"></a>14869               || part_die-&gt;tag == DW_TAG_subrange_type))
<a name="l14870"></a>14870         {
<a name="l14871"></a>14871           <span class="keywordflow">if</span> (building_psymtab &amp;&amp; part_die-&gt;name != NULL)
<a name="l14872"></a>14872             <a class="code" href="psympriv_8h.html#a62f8da83aee3f33ec2da32c0e583260a">add_psymbol_to_list</a> (part_die-&gt;name, strlen (part_die-&gt;name), 0,
<a name="l14873"></a>14873                                  <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>,
<a name="l14874"></a>14874                                  &amp;objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>,
<a name="l14875"></a>14875                                  0, (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 0, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>, objfile);
<a name="l14876"></a>14876           info_ptr = <a class="code" href="dwarf2read_8c.html#a2af2667574f99c03f3ff8f763221a47f">locate_pdi_sibling</a> (reader, part_die, info_ptr);
<a name="l14877"></a>14877           <span class="keywordflow">continue</span>;
<a name="l14878"></a>14878         }
<a name="l14879"></a>14879 
<a name="l14880"></a>14880       <span class="comment">/* The exception for DW_TAG_typedef with has_children above is</span>
<a name="l14881"></a>14881 <span class="comment">         a workaround of GCC PR debug/47510.  In the case of this complaint</span>
<a name="l14882"></a>14882 <span class="comment">         type_name_no_tag_or_error will error on such types later.</span>
<a name="l14883"></a>14883 <span class="comment"></span>
<a name="l14884"></a>14884 <span class="comment">         GDB skipped children of DW_TAG_typedef by the shortcut above and then</span>
<a name="l14885"></a>14885 <span class="comment">         it could not find the child DIEs referenced later, this is checked</span>
<a name="l14886"></a>14886 <span class="comment">         above.  In correct DWARF DW_TAG_typedef should have no children.  */</span>
<a name="l14887"></a>14887 
<a name="l14888"></a>14888       <span class="keywordflow">if</span> (part_die-&gt;tag == DW_TAG_typedef &amp;&amp; part_die-&gt;has_children)
<a name="l14889"></a>14889         <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l14890"></a>14890                    <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_TAG_typedef has childen - GCC PR debug/47510 bug &quot;</span>
<a name="l14891"></a>14891                      <span class="stringliteral">&quot;- DIE at 0x%x [in module %s]&quot;</span>),
<a name="l14892"></a>14892                    part_die-&gt;<a class="code" href="structpartial__die__info.html#a5db48cad0baeb15b63822fdaa0136c04">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l14893"></a>14893 
<a name="l14894"></a>14894       <span class="comment">/* If we&#39;re at the second level, and we&#39;re an enumerator, and</span>
<a name="l14895"></a>14895 <span class="comment">         our parent has no specification (meaning possibly lives in a</span>
<a name="l14896"></a>14896 <span class="comment">         namespace elsewhere), then we can add the partial symbol now</span>
<a name="l14897"></a>14897 <span class="comment">         instead of queueing it.  */</span>
<a name="l14898"></a>14898       <span class="keywordflow">if</span> (part_die-&gt;tag == DW_TAG_enumerator
<a name="l14899"></a>14899           &amp;&amp; parent_die != NULL
<a name="l14900"></a>14900           &amp;&amp; parent_die-&gt;<a class="code" href="structpartial__die__info.html#add5cb3fe3a136089a2cafa7027e59687">die_parent</a> == NULL
<a name="l14901"></a>14901           &amp;&amp; parent_die-&gt;tag == DW_TAG_enumeration_type
<a name="l14902"></a>14902           &amp;&amp; parent_die-&gt;has_specification == 0)
<a name="l14903"></a>14903         {
<a name="l14904"></a>14904           <span class="keywordflow">if</span> (part_die-&gt;name == NULL)
<a name="l14905"></a>14905             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l14906"></a>14906                        <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;malformed enumerator DIE ignored&quot;</span>));
<a name="l14907"></a>14907           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (building_psymtab)
<a name="l14908"></a>14908             <a class="code" href="psympriv_8h.html#a62f8da83aee3f33ec2da32c0e583260a">add_psymbol_to_list</a> (part_die-&gt;name, strlen (part_die-&gt;name), 0,
<a name="l14909"></a>14909                                  <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a5268309778a6727d08106ff9f2966e54">LOC_CONST</a>,
<a name="l14910"></a>14910                                  (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l14911"></a>14911                                   || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>)
<a name="l14912"></a>14912                                  ? &amp;objfile-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>
<a name="l14913"></a>14913                                  : &amp;objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>,
<a name="l14914"></a>14914                                  0, (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 0, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>, objfile);
<a name="l14915"></a>14915 
<a name="l14916"></a>14916           info_ptr = <a class="code" href="dwarf2read_8c.html#a2af2667574f99c03f3ff8f763221a47f">locate_pdi_sibling</a> (reader, part_die, info_ptr);
<a name="l14917"></a>14917           <span class="keywordflow">continue</span>;
<a name="l14918"></a>14918         }
<a name="l14919"></a>14919 
<a name="l14920"></a>14920       <span class="comment">/* We&#39;ll save this DIE so link it in.  */</span>
<a name="l14921"></a>14921       part_die-&gt;<a class="code" href="structpartial__die__info.html#add5cb3fe3a136089a2cafa7027e59687">die_parent</a> = parent_die;
<a name="l14922"></a>14922       part_die-&gt;<a class="code" href="structpartial__die__info.html#ad62d4a24f9c19d6835843c6a066fea36">die_sibling</a> = NULL;
<a name="l14923"></a>14923       part_die-&gt;<a class="code" href="structpartial__die__info.html#a7761befb396a96f0d770f8b2a126291b">die_child</a> = NULL;
<a name="l14924"></a>14924 
<a name="l14925"></a>14925       <span class="keywordflow">if</span> (last_die &amp;&amp; last_die == parent_die)
<a name="l14926"></a>14926         last_die-&gt;<a class="code" href="structpartial__die__info.html#a7761befb396a96f0d770f8b2a126291b">die_child</a> = part_die;
<a name="l14927"></a>14927       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (last_die)
<a name="l14928"></a>14928         last_die-&gt;<a class="code" href="structpartial__die__info.html#ad62d4a24f9c19d6835843c6a066fea36">die_sibling</a> = part_die;
<a name="l14929"></a>14929 
<a name="l14930"></a>14930       last_die = part_die;
<a name="l14931"></a>14931 
<a name="l14932"></a>14932       <span class="keywordflow">if</span> (first_die == NULL)
<a name="l14933"></a>14933         first_die = part_die;
<a name="l14934"></a>14934 
<a name="l14935"></a>14935       <span class="comment">/* Maybe add the DIE to the hash table.  Not all DIEs that we</span>
<a name="l14936"></a>14936 <span class="comment">         find interesting need to be in the hash table, because we</span>
<a name="l14937"></a>14937 <span class="comment">         also have the parent/sibling/child chains; only those that we</span>
<a name="l14938"></a>14938 <span class="comment">         might refer to by offset later during partial symbol reading.</span>
<a name="l14939"></a>14939 <span class="comment"></span>
<a name="l14940"></a>14940 <span class="comment">         For now this means things that might have be the target of a</span>
<a name="l14941"></a>14941 <span class="comment">         DW_AT_specification, DW_AT_abstract_origin, or</span>
<a name="l14942"></a>14942 <span class="comment">         DW_AT_extension.  DW_AT_extension will refer only to</span>
<a name="l14943"></a>14943 <span class="comment">         namespaces; DW_AT_abstract_origin refers to functions (and</span>
<a name="l14944"></a>14944 <span class="comment">         many things under the function DIE, but we do not recurse</span>
<a name="l14945"></a>14945 <span class="comment">         into function DIEs during partial symbol reading) and</span>
<a name="l14946"></a>14946 <span class="comment">         possibly variables as well; DW_AT_specification refers to</span>
<a name="l14947"></a>14947 <span class="comment">         declarations.  Declarations ought to have the DW_AT_declaration</span>
<a name="l14948"></a>14948 <span class="comment">         flag.  It happens that GCC forgets to put it in sometimes, but</span>
<a name="l14949"></a>14949 <span class="comment">         only for functions, not for types.</span>
<a name="l14950"></a>14950 <span class="comment"></span>
<a name="l14951"></a>14951 <span class="comment">         Adding more things than necessary to the hash table is harmless</span>
<a name="l14952"></a>14952 <span class="comment">         except for the performance cost.  Adding too few will result in</span>
<a name="l14953"></a>14953 <span class="comment">         wasted time in find_partial_die, when we reread the compilation</span>
<a name="l14954"></a>14954 <span class="comment">         unit with load_all_dies set.  */</span>
<a name="l14955"></a>14955 
<a name="l14956"></a>14956       <span class="keywordflow">if</span> (load_all
<a name="l14957"></a>14957           || abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> == DW_TAG_constant
<a name="l14958"></a>14958           || abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> == DW_TAG_subprogram
<a name="l14959"></a>14959           || abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> == DW_TAG_variable
<a name="l14960"></a>14960           || abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a> == DW_TAG_namespace
<a name="l14961"></a>14961           || part_die-&gt;is_declaration)
<a name="l14962"></a>14962         {
<a name="l14963"></a>14963           <span class="keywordtype">void</span> **slot;
<a name="l14964"></a>14964 
<a name="l14965"></a>14965           slot = htab_find_slot_with_hash (cu-&gt;<a class="code" href="structdwarf2__cu.html#a1e821881f894272409a466d336a88b1f">partial_dies</a>, part_die,
<a name="l14966"></a>14966                                            part_die-&gt;<a class="code" href="structpartial__die__info.html#a5db48cad0baeb15b63822fdaa0136c04">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, INSERT);
<a name="l14967"></a>14967           *slot = part_die;
<a name="l14968"></a>14968         }
<a name="l14969"></a>14969 
<a name="l14970"></a>14970       part_die = obstack_alloc (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>,
<a name="l14971"></a>14971                                 sizeof (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a>));
<a name="l14972"></a>14972 
<a name="l14973"></a>14973       <span class="comment">/* For some DIEs we want to follow their children (if any).  For C</span>
<a name="l14974"></a>14974 <span class="comment">         we have no reason to follow the children of structures; for other</span>
<a name="l14975"></a>14975 <span class="comment">         languages we have to, so that we can get at method physnames</span>
<a name="l14976"></a>14976 <span class="comment">         to infer fully qualified class names, for DW_AT_specification,</span>
<a name="l14977"></a>14977 <span class="comment">         and for C++ template arguments.  For C++, we also look one level</span>
<a name="l14978"></a>14978 <span class="comment">         inside functions to find template arguments (if the name of the</span>
<a name="l14979"></a>14979 <span class="comment">         function does not already contain the template arguments).</span>
<a name="l14980"></a>14980 <span class="comment"></span>
<a name="l14981"></a>14981 <span class="comment">         For Ada, we need to scan the children of subprograms and lexical</span>
<a name="l14982"></a>14982 <span class="comment">         blocks as well because Ada allows the definition of nested</span>
<a name="l14983"></a>14983 <span class="comment">         entities that could be interesting for the debugger, such as</span>
<a name="l14984"></a>14984 <span class="comment">         nested subprograms for instance.  */</span>
<a name="l14985"></a>14985       <span class="keywordflow">if</span> (last_die-&gt;has_children
<a name="l14986"></a>14986           &amp;&amp; (load_all
<a name="l14987"></a>14987               || last_die-&gt;tag == DW_TAG_namespace
<a name="l14988"></a>14988               || last_die-&gt;tag == DW_TAG_module
<a name="l14989"></a>14989               || last_die-&gt;tag == DW_TAG_enumeration_type
<a name="l14990"></a>14990               || (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l14991"></a>14991                   &amp;&amp; last_die-&gt;tag == DW_TAG_subprogram
<a name="l14992"></a>14992                   &amp;&amp; (last_die-&gt;name == NULL
<a name="l14993"></a>14993                       || <a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (last_die-&gt;name, <span class="charliteral">&#39;&lt;&#39;</span>) == NULL))
<a name="l14994"></a>14994               || (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202ad300f80a4c96edb04defba2280620a49">language_c</a>
<a name="l14995"></a>14995                   &amp;&amp; (last_die-&gt;tag == DW_TAG_class_type
<a name="l14996"></a>14996                       || last_die-&gt;tag == DW_TAG_interface_type
<a name="l14997"></a>14997                       || last_die-&gt;tag == DW_TAG_structure_type
<a name="l14998"></a>14998                       || last_die-&gt;tag == DW_TAG_union_type))
<a name="l14999"></a>14999               || (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>
<a name="l15000"></a>15000                   &amp;&amp; (last_die-&gt;tag == DW_TAG_subprogram
<a name="l15001"></a>15001                       || last_die-&gt;tag == DW_TAG_lexical_block))))
<a name="l15002"></a>15002         {
<a name="l15003"></a>15003           nesting_level++;
<a name="l15004"></a>15004           parent_die = last_die;
<a name="l15005"></a>15005           <span class="keywordflow">continue</span>;
<a name="l15006"></a>15006         }
<a name="l15007"></a>15007 
<a name="l15008"></a>15008       <span class="comment">/* Otherwise we skip to the next sibling, if any.  */</span>
<a name="l15009"></a>15009       info_ptr = <a class="code" href="dwarf2read_8c.html#a2af2667574f99c03f3ff8f763221a47f">locate_pdi_sibling</a> (reader, last_die, info_ptr);
<a name="l15010"></a>15010 
<a name="l15011"></a>15011       <span class="comment">/* Back to the top, do it again.  */</span>
<a name="l15012"></a>15012     }
<a name="l15013"></a>15013 }
<a name="l15014"></a>15014 
<a name="l15015"></a>15015 <span class="comment">/* Read a minimal amount of information into the minimal die structure.  */</span>
<a name="l15016"></a>15016 
<a name="l15017"></a>15017 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l15018"></a><a class="code" href="dwarf2read_8c.html#a288297ebd7e0b6037f0b863192d9cf8c">15018</a> <a class="code" href="dwarf2read_8c.html#a288297ebd7e0b6037f0b863192d9cf8c">read_partial_die</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l15019"></a>15019                   <span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *part_die,
<a name="l15020"></a>15020                   <span class="keyword">struct</span> <a class="code" href="structabbrev__info.html">abbrev_info</a> *abbrev, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> abbrev_len,
<a name="l15021"></a>15021                   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr)
<a name="l15022"></a>15022 {
<a name="l15023"></a>15023   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l15024"></a>15024   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l15025"></a>15025   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structbuffer.html">buffer</a> = reader-&gt;<a class="code" href="structdie__reader__specs.html#a923f3b4252ec94584560d5433e848dc0">buffer</a>;
<a name="l15026"></a>15026   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l15027"></a>15027   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> attr;
<a name="l15028"></a>15028   <span class="keywordtype">int</span> has_low_pc_attr = 0;
<a name="l15029"></a>15029   <span class="keywordtype">int</span> has_high_pc_attr = 0;
<a name="l15030"></a>15030   <span class="keywordtype">int</span> high_pc_relative = 0;
<a name="l15031"></a>15031 
<a name="l15032"></a>15032   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (part_die, 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a>));
<a name="l15033"></a>15033 
<a name="l15034"></a>15034   part_die-&gt;<a class="code" href="structpartial__die__info.html#a5db48cad0baeb15b63822fdaa0136c04">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = info_ptr - buffer;
<a name="l15035"></a>15035 
<a name="l15036"></a>15036   info_ptr += abbrev_len;
<a name="l15037"></a>15037 
<a name="l15038"></a>15038   <span class="keywordflow">if</span> (abbrev == NULL)
<a name="l15039"></a>15039     <span class="keywordflow">return</span> info_ptr;
<a name="l15040"></a>15040 
<a name="l15041"></a>15041   part_die-&gt;tag = abbrev-&gt;<a class="code" href="structabbrev__info.html#afc524e4ca9bcd8557dec878dd438a0d2">tag</a>;
<a name="l15042"></a>15042   part_die-&gt;has_children = abbrev-&gt;<a class="code" href="structabbrev__info.html#ac84c5aceafdfea0a95c619f623b78de1">has_children</a>;
<a name="l15043"></a>15043 
<a name="l15044"></a>15044   <span class="keywordflow">for</span> (i = 0; i &lt; abbrev-&gt;<a class="code" href="structabbrev__info.html#a34d2e21fe3925a6c1613e8e42993581e">num_attrs</a>; ++i)
<a name="l15045"></a>15045     {
<a name="l15046"></a>15046       info_ptr = <a class="code" href="dwarf2read_8c.html#a08e1a18f85e288f9241d3baab2ded2b0">read_attribute</a> (reader, &amp;attr, &amp;abbrev-&gt;<a class="code" href="structabbrev__info.html#aa70664d01df5b3d3567c6841c9de22f2">attrs</a>[i], info_ptr);
<a name="l15047"></a>15047 
<a name="l15048"></a>15048       <span class="comment">/* Store the data if it is of an attribute we want to keep in a</span>
<a name="l15049"></a>15049 <span class="comment">         partial symbol table.  */</span>
<a name="l15050"></a>15050       <span class="keywordflow">switch</span> (attr.name)
<a name="l15051"></a>15051         {
<a name="l15052"></a>15052         <span class="keywordflow">case</span> DW_AT_name:
<a name="l15053"></a>15053           <span class="keywordflow">switch</span> (part_die-&gt;tag)
<a name="l15054"></a>15054             {
<a name="l15055"></a>15055             <span class="keywordflow">case</span> DW_TAG_compile_unit:
<a name="l15056"></a>15056             <span class="keywordflow">case</span> DW_TAG_partial_unit:
<a name="l15057"></a>15057             <span class="keywordflow">case</span> DW_TAG_type_unit:
<a name="l15058"></a>15058               <span class="comment">/* Compilation units have a DW_AT_name that is a filename, not</span>
<a name="l15059"></a>15059 <span class="comment">                 a source language identifier.  */</span>
<a name="l15060"></a>15060             <span class="keywordflow">case</span> DW_TAG_enumeration_type:
<a name="l15061"></a>15061             <span class="keywordflow">case</span> DW_TAG_enumerator:
<a name="l15062"></a>15062               <span class="comment">/* These tags always have simple identifiers already; no need</span>
<a name="l15063"></a>15063 <span class="comment">                 to canonicalize them.  */</span>
<a name="l15064"></a>15064               part_die-&gt;name = <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (&amp;attr);
<a name="l15065"></a>15065               <span class="keywordflow">break</span>;
<a name="l15066"></a>15066             <span class="keywordflow">default</span>:
<a name="l15067"></a>15067               part_die-&gt;name
<a name="l15068"></a>15068                 = <a class="code" href="dwarf2read_8c.html#a15617623710ce00d6f31263aad9bd432">dwarf2_canonicalize_name</a> (<a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (&amp;attr), cu,
<a name="l15069"></a>15069                                             &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>);
<a name="l15070"></a>15070               <span class="keywordflow">break</span>;
<a name="l15071"></a>15071             }
<a name="l15072"></a>15072           <span class="keywordflow">break</span>;
<a name="l15073"></a>15073         <span class="keywordflow">case</span> DW_AT_linkage_name:
<a name="l15074"></a>15074         <span class="keywordflow">case</span> DW_AT_MIPS_linkage_name:
<a name="l15075"></a>15075           <span class="comment">/* Note that both forms of linkage name might appear.  We</span>
<a name="l15076"></a>15076 <span class="comment">             assume they will be the same, and we only store the last</span>
<a name="l15077"></a>15077 <span class="comment">             one we see.  */</span>
<a name="l15078"></a>15078           <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l15079"></a>15079             part_die-&gt;name = <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (&amp;attr);
<a name="l15080"></a>15080           part_die-&gt;linkage_name = <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (&amp;attr);
<a name="l15081"></a>15081           <span class="keywordflow">break</span>;
<a name="l15082"></a>15082         <span class="keywordflow">case</span> DW_AT_low_pc:
<a name="l15083"></a>15083           has_low_pc_attr = 1;
<a name="l15084"></a>15084           part_die-&gt;<a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a> = <a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (&amp;attr);
<a name="l15085"></a>15085           <span class="keywordflow">break</span>;
<a name="l15086"></a>15086         <span class="keywordflow">case</span> DW_AT_high_pc:
<a name="l15087"></a>15087           has_high_pc_attr = 1;
<a name="l15088"></a>15088           <span class="keywordflow">if</span> (attr.form == DW_FORM_addr
<a name="l15089"></a>15089               || attr.form == DW_FORM_GNU_addr_index)
<a name="l15090"></a>15090             part_die-&gt;<a class="code" href="structpartial__die__info.html#a958cea19f3de0168488931ed04efc700">highpc</a> = <a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (&amp;attr);
<a name="l15091"></a>15091           <span class="keywordflow">else</span>
<a name="l15092"></a>15092             {
<a name="l15093"></a>15093               high_pc_relative = 1;
<a name="l15094"></a>15094               part_die-&gt;<a class="code" href="structpartial__die__info.html#a958cea19f3de0168488931ed04efc700">highpc</a> = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (&amp;attr);
<a name="l15095"></a>15095             }
<a name="l15096"></a>15096           <span class="keywordflow">break</span>;
<a name="l15097"></a>15097         <span class="keywordflow">case</span> DW_AT_location:
<a name="l15098"></a>15098           <span class="comment">/* Support the .debug_loc offsets.  */</span>
<a name="l15099"></a>15099           <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (&amp;attr))
<a name="l15100"></a>15100             {
<a name="l15101"></a>15101                part_die-&gt;<a class="code" href="structpartial__die__info.html#ab829867c034259d5dda8a61679232609">d</a>.locdesc = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (&amp;attr);
<a name="l15102"></a>15102             }
<a name="l15103"></a>15103           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#aa2b54436e7d13233cd6b866f562f637e">attr_form_is_section_offset</a> (&amp;attr))
<a name="l15104"></a>15104             {
<a name="l15105"></a>15105               <a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">dwarf2_complex_location_expr_complaint</a> ();
<a name="l15106"></a>15106             }
<a name="l15107"></a>15107           <span class="keywordflow">else</span>
<a name="l15108"></a>15108             {
<a name="l15109"></a>15109               <a class="code" href="dwarf2read_8c.html#a0e9c948efe625df13875d3d70d218b65">dwarf2_invalid_attrib_class_complaint</a> (<span class="stringliteral">&quot;DW_AT_location&quot;</span>,
<a name="l15110"></a>15110                                                      <span class="stringliteral">&quot;partial symbol information&quot;</span>);
<a name="l15111"></a>15111             }
<a name="l15112"></a>15112           <span class="keywordflow">break</span>;
<a name="l15113"></a>15113         <span class="keywordflow">case</span> DW_AT_external:
<a name="l15114"></a>15114           part_die-&gt;is_external = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (&amp;attr);
<a name="l15115"></a>15115           <span class="keywordflow">break</span>;
<a name="l15116"></a>15116         <span class="keywordflow">case</span> DW_AT_declaration:
<a name="l15117"></a>15117           part_die-&gt;is_declaration = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (&amp;attr);
<a name="l15118"></a>15118           <span class="keywordflow">break</span>;
<a name="l15119"></a>15119         <span class="keywordflow">case</span> DW_AT_type:
<a name="l15120"></a>15120           part_die-&gt;has_type = 1;
<a name="l15121"></a>15121           <span class="keywordflow">break</span>;
<a name="l15122"></a>15122         <span class="keywordflow">case</span> DW_AT_abstract_origin:
<a name="l15123"></a>15123         <span class="keywordflow">case</span> DW_AT_specification:
<a name="l15124"></a>15124         <span class="keywordflow">case</span> DW_AT_extension:
<a name="l15125"></a>15125           part_die-&gt;has_specification = 1;
<a name="l15126"></a>15126           part_die-&gt;<a class="code" href="structpartial__die__info.html#ac9faa23b0720fe4585288e1286917877">spec_offset</a> = <a class="code" href="dwarf2read_8c.html#a28e7eb63f317d51f9be16584d407c508">dwarf2_get_ref_die_offset</a> (&amp;attr);
<a name="l15127"></a>15127           part_die-&gt;spec_is_dwz = (attr.form == DW_FORM_GNU_ref_alt
<a name="l15128"></a>15128                                    || cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a>);
<a name="l15129"></a>15129           <span class="keywordflow">break</span>;
<a name="l15130"></a>15130         <span class="keywordflow">case</span> DW_AT_sibling:
<a name="l15131"></a>15131           <span class="comment">/* Ignore absolute siblings, they might point outside of</span>
<a name="l15132"></a>15132 <span class="comment">             the current compile unit.  */</span>
<a name="l15133"></a>15133           <span class="keywordflow">if</span> (attr.form == DW_FORM_ref_addr)
<a name="l15134"></a>15134             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l15135"></a>15135                        <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;ignoring absolute DW_AT_sibling&quot;</span>));
<a name="l15136"></a>15136           <span class="keywordflow">else</span>
<a name="l15137"></a>15137             part_die-&gt;<a class="code" href="structpartial__die__info.html#aaf967ab6265b2f79cd8cc292ee597c49">sibling</a> = buffer + <a class="code" href="dwarf2read_8c.html#a28e7eb63f317d51f9be16584d407c508">dwarf2_get_ref_die_offset</a> (&amp;attr).<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l15138"></a>15138           <span class="keywordflow">break</span>;
<a name="l15139"></a>15139         <span class="keywordflow">case</span> DW_AT_byte_size:
<a name="l15140"></a>15140           part_die-&gt;has_byte_size = 1;
<a name="l15141"></a>15141           <span class="keywordflow">break</span>;
<a name="l15142"></a>15142         <span class="keywordflow">case</span> DW_AT_calling_convention:
<a name="l15143"></a>15143           <span class="comment">/* DWARF doesn&#39;t provide a way to identify a program&#39;s source-level</span>
<a name="l15144"></a>15144 <span class="comment">             entry point.  DW_AT_calling_convention attributes are only meant</span>
<a name="l15145"></a>15145 <span class="comment">             to describe functions&#39; calling conventions.</span>
<a name="l15146"></a>15146 <span class="comment"></span>
<a name="l15147"></a>15147 <span class="comment">             However, because it&#39;s a necessary piece of information in</span>
<a name="l15148"></a>15148 <span class="comment">             Fortran, and because DW_CC_program is the only piece of debugging</span>
<a name="l15149"></a>15149 <span class="comment">             information whose definition refers to a &#39;main program&#39; at all,</span>
<a name="l15150"></a>15150 <span class="comment">             several compilers have begun marking Fortran main programs with</span>
<a name="l15151"></a>15151 <span class="comment">             DW_CC_program --- even when those functions use the standard</span>
<a name="l15152"></a>15152 <span class="comment">             calling conventions.</span>
<a name="l15153"></a>15153 <span class="comment"></span>
<a name="l15154"></a>15154 <span class="comment">             So until DWARF specifies a way to provide this information and</span>
<a name="l15155"></a>15155 <span class="comment">             compilers pick up the new representation, we&#39;ll support this</span>
<a name="l15156"></a>15156 <span class="comment">             practice.  */</span>
<a name="l15157"></a>15157           <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (&amp;attr) == DW_CC_program
<a name="l15158"></a>15158               &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>)
<a name="l15159"></a>15159             {
<a name="l15160"></a>15160               <a class="code" href="symtab_8c.html#a117dddea071e8f0b701e2d724f72a671">set_main_name</a> (part_die-&gt;name);
<a name="l15161"></a>15161 
<a name="l15162"></a>15162               <span class="comment">/* As this DIE has a static linkage the name would be difficult</span>
<a name="l15163"></a>15163 <span class="comment">                 to look up later.  */</span>
<a name="l15164"></a>15164               <a class="code" href="symtab_8c.html#a45ae06cf39e854b1068058102f0c8234">language_of_main</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>;
<a name="l15165"></a>15165             }
<a name="l15166"></a>15166           <span class="keywordflow">break</span>;
<a name="l15167"></a>15167         <span class="keywordflow">case</span> DW_AT_inline:
<a name="l15168"></a>15168           <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (&amp;attr) == DW_INL_inlined
<a name="l15169"></a>15169               || <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (&amp;attr) == DW_INL_declared_inlined)
<a name="l15170"></a>15170             part_die-&gt;may_be_inlined = 1;
<a name="l15171"></a>15171           <span class="keywordflow">break</span>;
<a name="l15172"></a>15172 
<a name="l15173"></a>15173         <span class="keywordflow">case</span> DW_AT_import:
<a name="l15174"></a>15174           <span class="keywordflow">if</span> (part_die-&gt;tag == DW_TAG_imported_unit)
<a name="l15175"></a>15175             {
<a name="l15176"></a>15176               part_die-&gt;<a class="code" href="structpartial__die__info.html#ab829867c034259d5dda8a61679232609">d</a>.offset = <a class="code" href="dwarf2read_8c.html#a28e7eb63f317d51f9be16584d407c508">dwarf2_get_ref_die_offset</a> (&amp;attr);
<a name="l15177"></a>15177               part_die-&gt;is_dwz = (attr.form == DW_FORM_GNU_ref_alt
<a name="l15178"></a>15178                                   || cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a>);
<a name="l15179"></a>15179             }
<a name="l15180"></a>15180           <span class="keywordflow">break</span>;
<a name="l15181"></a>15181 
<a name="l15182"></a>15182         <span class="keywordflow">default</span>:
<a name="l15183"></a>15183           <span class="keywordflow">break</span>;
<a name="l15184"></a>15184         }
<a name="l15185"></a>15185     }
<a name="l15186"></a>15186 
<a name="l15187"></a>15187   <span class="keywordflow">if</span> (high_pc_relative)
<a name="l15188"></a>15188     part_die-&gt;<a class="code" href="structpartial__die__info.html#a958cea19f3de0168488931ed04efc700">highpc</a> += part_die-&gt;<a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a>;
<a name="l15189"></a>15189 
<a name="l15190"></a>15190   <span class="keywordflow">if</span> (has_low_pc_attr &amp;&amp; has_high_pc_attr)
<a name="l15191"></a>15191     {
<a name="l15192"></a>15192       <span class="comment">/* When using the GNU linker, .gnu.linkonce. sections are used to</span>
<a name="l15193"></a>15193 <span class="comment">         eliminate duplicate copies of functions and vtables and such.</span>
<a name="l15194"></a>15194 <span class="comment">         The linker will arbitrarily choose one and discard the others.</span>
<a name="l15195"></a>15195 <span class="comment">         The AT_*_pc values for such functions refer to local labels in</span>
<a name="l15196"></a>15196 <span class="comment">         these sections.  If the section from that file was discarded, the</span>
<a name="l15197"></a>15197 <span class="comment">         labels are not in the output, so the relocs get a value of 0.</span>
<a name="l15198"></a>15198 <span class="comment">         If this is a discarded function, mark the pc bounds as invalid,</span>
<a name="l15199"></a>15199 <span class="comment">         so that GDB will ignore it.  */</span>
<a name="l15200"></a>15200       <span class="keywordflow">if</span> (part_die-&gt;<a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a> == 0 &amp;&amp; !dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ab6b03c3a65fa04f04741158e8aebc895">has_section_at_zero</a>)
<a name="l15201"></a>15201         {
<a name="l15202"></a>15202           <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l15203"></a>15203 
<a name="l15204"></a>15204           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l15205"></a>15205                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_AT_low_pc %s is zero &quot;</span>
<a name="l15206"></a>15206                        <span class="stringliteral">&quot;for DIE at 0x%x [in module %s]&quot;</span>),
<a name="l15207"></a>15207                      <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, part_die-&gt;<a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a>),
<a name="l15208"></a>15208                      part_die-&gt;<a class="code" href="structpartial__die__info.html#a5db48cad0baeb15b63822fdaa0136c04">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l15209"></a>15209         }
<a name="l15210"></a>15210       <span class="comment">/* dwarf2_get_pc_bounds has also the strict low &lt; high requirement.  */</span>
<a name="l15211"></a>15211       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (part_die-&gt;<a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a> &gt;= part_die-&gt;<a class="code" href="structpartial__die__info.html#a958cea19f3de0168488931ed04efc700">highpc</a>)
<a name="l15212"></a>15212         {
<a name="l15213"></a>15213           <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l15214"></a>15214 
<a name="l15215"></a>15215           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l15216"></a>15216                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_AT_low_pc %s is not &lt; DW_AT_high_pc %s &quot;</span>
<a name="l15217"></a>15217                        <span class="stringliteral">&quot;for DIE at 0x%x [in module %s]&quot;</span>),
<a name="l15218"></a>15218                      <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, part_die-&gt;<a class="code" href="structpartial__die__info.html#af1bcb309463929bd54a45fccdc98fdb5">lowpc</a>),
<a name="l15219"></a>15219                      <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, part_die-&gt;<a class="code" href="structpartial__die__info.html#a958cea19f3de0168488931ed04efc700">highpc</a>),
<a name="l15220"></a>15220                      part_die-&gt;<a class="code" href="structpartial__die__info.html#a5db48cad0baeb15b63822fdaa0136c04">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l15221"></a>15221         }
<a name="l15222"></a>15222       <span class="keywordflow">else</span>
<a name="l15223"></a>15223         part_die-&gt;has_pc_info = 1;
<a name="l15224"></a>15224     }
<a name="l15225"></a>15225 
<a name="l15226"></a>15226   <span class="keywordflow">return</span> info_ptr;
<a name="l15227"></a>15227 }
<a name="l15228"></a>15228 
<a name="l15229"></a>15229 <span class="comment">/* Find a cached partial DIE at OFFSET in CU.  */</span>
<a name="l15230"></a>15230 
<a name="l15231"></a>15231 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *
<a name="l15232"></a><a class="code" href="dwarf2read_8c.html#a10c712971d5f39747dbe4835a5a4bc47">15232</a> <a class="code" href="dwarf2read_8c.html#a10c712971d5f39747dbe4835a5a4bc47">find_partial_die_in_comp_unit</a> (<a class="code" href="structsect__offset.html">sect_offset</a> offset, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l15233"></a>15233 {
<a name="l15234"></a>15234   <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *lookup_die = NULL;
<a name="l15235"></a>15235   <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> part_die;
<a name="l15236"></a>15236 
<a name="l15237"></a>15237   part_die.<a class="code" href="structpartial__die__info.html#a5db48cad0baeb15b63822fdaa0136c04">offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l15238"></a>15238   lookup_die = htab_find_with_hash (cu-&gt;<a class="code" href="structdwarf2__cu.html#a1e821881f894272409a466d336a88b1f">partial_dies</a>, &amp;part_die,
<a name="l15239"></a>15239                                     offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l15240"></a>15240 
<a name="l15241"></a>15241   <span class="keywordflow">return</span> lookup_die;
<a name="l15242"></a>15242 }
<a name="l15243"></a>15243 
<a name="l15244"></a>15244 <span class="comment">/* Find a partial DIE at OFFSET, which may or may not be in CU,</span>
<a name="l15245"></a>15245 <span class="comment">   except in the case of .debug_types DIEs which do not reference</span>
<a name="l15246"></a>15246 <span class="comment">   outside their CU (they do however referencing other types via</span>
<a name="l15247"></a>15247 <span class="comment">   DW_FORM_ref_sig8).  */</span>
<a name="l15248"></a>15248 
<a name="l15249"></a>15249 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *
<a name="l15250"></a><a class="code" href="dwarf2read_8c.html#a58e31b8772918ff152fc61303028195a">15250</a> <a class="code" href="dwarf2read_8c.html#a58e31b8772918ff152fc61303028195a">find_partial_die</a> (<a class="code" href="structsect__offset.html">sect_offset</a> offset, <span class="keywordtype">int</span> offset_in_dwz, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l15251"></a>15251 {
<a name="l15252"></a>15252   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l15253"></a>15253   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = NULL;
<a name="l15254"></a>15254   <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *pd = NULL;
<a name="l15255"></a>15255 
<a name="l15256"></a>15256   <span class="keywordflow">if</span> (offset_in_dwz == cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a>
<a name="l15257"></a>15257       &amp;&amp; <a class="code" href="dwarf2read_8c.html#a244f083f251f3bfffd839e9fd3670a9a">offset_in_cu_p</a> (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>, offset))
<a name="l15258"></a>15258     {
<a name="l15259"></a>15259       pd = <a class="code" href="dwarf2read_8c.html#a10c712971d5f39747dbe4835a5a4bc47">find_partial_die_in_comp_unit</a> (offset, cu);
<a name="l15260"></a>15260       <span class="keywordflow">if</span> (pd != NULL)
<a name="l15261"></a>15261         <span class="keywordflow">return</span> pd;
<a name="l15262"></a>15262       <span class="comment">/* We missed recording what we needed.</span>
<a name="l15263"></a>15263 <span class="comment">         Load all dies and try again.  */</span>
<a name="l15264"></a>15264       per_cu = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;
<a name="l15265"></a>15265     }
<a name="l15266"></a>15266   <span class="keywordflow">else</span>
<a name="l15267"></a>15267     {
<a name="l15268"></a>15268       <span class="comment">/* TUs don&#39;t reference other CUs/TUs (except via type signatures).  */</span>
<a name="l15269"></a>15269       <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l15270"></a>15270         {
<a name="l15271"></a>15271           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Type Unit at offset 0x%lx contains&quot;</span>
<a name="l15272"></a>15272                    <span class="stringliteral">&quot; external reference to offset 0x%lx [in module %s].\n&quot;</span>),
<a name="l15273"></a>15273                  (<span class="keywordtype">long</span>) cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, (<span class="keywordtype">long</span>) offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>,
<a name="l15274"></a>15274                  bfd_get_filename (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>));
<a name="l15275"></a>15275         }
<a name="l15276"></a>15276       per_cu = <a class="code" href="dwarf2read_8c.html#af3b37bdf179696b92b068cd2894de56d">dwarf2_find_containing_comp_unit</a> (offset, offset_in_dwz,
<a name="l15277"></a>15277                                                  objfile);
<a name="l15278"></a>15278 
<a name="l15279"></a>15279       <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> == NULL || per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#a1e821881f894272409a466d336a88b1f">partial_dies</a> == NULL)
<a name="l15280"></a>15280         <a class="code" href="dwarf2read_8c.html#ab25ad5cc00c575be16c01ae08b71efed">load_partial_comp_unit</a> (per_cu);
<a name="l15281"></a>15281 
<a name="l15282"></a>15282       per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ae8de3b2f422c424b62543c1ef121de02">last_used</a> = 0;
<a name="l15283"></a>15283       pd = <a class="code" href="dwarf2read_8c.html#a10c712971d5f39747dbe4835a5a4bc47">find_partial_die_in_comp_unit</a> (offset, per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>);
<a name="l15284"></a>15284     }
<a name="l15285"></a>15285 
<a name="l15286"></a>15286   <span class="comment">/* If we didn&#39;t find it, and not all dies have been loaded,</span>
<a name="l15287"></a>15287 <span class="comment">     load them all and try again.  */</span>
<a name="l15288"></a>15288 
<a name="l15289"></a>15289   <span class="keywordflow">if</span> (pd == NULL &amp;&amp; per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a86105edb17badc0d1b99c4e4427d2911">load_all_dies</a> == 0)
<a name="l15290"></a>15290     {
<a name="l15291"></a>15291       per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a86105edb17badc0d1b99c4e4427d2911">load_all_dies</a> = 1;
<a name="l15292"></a>15292 
<a name="l15293"></a>15293       <span class="comment">/* This is nasty.  When we reread the DIEs, somewhere up the call chain</span>
<a name="l15294"></a>15294 <span class="comment">         THIS_CU-&gt;cu may already be in use.  So we can&#39;t just free it and</span>
<a name="l15295"></a>15295 <span class="comment">         replace its DIEs with the ones we read in.  Instead, we leave those</span>
<a name="l15296"></a>15296 <span class="comment">         DIEs alone (which can still be in use, e.g. in scan_partial_symbols),</span>
<a name="l15297"></a>15297 <span class="comment">         and clobber THIS_CU-&gt;cu-&gt;partial_dies with the hash table for the new</span>
<a name="l15298"></a>15298 <span class="comment">         set.  */</span>
<a name="l15299"></a>15299       <a class="code" href="dwarf2read_8c.html#ab25ad5cc00c575be16c01ae08b71efed">load_partial_comp_unit</a> (per_cu);
<a name="l15300"></a>15300 
<a name="l15301"></a>15301       pd = <a class="code" href="dwarf2read_8c.html#a10c712971d5f39747dbe4835a5a4bc47">find_partial_die_in_comp_unit</a> (offset, per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>);
<a name="l15302"></a>15302     }
<a name="l15303"></a>15303 
<a name="l15304"></a>15304   <span class="keywordflow">if</span> (pd == NULL)
<a name="l15305"></a>15305     <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l15306"></a>15306                     <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;could not find partial DIE 0x%x &quot;</span>
<a name="l15307"></a>15307                       <span class="stringliteral">&quot;in cache [from module %s]\n&quot;</span>),
<a name="l15308"></a>15308                     offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, bfd_get_filename (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>));
<a name="l15309"></a>15309   <span class="keywordflow">return</span> pd;
<a name="l15310"></a>15310 }
<a name="l15311"></a>15311 
<a name="l15312"></a>15312 <span class="comment">/* See if we can figure out if the class lives in a namespace.  We do</span>
<a name="l15313"></a>15313 <span class="comment">   this by looking for a member function; its demangled name will</span>
<a name="l15314"></a>15314 <span class="comment">   contain namespace info, if there is any.  */</span>
<a name="l15315"></a>15315 
<a name="l15316"></a>15316 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l15317"></a><a class="code" href="dwarf2read_8c.html#a91394fb460c65fb01654a978af9447a3">15317</a> <a class="code" href="dwarf2read_8c.html#a91394fb460c65fb01654a978af9447a3">guess_partial_die_structure_name</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *struct_pdi,
<a name="l15318"></a>15318                                   <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l15319"></a>15319 {
<a name="l15320"></a>15320   <span class="comment">/* NOTE: carlton/2003-10-07: Getting the info this way changes</span>
<a name="l15321"></a>15321 <span class="comment">     what template types look like, because the demangler</span>
<a name="l15322"></a>15322 <span class="comment">     frequently doesn&#39;t give the same name as the debug info.  We</span>
<a name="l15323"></a>15323 <span class="comment">     could fix this by only using the demangled name to get the</span>
<a name="l15324"></a>15324 <span class="comment">     prefix (but see comment in read_structure_type).  */</span>
<a name="l15325"></a>15325 
<a name="l15326"></a>15326   <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *real_pdi;
<a name="l15327"></a>15327   <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *child_pdi;
<a name="l15328"></a>15328 
<a name="l15329"></a>15329   <span class="comment">/* If this DIE (this DIE&#39;s specification, if any) has a parent, then</span>
<a name="l15330"></a>15330 <span class="comment">     we should not do this.  We&#39;ll prepend the parent&#39;s fully qualified</span>
<a name="l15331"></a>15331 <span class="comment">     name when we create the partial symbol.  */</span>
<a name="l15332"></a>15332 
<a name="l15333"></a>15333   real_pdi = struct_pdi;
<a name="l15334"></a>15334   <span class="keywordflow">while</span> (real_pdi-&gt;has_specification)
<a name="l15335"></a>15335     real_pdi = <a class="code" href="dwarf2read_8c.html#a58e31b8772918ff152fc61303028195a">find_partial_die</a> (real_pdi-&gt;<a class="code" href="structpartial__die__info.html#ac9faa23b0720fe4585288e1286917877">spec_offset</a>,
<a name="l15336"></a>15336                                  real_pdi-&gt;spec_is_dwz, cu);
<a name="l15337"></a>15337 
<a name="l15338"></a>15338   <span class="keywordflow">if</span> (real_pdi-&gt;<a class="code" href="structpartial__die__info.html#add5cb3fe3a136089a2cafa7027e59687">die_parent</a> != NULL)
<a name="l15339"></a>15339     <span class="keywordflow">return</span>;
<a name="l15340"></a>15340 
<a name="l15341"></a>15341   <span class="keywordflow">for</span> (child_pdi = struct_pdi-&gt;<a class="code" href="structpartial__die__info.html#a7761befb396a96f0d770f8b2a126291b">die_child</a>;
<a name="l15342"></a>15342        child_pdi != NULL;
<a name="l15343"></a>15343        child_pdi = child_pdi-&gt;<a class="code" href="structpartial__die__info.html#ad62d4a24f9c19d6835843c6a066fea36">die_sibling</a>)
<a name="l15344"></a>15344     {
<a name="l15345"></a>15345       <span class="keywordflow">if</span> (child_pdi-&gt;tag == DW_TAG_subprogram
<a name="l15346"></a>15346           &amp;&amp; child_pdi-&gt;linkage_name != NULL)
<a name="l15347"></a>15347         {
<a name="l15348"></a>15348           <span class="keywordtype">char</span> *actual_class_name
<a name="l15349"></a>15349             = <a class="code" href="language_8c.html#ac1c0e6eb5f485ef5ea6b7d30b8a87f46">language_class_name_from_physname</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa12f3aeef950b4457378c14f9ba16f12">language_defn</a>,
<a name="l15350"></a>15350                                                  child_pdi-&gt;linkage_name);
<a name="l15351"></a>15351           <span class="keywordflow">if</span> (actual_class_name != NULL)
<a name="l15352"></a>15352             {
<a name="l15353"></a>15353               struct_pdi-&gt;name
<a name="l15354"></a>15354                 = obstack_copy0 (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l15355"></a>15355                                  actual_class_name,
<a name="l15356"></a>15356                                  strlen (actual_class_name));
<a name="l15357"></a>15357               <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (actual_class_name);
<a name="l15358"></a>15358             }
<a name="l15359"></a>15359           <span class="keywordflow">break</span>;
<a name="l15360"></a>15360         }
<a name="l15361"></a>15361     }
<a name="l15362"></a>15362 }
<a name="l15363"></a>15363 
<a name="l15364"></a>15364 <span class="comment">/* Adjust PART_DIE before generating a symbol for it.  This function</span>
<a name="l15365"></a>15365 <span class="comment">   may set the is_external flag or change the DIE&#39;s name.  */</span>
<a name="l15366"></a>15366 
<a name="l15367"></a>15367 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l15368"></a><a class="code" href="dwarf2read_8c.html#a271dd2144532648290913da6252d331b">15368</a> <a class="code" href="dwarf2read_8c.html#a271dd2144532648290913da6252d331b">fixup_partial_die</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__die__info.html">partial_die_info</a> *part_die,
<a name="l15369"></a>15369                    <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l15370"></a>15370 {
<a name="l15371"></a>15371   <span class="comment">/* Once we&#39;ve fixed up a die, there&#39;s no point in doing so again.</span>
<a name="l15372"></a>15372 <span class="comment">     This also avoids a memory leak if we were to call</span>
<a name="l15373"></a>15373 <span class="comment">     guess_partial_die_structure_name multiple times.  */</span>
<a name="l15374"></a>15374   <span class="keywordflow">if</span> (part_die-&gt;fixup_called)
<a name="l15375"></a>15375     <span class="keywordflow">return</span>;
<a name="l15376"></a>15376 
<a name="l15377"></a>15377   <span class="comment">/* If we found a reference attribute and the DIE has no name, try</span>
<a name="l15378"></a>15378 <span class="comment">     to find a name in the referred to DIE.  */</span>
<a name="l15379"></a>15379 
<a name="l15380"></a>15380   <span class="keywordflow">if</span> (part_die-&gt;name == NULL &amp;&amp; part_die-&gt;has_specification)
<a name="l15381"></a>15381     {
<a name="l15382"></a>15382       <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *spec_die;
<a name="l15383"></a>15383 
<a name="l15384"></a>15384       spec_die = <a class="code" href="dwarf2read_8c.html#a58e31b8772918ff152fc61303028195a">find_partial_die</a> (part_die-&gt;<a class="code" href="structpartial__die__info.html#ac9faa23b0720fe4585288e1286917877">spec_offset</a>,
<a name="l15385"></a>15385                                    part_die-&gt;spec_is_dwz, cu);
<a name="l15386"></a>15386 
<a name="l15387"></a>15387       <a class="code" href="dwarf2read_8c.html#a271dd2144532648290913da6252d331b">fixup_partial_die</a> (spec_die, cu);
<a name="l15388"></a>15388 
<a name="l15389"></a>15389       <span class="keywordflow">if</span> (spec_die-&gt;name)
<a name="l15390"></a>15390         {
<a name="l15391"></a>15391           part_die-&gt;name = spec_die-&gt;name;
<a name="l15392"></a>15392 
<a name="l15393"></a>15393           <span class="comment">/* Copy DW_AT_external attribute if it is set.  */</span>
<a name="l15394"></a>15394           <span class="keywordflow">if</span> (spec_die-&gt;is_external)
<a name="l15395"></a>15395             part_die-&gt;is_external = spec_die-&gt;is_external;
<a name="l15396"></a>15396         }
<a name="l15397"></a>15397     }
<a name="l15398"></a>15398 
<a name="l15399"></a>15399   <span class="comment">/* Set default names for some unnamed DIEs.  */</span>
<a name="l15400"></a>15400 
<a name="l15401"></a>15401   <span class="keywordflow">if</span> (part_die-&gt;name == NULL &amp;&amp; part_die-&gt;tag == DW_TAG_namespace)
<a name="l15402"></a>15402     part_die-&gt;name = <a class="code" href="cp-support_8h.html#a9d4961125aae81ae81b8fbf88512786d">CP_ANONYMOUS_NAMESPACE_STR</a>;
<a name="l15403"></a>15403 
<a name="l15404"></a>15404   <span class="comment">/* If there is no parent die to provide a namespace, and there are</span>
<a name="l15405"></a>15405 <span class="comment">     children, see if we can determine the namespace from their linkage</span>
<a name="l15406"></a>15406 <span class="comment">     name.  */</span>
<a name="l15407"></a>15407   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l15408"></a>15408       &amp;&amp; !<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>, dwarf2_per_objfile-&gt;types)
<a name="l15409"></a>15409       &amp;&amp; part_die-&gt;<a class="code" href="structpartial__die__info.html#add5cb3fe3a136089a2cafa7027e59687">die_parent</a> == NULL
<a name="l15410"></a>15410       &amp;&amp; part_die-&gt;has_children
<a name="l15411"></a>15411       &amp;&amp; (part_die-&gt;tag == DW_TAG_class_type
<a name="l15412"></a>15412           || part_die-&gt;tag == DW_TAG_structure_type
<a name="l15413"></a>15413           || part_die-&gt;tag == DW_TAG_union_type))
<a name="l15414"></a>15414     <a class="code" href="dwarf2read_8c.html#a91394fb460c65fb01654a978af9447a3">guess_partial_die_structure_name</a> (part_die, cu);
<a name="l15415"></a>15415 
<a name="l15416"></a>15416   <span class="comment">/* GCC might emit a nameless struct or union that has a linkage</span>
<a name="l15417"></a>15417 <span class="comment">     name.  See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47510.  */</span>
<a name="l15418"></a>15418   <span class="keywordflow">if</span> (part_die-&gt;name == NULL
<a name="l15419"></a>15419       &amp;&amp; (part_die-&gt;tag == DW_TAG_class_type
<a name="l15420"></a>15420           || part_die-&gt;tag == DW_TAG_interface_type
<a name="l15421"></a>15421           || part_die-&gt;tag == DW_TAG_structure_type
<a name="l15422"></a>15422           || part_die-&gt;tag == DW_TAG_union_type)
<a name="l15423"></a>15423       &amp;&amp; part_die-&gt;linkage_name != NULL)
<a name="l15424"></a>15424     {
<a name="l15425"></a>15425       <span class="keywordtype">char</span> *demangled;
<a name="l15426"></a>15426 
<a name="l15427"></a>15427       demangled = <a class="code" href="cp-support_8c.html#aa3fac1cb74e2709738e9ab3af7aac6b6">gdb_demangle</a> (part_die-&gt;linkage_name, DMGL_TYPES);
<a name="l15428"></a>15428       <span class="keywordflow">if</span> (demangled)
<a name="l15429"></a>15429         {
<a name="l15430"></a>15430           <span class="keyword">const</span> <span class="keywordtype">char</span> *base;
<a name="l15431"></a>15431 
<a name="l15432"></a>15432           <span class="comment">/* Strip any leading namespaces/classes, keep only the base name.</span>
<a name="l15433"></a>15433 <span class="comment">             DW_AT_name for named DIEs does not contain the prefixes.  */</span>
<a name="l15434"></a>15434           base = <a class="code" href="gdb__string_8h.html#a5cbb8bbfc7174d9468b1853f1031efb3">strrchr</a> (demangled, <span class="charliteral">&#39;:&#39;</span>);
<a name="l15435"></a>15435           <span class="keywordflow">if</span> (base &amp;&amp; base &gt; demangled &amp;&amp; base[-1] == <span class="charliteral">&#39;:&#39;</span>)
<a name="l15436"></a>15436             base++;
<a name="l15437"></a>15437           <span class="keywordflow">else</span>
<a name="l15438"></a>15438             base = demangled;
<a name="l15439"></a>15439 
<a name="l15440"></a>15440           part_die-&gt;name = obstack_copy0 (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l15441"></a>15441                                           base, strlen (base));
<a name="l15442"></a>15442           <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (demangled);
<a name="l15443"></a>15443         }
<a name="l15444"></a>15444     }
<a name="l15445"></a>15445 
<a name="l15446"></a>15446   part_die-&gt;fixup_called = 1;
<a name="l15447"></a>15447 }
<a name="l15448"></a>15448 
<a name="l15449"></a>15449 <span class="comment">/* Read an attribute value described by an attribute form.  */</span>
<a name="l15450"></a>15450 
<a name="l15451"></a>15451 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l15452"></a><a class="code" href="dwarf2read_8c.html#a8c07ede1e048243c48b1be12d29baf0e">15452</a> <a class="code" href="dwarf2read_8c.html#a8c07ede1e048243c48b1be12d29baf0e">read_attribute_value</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l15453"></a>15453                       <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr, <span class="keywordtype">unsigned</span> form,
<a name="l15454"></a>15454                       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr)
<a name="l15455"></a>15455 {
<a name="l15456"></a>15456   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l15457"></a>15457   bfd *abfd = reader-&gt;<a class="code" href="structdie__reader__specs.html#a1a2ea4151d385459f3a3fb7b0dad2973">abfd</a>;
<a name="l15458"></a>15458   <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_header = &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>;
<a name="l15459"></a>15459   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l15460"></a>15460   <span class="keyword">struct </span><a class="code" href="structdwarf__block.html">dwarf_block</a> *blk;
<a name="l15461"></a>15461 
<a name="l15462"></a>15462   attr-&gt;form = form;
<a name="l15463"></a>15463   <span class="keywordflow">switch</span> (form)
<a name="l15464"></a>15464     {
<a name="l15465"></a>15465     <span class="keywordflow">case</span> DW_FORM_ref_addr:
<a name="l15466"></a>15466       <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a68d6c482c646af0266771ad56b73748d">version</a> == 2)
<a name="l15467"></a>15467         <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = <a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">read_address</a> (abfd, info_ptr, cu, &amp;bytes_read);
<a name="l15468"></a>15468       <span class="keywordflow">else</span>
<a name="l15469"></a>15469         <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = <a class="code" href="dwarf2read_8c.html#afd4b43dc237191df908291fb832628e5">read_offset</a> (abfd, info_ptr,
<a name="l15470"></a>15470                                        &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>, &amp;bytes_read);
<a name="l15471"></a>15471       info_ptr += bytes_read;
<a name="l15472"></a>15472       <span class="keywordflow">break</span>;
<a name="l15473"></a>15473     <span class="keywordflow">case</span> DW_FORM_GNU_ref_alt:
<a name="l15474"></a>15474       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = <a class="code" href="dwarf2read_8c.html#afd4b43dc237191df908291fb832628e5">read_offset</a> (abfd, info_ptr, &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>, &amp;bytes_read);
<a name="l15475"></a>15475       info_ptr += bytes_read;
<a name="l15476"></a>15476       <span class="keywordflow">break</span>;
<a name="l15477"></a>15477     <span class="keywordflow">case</span> DW_FORM_addr:
<a name="l15478"></a>15478       <a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (attr) = <a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">read_address</a> (abfd, info_ptr, cu, &amp;bytes_read);
<a name="l15479"></a>15479       info_ptr += bytes_read;
<a name="l15480"></a>15480       <span class="keywordflow">break</span>;
<a name="l15481"></a>15481     <span class="keywordflow">case</span> DW_FORM_block2:
<a name="l15482"></a>15482       blk = <a class="code" href="dwarf2read_8c.html#ad90eafda28bec4d8aedfc8e1f37b210a">dwarf_alloc_block</a> (cu);
<a name="l15483"></a>15483       blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a> = <a class="code" href="dwarf2read_8c.html#a35663eebf65b4217082f14bc1f782307">read_2_bytes</a> (abfd, info_ptr);
<a name="l15484"></a>15484       info_ptr += 2;
<a name="l15485"></a>15485       blk-&gt;<a class="code" href="structdwarf__block.html#af3a8e3eb0d783b103b0078662dbdc211">data</a> = <a class="code" href="dwarf2read_8c.html#a7078db3bb8caab1b87567e9e8441d95f">read_n_bytes</a> (abfd, info_ptr, blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a>);
<a name="l15486"></a>15486       info_ptr += blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a>;
<a name="l15487"></a>15487       <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr) = blk;
<a name="l15488"></a>15488       <span class="keywordflow">break</span>;
<a name="l15489"></a>15489     <span class="keywordflow">case</span> DW_FORM_block4:
<a name="l15490"></a>15490       blk = <a class="code" href="dwarf2read_8c.html#ad90eafda28bec4d8aedfc8e1f37b210a">dwarf_alloc_block</a> (cu);
<a name="l15491"></a>15491       blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a> = <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (abfd, info_ptr);
<a name="l15492"></a>15492       info_ptr += 4;
<a name="l15493"></a>15493       blk-&gt;<a class="code" href="structdwarf__block.html#af3a8e3eb0d783b103b0078662dbdc211">data</a> = <a class="code" href="dwarf2read_8c.html#a7078db3bb8caab1b87567e9e8441d95f">read_n_bytes</a> (abfd, info_ptr, blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a>);
<a name="l15494"></a>15494       info_ptr += blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a>;
<a name="l15495"></a>15495       <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr) = blk;
<a name="l15496"></a>15496       <span class="keywordflow">break</span>;
<a name="l15497"></a>15497     <span class="keywordflow">case</span> DW_FORM_data2:
<a name="l15498"></a>15498       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = <a class="code" href="dwarf2read_8c.html#a35663eebf65b4217082f14bc1f782307">read_2_bytes</a> (abfd, info_ptr);
<a name="l15499"></a>15499       info_ptr += 2;
<a name="l15500"></a>15500       <span class="keywordflow">break</span>;
<a name="l15501"></a>15501     <span class="keywordflow">case</span> DW_FORM_data4:
<a name="l15502"></a>15502       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (abfd, info_ptr);
<a name="l15503"></a>15503       info_ptr += 4;
<a name="l15504"></a>15504       <span class="keywordflow">break</span>;
<a name="l15505"></a>15505     <span class="keywordflow">case</span> DW_FORM_data8:
<a name="l15506"></a>15506       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = <a class="code" href="dwarf2read_8c.html#af21c01feb67cfb3cd240c3ac803dd021">read_8_bytes</a> (abfd, info_ptr);
<a name="l15507"></a>15507       info_ptr += 8;
<a name="l15508"></a>15508       <span class="keywordflow">break</span>;
<a name="l15509"></a>15509     <span class="keywordflow">case</span> DW_FORM_sec_offset:
<a name="l15510"></a>15510       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = <a class="code" href="dwarf2read_8c.html#afd4b43dc237191df908291fb832628e5">read_offset</a> (abfd, info_ptr, &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>, &amp;bytes_read);
<a name="l15511"></a>15511       info_ptr += bytes_read;
<a name="l15512"></a>15512       <span class="keywordflow">break</span>;
<a name="l15513"></a>15513     <span class="keywordflow">case</span> DW_FORM_string:
<a name="l15514"></a>15514       <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr) = <a class="code" href="dwarf2read_8c.html#a5386044c6f74a934dbd3f4a3199cf5be">read_direct_string</a> (abfd, info_ptr, &amp;bytes_read);
<a name="l15515"></a>15515       <a class="code" href="dwarf2read_8c.html#a307f18e0d403d80487696d1a0a5d0fd6">DW_STRING_IS_CANONICAL</a> (attr) = 0;
<a name="l15516"></a>15516       info_ptr += bytes_read;
<a name="l15517"></a>15517       <span class="keywordflow">break</span>;
<a name="l15518"></a>15518     <span class="keywordflow">case</span> DW_FORM_strp:
<a name="l15519"></a>15519       <span class="keywordflow">if</span> (!cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a>)
<a name="l15520"></a>15520         {
<a name="l15521"></a>15521           <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr) = <a class="code" href="dwarf2read_8c.html#a3bafaf539b850b4e8610f36fefb1b4a2">read_indirect_string</a> (abfd, info_ptr, cu_header,
<a name="l15522"></a>15522                                                    &amp;bytes_read);
<a name="l15523"></a>15523           <a class="code" href="dwarf2read_8c.html#a307f18e0d403d80487696d1a0a5d0fd6">DW_STRING_IS_CANONICAL</a> (attr) = 0;
<a name="l15524"></a>15524           info_ptr += bytes_read;
<a name="l15525"></a>15525           <span class="keywordflow">break</span>;
<a name="l15526"></a>15526         }
<a name="l15527"></a>15527       <span class="comment">/* FALLTHROUGH */</span>
<a name="l15528"></a>15528     <span class="keywordflow">case</span> DW_FORM_GNU_strp_alt:
<a name="l15529"></a>15529       {
<a name="l15530"></a>15530         <span class="keyword">struct </span><a class="code" href="structdwz__file.html">dwz_file</a> *dwz = <a class="code" href="dwarf2read_8c.html#a926306809098933a820cfda81b19864c">dwarf2_get_dwz_file</a> ();
<a name="l15531"></a>15531         <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> str_offset = <a class="code" href="dwarf2read_8c.html#afd4b43dc237191df908291fb832628e5">read_offset</a> (abfd, info_ptr, cu_header,
<a name="l15532"></a>15532                                           &amp;bytes_read);
<a name="l15533"></a>15533 
<a name="l15534"></a>15534         <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr) = <a class="code" href="dwarf2read_8c.html#aae8af1e5be4adc81e8945968faf67e31">read_indirect_string_from_dwz</a> (dwz, str_offset);
<a name="l15535"></a>15535         <a class="code" href="dwarf2read_8c.html#a307f18e0d403d80487696d1a0a5d0fd6">DW_STRING_IS_CANONICAL</a> (attr) = 0;
<a name="l15536"></a>15536         info_ptr += bytes_read;
<a name="l15537"></a>15537       }
<a name="l15538"></a>15538       <span class="keywordflow">break</span>;
<a name="l15539"></a>15539     <span class="keywordflow">case</span> DW_FORM_exprloc:
<a name="l15540"></a>15540     <span class="keywordflow">case</span> DW_FORM_block:
<a name="l15541"></a>15541       blk = <a class="code" href="dwarf2read_8c.html#ad90eafda28bec4d8aedfc8e1f37b210a">dwarf_alloc_block</a> (cu);
<a name="l15542"></a>15542       blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a> = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, info_ptr, &amp;bytes_read);
<a name="l15543"></a>15543       info_ptr += bytes_read;
<a name="l15544"></a>15544       blk-&gt;<a class="code" href="structdwarf__block.html#af3a8e3eb0d783b103b0078662dbdc211">data</a> = <a class="code" href="dwarf2read_8c.html#a7078db3bb8caab1b87567e9e8441d95f">read_n_bytes</a> (abfd, info_ptr, blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a>);
<a name="l15545"></a>15545       info_ptr += blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a>;
<a name="l15546"></a>15546       <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr) = blk;
<a name="l15547"></a>15547       <span class="keywordflow">break</span>;
<a name="l15548"></a>15548     <span class="keywordflow">case</span> DW_FORM_block1:
<a name="l15549"></a>15549       blk = <a class="code" href="dwarf2read_8c.html#ad90eafda28bec4d8aedfc8e1f37b210a">dwarf_alloc_block</a> (cu);
<a name="l15550"></a>15550       blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a> = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, info_ptr);
<a name="l15551"></a>15551       info_ptr += 1;
<a name="l15552"></a>15552       blk-&gt;<a class="code" href="structdwarf__block.html#af3a8e3eb0d783b103b0078662dbdc211">data</a> = <a class="code" href="dwarf2read_8c.html#a7078db3bb8caab1b87567e9e8441d95f">read_n_bytes</a> (abfd, info_ptr, blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a>);
<a name="l15553"></a>15553       info_ptr += blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a>;
<a name="l15554"></a>15554       <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr) = blk;
<a name="l15555"></a>15555       <span class="keywordflow">break</span>;
<a name="l15556"></a>15556     <span class="keywordflow">case</span> DW_FORM_data1:
<a name="l15557"></a>15557       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, info_ptr);
<a name="l15558"></a>15558       info_ptr += 1;
<a name="l15559"></a>15559       <span class="keywordflow">break</span>;
<a name="l15560"></a>15560     <span class="keywordflow">case</span> DW_FORM_flag:
<a name="l15561"></a>15561       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, info_ptr);
<a name="l15562"></a>15562       info_ptr += 1;
<a name="l15563"></a>15563       <span class="keywordflow">break</span>;
<a name="l15564"></a>15564     <span class="keywordflow">case</span> DW_FORM_flag_present:
<a name="l15565"></a>15565       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = 1;
<a name="l15566"></a>15566       <span class="keywordflow">break</span>;
<a name="l15567"></a>15567     <span class="keywordflow">case</span> DW_FORM_sdata:
<a name="l15568"></a>15568       <a class="code" href="dwarf2read_8c.html#a66159661f7b11878469288def232a3e4">DW_SND</a> (attr) = <a class="code" href="dwarf2read_8c.html#adfbc149c8807d37b14d0d217da31ada0">read_signed_leb128</a> (abfd, info_ptr, &amp;bytes_read);
<a name="l15569"></a>15569       info_ptr += bytes_read;
<a name="l15570"></a>15570       <span class="keywordflow">break</span>;
<a name="l15571"></a>15571     <span class="keywordflow">case</span> DW_FORM_udata:
<a name="l15572"></a>15572       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, info_ptr, &amp;bytes_read);
<a name="l15573"></a>15573       info_ptr += bytes_read;
<a name="l15574"></a>15574       <span class="keywordflow">break</span>;
<a name="l15575"></a>15575     <span class="keywordflow">case</span> DW_FORM_ref1:
<a name="l15576"></a>15576       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>
<a name="l15577"></a>15577                          + <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, info_ptr));
<a name="l15578"></a>15578       info_ptr += 1;
<a name="l15579"></a>15579       <span class="keywordflow">break</span>;
<a name="l15580"></a>15580     <span class="keywordflow">case</span> DW_FORM_ref2:
<a name="l15581"></a>15581       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>
<a name="l15582"></a>15582                          + <a class="code" href="dwarf2read_8c.html#a35663eebf65b4217082f14bc1f782307">read_2_bytes</a> (abfd, info_ptr));
<a name="l15583"></a>15583       info_ptr += 2;
<a name="l15584"></a>15584       <span class="keywordflow">break</span>;
<a name="l15585"></a>15585     <span class="keywordflow">case</span> DW_FORM_ref4:
<a name="l15586"></a>15586       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>
<a name="l15587"></a>15587                          + <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (abfd, info_ptr));
<a name="l15588"></a>15588       info_ptr += 4;
<a name="l15589"></a>15589       <span class="keywordflow">break</span>;
<a name="l15590"></a>15590     <span class="keywordflow">case</span> DW_FORM_ref8:
<a name="l15591"></a>15591       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>
<a name="l15592"></a>15592                          + <a class="code" href="dwarf2read_8c.html#af21c01feb67cfb3cd240c3ac803dd021">read_8_bytes</a> (abfd, info_ptr));
<a name="l15593"></a>15593       info_ptr += 8;
<a name="l15594"></a>15594       <span class="keywordflow">break</span>;
<a name="l15595"></a>15595     <span class="keywordflow">case</span> DW_FORM_ref_sig8:
<a name="l15596"></a>15596       <a class="code" href="dwarf2read_8c.html#a8ba60632a90cfabc155c69f0bf2d2f83">DW_SIGNATURE</a> (attr) = <a class="code" href="dwarf2read_8c.html#af21c01feb67cfb3cd240c3ac803dd021">read_8_bytes</a> (abfd, info_ptr);
<a name="l15597"></a>15597       info_ptr += 8;
<a name="l15598"></a>15598       <span class="keywordflow">break</span>;
<a name="l15599"></a>15599     <span class="keywordflow">case</span> DW_FORM_ref_udata:
<a name="l15600"></a>15600       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>
<a name="l15601"></a>15601                          + <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, info_ptr, &amp;bytes_read));
<a name="l15602"></a>15602       info_ptr += bytes_read;
<a name="l15603"></a>15603       <span class="keywordflow">break</span>;
<a name="l15604"></a>15604     <span class="keywordflow">case</span> DW_FORM_indirect:
<a name="l15605"></a>15605       form = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, info_ptr, &amp;bytes_read);
<a name="l15606"></a>15606       info_ptr += bytes_read;
<a name="l15607"></a>15607       info_ptr = <a class="code" href="dwarf2read_8c.html#a8c07ede1e048243c48b1be12d29baf0e">read_attribute_value</a> (reader, attr, form, info_ptr);
<a name="l15608"></a>15608       <span class="keywordflow">break</span>;
<a name="l15609"></a>15609     <span class="keywordflow">case</span> DW_FORM_GNU_addr_index:
<a name="l15610"></a>15610       <span class="keywordflow">if</span> (reader-&gt;<a class="code" href="structdie__reader__specs.html#a64321aff4f42ed613b8831c4d0804c36">dwo_file</a> == NULL)
<a name="l15611"></a>15611         {
<a name="l15612"></a>15612           <span class="comment">/* For now flag a hard error.</span>
<a name="l15613"></a>15613 <span class="comment">             Later we can turn this into a complaint.  */</span>
<a name="l15614"></a>15614           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: %s found in non-DWO CU [in module %s]&quot;</span>),
<a name="l15615"></a>15615                  <a class="code" href="dwarf2read_8c.html#a6810653c49d4b3be30290dc1bcf20c94">dwarf_form_name</a> (form),
<a name="l15616"></a>15616                  bfd_get_filename (abfd));
<a name="l15617"></a>15617         }
<a name="l15618"></a>15618       <a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (attr) = <a class="code" href="dwarf2read_8c.html#a62579cbb3d5cf28bac5bff46f3d7ed11">read_addr_index_from_leb128</a> (cu, info_ptr, &amp;bytes_read);
<a name="l15619"></a>15619       info_ptr += bytes_read;
<a name="l15620"></a>15620       <span class="keywordflow">break</span>;
<a name="l15621"></a>15621     <span class="keywordflow">case</span> DW_FORM_GNU_str_index:
<a name="l15622"></a>15622       <span class="keywordflow">if</span> (reader-&gt;<a class="code" href="structdie__reader__specs.html#a64321aff4f42ed613b8831c4d0804c36">dwo_file</a> == NULL)
<a name="l15623"></a>15623         {
<a name="l15624"></a>15624           <span class="comment">/* For now flag a hard error.</span>
<a name="l15625"></a>15625 <span class="comment">             Later we can turn this into a complaint if warranted.  */</span>
<a name="l15626"></a>15626           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: %s found in non-DWO CU [in module %s]&quot;</span>),
<a name="l15627"></a>15627                  <a class="code" href="dwarf2read_8c.html#a6810653c49d4b3be30290dc1bcf20c94">dwarf_form_name</a> (form),
<a name="l15628"></a>15628                  bfd_get_filename (abfd));
<a name="l15629"></a>15629         }
<a name="l15630"></a>15630       {
<a name="l15631"></a>15631         <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> str_index =
<a name="l15632"></a>15632           <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, info_ptr, &amp;bytes_read);
<a name="l15633"></a>15633 
<a name="l15634"></a>15634         <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr) = <a class="code" href="dwarf2read_8c.html#a11ef1cbeffac261cacbe27fa98628253">read_str_index</a> (reader, cu, str_index);
<a name="l15635"></a>15635         <a class="code" href="dwarf2read_8c.html#a307f18e0d403d80487696d1a0a5d0fd6">DW_STRING_IS_CANONICAL</a> (attr) = 0;
<a name="l15636"></a>15636         info_ptr += bytes_read;
<a name="l15637"></a>15637       }
<a name="l15638"></a>15638       <span class="keywordflow">break</span>;
<a name="l15639"></a>15639     <span class="keywordflow">default</span>:
<a name="l15640"></a>15640       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Cannot handle %s in DWARF reader [in module %s]&quot;</span>),
<a name="l15641"></a>15641              <a class="code" href="dwarf2read_8c.html#a6810653c49d4b3be30290dc1bcf20c94">dwarf_form_name</a> (form),
<a name="l15642"></a>15642              bfd_get_filename (abfd));
<a name="l15643"></a>15643     }
<a name="l15644"></a>15644 
<a name="l15645"></a>15645   <span class="comment">/* Super hack.  */</span>
<a name="l15646"></a>15646   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a> &amp;&amp; <a class="code" href="dwarf2read_8c.html#a217d4eb87ed57947007169e88bb2a0f9">attr_form_is_ref</a> (attr))
<a name="l15647"></a>15647     attr-&gt;form = DW_FORM_GNU_ref_alt;
<a name="l15648"></a>15648 
<a name="l15649"></a>15649   <span class="comment">/* We have seen instances where the compiler tried to emit a byte</span>
<a name="l15650"></a>15650 <span class="comment">     size attribute of -1 which ended up being encoded as an unsigned</span>
<a name="l15651"></a>15651 <span class="comment">     0xffffffff.  Although 0xffffffff is technically a valid size value,</span>
<a name="l15652"></a>15652 <span class="comment">     an object of this size seems pretty unlikely so we can relatively</span>
<a name="l15653"></a>15653 <span class="comment">     safely treat these cases as if the size attribute was invalid and</span>
<a name="l15654"></a>15654 <span class="comment">     treat them as zero by default.  */</span>
<a name="l15655"></a>15655   <span class="keywordflow">if</span> (attr-&gt;name == DW_AT_byte_size
<a name="l15656"></a>15656       &amp;&amp; form == DW_FORM_data4
<a name="l15657"></a>15657       &amp;&amp; <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) &gt;= 0xffffffff)
<a name="l15658"></a>15658     {
<a name="l15659"></a>15659       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a>
<a name="l15660"></a>15660         (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l15661"></a>15661          <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Suspicious DW_AT_byte_size value treated as zero instead of %s&quot;</span>),
<a name="l15662"></a>15662          <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr)));
<a name="l15663"></a>15663       <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) = 0;
<a name="l15664"></a>15664     }
<a name="l15665"></a>15665 
<a name="l15666"></a>15666   <span class="keywordflow">return</span> info_ptr;
<a name="l15667"></a>15667 }
<a name="l15668"></a>15668 
<a name="l15669"></a>15669 <span class="comment">/* Read an attribute described by an abbreviated attribute.  */</span>
<a name="l15670"></a>15670 
<a name="l15671"></a>15671 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l15672"></a><a class="code" href="dwarf2read_8c.html#a08e1a18f85e288f9241d3baab2ded2b0">15672</a> <a class="code" href="dwarf2read_8c.html#a08e1a18f85e288f9241d3baab2ded2b0">read_attribute</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l15673"></a>15673                 <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr, <span class="keyword">struct</span> <a class="code" href="structattr__abbrev.html">attr_abbrev</a> *<a class="code" href="structdwz__file.html#a6d54052c436197e540e433c95f5361e3">abbrev</a>,
<a name="l15674"></a>15674                 <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr)
<a name="l15675"></a>15675 {
<a name="l15676"></a>15676   attr-&gt;name = abbrev-&gt;name;
<a name="l15677"></a>15677   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a8c07ede1e048243c48b1be12d29baf0e">read_attribute_value</a> (reader, attr, abbrev-&gt;form, info_ptr);
<a name="l15678"></a>15678 }
<a name="l15679"></a>15679 
<a name="l15680"></a>15680 <span class="comment">/* Read dwarf information from a buffer.  */</span>
<a name="l15681"></a>15681 
<a name="l15682"></a>15682 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l15683"></a><a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">15683</a> <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l15684"></a>15684 {
<a name="l15685"></a>15685   <span class="keywordflow">return</span> bfd_get_8 (abfd, buf);
<a name="l15686"></a>15686 }
<a name="l15687"></a>15687 
<a name="l15688"></a>15688 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l15689"></a><a class="code" href="dwarf2read_8c.html#a29c46d3cfe71a70e5ba65f3cd31c3ad5">15689</a> <a class="code" href="dwarf2read_8c.html#a29c46d3cfe71a70e5ba65f3cd31c3ad5">read_1_signed_byte</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l15690"></a>15690 {
<a name="l15691"></a>15691   <span class="keywordflow">return</span> bfd_get_signed_8 (abfd, buf);
<a name="l15692"></a>15692 }
<a name="l15693"></a>15693 
<a name="l15694"></a>15694 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l15695"></a><a class="code" href="dwarf2read_8c.html#a35663eebf65b4217082f14bc1f782307">15695</a> <a class="code" href="dwarf2read_8c.html#a35663eebf65b4217082f14bc1f782307">read_2_bytes</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l15696"></a>15696 {
<a name="l15697"></a>15697   <span class="keywordflow">return</span> bfd_get_16 (abfd, buf);
<a name="l15698"></a>15698 }
<a name="l15699"></a>15699 
<a name="l15700"></a>15700 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l15701"></a><a class="code" href="dwarf2read_8c.html#ab9f2390820a5e378c1ed97fba7ca1800">15701</a> <a class="code" href="dwarf2read_8c.html#ab9f2390820a5e378c1ed97fba7ca1800">read_2_signed_bytes</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l15702"></a>15702 {
<a name="l15703"></a>15703   <span class="keywordflow">return</span> bfd_get_signed_16 (abfd, buf);
<a name="l15704"></a>15704 }
<a name="l15705"></a>15705 
<a name="l15706"></a>15706 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l15707"></a><a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">15707</a> <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l15708"></a>15708 {
<a name="l15709"></a>15709   <span class="keywordflow">return</span> bfd_get_32 (abfd, buf);
<a name="l15710"></a>15710 }
<a name="l15711"></a>15711 
<a name="l15712"></a>15712 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l15713"></a><a class="code" href="dwarf2read_8c.html#a1d9409b16aeaceb60c53209d05d9c65c">15713</a> <a class="code" href="dwarf2read_8c.html#a1d9409b16aeaceb60c53209d05d9c65c">read_4_signed_bytes</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l15714"></a>15714 {
<a name="l15715"></a>15715   <span class="keywordflow">return</span> bfd_get_signed_32 (abfd, buf);
<a name="l15716"></a>15716 }
<a name="l15717"></a>15717 
<a name="l15718"></a>15718 <span class="keyword">static</span> <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a>
<a name="l15719"></a><a class="code" href="dwarf2read_8c.html#af21c01feb67cfb3cd240c3ac803dd021">15719</a> <a class="code" href="dwarf2read_8c.html#af21c01feb67cfb3cd240c3ac803dd021">read_8_bytes</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l15720"></a>15720 {
<a name="l15721"></a>15721   <span class="keywordflow">return</span> bfd_get_64 (abfd, buf);
<a name="l15722"></a>15722 }
<a name="l15723"></a>15723 
<a name="l15724"></a>15724 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l15725"></a><a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">15725</a> <a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">read_address</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l15726"></a>15726               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *bytes_read)
<a name="l15727"></a>15727 {
<a name="l15728"></a>15728   <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_header = &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>;
<a name="l15729"></a>15729   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> retval = 0;
<a name="l15730"></a>15730 
<a name="l15731"></a>15731   <span class="keywordflow">if</span> (cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a4dbec66bb53896b38a53f9f4c8c5e1fb">signed_addr_p</a>)
<a name="l15732"></a>15732     {
<a name="l15733"></a>15733       <span class="keywordflow">switch</span> (cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>)
<a name="l15734"></a>15734         {
<a name="l15735"></a>15735         <span class="keywordflow">case</span> 2:
<a name="l15736"></a>15736           retval = bfd_get_signed_16 (abfd, buf);
<a name="l15737"></a>15737           <span class="keywordflow">break</span>;
<a name="l15738"></a>15738         <span class="keywordflow">case</span> 4:
<a name="l15739"></a>15739           retval = bfd_get_signed_32 (abfd, buf);
<a name="l15740"></a>15740           <span class="keywordflow">break</span>;
<a name="l15741"></a>15741         <span class="keywordflow">case</span> 8:
<a name="l15742"></a>15742           retval = bfd_get_signed_64 (abfd, buf);
<a name="l15743"></a>15743           <span class="keywordflow">break</span>;
<a name="l15744"></a>15744         <span class="keywordflow">default</span>:
<a name="l15745"></a>15745           <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l15746"></a>15746                           <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;read_address: bad switch, signed [in module %s]&quot;</span>),
<a name="l15747"></a>15747                           bfd_get_filename (abfd));
<a name="l15748"></a>15748         }
<a name="l15749"></a>15749     }
<a name="l15750"></a>15750   <span class="keywordflow">else</span>
<a name="l15751"></a>15751     {
<a name="l15752"></a>15752       <span class="keywordflow">switch</span> (cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>)
<a name="l15753"></a>15753         {
<a name="l15754"></a>15754         <span class="keywordflow">case</span> 2:
<a name="l15755"></a>15755           retval = bfd_get_16 (abfd, buf);
<a name="l15756"></a>15756           <span class="keywordflow">break</span>;
<a name="l15757"></a>15757         <span class="keywordflow">case</span> 4:
<a name="l15758"></a>15758           retval = bfd_get_32 (abfd, buf);
<a name="l15759"></a>15759           <span class="keywordflow">break</span>;
<a name="l15760"></a>15760         <span class="keywordflow">case</span> 8:
<a name="l15761"></a>15761           retval = bfd_get_64 (abfd, buf);
<a name="l15762"></a>15762           <span class="keywordflow">break</span>;
<a name="l15763"></a>15763         <span class="keywordflow">default</span>:
<a name="l15764"></a>15764           <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l15765"></a>15765                           <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;read_address: bad switch, &quot;</span>
<a name="l15766"></a>15766                             <span class="stringliteral">&quot;unsigned [in module %s]&quot;</span>),
<a name="l15767"></a>15767                           bfd_get_filename (abfd));
<a name="l15768"></a>15768         }
<a name="l15769"></a>15769     }
<a name="l15770"></a>15770 
<a name="l15771"></a>15771   *bytes_read = cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l15772"></a>15772   <span class="keywordflow">return</span> retval;
<a name="l15773"></a>15773 }
<a name="l15774"></a>15774 
<a name="l15775"></a>15775 <span class="comment">/* Read the initial length from a section.  The (draft) DWARF 3</span>
<a name="l15776"></a>15776 <span class="comment">   specification allows the initial length to take up either 4 bytes</span>
<a name="l15777"></a>15777 <span class="comment">   or 12 bytes.  If the first 4 bytes are 0xffffffff, then the next 8</span>
<a name="l15778"></a>15778 <span class="comment">   bytes describe the length and all offsets will be 8 bytes in length</span>
<a name="l15779"></a>15779 <span class="comment">   instead of 4.</span>
<a name="l15780"></a>15780 <span class="comment"></span>
<a name="l15781"></a>15781 <span class="comment">   An older, non-standard 64-bit format is also handled by this</span>
<a name="l15782"></a>15782 <span class="comment">   function.  The older format in question stores the initial length</span>
<a name="l15783"></a>15783 <span class="comment">   as an 8-byte quantity without an escape value.  Lengths greater</span>
<a name="l15784"></a>15784 <span class="comment">   than 2^32 aren&#39;t very common which means that the initial 4 bytes</span>
<a name="l15785"></a>15785 <span class="comment">   is almost always zero.  Since a length value of zero doesn&#39;t make</span>
<a name="l15786"></a>15786 <span class="comment">   sense for the 32-bit format, this initial zero can be considered to</span>
<a name="l15787"></a>15787 <span class="comment">   be an escape value which indicates the presence of the older 64-bit</span>
<a name="l15788"></a>15788 <span class="comment">   format.  As written, the code can&#39;t detect (old format) lengths</span>
<a name="l15789"></a>15789 <span class="comment">   greater than 4GB.  If it becomes necessary to handle lengths</span>
<a name="l15790"></a>15790 <span class="comment">   somewhat larger than 4GB, we could allow other small values (such</span>
<a name="l15791"></a>15791 <span class="comment">   as the non-sensical values of 1, 2, and 3) to also be used as</span>
<a name="l15792"></a>15792 <span class="comment">   escape values indicating the presence of the old format.</span>
<a name="l15793"></a>15793 <span class="comment"></span>
<a name="l15794"></a>15794 <span class="comment">   The value returned via bytes_read should be used to increment the</span>
<a name="l15795"></a>15795 <span class="comment">   relevant pointer after calling read_initial_length().</span>
<a name="l15796"></a>15796 <span class="comment"></span>
<a name="l15797"></a>15797 <span class="comment">   [ Note:  read_initial_length() and read_offset() are based on the</span>
<a name="l15798"></a>15798 <span class="comment">     document entitled &quot;DWARF Debugging Information Format&quot;, revision</span>
<a name="l15799"></a>15799 <span class="comment">     3, draft 8, dated November 19, 2001.  This document was obtained</span>
<a name="l15800"></a>15800 <span class="comment">     from:</span>
<a name="l15801"></a>15801 <span class="comment"></span>
<a name="l15802"></a>15802 <span class="comment">        http://reality.sgiweb.org/davea/dwarf3-draft8-011125.pdf</span>
<a name="l15803"></a>15803 <span class="comment"></span>
<a name="l15804"></a>15804 <span class="comment">     This document is only a draft and is subject to change.  (So beware.)</span>
<a name="l15805"></a>15805 <span class="comment"></span>
<a name="l15806"></a>15806 <span class="comment">     Details regarding the older, non-standard 64-bit format were</span>
<a name="l15807"></a>15807 <span class="comment">     determined empirically by examining 64-bit ELF files produced by</span>
<a name="l15808"></a>15808 <span class="comment">     the SGI toolchain on an IRIX 6.5 machine.</span>
<a name="l15809"></a>15809 <span class="comment"></span>
<a name="l15810"></a>15810 <span class="comment">     - Kevin, July 16, 2002</span>
<a name="l15811"></a>15811 <span class="comment">   ] */</span>
<a name="l15812"></a>15812 
<a name="l15813"></a>15813 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l15814"></a><a class="code" href="dwarf2read_8c.html#a40cbc7bcde605127cf1baef337c57f9e">15814</a> <a class="code" href="dwarf2read_8c.html#a40cbc7bcde605127cf1baef337c57f9e">read_initial_length</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *bytes_read)
<a name="l15815"></a>15815 {
<a name="l15816"></a>15816   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a> = bfd_get_32 (abfd, buf);
<a name="l15817"></a>15817 
<a name="l15818"></a>15818   <span class="keywordflow">if</span> (length == 0xffffffff)
<a name="l15819"></a>15819     {
<a name="l15820"></a>15820       length = bfd_get_64 (abfd, buf + 4);
<a name="l15821"></a>15821       *bytes_read = 12;
<a name="l15822"></a>15822     }
<a name="l15823"></a>15823   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (length == 0)
<a name="l15824"></a>15824     {
<a name="l15825"></a>15825       <span class="comment">/* Handle the (non-standard) 64-bit DWARF2 format used by IRIX.  */</span>
<a name="l15826"></a>15826       length = bfd_get_64 (abfd, buf);
<a name="l15827"></a>15827       *bytes_read = 8;
<a name="l15828"></a>15828     }
<a name="l15829"></a>15829   <span class="keywordflow">else</span>
<a name="l15830"></a>15830     {
<a name="l15831"></a>15831       *bytes_read = 4;
<a name="l15832"></a>15832     }
<a name="l15833"></a>15833 
<a name="l15834"></a>15834   <span class="keywordflow">return</span> <a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a>;
<a name="l15835"></a>15835 }
<a name="l15836"></a>15836 
<a name="l15837"></a>15837 <span class="comment">/* Cover function for read_initial_length.</span>
<a name="l15838"></a>15838 <span class="comment">   Returns the length of the object at BUF, and stores the size of the</span>
<a name="l15839"></a>15839 <span class="comment">   initial length in *BYTES_READ and stores the size that offsets will be in</span>
<a name="l15840"></a>15840 <span class="comment">   *OFFSET_SIZE.</span>
<a name="l15841"></a>15841 <span class="comment">   If the initial length size is not equivalent to that specified in</span>
<a name="l15842"></a>15842 <span class="comment">   CU_HEADER then issue a complaint.</span>
<a name="l15843"></a>15843 <span class="comment">   This is useful when reading non-comp-unit headers.  */</span>
<a name="l15844"></a>15844 
<a name="l15845"></a>15845 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l15846"></a><a class="code" href="dwarf2read_8c.html#a7944620736e702f37e23ffd06e743fab">15846</a> <a class="code" href="dwarf2read_8c.html#a7944620736e702f37e23ffd06e743fab">read_checked_initial_length_and_offset</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf,
<a name="l15847"></a>15847                                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_header,
<a name="l15848"></a>15848                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *bytes_read,
<a name="l15849"></a>15849                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>)
<a name="l15850"></a>15850 {
<a name="l15851"></a>15851   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a> = <a class="code" href="dwarf2read_8c.html#a40cbc7bcde605127cf1baef337c57f9e">read_initial_length</a> (abfd, buf, bytes_read);
<a name="l15852"></a>15852 
<a name="l15853"></a>15853   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (cu_header-&gt;<a class="code" href="structcomp__unit__head.html#ac7e963b953a807bdbcecd0c3dd4f1790">initial_length_size</a> == 4
<a name="l15854"></a>15854               || cu_header-&gt;<a class="code" href="structcomp__unit__head.html#ac7e963b953a807bdbcecd0c3dd4f1790">initial_length_size</a> == 8
<a name="l15855"></a>15855               || cu_header-&gt;<a class="code" href="structcomp__unit__head.html#ac7e963b953a807bdbcecd0c3dd4f1790">initial_length_size</a> == 12);
<a name="l15856"></a>15856 
<a name="l15857"></a>15857   <span class="keywordflow">if</span> (cu_header-&gt;<a class="code" href="structcomp__unit__head.html#ac7e963b953a807bdbcecd0c3dd4f1790">initial_length_size</a> != *bytes_read)
<a name="l15858"></a>15858     <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l15859"></a>15859                <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;intermixed 32-bit and 64-bit DWARF sections&quot;</span>));
<a name="l15860"></a>15860 
<a name="l15861"></a>15861   *offset_size = (*bytes_read == 4) ? 4 : 8;
<a name="l15862"></a>15862   <span class="keywordflow">return</span> <a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a>;
<a name="l15863"></a>15863 }
<a name="l15864"></a>15864 
<a name="l15865"></a>15865 <span class="comment">/* Read an offset from the data stream.  The size of the offset is</span>
<a name="l15866"></a>15866 <span class="comment">   given by cu_header-&gt;offset_size.  */</span>
<a name="l15867"></a>15867 
<a name="l15868"></a>15868 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l15869"></a><a class="code" href="dwarf2read_8c.html#afd4b43dc237191df908291fb832628e5">15869</a> <a class="code" href="dwarf2read_8c.html#afd4b43dc237191df908291fb832628e5">read_offset</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf,
<a name="l15870"></a>15870              <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_header,
<a name="l15871"></a>15871              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *bytes_read)
<a name="l15872"></a>15872 {
<a name="l15873"></a>15873   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> offset = <a class="code" href="dwarf2read_8c.html#a7d7df1bb27bd8e2cdd3b27bafd16640b">read_offset_1</a> (abfd, buf, cu_header-&gt;<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>);
<a name="l15874"></a>15874 
<a name="l15875"></a>15875   *bytes_read = cu_header-&gt;<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>;
<a name="l15876"></a>15876   <span class="keywordflow">return</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l15877"></a>15877 }
<a name="l15878"></a>15878 
<a name="l15879"></a>15879 <span class="comment">/* Read an offset from the data stream.  */</span>
<a name="l15880"></a>15880 
<a name="l15881"></a>15881 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l15882"></a><a class="code" href="dwarf2read_8c.html#a7d7df1bb27bd8e2cdd3b27bafd16640b">15882</a> <a class="code" href="dwarf2read_8c.html#a7d7df1bb27bd8e2cdd3b27bafd16640b">read_offset_1</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>)
<a name="l15883"></a>15883 {
<a name="l15884"></a>15884   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> retval = 0;
<a name="l15885"></a>15885 
<a name="l15886"></a>15886   <span class="keywordflow">switch</span> (offset_size)
<a name="l15887"></a>15887     {
<a name="l15888"></a>15888     <span class="keywordflow">case</span> 4:
<a name="l15889"></a>15889       retval = bfd_get_32 (abfd, buf);
<a name="l15890"></a>15890       <span class="keywordflow">break</span>;
<a name="l15891"></a>15891     <span class="keywordflow">case</span> 8:
<a name="l15892"></a>15892       retval = bfd_get_64 (abfd, buf);
<a name="l15893"></a>15893       <span class="keywordflow">break</span>;
<a name="l15894"></a>15894     <span class="keywordflow">default</span>:
<a name="l15895"></a>15895       <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l15896"></a>15896                       <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;read_offset_1: bad switch [in module %s]&quot;</span>),
<a name="l15897"></a>15897                       bfd_get_filename (abfd));
<a name="l15898"></a>15898     }
<a name="l15899"></a>15899 
<a name="l15900"></a>15900   <span class="keywordflow">return</span> retval;
<a name="l15901"></a>15901 }
<a name="l15902"></a>15902 
<a name="l15903"></a>15903 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l15904"></a><a class="code" href="dwarf2read_8c.html#a7078db3bb8caab1b87567e9e8441d95f">15904</a> <a class="code" href="dwarf2read_8c.html#a7078db3bb8caab1b87567e9e8441d95f">read_n_bytes</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>)
<a name="l15905"></a>15905 {
<a name="l15906"></a>15906   <span class="comment">/* If the size of a host char is 8 bits, we can return a pointer</span>
<a name="l15907"></a>15907 <span class="comment">     to the buffer, otherwise we have to copy the data to a buffer</span>
<a name="l15908"></a>15908 <span class="comment">     allocated on the temporary obstack.  */</span>
<a name="l15909"></a>15909   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> == 8);
<a name="l15910"></a>15910   <span class="keywordflow">return</span> buf;
<a name="l15911"></a>15911 }
<a name="l15912"></a>15912 
<a name="l15913"></a>15913 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l15914"></a><a class="code" href="dwarf2read_8c.html#a5386044c6f74a934dbd3f4a3199cf5be">15914</a> <a class="code" href="dwarf2read_8c.html#a5386044c6f74a934dbd3f4a3199cf5be">read_direct_string</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf,
<a name="l15915"></a>15915                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *bytes_read_ptr)
<a name="l15916"></a>15916 {
<a name="l15917"></a>15917   <span class="comment">/* If the size of a host char is 8 bits, we can return a pointer</span>
<a name="l15918"></a>15918 <span class="comment">     to the string, otherwise we have to copy the string to a buffer</span>
<a name="l15919"></a>15919 <span class="comment">     allocated on the temporary obstack.  */</span>
<a name="l15920"></a>15920   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> == 8);
<a name="l15921"></a>15921   <span class="keywordflow">if</span> (*buf == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l15922"></a>15922     {
<a name="l15923"></a>15923       *bytes_read_ptr = 1;
<a name="l15924"></a>15924       <span class="keywordflow">return</span> NULL;
<a name="l15925"></a>15925     }
<a name="l15926"></a>15926   *bytes_read_ptr = strlen ((<span class="keyword">const</span> <span class="keywordtype">char</span> *) buf) + 1;
<a name="l15927"></a>15927   <span class="keywordflow">return</span> (<span class="keyword">const</span> <span class="keywordtype">char</span> *) buf;
<a name="l15928"></a>15928 }
<a name="l15929"></a>15929 
<a name="l15930"></a>15930 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l15931"></a><a class="code" href="dwarf2read_8c.html#a872bd8fea8791345413810a1049fa68f">15931</a> <a class="code" href="dwarf2read_8c.html#a872bd8fea8791345413810a1049fa68f">read_indirect_string_at_offset</a> (bfd *abfd, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> str_offset)
<a name="l15932"></a>15932 {
<a name="l15933"></a>15933   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (dwarf2_per_objfile-&gt;objfile, &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#aa102f0528a3f536a3e96802d8e76cc6b">str</a>);
<a name="l15934"></a>15934   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#aa102f0528a3f536a3e96802d8e76cc6b">str</a>.<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> == NULL)
<a name="l15935"></a>15935     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_FORM_strp used without .debug_str section [in module %s]&quot;</span>),
<a name="l15936"></a>15936            bfd_get_filename (abfd));
<a name="l15937"></a>15937   <span class="keywordflow">if</span> (str_offset &gt;= dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#aa102f0528a3f536a3e96802d8e76cc6b">str</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>)
<a name="l15938"></a>15938     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_FORM_strp pointing outside of &quot;</span>
<a name="l15939"></a>15939              <span class="stringliteral">&quot;.debug_str section [in module %s]&quot;</span>),
<a name="l15940"></a>15940            bfd_get_filename (abfd));
<a name="l15941"></a>15941   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> == 8);
<a name="l15942"></a>15942   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#aa102f0528a3f536a3e96802d8e76cc6b">str</a>.<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>[str_offset] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l15943"></a>15943     <span class="keywordflow">return</span> NULL;
<a name="l15944"></a>15944   <span class="keywordflow">return</span> (<span class="keyword">const</span> <span class="keywordtype">char</span> *) (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#aa102f0528a3f536a3e96802d8e76cc6b">str</a>.<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + str_offset);
<a name="l15945"></a>15945 }
<a name="l15946"></a>15946 
<a name="l15947"></a>15947 <span class="comment">/* Read a string at offset STR_OFFSET in the .debug_str section from</span>
<a name="l15948"></a>15948 <span class="comment">   the .dwz file DWZ.  Throw an error if the offset is too large.  If</span>
<a name="l15949"></a>15949 <span class="comment">   the string consists of a single NUL byte, return NULL; otherwise</span>
<a name="l15950"></a>15950 <span class="comment">   return a pointer to the string.  */</span>
<a name="l15951"></a>15951 
<a name="l15952"></a>15952 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l15953"></a><a class="code" href="dwarf2read_8c.html#aae8af1e5be4adc81e8945968faf67e31">15953</a> <a class="code" href="dwarf2read_8c.html#aae8af1e5be4adc81e8945968faf67e31">read_indirect_string_from_dwz</a> (<span class="keyword">struct</span> <a class="code" href="structdwz__file.html">dwz_file</a> *dwz, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> str_offset)
<a name="l15954"></a>15954 {
<a name="l15955"></a>15955   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (dwarf2_per_objfile-&gt;objfile, &amp;dwz-&gt;<a class="code" href="structdwz__file.html#a7eb5552ada9f95eca388ad29b74c28af">str</a>);
<a name="l15956"></a>15956 
<a name="l15957"></a>15957   <span class="keywordflow">if</span> (dwz-&gt;<a class="code" href="structdwz__file.html#a7eb5552ada9f95eca388ad29b74c28af">str</a>.<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> == NULL)
<a name="l15958"></a>15958     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_FORM_GNU_strp_alt used without .debug_str &quot;</span>
<a name="l15959"></a>15959              <span class="stringliteral">&quot;section [in module %s]&quot;</span>),
<a name="l15960"></a>15960            bfd_get_filename (dwz-&gt;<a class="code" href="structdwz__file.html#a9fc9bf241da902e55d1a4ddbaa8141eb">dwz_bfd</a>));
<a name="l15961"></a>15961   <span class="keywordflow">if</span> (str_offset &gt;= dwz-&gt;<a class="code" href="structdwz__file.html#a7eb5552ada9f95eca388ad29b74c28af">str</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>)
<a name="l15962"></a>15962     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_FORM_GNU_strp_alt pointing outside of &quot;</span>
<a name="l15963"></a>15963              <span class="stringliteral">&quot;.debug_str section [in module %s]&quot;</span>),
<a name="l15964"></a>15964            bfd_get_filename (dwz-&gt;<a class="code" href="structdwz__file.html#a9fc9bf241da902e55d1a4ddbaa8141eb">dwz_bfd</a>));
<a name="l15965"></a>15965   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> == 8);
<a name="l15966"></a>15966   <span class="keywordflow">if</span> (dwz-&gt;<a class="code" href="structdwz__file.html#a7eb5552ada9f95eca388ad29b74c28af">str</a>.<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>[str_offset] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l15967"></a>15967     <span class="keywordflow">return</span> NULL;
<a name="l15968"></a>15968   <span class="keywordflow">return</span> (<span class="keyword">const</span> <span class="keywordtype">char</span> *) (dwz-&gt;<a class="code" href="structdwz__file.html#a7eb5552ada9f95eca388ad29b74c28af">str</a>.<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + str_offset);
<a name="l15969"></a>15969 }
<a name="l15970"></a>15970 
<a name="l15971"></a>15971 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l15972"></a><a class="code" href="dwarf2read_8c.html#a3bafaf539b850b4e8610f36fefb1b4a2">15972</a> <a class="code" href="dwarf2read_8c.html#a3bafaf539b850b4e8610f36fefb1b4a2">read_indirect_string</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf,
<a name="l15973"></a>15973                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_header,
<a name="l15974"></a>15974                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *bytes_read_ptr)
<a name="l15975"></a>15975 {
<a name="l15976"></a>15976   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> str_offset = <a class="code" href="dwarf2read_8c.html#afd4b43dc237191df908291fb832628e5">read_offset</a> (abfd, buf, cu_header, bytes_read_ptr);
<a name="l15977"></a>15977 
<a name="l15978"></a>15978   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a872bd8fea8791345413810a1049fa68f">read_indirect_string_at_offset</a> (abfd, str_offset);
<a name="l15979"></a>15979 }
<a name="l15980"></a>15980 
<a name="l15981"></a>15981 <span class="keyword">static</span> <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a>
<a name="l15982"></a><a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">15982</a> <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf,
<a name="l15983"></a>15983                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *bytes_read_ptr)
<a name="l15984"></a>15984 {
<a name="l15985"></a>15985   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> result;
<a name="l15986"></a>15986   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_read;
<a name="l15987"></a>15987   <span class="keywordtype">int</span> i, shift;
<a name="l15988"></a>15988   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byte;
<a name="l15989"></a>15989 
<a name="l15990"></a>15990   result = 0;
<a name="l15991"></a>15991   shift = 0;
<a name="l15992"></a>15992   num_read = 0;
<a name="l15993"></a>15993   i = 0;
<a name="l15994"></a>15994   <span class="keywordflow">while</span> (1)
<a name="l15995"></a>15995     {
<a name="l15996"></a>15996       byte = bfd_get_8 (abfd, buf);
<a name="l15997"></a>15997       buf++;
<a name="l15998"></a>15998       num_read++;
<a name="l15999"></a>15999       result |= ((<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a>) (byte &amp; 127) &lt;&lt; shift);
<a name="l16000"></a>16000       <span class="keywordflow">if</span> ((byte &amp; 128) == 0)
<a name="l16001"></a>16001         {
<a name="l16002"></a>16002           <span class="keywordflow">break</span>;
<a name="l16003"></a>16003         }
<a name="l16004"></a>16004       shift += 7;
<a name="l16005"></a>16005     }
<a name="l16006"></a>16006   *bytes_read_ptr = num_read;
<a name="l16007"></a>16007   <span class="keywordflow">return</span> result;
<a name="l16008"></a>16008 }
<a name="l16009"></a>16009 
<a name="l16010"></a>16010 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l16011"></a><a class="code" href="dwarf2read_8c.html#adfbc149c8807d37b14d0d217da31ada0">16011</a> <a class="code" href="dwarf2read_8c.html#adfbc149c8807d37b14d0d217da31ada0">read_signed_leb128</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf,
<a name="l16012"></a>16012                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *bytes_read_ptr)
<a name="l16013"></a>16013 {
<a name="l16014"></a>16014   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> result;
<a name="l16015"></a>16015   <span class="keywordtype">int</span> i, shift, num_read;
<a name="l16016"></a>16016   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byte;
<a name="l16017"></a>16017 
<a name="l16018"></a>16018   result = 0;
<a name="l16019"></a>16019   shift = 0;
<a name="l16020"></a>16020   num_read = 0;
<a name="l16021"></a>16021   i = 0;
<a name="l16022"></a>16022   <span class="keywordflow">while</span> (1)
<a name="l16023"></a>16023     {
<a name="l16024"></a>16024       byte = bfd_get_8 (abfd, buf);
<a name="l16025"></a>16025       buf++;
<a name="l16026"></a>16026       num_read++;
<a name="l16027"></a>16027       result |= ((<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) (byte &amp; 127) &lt;&lt; shift);
<a name="l16028"></a>16028       shift += 7;
<a name="l16029"></a>16029       <span class="keywordflow">if</span> ((byte &amp; 128) == 0)
<a name="l16030"></a>16030         {
<a name="l16031"></a>16031           <span class="keywordflow">break</span>;
<a name="l16032"></a>16032         }
<a name="l16033"></a>16033     }
<a name="l16034"></a>16034   <span class="keywordflow">if</span> ((shift &lt; 8 * <span class="keyword">sizeof</span> (result)) &amp;&amp; (byte &amp; 0x40))
<a name="l16035"></a>16035     result |= -(((<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) 1) &lt;&lt; shift);
<a name="l16036"></a>16036   *bytes_read_ptr = num_read;
<a name="l16037"></a>16037   <span class="keywordflow">return</span> result;
<a name="l16038"></a>16038 }
<a name="l16039"></a>16039 
<a name="l16040"></a>16040 <span class="comment">/* Given index ADDR_INDEX in .debug_addr, fetch the value.</span>
<a name="l16041"></a>16041 <span class="comment">   ADDR_BASE is the DW_AT_GNU_addr_base attribute or zero.</span>
<a name="l16042"></a>16042 <span class="comment">   ADDR_SIZE is the size of addresses from the CU header.  */</span>
<a name="l16043"></a>16043 
<a name="l16044"></a>16044 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l16045"></a><a class="code" href="dwarf2read_8c.html#ab01351350fc50e277e3d4803930469ee">16045</a> <a class="code" href="dwarf2read_8c.html#ab01351350fc50e277e3d4803930469ee">read_addr_index_1</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> addr_index, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> addr_base, <span class="keywordtype">int</span> <a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>)
<a name="l16046"></a>16046 {
<a name="l16047"></a>16047   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l16048"></a>16048   bfd *abfd = objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>;
<a name="l16049"></a>16049   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr;
<a name="l16050"></a>16050 
<a name="l16051"></a>16051   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a51717beb2e74eb048118463e0030a16f">addr</a>);
<a name="l16052"></a>16052   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a51717beb2e74eb048118463e0030a16f">addr</a>.<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> == NULL)
<a name="l16053"></a>16053     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_FORM_addr_index used without .debug_addr section [in module %s]&quot;</span>),
<a name="l16054"></a>16054            <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l16055"></a>16055   <span class="keywordflow">if</span> (addr_base + addr_index * addr_size &gt;= dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a51717beb2e74eb048118463e0030a16f">addr</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>)
<a name="l16056"></a>16056     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;DW_FORM_addr_index pointing outside of &quot;</span>
<a name="l16057"></a>16057              <span class="stringliteral">&quot;.debug_addr section [in module %s]&quot;</span>),
<a name="l16058"></a>16058            <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l16059"></a>16059   info_ptr = (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a51717beb2e74eb048118463e0030a16f">addr</a>.<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>
<a name="l16060"></a>16060               + addr_base + addr_index * addr_size);
<a name="l16061"></a>16061   <span class="keywordflow">if</span> (addr_size == 4)
<a name="l16062"></a>16062     <span class="keywordflow">return</span> bfd_get_32 (abfd, info_ptr);
<a name="l16063"></a>16063   <span class="keywordflow">else</span>
<a name="l16064"></a>16064     <span class="keywordflow">return</span> bfd_get_64 (abfd, info_ptr);
<a name="l16065"></a>16065 }
<a name="l16066"></a>16066 
<a name="l16067"></a>16067 <span class="comment">/* Given index ADDR_INDEX in .debug_addr, fetch the value.  */</span>
<a name="l16068"></a>16068 
<a name="l16069"></a>16069 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l16070"></a><a class="code" href="dwarf2read_8c.html#addb17bd790d0fbedddfdae82d53c9d4f">16070</a> <a class="code" href="dwarf2read_8c.html#addb17bd790d0fbedddfdae82d53c9d4f">read_addr_index</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> addr_index)
<a name="l16071"></a>16071 {
<a name="l16072"></a>16072   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#ab01351350fc50e277e3d4803930469ee">read_addr_index_1</a> (addr_index, cu-&gt;addr_base, cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>);
<a name="l16073"></a>16073 }
<a name="l16074"></a>16074 
<a name="l16075"></a>16075 <span class="comment">/* Given a pointer to an leb128 value, fetch the value from .debug_addr.  */</span>
<a name="l16076"></a>16076 
<a name="l16077"></a>16077 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l16078"></a><a class="code" href="dwarf2read_8c.html#a62579cbb3d5cf28bac5bff46f3d7ed11">16078</a> <a class="code" href="dwarf2read_8c.html#a62579cbb3d5cf28bac5bff46f3d7ed11">read_addr_index_from_leb128</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l16079"></a>16079                              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *bytes_read)
<a name="l16080"></a>16080 {
<a name="l16081"></a>16081   bfd *abfd = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>;
<a name="l16082"></a>16082   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> addr_index = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, info_ptr, bytes_read);
<a name="l16083"></a>16083 
<a name="l16084"></a>16084   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#addb17bd790d0fbedddfdae82d53c9d4f">read_addr_index</a> (cu, addr_index);
<a name="l16085"></a>16085 }
<a name="l16086"></a>16086 
<a name="l16087"></a>16087 <span class="comment">/* Data structure to pass results from dwarf2_read_addr_index_reader</span>
<a name="l16088"></a>16088 <span class="comment">   back to dwarf2_read_addr_index.  */</span>
<a name="l16089"></a>16089 
<a name="l16090"></a><a class="code" href="structdwarf2__read__addr__index__data.html">16090</a> <span class="keyword">struct </span><a class="code" href="structdwarf2__read__addr__index__data.html">dwarf2_read_addr_index_data</a>
<a name="l16091"></a>16091 {
<a name="l16092"></a><a class="code" href="structdwarf2__read__addr__index__data.html#ae386a77b586dec3ce3728380aa35c11e">16092</a>   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structdwarf2__read__addr__index__data.html#ae386a77b586dec3ce3728380aa35c11e">addr_base</a>;
<a name="l16093"></a><a class="code" href="structdwarf2__read__addr__index__data.html#a242e73f83c97e31d9a538759d4d2713b">16093</a>   <span class="keywordtype">int</span> <a class="code" href="structdwarf2__read__addr__index__data.html#a242e73f83c97e31d9a538759d4d2713b">addr_size</a>;
<a name="l16094"></a>16094 };
<a name="l16095"></a>16095 
<a name="l16096"></a>16096 <span class="comment">/* die_reader_func for dwarf2_read_addr_index.  */</span>
<a name="l16097"></a>16097 
<a name="l16098"></a>16098 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l16099"></a><a class="code" href="dwarf2read_8c.html#a3f5321ce4b850dd2f8f1a0c75a70caf3">16099</a> <a class="code" href="dwarf2read_8c.html#a3f5321ce4b850dd2f8f1a0c75a70caf3">dwarf2_read_addr_index_reader</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l16100"></a>16100                                <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l16101"></a>16101                                <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *comp_unit_die,
<a name="l16102"></a>16102                                <span class="keywordtype">int</span> has_children,
<a name="l16103"></a>16103                                <span class="keywordtype">void</span> *data)
<a name="l16104"></a>16104 {
<a name="l16105"></a>16105   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l16106"></a>16106   <span class="keyword">struct </span><a class="code" href="structdwarf2__read__addr__index__data.html">dwarf2_read_addr_index_data</a> *aidata =
<a name="l16107"></a>16107     (<span class="keyword">struct </span><a class="code" href="structdwarf2__read__addr__index__data.html">dwarf2_read_addr_index_data</a> *) data;
<a name="l16108"></a>16108 
<a name="l16109"></a>16109   aidata-&gt;<a class="code" href="structdwarf2__read__addr__index__data.html#ae386a77b586dec3ce3728380aa35c11e">addr_base</a> = cu-&gt;addr_base;
<a name="l16110"></a>16110   aidata-&gt;<a class="code" href="structdwarf2__read__addr__index__data.html#a242e73f83c97e31d9a538759d4d2713b">addr_size</a> = cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l16111"></a>16111 }
<a name="l16112"></a>16112 
<a name="l16113"></a>16113 <span class="comment">/* Given an index in .debug_addr, fetch the value.</span>
<a name="l16114"></a>16114 <span class="comment">   NOTE: This can be called during dwarf expression evaluation,</span>
<a name="l16115"></a>16115 <span class="comment">   long after the debug information has been read, and thus per_cu-&gt;cu</span>
<a name="l16116"></a>16116 <span class="comment">   may no longer exist.  */</span>
<a name="l16117"></a>16117 
<a name="l16118"></a>16118 <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l16119"></a><a class="code" href="dwarf2read_8c.html#a17d485716cc05b58e95eaa45fde1b7c0">16119</a> <a class="code" href="dwarf2loc_8h.html#a17d485716cc05b58e95eaa45fde1b7c0">dwarf2_read_addr_index</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu,
<a name="l16120"></a>16120                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> addr_index)
<a name="l16121"></a>16121 {
<a name="l16122"></a>16122   <span class="keyword">struct </span>objfile *objfile = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>;
<a name="l16123"></a>16123   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>;
<a name="l16124"></a>16124   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> addr_base;
<a name="l16125"></a>16125   <span class="keywordtype">int</span> addr_size;
<a name="l16126"></a>16126 
<a name="l16127"></a>16127   <span class="comment">/* This is intended to be called from outside this file.  */</span>
<a name="l16128"></a>16128   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (objfile);
<a name="l16129"></a>16129 
<a name="l16130"></a>16130   <span class="comment">/* We need addr_base and addr_size.</span>
<a name="l16131"></a>16131 <span class="comment">     If we don&#39;t have PER_CU-&gt;cu, we have to get it.</span>
<a name="l16132"></a>16132 <span class="comment">     Nasty, but the alternative is storing the needed info in PER_CU,</span>
<a name="l16133"></a>16133 <span class="comment">     which at this point doesn&#39;t seem justified: it&#39;s not clear how frequently</span>
<a name="l16134"></a>16134 <span class="comment">     it would get used and it would increase the size of every PER_CU.</span>
<a name="l16135"></a>16135 <span class="comment">     Entry points like dwarf2_per_cu_addr_size do a similar thing</span>
<a name="l16136"></a>16136 <span class="comment">     so we&#39;re not in uncharted territory here.</span>
<a name="l16137"></a>16137 <span class="comment">     Alas we need to be a bit more complicated as addr_base is contained</span>
<a name="l16138"></a>16138 <span class="comment">     in the DIE.</span>
<a name="l16139"></a>16139 <span class="comment"></span>
<a name="l16140"></a>16140 <span class="comment">     We don&#39;t need to read the entire CU(/TU).</span>
<a name="l16141"></a>16141 <span class="comment">     We just need the header and top level die.</span>
<a name="l16142"></a>16142 <span class="comment"></span>
<a name="l16143"></a>16143 <span class="comment">     IWBN to use the aging mechanism to let us lazily later discard the CU.</span>
<a name="l16144"></a>16144 <span class="comment">     For now we skip this optimization.  */</span>
<a name="l16145"></a>16145 
<a name="l16146"></a>16146   <span class="keywordflow">if</span> (cu != NULL)
<a name="l16147"></a>16147     {
<a name="l16148"></a>16148       addr_base = cu-&gt;addr_base;
<a name="l16149"></a>16149       addr_size = cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l16150"></a>16150     }
<a name="l16151"></a>16151   <span class="keywordflow">else</span>
<a name="l16152"></a>16152     {
<a name="l16153"></a>16153       <span class="keyword">struct </span><a class="code" href="structdwarf2__read__addr__index__data.html">dwarf2_read_addr_index_data</a> aidata;
<a name="l16154"></a>16154 
<a name="l16155"></a>16155       <span class="comment">/* Note: We can&#39;t use init_cutu_and_read_dies_simple here,</span>
<a name="l16156"></a>16156 <span class="comment">         we need addr_base.  */</span>
<a name="l16157"></a>16157       <a class="code" href="dwarf2read_8c.html#a2887b925bcf54483d1c0dc40faefdd08">init_cutu_and_read_dies</a> (per_cu, NULL, 0, 0,
<a name="l16158"></a>16158                                <a class="code" href="dwarf2read_8c.html#a3f5321ce4b850dd2f8f1a0c75a70caf3">dwarf2_read_addr_index_reader</a>, &amp;aidata);
<a name="l16159"></a>16159       addr_base = aidata.<a class="code" href="structdwarf2__read__addr__index__data.html#ae386a77b586dec3ce3728380aa35c11e">addr_base</a>;
<a name="l16160"></a>16160       addr_size = aidata.<a class="code" href="structdwarf2__read__addr__index__data.html#a242e73f83c97e31d9a538759d4d2713b">addr_size</a>;
<a name="l16161"></a>16161     }
<a name="l16162"></a>16162 
<a name="l16163"></a>16163   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#ab01351350fc50e277e3d4803930469ee">read_addr_index_1</a> (addr_index, addr_base, addr_size);
<a name="l16164"></a>16164 }
<a name="l16165"></a>16165 
<a name="l16166"></a>16166 <span class="comment">/* Given a DW_FORM_GNU_str_index, fetch the string.</span>
<a name="l16167"></a>16167 <span class="comment">   This is only used by the Fission support.  */</span>
<a name="l16168"></a>16168 
<a name="l16169"></a>16169 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l16170"></a><a class="code" href="dwarf2read_8c.html#a11ef1cbeffac261cacbe27fa98628253">16170</a> <a class="code" href="dwarf2read_8c.html#a11ef1cbeffac261cacbe27fa98628253">read_str_index</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l16171"></a>16171                 <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> str_index)
<a name="l16172"></a>16172 {
<a name="l16173"></a>16173   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l16174"></a>16174   <span class="keyword">const</span> <span class="keywordtype">char</span> *dwo_name = <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile);
<a name="l16175"></a>16175   bfd *abfd = objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>;
<a name="l16176"></a>16176   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *str_section = &amp;reader-&gt;<a class="code" href="structdie__reader__specs.html#a64321aff4f42ed613b8831c4d0804c36">dwo_file</a>-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#ae8ef8aea284e8f15890bc43155754ce2">str</a>;
<a name="l16177"></a>16177   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *str_offsets_section =
<a name="l16178"></a>16178     &amp;reader-&gt;<a class="code" href="structdie__reader__specs.html#a64321aff4f42ed613b8831c4d0804c36">dwo_file</a>-&gt;<a class="code" href="structdwo__file.html#ab9a306838165c14bf4aba862e4f0d9ca">sections</a>.<a class="code" href="structdwo__sections.html#a931377e7a734f721034972c4061af209">str_offsets</a>;
<a name="l16179"></a>16179   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr;
<a name="l16180"></a>16180   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> str_offset;
<a name="l16181"></a>16181   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> form_name[] = <span class="stringliteral">&quot;DW_FORM_GNU_str_index&quot;</span>;
<a name="l16182"></a>16182 
<a name="l16183"></a>16183   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, str_section);
<a name="l16184"></a>16184   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, str_offsets_section);
<a name="l16185"></a>16185   <span class="keywordflow">if</span> (str_section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> == NULL)
<a name="l16186"></a>16186     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;%s used without .debug_str.dwo section&quot;</span>
<a name="l16187"></a>16187              <span class="stringliteral">&quot; in CU at offset 0x%lx [in module %s]&quot;</span>),
<a name="l16188"></a>16188            form_name, (<span class="keywordtype">long</span>) cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, dwo_name);
<a name="l16189"></a>16189   <span class="keywordflow">if</span> (str_offsets_section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> == NULL)
<a name="l16190"></a>16190     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;%s used without .debug_str_offsets.dwo section&quot;</span>
<a name="l16191"></a>16191              <span class="stringliteral">&quot; in CU at offset 0x%lx [in module %s]&quot;</span>),
<a name="l16192"></a>16192            form_name, (<span class="keywordtype">long</span>) cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, dwo_name);
<a name="l16193"></a>16193   <span class="keywordflow">if</span> (str_index * cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a> &gt;= str_offsets_section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>)
<a name="l16194"></a>16194     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;%s pointing outside of .debug_str_offsets.dwo&quot;</span>
<a name="l16195"></a>16195              <span class="stringliteral">&quot; section in CU at offset 0x%lx [in module %s]&quot;</span>),
<a name="l16196"></a>16196            form_name, (<span class="keywordtype">long</span>) cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, dwo_name);
<a name="l16197"></a>16197   info_ptr = (str_offsets_section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>
<a name="l16198"></a>16198               + str_index * cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>);
<a name="l16199"></a>16199   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a> == 4)
<a name="l16200"></a>16200     str_offset = bfd_get_32 (abfd, info_ptr);
<a name="l16201"></a>16201   <span class="keywordflow">else</span>
<a name="l16202"></a>16202     str_offset = bfd_get_64 (abfd, info_ptr);
<a name="l16203"></a>16203   <span class="keywordflow">if</span> (str_offset &gt;= str_section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>)
<a name="l16204"></a>16204     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Offset from %s pointing outside of&quot;</span>
<a name="l16205"></a>16205              <span class="stringliteral">&quot; .debug_str.dwo section in CU at offset 0x%lx [in module %s]&quot;</span>),
<a name="l16206"></a>16206            form_name, (<span class="keywordtype">long</span>) cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, dwo_name);
<a name="l16207"></a>16207   <span class="keywordflow">return</span> (<span class="keyword">const</span> <span class="keywordtype">char</span> *) (str_section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + str_offset);
<a name="l16208"></a>16208 }
<a name="l16209"></a>16209 
<a name="l16210"></a>16210 <span class="comment">/* Return the length of an LEB128 number in BUF.  */</span>
<a name="l16211"></a>16211 
<a name="l16212"></a>16212 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l16213"></a><a class="code" href="dwarf2read_8c.html#a3826fd18cd7dcc7366b810ea152e5cbd">16213</a> <a class="code" href="dwarf2read_8c.html#a3826fd18cd7dcc7366b810ea152e5cbd">leb128_size</a> (<span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l16214"></a>16214 {
<a name="l16215"></a>16215   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *begin = buf;
<a name="l16216"></a>16216   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> byte;
<a name="l16217"></a>16217 
<a name="l16218"></a>16218   <span class="keywordflow">while</span> (1)
<a name="l16219"></a>16219     {
<a name="l16220"></a>16220       byte = *buf++;
<a name="l16221"></a>16221       <span class="keywordflow">if</span> ((byte &amp; 128) == 0)
<a name="l16222"></a>16222         <span class="keywordflow">return</span> buf - begin;
<a name="l16223"></a>16223     }
<a name="l16224"></a>16224 }
<a name="l16225"></a>16225 
<a name="l16226"></a>16226 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l16227"></a><a class="code" href="dwarf2read_8c.html#abd567fd6ea120b361c1b04ce7c20ea54">16227</a> <a class="code" href="dwarf2read_8c.html#abd567fd6ea120b361c1b04ce7c20ea54">set_cu_language</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lang, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l16228"></a>16228 {
<a name="l16229"></a>16229   <span class="keywordflow">switch</span> (lang)
<a name="l16230"></a>16230     {
<a name="l16231"></a>16231     <span class="keywordflow">case</span> DW_LANG_C89:
<a name="l16232"></a>16232     <span class="keywordflow">case</span> DW_LANG_C99:
<a name="l16233"></a>16233     <span class="keywordflow">case</span> DW_LANG_C:
<a name="l16234"></a>16234     <span class="keywordflow">case</span> DW_LANG_UPC:
<a name="l16235"></a>16235       cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202ad300f80a4c96edb04defba2280620a49">language_c</a>;
<a name="l16236"></a>16236       <span class="keywordflow">break</span>;
<a name="l16237"></a>16237     <span class="keywordflow">case</span> DW_LANG_C_plus_plus:
<a name="l16238"></a>16238       cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>;
<a name="l16239"></a>16239       <span class="keywordflow">break</span>;
<a name="l16240"></a>16240     <span class="keywordflow">case</span> DW_LANG_D:
<a name="l16241"></a>16241       cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202ad3b00d43bb1174a9e66b236f872514f9">language_d</a>;
<a name="l16242"></a>16242       <span class="keywordflow">break</span>;
<a name="l16243"></a>16243     <span class="keywordflow">case</span> DW_LANG_Fortran77:
<a name="l16244"></a>16244     <span class="keywordflow">case</span> DW_LANG_Fortran90:
<a name="l16245"></a>16245     <span class="keywordflow">case</span> DW_LANG_Fortran95:
<a name="l16246"></a>16246       cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>;
<a name="l16247"></a>16247       <span class="keywordflow">break</span>;
<a name="l16248"></a>16248     <span class="keywordflow">case</span> DW_LANG_Go:
<a name="l16249"></a>16249       cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a702bd2253975155cace46837f64a702a">language_go</a>;
<a name="l16250"></a>16250       <span class="keywordflow">break</span>;
<a name="l16251"></a>16251     <span class="keywordflow">case</span> DW_LANG_Mips_Assembler:
<a name="l16252"></a>16252       cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a941a537936361d4d55ac49a1c194c08d">language_asm</a>;
<a name="l16253"></a>16253       <span class="keywordflow">break</span>;
<a name="l16254"></a>16254     <span class="keywordflow">case</span> DW_LANG_Java:
<a name="l16255"></a>16255       cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>;
<a name="l16256"></a>16256       <span class="keywordflow">break</span>;
<a name="l16257"></a>16257     <span class="keywordflow">case</span> DW_LANG_Ada83:
<a name="l16258"></a>16258     <span class="keywordflow">case</span> DW_LANG_Ada95:
<a name="l16259"></a>16259       cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>;
<a name="l16260"></a>16260       <span class="keywordflow">break</span>;
<a name="l16261"></a>16261     <span class="keywordflow">case</span> DW_LANG_Modula2:
<a name="l16262"></a>16262       cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a24814ec1696c6cf0b223224d0f54b2a7">language_m2</a>;
<a name="l16263"></a>16263       <span class="keywordflow">break</span>;
<a name="l16264"></a>16264     <span class="keywordflow">case</span> DW_LANG_Pascal83:
<a name="l16265"></a>16265       cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202aabc6aaebbfda1ac216522364b89db30c">language_pascal</a>;
<a name="l16266"></a>16266       <span class="keywordflow">break</span>;
<a name="l16267"></a>16267     <span class="keywordflow">case</span> DW_LANG_ObjC:
<a name="l16268"></a>16268       cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202af970f874c431c7404837e92fe971e813">language_objc</a>;
<a name="l16269"></a>16269       <span class="keywordflow">break</span>;
<a name="l16270"></a>16270     <span class="keywordflow">case</span> DW_LANG_Cobol74:
<a name="l16271"></a>16271     <span class="keywordflow">case</span> DW_LANG_Cobol85:
<a name="l16272"></a>16272     <span class="keywordflow">default</span>:
<a name="l16273"></a>16273       cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a389b59241274e837cb0d28b1909013ac">language_minimal</a>;
<a name="l16274"></a>16274       <span class="keywordflow">break</span>;
<a name="l16275"></a>16275     }
<a name="l16276"></a>16276   cu-&gt;<a class="code" href="structdwarf2__cu.html#aa12f3aeef950b4457378c14f9ba16f12">language_defn</a> = <a class="code" href="language_8c.html#adba6bd079cb2f1df763354ec97abe0cd">language_def</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>);
<a name="l16277"></a>16277 }
<a name="l16278"></a>16278 
<a name="l16279"></a>16279 <span class="comment">/* Return the named attribute or NULL if not there.  */</span>
<a name="l16280"></a>16280 
<a name="l16281"></a>16281 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *
<a name="l16282"></a><a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">16282</a> <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> name, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l16283"></a>16283 {
<a name="l16284"></a>16284   <span class="keywordflow">for</span> (;;)
<a name="l16285"></a>16285     {
<a name="l16286"></a>16286       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l16287"></a>16287       <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *spec = NULL;
<a name="l16288"></a>16288 
<a name="l16289"></a>16289       <span class="keywordflow">for</span> (i = 0; i &lt; die-&gt;num_attrs; ++i)
<a name="l16290"></a>16290         {
<a name="l16291"></a>16291           <span class="keywordflow">if</span> (die-&gt;attrs[i].name == name)
<a name="l16292"></a>16292             <span class="keywordflow">return</span> &amp;die-&gt;attrs[i];
<a name="l16293"></a>16293           <span class="keywordflow">if</span> (die-&gt;attrs[i].name == DW_AT_specification
<a name="l16294"></a>16294               || die-&gt;attrs[i].name == DW_AT_abstract_origin)
<a name="l16295"></a>16295             spec = &amp;die-&gt;attrs[i];
<a name="l16296"></a>16296         }
<a name="l16297"></a>16297 
<a name="l16298"></a>16298       <span class="keywordflow">if</span> (!spec)
<a name="l16299"></a>16299         <span class="keywordflow">break</span>;
<a name="l16300"></a>16300 
<a name="l16301"></a>16301       die = <a class="code" href="dwarf2read_8c.html#a079b531fef51cfc34f92ff6fde2ef8a4">follow_die_ref</a> (die, spec, &amp;cu);
<a name="l16302"></a>16302     }
<a name="l16303"></a>16303 
<a name="l16304"></a>16304   <span class="keywordflow">return</span> NULL;
<a name="l16305"></a>16305 }
<a name="l16306"></a>16306 
<a name="l16307"></a>16307 <span class="comment">/* Return the named attribute or NULL if not there,</span>
<a name="l16308"></a>16308 <span class="comment">   but do not follow DW_AT_specification, etc.</span>
<a name="l16309"></a>16309 <span class="comment">   This is for use in contexts where we&#39;re reading .debug_types dies.</span>
<a name="l16310"></a>16310 <span class="comment">   Following DW_AT_specification, DW_AT_abstract_origin will take us</span>
<a name="l16311"></a>16311 <span class="comment">   back up the chain, and we want to go down.  */</span>
<a name="l16312"></a>16312 
<a name="l16313"></a>16313 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *
<a name="l16314"></a><a class="code" href="dwarf2read_8c.html#a50710a3c575e046cafb61f16aaca480f">16314</a> <a class="code" href="dwarf2read_8c.html#a50710a3c575e046cafb61f16aaca480f">dwarf2_attr_no_follow</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> name)
<a name="l16315"></a>16315 {
<a name="l16316"></a>16316   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l16317"></a>16317 
<a name="l16318"></a>16318   <span class="keywordflow">for</span> (i = 0; i &lt; die-&gt;num_attrs; ++i)
<a name="l16319"></a>16319     <span class="keywordflow">if</span> (die-&gt;attrs[i].name == name)
<a name="l16320"></a>16320       <span class="keywordflow">return</span> &amp;die-&gt;attrs[i];
<a name="l16321"></a>16321 
<a name="l16322"></a>16322   <span class="keywordflow">return</span> NULL;
<a name="l16323"></a>16323 }
<a name="l16324"></a>16324 
<a name="l16325"></a>16325 <span class="comment">/* Return non-zero iff the attribute NAME is defined for the given DIE,</span>
<a name="l16326"></a>16326 <span class="comment">   and holds a non-zero value.  This function should only be used for</span>
<a name="l16327"></a>16327 <span class="comment">   DW_FORM_flag or DW_FORM_flag_present attributes.  */</span>
<a name="l16328"></a>16328 
<a name="l16329"></a>16329 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l16330"></a><a class="code" href="dwarf2read_8c.html#ae71fe9211c7daaccc4d43abbe838c8dc">16330</a> <a class="code" href="dwarf2read_8c.html#ae71fe9211c7daaccc4d43abbe838c8dc">dwarf2_flag_true_p</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keywordtype">unsigned</span> name, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l16331"></a>16331 {
<a name="l16332"></a>16332   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, name, cu);
<a name="l16333"></a>16333 
<a name="l16334"></a>16334   <span class="keywordflow">return</span> (attr &amp;&amp; <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr));
<a name="l16335"></a>16335 }
<a name="l16336"></a>16336 
<a name="l16337"></a>16337 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l16338"></a><a class="code" href="dwarf2read_8c.html#aa9ca23caab102417f39b86b7b2716588">16338</a> <a class="code" href="dwarf2read_8c.html#aa9ca23caab102417f39b86b7b2716588">die_is_declaration</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l16339"></a>16339 {
<a name="l16340"></a>16340   <span class="comment">/* A DIE is a declaration if it has a DW_AT_declaration attribute</span>
<a name="l16341"></a>16341 <span class="comment">     which value is non-zero.  However, we have to be careful with</span>
<a name="l16342"></a>16342 <span class="comment">     DIEs having a DW_AT_specification attribute, because dwarf2_attr()</span>
<a name="l16343"></a>16343 <span class="comment">     (via dwarf2_flag_true_p) follows this attribute.  So we may</span>
<a name="l16344"></a>16344 <span class="comment">     end up accidently finding a declaration attribute that belongs</span>
<a name="l16345"></a>16345 <span class="comment">     to a different DIE referenced by the specification attribute,</span>
<a name="l16346"></a>16346 <span class="comment">     even though the given DIE does not have a declaration attribute.  */</span>
<a name="l16347"></a>16347   <span class="keywordflow">return</span> (<a class="code" href="dwarf2read_8c.html#ae71fe9211c7daaccc4d43abbe838c8dc">dwarf2_flag_true_p</a> (die, DW_AT_declaration, cu)
<a name="l16348"></a>16348           &amp;&amp; <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_specification, cu) == NULL);
<a name="l16349"></a>16349 }
<a name="l16350"></a>16350 
<a name="l16351"></a>16351 <span class="comment">/* Return the die giving the specification for DIE, if there is</span>
<a name="l16352"></a>16352 <span class="comment">   one.  *SPEC_CU is the CU containing DIE on input, and the CU</span>
<a name="l16353"></a>16353 <span class="comment">   containing the return value on output.  If there is no</span>
<a name="l16354"></a>16354 <span class="comment">   specification, but there is an abstract origin, that is</span>
<a name="l16355"></a>16355 <span class="comment">   returned.  */</span>
<a name="l16356"></a>16356 
<a name="l16357"></a>16357 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *
<a name="l16358"></a><a class="code" href="dwarf2read_8c.html#a86adfa4fccde4cd4c512ca520e5bb1d7">16358</a> <a class="code" href="dwarf2read_8c.html#a86adfa4fccde4cd4c512ca520e5bb1d7">die_specification</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> **spec_cu)
<a name="l16359"></a>16359 {
<a name="l16360"></a>16360   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *spec_attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_specification,
<a name="l16361"></a>16361                                              *spec_cu);
<a name="l16362"></a>16362 
<a name="l16363"></a>16363   <span class="keywordflow">if</span> (spec_attr == NULL)
<a name="l16364"></a>16364     spec_attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_abstract_origin, *spec_cu);
<a name="l16365"></a>16365 
<a name="l16366"></a>16366   <span class="keywordflow">if</span> (spec_attr == NULL)
<a name="l16367"></a>16367     <span class="keywordflow">return</span> NULL;
<a name="l16368"></a>16368   <span class="keywordflow">else</span>
<a name="l16369"></a>16369     <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a079b531fef51cfc34f92ff6fde2ef8a4">follow_die_ref</a> (die, spec_attr, spec_cu);
<a name="l16370"></a>16370 }
<a name="l16371"></a>16371 
<a name="l16372"></a>16372 <span class="comment">/* Free the line_header structure *LH, and any arrays and strings it</span>
<a name="l16373"></a>16373 <span class="comment">   refers to.</span>
<a name="l16374"></a>16374 <span class="comment">   NOTE: This is also used as a &quot;cleanup&quot; function.  */</span>
<a name="l16375"></a>16375 
<a name="l16376"></a>16376 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l16377"></a><a class="code" href="dwarf2read_8c.html#a2b16344b24303ef21765208ef32dfe7a">16377</a> <a class="code" href="dwarf2read_8c.html#a2b16344b24303ef21765208ef32dfe7a">free_line_header</a> (<span class="keyword">struct</span> <a class="code" href="structline__header.html">line_header</a> *lh)
<a name="l16378"></a>16378 {
<a name="l16379"></a>16379   <span class="keywordflow">if</span> (lh-&gt;<a class="code" href="structline__header.html#a03b9061576badda7a0d72053c713dca8">standard_opcode_lengths</a>)
<a name="l16380"></a>16380     <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (lh-&gt;<a class="code" href="structline__header.html#a03b9061576badda7a0d72053c713dca8">standard_opcode_lengths</a>);
<a name="l16381"></a>16381 
<a name="l16382"></a>16382   <span class="comment">/* Remember that all the lh-&gt;file_names[i].name pointers are</span>
<a name="l16383"></a>16383 <span class="comment">     pointers into debug_line_buffer, and don&#39;t need to be freed.  */</span>
<a name="l16384"></a>16384   <span class="keywordflow">if</span> (lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>)
<a name="l16385"></a>16385     <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>);
<a name="l16386"></a>16386 
<a name="l16387"></a>16387   <span class="comment">/* Similarly for the include directory names.  */</span>
<a name="l16388"></a>16388   <span class="keywordflow">if</span> (lh-&gt;<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a>)
<a name="l16389"></a>16389     <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (lh-&gt;<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a>);
<a name="l16390"></a>16390 
<a name="l16391"></a>16391   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (lh);
<a name="l16392"></a>16392 }
<a name="l16393"></a>16393 
<a name="l16394"></a>16394 <span class="comment">/* Add an entry to LH&#39;s include directory table.  */</span>
<a name="l16395"></a>16395 
<a name="l16396"></a>16396 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l16397"></a><a class="code" href="dwarf2read_8c.html#a62c2cc39f8ae5b270e78665445b534c1">16397</a> <a class="code" href="dwarf2read_8c.html#a62c2cc39f8ae5b270e78665445b534c1">add_include_dir</a> (<span class="keyword">struct</span> <a class="code" href="structline__header.html">line_header</a> *lh, <span class="keyword">const</span> <span class="keywordtype">char</span> *include_dir)
<a name="l16398"></a>16398 {
<a name="l16399"></a>16399   <span class="comment">/* Grow the array if necessary.  */</span>
<a name="l16400"></a>16400   <span class="keywordflow">if</span> (lh-&gt;<a class="code" href="structline__header.html#a56a396ec7694be5d0f9ad8f89da6a523">include_dirs_size</a> == 0)
<a name="l16401"></a>16401     {
<a name="l16402"></a>16402       lh-&gt;<a class="code" href="structline__header.html#a56a396ec7694be5d0f9ad8f89da6a523">include_dirs_size</a> = 1; <span class="comment">/* for testing */</span>
<a name="l16403"></a>16403       lh-&gt;<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a> = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (lh-&gt;<a class="code" href="structline__header.html#a56a396ec7694be5d0f9ad8f89da6a523">include_dirs_size</a>
<a name="l16404"></a>16404                                   * sizeof (*lh-&gt;<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a>));
<a name="l16405"></a>16405     }
<a name="l16406"></a>16406   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lh-&gt;<a class="code" href="structline__header.html#a964a9375d1e583ba5af063ed07de0f8e">num_include_dirs</a> &gt;= lh-&gt;<a class="code" href="structline__header.html#a56a396ec7694be5d0f9ad8f89da6a523">include_dirs_size</a>)
<a name="l16407"></a>16407     {
<a name="l16408"></a>16408       lh-&gt;<a class="code" href="structline__header.html#a56a396ec7694be5d0f9ad8f89da6a523">include_dirs_size</a> *= 2;
<a name="l16409"></a>16409       lh-&gt;<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a> = <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (lh-&gt;<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a>,
<a name="l16410"></a>16410                                    (lh-&gt;<a class="code" href="structline__header.html#a56a396ec7694be5d0f9ad8f89da6a523">include_dirs_size</a>
<a name="l16411"></a>16411                                     * sizeof (*lh-&gt;<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a>)));
<a name="l16412"></a>16412     }
<a name="l16413"></a>16413 
<a name="l16414"></a>16414   lh-&gt;<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a>[lh-&gt;<a class="code" href="structline__header.html#a964a9375d1e583ba5af063ed07de0f8e">num_include_dirs</a>++] = include_dir;
<a name="l16415"></a>16415 }
<a name="l16416"></a>16416 
<a name="l16417"></a>16417 <span class="comment">/* Add an entry to LH&#39;s file name table.  */</span>
<a name="l16418"></a>16418 
<a name="l16419"></a>16419 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l16420"></a><a class="code" href="dwarf2read_8c.html#a28e5a65b29809611a0bfb7c9c0ff213c">16420</a> <a class="code" href="dwarf2read_8c.html#a28e5a65b29809611a0bfb7c9c0ff213c">add_file_name</a> (<span class="keyword">struct</span> <a class="code" href="structline__header.html">line_header</a> *lh,
<a name="l16421"></a>16421                <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l16422"></a>16422                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dir_index,
<a name="l16423"></a>16423                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mod_time,
<a name="l16424"></a>16424                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length)
<a name="l16425"></a>16425 {
<a name="l16426"></a>16426   <span class="keyword">struct </span>file_entry *fe;
<a name="l16427"></a>16427 
<a name="l16428"></a>16428   <span class="comment">/* Grow the array if necessary.  */</span>
<a name="l16429"></a>16429   <span class="keywordflow">if</span> (lh-&gt;<a class="code" href="structline__header.html#a1b6f1018fc0d5e55f09b75453c00a9ba">file_names_size</a> == 0)
<a name="l16430"></a>16430     {
<a name="l16431"></a>16431       lh-&gt;<a class="code" href="structline__header.html#a1b6f1018fc0d5e55f09b75453c00a9ba">file_names_size</a> = 1; <span class="comment">/* for testing */</span>
<a name="l16432"></a>16432       lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a> = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (lh-&gt;<a class="code" href="structline__header.html#a1b6f1018fc0d5e55f09b75453c00a9ba">file_names_size</a>
<a name="l16433"></a>16433                                 * sizeof (*lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>));
<a name="l16434"></a>16434     }
<a name="l16435"></a>16435   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a> &gt;= lh-&gt;<a class="code" href="structline__header.html#a1b6f1018fc0d5e55f09b75453c00a9ba">file_names_size</a>)
<a name="l16436"></a>16436     {
<a name="l16437"></a>16437       lh-&gt;<a class="code" href="structline__header.html#a1b6f1018fc0d5e55f09b75453c00a9ba">file_names_size</a> *= 2;
<a name="l16438"></a>16438       lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a> = <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>,
<a name="l16439"></a>16439                                  (lh-&gt;<a class="code" href="structline__header.html#a1b6f1018fc0d5e55f09b75453c00a9ba">file_names_size</a>
<a name="l16440"></a>16440                                   * sizeof (*lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>)));
<a name="l16441"></a>16441     }
<a name="l16442"></a>16442 
<a name="l16443"></a>16443   fe = &amp;lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>[lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a>++];
<a name="l16444"></a>16444   fe-&gt;<a class="code" href="structline__header_1_1file__entry.html#a97ef624fdc8da05cda47eacc540e428b">name</a> = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l16445"></a>16445   fe-&gt;dir_index = dir_index;
<a name="l16446"></a>16446   fe-&gt;mod_time = mod_time;
<a name="l16447"></a>16447   fe-&gt;length = length;
<a name="l16448"></a>16448   fe-&gt;included_p = 0;
<a name="l16449"></a>16449   fe-&gt;symtab = NULL;
<a name="l16450"></a>16450 }
<a name="l16451"></a>16451 
<a name="l16452"></a>16452 <span class="comment">/* A convenience function to find the proper .debug_line section for a</span>
<a name="l16453"></a>16453 <span class="comment">   CU.  */</span>
<a name="l16454"></a>16454 
<a name="l16455"></a>16455 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *
<a name="l16456"></a><a class="code" href="dwarf2read_8c.html#abc385300bf87f42ea38c160f238e233c">16456</a> <a class="code" href="dwarf2read_8c.html#abc385300bf87f42ea38c160f238e233c">get_debug_line_section</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l16457"></a>16457 {
<a name="l16458"></a>16458   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section;
<a name="l16459"></a>16459 
<a name="l16460"></a>16460   <span class="comment">/* For TUs in DWO files, the DW_AT_stmt_list attribute lives in the</span>
<a name="l16461"></a>16461 <span class="comment">     DWO file.  */</span>
<a name="l16462"></a>16462   <span class="keywordflow">if</span> (cu-&gt;dwo_unit &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l16463"></a>16463     section = &amp;cu-&gt;dwo_unit-&gt;dwo_file-&gt;sections.line;
<a name="l16464"></a>16464   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a>)
<a name="l16465"></a>16465     {
<a name="l16466"></a>16466       <span class="keyword">struct </span><a class="code" href="structdwz__file.html">dwz_file</a> *dwz = <a class="code" href="dwarf2read_8c.html#a926306809098933a820cfda81b19864c">dwarf2_get_dwz_file</a> ();
<a name="l16467"></a>16467 
<a name="l16468"></a>16468       section = &amp;dwz-&gt;<a class="code" href="structdwz__file.html#ae4fcce172e64ed4d7940f70a5e5d6c32">line</a>;
<a name="l16469"></a>16469     }
<a name="l16470"></a>16470   <span class="keywordflow">else</span>
<a name="l16471"></a>16471     section = &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a79ce82df68fb97ec19e6860fdf9c729a">line</a>;
<a name="l16472"></a>16472 
<a name="l16473"></a>16473   <span class="keywordflow">return</span> section;
<a name="l16474"></a>16474 }
<a name="l16475"></a>16475 
<a name="l16476"></a>16476 <span class="comment">/* Read the statement program header starting at OFFSET in</span>
<a name="l16477"></a>16477 <span class="comment">   .debug_line, or .debug_line.dwo.  Return a pointer</span>
<a name="l16478"></a>16478 <span class="comment">   to a struct line_header, allocated using xmalloc.</span>
<a name="l16479"></a>16479 <span class="comment"></span>
<a name="l16480"></a>16480 <span class="comment">   NOTE: the strings in the include directory and file name tables of</span>
<a name="l16481"></a>16481 <span class="comment">   the returned object point into the dwarf line section buffer,</span>
<a name="l16482"></a>16482 <span class="comment">   and must not be freed.  */</span>
<a name="l16483"></a>16483 
<a name="l16484"></a>16484 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structline__header.html">line_header</a> *
<a name="l16485"></a><a class="code" href="dwarf2read_8c.html#af87c579a0baccecf09b54fc18af2dea5">16485</a> <a class="code" href="dwarf2read_8c.html#af87c579a0baccecf09b54fc18af2dea5">dwarf_decode_line_header</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l16486"></a>16486 {
<a name="l16487"></a>16487   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to;
<a name="l16488"></a>16488   <span class="keyword">struct </span><a class="code" href="structline__header.html">line_header</a> *lh;
<a name="l16489"></a>16489   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *line_ptr;
<a name="l16490"></a>16490   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read, offset_size;
<a name="l16491"></a>16491   <span class="keywordtype">int</span> i;
<a name="l16492"></a>16492   <span class="keyword">const</span> <span class="keywordtype">char</span> *cur_dir, *cur_file;
<a name="l16493"></a>16493   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section;
<a name="l16494"></a>16494   bfd *abfd;
<a name="l16495"></a>16495 
<a name="l16496"></a>16496   section = <a class="code" href="dwarf2read_8c.html#abc385300bf87f42ea38c160f238e233c">get_debug_line_section</a> (cu);
<a name="l16497"></a>16497   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (dwarf2_per_objfile-&gt;objfile, section);
<a name="l16498"></a>16498   <span class="keywordflow">if</span> (section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> == NULL)
<a name="l16499"></a>16499     {
<a name="l16500"></a>16500       <span class="keywordflow">if</span> (cu-&gt;dwo_unit &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l16501"></a>16501         <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;missing .debug_line.dwo section&quot;</span>));
<a name="l16502"></a>16502       <span class="keywordflow">else</span>
<a name="l16503"></a>16503         <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;missing .debug_line section&quot;</span>));
<a name="l16504"></a>16504       <span class="keywordflow">return</span> 0;
<a name="l16505"></a>16505     }
<a name="l16506"></a>16506 
<a name="l16507"></a>16507   <span class="comment">/* We can&#39;t do this until we know the section is non-empty.</span>
<a name="l16508"></a>16508 <span class="comment">     Only then do we know we have such a section.  */</span>
<a name="l16509"></a>16509   abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l16510"></a>16510 
<a name="l16511"></a>16511   <span class="comment">/* Make sure that at least there&#39;s room for the total_length field.</span>
<a name="l16512"></a>16512 <span class="comment">     That could be 12 bytes long, but we&#39;re just going to fudge that.  */</span>
<a name="l16513"></a>16513   <span class="keywordflow">if</span> (offset + 4 &gt;= section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>)
<a name="l16514"></a>16514     {
<a name="l16515"></a>16515       <a class="code" href="dwarf2read_8c.html#adcbf7e3dda8c8b0e06a9d4a13f9b0bbc">dwarf2_statement_list_fits_in_line_number_section_complaint</a> ();
<a name="l16516"></a>16516       <span class="keywordflow">return</span> 0;
<a name="l16517"></a>16517     }
<a name="l16518"></a>16518 
<a name="l16519"></a>16519   lh = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (*lh));
<a name="l16520"></a>16520   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (lh, 0, <span class="keyword">sizeof</span> (*lh));
<a name="l16521"></a>16521   back_to = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> ((<a class="code" href="cleanups_8h.html#af70b0906b7aea57e09df4048d060f151">make_cleanup_ftype</a> *) <a class="code" href="dwarf2read_8c.html#a2b16344b24303ef21765208ef32dfe7a">free_line_header</a>,
<a name="l16522"></a>16522                           (<span class="keywordtype">void</span> *) lh);
<a name="l16523"></a>16523 
<a name="l16524"></a>16524   line_ptr = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l16525"></a>16525 
<a name="l16526"></a>16526   <span class="comment">/* Read in the header.  */</span>
<a name="l16527"></a>16527   lh-&gt;total_length =
<a name="l16528"></a>16528     <a class="code" href="dwarf2read_8c.html#a7944620736e702f37e23ffd06e743fab">read_checked_initial_length_and_offset</a> (abfd, line_ptr, &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>,
<a name="l16529"></a>16529                                             &amp;bytes_read, &amp;offset_size);
<a name="l16530"></a>16530   line_ptr += bytes_read;
<a name="l16531"></a>16531   <span class="keywordflow">if</span> (line_ptr + lh-&gt;total_length &gt; (section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>))
<a name="l16532"></a>16532     {
<a name="l16533"></a>16533       <a class="code" href="dwarf2read_8c.html#adcbf7e3dda8c8b0e06a9d4a13f9b0bbc">dwarf2_statement_list_fits_in_line_number_section_complaint</a> ();
<a name="l16534"></a>16534       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l16535"></a>16535       <span class="keywordflow">return</span> 0;
<a name="l16536"></a>16536     }
<a name="l16537"></a>16537   lh-&gt;statement_program_end = line_ptr + lh-&gt;total_length;
<a name="l16538"></a>16538   lh-&gt;version = <a class="code" href="dwarf2read_8c.html#a35663eebf65b4217082f14bc1f782307">read_2_bytes</a> (abfd, line_ptr);
<a name="l16539"></a>16539   line_ptr += 2;
<a name="l16540"></a>16540   lh-&gt;header_length = <a class="code" href="dwarf2read_8c.html#a7d7df1bb27bd8e2cdd3b27bafd16640b">read_offset_1</a> (abfd, line_ptr, offset_size);
<a name="l16541"></a>16541   line_ptr += offset_size;
<a name="l16542"></a>16542   lh-&gt;minimum_instruction_length = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, line_ptr);
<a name="l16543"></a>16543   line_ptr += 1;
<a name="l16544"></a>16544   <span class="keywordflow">if</span> (lh-&gt;version &gt;= 4)
<a name="l16545"></a>16545     {
<a name="l16546"></a>16546       lh-&gt;maximum_ops_per_instruction = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, line_ptr);
<a name="l16547"></a>16547       line_ptr += 1;
<a name="l16548"></a>16548     }
<a name="l16549"></a>16549   <span class="keywordflow">else</span>
<a name="l16550"></a>16550     lh-&gt;maximum_ops_per_instruction = 1;
<a name="l16551"></a>16551 
<a name="l16552"></a>16552   <span class="keywordflow">if</span> (lh-&gt;maximum_ops_per_instruction == 0)
<a name="l16553"></a>16553     {
<a name="l16554"></a>16554       lh-&gt;maximum_ops_per_instruction = 1;
<a name="l16555"></a>16555       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l16556"></a>16556                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;invalid maximum_ops_per_instruction &quot;</span>
<a name="l16557"></a>16557                    <span class="stringliteral">&quot;in `.debug_line&#39; section&quot;</span>));
<a name="l16558"></a>16558     }
<a name="l16559"></a>16559 
<a name="l16560"></a>16560   lh-&gt;default_is_stmt = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, line_ptr);
<a name="l16561"></a>16561   line_ptr += 1;
<a name="l16562"></a>16562   lh-&gt;line_base = <a class="code" href="dwarf2read_8c.html#a29c46d3cfe71a70e5ba65f3cd31c3ad5">read_1_signed_byte</a> (abfd, line_ptr);
<a name="l16563"></a>16563   line_ptr += 1;
<a name="l16564"></a>16564   lh-&gt;line_range = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, line_ptr);
<a name="l16565"></a>16565   line_ptr += 1;
<a name="l16566"></a>16566   lh-&gt;opcode_base = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, line_ptr);
<a name="l16567"></a>16567   line_ptr += 1;
<a name="l16568"></a>16568   lh-&gt;standard_opcode_lengths
<a name="l16569"></a>16569     = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (lh-&gt;opcode_base * sizeof (lh-&gt;standard_opcode_lengths[0]));
<a name="l16570"></a>16570 
<a name="l16571"></a>16571   lh-&gt;standard_opcode_lengths[0] = 1;  <span class="comment">/* This should never be used anyway.  */</span>
<a name="l16572"></a>16572   <span class="keywordflow">for</span> (i = 1; i &lt; lh-&gt;opcode_base; ++i)
<a name="l16573"></a>16573     {
<a name="l16574"></a>16574       lh-&gt;standard_opcode_lengths[i] = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, line_ptr);
<a name="l16575"></a>16575       line_ptr += 1;
<a name="l16576"></a>16576     }
<a name="l16577"></a>16577 
<a name="l16578"></a>16578   <span class="comment">/* Read directory table.  */</span>
<a name="l16579"></a>16579   <span class="keywordflow">while</span> ((cur_dir = <a class="code" href="dwarf2read_8c.html#a5386044c6f74a934dbd3f4a3199cf5be">read_direct_string</a> (abfd, line_ptr, &amp;bytes_read)) != NULL)
<a name="l16580"></a>16580     {
<a name="l16581"></a>16581       line_ptr += bytes_read;
<a name="l16582"></a>16582       <a class="code" href="dwarf2read_8c.html#a62c2cc39f8ae5b270e78665445b534c1">add_include_dir</a> (lh, cur_dir);
<a name="l16583"></a>16583     }
<a name="l16584"></a>16584   line_ptr += bytes_read;
<a name="l16585"></a>16585 
<a name="l16586"></a>16586   <span class="comment">/* Read file name table.  */</span>
<a name="l16587"></a>16587   <span class="keywordflow">while</span> ((cur_file = <a class="code" href="dwarf2read_8c.html#a5386044c6f74a934dbd3f4a3199cf5be">read_direct_string</a> (abfd, line_ptr, &amp;bytes_read)) != NULL)
<a name="l16588"></a>16588     {
<a name="l16589"></a>16589       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dir_index, mod_time, length;
<a name="l16590"></a>16590 
<a name="l16591"></a>16591       line_ptr += bytes_read;
<a name="l16592"></a>16592       dir_index = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, line_ptr, &amp;bytes_read);
<a name="l16593"></a>16593       line_ptr += bytes_read;
<a name="l16594"></a>16594       mod_time = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, line_ptr, &amp;bytes_read);
<a name="l16595"></a>16595       line_ptr += bytes_read;
<a name="l16596"></a>16596       length = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, line_ptr, &amp;bytes_read);
<a name="l16597"></a>16597       line_ptr += bytes_read;
<a name="l16598"></a>16598 
<a name="l16599"></a>16599       <a class="code" href="dwarf2read_8c.html#a28e5a65b29809611a0bfb7c9c0ff213c">add_file_name</a> (lh, cur_file, dir_index, mod_time, length);
<a name="l16600"></a>16600     }
<a name="l16601"></a>16601   line_ptr += bytes_read;
<a name="l16602"></a>16602   lh-&gt;statement_program_start = line_ptr;
<a name="l16603"></a>16603 
<a name="l16604"></a>16604   <span class="keywordflow">if</span> (line_ptr &gt; (section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>))
<a name="l16605"></a>16605     <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l16606"></a>16606                <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;line number info header doesn&#39;t &quot;</span>
<a name="l16607"></a>16607                  <span class="stringliteral">&quot;fit in `.debug_line&#39; section&quot;</span>));
<a name="l16608"></a>16608 
<a name="l16609"></a>16609   <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (back_to);
<a name="l16610"></a>16610   <span class="keywordflow">return</span> lh;
<a name="l16611"></a>16611 }
<a name="l16612"></a>16612 
<a name="l16613"></a>16613 <span class="comment">/* Subroutine of dwarf_decode_lines to simplify it.</span>
<a name="l16614"></a>16614 <span class="comment">   Return the file name of the psymtab for included file FILE_INDEX</span>
<a name="l16615"></a>16615 <span class="comment">   in line header LH of PST.</span>
<a name="l16616"></a>16616 <span class="comment">   COMP_DIR is the compilation directory (DW_AT_comp_dir) or NULL if unknown.</span>
<a name="l16617"></a>16617 <span class="comment">   If space for the result is malloc&#39;d, it will be freed by a cleanup.</span>
<a name="l16618"></a>16618 <span class="comment">   Returns NULL if FILE_INDEX should be ignored, i.e., it is pst-&gt;filename.</span>
<a name="l16619"></a>16619 <span class="comment"></span>
<a name="l16620"></a>16620 <span class="comment">   The function creates dangling cleanup registration.  */</span>
<a name="l16621"></a>16621 
<a name="l16622"></a>16622 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l16623"></a><a class="code" href="dwarf2read_8c.html#a6dbfbf9285152614d654a0e012a06fae">16623</a> <a class="code" href="dwarf2read_8c.html#a6dbfbf9285152614d654a0e012a06fae">psymtab_include_file_name</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structline__header.html">line_header</a> *lh, <span class="keywordtype">int</span> file_index,
<a name="l16624"></a>16624                            <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst,
<a name="l16625"></a>16625                            <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir)
<a name="l16626"></a>16626 {
<a name="l16627"></a>16627   <span class="keyword">const</span> <span class="keyword">struct </span>file_entry fe = lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a> [file_index];
<a name="l16628"></a>16628   <span class="keyword">const</span> <span class="keywordtype">char</span> *include_name = fe.<a class="code" href="structline__header_1_1file__entry.html#a97ef624fdc8da05cda47eacc540e428b">name</a>;
<a name="l16629"></a>16629   <span class="keyword">const</span> <span class="keywordtype">char</span> *include_name_to_compare = include_name;
<a name="l16630"></a>16630   <span class="keyword">const</span> <span class="keywordtype">char</span> *dir_name = NULL;
<a name="l16631"></a>16631   <span class="keyword">const</span> <span class="keywordtype">char</span> *pst_filename;
<a name="l16632"></a>16632   <span class="keywordtype">char</span> *copied_name = NULL;
<a name="l16633"></a>16633   <span class="keywordtype">int</span> file_is_pst;
<a name="l16634"></a>16634 
<a name="l16635"></a>16635   <span class="keywordflow">if</span> (fe.dir_index)
<a name="l16636"></a>16636     dir_name = lh-&gt;<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a>[fe.dir_index - 1];
<a name="l16637"></a>16637 
<a name="l16638"></a>16638   <span class="keywordflow">if</span> (!IS_ABSOLUTE_PATH (include_name)
<a name="l16639"></a>16639       &amp;&amp; (dir_name != NULL || comp_dir != NULL))
<a name="l16640"></a>16640     {
<a name="l16641"></a>16641       <span class="comment">/* Avoid creating a duplicate psymtab for PST.</span>
<a name="l16642"></a>16642 <span class="comment">         We do this by comparing INCLUDE_NAME and PST_FILENAME.</span>
<a name="l16643"></a>16643 <span class="comment">         Before we do the comparison, however, we need to account</span>
<a name="l16644"></a>16644 <span class="comment">         for DIR_NAME and COMP_DIR.</span>
<a name="l16645"></a>16645 <span class="comment">         First prepend dir_name (if non-NULL).  If we still don&#39;t</span>
<a name="l16646"></a>16646 <span class="comment">         have an absolute path prepend comp_dir (if non-NULL).</span>
<a name="l16647"></a>16647 <span class="comment">         However, the directory we record in the include-file&#39;s</span>
<a name="l16648"></a>16648 <span class="comment">         psymtab does not contain COMP_DIR (to match the</span>
<a name="l16649"></a>16649 <span class="comment">         corresponding symtab(s)).</span>
<a name="l16650"></a>16650 <span class="comment"></span>
<a name="l16651"></a>16651 <span class="comment">         Example:</span>
<a name="l16652"></a>16652 <span class="comment"></span>
<a name="l16653"></a>16653 <span class="comment">         bash$ cd /tmp</span>
<a name="l16654"></a>16654 <span class="comment">         bash$ gcc -g ./hello.c</span>
<a name="l16655"></a>16655 <span class="comment">         include_name = &quot;hello.c&quot;</span>
<a name="l16656"></a>16656 <span class="comment">         dir_name = &quot;.&quot;</span>
<a name="l16657"></a>16657 <span class="comment">         DW_AT_comp_dir = comp_dir = &quot;/tmp&quot;</span>
<a name="l16658"></a>16658 <span class="comment">         DW_AT_name = &quot;./hello.c&quot;  */</span>
<a name="l16659"></a>16659 
<a name="l16660"></a>16660       <span class="keywordflow">if</span> (dir_name != NULL)
<a name="l16661"></a>16661         {
<a name="l16662"></a>16662           <span class="keywordtype">char</span> *tem = concat (dir_name, SLASH_STRING,
<a name="l16663"></a>16663                               include_name, (<span class="keywordtype">char</span> *)NULL);
<a name="l16664"></a>16664 
<a name="l16665"></a>16665           <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, tem);
<a name="l16666"></a>16666           include_name = tem;
<a name="l16667"></a>16667           include_name_to_compare = include_name;
<a name="l16668"></a>16668         }
<a name="l16669"></a>16669       <span class="keywordflow">if</span> (!IS_ABSOLUTE_PATH (include_name) &amp;&amp; comp_dir != NULL)
<a name="l16670"></a>16670         {
<a name="l16671"></a>16671           <span class="keywordtype">char</span> *tem = concat (comp_dir, SLASH_STRING,
<a name="l16672"></a>16672                               include_name, (<span class="keywordtype">char</span> *)NULL);
<a name="l16673"></a>16673 
<a name="l16674"></a>16674           <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, tem);
<a name="l16675"></a>16675           include_name_to_compare = tem;
<a name="l16676"></a>16676         }
<a name="l16677"></a>16677     }
<a name="l16678"></a>16678 
<a name="l16679"></a>16679   pst_filename = pst-&gt;<a class="code" href="structpartial__symtab.html#a6ea70ac87d6dbd541967bdd6dacd7321">filename</a>;
<a name="l16680"></a>16680   <span class="keywordflow">if</span> (!IS_ABSOLUTE_PATH (pst_filename) &amp;&amp; pst-&gt;<a class="code" href="structpartial__symtab.html#a4861f775b1cc7a848abdf336238dbb37">dirname</a> != NULL)
<a name="l16681"></a>16681     {
<a name="l16682"></a>16682       copied_name = concat (pst-&gt;<a class="code" href="structpartial__symtab.html#a4861f775b1cc7a848abdf336238dbb37">dirname</a>, SLASH_STRING,
<a name="l16683"></a>16683                             pst_filename, (<span class="keywordtype">char</span> *)NULL);
<a name="l16684"></a>16684       pst_filename = copied_name;
<a name="l16685"></a>16685     }
<a name="l16686"></a>16686 
<a name="l16687"></a>16687   file_is_pst = FILENAME_CMP (include_name_to_compare, pst_filename) == 0;
<a name="l16688"></a>16688 
<a name="l16689"></a>16689   <span class="keywordflow">if</span> (copied_name != NULL)
<a name="l16690"></a>16690     <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (copied_name);
<a name="l16691"></a>16691 
<a name="l16692"></a>16692   <span class="keywordflow">if</span> (file_is_pst)
<a name="l16693"></a>16693     <span class="keywordflow">return</span> NULL;
<a name="l16694"></a>16694   <span class="keywordflow">return</span> include_name;
<a name="l16695"></a>16695 }
<a name="l16696"></a>16696 
<a name="l16697"></a>16697 <span class="comment">/* Ignore this record_line request.  */</span>
<a name="l16698"></a>16698 
<a name="l16699"></a>16699 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l16700"></a><a class="code" href="dwarf2read_8c.html#ae5147ee1dcb570990c2b718a23c96a08">16700</a> <a class="code" href="dwarf2read_8c.html#ae5147ee1dcb570990c2b718a23c96a08">noop_record_line</a> (<span class="keyword">struct</span> <a class="code" href="structsubfile.html">subfile</a> *<a class="code" href="structsubfile.html">subfile</a>, <span class="keywordtype">int</span> <a class="code" href="symtab_8h.html#a41ebd28ef1d7c6ade45642cb6acc1039">line</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc)
<a name="l16701"></a>16701 {
<a name="l16702"></a>16702   <span class="keywordflow">return</span>;
<a name="l16703"></a>16703 }
<a name="l16704"></a>16704 
<a name="l16705"></a>16705 <span class="comment">/* Subroutine of dwarf_decode_lines to simplify it.</span>
<a name="l16706"></a>16706 <span class="comment">   Process the line number information in LH.  */</span>
<a name="l16707"></a>16707 
<a name="l16708"></a>16708 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l16709"></a><a class="code" href="dwarf2read_8c.html#aad3235afa46c65068458e3e7421a9a9a">16709</a> <a class="code" href="dwarf2read_8c.html#aad3235afa46c65068458e3e7421a9a9a">dwarf_decode_lines_1</a> (<span class="keyword">struct</span> <a class="code" href="structline__header.html">line_header</a> *lh, <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir,
<a name="l16710"></a>16710                       <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst)
<a name="l16711"></a>16711 {
<a name="l16712"></a>16712   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *line_ptr, *extended_end;
<a name="l16713"></a>16713   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *line_end;
<a name="l16714"></a>16714   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read, extended_len;
<a name="l16715"></a>16715   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> op_code, extended_op, adj_opcode;
<a name="l16716"></a>16716   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> baseaddr;
<a name="l16717"></a>16717   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l16718"></a>16718   bfd *abfd = objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>;
<a name="l16719"></a>16719   <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l16720"></a>16720   <span class="keyword">const</span> <span class="keywordtype">int</span> decode_for_pst_p = (pst != NULL);
<a name="l16721"></a>16721   <span class="keyword">struct </span><a class="code" href="structsubfile.html">subfile</a> *last_subfile = NULL;
<a name="l16722"></a>16722   void (*p_record_line) (<span class="keyword">struct </span><a class="code" href="structsubfile.html">subfile</a> *<a class="code" href="structsubfile.html">subfile</a>, <span class="keywordtype">int</span> <a class="code" href="symtab_8h.html#a41ebd28ef1d7c6ade45642cb6acc1039">line</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc)
<a name="l16723"></a>16723     = <a class="code" href="buildsym_8c.html#aa27b873635715b9ea33b19508c221891">record_line</a>;
<a name="l16724"></a>16724 
<a name="l16725"></a>16725   baseaddr = <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>, <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l16726"></a>16726 
<a name="l16727"></a>16727   line_ptr = lh-&gt;<a class="code" href="structline__header.html#a213bcc6bc49b3282d163d89ccad32395">statement_program_start</a>;
<a name="l16728"></a>16728   line_end = lh-&gt;<a class="code" href="structline__header.html#a0e8f9a1407b470dd4dd383c6508191a7">statement_program_end</a>;
<a name="l16729"></a>16729 
<a name="l16730"></a>16730   <span class="comment">/* Read the statement sequences until there&#39;s nothing left.  */</span>
<a name="l16731"></a>16731   <span class="keywordflow">while</span> (line_ptr &lt; line_end)
<a name="l16732"></a>16732     {
<a name="l16733"></a>16733       <span class="comment">/* state machine registers  */</span>
<a name="l16734"></a>16734       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address = 0;
<a name="l16735"></a>16735       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> file = 1;
<a name="l16736"></a>16736       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> line = 1;
<a name="l16737"></a>16737       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> column = 0;
<a name="l16738"></a>16738       <span class="keywordtype">int</span> is_stmt = lh-&gt;<a class="code" href="structline__header.html#a8d783ae46e1831d48f71693cbd8f4931">default_is_stmt</a>;
<a name="l16739"></a>16739       <span class="keywordtype">int</span> basic_block = 0;
<a name="l16740"></a>16740       <span class="keywordtype">int</span> end_sequence = 0;
<a name="l16741"></a>16741       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr;
<a name="l16742"></a>16742       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> op_index = 0;
<a name="l16743"></a>16743 
<a name="l16744"></a>16744       <span class="keywordflow">if</span> (!decode_for_pst_p &amp;&amp; lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a> &gt;= file)
<a name="l16745"></a>16745         {
<a name="l16746"></a>16746           <span class="comment">/* Start a subfile for the current file of the state machine.  */</span>
<a name="l16747"></a>16747           <span class="comment">/* lh-&gt;include_dirs and lh-&gt;file_names are 0-based, but the</span>
<a name="l16748"></a>16748 <span class="comment">             directory and file name numbers in the statement program</span>
<a name="l16749"></a>16749 <span class="comment">             are 1-based.  */</span>
<a name="l16750"></a>16750           <span class="keyword">struct </span>file_entry *fe = &amp;lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>[file - 1];
<a name="l16751"></a>16751           <span class="keyword">const</span> <span class="keywordtype">char</span> *dir = NULL;
<a name="l16752"></a>16752 
<a name="l16753"></a>16753           <span class="keywordflow">if</span> (fe-&gt;dir_index)
<a name="l16754"></a>16754             dir = lh-&gt;<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a>[fe-&gt;dir_index - 1];
<a name="l16755"></a>16755 
<a name="l16756"></a>16756           <a class="code" href="dwarf2read_8c.html#ad6fdb87bbae94e6e0f3b4e9f46b15182">dwarf2_start_subfile</a> (fe-&gt;name, dir, comp_dir);
<a name="l16757"></a>16757         }
<a name="l16758"></a>16758 
<a name="l16759"></a>16759       <span class="comment">/* Decode the table.  */</span>
<a name="l16760"></a>16760       <span class="keywordflow">while</span> (!end_sequence)
<a name="l16761"></a>16761         {
<a name="l16762"></a>16762           op_code = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, line_ptr);
<a name="l16763"></a>16763           line_ptr += 1;
<a name="l16764"></a>16764           <span class="keywordflow">if</span> (line_ptr &gt; line_end)
<a name="l16765"></a>16765             {
<a name="l16766"></a>16766               <a class="code" href="dwarf2read_8c.html#aad021e9f4b344a2b623372f88b39fbdf">dwarf2_debug_line_missing_end_sequence_complaint</a> ();
<a name="l16767"></a>16767               <span class="keywordflow">break</span>;
<a name="l16768"></a>16768             }
<a name="l16769"></a>16769 
<a name="l16770"></a>16770           <span class="keywordflow">if</span> (op_code &gt;= lh-&gt;<a class="code" href="structline__header.html#ad2a6411397863aa4d1931feaa00327b6">opcode_base</a>)
<a name="l16771"></a>16771             {
<a name="l16772"></a>16772               <span class="comment">/* Special operand.  */</span>
<a name="l16773"></a>16773               adj_opcode = op_code - lh-&gt;<a class="code" href="structline__header.html#ad2a6411397863aa4d1931feaa00327b6">opcode_base</a>;
<a name="l16774"></a>16774               address += (((op_index + (adj_opcode / lh-&gt;<a class="code" href="structline__header.html#a433918b1f2ecc23cc8116442b2800bfc">line_range</a>))
<a name="l16775"></a>16775                            / lh-&gt;<a class="code" href="structline__header.html#ab11deabba24eabe57960856f3e5a47bb">maximum_ops_per_instruction</a>)
<a name="l16776"></a>16776                           * lh-&gt;<a class="code" href="structline__header.html#a0ded590fbc4ad196cc2ba36ca5963e1a">minimum_instruction_length</a>);
<a name="l16777"></a>16777               op_index = ((op_index + (adj_opcode / lh-&gt;<a class="code" href="structline__header.html#a433918b1f2ecc23cc8116442b2800bfc">line_range</a>))
<a name="l16778"></a>16778                           % lh-&gt;<a class="code" href="structline__header.html#ab11deabba24eabe57960856f3e5a47bb">maximum_ops_per_instruction</a>);
<a name="l16779"></a>16779               line += lh-&gt;<a class="code" href="structline__header.html#a9c2448a272a79bb798d963fae8f5b305">line_base</a> + (adj_opcode % lh-&gt;<a class="code" href="structline__header.html#a433918b1f2ecc23cc8116442b2800bfc">line_range</a>);
<a name="l16780"></a>16780               <span class="keywordflow">if</span> (lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a> &lt; file || file == 0)
<a name="l16781"></a>16781                 <a class="code" href="dwarf2read_8c.html#a9acddb20f4fc03ac6c460af9bd003928">dwarf2_debug_line_missing_file_complaint</a> ();
<a name="l16782"></a>16782               <span class="comment">/* For now we ignore lines not starting on an</span>
<a name="l16783"></a>16783 <span class="comment">                 instruction boundary.  */</span>
<a name="l16784"></a>16784               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (op_index == 0)
<a name="l16785"></a>16785                 {
<a name="l16786"></a>16786                   lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>[file - 1].<a class="code" href="structline__header_1_1file__entry.html#a6a169260c0b31870645999eb38a0c86c">included_p</a> = 1;
<a name="l16787"></a>16787                   <span class="keywordflow">if</span> (!decode_for_pst_p &amp;&amp; is_stmt)
<a name="l16788"></a>16788                     {
<a name="l16789"></a>16789                       <span class="keywordflow">if</span> (last_subfile != <a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>)
<a name="l16790"></a>16790                         {
<a name="l16791"></a>16791                           addr = <a class="code" href="gdbarch_8c.html#abee635dc7cb9e9793c6100971df1a859">gdbarch_addr_bits_remove</a> (gdbarch, address);
<a name="l16792"></a>16792                           <span class="keywordflow">if</span> (last_subfile)
<a name="l16793"></a>16793                             (*p_record_line) (last_subfile, 0, addr);
<a name="l16794"></a>16794                           last_subfile = <a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>;
<a name="l16795"></a>16795                         }
<a name="l16796"></a>16796                       <span class="comment">/* Append row to matrix using current values.  */</span>
<a name="l16797"></a>16797                       addr = <a class="code" href="gdbarch_8c.html#abee635dc7cb9e9793c6100971df1a859">gdbarch_addr_bits_remove</a> (gdbarch, address);
<a name="l16798"></a>16798                       (*p_record_line) (<a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>, <a class="code" href="symtab_8h.html#a41ebd28ef1d7c6ade45642cb6acc1039">line</a>, addr);
<a name="l16799"></a>16799                     }
<a name="l16800"></a>16800                 }
<a name="l16801"></a>16801               basic_block = 0;
<a name="l16802"></a>16802             }
<a name="l16803"></a>16803           <span class="keywordflow">else</span> <span class="keywordflow">switch</span> (op_code)
<a name="l16804"></a>16804             {
<a name="l16805"></a>16805             <span class="keywordflow">case</span> DW_LNS_extended_op:
<a name="l16806"></a>16806               extended_len = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, line_ptr,
<a name="l16807"></a>16807                                                    &amp;bytes_read);
<a name="l16808"></a>16808               line_ptr += bytes_read;
<a name="l16809"></a>16809               extended_end = line_ptr + extended_len;
<a name="l16810"></a>16810               extended_op = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, line_ptr);
<a name="l16811"></a>16811               line_ptr += 1;
<a name="l16812"></a>16812               <span class="keywordflow">switch</span> (extended_op)
<a name="l16813"></a>16813                 {
<a name="l16814"></a>16814                 <span class="keywordflow">case</span> DW_LNE_end_sequence:
<a name="l16815"></a>16815                   p_record_line = <a class="code" href="buildsym_8c.html#aa27b873635715b9ea33b19508c221891">record_line</a>;
<a name="l16816"></a>16816                   end_sequence = 1;
<a name="l16817"></a>16817                   <span class="keywordflow">break</span>;
<a name="l16818"></a>16818                 <span class="keywordflow">case</span> DW_LNE_set_address:
<a name="l16819"></a>16819                   address = <a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">read_address</a> (abfd, line_ptr, cu, &amp;bytes_read);
<a name="l16820"></a>16820 
<a name="l16821"></a>16821                   <span class="keywordflow">if</span> (address == 0 &amp;&amp; !dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ab6b03c3a65fa04f04741158e8aebc895">has_section_at_zero</a>)
<a name="l16822"></a>16822                     {
<a name="l16823"></a>16823                       <span class="comment">/* This line table is for a function which has been</span>
<a name="l16824"></a>16824 <span class="comment">                         GCd by the linker.  Ignore it.  PR gdb/12528 */</span>
<a name="l16825"></a>16825 
<a name="l16826"></a>16826                       <span class="keywordtype">long</span> <a class="code" href="structline__offset.html">line_offset</a>
<a name="l16827"></a>16827                         = line_ptr - <a class="code" href="dwarf2read_8c.html#abc385300bf87f42ea38c160f238e233c">get_debug_line_section</a> (cu)-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a>;
<a name="l16828"></a>16828 
<a name="l16829"></a>16829                       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l16830"></a>16830                                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;.debug_line address at offset 0x%lx is 0 &quot;</span>
<a name="l16831"></a>16831                                    <span class="stringliteral">&quot;[in module %s]&quot;</span>),
<a name="l16832"></a>16832                                  line_offset, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l16833"></a>16833                       p_record_line = <a class="code" href="dwarf2read_8c.html#ae5147ee1dcb570990c2b718a23c96a08">noop_record_line</a>;
<a name="l16834"></a>16834                     }
<a name="l16835"></a>16835 
<a name="l16836"></a>16836                   op_index = 0;
<a name="l16837"></a>16837                   line_ptr += bytes_read;
<a name="l16838"></a>16838                   address += baseaddr;
<a name="l16839"></a>16839                   <span class="keywordflow">break</span>;
<a name="l16840"></a>16840                 <span class="keywordflow">case</span> DW_LNE_define_file:
<a name="l16841"></a>16841                   {
<a name="l16842"></a>16842                     <span class="keyword">const</span> <span class="keywordtype">char</span> *cur_file;
<a name="l16843"></a>16843                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dir_index, mod_time, length;
<a name="l16844"></a>16844 
<a name="l16845"></a>16845                     cur_file = <a class="code" href="dwarf2read_8c.html#a5386044c6f74a934dbd3f4a3199cf5be">read_direct_string</a> (abfd, line_ptr,
<a name="l16846"></a>16846                                                    &amp;bytes_read);
<a name="l16847"></a>16847                     line_ptr += bytes_read;
<a name="l16848"></a>16848                     dir_index =
<a name="l16849"></a>16849                       <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, line_ptr, &amp;bytes_read);
<a name="l16850"></a>16850                     line_ptr += bytes_read;
<a name="l16851"></a>16851                     mod_time =
<a name="l16852"></a>16852                       <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, line_ptr, &amp;bytes_read);
<a name="l16853"></a>16853                     line_ptr += bytes_read;
<a name="l16854"></a>16854                     length =
<a name="l16855"></a>16855                       <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, line_ptr, &amp;bytes_read);
<a name="l16856"></a>16856                     line_ptr += bytes_read;
<a name="l16857"></a>16857                     <a class="code" href="dwarf2read_8c.html#a28e5a65b29809611a0bfb7c9c0ff213c">add_file_name</a> (lh, cur_file, dir_index, mod_time, length);
<a name="l16858"></a>16858                   }
<a name="l16859"></a>16859                   <span class="keywordflow">break</span>;
<a name="l16860"></a>16860                 <span class="keywordflow">case</span> DW_LNE_set_discriminator:
<a name="l16861"></a>16861                   <span class="comment">/* The discriminator is not interesting to the debugger;</span>
<a name="l16862"></a>16862 <span class="comment">                     just ignore it.  */</span>
<a name="l16863"></a>16863                   line_ptr = extended_end;
<a name="l16864"></a>16864                   <span class="keywordflow">break</span>;
<a name="l16865"></a>16865                 <span class="keywordflow">default</span>:
<a name="l16866"></a>16866                   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l16867"></a>16867                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;mangled .debug_line section&quot;</span>));
<a name="l16868"></a>16868                   <span class="keywordflow">return</span>;
<a name="l16869"></a>16869                 }
<a name="l16870"></a>16870               <span class="comment">/* Make sure that we parsed the extended op correctly.  If e.g.</span>
<a name="l16871"></a>16871 <span class="comment">                 we expected a different address size than the producer used,</span>
<a name="l16872"></a>16872 <span class="comment">                 we may have read the wrong number of bytes.  */</span>
<a name="l16873"></a>16873               <span class="keywordflow">if</span> (line_ptr != extended_end)
<a name="l16874"></a>16874                 {
<a name="l16875"></a>16875                   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l16876"></a>16876                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;mangled .debug_line section&quot;</span>));
<a name="l16877"></a>16877                   <span class="keywordflow">return</span>;
<a name="l16878"></a>16878                 }
<a name="l16879"></a>16879               <span class="keywordflow">break</span>;
<a name="l16880"></a>16880             <span class="keywordflow">case</span> DW_LNS_copy:
<a name="l16881"></a>16881               <span class="keywordflow">if</span> (lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a> &lt; file || file == 0)
<a name="l16882"></a>16882                 <a class="code" href="dwarf2read_8c.html#a9acddb20f4fc03ac6c460af9bd003928">dwarf2_debug_line_missing_file_complaint</a> ();
<a name="l16883"></a>16883               <span class="keywordflow">else</span>
<a name="l16884"></a>16884                 {
<a name="l16885"></a>16885                   lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>[file - 1].<a class="code" href="structline__header_1_1file__entry.html#a6a169260c0b31870645999eb38a0c86c">included_p</a> = 1;
<a name="l16886"></a>16886                   <span class="keywordflow">if</span> (!decode_for_pst_p &amp;&amp; is_stmt)
<a name="l16887"></a>16887                     {
<a name="l16888"></a>16888                       <span class="keywordflow">if</span> (last_subfile != <a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>)
<a name="l16889"></a>16889                         {
<a name="l16890"></a>16890                           addr = <a class="code" href="gdbarch_8c.html#abee635dc7cb9e9793c6100971df1a859">gdbarch_addr_bits_remove</a> (gdbarch, address);
<a name="l16891"></a>16891                           <span class="keywordflow">if</span> (last_subfile)
<a name="l16892"></a>16892                             (*p_record_line) (last_subfile, 0, addr);
<a name="l16893"></a>16893                           last_subfile = <a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>;
<a name="l16894"></a>16894                         }
<a name="l16895"></a>16895                       addr = <a class="code" href="gdbarch_8c.html#abee635dc7cb9e9793c6100971df1a859">gdbarch_addr_bits_remove</a> (gdbarch, address);
<a name="l16896"></a>16896                       (*p_record_line) (<a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>, <a class="code" href="symtab_8h.html#a41ebd28ef1d7c6ade45642cb6acc1039">line</a>, addr);
<a name="l16897"></a>16897                     }
<a name="l16898"></a>16898                 }
<a name="l16899"></a>16899               basic_block = 0;
<a name="l16900"></a>16900               <span class="keywordflow">break</span>;
<a name="l16901"></a>16901             <span class="keywordflow">case</span> DW_LNS_advance_pc:
<a name="l16902"></a>16902               {
<a name="l16903"></a>16903                 <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> adjust
<a name="l16904"></a>16904                   = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, line_ptr, &amp;bytes_read);
<a name="l16905"></a>16905 
<a name="l16906"></a>16906                 address += (((op_index + adjust)
<a name="l16907"></a>16907                              / lh-&gt;<a class="code" href="structline__header.html#ab11deabba24eabe57960856f3e5a47bb">maximum_ops_per_instruction</a>)
<a name="l16908"></a>16908                             * lh-&gt;<a class="code" href="structline__header.html#a0ded590fbc4ad196cc2ba36ca5963e1a">minimum_instruction_length</a>);
<a name="l16909"></a>16909                 op_index = ((op_index + adjust)
<a name="l16910"></a>16910                             % lh-&gt;<a class="code" href="structline__header.html#ab11deabba24eabe57960856f3e5a47bb">maximum_ops_per_instruction</a>);
<a name="l16911"></a>16911                 line_ptr += bytes_read;
<a name="l16912"></a>16912               }
<a name="l16913"></a>16913               <span class="keywordflow">break</span>;
<a name="l16914"></a>16914             <span class="keywordflow">case</span> DW_LNS_advance_line:
<a name="l16915"></a>16915               line += <a class="code" href="dwarf2read_8c.html#adfbc149c8807d37b14d0d217da31ada0">read_signed_leb128</a> (abfd, line_ptr, &amp;bytes_read);
<a name="l16916"></a>16916               line_ptr += bytes_read;
<a name="l16917"></a>16917               <span class="keywordflow">break</span>;
<a name="l16918"></a>16918             <span class="keywordflow">case</span> DW_LNS_set_file:
<a name="l16919"></a>16919               {
<a name="l16920"></a>16920                 <span class="comment">/* The arrays lh-&gt;include_dirs and lh-&gt;file_names are</span>
<a name="l16921"></a>16921 <span class="comment">                   0-based, but the directory and file name numbers in</span>
<a name="l16922"></a>16922 <span class="comment">                   the statement program are 1-based.  */</span>
<a name="l16923"></a>16923                 <span class="keyword">struct </span>file_entry *fe;
<a name="l16924"></a>16924                 <span class="keyword">const</span> <span class="keywordtype">char</span> *dir = NULL;
<a name="l16925"></a>16925 
<a name="l16926"></a>16926                 file = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, line_ptr, &amp;bytes_read);
<a name="l16927"></a>16927                 line_ptr += bytes_read;
<a name="l16928"></a>16928                 <span class="keywordflow">if</span> (lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a> &lt; file || file == 0)
<a name="l16929"></a>16929                   <a class="code" href="dwarf2read_8c.html#a9acddb20f4fc03ac6c460af9bd003928">dwarf2_debug_line_missing_file_complaint</a> ();
<a name="l16930"></a>16930                 <span class="keywordflow">else</span>
<a name="l16931"></a>16931                   {
<a name="l16932"></a>16932                     fe = &amp;lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>[file - 1];
<a name="l16933"></a>16933                     <span class="keywordflow">if</span> (fe-&gt;dir_index)
<a name="l16934"></a>16934                       dir = lh-&gt;<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a>[fe-&gt;dir_index - 1];
<a name="l16935"></a>16935                     <span class="keywordflow">if</span> (!decode_for_pst_p)
<a name="l16936"></a>16936                       {
<a name="l16937"></a>16937                         last_subfile = <a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>;
<a name="l16938"></a>16938                         <a class="code" href="dwarf2read_8c.html#ad6fdb87bbae94e6e0f3b4e9f46b15182">dwarf2_start_subfile</a> (fe-&gt;name, dir, comp_dir);
<a name="l16939"></a>16939                       }
<a name="l16940"></a>16940                   }
<a name="l16941"></a>16941               }
<a name="l16942"></a>16942               <span class="keywordflow">break</span>;
<a name="l16943"></a>16943             <span class="keywordflow">case</span> DW_LNS_set_column:
<a name="l16944"></a>16944               column = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, line_ptr, &amp;bytes_read);
<a name="l16945"></a>16945               line_ptr += bytes_read;
<a name="l16946"></a>16946               <span class="keywordflow">break</span>;
<a name="l16947"></a>16947             <span class="keywordflow">case</span> DW_LNS_negate_stmt:
<a name="l16948"></a>16948               is_stmt = (!is_stmt);
<a name="l16949"></a>16949               <span class="keywordflow">break</span>;
<a name="l16950"></a>16950             <span class="keywordflow">case</span> DW_LNS_set_basic_block:
<a name="l16951"></a>16951               basic_block = 1;
<a name="l16952"></a>16952               <span class="keywordflow">break</span>;
<a name="l16953"></a>16953             <span class="comment">/* Add to the address register of the state machine the</span>
<a name="l16954"></a>16954 <span class="comment">               address increment value corresponding to special opcode</span>
<a name="l16955"></a>16955 <span class="comment">               255.  I.e., this value is scaled by the minimum</span>
<a name="l16956"></a>16956 <span class="comment">               instruction length since special opcode 255 would have</span>
<a name="l16957"></a>16957 <span class="comment">               scaled the increment.  */</span>
<a name="l16958"></a>16958             <span class="keywordflow">case</span> DW_LNS_const_add_pc:
<a name="l16959"></a>16959               {
<a name="l16960"></a>16960                 <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> adjust = (255 - lh-&gt;<a class="code" href="structline__header.html#ad2a6411397863aa4d1931feaa00327b6">opcode_base</a>) / lh-&gt;<a class="code" href="structline__header.html#a433918b1f2ecc23cc8116442b2800bfc">line_range</a>;
<a name="l16961"></a>16961 
<a name="l16962"></a>16962                 address += (((op_index + adjust)
<a name="l16963"></a>16963                              / lh-&gt;<a class="code" href="structline__header.html#ab11deabba24eabe57960856f3e5a47bb">maximum_ops_per_instruction</a>)
<a name="l16964"></a>16964                             * lh-&gt;<a class="code" href="structline__header.html#a0ded590fbc4ad196cc2ba36ca5963e1a">minimum_instruction_length</a>);
<a name="l16965"></a>16965                 op_index = ((op_index + adjust)
<a name="l16966"></a>16966                             % lh-&gt;<a class="code" href="structline__header.html#ab11deabba24eabe57960856f3e5a47bb">maximum_ops_per_instruction</a>);
<a name="l16967"></a>16967               }
<a name="l16968"></a>16968               <span class="keywordflow">break</span>;
<a name="l16969"></a>16969             <span class="keywordflow">case</span> DW_LNS_fixed_advance_pc:
<a name="l16970"></a>16970               address += <a class="code" href="dwarf2read_8c.html#a35663eebf65b4217082f14bc1f782307">read_2_bytes</a> (abfd, line_ptr);
<a name="l16971"></a>16971               op_index = 0;
<a name="l16972"></a>16972               line_ptr += 2;
<a name="l16973"></a>16973               <span class="keywordflow">break</span>;
<a name="l16974"></a>16974             <span class="keywordflow">default</span>:
<a name="l16975"></a>16975               {
<a name="l16976"></a>16976                 <span class="comment">/* Unknown standard opcode, ignore it.  */</span>
<a name="l16977"></a>16977                 <span class="keywordtype">int</span> i;
<a name="l16978"></a>16978 
<a name="l16979"></a>16979                 <span class="keywordflow">for</span> (i = 0; i &lt; lh-&gt;<a class="code" href="structline__header.html#a03b9061576badda7a0d72053c713dca8">standard_opcode_lengths</a>[op_code]; i++)
<a name="l16980"></a>16980                   {
<a name="l16981"></a>16981                     (void) <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, line_ptr, &amp;bytes_read);
<a name="l16982"></a>16982                     line_ptr += bytes_read;
<a name="l16983"></a>16983                   }
<a name="l16984"></a>16984               }
<a name="l16985"></a>16985             }
<a name="l16986"></a>16986         }
<a name="l16987"></a>16987       <span class="keywordflow">if</span> (lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a> &lt; file || file == 0)
<a name="l16988"></a>16988         <a class="code" href="dwarf2read_8c.html#a9acddb20f4fc03ac6c460af9bd003928">dwarf2_debug_line_missing_file_complaint</a> ();
<a name="l16989"></a>16989       <span class="keywordflow">else</span>
<a name="l16990"></a>16990         {
<a name="l16991"></a>16991           lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>[file - 1].<a class="code" href="structline__header_1_1file__entry.html#a6a169260c0b31870645999eb38a0c86c">included_p</a> = 1;
<a name="l16992"></a>16992           <span class="keywordflow">if</span> (!decode_for_pst_p)
<a name="l16993"></a>16993             {
<a name="l16994"></a>16994               addr = <a class="code" href="gdbarch_8c.html#abee635dc7cb9e9793c6100971df1a859">gdbarch_addr_bits_remove</a> (gdbarch, address);
<a name="l16995"></a>16995               (*p_record_line) (<a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>, 0, addr);
<a name="l16996"></a>16996             }
<a name="l16997"></a>16997         }
<a name="l16998"></a>16998     }
<a name="l16999"></a>16999 }
<a name="l17000"></a>17000 
<a name="l17001"></a>17001 <span class="comment">/* Decode the Line Number Program (LNP) for the given line_header</span>
<a name="l17002"></a>17002 <span class="comment">   structure and CU.  The actual information extracted and the type</span>
<a name="l17003"></a>17003 <span class="comment">   of structures created from the LNP depends on the value of PST.</span>
<a name="l17004"></a>17004 <span class="comment"></span>
<a name="l17005"></a>17005 <span class="comment">   1. If PST is NULL, then this procedure uses the data from the program</span>
<a name="l17006"></a>17006 <span class="comment">      to create all necessary symbol tables, and their linetables.</span>
<a name="l17007"></a>17007 <span class="comment"></span>
<a name="l17008"></a>17008 <span class="comment">   2. If PST is not NULL, this procedure reads the program to determine</span>
<a name="l17009"></a>17009 <span class="comment">      the list of files included by the unit represented by PST, and</span>
<a name="l17010"></a>17010 <span class="comment">      builds all the associated partial symbol tables.</span>
<a name="l17011"></a>17011 <span class="comment"></span>
<a name="l17012"></a>17012 <span class="comment">   COMP_DIR is the compilation directory (DW_AT_comp_dir) or NULL if unknown.</span>
<a name="l17013"></a>17013 <span class="comment">   It is used for relative paths in the line table.</span>
<a name="l17014"></a>17014 <span class="comment">   NOTE: When processing partial symtabs (pst != NULL),</span>
<a name="l17015"></a>17015 <span class="comment">   comp_dir == pst-&gt;dirname.</span>
<a name="l17016"></a>17016 <span class="comment"></span>
<a name="l17017"></a>17017 <span class="comment">   NOTE: It is important that psymtabs have the same file name (via strcmp)</span>
<a name="l17018"></a>17018 <span class="comment">   as the corresponding symtab.  Since COMP_DIR is not used in the name of the</span>
<a name="l17019"></a>17019 <span class="comment">   symtab we don&#39;t use it in the name of the psymtabs we create.</span>
<a name="l17020"></a>17020 <span class="comment">   E.g. expand_line_sal requires this when finding psymtabs to expand.</span>
<a name="l17021"></a>17021 <span class="comment">   A good testcase for this is mb-inline.exp.  */</span>
<a name="l17022"></a>17022 
<a name="l17023"></a>17023 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l17024"></a><a class="code" href="dwarf2read_8c.html#af810de33caeeaf4969d37ee378ef6e06">17024</a> <a class="code" href="dwarf2read_8c.html#af810de33caeeaf4969d37ee378ef6e06">dwarf_decode_lines</a> (<span class="keyword">struct</span> <a class="code" href="structline__header.html">line_header</a> *lh, <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir,
<a name="l17025"></a>17025                     <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst,
<a name="l17026"></a>17026                     <span class="keywordtype">int</span> want_line_info)
<a name="l17027"></a>17027 {
<a name="l17028"></a>17028   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l17029"></a>17029   <span class="keyword">const</span> <span class="keywordtype">int</span> decode_for_pst_p = (pst != NULL);
<a name="l17030"></a>17030   <span class="keyword">struct </span><a class="code" href="structsubfile.html">subfile</a> *first_subfile = <a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>;
<a name="l17031"></a>17031 
<a name="l17032"></a>17032   <span class="keywordflow">if</span> (want_line_info)
<a name="l17033"></a>17033     <a class="code" href="dwarf2read_8c.html#aad3235afa46c65068458e3e7421a9a9a">dwarf_decode_lines_1</a> (lh, comp_dir, cu, pst);
<a name="l17034"></a>17034 
<a name="l17035"></a>17035   <span class="keywordflow">if</span> (decode_for_pst_p)
<a name="l17036"></a>17036     {
<a name="l17037"></a>17037       <span class="keywordtype">int</span> file_index;
<a name="l17038"></a>17038 
<a name="l17039"></a>17039       <span class="comment">/* Now that we&#39;re done scanning the Line Header Program, we can</span>
<a name="l17040"></a>17040 <span class="comment">         create the psymtab of each included file.  */</span>
<a name="l17041"></a>17041       <span class="keywordflow">for</span> (file_index = 0; file_index &lt; lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a>; file_index++)
<a name="l17042"></a>17042         <span class="keywordflow">if</span> (lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>[file_index].<a class="code" href="structline__header_1_1file__entry.html#a6a169260c0b31870645999eb38a0c86c">included_p</a> == 1)
<a name="l17043"></a>17043           {
<a name="l17044"></a>17044             <span class="keyword">const</span> <span class="keywordtype">char</span> *include_name =
<a name="l17045"></a>17045               <a class="code" href="dwarf2read_8c.html#a6dbfbf9285152614d654a0e012a06fae">psymtab_include_file_name</a> (lh, file_index, pst, comp_dir);
<a name="l17046"></a>17046             <span class="keywordflow">if</span> (include_name != NULL)
<a name="l17047"></a>17047               <a class="code" href="dwarf2read_8c.html#a2c89367081c50c376581cfa9e6ea64cc">dwarf2_create_include_psymtab</a> (include_name, pst, objfile);
<a name="l17048"></a>17048           }
<a name="l17049"></a>17049     }
<a name="l17050"></a>17050   <span class="keywordflow">else</span>
<a name="l17051"></a>17051     {
<a name="l17052"></a>17052       <span class="comment">/* Make sure a symtab is created for every file, even files</span>
<a name="l17053"></a>17053 <span class="comment">         which contain only variables (i.e. no code with associated</span>
<a name="l17054"></a>17054 <span class="comment">         line numbers).  */</span>
<a name="l17055"></a>17055       <span class="keywordtype">int</span> i;
<a name="l17056"></a>17056 
<a name="l17057"></a>17057       <span class="keywordflow">for</span> (i = 0; i &lt; lh-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a>; i++)
<a name="l17058"></a>17058         {
<a name="l17059"></a>17059           <span class="keyword">const</span> <span class="keywordtype">char</span> *dir = NULL;
<a name="l17060"></a>17060           <span class="keyword">struct </span>file_entry *fe;
<a name="l17061"></a>17061 
<a name="l17062"></a>17062           fe = &amp;lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>[i];
<a name="l17063"></a>17063           <span class="keywordflow">if</span> (fe-&gt;dir_index)
<a name="l17064"></a>17064             dir = lh-&gt;<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a>[fe-&gt;dir_index - 1];
<a name="l17065"></a>17065           <a class="code" href="dwarf2read_8c.html#ad6fdb87bbae94e6e0f3b4e9f46b15182">dwarf2_start_subfile</a> (fe-&gt;name, dir, comp_dir);
<a name="l17066"></a>17066 
<a name="l17067"></a>17067           <span class="comment">/* Skip the main file; we don&#39;t need it, and it must be</span>
<a name="l17068"></a>17068 <span class="comment">             allocated last, so that it will show up before the</span>
<a name="l17069"></a>17069 <span class="comment">             non-primary symtabs in the objfile&#39;s symtab list.  */</span>
<a name="l17070"></a>17070           <span class="keywordflow">if</span> (<a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a> == first_subfile)
<a name="l17071"></a>17071             <span class="keywordflow">continue</span>;
<a name="l17072"></a>17072 
<a name="l17073"></a>17073           <span class="keywordflow">if</span> (<a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>-&gt;<a class="code" href="structsubfile.html#ae436710af72b07723aff5356c99f2165">symtab</a> == NULL)
<a name="l17074"></a>17074             <a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>-&gt;<a class="code" href="structsubfile.html#ae436710af72b07723aff5356c99f2165">symtab</a> = <a class="code" href="symfile_8c.html#aafc3cce0320aaa35c9037f78fe662a7b">allocate_symtab</a> (<a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>-&gt;<a class="code" href="structsubfile.html#abeea2b58c088097522289f83a3164d77">name</a>,
<a name="l17075"></a>17075                                                        objfile);
<a name="l17076"></a>17076           fe-&gt;symtab = <a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>-&gt;<a class="code" href="structsubfile.html#ae436710af72b07723aff5356c99f2165">symtab</a>;
<a name="l17077"></a>17077         }
<a name="l17078"></a>17078     }
<a name="l17079"></a>17079 }
<a name="l17080"></a>17080 
<a name="l17081"></a>17081 <span class="comment">/* Start a subfile for DWARF.  FILENAME is the name of the file and</span>
<a name="l17082"></a>17082 <span class="comment">   DIRNAME the name of the source directory which contains FILENAME</span>
<a name="l17083"></a>17083 <span class="comment">   or NULL if not known.  COMP_DIR is the compilation directory for the</span>
<a name="l17084"></a>17084 <span class="comment">   linetable&#39;s compilation unit or NULL if not known.</span>
<a name="l17085"></a>17085 <span class="comment">   This routine tries to keep line numbers from identical absolute and</span>
<a name="l17086"></a>17086 <span class="comment">   relative file names in a common subfile.</span>
<a name="l17087"></a>17087 <span class="comment"></span>
<a name="l17088"></a>17088 <span class="comment">   Using the `list&#39; example from the GDB testsuite, which resides in</span>
<a name="l17089"></a>17089 <span class="comment">   /srcdir and compiling it with Irix6.2 cc in /compdir using a filename</span>
<a name="l17090"></a>17090 <span class="comment">   of /srcdir/list0.c yields the following debugging information for list0.c:</span>
<a name="l17091"></a>17091 <span class="comment"></span>
<a name="l17092"></a>17092 <span class="comment">   DW_AT_name:          /srcdir/list0.c</span>
<a name="l17093"></a>17093 <span class="comment">   DW_AT_comp_dir:              /compdir</span>
<a name="l17094"></a>17094 <span class="comment">   files.files[0].name: list0.h</span>
<a name="l17095"></a>17095 <span class="comment">   files.files[0].dir:  /srcdir</span>
<a name="l17096"></a>17096 <span class="comment">   files.files[1].name: list0.c</span>
<a name="l17097"></a>17097 <span class="comment">   files.files[1].dir:  /srcdir</span>
<a name="l17098"></a>17098 <span class="comment"></span>
<a name="l17099"></a>17099 <span class="comment">   The line number information for list0.c has to end up in a single</span>
<a name="l17100"></a>17100 <span class="comment">   subfile, so that `break /srcdir/list0.c:1&#39; works as expected.</span>
<a name="l17101"></a>17101 <span class="comment">   start_subfile will ensure that this happens provided that we pass the</span>
<a name="l17102"></a>17102 <span class="comment">   concatenation of files.files[1].dir and files.files[1].name as the</span>
<a name="l17103"></a>17103 <span class="comment">   subfile&#39;s name.  */</span>
<a name="l17104"></a>17104 
<a name="l17105"></a>17105 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l17106"></a><a class="code" href="dwarf2read_8c.html#ad6fdb87bbae94e6e0f3b4e9f46b15182">17106</a> <a class="code" href="dwarf2read_8c.html#ad6fdb87bbae94e6e0f3b4e9f46b15182">dwarf2_start_subfile</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *dirname,
<a name="l17107"></a>17107                       <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir)
<a name="l17108"></a>17108 {
<a name="l17109"></a>17109   <span class="keywordtype">char</span> *copy = NULL;
<a name="l17110"></a>17110 
<a name="l17111"></a>17111   <span class="comment">/* While reading the DIEs, we call start_symtab(DW_AT_name, DW_AT_comp_dir).</span>
<a name="l17112"></a>17112 <span class="comment">     `start_symtab&#39; will always pass the contents of DW_AT_comp_dir as</span>
<a name="l17113"></a>17113 <span class="comment">     second argument to start_subfile.  To be consistent, we do the</span>
<a name="l17114"></a>17114 <span class="comment">     same here.  In order not to lose the line information directory,</span>
<a name="l17115"></a>17115 <span class="comment">     we concatenate it to the filename when it makes sense.</span>
<a name="l17116"></a>17116 <span class="comment">     Note that the Dwarf3 standard says (speaking of filenames in line</span>
<a name="l17117"></a>17117 <span class="comment">     information): ``The directory index is ignored for file names</span>
<a name="l17118"></a>17118 <span class="comment">     that represent full path names&#39;&#39;.  Thus ignoring dirname in the</span>
<a name="l17119"></a>17119 <span class="comment">     `else&#39; branch below isn&#39;t an issue.  */</span>
<a name="l17120"></a>17120 
<a name="l17121"></a>17121   <span class="keywordflow">if</span> (!IS_ABSOLUTE_PATH (filename) &amp;&amp; dirname != NULL)
<a name="l17122"></a>17122     {
<a name="l17123"></a>17123       copy = concat (dirname, SLASH_STRING, filename, (<span class="keywordtype">char</span> *)NULL);
<a name="l17124"></a>17124       filename = copy;
<a name="l17125"></a>17125     }
<a name="l17126"></a>17126 
<a name="l17127"></a>17127   <a class="code" href="buildsym_8c.html#af083d85ebd6687be94e62373507696a6">start_subfile</a> (filename, comp_dir);
<a name="l17128"></a>17128 
<a name="l17129"></a>17129   <span class="keywordflow">if</span> (copy != NULL)
<a name="l17130"></a>17130     <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (copy);
<a name="l17131"></a>17131 }
<a name="l17132"></a>17132 
<a name="l17133"></a>17133 <span class="comment">/* Start a symtab for DWARF.</span>
<a name="l17134"></a>17134 <span class="comment">   NAME, COMP_DIR, LOW_PC are passed to start_symtab.  */</span>
<a name="l17135"></a>17135 
<a name="l17136"></a>17136 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l17137"></a><a class="code" href="dwarf2read_8c.html#a6682d90849e89e7ce892ec7d58cf4c9c">17137</a> <a class="code" href="dwarf2read_8c.html#a6682d90849e89e7ce892ec7d58cf4c9c">dwarf2_start_symtab</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l17138"></a>17138                      <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> low_pc)
<a name="l17139"></a>17139 {
<a name="l17140"></a>17140   <a class="code" href="buildsym_8c.html#a999baf4228b297244bfae8bbd78cd578">start_symtab</a> (name, comp_dir, low_pc);
<a name="l17141"></a>17141   <a class="code" href="buildsym_8c.html#a76a92cacc4928e0f51361dd056181de6">record_debugformat</a> (<span class="stringliteral">&quot;DWARF 2&quot;</span>);
<a name="l17142"></a>17142   <a class="code" href="buildsym_8c.html#a92dfe9e504c9853534b1d48f3c42540b">record_producer</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>);
<a name="l17143"></a>17143 
<a name="l17144"></a>17144   <span class="comment">/* We assume that we&#39;re processing GCC output.  */</span>
<a name="l17145"></a>17145   <a class="code" href="buildsym_8h.html#aa15527c54c8936a8b3e872312b772b5f">processing_gcc_compilation</a> = 2;
<a name="l17146"></a>17146 
<a name="l17147"></a>17147   cu-&gt;processing_has_namespace_info = 0;
<a name="l17148"></a>17148 }
<a name="l17149"></a>17149 
<a name="l17150"></a>17150 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l17151"></a><a class="code" href="dwarf2read_8c.html#aa26aaf3478a63412f94425282c0d01ba">17151</a> <a class="code" href="dwarf2read_8c.html#aa26aaf3478a63412f94425282c0d01ba">var_decode_location</a> (<span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym,
<a name="l17152"></a>17152                      <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l17153"></a>17153 {
<a name="l17154"></a>17154   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l17155"></a>17155   <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_header = &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>;
<a name="l17156"></a>17156 
<a name="l17157"></a>17157   <span class="comment">/* NOTE drow/2003-01-30: There used to be a comment and some special</span>
<a name="l17158"></a>17158 <span class="comment">     code here to turn a symbol with DW_AT_external and a</span>
<a name="l17159"></a>17159 <span class="comment">     SYMBOL_VALUE_ADDRESS of 0 into a LOC_UNRESOLVED symbol.  This was</span>
<a name="l17160"></a>17160 <span class="comment">     necessary for platforms (maybe Alpha, certainly PowerPC GNU/Linux</span>
<a name="l17161"></a>17161 <span class="comment">     with some versions of binutils) where shared libraries could have</span>
<a name="l17162"></a>17162 <span class="comment">     relocations against symbols in their debug information - the</span>
<a name="l17163"></a>17163 <span class="comment">     minimal symbol would have the right address, but the debug info</span>
<a name="l17164"></a>17164 <span class="comment">     would not.  It&#39;s no longer necessary, because we will explicitly</span>
<a name="l17165"></a>17165 <span class="comment">     apply relocations when we read in the debug information now.  */</span>
<a name="l17166"></a>17166 
<a name="l17167"></a>17167   <span class="comment">/* A DW_AT_location attribute with no contents indicates that a</span>
<a name="l17168"></a>17168 <span class="comment">     variable has been optimized away.  */</span>
<a name="l17169"></a>17169   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (attr) &amp;&amp; <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;<a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> == 0)
<a name="l17170"></a>17170     {
<a name="l17171"></a>17171       <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3aa4f37f80c900ee253911325c30b8a60f">LOC_OPTIMIZED_OUT</a>;
<a name="l17172"></a>17172       <span class="keywordflow">return</span>;
<a name="l17173"></a>17173     }
<a name="l17174"></a>17174 
<a name="l17175"></a>17175   <span class="comment">/* Handle one degenerate form of location expression specially, to</span>
<a name="l17176"></a>17176 <span class="comment">     preserve GDB&#39;s previous behavior when section offsets are</span>
<a name="l17177"></a>17177 <span class="comment">     specified.  If this is just a DW_OP_addr or DW_OP_GNU_addr_index</span>
<a name="l17178"></a>17178 <span class="comment">     then mark this symbol as LOC_STATIC.  */</span>
<a name="l17179"></a>17179 
<a name="l17180"></a>17180   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (attr)
<a name="l17181"></a>17181       &amp;&amp; ((<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data[0] == DW_OP_addr
<a name="l17182"></a>17182            &amp;&amp; <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;<a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> == 1 + cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>)
<a name="l17183"></a>17183           || (<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data[0] == DW_OP_GNU_addr_index
<a name="l17184"></a>17184               &amp;&amp; (<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;<a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>
<a name="l17185"></a>17185                   == 1 + <a class="code" href="dwarf2read_8c.html#a3826fd18cd7dcc7366b810ea152e5cbd">leb128_size</a> (&amp;<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data[1])))))
<a name="l17186"></a>17186     {
<a name="l17187"></a>17187       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a36fb645a916cd19d79712e75c47b8d03">dummy</a>;
<a name="l17188"></a>17188 
<a name="l17189"></a>17189       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data[0] == DW_OP_addr)
<a name="l17190"></a>17190         <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (sym) =
<a name="l17191"></a>17191           <a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">read_address</a> (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>, <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data + 1, cu, &amp;dummy);
<a name="l17192"></a>17192       <span class="keywordflow">else</span>
<a name="l17193"></a>17193         <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (sym) =
<a name="l17194"></a>17194           <a class="code" href="dwarf2read_8c.html#a62579cbb3d5cf28bac5bff46f3d7ed11">read_addr_index_from_leb128</a> (cu, <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data + 1, &amp;dummy);
<a name="l17195"></a>17195       <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a154b256439f7acd7ec7f6257d5881a0f">LOC_STATIC</a>;
<a name="l17196"></a>17196       <a class="code" href="symtab_8c.html#a569809b8edfbd2e0a6d9bb40295840f0">fixup_symbol_section</a> (sym, objfile);
<a name="l17197"></a>17197       <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (sym) += <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>,
<a name="l17198"></a>17198                                               <a class="code" href="symtab_8h.html#a9e82ed3317c58c4b85104d87e738fada">SYMBOL_SECTION</a> (sym));
<a name="l17199"></a>17199       <span class="keywordflow">return</span>;
<a name="l17200"></a>17200     }
<a name="l17201"></a>17201 
<a name="l17202"></a>17202   <span class="comment">/* NOTE drow/2002-01-30: It might be worthwhile to have a static</span>
<a name="l17203"></a>17203 <span class="comment">     expression evaluator, and use LOC_COMPUTED only when necessary</span>
<a name="l17204"></a>17204 <span class="comment">     (i.e. when the value of a register or memory location is</span>
<a name="l17205"></a>17205 <span class="comment">     referenced, or a thread-local block, etc.).  Then again, it might</span>
<a name="l17206"></a>17206 <span class="comment">     not be worthwhile.  I&#39;m assuming that it isn&#39;t unless performance</span>
<a name="l17207"></a>17207 <span class="comment">     or memory numbers show me otherwise.  */</span>
<a name="l17208"></a>17208 
<a name="l17209"></a>17209   <a class="code" href="dwarf2read_8c.html#a097117b0b695bca7ad085fee973f5bd1">dwarf2_symbol_mark_computed</a> (attr, sym, cu, 0);
<a name="l17210"></a>17210 
<a name="l17211"></a>17211   <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a9d6910f7fd67567d273e8ee619e0ef4e">SYMBOL_COMPUTED_OPS</a> (sym)-&gt;location_has_loclist)
<a name="l17212"></a>17212     cu-&gt;has_loclist = 1;
<a name="l17213"></a>17213 }
<a name="l17214"></a>17214 
<a name="l17215"></a>17215 <span class="comment">/* Given a pointer to a DWARF information entry, figure out if we need</span>
<a name="l17216"></a>17216 <span class="comment">   to make a symbol table entry for it, and if so, create a new entry</span>
<a name="l17217"></a>17217 <span class="comment">   and return a pointer to it.</span>
<a name="l17218"></a>17218 <span class="comment">   If TYPE is NULL, determine symbol type from the die, otherwise</span>
<a name="l17219"></a>17219 <span class="comment">   used the passed type.</span>
<a name="l17220"></a>17220 <span class="comment">   If SPACE is not NULL, use it to hold the new symbol.  If it is</span>
<a name="l17221"></a>17221 <span class="comment">   NULL, allocate a new symbol on the objfile&#39;s obstack.  */</span>
<a name="l17222"></a>17222 
<a name="l17223"></a>17223 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *
<a name="l17224"></a><a class="code" href="dwarf2read_8c.html#a3fc581e6a60a1d1195917cf292c45234">17224</a> <a class="code" href="dwarf2read_8c.html#a3fc581e6a60a1d1195917cf292c45234">new_symbol_full</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l17225"></a>17225                  <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *space)
<a name="l17226"></a>17226 {
<a name="l17227"></a>17227   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l17228"></a>17228   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym = NULL;
<a name="l17229"></a>17229   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l17230"></a>17230   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr = NULL;
<a name="l17231"></a>17231   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr2 = NULL;
<a name="l17232"></a>17232   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> baseaddr;
<a name="l17233"></a>17233   <span class="keyword">struct </span><a class="code" href="structpending.html">pending</a> **list_to_add = NULL;
<a name="l17234"></a>17234 
<a name="l17235"></a>17235   <span class="keywordtype">int</span> inlined_func = (die-&gt;tag == DW_TAG_inlined_subroutine);
<a name="l17236"></a>17236 
<a name="l17237"></a>17237   baseaddr = <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>, <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l17238"></a>17238 
<a name="l17239"></a>17239   name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l17240"></a>17240   <span class="keywordflow">if</span> (name)
<a name="l17241"></a>17241     {
<a name="l17242"></a>17242       <span class="keyword">const</span> <span class="keywordtype">char</span> *linkagename;
<a name="l17243"></a>17243       <span class="keywordtype">int</span> suppress_add = 0;
<a name="l17244"></a>17244 
<a name="l17245"></a>17245       <span class="keywordflow">if</span> (space)
<a name="l17246"></a>17246         sym = space;
<a name="l17247"></a>17247       <span class="keywordflow">else</span>
<a name="l17248"></a>17248         sym = <a class="code" href="symtab_8c.html#a6a7a23ba37378ec001ecd461c5137b83">allocate_symbol</a> (objfile);
<a name="l17249"></a>17249       <a class="code" href="objfiles_8h.html#abdcf99cd4c458e281e591cbce3fa627c">OBJSTAT</a> (objfile, n_syms++);
<a name="l17250"></a>17250 
<a name="l17251"></a>17251       <span class="comment">/* Cache this symbol&#39;s name and the name&#39;s demangled form (if any).  */</span>
<a name="l17252"></a>17252       <a class="code" href="symtab_8h.html#add78e67f78de1edd9f8aa220f11bfd89">SYMBOL_SET_LANGUAGE</a> (sym, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>, &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>);
<a name="l17253"></a>17253       linkagename = <a class="code" href="dwarf2read_8c.html#a94813a9fc414b7ba920cdcee76b34d36">dwarf2_physname</a> (name, die, cu);
<a name="l17254"></a>17254       <a class="code" href="symtab_8h.html#a1f31078ca0e1d9517eb48e71fe7d53f9">SYMBOL_SET_NAMES</a> (sym, linkagename, strlen (linkagename), 0, objfile);
<a name="l17255"></a>17255 
<a name="l17256"></a>17256       <span class="comment">/* Fortran does not have mangling standard and the mangling does differ</span>
<a name="l17257"></a>17257 <span class="comment">         between gfortran, iFort etc.  */</span>
<a name="l17258"></a>17258       <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>
<a name="l17259"></a>17259           &amp;&amp; <a class="code" href="symtab_8c.html#a418fc7597f40c930882c39c0cec23017">symbol_get_demangled_name</a> (&amp;(sym-&gt;<a class="code" href="structsymbol.html#a324e2db145c0615116db355341f7b94c">ginfo</a>)) == NULL)
<a name="l17260"></a>17260         <a class="code" href="symtab_8c.html#af12dd1e96c9e2c15313900e4d2c3f14d">symbol_set_demangled_name</a> (&amp;(sym-&gt;<a class="code" href="structsymbol.html#a324e2db145c0615116db355341f7b94c">ginfo</a>),
<a name="l17261"></a>17261                                    <a class="code" href="dwarf2read_8c.html#a01de8f373799ebb39da7b5758619ec4c">dwarf2_full_name</a> (name, die, cu),
<a name="l17262"></a>17262                                    NULL);
<a name="l17263"></a>17263 
<a name="l17264"></a>17264       <span class="comment">/* Default assumptions.</span>
<a name="l17265"></a>17265 <span class="comment">         Use the passed type or decode it from the die.  */</span>
<a name="l17266"></a>17266       <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym) = <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>;
<a name="l17267"></a>17267       <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3aa4f37f80c900ee253911325c30b8a60f">LOC_OPTIMIZED_OUT</a>;
<a name="l17268"></a>17268       <span class="keywordflow">if</span> (type != NULL)
<a name="l17269"></a>17269         <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym) = <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l17270"></a>17270       <span class="keywordflow">else</span>
<a name="l17271"></a>17271         <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym) = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l17272"></a>17272       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die,
<a name="l17273"></a>17273                           inlined_func ? DW_AT_call_line : DW_AT_decl_line,
<a name="l17274"></a>17274                           cu);
<a name="l17275"></a>17275       <span class="keywordflow">if</span> (attr)
<a name="l17276"></a>17276         {
<a name="l17277"></a>17277           <a class="code" href="symtab_8h.html#aaaa694c80f2e32770027d7561a171a55">SYMBOL_LINE</a> (sym) = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l17278"></a>17278         }
<a name="l17279"></a>17279 
<a name="l17280"></a>17280       attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die,
<a name="l17281"></a>17281                           inlined_func ? DW_AT_call_file : DW_AT_decl_file,
<a name="l17282"></a>17282                           cu);
<a name="l17283"></a>17283       <span class="keywordflow">if</span> (attr)
<a name="l17284"></a>17284         {
<a name="l17285"></a>17285           <span class="keywordtype">int</span> file_index = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l17286"></a>17286 
<a name="l17287"></a>17287           <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a94864e6f22ffa7350c883da402931b99">line_header</a> == NULL
<a name="l17288"></a>17288               || file_index &gt; cu-&gt;<a class="code" href="structdwarf2__cu.html#a94864e6f22ffa7350c883da402931b99">line_header</a>-&gt;<a class="code" href="structline__header.html#a0fd5d9a946339cfe3665ae0a73088d67">num_file_names</a>)
<a name="l17289"></a>17289             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l17290"></a>17290                        <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;file index out of range&quot;</span>));
<a name="l17291"></a>17291           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (file_index &gt; 0)
<a name="l17292"></a>17292             {
<a name="l17293"></a>17293               <span class="keyword">struct </span>file_entry *fe;
<a name="l17294"></a>17294 
<a name="l17295"></a>17295               fe = &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#a94864e6f22ffa7350c883da402931b99">line_header</a>-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>[file_index - 1];
<a name="l17296"></a>17296               <a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (sym) = fe-&gt;symtab;
<a name="l17297"></a>17297             }
<a name="l17298"></a>17298         }
<a name="l17299"></a>17299 
<a name="l17300"></a>17300       <span class="keywordflow">switch</span> (die-&gt;tag)
<a name="l17301"></a>17301         {
<a name="l17302"></a>17302         <span class="keywordflow">case</span> DW_TAG_label:
<a name="l17303"></a>17303           attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_low_pc, cu);
<a name="l17304"></a>17304           <span class="keywordflow">if</span> (attr)
<a name="l17305"></a>17305             {
<a name="l17306"></a>17306               <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (sym) = <a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (attr) + baseaddr;
<a name="l17307"></a>17307             }
<a name="l17308"></a>17308           <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym) = <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#ad83f60998b933fb4fec11e38ba67dee5">builtin_core_addr</a>;
<a name="l17309"></a>17309           <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym) = <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa56127af42926055244b2318cbdbc8413">LABEL_DOMAIN</a>;
<a name="l17310"></a>17310           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a246b44ddd9acee8dac2a7d9d2c5d7c6e">LOC_LABEL</a>;
<a name="l17311"></a>17311           <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>);
<a name="l17312"></a>17312           <span class="keywordflow">break</span>;
<a name="l17313"></a>17313         <span class="keywordflow">case</span> DW_TAG_subprogram:
<a name="l17314"></a>17314           <span class="comment">/* SYMBOL_BLOCK_VALUE (sym) will be filled in later by</span>
<a name="l17315"></a>17315 <span class="comment">             finish_block.  */</span>
<a name="l17316"></a>17316           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>;
<a name="l17317"></a>17317           attr2 = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_external, cu);
<a name="l17318"></a>17318           <span class="keywordflow">if</span> ((attr2 &amp;&amp; (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr2) != 0))
<a name="l17319"></a>17319               || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l17320"></a>17320             {
<a name="l17321"></a>17321               <span class="comment">/* Subprograms marked external are stored as a global symbol.</span>
<a name="l17322"></a>17322 <span class="comment">                 Ada subprograms, whether marked external or not, are always</span>
<a name="l17323"></a>17323 <span class="comment">                 stored as a global symbol, because we want to be able to</span>
<a name="l17324"></a>17324 <span class="comment">                 access them globally.  For instance, we want to be able</span>
<a name="l17325"></a>17325 <span class="comment">                 to break on a nested subprogram without having to</span>
<a name="l17326"></a>17326 <span class="comment">                 specify the context.  */</span>
<a name="l17327"></a>17327               list_to_add = &amp;<a class="code" href="buildsym_8h.html#a759a37cb08a814d2400a8241ce11387d">global_symbols</a>;
<a name="l17328"></a>17328             }
<a name="l17329"></a>17329           <span class="keywordflow">else</span>
<a name="l17330"></a>17330             {
<a name="l17331"></a>17331               list_to_add = cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>;
<a name="l17332"></a>17332             }
<a name="l17333"></a>17333           <span class="keywordflow">break</span>;
<a name="l17334"></a>17334         <span class="keywordflow">case</span> DW_TAG_inlined_subroutine:
<a name="l17335"></a>17335           <span class="comment">/* SYMBOL_BLOCK_VALUE (sym) will be filled in later by</span>
<a name="l17336"></a>17336 <span class="comment">             finish_block.  */</span>
<a name="l17337"></a>17337           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>;
<a name="l17338"></a>17338           <a class="code" href="symtab_8h.html#ad695f7fd9589586be6188d9cbc0efda6">SYMBOL_INLINED</a> (sym) = 1;
<a name="l17339"></a>17339           list_to_add = cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>;
<a name="l17340"></a>17340           <span class="keywordflow">break</span>;
<a name="l17341"></a>17341         <span class="keywordflow">case</span> DW_TAG_template_value_param:
<a name="l17342"></a>17342           suppress_add = 1;
<a name="l17343"></a>17343           <span class="comment">/* Fall through.  */</span>
<a name="l17344"></a>17344         <span class="keywordflow">case</span> DW_TAG_constant:
<a name="l17345"></a>17345         <span class="keywordflow">case</span> DW_TAG_variable:
<a name="l17346"></a>17346         <span class="keywordflow">case</span> DW_TAG_member:
<a name="l17347"></a>17347           <span class="comment">/* Compilation with minimal debug info may result in</span>
<a name="l17348"></a>17348 <span class="comment">             variables with missing type entries.  Change the</span>
<a name="l17349"></a>17349 <span class="comment">             misleading `void&#39; type to something sensible.  */</span>
<a name="l17350"></a>17350           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>)
<a name="l17351"></a>17351             <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym)
<a name="l17352"></a>17352               = <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#af2516f8f1d7556b0bc245154c635fa79">nodebug_data_symbol</a>;
<a name="l17353"></a>17353 
<a name="l17354"></a>17354           attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_const_value, cu);
<a name="l17355"></a>17355           <span class="comment">/* In the case of DW_TAG_member, we should only be called for</span>
<a name="l17356"></a>17356 <span class="comment">             static const members.  */</span>
<a name="l17357"></a>17357           <span class="keywordflow">if</span> (die-&gt;tag == DW_TAG_member)
<a name="l17358"></a>17358             {
<a name="l17359"></a>17359               <span class="comment">/* dwarf2_add_field uses die_is_declaration,</span>
<a name="l17360"></a>17360 <span class="comment">                 so we do the same.  */</span>
<a name="l17361"></a>17361               <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="dwarf2read_8c.html#aa9ca23caab102417f39b86b7b2716588">die_is_declaration</a> (die, cu));
<a name="l17362"></a>17362               <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (attr);
<a name="l17363"></a>17363             }
<a name="l17364"></a>17364           <span class="keywordflow">if</span> (attr)
<a name="l17365"></a>17365             {
<a name="l17366"></a>17366               <a class="code" href="dwarf2read_8c.html#a87cdf01457f983687ddcb8f7a377b581">dwarf2_const_value</a> (attr, sym, cu);
<a name="l17367"></a>17367               attr2 = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_external, cu);
<a name="l17368"></a>17368               <span class="keywordflow">if</span> (!suppress_add)
<a name="l17369"></a>17369                 {
<a name="l17370"></a>17370                   <span class="keywordflow">if</span> (attr2 &amp;&amp; (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr2) != 0))
<a name="l17371"></a>17371                     list_to_add = &amp;<a class="code" href="buildsym_8h.html#a759a37cb08a814d2400a8241ce11387d">global_symbols</a>;
<a name="l17372"></a>17372                   <span class="keywordflow">else</span>
<a name="l17373"></a>17373                     list_to_add = cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>;
<a name="l17374"></a>17374                 }
<a name="l17375"></a>17375               <span class="keywordflow">break</span>;
<a name="l17376"></a>17376             }
<a name="l17377"></a>17377           attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_location, cu);
<a name="l17378"></a>17378           <span class="keywordflow">if</span> (attr)
<a name="l17379"></a>17379             {
<a name="l17380"></a>17380               <a class="code" href="dwarf2read_8c.html#aa26aaf3478a63412f94425282c0d01ba">var_decode_location</a> (attr, sym, cu);
<a name="l17381"></a>17381               attr2 = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_external, cu);
<a name="l17382"></a>17382 
<a name="l17383"></a>17383               <span class="comment">/* Fortran explicitly imports any global symbols to the local</span>
<a name="l17384"></a>17384 <span class="comment">                 scope by DW_TAG_common_block.  */</span>
<a name="l17385"></a>17385               <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a> &amp;&amp; die-&gt;parent
<a name="l17386"></a>17386                   &amp;&amp; die-&gt;parent-&gt;tag == DW_TAG_common_block)
<a name="l17387"></a>17387                 attr2 = NULL;
<a name="l17388"></a>17388 
<a name="l17389"></a>17389               <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a154b256439f7acd7ec7f6257d5881a0f">LOC_STATIC</a>
<a name="l17390"></a>17390                   &amp;&amp; <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (sym) == 0
<a name="l17391"></a>17391                   &amp;&amp; !dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ab6b03c3a65fa04f04741158e8aebc895">has_section_at_zero</a>)
<a name="l17392"></a>17392                 {
<a name="l17393"></a>17393                   <span class="comment">/* When a static variable is eliminated by the linker,</span>
<a name="l17394"></a>17394 <span class="comment">                     the corresponding debug information is not stripped</span>
<a name="l17395"></a>17395 <span class="comment">                     out, but the variable address is set to null;</span>
<a name="l17396"></a>17396 <span class="comment">                     do not add such variables into symbol table.  */</span>
<a name="l17397"></a>17397                 }
<a name="l17398"></a>17398               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attr2 &amp;&amp; (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr2) != 0))
<a name="l17399"></a>17399                 {
<a name="l17400"></a>17400                   <span class="comment">/* Workaround gfortran PR debug/40040 - it uses</span>
<a name="l17401"></a>17401 <span class="comment">                     DW_AT_location for variables in -fPIC libraries which may</span>
<a name="l17402"></a>17402 <span class="comment">                     get overriden by other libraries/executable and get</span>
<a name="l17403"></a>17403 <span class="comment">                     a different address.  Resolve it by the minimal symbol</span>
<a name="l17404"></a>17404 <span class="comment">                     which may come from inferior&#39;s executable using copy</span>
<a name="l17405"></a>17405 <span class="comment">                     relocation.  Make this workaround only for gfortran as for</span>
<a name="l17406"></a>17406 <span class="comment">                     other compilers GDB cannot guess the minimal symbol</span>
<a name="l17407"></a>17407 <span class="comment">                     Fortran mangling kind.  */</span>
<a name="l17408"></a>17408                   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a> &amp;&amp; die-&gt;parent
<a name="l17409"></a>17409                       &amp;&amp; die-&gt;parent-&gt;tag == DW_TAG_module
<a name="l17410"></a>17410                       &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>
<a name="l17411"></a>17411                       &amp;&amp; strncmp (cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a>, <span class="stringliteral">&quot;GNU Fortran &quot;</span>, 12) == 0)
<a name="l17412"></a>17412                     <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a3d61e7ad56c95328fba05416abc73f7a">LOC_UNRESOLVED</a>;
<a name="l17413"></a>17413 
<a name="l17414"></a>17414                   <span class="comment">/* A variable with DW_AT_external is never static,</span>
<a name="l17415"></a>17415 <span class="comment">                     but it may be block-scoped.  */</span>
<a name="l17416"></a>17416                   list_to_add = (cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a> == &amp;<a class="code" href="buildsym_8h.html#a2d83ed7f7eeffeffeb2e00320573fd0d">file_symbols</a>
<a name="l17417"></a>17417                                  ? &amp;<a class="code" href="buildsym_8h.html#a759a37cb08a814d2400a8241ce11387d">global_symbols</a> : cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>);
<a name="l17418"></a>17418                 }
<a name="l17419"></a>17419               <span class="keywordflow">else</span>
<a name="l17420"></a>17420                 list_to_add = cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>;
<a name="l17421"></a>17421             }
<a name="l17422"></a>17422           <span class="keywordflow">else</span>
<a name="l17423"></a>17423             {
<a name="l17424"></a>17424               <span class="comment">/* We do not know the address of this symbol.</span>
<a name="l17425"></a>17425 <span class="comment">                 If it is an external symbol and we have type information</span>
<a name="l17426"></a>17426 <span class="comment">                 for it, enter the symbol as a LOC_UNRESOLVED symbol.</span>
<a name="l17427"></a>17427 <span class="comment">                 The address of the variable will then be determined from</span>
<a name="l17428"></a>17428 <span class="comment">                 the minimal symbol table whenever the variable is</span>
<a name="l17429"></a>17429 <span class="comment">                 referenced.  */</span>
<a name="l17430"></a>17430               attr2 = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_external, cu);
<a name="l17431"></a>17431 
<a name="l17432"></a>17432               <span class="comment">/* Fortran explicitly imports any global symbols to the local</span>
<a name="l17433"></a>17433 <span class="comment">                 scope by DW_TAG_common_block.  */</span>
<a name="l17434"></a>17434               <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a> &amp;&amp; die-&gt;parent
<a name="l17435"></a>17435                   &amp;&amp; die-&gt;parent-&gt;tag == DW_TAG_common_block)
<a name="l17436"></a>17436                 {
<a name="l17437"></a>17437                   <span class="comment">/* SYMBOL_CLASS doesn&#39;t matter here because</span>
<a name="l17438"></a>17438 <span class="comment">                     read_common_block is going to reset it.  */</span>
<a name="l17439"></a>17439                   <span class="keywordflow">if</span> (!suppress_add)
<a name="l17440"></a>17440                     list_to_add = cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>;
<a name="l17441"></a>17441                 }
<a name="l17442"></a>17442               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attr2 &amp;&amp; (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr2) != 0)
<a name="l17443"></a>17443                        &amp;&amp; <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_type, cu) != NULL)
<a name="l17444"></a>17444                 {
<a name="l17445"></a>17445                   <span class="comment">/* A variable with DW_AT_external is never static, but it</span>
<a name="l17446"></a>17446 <span class="comment">                     may be block-scoped.  */</span>
<a name="l17447"></a>17447                   list_to_add = (cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a> == &amp;<a class="code" href="buildsym_8h.html#a2d83ed7f7eeffeffeb2e00320573fd0d">file_symbols</a>
<a name="l17448"></a>17448                                  ? &amp;<a class="code" href="buildsym_8h.html#a759a37cb08a814d2400a8241ce11387d">global_symbols</a> : cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>);
<a name="l17449"></a>17449 
<a name="l17450"></a>17450                   <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a3d61e7ad56c95328fba05416abc73f7a">LOC_UNRESOLVED</a>;
<a name="l17451"></a>17451                 }
<a name="l17452"></a>17452               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="dwarf2read_8c.html#aa9ca23caab102417f39b86b7b2716588">die_is_declaration</a> (die, cu))
<a name="l17453"></a>17453                 {
<a name="l17454"></a>17454                   <span class="comment">/* Use the default LOC_OPTIMIZED_OUT class.  */</span>
<a name="l17455"></a>17455                   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3aa4f37f80c900ee253911325c30b8a60f">LOC_OPTIMIZED_OUT</a>);
<a name="l17456"></a>17456                   <span class="keywordflow">if</span> (!suppress_add)
<a name="l17457"></a>17457                     list_to_add = cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>;
<a name="l17458"></a>17458                 }
<a name="l17459"></a>17459             }
<a name="l17460"></a>17460           <span class="keywordflow">break</span>;
<a name="l17461"></a>17461         <span class="keywordflow">case</span> DW_TAG_formal_parameter:
<a name="l17462"></a>17462           <span class="comment">/* If we are inside a function, mark this as an argument.  If</span>
<a name="l17463"></a>17463 <span class="comment">             not, we might be looking at an argument to an inlined function</span>
<a name="l17464"></a>17464 <span class="comment">             when we do not have enough information to show inlined frames;</span>
<a name="l17465"></a>17465 <span class="comment">             pretend it&#39;s a local variable in that case so that the user can</span>
<a name="l17466"></a>17466 <span class="comment">             still see it.  */</span>
<a name="l17467"></a>17467           <span class="keywordflow">if</span> (<a class="code" href="buildsym_8h.html#ae0be96b381252ebd96109ede811ed7c4">context_stack_depth</a> &gt; 0
<a name="l17468"></a>17468               &amp;&amp; <a class="code" href="structcontext__stack.html">context_stack</a>[<a class="code" href="buildsym_8h.html#ae0be96b381252ebd96109ede811ed7c4">context_stack_depth</a> - 1].name != NULL)
<a name="l17469"></a>17469             <a class="code" href="symtab_8h.html#ab3de6f2d8c380d3ca8bef520b1b4dfb9">SYMBOL_IS_ARGUMENT</a> (sym) = 1;
<a name="l17470"></a>17470           attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_location, cu);
<a name="l17471"></a>17471           <span class="keywordflow">if</span> (attr)
<a name="l17472"></a>17472             {
<a name="l17473"></a>17473               <a class="code" href="dwarf2read_8c.html#aa26aaf3478a63412f94425282c0d01ba">var_decode_location</a> (attr, sym, cu);
<a name="l17474"></a>17474             }
<a name="l17475"></a>17475           attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_const_value, cu);
<a name="l17476"></a>17476           <span class="keywordflow">if</span> (attr)
<a name="l17477"></a>17477             {
<a name="l17478"></a>17478               <a class="code" href="dwarf2read_8c.html#a87cdf01457f983687ddcb8f7a377b581">dwarf2_const_value</a> (attr, sym, cu);
<a name="l17479"></a>17479             }
<a name="l17480"></a>17480 
<a name="l17481"></a>17481           list_to_add = cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>;
<a name="l17482"></a>17482           <span class="keywordflow">break</span>;
<a name="l17483"></a>17483         <span class="keywordflow">case</span> DW_TAG_unspecified_parameters:
<a name="l17484"></a>17484           <span class="comment">/* From varargs functions; gdb doesn&#39;t seem to have any</span>
<a name="l17485"></a>17485 <span class="comment">             interest in this information, so just ignore it for now.</span>
<a name="l17486"></a>17486 <span class="comment">             (FIXME?) */</span>
<a name="l17487"></a>17487           <span class="keywordflow">break</span>;
<a name="l17488"></a>17488         <span class="keywordflow">case</span> DW_TAG_template_type_param:
<a name="l17489"></a>17489           suppress_add = 1;
<a name="l17490"></a>17490           <span class="comment">/* Fall through.  */</span>
<a name="l17491"></a>17491         <span class="keywordflow">case</span> DW_TAG_class_type:
<a name="l17492"></a>17492         <span class="keywordflow">case</span> DW_TAG_interface_type:
<a name="l17493"></a>17493         <span class="keywordflow">case</span> DW_TAG_structure_type:
<a name="l17494"></a>17494         <span class="keywordflow">case</span> DW_TAG_union_type:
<a name="l17495"></a>17495         <span class="keywordflow">case</span> DW_TAG_set_type:
<a name="l17496"></a>17496         <span class="keywordflow">case</span> DW_TAG_enumeration_type:
<a name="l17497"></a>17497           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>;
<a name="l17498"></a>17498           <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym) = <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa1f05a16e681efd2e892974878c353f11">STRUCT_DOMAIN</a>;
<a name="l17499"></a>17499 
<a name="l17500"></a>17500           {
<a name="l17501"></a>17501             <span class="comment">/* NOTE: carlton/2003-11-10: C++ and Java class symbols shouldn&#39;t</span>
<a name="l17502"></a>17502 <span class="comment">               really ever be static objects: otherwise, if you try</span>
<a name="l17503"></a>17503 <span class="comment">               to, say, break of a class&#39;s method and you&#39;re in a file</span>
<a name="l17504"></a>17504 <span class="comment">               which doesn&#39;t mention that class, it won&#39;t work unless</span>
<a name="l17505"></a>17505 <span class="comment">               the check for all static symbols in lookup_symbol_aux</span>
<a name="l17506"></a>17506 <span class="comment">               saves you.  See the OtherFileClass tests in</span>
<a name="l17507"></a>17507 <span class="comment">               gdb.c++/namespace.exp.  */</span>
<a name="l17508"></a>17508 
<a name="l17509"></a>17509             <span class="keywordflow">if</span> (!suppress_add)
<a name="l17510"></a>17510               {
<a name="l17511"></a>17511                 list_to_add = (cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a> == &amp;<a class="code" href="buildsym_8h.html#a2d83ed7f7eeffeffeb2e00320573fd0d">file_symbols</a>
<a name="l17512"></a>17512                                &amp;&amp; (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l17513"></a>17513                                    || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>)
<a name="l17514"></a>17514                                ? &amp;<a class="code" href="buildsym_8h.html#a759a37cb08a814d2400a8241ce11387d">global_symbols</a> : cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>);
<a name="l17515"></a>17515 
<a name="l17516"></a>17516                 <span class="comment">/* The semantics of C++ state that &quot;struct foo {</span>
<a name="l17517"></a>17517 <span class="comment">                   ... }&quot; also defines a typedef for &quot;foo&quot;.  A Java</span>
<a name="l17518"></a>17518 <span class="comment">                   class declaration also defines a typedef for the</span>
<a name="l17519"></a>17519 <span class="comment">                   class.  */</span>
<a name="l17520"></a>17520                 <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l17521"></a>17521                     || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>
<a name="l17522"></a>17522                     || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l17523"></a>17523                   {
<a name="l17524"></a>17524                     <span class="comment">/* The symbol&#39;s name is already allocated along</span>
<a name="l17525"></a>17525 <span class="comment">                       with this objfile, so we don&#39;t need to</span>
<a name="l17526"></a>17526 <span class="comment">                       duplicate it for the type.  */</span>
<a name="l17527"></a>17527                     <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym)) == 0)
<a name="l17528"></a>17528                       <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym)) = <a class="code" href="symtab_8h.html#a16e484ff2bd09d4f0400caf5e3f8c3eb">SYMBOL_SEARCH_NAME</a> (sym);
<a name="l17529"></a>17529                   }
<a name="l17530"></a>17530               }
<a name="l17531"></a>17531           }
<a name="l17532"></a>17532           <span class="keywordflow">break</span>;
<a name="l17533"></a>17533         <span class="keywordflow">case</span> DW_TAG_typedef:
<a name="l17534"></a>17534           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>;
<a name="l17535"></a>17535           <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym) = <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>;
<a name="l17536"></a>17536           list_to_add = cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>;
<a name="l17537"></a>17537           <span class="keywordflow">break</span>;
<a name="l17538"></a>17538         <span class="keywordflow">case</span> DW_TAG_base_type:
<a name="l17539"></a>17539         <span class="keywordflow">case</span> DW_TAG_subrange_type:
<a name="l17540"></a>17540           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>;
<a name="l17541"></a>17541           <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym) = <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>;
<a name="l17542"></a>17542           list_to_add = cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>;
<a name="l17543"></a>17543           <span class="keywordflow">break</span>;
<a name="l17544"></a>17544         <span class="keywordflow">case</span> DW_TAG_enumerator:
<a name="l17545"></a>17545           attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_const_value, cu);
<a name="l17546"></a>17546           <span class="keywordflow">if</span> (attr)
<a name="l17547"></a>17547             {
<a name="l17548"></a>17548               <a class="code" href="dwarf2read_8c.html#a87cdf01457f983687ddcb8f7a377b581">dwarf2_const_value</a> (attr, sym, cu);
<a name="l17549"></a>17549             }
<a name="l17550"></a>17550           {
<a name="l17551"></a>17551             <span class="comment">/* NOTE: carlton/2003-11-10: See comment above in the</span>
<a name="l17552"></a>17552 <span class="comment">               DW_TAG_class_type, etc. block.  */</span>
<a name="l17553"></a>17553 
<a name="l17554"></a>17554             list_to_add = (cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a> == &amp;<a class="code" href="buildsym_8h.html#a2d83ed7f7eeffeffeb2e00320573fd0d">file_symbols</a>
<a name="l17555"></a>17555                            &amp;&amp; (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l17556"></a>17556                                || cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>)
<a name="l17557"></a>17557                            ? &amp;<a class="code" href="buildsym_8h.html#a759a37cb08a814d2400a8241ce11387d">global_symbols</a> : cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>);
<a name="l17558"></a>17558           }
<a name="l17559"></a>17559           <span class="keywordflow">break</span>;
<a name="l17560"></a>17560         <span class="keywordflow">case</span> DW_TAG_namespace:
<a name="l17561"></a>17561           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>;
<a name="l17562"></a>17562           list_to_add = &amp;<a class="code" href="buildsym_8h.html#a759a37cb08a814d2400a8241ce11387d">global_symbols</a>;
<a name="l17563"></a>17563           <span class="keywordflow">break</span>;
<a name="l17564"></a>17564         <span class="keywordflow">case</span> DW_TAG_common_block:
<a name="l17565"></a>17565           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3aecebcd8206a80b05907907b04219722a">LOC_COMMON_BLOCK</a>;
<a name="l17566"></a>17566           <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym) = <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa60e9537c28edca1b9d62867b8afcfe98">COMMON_BLOCK_DOMAIN</a>;
<a name="l17567"></a>17567           <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, cu-&gt;<a class="code" href="structdwarf2__cu.html#a945258f9662817ef1c60bec75b248463">list_in_scope</a>);
<a name="l17568"></a>17568           <span class="keywordflow">break</span>;
<a name="l17569"></a>17569         <span class="keywordflow">default</span>:
<a name="l17570"></a>17570           <span class="comment">/* Not a tag we recognize.  Hopefully we aren&#39;t processing</span>
<a name="l17571"></a>17571 <span class="comment">             trash data, but since we must specifically ignore things</span>
<a name="l17572"></a>17572 <span class="comment">             we don&#39;t recognize, there is nothing else we should do at</span>
<a name="l17573"></a>17573 <span class="comment">             this point.  */</span>
<a name="l17574"></a>17574           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unsupported tag: &#39;%s&#39;&quot;</span>),
<a name="l17575"></a>17575                      <a class="code" href="dwarf2read_8c.html#af80d37a7ff366081b096550409d46e45">dwarf_tag_name</a> (die-&gt;tag));
<a name="l17576"></a>17576           <span class="keywordflow">break</span>;
<a name="l17577"></a>17577         }
<a name="l17578"></a>17578 
<a name="l17579"></a>17579       <span class="keywordflow">if</span> (suppress_add)
<a name="l17580"></a>17580         {
<a name="l17581"></a>17581           sym-&gt;<a class="code" href="structsymbol.html#ae072d1dcf8c26c08b2c852c1621a1eca">hash_next</a> = objfile-&gt;<a class="code" href="structobjfile.html#ab974a7032279a493812c9399e9df4df2">template_symbols</a>;
<a name="l17582"></a>17582           objfile-&gt;<a class="code" href="structobjfile.html#ab974a7032279a493812c9399e9df4df2">template_symbols</a> = sym;
<a name="l17583"></a>17583           list_to_add = NULL;
<a name="l17584"></a>17584         }
<a name="l17585"></a>17585 
<a name="l17586"></a>17586       <span class="keywordflow">if</span> (list_to_add != NULL)
<a name="l17587"></a>17587         <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, list_to_add);
<a name="l17588"></a>17588 
<a name="l17589"></a>17589       <span class="comment">/* For the benefit of old versions of GCC, check for anonymous</span>
<a name="l17590"></a>17590 <span class="comment">         namespaces based on the demangled name.  */</span>
<a name="l17591"></a>17591       <span class="keywordflow">if</span> (!cu-&gt;processing_has_namespace_info
<a name="l17592"></a>17592           &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>)
<a name="l17593"></a>17593         <a class="code" href="cp-namespace_8c.html#a81883a13bb77dc248d8fce096b7a616f">cp_scan_for_anonymous_namespaces</a> (sym, objfile);
<a name="l17594"></a>17594     }
<a name="l17595"></a>17595   <span class="keywordflow">return</span> (sym);
<a name="l17596"></a>17596 }
<a name="l17597"></a>17597 
<a name="l17598"></a>17598 <span class="comment">/* A wrapper for new_symbol_full that always allocates a new symbol.  */</span>
<a name="l17599"></a>17599 
<a name="l17600"></a>17600 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *
<a name="l17601"></a><a class="code" href="dwarf2read_8c.html#a4b79d225399dba2c4a3397a858440dd4">17601</a> <a class="code" href="dwarf2read_8c.html#a4b79d225399dba2c4a3397a858440dd4">new_symbol</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l17602"></a>17602 {
<a name="l17603"></a>17603   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a3fc581e6a60a1d1195917cf292c45234">new_symbol_full</a> (die, type, cu, NULL);
<a name="l17604"></a>17604 }
<a name="l17605"></a>17605 
<a name="l17606"></a>17606 <span class="comment">/* Given an attr with a DW_FORM_dataN value in host byte order,</span>
<a name="l17607"></a>17607 <span class="comment">   zero-extend it as appropriate for the symbol&#39;s type.  The DWARF</span>
<a name="l17608"></a>17608 <span class="comment">   standard (v4) is not entirely clear about the meaning of using</span>
<a name="l17609"></a>17609 <span class="comment">   DW_FORM_dataN for a constant with a signed type, where the type is</span>
<a name="l17610"></a>17610 <span class="comment">   wider than the data.  The conclusion of a discussion on the DWARF</span>
<a name="l17611"></a>17611 <span class="comment">   list was that this is unspecified.  We choose to always zero-extend</span>
<a name="l17612"></a>17612 <span class="comment">   because that is the interpretation long in use by GCC.  */</span>
<a name="l17613"></a>17613 
<a name="l17614"></a>17614 <span class="keyword">static</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l17615"></a><a class="code" href="dwarf2read_8c.html#a28881b92367fe7a886c50d60d459ad3f">17615</a> <a class="code" href="dwarf2read_8c.html#a28881b92367fe7a886c50d60d459ad3f">dwarf2_const_value_data</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr, <span class="keyword">struct</span> obstack *obstack,
<a name="l17616"></a>17616                          <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *<a class="code" href="structvalue.html">value</a>, <span class="keywordtype">int</span> <a class="code" href="arm-tdep_8c.html#a6d53921cd0f216408c4aed2806a0cb1f">bits</a>)
<a name="l17617"></a>17617 {
<a name="l17618"></a>17618   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l17619"></a>17619   <span class="keyword">enum</span> bfd_endian byte_order = bfd_big_endian (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>) ?
<a name="l17620"></a>17620                                 BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;
<a name="l17621"></a>17621   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> l = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l17622"></a>17622 
<a name="l17623"></a>17623   <span class="keywordflow">if</span> (bits &lt; <span class="keyword">sizeof</span> (*value) * 8)
<a name="l17624"></a>17624     {
<a name="l17625"></a>17625       l &amp;= ((<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) 1 &lt;&lt; bits) - 1;
<a name="l17626"></a>17626       *value = l;
<a name="l17627"></a>17627     }
<a name="l17628"></a>17628   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bits == <span class="keyword">sizeof</span> (*value) * 8)
<a name="l17629"></a>17629     *value = l;
<a name="l17630"></a>17630   <span class="keywordflow">else</span>
<a name="l17631"></a>17631     {
<a name="l17632"></a>17632       <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *bytes = obstack_alloc (obstack, bits / 8);
<a name="l17633"></a>17633       <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (bytes, bits / 8, byte_order, l);
<a name="l17634"></a>17634       <span class="keywordflow">return</span> bytes;
<a name="l17635"></a>17635     }
<a name="l17636"></a>17636 
<a name="l17637"></a>17637   <span class="keywordflow">return</span> NULL;
<a name="l17638"></a>17638 }
<a name="l17639"></a>17639 
<a name="l17640"></a>17640 <span class="comment">/* Read a constant value from an attribute.  Either set *VALUE, or if</span>
<a name="l17641"></a>17641 <span class="comment">   the value does not fit in *VALUE, set *BYTES - either already</span>
<a name="l17642"></a>17642 <span class="comment">   allocated on the objfile obstack, or newly allocated on OBSTACK,</span>
<a name="l17643"></a>17643 <span class="comment">   or, set *BATON, if we translated the constant to a location</span>
<a name="l17644"></a>17644 <span class="comment">   expression.  */</span>
<a name="l17645"></a>17645 
<a name="l17646"></a>17646 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l17647"></a><a class="code" href="dwarf2read_8c.html#af4c429879bd3d814ab4b878a0d4f926e">17647</a> <a class="code" href="dwarf2read_8c.html#af4c429879bd3d814ab4b878a0d4f926e">dwarf2_const_value_attr</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>,
<a name="l17648"></a>17648                          <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> obstack *obstack,
<a name="l17649"></a>17649                          <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l17650"></a>17650                          <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *<a class="code" href="structvalue.html">value</a>, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **bytes,
<a name="l17651"></a>17651                          <span class="keyword">struct</span> <a class="code" href="structdwarf2__locexpr__baton.html">dwarf2_locexpr_baton</a> **baton)
<a name="l17652"></a>17652 {
<a name="l17653"></a>17653   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l17654"></a>17654   <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_header = &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>;
<a name="l17655"></a>17655   <span class="keyword">struct </span><a class="code" href="structdwarf__block.html">dwarf_block</a> *blk;
<a name="l17656"></a>17656   <span class="keyword">enum</span> bfd_endian byte_order = (bfd_big_endian (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>) ?
<a name="l17657"></a>17657                                 BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE);
<a name="l17658"></a>17658 
<a name="l17659"></a>17659   *value = 0;
<a name="l17660"></a>17660   *bytes = NULL;
<a name="l17661"></a>17661   *baton = NULL;
<a name="l17662"></a>17662 
<a name="l17663"></a>17663   <span class="keywordflow">switch</span> (attr-&gt;form)
<a name="l17664"></a>17664     {
<a name="l17665"></a>17665     <span class="keywordflow">case</span> DW_FORM_addr:
<a name="l17666"></a>17666     <span class="keywordflow">case</span> DW_FORM_GNU_addr_index:
<a name="l17667"></a>17667       {
<a name="l17668"></a>17668         <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structdwarf__block.html#af3a8e3eb0d783b103b0078662dbdc211">data</a>;
<a name="l17669"></a>17669 
<a name="l17670"></a>17670         <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) != cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>)
<a name="l17671"></a>17671           <a class="code" href="dwarf2read_8c.html#a232ddfa8f3451df295d5a5bd5870f82c">dwarf2_const_value_length_mismatch_complaint</a> (name,
<a name="l17672"></a>17672                                                         cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>,
<a name="l17673"></a>17673                                                         <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type));
<a name="l17674"></a>17674         <span class="comment">/* Symbols of this form are reasonably rare, so we just</span>
<a name="l17675"></a>17675 <span class="comment">           piggyback on the existing location code rather than writing</span>
<a name="l17676"></a>17676 <span class="comment">           a new implementation of symbol_computed_ops.  */</span>
<a name="l17677"></a>17677         *baton = obstack_alloc (obstack, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__locexpr__baton.html">dwarf2_locexpr_baton</a>));
<a name="l17678"></a>17678         (*baton)-&gt;per_cu = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;
<a name="l17679"></a>17679         <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> ((*baton)-&gt;per_cu);
<a name="l17680"></a>17680 
<a name="l17681"></a>17681         (*baton)-&gt;size = 2 + cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l17682"></a>17682         data = obstack_alloc (obstack, (*baton)-&gt;size);
<a name="l17683"></a>17683         (*baton)-&gt;data = <a class="code" href="structdwarf__block.html#af3a8e3eb0d783b103b0078662dbdc211">data</a>;
<a name="l17684"></a>17684 
<a name="l17685"></a>17685         data[0] = DW_OP_addr;
<a name="l17686"></a>17686         <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (&amp;data[1], cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>,
<a name="l17687"></a>17687                                 byte_order, <a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (attr));
<a name="l17688"></a>17688         data[cu_header-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a> + 1] = DW_OP_stack_value;
<a name="l17689"></a>17689       }
<a name="l17690"></a>17690       <span class="keywordflow">break</span>;
<a name="l17691"></a>17691     <span class="keywordflow">case</span> DW_FORM_string:
<a name="l17692"></a>17692     <span class="keywordflow">case</span> DW_FORM_strp:
<a name="l17693"></a>17693     <span class="keywordflow">case</span> DW_FORM_GNU_str_index:
<a name="l17694"></a>17694     <span class="keywordflow">case</span> DW_FORM_GNU_strp_alt:
<a name="l17695"></a>17695       <span class="comment">/* DW_STRING is already allocated on the objfile obstack, point</span>
<a name="l17696"></a>17696 <span class="comment">         directly to it.  */</span>
<a name="l17697"></a>17697       *bytes = (<span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *) <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr);
<a name="l17698"></a>17698       <span class="keywordflow">break</span>;
<a name="l17699"></a>17699     <span class="keywordflow">case</span> DW_FORM_block1:
<a name="l17700"></a>17700     <span class="keywordflow">case</span> DW_FORM_block2:
<a name="l17701"></a>17701     <span class="keywordflow">case</span> DW_FORM_block4:
<a name="l17702"></a>17702     <span class="keywordflow">case</span> DW_FORM_block:
<a name="l17703"></a>17703     <span class="keywordflow">case</span> DW_FORM_exprloc:
<a name="l17704"></a>17704       blk = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr);
<a name="l17705"></a>17705       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) != blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a>)
<a name="l17706"></a>17706         <a class="code" href="dwarf2read_8c.html#a232ddfa8f3451df295d5a5bd5870f82c">dwarf2_const_value_length_mismatch_complaint</a> (name, blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a>,
<a name="l17707"></a>17707                                                       <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type));
<a name="l17708"></a>17708       *bytes = blk-&gt;<a class="code" href="structdwarf__block.html#af3a8e3eb0d783b103b0078662dbdc211">data</a>;
<a name="l17709"></a>17709       <span class="keywordflow">break</span>;
<a name="l17710"></a>17710 
<a name="l17711"></a>17711       <span class="comment">/* The DW_AT_const_value attributes are supposed to carry the</span>
<a name="l17712"></a>17712 <span class="comment">         symbol&#39;s value &quot;represented as it would be on the target</span>
<a name="l17713"></a>17713 <span class="comment">         architecture.&quot;  By the time we get here, it&#39;s already been</span>
<a name="l17714"></a>17714 <span class="comment">         converted to host endianness, so we just need to sign- or</span>
<a name="l17715"></a>17715 <span class="comment">         zero-extend it as appropriate.  */</span>
<a name="l17716"></a>17716     <span class="keywordflow">case</span> DW_FORM_data1:
<a name="l17717"></a>17717       *bytes = <a class="code" href="dwarf2read_8c.html#a28881b92367fe7a886c50d60d459ad3f">dwarf2_const_value_data</a> (attr, obstack, cu, value, 8);
<a name="l17718"></a>17718       <span class="keywordflow">break</span>;
<a name="l17719"></a>17719     <span class="keywordflow">case</span> DW_FORM_data2:
<a name="l17720"></a>17720       *bytes = <a class="code" href="dwarf2read_8c.html#a28881b92367fe7a886c50d60d459ad3f">dwarf2_const_value_data</a> (attr, obstack, cu, value, 16);
<a name="l17721"></a>17721       <span class="keywordflow">break</span>;
<a name="l17722"></a>17722     <span class="keywordflow">case</span> DW_FORM_data4:
<a name="l17723"></a>17723       *bytes = <a class="code" href="dwarf2read_8c.html#a28881b92367fe7a886c50d60d459ad3f">dwarf2_const_value_data</a> (attr, obstack, cu, value, 32);
<a name="l17724"></a>17724       <span class="keywordflow">break</span>;
<a name="l17725"></a>17725     <span class="keywordflow">case</span> DW_FORM_data8:
<a name="l17726"></a>17726       *bytes = <a class="code" href="dwarf2read_8c.html#a28881b92367fe7a886c50d60d459ad3f">dwarf2_const_value_data</a> (attr, obstack, cu, value, 64);
<a name="l17727"></a>17727       <span class="keywordflow">break</span>;
<a name="l17728"></a>17728 
<a name="l17729"></a>17729     <span class="keywordflow">case</span> DW_FORM_sdata:
<a name="l17730"></a>17730       *value = <a class="code" href="dwarf2read_8c.html#a66159661f7b11878469288def232a3e4">DW_SND</a> (attr);
<a name="l17731"></a>17731       <span class="keywordflow">break</span>;
<a name="l17732"></a>17732 
<a name="l17733"></a>17733     <span class="keywordflow">case</span> DW_FORM_udata:
<a name="l17734"></a>17734       *value = <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l17735"></a>17735       <span class="keywordflow">break</span>;
<a name="l17736"></a>17736 
<a name="l17737"></a>17737     <span class="keywordflow">default</span>:
<a name="l17738"></a>17738       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l17739"></a>17739                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unsupported const value attribute form: &#39;%s&#39;&quot;</span>),
<a name="l17740"></a>17740                  <a class="code" href="dwarf2read_8c.html#a6810653c49d4b3be30290dc1bcf20c94">dwarf_form_name</a> (attr-&gt;form));
<a name="l17741"></a>17741       *value = 0;
<a name="l17742"></a>17742       <span class="keywordflow">break</span>;
<a name="l17743"></a>17743     }
<a name="l17744"></a>17744 }
<a name="l17745"></a>17745 
<a name="l17746"></a>17746 
<a name="l17747"></a>17747 <span class="comment">/* Copy constant value from an attribute to a symbol.  */</span>
<a name="l17748"></a>17748 
<a name="l17749"></a>17749 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l17750"></a><a class="code" href="dwarf2read_8c.html#a87cdf01457f983687ddcb8f7a377b581">17750</a> <a class="code" href="dwarf2read_8c.html#a87cdf01457f983687ddcb8f7a377b581">dwarf2_const_value</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym,
<a name="l17751"></a>17751                     <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l17752"></a>17752 {
<a name="l17753"></a>17753   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l17754"></a>17754   <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_header = &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>;
<a name="l17755"></a>17755   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="structvalue.html">value</a>;
<a name="l17756"></a>17756   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *bytes;
<a name="l17757"></a>17757   <span class="keyword">struct </span><a class="code" href="structdwarf2__locexpr__baton.html">dwarf2_locexpr_baton</a> *baton;
<a name="l17758"></a>17758 
<a name="l17759"></a>17759   <a class="code" href="dwarf2read_8c.html#af4c429879bd3d814ab4b878a0d4f926e">dwarf2_const_value_attr</a> (attr, <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym),
<a name="l17760"></a>17760                            <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (sym),
<a name="l17761"></a>17761                            &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, cu,
<a name="l17762"></a>17762                            &amp;value, &amp;bytes, &amp;baton);
<a name="l17763"></a>17763 
<a name="l17764"></a>17764   <span class="keywordflow">if</span> (baton != NULL)
<a name="l17765"></a>17765     {
<a name="l17766"></a>17766       <a class="code" href="symtab_8h.html#adf0a8c62c6a593ba1462bc338b95dadf">SYMBOL_LOCATION_BATON</a> (sym) = baton;
<a name="l17767"></a>17767       <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="dwarf2read_8c.html#a52b4c75a920c1e0dbff24148745bc8ca">dwarf2_locexpr_index</a>;
<a name="l17768"></a>17768     }
<a name="l17769"></a>17769   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytes != NULL)
<a name="l17770"></a>17770      {
<a name="l17771"></a>17771       <a class="code" href="symtab_8h.html#aee6737494aece52ad5bdc0516f2a14a9">SYMBOL_VALUE_BYTES</a> (sym) = bytes;
<a name="l17772"></a>17772       <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a74c269ff88b13d3497422a9ebfd98b2d">LOC_CONST_BYTES</a>;
<a name="l17773"></a>17773     }
<a name="l17774"></a>17774   <span class="keywordflow">else</span>
<a name="l17775"></a>17775     {
<a name="l17776"></a>17776       <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (sym) = value;
<a name="l17777"></a>17777       <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a5268309778a6727d08106ff9f2966e54">LOC_CONST</a>;
<a name="l17778"></a>17778     }
<a name="l17779"></a>17779 }
<a name="l17780"></a>17780 
<a name="l17781"></a>17781 <span class="comment">/* Return the type of the die in question using its DW_AT_type attribute.  */</span>
<a name="l17782"></a>17782 
<a name="l17783"></a>17783 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l17784"></a><a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">17784</a> <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l17785"></a>17785 {
<a name="l17786"></a>17786   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *type_attr;
<a name="l17787"></a>17787 
<a name="l17788"></a>17788   type_attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_type, cu);
<a name="l17789"></a>17789   <span class="keywordflow">if</span> (!type_attr)
<a name="l17790"></a>17790     {
<a name="l17791"></a>17791       <span class="comment">/* A missing DW_AT_type represents a void type.  */</span>
<a name="l17792"></a>17792       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>)-&gt;<a class="code" href="structobjfile__type.html#a4143df3933c553aa6f862ea7d3140151">builtin_void</a>;
<a name="l17793"></a>17793     }
<a name="l17794"></a>17794 
<a name="l17795"></a>17795   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#af43079f3d89059ef6812c6c1ed6141c9">lookup_die_type</a> (die, type_attr, cu);
<a name="l17796"></a>17796 }
<a name="l17797"></a>17797 
<a name="l17798"></a>17798 <span class="comment">/* True iff CU&#39;s producer generates GNAT Ada auxiliary information</span>
<a name="l17799"></a>17799 <span class="comment">   that allows to find parallel types through that information instead</span>
<a name="l17800"></a>17800 <span class="comment">   of having to do expensive parallel lookups by type name.  */</span>
<a name="l17801"></a>17801 
<a name="l17802"></a>17802 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l17803"></a><a class="code" href="dwarf2read_8c.html#aa6f64de62201aa04386e42862d37959c">17803</a> <a class="code" href="dwarf2read_8c.html#aa6f64de62201aa04386e42862d37959c">need_gnat_info</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l17804"></a>17804 {
<a name="l17805"></a>17805   <span class="comment">/* FIXME: brobecker/2010-10-12: As of now, only the AdaCore version</span>
<a name="l17806"></a>17806 <span class="comment">     of GNAT produces this auxiliary information, without any indication</span>
<a name="l17807"></a>17807 <span class="comment">     that it is produced.  Part of enhancing the FSF version of GNAT</span>
<a name="l17808"></a>17808 <span class="comment">     to produce that information will be to put in place an indicator</span>
<a name="l17809"></a>17809 <span class="comment">     that we can use in order to determine whether the descriptive type</span>
<a name="l17810"></a>17810 <span class="comment">     info is available or not.  One suggestion that has been made is</span>
<a name="l17811"></a>17811 <span class="comment">     to use a new attribute, attached to the CU die.  For now, assume</span>
<a name="l17812"></a>17812 <span class="comment">     that the descriptive type info is not available.  */</span>
<a name="l17813"></a>17813   <span class="keywordflow">return</span> 0;
<a name="l17814"></a>17814 }
<a name="l17815"></a>17815 
<a name="l17816"></a>17816 <span class="comment">/* Return the auxiliary type of the die in question using its</span>
<a name="l17817"></a>17817 <span class="comment">   DW_AT_GNAT_descriptive_type attribute.  Returns NULL if the</span>
<a name="l17818"></a>17818 <span class="comment">   attribute is not present.  */</span>
<a name="l17819"></a>17819 
<a name="l17820"></a>17820 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l17821"></a><a class="code" href="dwarf2read_8c.html#aff7b3d15e86cadcd51281c9cb07656ab">17821</a> <a class="code" href="dwarf2read_8c.html#aff7b3d15e86cadcd51281c9cb07656ab">die_descriptive_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l17822"></a>17822 {
<a name="l17823"></a>17823   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *type_attr;
<a name="l17824"></a>17824 
<a name="l17825"></a>17825   type_attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_GNAT_descriptive_type, cu);
<a name="l17826"></a>17826   <span class="keywordflow">if</span> (!type_attr)
<a name="l17827"></a>17827     <span class="keywordflow">return</span> NULL;
<a name="l17828"></a>17828 
<a name="l17829"></a>17829   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#af43079f3d89059ef6812c6c1ed6141c9">lookup_die_type</a> (die, type_attr, cu);
<a name="l17830"></a>17830 }
<a name="l17831"></a>17831 
<a name="l17832"></a>17832 <span class="comment">/* If DIE has a descriptive_type attribute, then set the TYPE&#39;s</span>
<a name="l17833"></a>17833 <span class="comment">   descriptive type accordingly.  */</span>
<a name="l17834"></a>17834 
<a name="l17835"></a>17835 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l17836"></a><a class="code" href="dwarf2read_8c.html#abc906394dd587b9b28825cf6798d43d9">17836</a> <a class="code" href="dwarf2read_8c.html#abc906394dd587b9b28825cf6798d43d9">set_descriptive_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die,
<a name="l17837"></a>17837                       <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l17838"></a>17838 {
<a name="l17839"></a>17839   <span class="keyword">struct </span>type *descriptive_type = <a class="code" href="dwarf2read_8c.html#aff7b3d15e86cadcd51281c9cb07656ab">die_descriptive_type</a> (die, cu);
<a name="l17840"></a>17840 
<a name="l17841"></a>17841   <span class="keywordflow">if</span> (descriptive_type)
<a name="l17842"></a>17842     {
<a name="l17843"></a>17843       <a class="code" href="gdbtypes_8h.html#a79d8159b14f17291ce9b150d9ce4f7c4">ALLOCATE_GNAT_AUX_TYPE</a> (type);
<a name="l17844"></a>17844       <a class="code" href="gdbtypes_8h.html#a13051c2080a5b87f05b73a931f0eee3a">TYPE_DESCRIPTIVE_TYPE</a> (type) = descriptive_type;
<a name="l17845"></a>17845     }
<a name="l17846"></a>17846 }
<a name="l17847"></a>17847 
<a name="l17848"></a>17848 <span class="comment">/* Return the containing type of the die in question using its</span>
<a name="l17849"></a>17849 <span class="comment">   DW_AT_containing_type attribute.  */</span>
<a name="l17850"></a>17850 
<a name="l17851"></a>17851 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l17852"></a><a class="code" href="dwarf2read_8c.html#a2ce2b8e439742408e8161e899d9cb67a">17852</a> <a class="code" href="dwarf2read_8c.html#a2ce2b8e439742408e8161e899d9cb67a">die_containing_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l17853"></a>17853 {
<a name="l17854"></a>17854   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *type_attr;
<a name="l17855"></a>17855 
<a name="l17856"></a>17856   type_attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_containing_type, cu);
<a name="l17857"></a>17857   <span class="keywordflow">if</span> (!type_attr)
<a name="l17858"></a>17858     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Problem turning containing type into gdb type &quot;</span>
<a name="l17859"></a>17859              <span class="stringliteral">&quot;[in module %s]&quot;</span>), <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>));
<a name="l17860"></a>17860 
<a name="l17861"></a>17861   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#af43079f3d89059ef6812c6c1ed6141c9">lookup_die_type</a> (die, type_attr, cu);
<a name="l17862"></a>17862 }
<a name="l17863"></a>17863 
<a name="l17864"></a>17864 <span class="comment">/* Return an error marker type to use for the ill formed type in DIE/CU.  */</span>
<a name="l17865"></a>17865 
<a name="l17866"></a>17866 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l17867"></a><a class="code" href="dwarf2read_8c.html#a4a3b5d2bd904b30c13a2c22b09778ae6">17867</a> <a class="code" href="dwarf2read_8c.html#a4a3b5d2bd904b30c13a2c22b09778ae6">build_error_marker_type</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die)
<a name="l17868"></a>17868 {
<a name="l17869"></a>17869   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l17870"></a>17870   <span class="keywordtype">char</span> *message, *saved;
<a name="l17871"></a>17871 
<a name="l17872"></a>17872   message = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;&lt;unknown type in %s, CU 0x%x, DIE 0x%x&gt;&quot;</span>),
<a name="l17873"></a>17873                         <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile),
<a name="l17874"></a>17874                         cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a19c7fc05cc13c09ad407c1b594d75792">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>,
<a name="l17875"></a>17875                         die-&gt;offset.sect_off);
<a name="l17876"></a>17876   saved = obstack_copy0 (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l17877"></a>17877                          message, strlen (message));
<a name="l17878"></a>17878   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (message);
<a name="l17879"></a>17879 
<a name="l17880"></a>17880   <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac74c6d3def8258efc09a3deb8f395d64">init_type</a> (<a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a36e1735c46b31ec7fc392e40606f8f65">TYPE_CODE_ERROR</a>, 0, 0, saved, objfile);
<a name="l17881"></a>17881 }
<a name="l17882"></a>17882 
<a name="l17883"></a>17883 <span class="comment">/* Look up the type of DIE in CU using its type attribute ATTR.</span>
<a name="l17884"></a>17884 <span class="comment">   ATTR must be one of: DW_AT_type, DW_AT_GNAT_descriptive_type,</span>
<a name="l17885"></a>17885 <span class="comment">   DW_AT_containing_type.</span>
<a name="l17886"></a>17886 <span class="comment">   If there is no type substitute an error marker.  */</span>
<a name="l17887"></a>17887 
<a name="l17888"></a>17888 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l17889"></a><a class="code" href="dwarf2read_8c.html#af43079f3d89059ef6812c6c1ed6141c9">17889</a> <a class="code" href="dwarf2read_8c.html#af43079f3d89059ef6812c6c1ed6141c9">lookup_die_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr,
<a name="l17890"></a>17890                  <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l17891"></a>17891 {
<a name="l17892"></a>17892   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l17893"></a>17893   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *this_type;
<a name="l17894"></a>17894 
<a name="l17895"></a>17895   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (attr-&gt;name == DW_AT_type
<a name="l17896"></a>17896               || attr-&gt;name == DW_AT_GNAT_descriptive_type
<a name="l17897"></a>17897               || attr-&gt;name == DW_AT_containing_type);
<a name="l17898"></a>17898 
<a name="l17899"></a>17899   <span class="comment">/* First see if we have it cached.  */</span>
<a name="l17900"></a>17900 
<a name="l17901"></a>17901   <span class="keywordflow">if</span> (attr-&gt;form == DW_FORM_GNU_ref_alt)
<a name="l17902"></a>17902     {
<a name="l17903"></a>17903       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu;
<a name="l17904"></a>17904       <a class="code" href="structsect__offset.html">sect_offset</a> offset = <a class="code" href="dwarf2read_8c.html#a28e7eb63f317d51f9be16584d407c508">dwarf2_get_ref_die_offset</a> (attr);
<a name="l17905"></a>17905 
<a name="l17906"></a>17906       per_cu = <a class="code" href="dwarf2read_8c.html#af3b37bdf179696b92b068cd2894de56d">dwarf2_find_containing_comp_unit</a> (offset, 1, cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>);
<a name="l17907"></a>17907       this_type = <a class="code" href="dwarf2read_8c.html#ae277955c587127c2a481663cca343437">get_die_type_at_offset</a> (offset, per_cu);
<a name="l17908"></a>17908     }
<a name="l17909"></a>17909   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a217d4eb87ed57947007169e88bb2a0f9">attr_form_is_ref</a> (attr))
<a name="l17910"></a>17910     {
<a name="l17911"></a>17911       <a class="code" href="structsect__offset.html">sect_offset</a> offset = <a class="code" href="dwarf2read_8c.html#a28e7eb63f317d51f9be16584d407c508">dwarf2_get_ref_die_offset</a> (attr);
<a name="l17912"></a>17912 
<a name="l17913"></a>17913       this_type = <a class="code" href="dwarf2read_8c.html#ae277955c587127c2a481663cca343437">get_die_type_at_offset</a> (offset, cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>);
<a name="l17914"></a>17914     }
<a name="l17915"></a>17915   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attr-&gt;form == DW_FORM_ref_sig8)
<a name="l17916"></a>17916     {
<a name="l17917"></a>17917       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> signature = <a class="code" href="dwarf2read_8c.html#a8ba60632a90cfabc155c69f0bf2d2f83">DW_SIGNATURE</a> (attr);
<a name="l17918"></a>17918 
<a name="l17919"></a>17919       <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a743c93f0f8a0cfece75baa06b8b1f5a0">get_signatured_type</a> (die, signature, cu);
<a name="l17920"></a>17920     }
<a name="l17921"></a>17921   <span class="keywordflow">else</span>
<a name="l17922"></a>17922     {
<a name="l17923"></a>17923       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l17924"></a>17924                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Bad type attribute %s in DIE&quot;</span>
<a name="l17925"></a>17925                    <span class="stringliteral">&quot; at 0x%x [in module %s]&quot;</span>),
<a name="l17926"></a>17926                  <a class="code" href="dwarf2read_8c.html#a9cf5304ec3b94ab9e1786529ad97338b">dwarf_attr_name</a> (attr-&gt;name), die-&gt;offset.sect_off,
<a name="l17927"></a>17927                  <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l17928"></a>17928       <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a4a3b5d2bd904b30c13a2c22b09778ae6">build_error_marker_type</a> (cu, die);
<a name="l17929"></a>17929     }
<a name="l17930"></a>17930 
<a name="l17931"></a>17931   <span class="comment">/* If not cached we need to read it in.  */</span>
<a name="l17932"></a>17932 
<a name="l17933"></a>17933   <span class="keywordflow">if</span> (this_type == NULL)
<a name="l17934"></a>17934     {
<a name="l17935"></a>17935       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *type_die = NULL;
<a name="l17936"></a>17936       <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *type_cu = cu;
<a name="l17937"></a>17937 
<a name="l17938"></a>17938       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a217d4eb87ed57947007169e88bb2a0f9">attr_form_is_ref</a> (attr))
<a name="l17939"></a>17939         type_die = <a class="code" href="dwarf2read_8c.html#a079b531fef51cfc34f92ff6fde2ef8a4">follow_die_ref</a> (die, attr, &amp;type_cu);
<a name="l17940"></a>17940       <span class="keywordflow">if</span> (type_die == NULL)
<a name="l17941"></a>17941         <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a4a3b5d2bd904b30c13a2c22b09778ae6">build_error_marker_type</a> (cu, die);
<a name="l17942"></a>17942       <span class="comment">/* If we find the type now, it&#39;s probably because the type came</span>
<a name="l17943"></a>17943 <span class="comment">         from an inter-CU reference and the type&#39;s CU got expanded before</span>
<a name="l17944"></a>17944 <span class="comment">         ours.  */</span>
<a name="l17945"></a>17945       this_type = <a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (type_die, type_cu);
<a name="l17946"></a>17946     }
<a name="l17947"></a>17947 
<a name="l17948"></a>17948   <span class="comment">/* If we still don&#39;t have a type use an error marker.  */</span>
<a name="l17949"></a>17949 
<a name="l17950"></a>17950   <span class="keywordflow">if</span> (this_type == NULL)
<a name="l17951"></a>17951     <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a4a3b5d2bd904b30c13a2c22b09778ae6">build_error_marker_type</a> (cu, die);
<a name="l17952"></a>17952 
<a name="l17953"></a>17953   <span class="keywordflow">return</span> this_type;
<a name="l17954"></a>17954 }
<a name="l17955"></a>17955 
<a name="l17956"></a>17956 <span class="comment">/* Return the type in DIE, CU.</span>
<a name="l17957"></a>17957 <span class="comment">   Returns NULL for invalid types.</span>
<a name="l17958"></a>17958 <span class="comment"></span>
<a name="l17959"></a>17959 <span class="comment">   This first does a lookup in die_type_hash,</span>
<a name="l17960"></a>17960 <span class="comment">   and only reads the die in if necessary.</span>
<a name="l17961"></a>17961 <span class="comment"></span>
<a name="l17962"></a>17962 <span class="comment">   NOTE: This can be called when reading in partial or full symbols.  */</span>
<a name="l17963"></a>17963 
<a name="l17964"></a>17964 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l17965"></a><a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">17965</a> <a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l17966"></a>17966 {
<a name="l17967"></a>17967   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *this_type;
<a name="l17968"></a>17968 
<a name="l17969"></a>17969   this_type = <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (die, cu);
<a name="l17970"></a>17970   <span class="keywordflow">if</span> (this_type)
<a name="l17971"></a>17971     <span class="keywordflow">return</span> this_type;
<a name="l17972"></a>17972 
<a name="l17973"></a>17973   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#ae16a66bf29f050e080c494d9fabf548e">read_type_die_1</a> (die, cu);
<a name="l17974"></a>17974 }
<a name="l17975"></a>17975 
<a name="l17976"></a>17976 <span class="comment">/* Read the type in DIE, CU.</span>
<a name="l17977"></a>17977 <span class="comment">   Returns NULL for invalid types.  */</span>
<a name="l17978"></a>17978 
<a name="l17979"></a>17979 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l17980"></a><a class="code" href="dwarf2read_8c.html#ae16a66bf29f050e080c494d9fabf548e">17980</a> <a class="code" href="dwarf2read_8c.html#ae16a66bf29f050e080c494d9fabf548e">read_type_die_1</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l17981"></a>17981 {
<a name="l17982"></a>17982   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *this_type = NULL;
<a name="l17983"></a>17983 
<a name="l17984"></a>17984   <span class="keywordflow">switch</span> (die-&gt;tag)
<a name="l17985"></a>17985     {
<a name="l17986"></a>17986     <span class="keywordflow">case</span> DW_TAG_class_type:
<a name="l17987"></a>17987     <span class="keywordflow">case</span> DW_TAG_interface_type:
<a name="l17988"></a>17988     <span class="keywordflow">case</span> DW_TAG_structure_type:
<a name="l17989"></a>17989     <span class="keywordflow">case</span> DW_TAG_union_type:
<a name="l17990"></a>17990       this_type = <a class="code" href="dwarf2read_8c.html#a8a81f5037ce9ef3a37c692027a511e68">read_structure_type</a> (die, cu);
<a name="l17991"></a>17991       <span class="keywordflow">break</span>;
<a name="l17992"></a>17992     <span class="keywordflow">case</span> DW_TAG_enumeration_type:
<a name="l17993"></a>17993       this_type = <a class="code" href="dwarf2read_8c.html#abdeef1b6d889ebd38830b6ba38d05f37">read_enumeration_type</a> (die, cu);
<a name="l17994"></a>17994       <span class="keywordflow">break</span>;
<a name="l17995"></a>17995     <span class="keywordflow">case</span> DW_TAG_subprogram:
<a name="l17996"></a>17996     <span class="keywordflow">case</span> DW_TAG_subroutine_type:
<a name="l17997"></a>17997     <span class="keywordflow">case</span> DW_TAG_inlined_subroutine:
<a name="l17998"></a>17998       this_type = <a class="code" href="dwarf2read_8c.html#a036db2ec5896a2ab6de7ceac5a444be1">read_subroutine_type</a> (die, cu);
<a name="l17999"></a>17999       <span class="keywordflow">break</span>;
<a name="l18000"></a>18000     <span class="keywordflow">case</span> DW_TAG_array_type:
<a name="l18001"></a>18001       this_type = <a class="code" href="dwarf2read_8c.html#acd2768b4f079f42297c0946fd77225b5">read_array_type</a> (die, cu);
<a name="l18002"></a>18002       <span class="keywordflow">break</span>;
<a name="l18003"></a>18003     <span class="keywordflow">case</span> DW_TAG_set_type:
<a name="l18004"></a>18004       this_type = <a class="code" href="dwarf2read_8c.html#acedddf0d654aa0b435d336a819051c37">read_set_type</a> (die, cu);
<a name="l18005"></a>18005       <span class="keywordflow">break</span>;
<a name="l18006"></a>18006     <span class="keywordflow">case</span> DW_TAG_pointer_type:
<a name="l18007"></a>18007       this_type = <a class="code" href="dwarf2read_8c.html#a129b8da76768577ac923c37c5032d5b3">read_tag_pointer_type</a> (die, cu);
<a name="l18008"></a>18008       <span class="keywordflow">break</span>;
<a name="l18009"></a>18009     <span class="keywordflow">case</span> DW_TAG_ptr_to_member_type:
<a name="l18010"></a>18010       this_type = <a class="code" href="dwarf2read_8c.html#a7e75df1461a49fb5cbeb691d29d32f84">read_tag_ptr_to_member_type</a> (die, cu);
<a name="l18011"></a>18011       <span class="keywordflow">break</span>;
<a name="l18012"></a>18012     <span class="keywordflow">case</span> DW_TAG_reference_type:
<a name="l18013"></a>18013       this_type = <a class="code" href="dwarf2read_8c.html#adafa7d9319e91244bbebff956f725617">read_tag_reference_type</a> (die, cu);
<a name="l18014"></a>18014       <span class="keywordflow">break</span>;
<a name="l18015"></a>18015     <span class="keywordflow">case</span> DW_TAG_const_type:
<a name="l18016"></a>18016       this_type = <a class="code" href="dwarf2read_8c.html#acb16fe8bbe51e3eafac738ee28c31443">read_tag_const_type</a> (die, cu);
<a name="l18017"></a>18017       <span class="keywordflow">break</span>;
<a name="l18018"></a>18018     <span class="keywordflow">case</span> DW_TAG_volatile_type:
<a name="l18019"></a>18019       this_type = <a class="code" href="dwarf2read_8c.html#a5276cd2ff93de6b77fcb7120719f84ea">read_tag_volatile_type</a> (die, cu);
<a name="l18020"></a>18020       <span class="keywordflow">break</span>;
<a name="l18021"></a>18021     <span class="keywordflow">case</span> DW_TAG_restrict_type:
<a name="l18022"></a>18022       this_type = <a class="code" href="dwarf2read_8c.html#a391d058296d6101d946a79a6fca703dc">read_tag_restrict_type</a> (die, cu);
<a name="l18023"></a>18023       <span class="keywordflow">break</span>;
<a name="l18024"></a>18024     <span class="keywordflow">case</span> DW_TAG_string_type:
<a name="l18025"></a>18025       this_type = <a class="code" href="dwarf2read_8c.html#a12c451dc793da3bff47faf4f826f8d84">read_tag_string_type</a> (die, cu);
<a name="l18026"></a>18026       <span class="keywordflow">break</span>;
<a name="l18027"></a>18027     <span class="keywordflow">case</span> DW_TAG_typedef:
<a name="l18028"></a>18028       this_type = <a class="code" href="dwarf2read_8c.html#a26cc54e0bf4355982c4039050812f08c">read_typedef</a> (die, cu);
<a name="l18029"></a>18029       <span class="keywordflow">break</span>;
<a name="l18030"></a>18030     <span class="keywordflow">case</span> DW_TAG_subrange_type:
<a name="l18031"></a>18031       this_type = <a class="code" href="dwarf2read_8c.html#a8749190a8e238fcc0fb7cb25f8d0f2ce">read_subrange_type</a> (die, cu);
<a name="l18032"></a>18032       <span class="keywordflow">break</span>;
<a name="l18033"></a>18033     <span class="keywordflow">case</span> DW_TAG_base_type:
<a name="l18034"></a>18034       this_type = <a class="code" href="dwarf2read_8c.html#a869473b2da0ab4c33c5b185c316b6bc9">read_base_type</a> (die, cu);
<a name="l18035"></a>18035       <span class="keywordflow">break</span>;
<a name="l18036"></a>18036     <span class="keywordflow">case</span> DW_TAG_unspecified_type:
<a name="l18037"></a>18037       this_type = <a class="code" href="dwarf2read_8c.html#a206b3e0c61cd6d9d6d16b325dd73e602">read_unspecified_type</a> (die, cu);
<a name="l18038"></a>18038       <span class="keywordflow">break</span>;
<a name="l18039"></a>18039     <span class="keywordflow">case</span> DW_TAG_namespace:
<a name="l18040"></a>18040       this_type = <a class="code" href="dwarf2read_8c.html#ada8cae48662eacbf63c43ee01bc7933b">read_namespace_type</a> (die, cu);
<a name="l18041"></a>18041       <span class="keywordflow">break</span>;
<a name="l18042"></a>18042     <span class="keywordflow">case</span> DW_TAG_module:
<a name="l18043"></a>18043       this_type = <a class="code" href="dwarf2read_8c.html#a2d1e350c81129a2c7dc6591e4b67267e">read_module_type</a> (die, cu);
<a name="l18044"></a>18044       <span class="keywordflow">break</span>;
<a name="l18045"></a>18045     <span class="keywordflow">default</span>:
<a name="l18046"></a>18046       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l18047"></a>18047                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unexpected tag in read_type_die: &#39;%s&#39;&quot;</span>),
<a name="l18048"></a>18048                  <a class="code" href="dwarf2read_8c.html#af80d37a7ff366081b096550409d46e45">dwarf_tag_name</a> (die-&gt;tag));
<a name="l18049"></a>18049       <span class="keywordflow">break</span>;
<a name="l18050"></a>18050     }
<a name="l18051"></a>18051 
<a name="l18052"></a>18052   <span class="keywordflow">return</span> this_type;
<a name="l18053"></a>18053 }
<a name="l18054"></a>18054 
<a name="l18055"></a>18055 <span class="comment">/* See if we can figure out if the class lives in a namespace.  We do</span>
<a name="l18056"></a>18056 <span class="comment">   this by looking for a member function; its demangled name will</span>
<a name="l18057"></a>18057 <span class="comment">   contain namespace info, if there is any.</span>
<a name="l18058"></a>18058 <span class="comment">   Return the computed name or NULL.</span>
<a name="l18059"></a>18059 <span class="comment">   Space for the result is allocated on the objfile&#39;s obstack.</span>
<a name="l18060"></a>18060 <span class="comment">   This is the full-die version of guess_partial_die_structure_name.</span>
<a name="l18061"></a>18061 <span class="comment">   In this case we know DIE has no useful parent.  */</span>
<a name="l18062"></a>18062 
<a name="l18063"></a>18063 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l18064"></a><a class="code" href="dwarf2read_8c.html#a0d9409273e090033910508a49936aeaf">18064</a> <a class="code" href="dwarf2read_8c.html#a0d9409273e090033910508a49936aeaf">guess_full_die_structure_name</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l18065"></a>18065 {
<a name="l18066"></a>18066   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *spec_die;
<a name="l18067"></a>18067   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *spec_cu;
<a name="l18068"></a>18068   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *child;
<a name="l18069"></a>18069 
<a name="l18070"></a>18070   spec_cu = cu;
<a name="l18071"></a>18071   spec_die = <a class="code" href="dwarf2read_8c.html#a86adfa4fccde4cd4c512ca520e5bb1d7">die_specification</a> (die, &amp;spec_cu);
<a name="l18072"></a>18072   <span class="keywordflow">if</span> (spec_die != NULL)
<a name="l18073"></a>18073     {
<a name="l18074"></a>18074       die = spec_die;
<a name="l18075"></a>18075       cu = spec_cu;
<a name="l18076"></a>18076     }
<a name="l18077"></a>18077 
<a name="l18078"></a>18078   <span class="keywordflow">for</span> (child = die-&gt;child;
<a name="l18079"></a>18079        child != NULL;
<a name="l18080"></a>18080        child = child-&gt;sibling)
<a name="l18081"></a>18081     {
<a name="l18082"></a>18082       <span class="keywordflow">if</span> (child-&gt;tag == DW_TAG_subprogram)
<a name="l18083"></a>18083         {
<a name="l18084"></a>18084           <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l18085"></a>18085 
<a name="l18086"></a>18086           attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (child, DW_AT_linkage_name, cu);
<a name="l18087"></a>18087           <span class="keywordflow">if</span> (attr == NULL)
<a name="l18088"></a>18088             attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (child, DW_AT_MIPS_linkage_name, cu);
<a name="l18089"></a>18089           <span class="keywordflow">if</span> (attr != NULL)
<a name="l18090"></a>18090             {
<a name="l18091"></a>18091               <span class="keywordtype">char</span> *actual_name
<a name="l18092"></a>18092                 = <a class="code" href="language_8c.html#ac1c0e6eb5f485ef5ea6b7d30b8a87f46">language_class_name_from_physname</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa12f3aeef950b4457378c14f9ba16f12">language_defn</a>,
<a name="l18093"></a>18093                                                      <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr));
<a name="l18094"></a>18094               <span class="keywordtype">char</span> *name = NULL;
<a name="l18095"></a>18095 
<a name="l18096"></a>18096               <span class="keywordflow">if</span> (actual_name != NULL)
<a name="l18097"></a>18097                 {
<a name="l18098"></a>18098                   <span class="keyword">const</span> <span class="keywordtype">char</span> *die_name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l18099"></a>18099 
<a name="l18100"></a>18100                   <span class="keywordflow">if</span> (die_name != NULL
<a name="l18101"></a>18101                       &amp;&amp; strcmp (die_name, actual_name) != 0)
<a name="l18102"></a>18102                     {
<a name="l18103"></a>18103                       <span class="comment">/* Strip off the class name from the full name.</span>
<a name="l18104"></a>18104 <span class="comment">                         We want the prefix.  */</span>
<a name="l18105"></a>18105                       <span class="keywordtype">int</span> die_name_len = strlen (die_name);
<a name="l18106"></a>18106                       <span class="keywordtype">int</span> actual_name_len = strlen (actual_name);
<a name="l18107"></a>18107 
<a name="l18108"></a>18108                       <span class="comment">/* Test for &#39;::&#39; as a sanity check.  */</span>
<a name="l18109"></a>18109                       <span class="keywordflow">if</span> (actual_name_len &gt; die_name_len + 2
<a name="l18110"></a>18110                           &amp;&amp; actual_name[actual_name_len
<a name="l18111"></a>18111                                          - die_name_len - 1] == <span class="charliteral">&#39;:&#39;</span>)
<a name="l18112"></a>18112                         name =
<a name="l18113"></a>18113                           obstack_copy0 (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l18114"></a>18114                                          actual_name,
<a name="l18115"></a>18115                                          actual_name_len - die_name_len - 2);
<a name="l18116"></a>18116                     }
<a name="l18117"></a>18117                 }
<a name="l18118"></a>18118               <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (actual_name);
<a name="l18119"></a>18119               <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l18120"></a>18120             }
<a name="l18121"></a>18121         }
<a name="l18122"></a>18122     }
<a name="l18123"></a>18123 
<a name="l18124"></a>18124   <span class="keywordflow">return</span> NULL;
<a name="l18125"></a>18125 }
<a name="l18126"></a>18126 
<a name="l18127"></a>18127 <span class="comment">/* GCC might emit a nameless typedef that has a linkage name.  Determine the</span>
<a name="l18128"></a>18128 <span class="comment">   prefix part in such case.  See</span>
<a name="l18129"></a>18129 <span class="comment">   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47510.  */</span>
<a name="l18130"></a>18130 
<a name="l18131"></a>18131 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l18132"></a><a class="code" href="dwarf2read_8c.html#a7837bf4421f1d0bd343b991359608f63">18132</a> <a class="code" href="dwarf2read_8c.html#a7837bf4421f1d0bd343b991359608f63">anonymous_struct_prefix</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l18133"></a>18133 {
<a name="l18134"></a>18134   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l18135"></a>18135   <span class="keywordtype">char</span> *base;
<a name="l18136"></a>18136 
<a name="l18137"></a>18137   <span class="keywordflow">if</span> (die-&gt;tag != DW_TAG_class_type &amp;&amp; die-&gt;tag != DW_TAG_interface_type
<a name="l18138"></a>18138       &amp;&amp; die-&gt;tag != DW_TAG_structure_type &amp;&amp; die-&gt;tag != DW_TAG_union_type)
<a name="l18139"></a>18139     <span class="keywordflow">return</span> NULL;
<a name="l18140"></a>18140 
<a name="l18141"></a>18141   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_name, cu);
<a name="l18142"></a>18142   <span class="keywordflow">if</span> (attr != NULL &amp;&amp; <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr) != NULL)
<a name="l18143"></a>18143     <span class="keywordflow">return</span> NULL;
<a name="l18144"></a>18144 
<a name="l18145"></a>18145   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_linkage_name, cu);
<a name="l18146"></a>18146   <span class="keywordflow">if</span> (attr == NULL)
<a name="l18147"></a>18147     attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_MIPS_linkage_name, cu);
<a name="l18148"></a>18148   <span class="keywordflow">if</span> (attr == NULL || <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr) == NULL)
<a name="l18149"></a>18149     <span class="keywordflow">return</span> NULL;
<a name="l18150"></a>18150 
<a name="l18151"></a>18151   <span class="comment">/* dwarf2_name had to be already called.  */</span>
<a name="l18152"></a>18152   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="dwarf2read_8c.html#a307f18e0d403d80487696d1a0a5d0fd6">DW_STRING_IS_CANONICAL</a> (attr));
<a name="l18153"></a>18153 
<a name="l18154"></a>18154   <span class="comment">/* Strip the base name, keep any leading namespaces/classes.  */</span>
<a name="l18155"></a>18155   base = <a class="code" href="gdb__string_8h.html#a5cbb8bbfc7174d9468b1853f1031efb3">strrchr</a> (<a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr), <span class="charliteral">&#39;:&#39;</span>);
<a name="l18156"></a>18156   <span class="keywordflow">if</span> (base == NULL || base == <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr) || base[-1] != <span class="charliteral">&#39;:&#39;</span>)
<a name="l18157"></a>18157     <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l18158"></a>18158 
<a name="l18159"></a>18159   <span class="keywordflow">return</span> obstack_copy0 (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l18160"></a>18160                         <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr), &amp;base[-1] - <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr));
<a name="l18161"></a>18161 }
<a name="l18162"></a>18162 
<a name="l18163"></a>18163 <span class="comment">/* Return the name of the namespace/class that DIE is defined within,</span>
<a name="l18164"></a>18164 <span class="comment">   or &quot;&quot; if we can&#39;t tell.  The caller should not xfree the result.</span>
<a name="l18165"></a>18165 <span class="comment"></span>
<a name="l18166"></a>18166 <span class="comment">   For example, if we&#39;re within the method foo() in the following</span>
<a name="l18167"></a>18167 <span class="comment">   code:</span>
<a name="l18168"></a>18168 <span class="comment"></span>
<a name="l18169"></a>18169 <span class="comment">   namespace N {</span>
<a name="l18170"></a>18170 <span class="comment">     class C {</span>
<a name="l18171"></a>18171 <span class="comment">       void foo () {</span>
<a name="l18172"></a>18172 <span class="comment">       }</span>
<a name="l18173"></a>18173 <span class="comment">     };</span>
<a name="l18174"></a>18174 <span class="comment">   }</span>
<a name="l18175"></a>18175 <span class="comment"></span>
<a name="l18176"></a>18176 <span class="comment">   then determine_prefix on foo&#39;s die will return &quot;N::C&quot;.  */</span>
<a name="l18177"></a>18177 
<a name="l18178"></a>18178 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l18179"></a><a class="code" href="dwarf2read_8c.html#a2417ea09b6b125e47a255352f662e856">18179</a> <a class="code" href="dwarf2read_8c.html#a2417ea09b6b125e47a255352f662e856">determine_prefix</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l18180"></a>18180 {
<a name="l18181"></a>18181   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *parent, *spec_die;
<a name="l18182"></a>18182   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *spec_cu;
<a name="l18183"></a>18183   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *parent_type;
<a name="l18184"></a>18184   <span class="keywordtype">char</span> *retval;
<a name="l18185"></a>18185 
<a name="l18186"></a>18186   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a> &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>
<a name="l18187"></a>18187       &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a>)
<a name="l18188"></a>18188     <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l18189"></a>18189 
<a name="l18190"></a>18190   retval = <a class="code" href="dwarf2read_8c.html#a7837bf4421f1d0bd343b991359608f63">anonymous_struct_prefix</a> (die, cu);
<a name="l18191"></a>18191   <span class="keywordflow">if</span> (retval)
<a name="l18192"></a>18192     <span class="keywordflow">return</span> retval;
<a name="l18193"></a>18193 
<a name="l18194"></a>18194   <span class="comment">/* We have to be careful in the presence of DW_AT_specification.</span>
<a name="l18195"></a>18195 <span class="comment">     For example, with GCC 3.4, given the code</span>
<a name="l18196"></a>18196 <span class="comment"></span>
<a name="l18197"></a>18197 <span class="comment">     namespace N {</span>
<a name="l18198"></a>18198 <span class="comment">       void foo() {</span>
<a name="l18199"></a>18199 <span class="comment">         // Definition of N::foo.</span>
<a name="l18200"></a>18200 <span class="comment">       }</span>
<a name="l18201"></a>18201 <span class="comment">     }</span>
<a name="l18202"></a>18202 <span class="comment"></span>
<a name="l18203"></a>18203 <span class="comment">     then we&#39;ll have a tree of DIEs like this:</span>
<a name="l18204"></a>18204 <span class="comment"></span>
<a name="l18205"></a>18205 <span class="comment">     1: DW_TAG_compile_unit</span>
<a name="l18206"></a>18206 <span class="comment">       2: DW_TAG_namespace        // N</span>
<a name="l18207"></a>18207 <span class="comment">         3: DW_TAG_subprogram     // declaration of N::foo</span>
<a name="l18208"></a>18208 <span class="comment">       4: DW_TAG_subprogram       // definition of N::foo</span>
<a name="l18209"></a>18209 <span class="comment">            DW_AT_specification   // refers to die #3</span>
<a name="l18210"></a>18210 <span class="comment"></span>
<a name="l18211"></a>18211 <span class="comment">     Thus, when processing die #4, we have to pretend that we&#39;re in</span>
<a name="l18212"></a>18212 <span class="comment">     the context of its DW_AT_specification, namely the contex of die</span>
<a name="l18213"></a>18213 <span class="comment">     #3.  */</span>
<a name="l18214"></a>18214   spec_cu = cu;
<a name="l18215"></a>18215   spec_die = <a class="code" href="dwarf2read_8c.html#a86adfa4fccde4cd4c512ca520e5bb1d7">die_specification</a> (die, &amp;spec_cu);
<a name="l18216"></a>18216   <span class="keywordflow">if</span> (spec_die == NULL)
<a name="l18217"></a>18217     parent = die-&gt;parent;
<a name="l18218"></a>18218   <span class="keywordflow">else</span>
<a name="l18219"></a>18219     {
<a name="l18220"></a>18220       parent = spec_die-&gt;parent;
<a name="l18221"></a>18221       cu = spec_cu;
<a name="l18222"></a>18222     }
<a name="l18223"></a>18223 
<a name="l18224"></a>18224   <span class="keywordflow">if</span> (parent == NULL)
<a name="l18225"></a>18225     <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l18226"></a>18226   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parent-&gt;building_fullname)
<a name="l18227"></a>18227     {
<a name="l18228"></a>18228       <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l18229"></a>18229       <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_name;
<a name="l18230"></a>18230 
<a name="l18231"></a>18231       <span class="comment">/* It has been seen on RealView 2.2 built binaries,</span>
<a name="l18232"></a>18232 <span class="comment">         DW_TAG_template_type_param types actually _defined_ as</span>
<a name="l18233"></a>18233 <span class="comment">         children of the parent class:</span>
<a name="l18234"></a>18234 <span class="comment"></span>
<a name="l18235"></a>18235 <span class="comment">         enum E {};</span>
<a name="l18236"></a>18236 <span class="comment">         template class &lt;class Enum&gt; Class{};</span>
<a name="l18237"></a>18237 <span class="comment">         Class&lt;enum E&gt; class_e;</span>
<a name="l18238"></a>18238 <span class="comment"></span>
<a name="l18239"></a>18239 <span class="comment">         1: DW_TAG_class_type (Class)</span>
<a name="l18240"></a>18240 <span class="comment">           2: DW_TAG_enumeration_type (E)</span>
<a name="l18241"></a>18241 <span class="comment">             3: DW_TAG_enumerator (enum1:0)</span>
<a name="l18242"></a>18242 <span class="comment">             3: DW_TAG_enumerator (enum2:1)</span>
<a name="l18243"></a>18243 <span class="comment">             ...</span>
<a name="l18244"></a>18244 <span class="comment">           2: DW_TAG_template_type_param</span>
<a name="l18245"></a>18245 <span class="comment">              DW_AT_type  DW_FORM_ref_udata (E)</span>
<a name="l18246"></a>18246 <span class="comment"></span>
<a name="l18247"></a>18247 <span class="comment">         Besides being broken debug info, it can put GDB into an</span>
<a name="l18248"></a>18248 <span class="comment">         infinite loop.  Consider:</span>
<a name="l18249"></a>18249 <span class="comment"></span>
<a name="l18250"></a>18250 <span class="comment">         When we&#39;re building the full name for Class&lt;E&gt;, we&#39;ll start</span>
<a name="l18251"></a>18251 <span class="comment">         at Class, and go look over its template type parameters,</span>
<a name="l18252"></a>18252 <span class="comment">         finding E.  We&#39;ll then try to build the full name of E, and</span>
<a name="l18253"></a>18253 <span class="comment">         reach here.  We&#39;re now trying to build the full name of E,</span>
<a name="l18254"></a>18254 <span class="comment">         and look over the parent DIE for containing scope.  In the</span>
<a name="l18255"></a>18255 <span class="comment">         broken case, if we followed the parent DIE of E, we&#39;d again</span>
<a name="l18256"></a>18256 <span class="comment">         find Class, and once again go look at its template type</span>
<a name="l18257"></a>18257 <span class="comment">         arguments, etc., etc.  Simply don&#39;t consider such parent die</span>
<a name="l18258"></a>18258 <span class="comment">         as source-level parent of this die (it can&#39;t be, the language</span>
<a name="l18259"></a>18259 <span class="comment">         doesn&#39;t allow it), and break the loop here.  */</span>
<a name="l18260"></a>18260       name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l18261"></a>18261       parent_name = <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (parent, cu);
<a name="l18262"></a>18262       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l18263"></a>18263                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;template param type &#39;%s&#39; defined within parent &#39;%s&#39;&quot;</span>),
<a name="l18264"></a>18264                  name ? name : <span class="stringliteral">&quot;&lt;unknown&gt;&quot;</span>,
<a name="l18265"></a>18265                  parent_name ? parent_name : <span class="stringliteral">&quot;&lt;unknown&gt;&quot;</span>);
<a name="l18266"></a>18266       <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l18267"></a>18267     }
<a name="l18268"></a>18268   <span class="keywordflow">else</span>
<a name="l18269"></a>18269     <span class="keywordflow">switch</span> (parent-&gt;tag)
<a name="l18270"></a>18270       {
<a name="l18271"></a>18271       <span class="keywordflow">case</span> DW_TAG_namespace:
<a name="l18272"></a>18272         parent_type = <a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (parent, cu);
<a name="l18273"></a>18273         <span class="comment">/* GCC 4.0 and 4.1 had a bug (PR c++/28460) where they generated bogus</span>
<a name="l18274"></a>18274 <span class="comment">           DW_TAG_namespace DIEs with a name of &quot;::&quot; for the global namespace.</span>
<a name="l18275"></a>18275 <span class="comment">           Work around this problem here.  */</span>
<a name="l18276"></a>18276         <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l18277"></a>18277             &amp;&amp; strcmp (<a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (parent_type), <span class="stringliteral">&quot;::&quot;</span>) == 0)
<a name="l18278"></a>18278           <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l18279"></a>18279         <span class="comment">/* We give a name to even anonymous namespaces.  */</span>
<a name="l18280"></a>18280         <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (parent_type);
<a name="l18281"></a>18281       <span class="keywordflow">case</span> DW_TAG_class_type:
<a name="l18282"></a>18282       <span class="keywordflow">case</span> DW_TAG_interface_type:
<a name="l18283"></a>18283       <span class="keywordflow">case</span> DW_TAG_structure_type:
<a name="l18284"></a>18284       <span class="keywordflow">case</span> DW_TAG_union_type:
<a name="l18285"></a>18285       <span class="keywordflow">case</span> DW_TAG_module:
<a name="l18286"></a>18286         parent_type = <a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (parent, cu);
<a name="l18287"></a>18287         <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (parent_type) != NULL)
<a name="l18288"></a>18288           <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (parent_type);
<a name="l18289"></a>18289         <span class="keywordflow">else</span>
<a name="l18290"></a>18290           <span class="comment">/* An anonymous structure is only allowed non-static data</span>
<a name="l18291"></a>18291 <span class="comment">             members; no typedefs, no member functions, et cetera.</span>
<a name="l18292"></a>18292 <span class="comment">             So it does not need a prefix.  */</span>
<a name="l18293"></a>18293           <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l18294"></a>18294       <span class="keywordflow">case</span> DW_TAG_compile_unit:
<a name="l18295"></a>18295       <span class="keywordflow">case</span> DW_TAG_partial_unit:
<a name="l18296"></a>18296         <span class="comment">/* gcc-4.5 -gdwarf-4 can drop the enclosing namespace.  Cope.  */</span>
<a name="l18297"></a>18297         <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>
<a name="l18298"></a>18298             &amp;&amp; !<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>, dwarf2_per_objfile-&gt;types)
<a name="l18299"></a>18299             &amp;&amp; die-&gt;child != NULL
<a name="l18300"></a>18300             &amp;&amp; (die-&gt;tag == DW_TAG_class_type
<a name="l18301"></a>18301                 || die-&gt;tag == DW_TAG_structure_type
<a name="l18302"></a>18302                 || die-&gt;tag == DW_TAG_union_type))
<a name="l18303"></a>18303           {
<a name="l18304"></a>18304             <span class="keywordtype">char</span> *name = <a class="code" href="dwarf2read_8c.html#a0d9409273e090033910508a49936aeaf">guess_full_die_structure_name</a> (die, cu);
<a name="l18305"></a>18305             <span class="keywordflow">if</span> (name != NULL)
<a name="l18306"></a>18306               <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l18307"></a>18307           }
<a name="l18308"></a>18308         <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l18309"></a>18309       <span class="keywordflow">default</span>:
<a name="l18310"></a>18310         <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a2417ea09b6b125e47a255352f662e856">determine_prefix</a> (parent, cu);
<a name="l18311"></a>18311       }
<a name="l18312"></a>18312 }
<a name="l18313"></a>18313 
<a name="l18314"></a>18314 <span class="comment">/* Return a newly-allocated string formed by concatenating PREFIX and SUFFIX</span>
<a name="l18315"></a>18315 <span class="comment">   with appropriate separator.  If PREFIX or SUFFIX is NULL or empty, then</span>
<a name="l18316"></a>18316 <span class="comment">   simply copy the SUFFIX or PREFIX, respectively.  If OBS is non-null, perform</span>
<a name="l18317"></a>18317 <span class="comment">   an obconcat, otherwise allocate storage for the result.  The CU argument is</span>
<a name="l18318"></a>18318 <span class="comment">   used to determine the language and hence, the appropriate separator.  */</span>
<a name="l18319"></a>18319 
<a name="l18320"></a><a class="code" href="dwarf2read_8c.html#a7e808530d236eab9744b23836a99d944">18320</a> <span class="preprocessor">#define MAX_SEP_LEN 7  </span><span class="comment">/* strlen (&quot;__&quot;) + strlen (&quot;_MOD_&quot;)  */</span>
<a name="l18321"></a>18321 
<a name="l18322"></a>18322 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l18323"></a><a class="code" href="dwarf2read_8c.html#a6abe45afe642868fb22402ce7349ad7f">18323</a> <a class="code" href="dwarf2read_8c.html#a6abe45afe642868fb22402ce7349ad7f">typename_concat</a> (<span class="keyword">struct</span> obstack *obs, <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix, <span class="keyword">const</span> <span class="keywordtype">char</span> *suffix,
<a name="l18324"></a>18324                  <span class="keywordtype">int</span> physname, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l18325"></a>18325 {
<a name="l18326"></a>18326   <span class="keyword">const</span> <span class="keywordtype">char</span> *lead = <span class="stringliteral">&quot;&quot;</span>;
<a name="l18327"></a>18327   <span class="keyword">const</span> <span class="keywordtype">char</span> *sep;
<a name="l18328"></a>18328 
<a name="l18329"></a>18329   <span class="keywordflow">if</span> (suffix == NULL || suffix[0] == <span class="charliteral">&#39;\0&#39;</span>
<a name="l18330"></a>18330       || prefix == NULL || prefix[0] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l18331"></a>18331     sep = <span class="stringliteral">&quot;&quot;</span>;
<a name="l18332"></a>18332   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>)
<a name="l18333"></a>18333     sep = <span class="stringliteral">&quot;.&quot;</span>;
<a name="l18334"></a>18334   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a9c3ffaaf7e0e54084c4529d76e9bdc92">language_fortran</a> &amp;&amp; physname)
<a name="l18335"></a>18335     {
<a name="l18336"></a>18336       <span class="comment">/* This is gfortran specific mangling.  Normally DW_AT_linkage_name or</span>
<a name="l18337"></a>18337 <span class="comment">         DW_AT_MIPS_linkage_name is preferred and used instead.  */</span>
<a name="l18338"></a>18338 
<a name="l18339"></a>18339       lead = <span class="stringliteral">&quot;__&quot;</span>;
<a name="l18340"></a>18340       sep = <span class="stringliteral">&quot;_MOD_&quot;</span>;
<a name="l18341"></a>18341     }
<a name="l18342"></a>18342   <span class="keywordflow">else</span>
<a name="l18343"></a>18343     sep = <span class="stringliteral">&quot;::&quot;</span>;
<a name="l18344"></a>18344 
<a name="l18345"></a>18345   <span class="keywordflow">if</span> (prefix == NULL)
<a name="l18346"></a>18346     prefix = <span class="stringliteral">&quot;&quot;</span>;
<a name="l18347"></a>18347   <span class="keywordflow">if</span> (suffix == NULL)
<a name="l18348"></a>18348     suffix = <span class="stringliteral">&quot;&quot;</span>;
<a name="l18349"></a>18349 
<a name="l18350"></a>18350   <span class="keywordflow">if</span> (obs == NULL)
<a name="l18351"></a>18351     {
<a name="l18352"></a>18352       <span class="keywordtype">char</span> *retval
<a name="l18353"></a>18353         = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (strlen (prefix) + <a class="code" href="dwarf2read_8c.html#a7e808530d236eab9744b23836a99d944">MAX_SEP_LEN</a> + strlen (suffix) + 1);
<a name="l18354"></a>18354 
<a name="l18355"></a>18355       strcpy (retval, lead);
<a name="l18356"></a>18356       strcat (retval, prefix);
<a name="l18357"></a>18357       strcat (retval, sep);
<a name="l18358"></a>18358       strcat (retval, suffix);
<a name="l18359"></a>18359       <span class="keywordflow">return</span> retval;
<a name="l18360"></a>18360     }
<a name="l18361"></a>18361   <span class="keywordflow">else</span>
<a name="l18362"></a>18362     {
<a name="l18363"></a>18363       <span class="comment">/* We have an obstack.  */</span>
<a name="l18364"></a>18364       <span class="keywordflow">return</span> <a class="code" href="gdb__obstack_8c.html#acb9aae13bbc489afdf51994a923ef45a">obconcat</a> (obs, lead, prefix, sep, suffix, (<span class="keywordtype">char</span> *) NULL);
<a name="l18365"></a>18365     }
<a name="l18366"></a>18366 }
<a name="l18367"></a>18367 
<a name="l18368"></a>18368 <span class="comment">/* Return sibling of die, NULL if no sibling.  */</span>
<a name="l18369"></a>18369 
<a name="l18370"></a>18370 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *
<a name="l18371"></a><a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">18371</a> <a class="code" href="dwarf2read_8c.html#afe366bd2649946d12a24173696f64aca">sibling_die</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die)
<a name="l18372"></a>18372 {
<a name="l18373"></a>18373   <span class="keywordflow">return</span> die-&gt;sibling;
<a name="l18374"></a>18374 }
<a name="l18375"></a>18375 
<a name="l18376"></a>18376 <span class="comment">/* Get name of a die, return NULL if not found.  */</span>
<a name="l18377"></a>18377 
<a name="l18378"></a>18378 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l18379"></a><a class="code" href="dwarf2read_8c.html#a15617623710ce00d6f31263aad9bd432">18379</a> <a class="code" href="dwarf2read_8c.html#a15617623710ce00d6f31263aad9bd432">dwarf2_canonicalize_name</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l18380"></a>18380                           <span class="keyword">struct</span> obstack *obstack)
<a name="l18381"></a>18381 {
<a name="l18382"></a>18382   <span class="keywordflow">if</span> (name &amp;&amp; cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>)
<a name="l18383"></a>18383     {
<a name="l18384"></a>18384       <span class="keywordtype">char</span> *canon_name = <a class="code" href="cp-support_8c.html#a8fdbec9f6e31d857cb084d73ec5a62f8">cp_canonicalize_string</a> (name);
<a name="l18385"></a>18385 
<a name="l18386"></a>18386       <span class="keywordflow">if</span> (canon_name != NULL)
<a name="l18387"></a>18387         {
<a name="l18388"></a>18388           <span class="keywordflow">if</span> (strcmp (canon_name, name) != 0)
<a name="l18389"></a>18389             name = obstack_copy0 (obstack, canon_name, strlen (canon_name));
<a name="l18390"></a>18390           <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (canon_name);
<a name="l18391"></a>18391         }
<a name="l18392"></a>18392     }
<a name="l18393"></a>18393 
<a name="l18394"></a>18394   <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l18395"></a>18395 }
<a name="l18396"></a>18396 
<a name="l18397"></a>18397 <span class="comment">/* Get name of a die, return NULL if not found.  */</span>
<a name="l18398"></a>18398 
<a name="l18399"></a>18399 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l18400"></a><a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">18400</a> <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l18401"></a>18401 {
<a name="l18402"></a>18402   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l18403"></a>18403 
<a name="l18404"></a>18404   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_name, cu);
<a name="l18405"></a>18405   <span class="keywordflow">if</span> ((!attr || !<a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr))
<a name="l18406"></a>18406       &amp;&amp; die-&gt;tag != DW_TAG_class_type
<a name="l18407"></a>18407       &amp;&amp; die-&gt;tag != DW_TAG_interface_type
<a name="l18408"></a>18408       &amp;&amp; die-&gt;tag != DW_TAG_structure_type
<a name="l18409"></a>18409       &amp;&amp; die-&gt;tag != DW_TAG_union_type)
<a name="l18410"></a>18410     <span class="keywordflow">return</span> NULL;
<a name="l18411"></a>18411 
<a name="l18412"></a>18412   <span class="keywordflow">switch</span> (die-&gt;tag)
<a name="l18413"></a>18413     {
<a name="l18414"></a>18414     <span class="keywordflow">case</span> DW_TAG_compile_unit:
<a name="l18415"></a>18415     <span class="keywordflow">case</span> DW_TAG_partial_unit:
<a name="l18416"></a>18416       <span class="comment">/* Compilation units have a DW_AT_name that is a filename, not</span>
<a name="l18417"></a>18417 <span class="comment">         a source language identifier.  */</span>
<a name="l18418"></a>18418     <span class="keywordflow">case</span> DW_TAG_enumeration_type:
<a name="l18419"></a>18419     <span class="keywordflow">case</span> DW_TAG_enumerator:
<a name="l18420"></a>18420       <span class="comment">/* These tags always have simple identifiers already; no need</span>
<a name="l18421"></a>18421 <span class="comment">         to canonicalize them.  */</span>
<a name="l18422"></a>18422       <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr);
<a name="l18423"></a>18423 
<a name="l18424"></a>18424     <span class="keywordflow">case</span> DW_TAG_subprogram:
<a name="l18425"></a>18425       <span class="comment">/* Java constructors will all be named &quot;&lt;init&gt;&quot;, so return</span>
<a name="l18426"></a>18426 <span class="comment">         the class name when we see this special case.  */</span>
<a name="l18427"></a>18427       <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>
<a name="l18428"></a>18428           &amp;&amp; <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr) != NULL
<a name="l18429"></a>18429           &amp;&amp; strcmp (<a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr), <span class="stringliteral">&quot;&lt;init&gt;&quot;</span>) == 0)
<a name="l18430"></a>18430         {
<a name="l18431"></a>18431           <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *spec_cu = cu;
<a name="l18432"></a>18432           <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *spec_die;
<a name="l18433"></a>18433 
<a name="l18434"></a>18434           <span class="comment">/* GCJ will output &#39;&lt;init&gt;&#39; for Java constructor names.</span>
<a name="l18435"></a>18435 <span class="comment">             For this special case, return the name of the parent class.  */</span>
<a name="l18436"></a>18436 
<a name="l18437"></a>18437           <span class="comment">/* GCJ may output suprogram DIEs with AT_specification set.</span>
<a name="l18438"></a>18438 <span class="comment">             If so, use the name of the specified DIE.  */</span>
<a name="l18439"></a>18439           spec_die = <a class="code" href="dwarf2read_8c.html#a86adfa4fccde4cd4c512ca520e5bb1d7">die_specification</a> (die, &amp;spec_cu);
<a name="l18440"></a>18440           <span class="keywordflow">if</span> (spec_die != NULL)
<a name="l18441"></a>18441             <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (spec_die, spec_cu);
<a name="l18442"></a>18442 
<a name="l18443"></a>18443           <span class="keywordflow">do</span>
<a name="l18444"></a>18444             {
<a name="l18445"></a>18445               die = die-&gt;parent;
<a name="l18446"></a>18446               <span class="keywordflow">if</span> (die-&gt;tag == DW_TAG_class_type)
<a name="l18447"></a>18447                 <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#ac7176390b41777b684253fe89bcacd14">dwarf2_name</a> (die, cu);
<a name="l18448"></a>18448             }
<a name="l18449"></a>18449           <span class="keywordflow">while</span> (die-&gt;tag != DW_TAG_compile_unit
<a name="l18450"></a>18450                  &amp;&amp; die-&gt;tag != DW_TAG_partial_unit);
<a name="l18451"></a>18451         }
<a name="l18452"></a>18452       <span class="keywordflow">break</span>;
<a name="l18453"></a>18453 
<a name="l18454"></a>18454     <span class="keywordflow">case</span> DW_TAG_class_type:
<a name="l18455"></a>18455     <span class="keywordflow">case</span> DW_TAG_interface_type:
<a name="l18456"></a>18456     <span class="keywordflow">case</span> DW_TAG_structure_type:
<a name="l18457"></a>18457     <span class="keywordflow">case</span> DW_TAG_union_type:
<a name="l18458"></a>18458       <span class="comment">/* Some GCC versions emit spurious DW_AT_name attributes for unnamed</span>
<a name="l18459"></a>18459 <span class="comment">         structures or unions.  These were of the form &quot;._%d&quot; in GCC 4.1,</span>
<a name="l18460"></a>18460 <span class="comment">         or simply &quot;&lt;anonymous struct&gt;&quot; or &quot;&lt;anonymous union&gt;&quot; in GCC 4.3</span>
<a name="l18461"></a>18461 <span class="comment">         and GCC 4.4.  We work around this problem by ignoring these.  */</span>
<a name="l18462"></a>18462       <span class="keywordflow">if</span> (attr &amp;&amp; <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr)
<a name="l18463"></a>18463           &amp;&amp; (strncmp (<a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr), <span class="stringliteral">&quot;._&quot;</span>, 2) == 0
<a name="l18464"></a>18464               || strncmp (<a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr), <span class="stringliteral">&quot;&lt;anonymous&quot;</span>, 10) == 0))
<a name="l18465"></a>18465         <span class="keywordflow">return</span> NULL;
<a name="l18466"></a>18466 
<a name="l18467"></a>18467       <span class="comment">/* GCC might emit a nameless typedef that has a linkage name.  See</span>
<a name="l18468"></a>18468 <span class="comment">         http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47510.  */</span>
<a name="l18469"></a>18469       <span class="keywordflow">if</span> (!attr || <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr) == NULL)
<a name="l18470"></a>18470         {
<a name="l18471"></a>18471           <span class="keywordtype">char</span> *demangled = NULL;
<a name="l18472"></a>18472 
<a name="l18473"></a>18473           attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_linkage_name, cu);
<a name="l18474"></a>18474           <span class="keywordflow">if</span> (attr == NULL)
<a name="l18475"></a>18475             attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_MIPS_linkage_name, cu);
<a name="l18476"></a>18476 
<a name="l18477"></a>18477           <span class="keywordflow">if</span> (attr == NULL || <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr) == NULL)
<a name="l18478"></a>18478             <span class="keywordflow">return</span> NULL;
<a name="l18479"></a>18479 
<a name="l18480"></a>18480           <span class="comment">/* Avoid demangling DW_STRING (attr) the second time on a second</span>
<a name="l18481"></a>18481 <span class="comment">             call for the same DIE.  */</span>
<a name="l18482"></a>18482           <span class="keywordflow">if</span> (!<a class="code" href="dwarf2read_8c.html#a307f18e0d403d80487696d1a0a5d0fd6">DW_STRING_IS_CANONICAL</a> (attr))
<a name="l18483"></a>18483             demangled = <a class="code" href="cp-support_8c.html#aa3fac1cb74e2709738e9ab3af7aac6b6">gdb_demangle</a> (<a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr), DMGL_TYPES);
<a name="l18484"></a>18484 
<a name="l18485"></a>18485           <span class="keywordflow">if</span> (demangled)
<a name="l18486"></a>18486             {
<a name="l18487"></a>18487               <span class="keywordtype">char</span> *base;
<a name="l18488"></a>18488 
<a name="l18489"></a>18489               <span class="comment">/* FIXME: we already did this for the partial symbol... */</span>
<a name="l18490"></a>18490               <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr) = obstack_copy0 (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l18491"></a>18491                                                 demangled, strlen (demangled));
<a name="l18492"></a>18492               <a class="code" href="dwarf2read_8c.html#a307f18e0d403d80487696d1a0a5d0fd6">DW_STRING_IS_CANONICAL</a> (attr) = 1;
<a name="l18493"></a>18493               <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (demangled);
<a name="l18494"></a>18494 
<a name="l18495"></a>18495               <span class="comment">/* Strip any leading namespaces/classes, keep only the base name.</span>
<a name="l18496"></a>18496 <span class="comment">                 DW_AT_name for named DIEs does not contain the prefixes.  */</span>
<a name="l18497"></a>18497               base = <a class="code" href="gdb__string_8h.html#a5cbb8bbfc7174d9468b1853f1031efb3">strrchr</a> (<a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr), <span class="charliteral">&#39;:&#39;</span>);
<a name="l18498"></a>18498               <span class="keywordflow">if</span> (base &amp;&amp; base &gt; <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr) &amp;&amp; base[-1] == <span class="charliteral">&#39;:&#39;</span>)
<a name="l18499"></a>18499                 <span class="keywordflow">return</span> &amp;base[1];
<a name="l18500"></a>18500               <span class="keywordflow">else</span>
<a name="l18501"></a>18501                 <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr);
<a name="l18502"></a>18502             }
<a name="l18503"></a>18503         }
<a name="l18504"></a>18504       <span class="keywordflow">break</span>;
<a name="l18505"></a>18505 
<a name="l18506"></a>18506     <span class="keywordflow">default</span>:
<a name="l18507"></a>18507       <span class="keywordflow">break</span>;
<a name="l18508"></a>18508     }
<a name="l18509"></a>18509 
<a name="l18510"></a>18510   <span class="keywordflow">if</span> (!<a class="code" href="dwarf2read_8c.html#a307f18e0d403d80487696d1a0a5d0fd6">DW_STRING_IS_CANONICAL</a> (attr))
<a name="l18511"></a>18511     {
<a name="l18512"></a>18512       <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr)
<a name="l18513"></a>18513         = <a class="code" href="dwarf2read_8c.html#a15617623710ce00d6f31263aad9bd432">dwarf2_canonicalize_name</a> (<a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr), cu,
<a name="l18514"></a>18514                                     &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>);
<a name="l18515"></a>18515       <a class="code" href="dwarf2read_8c.html#a307f18e0d403d80487696d1a0a5d0fd6">DW_STRING_IS_CANONICAL</a> (attr) = 1;
<a name="l18516"></a>18516     }
<a name="l18517"></a>18517   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr);
<a name="l18518"></a>18518 }
<a name="l18519"></a>18519 
<a name="l18520"></a>18520 <span class="comment">/* Return the die that this die in an extension of, or NULL if there</span>
<a name="l18521"></a>18521 <span class="comment">   is none.  *EXT_CU is the CU containing DIE on input, and the CU</span>
<a name="l18522"></a>18522 <span class="comment">   containing the return value on output.  */</span>
<a name="l18523"></a>18523 
<a name="l18524"></a>18524 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *
<a name="l18525"></a><a class="code" href="dwarf2read_8c.html#a8308114946895d0f9cb9c1ff8a92d115">18525</a> <a class="code" href="dwarf2read_8c.html#a8308114946895d0f9cb9c1ff8a92d115">dwarf2_extension</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> **ext_cu)
<a name="l18526"></a>18526 {
<a name="l18527"></a>18527   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l18528"></a>18528 
<a name="l18529"></a>18529   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_extension, *ext_cu);
<a name="l18530"></a>18530   <span class="keywordflow">if</span> (attr == NULL)
<a name="l18531"></a>18531     <span class="keywordflow">return</span> NULL;
<a name="l18532"></a>18532 
<a name="l18533"></a>18533   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a079b531fef51cfc34f92ff6fde2ef8a4">follow_die_ref</a> (die, attr, ext_cu);
<a name="l18534"></a>18534 }
<a name="l18535"></a>18535 
<a name="l18536"></a>18536 <span class="comment">/* Convert a DIE tag into its string name.  */</span>
<a name="l18537"></a>18537 
<a name="l18538"></a>18538 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l18539"></a><a class="code" href="dwarf2read_8c.html#af80d37a7ff366081b096550409d46e45">18539</a> <a class="code" href="dwarf2read_8c.html#af80d37a7ff366081b096550409d46e45">dwarf_tag_name</a> (<span class="keywordtype">unsigned</span> tag)
<a name="l18540"></a>18540 {
<a name="l18541"></a>18541   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = get_DW_TAG_name (tag);
<a name="l18542"></a>18542 
<a name="l18543"></a>18543   <span class="keywordflow">if</span> (name == NULL)
<a name="l18544"></a>18544     <span class="keywordflow">return</span> <span class="stringliteral">&quot;DW_TAG_&lt;unknown&gt;&quot;</span>;
<a name="l18545"></a>18545 
<a name="l18546"></a>18546   <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l18547"></a>18547 }
<a name="l18548"></a>18548 
<a name="l18549"></a>18549 <span class="comment">/* Convert a DWARF attribute code into its string name.  */</span>
<a name="l18550"></a>18550 
<a name="l18551"></a>18551 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l18552"></a><a class="code" href="dwarf2read_8c.html#a9cf5304ec3b94ab9e1786529ad97338b">18552</a> <a class="code" href="dwarf2read_8c.html#a9cf5304ec3b94ab9e1786529ad97338b">dwarf_attr_name</a> (<span class="keywordtype">unsigned</span> attr)
<a name="l18553"></a>18553 {
<a name="l18554"></a>18554   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l18555"></a>18555 
<a name="l18556"></a>18556 <span class="preprocessor">#ifdef MIPS </span><span class="comment">/* collides with DW_AT_HP_block_index */</span>
<a name="l18557"></a>18557   <span class="keywordflow">if</span> (attr == DW_AT_MIPS_fde)
<a name="l18558"></a>18558     <span class="keywordflow">return</span> <span class="stringliteral">&quot;DW_AT_MIPS_fde&quot;</span>;
<a name="l18559"></a>18559 <span class="preprocessor">#else</span>
<a name="l18560"></a>18560 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (attr == DW_AT_HP_block_index)
<a name="l18561"></a>18561     <span class="keywordflow">return</span> <span class="stringliteral">&quot;DW_AT_HP_block_index&quot;</span>;
<a name="l18562"></a>18562 <span class="preprocessor">#endif</span>
<a name="l18563"></a>18563 <span class="preprocessor"></span>
<a name="l18564"></a>18564   name = get_DW_AT_name (attr);
<a name="l18565"></a>18565 
<a name="l18566"></a>18566   <span class="keywordflow">if</span> (name == NULL)
<a name="l18567"></a>18567     <span class="keywordflow">return</span> <span class="stringliteral">&quot;DW_AT_&lt;unknown&gt;&quot;</span>;
<a name="l18568"></a>18568 
<a name="l18569"></a>18569   <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l18570"></a>18570 }
<a name="l18571"></a>18571 
<a name="l18572"></a>18572 <span class="comment">/* Convert a DWARF value form code into its string name.  */</span>
<a name="l18573"></a>18573 
<a name="l18574"></a>18574 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l18575"></a><a class="code" href="dwarf2read_8c.html#a6810653c49d4b3be30290dc1bcf20c94">18575</a> <a class="code" href="dwarf2read_8c.html#a6810653c49d4b3be30290dc1bcf20c94">dwarf_form_name</a> (<span class="keywordtype">unsigned</span> form)
<a name="l18576"></a>18576 {
<a name="l18577"></a>18577   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = get_DW_FORM_name (form);
<a name="l18578"></a>18578 
<a name="l18579"></a>18579   <span class="keywordflow">if</span> (name == NULL)
<a name="l18580"></a>18580     <span class="keywordflow">return</span> <span class="stringliteral">&quot;DW_FORM_&lt;unknown&gt;&quot;</span>;
<a name="l18581"></a>18581 
<a name="l18582"></a>18582   <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l18583"></a>18583 }
<a name="l18584"></a>18584 
<a name="l18585"></a>18585 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l18586"></a><a class="code" href="dwarf2read_8c.html#ad4ab7046a0a5b2c18a47b2e3eb36c5b6">18586</a> <a class="code" href="dwarf2read_8c.html#ad4ab7046a0a5b2c18a47b2e3eb36c5b6">dwarf_bool_name</a> (<span class="keywordtype">unsigned</span> mybool)
<a name="l18587"></a>18587 {
<a name="l18588"></a>18588   <span class="keywordflow">if</span> (mybool)
<a name="l18589"></a>18589     <span class="keywordflow">return</span> <span class="stringliteral">&quot;TRUE&quot;</span>;
<a name="l18590"></a>18590   <span class="keywordflow">else</span>
<a name="l18591"></a>18591     <span class="keywordflow">return</span> <span class="stringliteral">&quot;FALSE&quot;</span>;
<a name="l18592"></a>18592 }
<a name="l18593"></a>18593 
<a name="l18594"></a>18594 <span class="comment">/* Convert a DWARF type code into its string name.  */</span>
<a name="l18595"></a>18595 
<a name="l18596"></a>18596 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l18597"></a><a class="code" href="dwarf2read_8c.html#a0a45f38cd8954cc90b8f97f03e1effd3">18597</a> <a class="code" href="dwarf2read_8c.html#a0a45f38cd8954cc90b8f97f03e1effd3">dwarf_type_encoding_name</a> (<span class="keywordtype">unsigned</span> enc)
<a name="l18598"></a>18598 {
<a name="l18599"></a>18599   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = get_DW_ATE_name (enc);
<a name="l18600"></a>18600 
<a name="l18601"></a>18601   <span class="keywordflow">if</span> (name == NULL)
<a name="l18602"></a>18602     <span class="keywordflow">return</span> <span class="stringliteral">&quot;DW_ATE_&lt;unknown&gt;&quot;</span>;
<a name="l18603"></a>18603 
<a name="l18604"></a>18604   <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l18605"></a>18605 }
<a name="l18606"></a>18606 
<a name="l18607"></a>18607 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l18608"></a><a class="code" href="dwarf2read_8c.html#a7e3db4d14d7ec766f3db21faff32e214">18608</a> <a class="code" href="dwarf2read_8c.html#a7e3db4d14d7ec766f3db21faff32e214">dump_die_shallow</a> (<span class="keyword">struct</span> <a class="code" href="structui__file.html">ui_file</a> *f, <span class="keywordtype">int</span> indent, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die)
<a name="l18609"></a>18609 {
<a name="l18610"></a>18610   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l18611"></a>18611 
<a name="l18612"></a>18612   <a class="code" href="utils_8c.html#a2fd01c2e194426a2c39db249457dba9b">print_spaces</a> (indent, f);
<a name="l18613"></a>18613   <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;Die: %s (abbrev %d, offset 0x%x)\n&quot;</span>,
<a name="l18614"></a>18614            <a class="code" href="dwarf2read_8c.html#af80d37a7ff366081b096550409d46e45">dwarf_tag_name</a> (die-&gt;tag), die-&gt;abbrev, die-&gt;offset.sect_off);
<a name="l18615"></a>18615 
<a name="l18616"></a>18616   <span class="keywordflow">if</span> (die-&gt;parent != NULL)
<a name="l18617"></a>18617     {
<a name="l18618"></a>18618       <a class="code" href="utils_8c.html#a2fd01c2e194426a2c39db249457dba9b">print_spaces</a> (indent, f);
<a name="l18619"></a>18619       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;  parent at offset: 0x%x\n&quot;</span>,
<a name="l18620"></a>18620                           die-&gt;parent-&gt;offset.sect_off);
<a name="l18621"></a>18621     }
<a name="l18622"></a>18622 
<a name="l18623"></a>18623   <a class="code" href="utils_8c.html#a2fd01c2e194426a2c39db249457dba9b">print_spaces</a> (indent, f);
<a name="l18624"></a>18624   <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;  has children: %s\n&quot;</span>,
<a name="l18625"></a>18625            <a class="code" href="dwarf2read_8c.html#ad4ab7046a0a5b2c18a47b2e3eb36c5b6">dwarf_bool_name</a> (die-&gt;child != NULL));
<a name="l18626"></a>18626 
<a name="l18627"></a>18627   <a class="code" href="utils_8c.html#a2fd01c2e194426a2c39db249457dba9b">print_spaces</a> (indent, f);
<a name="l18628"></a>18628   <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;  attributes:\n&quot;</span>);
<a name="l18629"></a>18629 
<a name="l18630"></a>18630   <span class="keywordflow">for</span> (i = 0; i &lt; die-&gt;num_attrs; ++i)
<a name="l18631"></a>18631     {
<a name="l18632"></a>18632       <a class="code" href="utils_8c.html#a2fd01c2e194426a2c39db249457dba9b">print_spaces</a> (indent, f);
<a name="l18633"></a>18633       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;    %s (%s) &quot;</span>,
<a name="l18634"></a>18634                <a class="code" href="dwarf2read_8c.html#a9cf5304ec3b94ab9e1786529ad97338b">dwarf_attr_name</a> (die-&gt;attrs[i].name),
<a name="l18635"></a>18635                <a class="code" href="dwarf2read_8c.html#a6810653c49d4b3be30290dc1bcf20c94">dwarf_form_name</a> (die-&gt;attrs[i].form));
<a name="l18636"></a>18636 
<a name="l18637"></a>18637       <span class="keywordflow">switch</span> (die-&gt;attrs[i].form)
<a name="l18638"></a>18638         {
<a name="l18639"></a>18639         <span class="keywordflow">case</span> DW_FORM_addr:
<a name="l18640"></a>18640         <span class="keywordflow">case</span> DW_FORM_GNU_addr_index:
<a name="l18641"></a>18641           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;address: &quot;</span>);
<a name="l18642"></a>18642           <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (<a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (&amp;die-&gt;attrs[i])), f);
<a name="l18643"></a>18643           <span class="keywordflow">break</span>;
<a name="l18644"></a>18644         <span class="keywordflow">case</span> DW_FORM_block2:
<a name="l18645"></a>18645         <span class="keywordflow">case</span> DW_FORM_block4:
<a name="l18646"></a>18646         <span class="keywordflow">case</span> DW_FORM_block:
<a name="l18647"></a>18647         <span class="keywordflow">case</span> DW_FORM_block1:
<a name="l18648"></a>18648           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;block: size %s&quot;</span>,
<a name="l18649"></a>18649                               <a class="code" href="utils_8c.html#ab74ba9d12a782e5964a4af4ddc5de3ae">pulongest</a> (<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (&amp;die-&gt;attrs[i])-&gt;size));
<a name="l18650"></a>18650           <span class="keywordflow">break</span>;
<a name="l18651"></a>18651         <span class="keywordflow">case</span> DW_FORM_exprloc:
<a name="l18652"></a>18652           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;expression: size %s&quot;</span>,
<a name="l18653"></a>18653                               <a class="code" href="utils_8c.html#ab74ba9d12a782e5964a4af4ddc5de3ae">pulongest</a> (<a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (&amp;die-&gt;attrs[i])-&gt;size));
<a name="l18654"></a>18654           <span class="keywordflow">break</span>;
<a name="l18655"></a>18655         <span class="keywordflow">case</span> DW_FORM_ref_addr:
<a name="l18656"></a>18656           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;ref address: &quot;</span>);
<a name="l18657"></a>18657           <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (&amp;die-&gt;attrs[i])), f);
<a name="l18658"></a>18658           <span class="keywordflow">break</span>;
<a name="l18659"></a>18659         <span class="keywordflow">case</span> DW_FORM_GNU_ref_alt:
<a name="l18660"></a>18660           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;alt ref address: &quot;</span>);
<a name="l18661"></a>18661           <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (&amp;die-&gt;attrs[i])), f);
<a name="l18662"></a>18662           <span class="keywordflow">break</span>;
<a name="l18663"></a>18663         <span class="keywordflow">case</span> DW_FORM_ref1:
<a name="l18664"></a>18664         <span class="keywordflow">case</span> DW_FORM_ref2:
<a name="l18665"></a>18665         <span class="keywordflow">case</span> DW_FORM_ref4:
<a name="l18666"></a>18666         <span class="keywordflow">case</span> DW_FORM_ref8:
<a name="l18667"></a>18667         <span class="keywordflow">case</span> DW_FORM_ref_udata:
<a name="l18668"></a>18668           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;constant ref: 0x%lx (adjusted)&quot;</span>,
<a name="l18669"></a>18669                               (<span class="keywordtype">long</span>) (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (&amp;die-&gt;attrs[i])));
<a name="l18670"></a>18670           <span class="keywordflow">break</span>;
<a name="l18671"></a>18671         <span class="keywordflow">case</span> DW_FORM_data1:
<a name="l18672"></a>18672         <span class="keywordflow">case</span> DW_FORM_data2:
<a name="l18673"></a>18673         <span class="keywordflow">case</span> DW_FORM_data4:
<a name="l18674"></a>18674         <span class="keywordflow">case</span> DW_FORM_data8:
<a name="l18675"></a>18675         <span class="keywordflow">case</span> DW_FORM_udata:
<a name="l18676"></a>18676         <span class="keywordflow">case</span> DW_FORM_sdata:
<a name="l18677"></a>18677           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;constant: %s&quot;</span>,
<a name="l18678"></a>18678                               <a class="code" href="utils_8c.html#ab74ba9d12a782e5964a4af4ddc5de3ae">pulongest</a> (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (&amp;die-&gt;attrs[i])));
<a name="l18679"></a>18679           <span class="keywordflow">break</span>;
<a name="l18680"></a>18680         <span class="keywordflow">case</span> DW_FORM_sec_offset:
<a name="l18681"></a>18681           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;section offset: %s&quot;</span>,
<a name="l18682"></a>18682                               <a class="code" href="utils_8c.html#ab74ba9d12a782e5964a4af4ddc5de3ae">pulongest</a> (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (&amp;die-&gt;attrs[i])));
<a name="l18683"></a>18683           <span class="keywordflow">break</span>;
<a name="l18684"></a>18684         <span class="keywordflow">case</span> DW_FORM_ref_sig8:
<a name="l18685"></a>18685           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;signature: %s&quot;</span>,
<a name="l18686"></a>18686                               <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (<a class="code" href="dwarf2read_8c.html#a8ba60632a90cfabc155c69f0bf2d2f83">DW_SIGNATURE</a> (&amp;die-&gt;attrs[i])));
<a name="l18687"></a>18687           <span class="keywordflow">break</span>;
<a name="l18688"></a>18688         <span class="keywordflow">case</span> DW_FORM_string:
<a name="l18689"></a>18689         <span class="keywordflow">case</span> DW_FORM_strp:
<a name="l18690"></a>18690         <span class="keywordflow">case</span> DW_FORM_GNU_str_index:
<a name="l18691"></a>18691         <span class="keywordflow">case</span> DW_FORM_GNU_strp_alt:
<a name="l18692"></a>18692           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;string: \&quot;%s\&quot; (%s canonicalized)&quot;</span>,
<a name="l18693"></a>18693                    <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (&amp;die-&gt;attrs[i])
<a name="l18694"></a>18694                    ? <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (&amp;die-&gt;attrs[i]) : <span class="stringliteral">&quot;&quot;</span>,
<a name="l18695"></a>18695                    <a class="code" href="dwarf2read_8c.html#a307f18e0d403d80487696d1a0a5d0fd6">DW_STRING_IS_CANONICAL</a> (&amp;die-&gt;attrs[i]) ? <span class="stringliteral">&quot;is&quot;</span> : <span class="stringliteral">&quot;not&quot;</span>);
<a name="l18696"></a>18696           <span class="keywordflow">break</span>;
<a name="l18697"></a>18697         <span class="keywordflow">case</span> DW_FORM_flag:
<a name="l18698"></a>18698           <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (&amp;die-&gt;attrs[i]))
<a name="l18699"></a>18699             <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;flag: TRUE&quot;</span>);
<a name="l18700"></a>18700           <span class="keywordflow">else</span>
<a name="l18701"></a>18701             <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;flag: FALSE&quot;</span>);
<a name="l18702"></a>18702           <span class="keywordflow">break</span>;
<a name="l18703"></a>18703         <span class="keywordflow">case</span> DW_FORM_flag_present:
<a name="l18704"></a>18704           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;flag: TRUE&quot;</span>);
<a name="l18705"></a>18705           <span class="keywordflow">break</span>;
<a name="l18706"></a>18706         <span class="keywordflow">case</span> DW_FORM_indirect:
<a name="l18707"></a>18707           <span class="comment">/* The reader will have reduced the indirect form to</span>
<a name="l18708"></a>18708 <span class="comment">             the &quot;base form&quot; so this form should not occur.  */</span>
<a name="l18709"></a>18709           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, 
<a name="l18710"></a>18710                               <span class="stringliteral">&quot;unexpected attribute form: DW_FORM_indirect&quot;</span>);
<a name="l18711"></a>18711           <span class="keywordflow">break</span>;
<a name="l18712"></a>18712         <span class="keywordflow">default</span>:
<a name="l18713"></a>18713           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;unsupported attribute form: %d.&quot;</span>,
<a name="l18714"></a>18714                    die-&gt;attrs[i].form);
<a name="l18715"></a>18715           <span class="keywordflow">break</span>;
<a name="l18716"></a>18716         }
<a name="l18717"></a>18717       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l18718"></a>18718     }
<a name="l18719"></a>18719 }
<a name="l18720"></a>18720 
<a name="l18721"></a>18721 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l18722"></a><a class="code" href="dwarf2read_8c.html#a6e4e3ec89be5cd344456da9d82bc20d7">18722</a> <a class="code" href="dwarf2read_8c.html#a6e4e3ec89be5cd344456da9d82bc20d7">dump_die_for_error</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die)
<a name="l18723"></a>18723 {
<a name="l18724"></a>18724   <a class="code" href="dwarf2read_8c.html#a7e3db4d14d7ec766f3db21faff32e214">dump_die_shallow</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, 0, die);
<a name="l18725"></a>18725 }
<a name="l18726"></a>18726 
<a name="l18727"></a>18727 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l18728"></a><a class="code" href="dwarf2read_8c.html#a9eb6c811f2245f1b4af3e337d3746c76">18728</a> <a class="code" href="dwarf2read_8c.html#a9eb6c811f2245f1b4af3e337d3746c76">dump_die_1</a> (<span class="keyword">struct</span> <a class="code" href="structui__file.html">ui_file</a> *f, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> max_level, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die)
<a name="l18729"></a>18729 {
<a name="l18730"></a>18730   <span class="keywordtype">int</span> indent = level * 4;
<a name="l18731"></a>18731 
<a name="l18732"></a>18732   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (die != NULL);
<a name="l18733"></a>18733 
<a name="l18734"></a>18734   <span class="keywordflow">if</span> (level &gt;= max_level)
<a name="l18735"></a>18735     <span class="keywordflow">return</span>;
<a name="l18736"></a>18736 
<a name="l18737"></a>18737   <a class="code" href="dwarf2read_8c.html#a7e3db4d14d7ec766f3db21faff32e214">dump_die_shallow</a> (f, indent, die);
<a name="l18738"></a>18738 
<a name="l18739"></a>18739   <span class="keywordflow">if</span> (die-&gt;child != NULL)
<a name="l18740"></a>18740     {
<a name="l18741"></a>18741       <a class="code" href="utils_8c.html#a2fd01c2e194426a2c39db249457dba9b">print_spaces</a> (indent, f);
<a name="l18742"></a>18742       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;  Children:&quot;</span>);
<a name="l18743"></a>18743       <span class="keywordflow">if</span> (level + 1 &lt; max_level)
<a name="l18744"></a>18744         {
<a name="l18745"></a>18745           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l18746"></a>18746           <a class="code" href="dwarf2read_8c.html#a9eb6c811f2245f1b4af3e337d3746c76">dump_die_1</a> (f, level + 1, max_level, die-&gt;child);
<a name="l18747"></a>18747         }
<a name="l18748"></a>18748       <span class="keywordflow">else</span>
<a name="l18749"></a>18749         {
<a name="l18750"></a>18750           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (f,
<a name="l18751"></a>18751                               <span class="stringliteral">&quot; [not printed, max nesting level reached]\n&quot;</span>);
<a name="l18752"></a>18752         }
<a name="l18753"></a>18753     }
<a name="l18754"></a>18754 
<a name="l18755"></a>18755   <span class="keywordflow">if</span> (die-&gt;sibling != NULL &amp;&amp; level &gt; 0)
<a name="l18756"></a>18756     {
<a name="l18757"></a>18757       <a class="code" href="dwarf2read_8c.html#a9eb6c811f2245f1b4af3e337d3746c76">dump_die_1</a> (f, level, max_level, die-&gt;sibling);
<a name="l18758"></a>18758     }
<a name="l18759"></a>18759 }
<a name="l18760"></a>18760 
<a name="l18761"></a>18761 <span class="comment">/* This is called from the pdie macro in gdbinit.in.</span>
<a name="l18762"></a>18762 <span class="comment">   It&#39;s not static so gcc will keep a copy callable from gdb.  */</span>
<a name="l18763"></a>18763 
<a name="l18764"></a>18764 <span class="keywordtype">void</span>
<a name="l18765"></a><a class="code" href="dwarf2read_8c.html#aa1e7ee43f6ccdd2c19768ae5eff4bd89">18765</a> <a class="code" href="dwarf2read_8c.html#aa1e7ee43f6ccdd2c19768ae5eff4bd89">dump_die</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keywordtype">int</span> max_level)
<a name="l18766"></a>18766 {
<a name="l18767"></a>18767   <a class="code" href="dwarf2read_8c.html#a9eb6c811f2245f1b4af3e337d3746c76">dump_die_1</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, 0, max_level, die);
<a name="l18768"></a>18768 }
<a name="l18769"></a>18769 
<a name="l18770"></a>18770 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l18771"></a><a class="code" href="dwarf2read_8c.html#a73da43858dcf4f74ace71583baadf321">18771</a> <a class="code" href="dwarf2read_8c.html#a73da43858dcf4f74ace71583baadf321">store_in_ref_table</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l18772"></a>18772 {
<a name="l18773"></a>18773   <span class="keywordtype">void</span> **slot;
<a name="l18774"></a>18774 
<a name="l18775"></a>18775   slot = htab_find_slot_with_hash (cu-&gt;<a class="code" href="structdwarf2__cu.html#a681ffa0c8fdc7c63efa8fffb2a441f12">die_hash</a>, die, die-&gt;offset.sect_off,
<a name="l18776"></a>18776                                    INSERT);
<a name="l18777"></a>18777 
<a name="l18778"></a>18778   *slot = die;
<a name="l18779"></a>18779 }
<a name="l18780"></a>18780 
<a name="l18781"></a>18781 <span class="comment">/* Return DIE offset of ATTR.  Return 0 with complaint if ATTR is not of the</span>
<a name="l18782"></a>18782 <span class="comment">   required kind.  */</span>
<a name="l18783"></a>18783 
<a name="l18784"></a>18784 <span class="keyword">static</span> <a class="code" href="structsect__offset.html">sect_offset</a>
<a name="l18785"></a><a class="code" href="dwarf2read_8c.html#a28e7eb63f317d51f9be16584d407c508">18785</a> <a class="code" href="dwarf2read_8c.html#a28e7eb63f317d51f9be16584d407c508">dwarf2_get_ref_die_offset</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr)
<a name="l18786"></a>18786 {
<a name="l18787"></a>18787   <a class="code" href="structsect__offset.html">sect_offset</a> retval = { <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) };
<a name="l18788"></a>18788 
<a name="l18789"></a>18789   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a217d4eb87ed57947007169e88bb2a0f9">attr_form_is_ref</a> (attr))
<a name="l18790"></a>18790     <span class="keywordflow">return</span> retval;
<a name="l18791"></a>18791 
<a name="l18792"></a>18792   retval.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = 0;
<a name="l18793"></a>18793   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l18794"></a>18794              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unsupported die ref attribute form: &#39;%s&#39;&quot;</span>),
<a name="l18795"></a>18795              <a class="code" href="dwarf2read_8c.html#a6810653c49d4b3be30290dc1bcf20c94">dwarf_form_name</a> (attr-&gt;form));
<a name="l18796"></a>18796   <span class="keywordflow">return</span> retval;
<a name="l18797"></a>18797 }
<a name="l18798"></a>18798 
<a name="l18799"></a>18799 <span class="comment">/* Return the constant value held by ATTR.  Return DEFAULT_VALUE if</span>
<a name="l18800"></a>18800 <span class="comment"> * the value held by the attribute is not constant.  */</span>
<a name="l18801"></a>18801 
<a name="l18802"></a>18802 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l18803"></a><a class="code" href="dwarf2read_8c.html#a483ab0874bc41021a77b11c5e6d3b740">18803</a> <a class="code" href="dwarf2read_8c.html#a483ab0874bc41021a77b11c5e6d3b740">dwarf2_get_attr_constant_value</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr, <span class="keywordtype">int</span> default_value)
<a name="l18804"></a>18804 {
<a name="l18805"></a>18805   <span class="keywordflow">if</span> (attr-&gt;form == DW_FORM_sdata)
<a name="l18806"></a>18806     <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a66159661f7b11878469288def232a3e4">DW_SND</a> (attr);
<a name="l18807"></a>18807   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attr-&gt;form == DW_FORM_udata
<a name="l18808"></a>18808            || attr-&gt;form == DW_FORM_data1
<a name="l18809"></a>18809            || attr-&gt;form == DW_FORM_data2
<a name="l18810"></a>18810            || attr-&gt;form == DW_FORM_data4
<a name="l18811"></a>18811            || attr-&gt;form == DW_FORM_data8)
<a name="l18812"></a>18812     <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l18813"></a>18813   <span class="keywordflow">else</span>
<a name="l18814"></a>18814     {
<a name="l18815"></a>18815       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l18816"></a>18816                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attribute value is not a constant (%s)&quot;</span>),
<a name="l18817"></a>18817                  <a class="code" href="dwarf2read_8c.html#a6810653c49d4b3be30290dc1bcf20c94">dwarf_form_name</a> (attr-&gt;form));
<a name="l18818"></a>18818       <span class="keywordflow">return</span> default_value;
<a name="l18819"></a>18819     }
<a name="l18820"></a>18820 }
<a name="l18821"></a>18821 
<a name="l18822"></a>18822 <span class="comment">/* Follow reference or signature attribute ATTR of SRC_DIE.</span>
<a name="l18823"></a>18823 <span class="comment">   On entry *REF_CU is the CU of SRC_DIE.</span>
<a name="l18824"></a>18824 <span class="comment">   On exit *REF_CU is the CU of the result.  */</span>
<a name="l18825"></a>18825 
<a name="l18826"></a>18826 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *
<a name="l18827"></a><a class="code" href="dwarf2read_8c.html#a468c4b93171973f8c93dd21db4de1634">18827</a> <a class="code" href="dwarf2read_8c.html#a468c4b93171973f8c93dd21db4de1634">follow_die_ref_or_sig</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *src_die, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr,
<a name="l18828"></a>18828                        <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> **ref_cu)
<a name="l18829"></a>18829 {
<a name="l18830"></a>18830   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die;
<a name="l18831"></a>18831 
<a name="l18832"></a>18832   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a217d4eb87ed57947007169e88bb2a0f9">attr_form_is_ref</a> (attr))
<a name="l18833"></a>18833     die = <a class="code" href="dwarf2read_8c.html#a079b531fef51cfc34f92ff6fde2ef8a4">follow_die_ref</a> (src_die, attr, ref_cu);
<a name="l18834"></a>18834   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attr-&gt;form == DW_FORM_ref_sig8)
<a name="l18835"></a>18835     die = <a class="code" href="dwarf2read_8c.html#add2431995750b3a2bbd9f2eeb861b57a">follow_die_sig</a> (src_die, attr, ref_cu);
<a name="l18836"></a>18836   <span class="keywordflow">else</span>
<a name="l18837"></a>18837     {
<a name="l18838"></a>18838       <a class="code" href="dwarf2read_8c.html#a6e4e3ec89be5cd344456da9d82bc20d7">dump_die_for_error</a> (src_die);
<a name="l18839"></a>18839       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Expected reference attribute [in module %s]&quot;</span>),
<a name="l18840"></a>18840              <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> ((*ref_cu)-&gt;objfile));
<a name="l18841"></a>18841     }
<a name="l18842"></a>18842 
<a name="l18843"></a>18843   <span class="keywordflow">return</span> die;
<a name="l18844"></a>18844 }
<a name="l18845"></a>18845 
<a name="l18846"></a>18846 <span class="comment">/* Follow reference OFFSET.</span>
<a name="l18847"></a>18847 <span class="comment">   On entry *REF_CU is the CU of the source die referencing OFFSET.</span>
<a name="l18848"></a>18848 <span class="comment">   On exit *REF_CU is the CU of the result.</span>
<a name="l18849"></a>18849 <span class="comment">   Returns NULL if OFFSET is invalid.  */</span>
<a name="l18850"></a>18850 
<a name="l18851"></a>18851 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *
<a name="l18852"></a><a class="code" href="dwarf2read_8c.html#a8418373f28d2825dcf8bba82610d4a90">18852</a> <a class="code" href="dwarf2read_8c.html#a8418373f28d2825dcf8bba82610d4a90">follow_die_offset</a> (<a class="code" href="structsect__offset.html">sect_offset</a> offset, <span class="keywordtype">int</span> offset_in_dwz,
<a name="l18853"></a>18853                    <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> **ref_cu)
<a name="l18854"></a>18854 {
<a name="l18855"></a>18855   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> temp_die;
<a name="l18856"></a>18856   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *target_cu, *cu = *ref_cu;
<a name="l18857"></a>18857 
<a name="l18858"></a>18858   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a> != NULL);
<a name="l18859"></a>18859 
<a name="l18860"></a>18860   target_cu = cu;
<a name="l18861"></a>18861 
<a name="l18862"></a>18862   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>)
<a name="l18863"></a>18863     {
<a name="l18864"></a>18864       <span class="comment">/* .debug_types CUs cannot reference anything outside their CU.</span>
<a name="l18865"></a>18865 <span class="comment">         If they need to, they have to reference a signatured type via</span>
<a name="l18866"></a>18866 <span class="comment">         DW_FORM_ref_sig8.  */</span>
<a name="l18867"></a>18867       <span class="keywordflow">if</span> (! <a class="code" href="dwarf2read_8c.html#a244f083f251f3bfffd839e9fd3670a9a">offset_in_cu_p</a> (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>, offset))
<a name="l18868"></a>18868         <span class="keywordflow">return</span> NULL;
<a name="l18869"></a>18869     }
<a name="l18870"></a>18870   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (offset_in_dwz != cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a>
<a name="l18871"></a>18871            || ! <a class="code" href="dwarf2read_8c.html#a244f083f251f3bfffd839e9fd3670a9a">offset_in_cu_p</a> (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>, offset))
<a name="l18872"></a>18872     {
<a name="l18873"></a>18873       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu;
<a name="l18874"></a>18874 
<a name="l18875"></a>18875       per_cu = <a class="code" href="dwarf2read_8c.html#af3b37bdf179696b92b068cd2894de56d">dwarf2_find_containing_comp_unit</a> (offset, offset_in_dwz,
<a name="l18876"></a>18876                                                  cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>);
<a name="l18877"></a>18877 
<a name="l18878"></a>18878       <span class="comment">/* If necessary, add it to the queue and load its DIEs.  */</span>
<a name="l18879"></a>18879       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ac102eb30f433a30a29425f0d30a461c2">maybe_queue_comp_unit</a> (cu, per_cu, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>))
<a name="l18880"></a>18880         <a class="code" href="dwarf2read_8c.html#a9f845956e1dd14ace7c6471ee8c2b502">load_full_comp_unit</a> (per_cu, cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>);
<a name="l18881"></a>18881 
<a name="l18882"></a>18882       target_cu = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>;
<a name="l18883"></a>18883     }
<a name="l18884"></a>18884   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#abc8aaad6bb3799398e9769f989fd1692">dies</a> == NULL)
<a name="l18885"></a>18885     {
<a name="l18886"></a>18886       <span class="comment">/* We&#39;re loading full DIEs during partial symbol reading.  */</span>
<a name="l18887"></a>18887       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a91e7a3d79383661130df87b91ef1e6c9">reading_partial_symbols</a>);
<a name="l18888"></a>18888       <a class="code" href="dwarf2read_8c.html#a9f845956e1dd14ace7c6471ee8c2b502">load_full_comp_unit</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>, <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a389b59241274e837cb0d28b1909013ac">language_minimal</a>);
<a name="l18889"></a>18889     }
<a name="l18890"></a>18890 
<a name="l18891"></a>18891   *ref_cu = target_cu;
<a name="l18892"></a>18892   temp_die.offset = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l18893"></a>18893   <span class="keywordflow">return</span> htab_find_with_hash (target_cu-&gt;<a class="code" href="structdwarf2__cu.html#a681ffa0c8fdc7c63efa8fffb2a441f12">die_hash</a>, &amp;temp_die, offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l18894"></a>18894 }
<a name="l18895"></a>18895 
<a name="l18896"></a>18896 <span class="comment">/* Follow reference attribute ATTR of SRC_DIE.</span>
<a name="l18897"></a>18897 <span class="comment">   On entry *REF_CU is the CU of SRC_DIE.</span>
<a name="l18898"></a>18898 <span class="comment">   On exit *REF_CU is the CU of the result.  */</span>
<a name="l18899"></a>18899 
<a name="l18900"></a>18900 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *
<a name="l18901"></a><a class="code" href="dwarf2read_8c.html#a079b531fef51cfc34f92ff6fde2ef8a4">18901</a> <a class="code" href="dwarf2read_8c.html#a079b531fef51cfc34f92ff6fde2ef8a4">follow_die_ref</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *src_die, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr,
<a name="l18902"></a>18902                 <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> **ref_cu)
<a name="l18903"></a>18903 {
<a name="l18904"></a>18904   <a class="code" href="structsect__offset.html">sect_offset</a> offset = <a class="code" href="dwarf2read_8c.html#a28e7eb63f317d51f9be16584d407c508">dwarf2_get_ref_die_offset</a> (attr);
<a name="l18905"></a>18905   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = *ref_cu;
<a name="l18906"></a>18906   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die;
<a name="l18907"></a>18907 
<a name="l18908"></a>18908   die = <a class="code" href="dwarf2read_8c.html#a8418373f28d2825dcf8bba82610d4a90">follow_die_offset</a> (offset,
<a name="l18909"></a>18909                            (attr-&gt;form == DW_FORM_GNU_ref_alt
<a name="l18910"></a>18910                             || cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a>),
<a name="l18911"></a>18911                            ref_cu);
<a name="l18912"></a>18912   <span class="keywordflow">if</span> (!die)
<a name="l18913"></a>18913     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Cannot find DIE at 0x%x referenced from DIE &quot;</span>
<a name="l18914"></a>18914            <span class="stringliteral">&quot;at 0x%x [in module %s]&quot;</span>),
<a name="l18915"></a>18915            offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, src_die-&gt;offset.sect_off,
<a name="l18916"></a>18916            <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>));
<a name="l18917"></a>18917 
<a name="l18918"></a>18918   <span class="keywordflow">return</span> die;
<a name="l18919"></a>18919 }
<a name="l18920"></a>18920 
<a name="l18921"></a>18921 <span class="comment">/* Return DWARF block referenced by DW_AT_location of DIE at OFFSET at PER_CU.</span>
<a name="l18922"></a>18922 <span class="comment">   Returned value is intended for DW_OP_call*.  Returned</span>
<a name="l18923"></a>18923 <span class="comment">   dwarf2_locexpr_baton-&gt;data has lifetime of PER_CU-&gt;OBJFILE.  */</span>
<a name="l18924"></a>18924 
<a name="l18925"></a>18925 <span class="keyword">struct </span><a class="code" href="structdwarf2__locexpr__baton.html">dwarf2_locexpr_baton</a>
<a name="l18926"></a><a class="code" href="dwarf2read_8c.html#abe65b072fc5fdf942e39cffca7bcd751">18926</a> <a class="code" href="dwarf2loc_8h.html#ac78fc2f387680a9b9eb2658bf0c70ea8">dwarf2_fetch_die_loc_sect_off</a> (<a class="code" href="structsect__offset.html">sect_offset</a> offset,
<a name="l18927"></a>18927                                struct <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *<a class="code" href="structdwarf2__locexpr__baton.html#a4f4c2fcdbde62332afde34a8a95d91fe">per_cu</a>,
<a name="l18928"></a>18928                                <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> (*<a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a>) (<span class="keywordtype">void</span> *baton),
<a name="l18929"></a>18929                                <span class="keywordtype">void</span> *baton)
<a name="l18930"></a>18930 {
<a name="l18931"></a>18931   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu;
<a name="l18932"></a>18932   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die;
<a name="l18933"></a>18933   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l18934"></a>18934   <span class="keyword">struct </span><a class="code" href="structdwarf2__locexpr__baton.html">dwarf2_locexpr_baton</a> retval;
<a name="l18935"></a>18935 
<a name="l18936"></a>18936   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (per_cu-&gt;objfile);
<a name="l18937"></a>18937 
<a name="l18938"></a>18938   <span class="keywordflow">if</span> (per_cu-&gt;cu == NULL)
<a name="l18939"></a>18939     <a class="code" href="dwarf2read_8c.html#a2a36765902f5385cca0fde58497b3c8b">load_cu</a> (per_cu);
<a name="l18940"></a>18940   cu = per_cu-&gt;cu;
<a name="l18941"></a>18941 
<a name="l18942"></a>18942   die = <a class="code" href="dwarf2read_8c.html#a8418373f28d2825dcf8bba82610d4a90">follow_die_offset</a> (offset, per_cu-&gt;is_dwz, &amp;cu);
<a name="l18943"></a>18943   <span class="keywordflow">if</span> (!die)
<a name="l18944"></a>18944     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Cannot find DIE at 0x%x referenced in module %s&quot;</span>),
<a name="l18945"></a>18945            offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (per_cu-&gt;objfile));
<a name="l18946"></a>18946 
<a name="l18947"></a>18947   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_location, cu);
<a name="l18948"></a>18948   <span class="keywordflow">if</span> (!attr)
<a name="l18949"></a>18949     {
<a name="l18950"></a>18950       <span class="comment">/* DWARF: &quot;If there is no such attribute, then there is no effect.&quot;.</span>
<a name="l18951"></a>18951 <span class="comment">         DATA is ignored if SIZE is 0.  */</span>
<a name="l18952"></a>18952 
<a name="l18953"></a>18953       retval.<a class="code" href="structdwarf2__locexpr__baton.html#a629a2d12a13c59e34ffc1f64953b5f01">data</a> = NULL;
<a name="l18954"></a>18954       retval.<a class="code" href="structdwarf2__locexpr__baton.html#aad393a9f0c112b45b23fb0d30c19df07">size</a> = 0;
<a name="l18955"></a>18955     }
<a name="l18956"></a>18956   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#aa2b54436e7d13233cd6b866f562f637e">attr_form_is_section_offset</a> (attr))
<a name="l18957"></a>18957     {
<a name="l18958"></a>18958       <span class="keyword">struct </span><a class="code" href="structdwarf2__loclist__baton.html">dwarf2_loclist_baton</a> loclist_baton;
<a name="l18959"></a>18959       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc = (*get_frame_pc) (baton);
<a name="l18960"></a>18960       <span class="keywordtype">size_t</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l18961"></a>18961 
<a name="l18962"></a>18962       <a class="code" href="dwarf2read_8c.html#ad27262e92622f057801c24c2d248593d">fill_in_loclist_baton</a> (cu, &amp;loclist_baton, attr);
<a name="l18963"></a>18963 
<a name="l18964"></a>18964       retval.<a class="code" href="structdwarf2__locexpr__baton.html#a629a2d12a13c59e34ffc1f64953b5f01">data</a> = <a class="code" href="dwarf2loc_8c.html#aa139c7d49bdef0a3724353ba47c6451b">dwarf2_find_location_expression</a> (&amp;loclist_baton,
<a name="l18965"></a>18965                                                      &amp;size, pc);
<a name="l18966"></a>18966       retval.<a class="code" href="structdwarf2__locexpr__baton.html#aad393a9f0c112b45b23fb0d30c19df07">size</a> = <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l18967"></a>18967     }
<a name="l18968"></a>18968   <span class="keywordflow">else</span>
<a name="l18969"></a>18969     {
<a name="l18970"></a>18970       <span class="keywordflow">if</span> (!<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (attr))
<a name="l18971"></a>18971         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: DIE at 0x%x referenced in module %s &quot;</span>
<a name="l18972"></a>18972                  <span class="stringliteral">&quot;is neither DW_FORM_block* nor DW_FORM_exprloc&quot;</span>),
<a name="l18973"></a>18973                offset.sect_off, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (per_cu-&gt;objfile));
<a name="l18974"></a>18974 
<a name="l18975"></a>18975       retval.<a class="code" href="structdwarf2__locexpr__baton.html#a629a2d12a13c59e34ffc1f64953b5f01">data</a> = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data;
<a name="l18976"></a>18976       retval.<a class="code" href="structdwarf2__locexpr__baton.html#aad393a9f0c112b45b23fb0d30c19df07">size</a> = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;size;
<a name="l18977"></a>18977     }
<a name="l18978"></a>18978   retval.<a class="code" href="structdwarf2__locexpr__baton.html#a4f4c2fcdbde62332afde34a8a95d91fe">per_cu</a> = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;
<a name="l18979"></a>18979 
<a name="l18980"></a>18980   <a class="code" href="dwarf2read_8c.html#aea3bec269cdf43d65a84eb61d8c2c48b">age_cached_comp_units</a> ();
<a name="l18981"></a>18981 
<a name="l18982"></a>18982   <span class="keywordflow">return</span> retval;
<a name="l18983"></a>18983 }
<a name="l18984"></a>18984 
<a name="l18985"></a>18985 <span class="comment">/* Like dwarf2_fetch_die_loc_sect_off, but take a CU</span>
<a name="l18986"></a>18986 <span class="comment">   offset.  */</span>
<a name="l18987"></a>18987 
<a name="l18988"></a>18988 <span class="keyword">struct </span><a class="code" href="structdwarf2__locexpr__baton.html">dwarf2_locexpr_baton</a>
<a name="l18989"></a><a class="code" href="dwarf2read_8c.html#aed2cd827bb2fe657705007ead3b04e7f">18989</a> <a class="code" href="dwarf2loc_8h.html#aed2cd827bb2fe657705007ead3b04e7f">dwarf2_fetch_die_loc_cu_off</a> (<a class="code" href="structcu__offset.html">cu_offset</a> offset_in_cu,
<a name="l18990"></a>18990                              struct <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *<a class="code" href="structdwarf2__locexpr__baton.html#a4f4c2fcdbde62332afde34a8a95d91fe">per_cu</a>,
<a name="l18991"></a>18991                              <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> (*<a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a>) (<span class="keywordtype">void</span> *baton),
<a name="l18992"></a>18992                              <span class="keywordtype">void</span> *baton)
<a name="l18993"></a>18993 {
<a name="l18994"></a>18994   <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a> = { per_cu-&gt;offset.sect_off + offset_in_cu.cu_off };
<a name="l18995"></a>18995 
<a name="l18996"></a>18996   <span class="keywordflow">return</span> <a class="code" href="dwarf2loc_8h.html#ac78fc2f387680a9b9eb2658bf0c70ea8">dwarf2_fetch_die_loc_sect_off</a> (offset, per_cu, <a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a>, baton);
<a name="l18997"></a>18997 }
<a name="l18998"></a>18998 
<a name="l18999"></a>18999 <span class="comment">/* Write a constant of a given type as target-ordered bytes into</span>
<a name="l19000"></a>19000 <span class="comment">   OBSTACK.  */</span>
<a name="l19001"></a>19001 
<a name="l19002"></a>19002 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l19003"></a><a class="code" href="dwarf2read_8c.html#adda11a4c8d4ee59d21bbd6ecb7362292">19003</a> <a class="code" href="dwarf2read_8c.html#adda11a4c8d4ee59d21bbd6ecb7362292">write_constant_as_bytes</a> (<span class="keyword">struct</span> obstack *obstack,
<a name="l19004"></a>19004                          <span class="keyword">enum</span> bfd_endian byte_order,
<a name="l19005"></a>19005                          <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>,
<a name="l19006"></a>19006                          <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structvalue.html">value</a>,
<a name="l19007"></a>19007                          <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *<a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>)
<a name="l19008"></a>19008 {
<a name="l19009"></a>19009   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *result;
<a name="l19010"></a>19010 
<a name="l19011"></a>19011   *len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type);
<a name="l19012"></a>19012   result = obstack_alloc (obstack, *len);
<a name="l19013"></a>19013   <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (result, *len, byte_order, value);
<a name="l19014"></a>19014 
<a name="l19015"></a>19015   <span class="keywordflow">return</span> result;
<a name="l19016"></a>19016 }
<a name="l19017"></a>19017 
<a name="l19018"></a>19018 <span class="comment">/* If the DIE at OFFSET in PER_CU has a DW_AT_const_value, return a</span>
<a name="l19019"></a>19019 <span class="comment">   pointer to the constant bytes and set LEN to the length of the</span>
<a name="l19020"></a>19020 <span class="comment">   data.  If memory is needed, allocate it on OBSTACK.  If the DIE</span>
<a name="l19021"></a>19021 <span class="comment">   does not have a DW_AT_const_value, return NULL.  */</span>
<a name="l19022"></a>19022 
<a name="l19023"></a>19023 <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l19024"></a><a class="code" href="dwarf2read_8c.html#a29b6336d31d174188b17fc98a38f72df">19024</a> <a class="code" href="dwarf2loc_8h.html#ab4e63727c69b23d9cfda95c82e028946">dwarf2_fetch_constant_bytes</a> (<a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>,
<a name="l19025"></a>19025                              <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu,
<a name="l19026"></a>19026                              <span class="keyword">struct</span> obstack *obstack,
<a name="l19027"></a>19027                              <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *<a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>)
<a name="l19028"></a>19028 {
<a name="l19029"></a>19029   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu;
<a name="l19030"></a>19030   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die;
<a name="l19031"></a>19031   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l19032"></a>19032   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *result = NULL;
<a name="l19033"></a>19033   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l19034"></a>19034   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="structvalue.html">value</a>;
<a name="l19035"></a>19035   <span class="keyword">enum</span> bfd_endian byte_order;
<a name="l19036"></a>19036 
<a name="l19037"></a>19037   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>);
<a name="l19038"></a>19038 
<a name="l19039"></a>19039   <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> == NULL)
<a name="l19040"></a>19040     <a class="code" href="dwarf2read_8c.html#a2a36765902f5385cca0fde58497b3c8b">load_cu</a> (per_cu);
<a name="l19041"></a>19041   cu = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>;
<a name="l19042"></a>19042 
<a name="l19043"></a>19043   die = <a class="code" href="dwarf2read_8c.html#a8418373f28d2825dcf8bba82610d4a90">follow_die_offset</a> (offset, per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a>, &amp;cu);
<a name="l19044"></a>19044   <span class="keywordflow">if</span> (!die)
<a name="l19045"></a>19045     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Cannot find DIE at 0x%x referenced in module %s&quot;</span>),
<a name="l19046"></a>19046            offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>));
<a name="l19047"></a>19047 
<a name="l19048"></a>19048 
<a name="l19049"></a>19049   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (die, DW_AT_const_value, cu);
<a name="l19050"></a>19050   <span class="keywordflow">if</span> (attr == NULL)
<a name="l19051"></a>19051     <span class="keywordflow">return</span> NULL;
<a name="l19052"></a>19052 
<a name="l19053"></a>19053   byte_order = (bfd_big_endian (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>)
<a name="l19054"></a>19054                 ? BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE);
<a name="l19055"></a>19055 
<a name="l19056"></a>19056   <span class="keywordflow">switch</span> (attr-&gt;form)
<a name="l19057"></a>19057     {
<a name="l19058"></a>19058     <span class="keywordflow">case</span> DW_FORM_addr:
<a name="l19059"></a>19059     <span class="keywordflow">case</span> DW_FORM_GNU_addr_index:
<a name="l19060"></a>19060       {
<a name="l19061"></a>19061         <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *tem;
<a name="l19062"></a>19062 
<a name="l19063"></a>19063         *len = cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l19064"></a>19064         tem = obstack_alloc (obstack, *len);
<a name="l19065"></a>19065         <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (tem, *len, byte_order, <a class="code" href="dwarf2read_8c.html#a6025dcd4fa91fa005df407941029683f">DW_ADDR</a> (attr));
<a name="l19066"></a>19066         result = tem;
<a name="l19067"></a>19067       }
<a name="l19068"></a>19068       <span class="keywordflow">break</span>;
<a name="l19069"></a>19069     <span class="keywordflow">case</span> DW_FORM_string:
<a name="l19070"></a>19070     <span class="keywordflow">case</span> DW_FORM_strp:
<a name="l19071"></a>19071     <span class="keywordflow">case</span> DW_FORM_GNU_str_index:
<a name="l19072"></a>19072     <span class="keywordflow">case</span> DW_FORM_GNU_strp_alt:
<a name="l19073"></a>19073       <span class="comment">/* DW_STRING is already allocated on the objfile obstack, point</span>
<a name="l19074"></a>19074 <span class="comment">         directly to it.  */</span>
<a name="l19075"></a>19075       result = (<span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *) <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr);
<a name="l19076"></a>19076       *len = strlen (<a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr));
<a name="l19077"></a>19077       <span class="keywordflow">break</span>;
<a name="l19078"></a>19078     <span class="keywordflow">case</span> DW_FORM_block1:
<a name="l19079"></a>19079     <span class="keywordflow">case</span> DW_FORM_block2:
<a name="l19080"></a>19080     <span class="keywordflow">case</span> DW_FORM_block4:
<a name="l19081"></a>19081     <span class="keywordflow">case</span> DW_FORM_block:
<a name="l19082"></a>19082     <span class="keywordflow">case</span> DW_FORM_exprloc:
<a name="l19083"></a>19083       result = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data;
<a name="l19084"></a>19084       *len = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;size;
<a name="l19085"></a>19085       <span class="keywordflow">break</span>;
<a name="l19086"></a>19086 
<a name="l19087"></a>19087       <span class="comment">/* The DW_AT_const_value attributes are supposed to carry the</span>
<a name="l19088"></a>19088 <span class="comment">         symbol&#39;s value &quot;represented as it would be on the target</span>
<a name="l19089"></a>19089 <span class="comment">         architecture.&quot;  By the time we get here, it&#39;s already been</span>
<a name="l19090"></a>19090 <span class="comment">         converted to host endianness, so we just need to sign- or</span>
<a name="l19091"></a>19091 <span class="comment">         zero-extend it as appropriate.  */</span>
<a name="l19092"></a>19092     <span class="keywordflow">case</span> DW_FORM_data1:
<a name="l19093"></a>19093       type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l19094"></a>19094       result = <a class="code" href="dwarf2read_8c.html#a28881b92367fe7a886c50d60d459ad3f">dwarf2_const_value_data</a> (attr, obstack, cu, &amp;value, 8);
<a name="l19095"></a>19095       <span class="keywordflow">if</span> (result == NULL)
<a name="l19096"></a>19096         result = <a class="code" href="dwarf2read_8c.html#adda11a4c8d4ee59d21bbd6ecb7362292">write_constant_as_bytes</a> (obstack, byte_order,
<a name="l19097"></a>19097                                           type, value, len);
<a name="l19098"></a>19098       <span class="keywordflow">break</span>;
<a name="l19099"></a>19099     <span class="keywordflow">case</span> DW_FORM_data2:
<a name="l19100"></a>19100       type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l19101"></a>19101       result = <a class="code" href="dwarf2read_8c.html#a28881b92367fe7a886c50d60d459ad3f">dwarf2_const_value_data</a> (attr, obstack, cu, &amp;value, 16);
<a name="l19102"></a>19102       <span class="keywordflow">if</span> (result == NULL)
<a name="l19103"></a>19103         result = <a class="code" href="dwarf2read_8c.html#adda11a4c8d4ee59d21bbd6ecb7362292">write_constant_as_bytes</a> (obstack, byte_order,
<a name="l19104"></a>19104                                           type, value, len);
<a name="l19105"></a>19105       <span class="keywordflow">break</span>;
<a name="l19106"></a>19106     <span class="keywordflow">case</span> DW_FORM_data4:
<a name="l19107"></a>19107       type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l19108"></a>19108       result = <a class="code" href="dwarf2read_8c.html#a28881b92367fe7a886c50d60d459ad3f">dwarf2_const_value_data</a> (attr, obstack, cu, &amp;value, 32);
<a name="l19109"></a>19109       <span class="keywordflow">if</span> (result == NULL)
<a name="l19110"></a>19110         result = <a class="code" href="dwarf2read_8c.html#adda11a4c8d4ee59d21bbd6ecb7362292">write_constant_as_bytes</a> (obstack, byte_order,
<a name="l19111"></a>19111                                           type, value, len);
<a name="l19112"></a>19112       <span class="keywordflow">break</span>;
<a name="l19113"></a>19113     <span class="keywordflow">case</span> DW_FORM_data8:
<a name="l19114"></a>19114       type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l19115"></a>19115       result = <a class="code" href="dwarf2read_8c.html#a28881b92367fe7a886c50d60d459ad3f">dwarf2_const_value_data</a> (attr, obstack, cu, &amp;value, 64);
<a name="l19116"></a>19116       <span class="keywordflow">if</span> (result == NULL)
<a name="l19117"></a>19117         result = <a class="code" href="dwarf2read_8c.html#adda11a4c8d4ee59d21bbd6ecb7362292">write_constant_as_bytes</a> (obstack, byte_order,
<a name="l19118"></a>19118                                           type, value, len);
<a name="l19119"></a>19119       <span class="keywordflow">break</span>;
<a name="l19120"></a>19120 
<a name="l19121"></a>19121     <span class="keywordflow">case</span> DW_FORM_sdata:
<a name="l19122"></a>19122       type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l19123"></a>19123       result = <a class="code" href="dwarf2read_8c.html#adda11a4c8d4ee59d21bbd6ecb7362292">write_constant_as_bytes</a> (obstack, byte_order,
<a name="l19124"></a>19124                                         type, <a class="code" href="dwarf2read_8c.html#a66159661f7b11878469288def232a3e4">DW_SND</a> (attr), len);
<a name="l19125"></a>19125       <span class="keywordflow">break</span>;
<a name="l19126"></a>19126 
<a name="l19127"></a>19127     <span class="keywordflow">case</span> DW_FORM_udata:
<a name="l19128"></a>19128       type = <a class="code" href="dwarf2read_8c.html#a609728d4744d63566efe1362e574f4cf">die_type</a> (die, cu);
<a name="l19129"></a>19129       result = <a class="code" href="dwarf2read_8c.html#adda11a4c8d4ee59d21bbd6ecb7362292">write_constant_as_bytes</a> (obstack, byte_order,
<a name="l19130"></a>19130                                         type, <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr), len);
<a name="l19131"></a>19131       <span class="keywordflow">break</span>;
<a name="l19132"></a>19132 
<a name="l19133"></a>19133     <span class="keywordflow">default</span>:
<a name="l19134"></a>19134       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l19135"></a>19135                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unsupported const value attribute form: &#39;%s&#39;&quot;</span>),
<a name="l19136"></a>19136                  <a class="code" href="dwarf2read_8c.html#a6810653c49d4b3be30290dc1bcf20c94">dwarf_form_name</a> (attr-&gt;form));
<a name="l19137"></a>19137       <span class="keywordflow">break</span>;
<a name="l19138"></a>19138     }
<a name="l19139"></a>19139 
<a name="l19140"></a>19140   <span class="keywordflow">return</span> result;
<a name="l19141"></a>19141 }
<a name="l19142"></a>19142 
<a name="l19143"></a>19143 <span class="comment">/* Return the type of the DIE at DIE_OFFSET in the CU named by</span>
<a name="l19144"></a>19144 <span class="comment">   PER_CU.  */</span>
<a name="l19145"></a>19145 
<a name="l19146"></a>19146 <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l19147"></a><a class="code" href="dwarf2read_8c.html#ac604120315635d7460935197dbc81e46">19147</a> <a class="code" href="dwarf2loc_8h.html#ac604120315635d7460935197dbc81e46">dwarf2_get_die_type</a> (<a class="code" href="structcu__offset.html">cu_offset</a> die_offset,
<a name="l19148"></a>19148                      <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l19149"></a>19149 {
<a name="l19150"></a>19150   <a class="code" href="structsect__offset.html">sect_offset</a> die_offset_sect;
<a name="l19151"></a>19151 
<a name="l19152"></a>19152   <a class="code" href="dwarf2read_8c.html#a2fd3e207007c7f6db6cb876acac99997">dw2_setup</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>);
<a name="l19153"></a>19153 
<a name="l19154"></a>19154   die_offset_sect.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> + die_offset.<a class="code" href="structcu__offset.html#a19224b0dc5f0bc49babd2b7701a8d63e">cu_off</a>;
<a name="l19155"></a>19155   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#ae277955c587127c2a481663cca343437">get_die_type_at_offset</a> (die_offset_sect, per_cu);
<a name="l19156"></a>19156 }
<a name="l19157"></a>19157 
<a name="l19158"></a>19158 <span class="comment">/* Follow type unit SIG_TYPE referenced by SRC_DIE.</span>
<a name="l19159"></a>19159 <span class="comment">   On entry *REF_CU is the CU of SRC_DIE.</span>
<a name="l19160"></a>19160 <span class="comment">   On exit *REF_CU is the CU of the result.</span>
<a name="l19161"></a>19161 <span class="comment">   Returns NULL if the referenced DIE isn&#39;t found.  */</span>
<a name="l19162"></a>19162 
<a name="l19163"></a>19163 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *
<a name="l19164"></a><a class="code" href="dwarf2read_8c.html#a5826fe34a1e5f587825d1ed149f8416c">19164</a> <a class="code" href="dwarf2read_8c.html#a5826fe34a1e5f587825d1ed149f8416c">follow_die_sig_1</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *src_die, <span class="keyword">struct</span> <a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type,
<a name="l19165"></a>19165                   <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> **ref_cu)
<a name="l19166"></a>19166 {
<a name="l19167"></a>19167   <span class="keyword">struct </span>objfile *objfile = (*ref_cu)-&gt;objfile;
<a name="l19168"></a>19168   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> temp_die;
<a name="l19169"></a>19169   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *sig_cu;
<a name="l19170"></a>19170   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die;
<a name="l19171"></a>19171 
<a name="l19172"></a>19172   <span class="comment">/* While it might be nice to assert sig_type-&gt;type == NULL here,</span>
<a name="l19173"></a>19173 <span class="comment">     we can get here for DW_AT_imported_declaration where we need</span>
<a name="l19174"></a>19174 <span class="comment">     the DIE not the type.  */</span>
<a name="l19175"></a>19175 
<a name="l19176"></a>19176   <span class="comment">/* If necessary, add it to the queue and load its DIEs.  */</span>
<a name="l19177"></a>19177 
<a name="l19178"></a>19178   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ac102eb30f433a30a29425f0d30a461c2">maybe_queue_comp_unit</a> (*ref_cu, &amp;sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>, <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a389b59241274e837cb0d28b1909013ac">language_minimal</a>))
<a name="l19179"></a>19179     <a class="code" href="dwarf2read_8c.html#acb79afa78ab76b39b5a27f8135e60509">read_signatured_type</a> (sig_type);
<a name="l19180"></a>19180 
<a name="l19181"></a>19181   sig_cu = sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>;
<a name="l19182"></a>19182   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sig_cu != NULL);
<a name="l19183"></a>19183   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sig_type-&gt;<a class="code" href="structsignatured__type.html#aa8e49a69ad9d6311b553b063fa0fe62d">type_offset_in_section</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> != 0);
<a name="l19184"></a>19184   temp_die.offset = sig_type-&gt;<a class="code" href="structsignatured__type.html#aa8e49a69ad9d6311b553b063fa0fe62d">type_offset_in_section</a>;
<a name="l19185"></a>19185   die = htab_find_with_hash (sig_cu-&gt;<a class="code" href="structdwarf2__cu.html#a681ffa0c8fdc7c63efa8fffb2a441f12">die_hash</a>, &amp;temp_die,
<a name="l19186"></a>19186                              temp_die.offset.sect_off);
<a name="l19187"></a>19187   <span class="keywordflow">if</span> (die)
<a name="l19188"></a>19188     {
<a name="l19189"></a>19189       <span class="comment">/* For .gdb_index version 7 keep track of included TUs.</span>
<a name="l19190"></a>19190 <span class="comment">         http://sourceware.org/bugzilla/show_bug.cgi?id=15021.  */</span>
<a name="l19191"></a>19191       <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a1e58a614b6e77589e24dac14dfdc62e5">index_table</a> != NULL
<a name="l19192"></a>19192           &amp;&amp; dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a1e58a614b6e77589e24dac14dfdc62e5">index_table</a>-&gt;<a class="code" href="structmapped__index.html#a6204ce2b69334c8d243357d524858ccd">version</a> &lt;= 7)
<a name="l19193"></a>19193         {
<a name="l19194"></a>19194           <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (dwarf2_per_cu_ptr,
<a name="l19195"></a>19195                          (*ref_cu)-&gt;per_cu-&gt;imported_symtabs,
<a name="l19196"></a>19196                          sig_cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>);
<a name="l19197"></a>19197         }
<a name="l19198"></a>19198 
<a name="l19199"></a>19199       *ref_cu = sig_cu;
<a name="l19200"></a>19200       <span class="keywordflow">return</span> die;
<a name="l19201"></a>19201     }
<a name="l19202"></a>19202 
<a name="l19203"></a>19203   <span class="keywordflow">return</span> NULL;
<a name="l19204"></a>19204 }
<a name="l19205"></a>19205 
<a name="l19206"></a>19206 <span class="comment">/* Follow signatured type referenced by ATTR in SRC_DIE.</span>
<a name="l19207"></a>19207 <span class="comment">   On entry *REF_CU is the CU of SRC_DIE.</span>
<a name="l19208"></a>19208 <span class="comment">   On exit *REF_CU is the CU of the result.</span>
<a name="l19209"></a>19209 <span class="comment">   The result is the DIE of the type.</span>
<a name="l19210"></a>19210 <span class="comment">   If the referenced type cannot be found an error is thrown.  */</span>
<a name="l19211"></a>19211 
<a name="l19212"></a>19212 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *
<a name="l19213"></a><a class="code" href="dwarf2read_8c.html#add2431995750b3a2bbd9f2eeb861b57a">19213</a> <a class="code" href="dwarf2read_8c.html#add2431995750b3a2bbd9f2eeb861b57a">follow_die_sig</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *src_die, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr,
<a name="l19214"></a>19214                 <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> **ref_cu)
<a name="l19215"></a>19215 {
<a name="l19216"></a>19216   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> signature = <a class="code" href="dwarf2read_8c.html#a8ba60632a90cfabc155c69f0bf2d2f83">DW_SIGNATURE</a> (attr);
<a name="l19217"></a>19217   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type;
<a name="l19218"></a>19218   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die;
<a name="l19219"></a>19219 
<a name="l19220"></a>19220   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (attr-&gt;form == DW_FORM_ref_sig8);
<a name="l19221"></a>19221 
<a name="l19222"></a>19222   sig_type = <a class="code" href="dwarf2read_8c.html#ac5606f704cf6961d275314004161334b">lookup_signatured_type</a> (*ref_cu, signature);
<a name="l19223"></a>19223   <span class="comment">/* sig_type will be NULL if the signatured type is missing from</span>
<a name="l19224"></a>19224 <span class="comment">     the debug info.  */</span>
<a name="l19225"></a>19225   <span class="keywordflow">if</span> (sig_type == NULL)
<a name="l19226"></a>19226     {
<a name="l19227"></a>19227       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Cannot find signatured DIE %s referenced&quot;</span>
<a name="l19228"></a>19228                <span class="stringliteral">&quot; from DIE at 0x%x [in module %s]&quot;</span>),
<a name="l19229"></a>19229              <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (signature), src_die-&gt;offset.sect_off,
<a name="l19230"></a>19230              <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> ((*ref_cu)-&gt;objfile));
<a name="l19231"></a>19231     }
<a name="l19232"></a>19232 
<a name="l19233"></a>19233   die = <a class="code" href="dwarf2read_8c.html#a5826fe34a1e5f587825d1ed149f8416c">follow_die_sig_1</a> (src_die, sig_type, ref_cu);
<a name="l19234"></a>19234   <span class="keywordflow">if</span> (die == NULL)
<a name="l19235"></a>19235     {
<a name="l19236"></a>19236       <a class="code" href="dwarf2read_8c.html#a6e4e3ec89be5cd344456da9d82bc20d7">dump_die_for_error</a> (src_die);
<a name="l19237"></a>19237       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Problem reading signatured DIE %s referenced&quot;</span>
<a name="l19238"></a>19238                <span class="stringliteral">&quot; from DIE at 0x%x [in module %s]&quot;</span>),
<a name="l19239"></a>19239              <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (signature), src_die-&gt;offset.sect_off,
<a name="l19240"></a>19240              <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> ((*ref_cu)-&gt;objfile));
<a name="l19241"></a>19241     }
<a name="l19242"></a>19242 
<a name="l19243"></a>19243   <span class="keywordflow">return</span> die;
<a name="l19244"></a>19244 }
<a name="l19245"></a>19245 
<a name="l19246"></a>19246 <span class="comment">/* Get the type specified by SIGNATURE referenced in DIE/CU,</span>
<a name="l19247"></a>19247 <span class="comment">   reading in and processing the type unit if necessary.  */</span>
<a name="l19248"></a>19248 
<a name="l19249"></a>19249 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l19250"></a><a class="code" href="dwarf2read_8c.html#a743c93f0f8a0cfece75baa06b8b1f5a0">19250</a> <a class="code" href="dwarf2read_8c.html#a743c93f0f8a0cfece75baa06b8b1f5a0">get_signatured_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> signature,
<a name="l19251"></a>19251                      <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l19252"></a>19252 {
<a name="l19253"></a>19253   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type;
<a name="l19254"></a>19254   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *type_cu;
<a name="l19255"></a>19255   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *type_die;
<a name="l19256"></a>19256   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l19257"></a>19257 
<a name="l19258"></a>19258   sig_type = <a class="code" href="dwarf2read_8c.html#ac5606f704cf6961d275314004161334b">lookup_signatured_type</a> (cu, signature);
<a name="l19259"></a>19259   <span class="comment">/* sig_type will be NULL if the signatured type is missing from</span>
<a name="l19260"></a>19260 <span class="comment">     the debug info.  */</span>
<a name="l19261"></a>19261   <span class="keywordflow">if</span> (sig_type == NULL)
<a name="l19262"></a>19262     {
<a name="l19263"></a>19263       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l19264"></a>19264                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Cannot find signatured DIE %s referenced&quot;</span>
<a name="l19265"></a>19265                    <span class="stringliteral">&quot; from DIE at 0x%x [in module %s]&quot;</span>),
<a name="l19266"></a>19266                  <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (signature), die-&gt;offset.sect_off,
<a name="l19267"></a>19267                  <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (dwarf2_per_objfile-&gt;objfile));
<a name="l19268"></a>19268       <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a4a3b5d2bd904b30c13a2c22b09778ae6">build_error_marker_type</a> (cu, die);
<a name="l19269"></a>19269     }
<a name="l19270"></a>19270 
<a name="l19271"></a>19271   <span class="comment">/* If we already know the type we&#39;re done.  */</span>
<a name="l19272"></a>19272   <span class="keywordflow">if</span> (sig_type-&gt;<a class="code" href="structsignatured__type.html#a989d99d874e2a997ff78faa0bcf2e5d2">type</a> != NULL)
<a name="l19273"></a>19273     <span class="keywordflow">return</span> sig_type-&gt;<a class="code" href="structsignatured__type.html#a989d99d874e2a997ff78faa0bcf2e5d2">type</a>;
<a name="l19274"></a>19274 
<a name="l19275"></a>19275   type_cu = cu;
<a name="l19276"></a>19276   type_die = <a class="code" href="dwarf2read_8c.html#a5826fe34a1e5f587825d1ed149f8416c">follow_die_sig_1</a> (die, sig_type, &amp;type_cu);
<a name="l19277"></a>19277   <span class="keywordflow">if</span> (type_die != NULL)
<a name="l19278"></a>19278     {
<a name="l19279"></a>19279       <span class="comment">/* N.B. We need to call get_die_type to ensure only one type for this DIE</span>
<a name="l19280"></a>19280 <span class="comment">         is created.  This is important, for example, because for c++ classes</span>
<a name="l19281"></a>19281 <span class="comment">         we need TYPE_NAME set which is only done by new_symbol.  Blech.  */</span>
<a name="l19282"></a>19282       type = <a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (type_die, type_cu);
<a name="l19283"></a>19283       <span class="keywordflow">if</span> (type == NULL)
<a name="l19284"></a>19284         {
<a name="l19285"></a>19285           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l19286"></a>19286                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Cannot build signatured type %s&quot;</span>
<a name="l19287"></a>19287                        <span class="stringliteral">&quot; referenced from DIE at 0x%x [in module %s]&quot;</span>),
<a name="l19288"></a>19288                      <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (signature), die-&gt;offset.sect_off,
<a name="l19289"></a>19289                      <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (dwarf2_per_objfile-&gt;objfile));
<a name="l19290"></a>19290           type = <a class="code" href="dwarf2read_8c.html#a4a3b5d2bd904b30c13a2c22b09778ae6">build_error_marker_type</a> (cu, die);
<a name="l19291"></a>19291         }
<a name="l19292"></a>19292     }
<a name="l19293"></a>19293   <span class="keywordflow">else</span>
<a name="l19294"></a>19294     {
<a name="l19295"></a>19295       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l19296"></a>19296                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: Problem reading signatured DIE %s referenced&quot;</span>
<a name="l19297"></a>19297                    <span class="stringliteral">&quot; from DIE at 0x%x [in module %s]&quot;</span>),
<a name="l19298"></a>19298                  <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (signature), die-&gt;offset.sect_off,
<a name="l19299"></a>19299                  <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (dwarf2_per_objfile-&gt;objfile));
<a name="l19300"></a>19300       type = <a class="code" href="dwarf2read_8c.html#a4a3b5d2bd904b30c13a2c22b09778ae6">build_error_marker_type</a> (cu, die);
<a name="l19301"></a>19301     }
<a name="l19302"></a>19302   sig_type-&gt;<a class="code" href="structsignatured__type.html#a989d99d874e2a997ff78faa0bcf2e5d2">type</a> = <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l19303"></a>19303 
<a name="l19304"></a>19304   <span class="keywordflow">return</span> <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l19305"></a>19305 }
<a name="l19306"></a>19306 
<a name="l19307"></a>19307 <span class="comment">/* Get the type specified by the DW_AT_signature ATTR in DIE/CU,</span>
<a name="l19308"></a>19308 <span class="comment">   reading in and processing the type unit if necessary.  */</span>
<a name="l19309"></a>19309 
<a name="l19310"></a>19310 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l19311"></a><a class="code" href="dwarf2read_8c.html#ad28686b8248336c2fdf52288043a74f7">19311</a> <a class="code" href="dwarf2read_8c.html#ad28686b8248336c2fdf52288043a74f7">get_DW_AT_signature_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr,
<a name="l19312"></a>19312                           <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu) <span class="comment">/* ARI: editCase function */</span>
<a name="l19313"></a>19313 {
<a name="l19314"></a>19314   <span class="comment">/* Yes, DW_AT_signature can use a non-ref_sig8 reference.  */</span>
<a name="l19315"></a>19315   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a217d4eb87ed57947007169e88bb2a0f9">attr_form_is_ref</a> (attr))
<a name="l19316"></a>19316     {
<a name="l19317"></a>19317       <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *type_cu = cu;
<a name="l19318"></a>19318       <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *type_die = <a class="code" href="dwarf2read_8c.html#a079b531fef51cfc34f92ff6fde2ef8a4">follow_die_ref</a> (die, attr, &amp;type_cu);
<a name="l19319"></a>19319 
<a name="l19320"></a>19320       <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a3db62d6a21012733426fc5125da9f458">read_type_die</a> (type_die, type_cu);
<a name="l19321"></a>19321     }
<a name="l19322"></a>19322   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attr-&gt;form == DW_FORM_ref_sig8)
<a name="l19323"></a>19323     {
<a name="l19324"></a>19324       <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a743c93f0f8a0cfece75baa06b8b1f5a0">get_signatured_type</a> (die, <a class="code" href="dwarf2read_8c.html#a8ba60632a90cfabc155c69f0bf2d2f83">DW_SIGNATURE</a> (attr), cu);
<a name="l19325"></a>19325     }
<a name="l19326"></a>19326   <span class="keywordflow">else</span>
<a name="l19327"></a>19327     {
<a name="l19328"></a>19328       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l19329"></a>19329                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: DW_AT_signature has bad form %s in DIE&quot;</span>
<a name="l19330"></a>19330                    <span class="stringliteral">&quot; at 0x%x [in module %s]&quot;</span>),
<a name="l19331"></a>19331                  <a class="code" href="dwarf2read_8c.html#a6810653c49d4b3be30290dc1bcf20c94">dwarf_form_name</a> (attr-&gt;form), die-&gt;offset.sect_off,
<a name="l19332"></a>19332                  <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (dwarf2_per_objfile-&gt;objfile));
<a name="l19333"></a>19333       <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#a4a3b5d2bd904b30c13a2c22b09778ae6">build_error_marker_type</a> (cu, die);
<a name="l19334"></a>19334     }
<a name="l19335"></a>19335 }
<a name="l19336"></a>19336 
<a name="l19337"></a>19337 <span class="comment">/* Load the DIEs associated with type unit PER_CU into memory.  */</span>
<a name="l19338"></a>19338 
<a name="l19339"></a>19339 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l19340"></a><a class="code" href="dwarf2read_8c.html#a1d0f2204cbb2e3c2103d9e9a40b97f61">19340</a> <a class="code" href="dwarf2read_8c.html#a1d0f2204cbb2e3c2103d9e9a40b97f61">load_full_type_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l19341"></a>19341 {
<a name="l19342"></a>19342   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type;
<a name="l19343"></a>19343 
<a name="l19344"></a>19344   <span class="comment">/* Caller is responsible for ensuring type_unit_groups don&#39;t get here.  */</span>
<a name="l19345"></a>19345   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (! <a class="code" href="dwarf2read_8c.html#aa278b6364c9b859353eeea535d81221e">IS_TYPE_UNIT_GROUP</a> (per_cu));
<a name="l19346"></a>19346 
<a name="l19347"></a>19347   <span class="comment">/* We have the per_cu, but we need the signatured_type.</span>
<a name="l19348"></a>19348 <span class="comment">     Fortunately this is an easy translation.  */</span>
<a name="l19349"></a>19349   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l19350"></a>19350   sig_type = (<span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *) per_cu;
<a name="l19351"></a>19351 
<a name="l19352"></a>19352   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> == NULL);
<a name="l19353"></a>19353 
<a name="l19354"></a>19354   <a class="code" href="dwarf2read_8c.html#acb79afa78ab76b39b5a27f8135e60509">read_signatured_type</a> (sig_type);
<a name="l19355"></a>19355 
<a name="l19356"></a>19356   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> != NULL);
<a name="l19357"></a>19357 }
<a name="l19358"></a>19358 
<a name="l19359"></a>19359 <span class="comment">/* die_reader_func for read_signatured_type.</span>
<a name="l19360"></a>19360 <span class="comment">   This is identical to load_full_comp_unit_reader,</span>
<a name="l19361"></a>19361 <span class="comment">   but is kept separate for now.  */</span>
<a name="l19362"></a>19362 
<a name="l19363"></a>19363 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l19364"></a><a class="code" href="dwarf2read_8c.html#acc8fafa1196f727efa36b45329eb5892">19364</a> <a class="code" href="dwarf2read_8c.html#acc8fafa1196f727efa36b45329eb5892">read_signatured_type_reader</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structdie__reader__specs.html">die_reader_specs</a> *reader,
<a name="l19365"></a>19365                              <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr,
<a name="l19366"></a>19366                              <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *comp_unit_die,
<a name="l19367"></a>19367                              <span class="keywordtype">int</span> has_children,
<a name="l19368"></a>19368                              <span class="keywordtype">void</span> *data)
<a name="l19369"></a>19369 {
<a name="l19370"></a>19370   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = reader-&gt;<a class="code" href="structdie__reader__specs.html#a328659b366729a75fe286d8b2c3d419a">cu</a>;
<a name="l19371"></a>19371 
<a name="l19372"></a>19372   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a681ffa0c8fdc7c63efa8fffb2a441f12">die_hash</a> == NULL);
<a name="l19373"></a>19373   cu-&gt;<a class="code" href="structdwarf2__cu.html#a681ffa0c8fdc7c63efa8fffb2a441f12">die_hash</a> =
<a name="l19374"></a>19374     htab_create_alloc_ex (cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#a769873371bdcd274e277b2c51bdc775b">length</a> / 12,
<a name="l19375"></a>19375                           <a class="code" href="dwarf2read_8c.html#a265b107f617db27d5a264d29218175d7">die_hash</a>,
<a name="l19376"></a>19376                           <a class="code" href="dwarf2read_8c.html#aaff47c3e3a9ffa480689aceb5a696060">die_eq</a>,
<a name="l19377"></a>19377                           NULL,
<a name="l19378"></a>19378                           &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>,
<a name="l19379"></a>19379                           <a class="code" href="utils_8c.html#a64b0a5e317b6f45f062aa8356111644b">hashtab_obstack_allocate</a>,
<a name="l19380"></a>19380                           <a class="code" href="utils_8c.html#af32d0d55c7c49d59093e66ef695f9513">dummy_obstack_deallocate</a>);
<a name="l19381"></a>19381 
<a name="l19382"></a>19382   <span class="keywordflow">if</span> (has_children)
<a name="l19383"></a>19383     comp_unit_die-&gt;child = <a class="code" href="dwarf2read_8c.html#a79a10115d28e35221fb4b78c2023be76">read_die_and_siblings</a> (reader, info_ptr,
<a name="l19384"></a>19384                                                   &amp;info_ptr, comp_unit_die);
<a name="l19385"></a>19385   cu-&gt;<a class="code" href="structdwarf2__cu.html#abc8aaad6bb3799398e9769f989fd1692">dies</a> = comp_unit_die;
<a name="l19386"></a>19386   <span class="comment">/* comp_unit_die is not stored in die_hash, no need.  */</span>
<a name="l19387"></a>19387 
<a name="l19388"></a>19388   <span class="comment">/* We try not to read any attributes in this function, because not</span>
<a name="l19389"></a>19389 <span class="comment">     all CUs needed for references have been loaded yet, and symbol</span>
<a name="l19390"></a>19390 <span class="comment">     table processing isn&#39;t initialized.  But we have to set the CU language,</span>
<a name="l19391"></a>19391 <span class="comment">     or we won&#39;t be able to build types correctly.</span>
<a name="l19392"></a>19392 <span class="comment">     Similarly, if we do not read the producer, we can not apply</span>
<a name="l19393"></a>19393 <span class="comment">     producer-specific interpretation.  */</span>
<a name="l19394"></a>19394   <a class="code" href="dwarf2read_8c.html#a7a6cb8459a76588ce7ef6a56b19ef5c8">prepare_one_comp_unit</a> (cu, cu-&gt;<a class="code" href="structdwarf2__cu.html#abc8aaad6bb3799398e9769f989fd1692">dies</a>, <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a389b59241274e837cb0d28b1909013ac">language_minimal</a>);
<a name="l19395"></a>19395 }
<a name="l19396"></a>19396 
<a name="l19397"></a>19397 <span class="comment">/* Read in a signatured type and build its CU and DIEs.</span>
<a name="l19398"></a>19398 <span class="comment">   If the type is a stub for the real type in a DWO file,</span>
<a name="l19399"></a>19399 <span class="comment">   read in the real type from the DWO file as well.  */</span>
<a name="l19400"></a>19400 
<a name="l19401"></a>19401 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l19402"></a><a class="code" href="dwarf2read_8c.html#acb79afa78ab76b39b5a27f8135e60509">19402</a> <a class="code" href="dwarf2read_8c.html#acb79afa78ab76b39b5a27f8135e60509">read_signatured_type</a> (<span class="keyword">struct</span> <a class="code" href="structsignatured__type.html">signatured_type</a> *sig_type)
<a name="l19403"></a>19403 {
<a name="l19404"></a>19404   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu = &amp;sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>;
<a name="l19405"></a>19405 
<a name="l19406"></a>19406   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#abaa41e72f92f1cad7850a911e1a1ae5c">is_debug_types</a>);
<a name="l19407"></a>19407   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> == NULL);
<a name="l19408"></a>19408 
<a name="l19409"></a>19409   <a class="code" href="dwarf2read_8c.html#a2887b925bcf54483d1c0dc40faefdd08">init_cutu_and_read_dies</a> (per_cu, NULL, 0, 1,
<a name="l19410"></a>19410                            <a class="code" href="dwarf2read_8c.html#acc8fafa1196f727efa36b45329eb5892">read_signatured_type_reader</a>, NULL);
<a name="l19411"></a>19411   sig_type-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#ace5ce61a37eefad9502e7d9881173de8">tu_read</a> = 1;
<a name="l19412"></a>19412 }
<a name="l19413"></a>19413 
<a name="l19414"></a>19414 <span class="comment">/* Decode simple location descriptions.</span>
<a name="l19415"></a>19415 <span class="comment">   Given a pointer to a dwarf block that defines a location, compute</span>
<a name="l19416"></a>19416 <span class="comment">   the location and return the value.</span>
<a name="l19417"></a>19417 <span class="comment"></span>
<a name="l19418"></a>19418 <span class="comment">   NOTE drow/2003-11-18: This function is called in two situations</span>
<a name="l19419"></a>19419 <span class="comment">   now: for the address of static or global variables (partial symbols</span>
<a name="l19420"></a>19420 <span class="comment">   only) and for offsets into structures which are expected to be</span>
<a name="l19421"></a>19421 <span class="comment">   (more or less) constant.  The partial symbol case should go away,</span>
<a name="l19422"></a>19422 <span class="comment">   and only the constant case should remain.  That will let this</span>
<a name="l19423"></a>19423 <span class="comment">   function complain more accurately.  A few special modes are allowed</span>
<a name="l19424"></a>19424 <span class="comment">   without complaint for global variables (for instance, global</span>
<a name="l19425"></a>19425 <span class="comment">   register values and thread-local values).</span>
<a name="l19426"></a>19426 <span class="comment"></span>
<a name="l19427"></a>19427 <span class="comment">   A location description containing no operations indicates that the</span>
<a name="l19428"></a>19428 <span class="comment">   object is optimized out.  The return value is 0 for that case.</span>
<a name="l19429"></a>19429 <span class="comment">   FIXME drow/2003-11-16: No callers check for this case any more; soon all</span>
<a name="l19430"></a>19430 <span class="comment">   callers will only want a very basic result and this can become a</span>
<a name="l19431"></a>19431 <span class="comment">   complaint.</span>
<a name="l19432"></a>19432 <span class="comment"></span>
<a name="l19433"></a>19433 <span class="comment">   Note that stack[0] is unused except as a default error return.  */</span>
<a name="l19434"></a>19434 
<a name="l19435"></a>19435 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l19436"></a><a class="code" href="dwarf2read_8c.html#ab042fa76d14a2a97bb1b0d6f75e60d79">19436</a> <a class="code" href="dwarf2read_8c.html#ab042fa76d14a2a97bb1b0d6f75e60d79">decode_locdesc</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf__block.html">dwarf_block</a> *blk, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>)
<a name="l19437"></a>19437 {
<a name="l19438"></a>19438   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l19439"></a>19439   <span class="keywordtype">size_t</span> i;
<a name="l19440"></a>19440   <span class="keywordtype">size_t</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> = blk-&gt;<a class="code" href="structdwarf__block.html#a951a7a5de6216eb772be5fe7df7e7865">size</a>;
<a name="l19441"></a>19441   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *data = blk-&gt;<a class="code" href="structdwarf__block.html#af3a8e3eb0d783b103b0078662dbdc211">data</a>;
<a name="l19442"></a>19442   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> stack[64];
<a name="l19443"></a>19443   <span class="keywordtype">int</span> stacki;
<a name="l19444"></a>19444   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read, unsnd;
<a name="l19445"></a>19445   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> op;
<a name="l19446"></a>19446 
<a name="l19447"></a>19447   i = 0;
<a name="l19448"></a>19448   stacki = 0;
<a name="l19449"></a>19449   stack[stacki] = 0;
<a name="l19450"></a>19450   stack[++stacki] = 0;
<a name="l19451"></a>19451 
<a name="l19452"></a>19452   <span class="keywordflow">while</span> (i &lt; size)
<a name="l19453"></a>19453     {
<a name="l19454"></a>19454       op = data[i++];
<a name="l19455"></a>19455       <span class="keywordflow">switch</span> (op)
<a name="l19456"></a>19456         {
<a name="l19457"></a>19457         <span class="keywordflow">case</span> DW_OP_lit0:
<a name="l19458"></a>19458         <span class="keywordflow">case</span> DW_OP_lit1:
<a name="l19459"></a>19459         <span class="keywordflow">case</span> DW_OP_lit2:
<a name="l19460"></a>19460         <span class="keywordflow">case</span> DW_OP_lit3:
<a name="l19461"></a>19461         <span class="keywordflow">case</span> DW_OP_lit4:
<a name="l19462"></a>19462         <span class="keywordflow">case</span> DW_OP_lit5:
<a name="l19463"></a>19463         <span class="keywordflow">case</span> DW_OP_lit6:
<a name="l19464"></a>19464         <span class="keywordflow">case</span> DW_OP_lit7:
<a name="l19465"></a>19465         <span class="keywordflow">case</span> DW_OP_lit8:
<a name="l19466"></a>19466         <span class="keywordflow">case</span> DW_OP_lit9:
<a name="l19467"></a>19467         <span class="keywordflow">case</span> DW_OP_lit10:
<a name="l19468"></a>19468         <span class="keywordflow">case</span> DW_OP_lit11:
<a name="l19469"></a>19469         <span class="keywordflow">case</span> DW_OP_lit12:
<a name="l19470"></a>19470         <span class="keywordflow">case</span> DW_OP_lit13:
<a name="l19471"></a>19471         <span class="keywordflow">case</span> DW_OP_lit14:
<a name="l19472"></a>19472         <span class="keywordflow">case</span> DW_OP_lit15:
<a name="l19473"></a>19473         <span class="keywordflow">case</span> DW_OP_lit16:
<a name="l19474"></a>19474         <span class="keywordflow">case</span> DW_OP_lit17:
<a name="l19475"></a>19475         <span class="keywordflow">case</span> DW_OP_lit18:
<a name="l19476"></a>19476         <span class="keywordflow">case</span> DW_OP_lit19:
<a name="l19477"></a>19477         <span class="keywordflow">case</span> DW_OP_lit20:
<a name="l19478"></a>19478         <span class="keywordflow">case</span> DW_OP_lit21:
<a name="l19479"></a>19479         <span class="keywordflow">case</span> DW_OP_lit22:
<a name="l19480"></a>19480         <span class="keywordflow">case</span> DW_OP_lit23:
<a name="l19481"></a>19481         <span class="keywordflow">case</span> DW_OP_lit24:
<a name="l19482"></a>19482         <span class="keywordflow">case</span> DW_OP_lit25:
<a name="l19483"></a>19483         <span class="keywordflow">case</span> DW_OP_lit26:
<a name="l19484"></a>19484         <span class="keywordflow">case</span> DW_OP_lit27:
<a name="l19485"></a>19485         <span class="keywordflow">case</span> DW_OP_lit28:
<a name="l19486"></a>19486         <span class="keywordflow">case</span> DW_OP_lit29:
<a name="l19487"></a>19487         <span class="keywordflow">case</span> DW_OP_lit30:
<a name="l19488"></a>19488         <span class="keywordflow">case</span> DW_OP_lit31:
<a name="l19489"></a>19489           stack[++stacki] = op - DW_OP_lit0;
<a name="l19490"></a>19490           <span class="keywordflow">break</span>;
<a name="l19491"></a>19491 
<a name="l19492"></a>19492         <span class="keywordflow">case</span> DW_OP_reg0:
<a name="l19493"></a>19493         <span class="keywordflow">case</span> DW_OP_reg1:
<a name="l19494"></a>19494         <span class="keywordflow">case</span> DW_OP_reg2:
<a name="l19495"></a>19495         <span class="keywordflow">case</span> DW_OP_reg3:
<a name="l19496"></a>19496         <span class="keywordflow">case</span> DW_OP_reg4:
<a name="l19497"></a>19497         <span class="keywordflow">case</span> DW_OP_reg5:
<a name="l19498"></a>19498         <span class="keywordflow">case</span> DW_OP_reg6:
<a name="l19499"></a>19499         <span class="keywordflow">case</span> DW_OP_reg7:
<a name="l19500"></a>19500         <span class="keywordflow">case</span> DW_OP_reg8:
<a name="l19501"></a>19501         <span class="keywordflow">case</span> DW_OP_reg9:
<a name="l19502"></a>19502         <span class="keywordflow">case</span> DW_OP_reg10:
<a name="l19503"></a>19503         <span class="keywordflow">case</span> DW_OP_reg11:
<a name="l19504"></a>19504         <span class="keywordflow">case</span> DW_OP_reg12:
<a name="l19505"></a>19505         <span class="keywordflow">case</span> DW_OP_reg13:
<a name="l19506"></a>19506         <span class="keywordflow">case</span> DW_OP_reg14:
<a name="l19507"></a>19507         <span class="keywordflow">case</span> DW_OP_reg15:
<a name="l19508"></a>19508         <span class="keywordflow">case</span> DW_OP_reg16:
<a name="l19509"></a>19509         <span class="keywordflow">case</span> DW_OP_reg17:
<a name="l19510"></a>19510         <span class="keywordflow">case</span> DW_OP_reg18:
<a name="l19511"></a>19511         <span class="keywordflow">case</span> DW_OP_reg19:
<a name="l19512"></a>19512         <span class="keywordflow">case</span> DW_OP_reg20:
<a name="l19513"></a>19513         <span class="keywordflow">case</span> DW_OP_reg21:
<a name="l19514"></a>19514         <span class="keywordflow">case</span> DW_OP_reg22:
<a name="l19515"></a>19515         <span class="keywordflow">case</span> DW_OP_reg23:
<a name="l19516"></a>19516         <span class="keywordflow">case</span> DW_OP_reg24:
<a name="l19517"></a>19517         <span class="keywordflow">case</span> DW_OP_reg25:
<a name="l19518"></a>19518         <span class="keywordflow">case</span> DW_OP_reg26:
<a name="l19519"></a>19519         <span class="keywordflow">case</span> DW_OP_reg27:
<a name="l19520"></a>19520         <span class="keywordflow">case</span> DW_OP_reg28:
<a name="l19521"></a>19521         <span class="keywordflow">case</span> DW_OP_reg29:
<a name="l19522"></a>19522         <span class="keywordflow">case</span> DW_OP_reg30:
<a name="l19523"></a>19523         <span class="keywordflow">case</span> DW_OP_reg31:
<a name="l19524"></a>19524           stack[++stacki] = op - DW_OP_reg0;
<a name="l19525"></a>19525           <span class="keywordflow">if</span> (i &lt; size)
<a name="l19526"></a>19526             <a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">dwarf2_complex_location_expr_complaint</a> ();
<a name="l19527"></a>19527           <span class="keywordflow">break</span>;
<a name="l19528"></a>19528 
<a name="l19529"></a>19529         <span class="keywordflow">case</span> DW_OP_regx:
<a name="l19530"></a>19530           unsnd = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (NULL, (data + i), &amp;bytes_read);
<a name="l19531"></a>19531           i += bytes_read;
<a name="l19532"></a>19532           stack[++stacki] = unsnd;
<a name="l19533"></a>19533           <span class="keywordflow">if</span> (i &lt; size)
<a name="l19534"></a>19534             <a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">dwarf2_complex_location_expr_complaint</a> ();
<a name="l19535"></a>19535           <span class="keywordflow">break</span>;
<a name="l19536"></a>19536 
<a name="l19537"></a>19537         <span class="keywordflow">case</span> DW_OP_addr:
<a name="l19538"></a>19538           stack[++stacki] = <a class="code" href="dwarf2read_8c.html#a15a6057864c7bae887725caafe5db6f7">read_address</a> (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>, &amp;data[i],
<a name="l19539"></a>19539                                           cu, &amp;bytes_read);
<a name="l19540"></a>19540           i += bytes_read;
<a name="l19541"></a>19541           <span class="keywordflow">break</span>;
<a name="l19542"></a>19542 
<a name="l19543"></a>19543         <span class="keywordflow">case</span> DW_OP_const1u:
<a name="l19544"></a>19544           stack[++stacki] = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>, &amp;data[i]);
<a name="l19545"></a>19545           i += 1;
<a name="l19546"></a>19546           <span class="keywordflow">break</span>;
<a name="l19547"></a>19547 
<a name="l19548"></a>19548         <span class="keywordflow">case</span> DW_OP_const1s:
<a name="l19549"></a>19549           stack[++stacki] = <a class="code" href="dwarf2read_8c.html#a29c46d3cfe71a70e5ba65f3cd31c3ad5">read_1_signed_byte</a> (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>, &amp;data[i]);
<a name="l19550"></a>19550           i += 1;
<a name="l19551"></a>19551           <span class="keywordflow">break</span>;
<a name="l19552"></a>19552 
<a name="l19553"></a>19553         <span class="keywordflow">case</span> DW_OP_const2u:
<a name="l19554"></a>19554           stack[++stacki] = <a class="code" href="dwarf2read_8c.html#a35663eebf65b4217082f14bc1f782307">read_2_bytes</a> (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>, &amp;data[i]);
<a name="l19555"></a>19555           i += 2;
<a name="l19556"></a>19556           <span class="keywordflow">break</span>;
<a name="l19557"></a>19557 
<a name="l19558"></a>19558         <span class="keywordflow">case</span> DW_OP_const2s:
<a name="l19559"></a>19559           stack[++stacki] = <a class="code" href="dwarf2read_8c.html#ab9f2390820a5e378c1ed97fba7ca1800">read_2_signed_bytes</a> (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>, &amp;data[i]);
<a name="l19560"></a>19560           i += 2;
<a name="l19561"></a>19561           <span class="keywordflow">break</span>;
<a name="l19562"></a>19562 
<a name="l19563"></a>19563         <span class="keywordflow">case</span> DW_OP_const4u:
<a name="l19564"></a>19564           stack[++stacki] = <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>, &amp;data[i]);
<a name="l19565"></a>19565           i += 4;
<a name="l19566"></a>19566           <span class="keywordflow">break</span>;
<a name="l19567"></a>19567 
<a name="l19568"></a>19568         <span class="keywordflow">case</span> DW_OP_const4s:
<a name="l19569"></a>19569           stack[++stacki] = <a class="code" href="dwarf2read_8c.html#a1d9409b16aeaceb60c53209d05d9c65c">read_4_signed_bytes</a> (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>, &amp;data[i]);
<a name="l19570"></a>19570           i += 4;
<a name="l19571"></a>19571           <span class="keywordflow">break</span>;
<a name="l19572"></a>19572 
<a name="l19573"></a>19573         <span class="keywordflow">case</span> DW_OP_const8u:
<a name="l19574"></a>19574           stack[++stacki] = <a class="code" href="dwarf2read_8c.html#af21c01feb67cfb3cd240c3ac803dd021">read_8_bytes</a> (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>, &amp;data[i]);
<a name="l19575"></a>19575           i += 8;
<a name="l19576"></a>19576           <span class="keywordflow">break</span>;
<a name="l19577"></a>19577 
<a name="l19578"></a>19578         <span class="keywordflow">case</span> DW_OP_constu:
<a name="l19579"></a>19579           stack[++stacki] = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (NULL, (data + i),
<a name="l19580"></a>19580                                                   &amp;bytes_read);
<a name="l19581"></a>19581           i += bytes_read;
<a name="l19582"></a>19582           <span class="keywordflow">break</span>;
<a name="l19583"></a>19583 
<a name="l19584"></a>19584         <span class="keywordflow">case</span> DW_OP_consts:
<a name="l19585"></a>19585           stack[++stacki] = <a class="code" href="dwarf2read_8c.html#adfbc149c8807d37b14d0d217da31ada0">read_signed_leb128</a> (NULL, (data + i), &amp;bytes_read);
<a name="l19586"></a>19586           i += bytes_read;
<a name="l19587"></a>19587           <span class="keywordflow">break</span>;
<a name="l19588"></a>19588 
<a name="l19589"></a>19589         <span class="keywordflow">case</span> DW_OP_dup:
<a name="l19590"></a>19590           stack[stacki + 1] = stack[stacki];
<a name="l19591"></a>19591           stacki++;
<a name="l19592"></a>19592           <span class="keywordflow">break</span>;
<a name="l19593"></a>19593 
<a name="l19594"></a>19594         <span class="keywordflow">case</span> DW_OP_plus:
<a name="l19595"></a>19595           stack[stacki - 1] += stack[stacki];
<a name="l19596"></a>19596           stacki--;
<a name="l19597"></a>19597           <span class="keywordflow">break</span>;
<a name="l19598"></a>19598 
<a name="l19599"></a>19599         <span class="keywordflow">case</span> DW_OP_plus_uconst:
<a name="l19600"></a>19600           stack[stacki] += <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (NULL, (data + i),
<a name="l19601"></a>19601                                                  &amp;bytes_read);
<a name="l19602"></a>19602           i += bytes_read;
<a name="l19603"></a>19603           <span class="keywordflow">break</span>;
<a name="l19604"></a>19604 
<a name="l19605"></a>19605         <span class="keywordflow">case</span> DW_OP_minus:
<a name="l19606"></a>19606           stack[stacki - 1] -= stack[stacki];
<a name="l19607"></a>19607           stacki--;
<a name="l19608"></a>19608           <span class="keywordflow">break</span>;
<a name="l19609"></a>19609 
<a name="l19610"></a>19610         <span class="keywordflow">case</span> DW_OP_deref:
<a name="l19611"></a>19611           <span class="comment">/* If we&#39;re not the last op, then we definitely can&#39;t encode</span>
<a name="l19612"></a>19612 <span class="comment">             this using GDB&#39;s address_class enum.  This is valid for partial</span>
<a name="l19613"></a>19613 <span class="comment">             global symbols, although the variable&#39;s address will be bogus</span>
<a name="l19614"></a>19614 <span class="comment">             in the psymtab.  */</span>
<a name="l19615"></a>19615           <span class="keywordflow">if</span> (i &lt; size)
<a name="l19616"></a>19616             <a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">dwarf2_complex_location_expr_complaint</a> ();
<a name="l19617"></a>19617           <span class="keywordflow">break</span>;
<a name="l19618"></a>19618 
<a name="l19619"></a>19619         <span class="keywordflow">case</span> DW_OP_GNU_push_tls_address:
<a name="l19620"></a>19620           <span class="comment">/* The top of the stack has the offset from the beginning</span>
<a name="l19621"></a>19621 <span class="comment">             of the thread control block at which the variable is located.  */</span>
<a name="l19622"></a>19622           <span class="comment">/* Nothing should follow this operator, so the top of stack would</span>
<a name="l19623"></a>19623 <span class="comment">             be returned.  */</span>
<a name="l19624"></a>19624           <span class="comment">/* This is valid for partial global symbols, but the variable&#39;s</span>
<a name="l19625"></a>19625 <span class="comment">             address will be bogus in the psymtab.  Make it always at least</span>
<a name="l19626"></a>19626 <span class="comment">             non-zero to not look as a variable garbage collected by linker</span>
<a name="l19627"></a>19627 <span class="comment">             which have DW_OP_addr 0.  */</span>
<a name="l19628"></a>19628           <span class="keywordflow">if</span> (i &lt; size)
<a name="l19629"></a>19629             <a class="code" href="dwarf2read_8c.html#a8a3666a7138b4f2acb940e652d20cc28">dwarf2_complex_location_expr_complaint</a> ();
<a name="l19630"></a>19630           stack[stacki]++;
<a name="l19631"></a>19631           <span class="keywordflow">break</span>;
<a name="l19632"></a>19632 
<a name="l19633"></a>19633         <span class="keywordflow">case</span> DW_OP_GNU_uninit:
<a name="l19634"></a>19634           <span class="keywordflow">break</span>;
<a name="l19635"></a>19635 
<a name="l19636"></a>19636         <span class="keywordflow">case</span> DW_OP_GNU_addr_index:
<a name="l19637"></a>19637         <span class="keywordflow">case</span> DW_OP_GNU_const_index:
<a name="l19638"></a>19638           stack[++stacki] = <a class="code" href="dwarf2read_8c.html#a62579cbb3d5cf28bac5bff46f3d7ed11">read_addr_index_from_leb128</a> (cu, &amp;data[i],
<a name="l19639"></a>19639                                                          &amp;bytes_read);
<a name="l19640"></a>19640           i += bytes_read;
<a name="l19641"></a>19641           <span class="keywordflow">break</span>;
<a name="l19642"></a>19642 
<a name="l19643"></a>19643         <span class="keywordflow">default</span>:
<a name="l19644"></a>19644           {
<a name="l19645"></a>19645             <span class="keyword">const</span> <span class="keywordtype">char</span> *name = get_DW_OP_name (op);
<a name="l19646"></a>19646 
<a name="l19647"></a>19647             <span class="keywordflow">if</span> (name)
<a name="l19648"></a>19648               <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unsupported stack op: &#39;%s&#39;&quot;</span>),
<a name="l19649"></a>19649                          name);
<a name="l19650"></a>19650             <span class="keywordflow">else</span>
<a name="l19651"></a>19651               <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unsupported stack op: &#39;%02x&#39;&quot;</span>),
<a name="l19652"></a>19652                          op);
<a name="l19653"></a>19653           }
<a name="l19654"></a>19654 
<a name="l19655"></a>19655           <span class="keywordflow">return</span> (stack[stacki]);
<a name="l19656"></a>19656         }
<a name="l19657"></a>19657 
<a name="l19658"></a>19658       <span class="comment">/* Enforce maximum stack depth of SIZE-1 to avoid writing</span>
<a name="l19659"></a>19659 <span class="comment">         outside of the allocated space.  Also enforce minimum&gt;0.  */</span>
<a name="l19660"></a>19660       <span class="keywordflow">if</span> (stacki &gt;= ARRAY_SIZE (stack) - 1)
<a name="l19661"></a>19661         {
<a name="l19662"></a>19662           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l19663"></a>19663                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;location description stack overflow&quot;</span>));
<a name="l19664"></a>19664           <span class="keywordflow">return</span> 0;
<a name="l19665"></a>19665         }
<a name="l19666"></a>19666 
<a name="l19667"></a>19667       <span class="keywordflow">if</span> (stacki &lt;= 0)
<a name="l19668"></a>19668         {
<a name="l19669"></a>19669           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l19670"></a>19670                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;location description stack underflow&quot;</span>));
<a name="l19671"></a>19671           <span class="keywordflow">return</span> 0;
<a name="l19672"></a>19672         }
<a name="l19673"></a>19673     }
<a name="l19674"></a>19674   <span class="keywordflow">return</span> (stack[stacki]);
<a name="l19675"></a>19675 }
<a name="l19676"></a>19676 
<a name="l19677"></a>19677 <span class="comment">/* memory allocation interface */</span>
<a name="l19678"></a>19678 
<a name="l19679"></a>19679 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwarf__block.html">dwarf_block</a> *
<a name="l19680"></a><a class="code" href="dwarf2read_8c.html#ad90eafda28bec4d8aedfc8e1f37b210a">19680</a> <a class="code" href="dwarf2read_8c.html#ad90eafda28bec4d8aedfc8e1f37b210a">dwarf_alloc_block</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l19681"></a>19681 {
<a name="l19682"></a>19682   <span class="keyword">struct </span><a class="code" href="structdwarf__block.html">dwarf_block</a> *blk;
<a name="l19683"></a>19683 
<a name="l19684"></a>19684   blk = (<span class="keyword">struct </span><a class="code" href="structdwarf__block.html">dwarf_block</a> *)
<a name="l19685"></a>19685     obstack_alloc (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>, sizeof (<span class="keyword">struct</span> <a class="code" href="structdwarf__block.html">dwarf_block</a>));
<a name="l19686"></a>19686   <span class="keywordflow">return</span> (blk);
<a name="l19687"></a>19687 }
<a name="l19688"></a>19688 
<a name="l19689"></a>19689 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *
<a name="l19690"></a><a class="code" href="dwarf2read_8c.html#ad0de318a450615df05b9d8225925b9aa">19690</a> <a class="code" href="dwarf2read_8c.html#ad0de318a450615df05b9d8225925b9aa">dwarf_alloc_die</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <span class="keywordtype">int</span> num_attrs)
<a name="l19691"></a>19691 {
<a name="l19692"></a>19692   <span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *die;
<a name="l19693"></a>19693   <span class="keywordtype">size_t</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> = <span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a>);
<a name="l19694"></a>19694 
<a name="l19695"></a>19695   <span class="keywordflow">if</span> (num_attrs &gt; 1)
<a name="l19696"></a>19696     size += (num_attrs - 1) * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a>);
<a name="l19697"></a>19697 
<a name="l19698"></a>19698   die = (<span class="keyword">struct </span><a class="code" href="structdie__info.html">die_info</a> *) obstack_alloc (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>, size);
<a name="l19699"></a>19699   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (die, 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a>));
<a name="l19700"></a>19700   <span class="keywordflow">return</span> (die);
<a name="l19701"></a>19701 }
<a name="l19702"></a>19702 
<a name="l19703"></a>19703 
<a name="l19704"></a>19704 <span class="comment">/* Macro support.  */</span>
<a name="l19705"></a>19705 
<a name="l19706"></a>19706 <span class="comment">/* Return file name relative to the compilation directory of file number I in</span>
<a name="l19707"></a>19707 <span class="comment">   *LH&#39;s file name table.  The result is allocated using xmalloc; the caller is</span>
<a name="l19708"></a>19708 <span class="comment">   responsible for freeing it.  */</span>
<a name="l19709"></a>19709 
<a name="l19710"></a>19710 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l19711"></a><a class="code" href="dwarf2read_8c.html#ad62206f66abaaee749fcd19e62ca71be">19711</a> <a class="code" href="dwarf2read_8c.html#ad62206f66abaaee749fcd19e62ca71be">file_file_name</a> (<span class="keywordtype">int</span> file, <span class="keyword">struct</span> <a class="code" href="structline__header.html">line_header</a> *lh)
<a name="l19712"></a>19712 {
<a name="l19713"></a>19713   <span class="comment">/* Is the file number a valid index into the line header&#39;s file name</span>
<a name="l19714"></a>19714 <span class="comment">     table?  Remember that file numbers start with one, not zero.  */</span>
<a name="l19715"></a>19715   <span class="keywordflow">if</span> (1 &lt;= file &amp;&amp; file &lt;= lh-&gt;num_file_names)
<a name="l19716"></a>19716     {
<a name="l19717"></a>19717       <span class="keyword">struct </span>file_entry *fe = &amp;lh-&gt;<a class="code" href="structline__header.html#a47d25fec8ae9597a3aa37b613a06b63a">file_names</a>[file - 1];
<a name="l19718"></a>19718 
<a name="l19719"></a>19719       <span class="keywordflow">if</span> (IS_ABSOLUTE_PATH (fe-&gt;name) || fe-&gt;dir_index == 0)
<a name="l19720"></a>19720         <span class="keywordflow">return</span> xstrdup (fe-&gt;name);
<a name="l19721"></a>19721       <span class="keywordflow">return</span> concat (lh-&gt;<a class="code" href="structline__header.html#a4bf9561447bf945863b08c4dc1a5488f">include_dirs</a>[fe-&gt;dir_index - 1], SLASH_STRING,
<a name="l19722"></a>19722                      fe-&gt;name, NULL);
<a name="l19723"></a>19723     }
<a name="l19724"></a>19724   <span class="keywordflow">else</span>
<a name="l19725"></a>19725     {
<a name="l19726"></a>19726       <span class="comment">/* The compiler produced a bogus file number.  We can at least</span>
<a name="l19727"></a>19727 <span class="comment">         record the macro definitions made in the file, even if we</span>
<a name="l19728"></a>19728 <span class="comment">         won&#39;t be able to find the file by name.  */</span>
<a name="l19729"></a>19729       <span class="keywordtype">char</span> fake_name[80];
<a name="l19730"></a>19730 
<a name="l19731"></a>19731       <a class="code" href="common-utils_8c.html#ad9940337ec98983dae9951c947879fc8">xsnprintf</a> (fake_name, <span class="keyword">sizeof</span> (fake_name),
<a name="l19732"></a>19732                  <span class="stringliteral">&quot;&lt;bad macro file number %d&gt;&quot;</span>, file);
<a name="l19733"></a>19733 
<a name="l19734"></a>19734       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l19735"></a>19735                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;bad file number in macro information (%d)&quot;</span>),
<a name="l19736"></a>19736                  file);
<a name="l19737"></a>19737 
<a name="l19738"></a>19738       <span class="keywordflow">return</span> xstrdup (fake_name);
<a name="l19739"></a>19739     }
<a name="l19740"></a>19740 }
<a name="l19741"></a>19741 
<a name="l19742"></a>19742 <span class="comment">/* Return the full name of file number I in *LH&#39;s file name table.</span>
<a name="l19743"></a>19743 <span class="comment">   Use COMP_DIR as the name of the current directory of the</span>
<a name="l19744"></a>19744 <span class="comment">   compilation.  The result is allocated using xmalloc; the caller is</span>
<a name="l19745"></a>19745 <span class="comment">   responsible for freeing it.  */</span>
<a name="l19746"></a>19746 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l19747"></a><a class="code" href="dwarf2read_8c.html#a10e5b152dbd3c862a6832d5028b0d1d1">19747</a> <a class="code" href="dwarf2read_8c.html#a10e5b152dbd3c862a6832d5028b0d1d1">file_full_name</a> (<span class="keywordtype">int</span> file, <span class="keyword">struct</span> <a class="code" href="structline__header.html">line_header</a> *lh, <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir)
<a name="l19748"></a>19748 {
<a name="l19749"></a>19749   <span class="comment">/* Is the file number a valid index into the line header&#39;s file name</span>
<a name="l19750"></a>19750 <span class="comment">     table?  Remember that file numbers start with one, not zero.  */</span>
<a name="l19751"></a>19751   <span class="keywordflow">if</span> (1 &lt;= file &amp;&amp; file &lt;= lh-&gt;num_file_names)
<a name="l19752"></a>19752     {
<a name="l19753"></a>19753       <span class="keywordtype">char</span> *relative = <a class="code" href="dwarf2read_8c.html#ad62206f66abaaee749fcd19e62ca71be">file_file_name</a> (file, lh);
<a name="l19754"></a>19754 
<a name="l19755"></a>19755       <span class="keywordflow">if</span> (IS_ABSOLUTE_PATH (relative) || comp_dir == NULL)
<a name="l19756"></a>19756         <span class="keywordflow">return</span> relative;
<a name="l19757"></a>19757       <span class="keywordflow">return</span> reconcat (relative, comp_dir, SLASH_STRING, relative, NULL);
<a name="l19758"></a>19758     }
<a name="l19759"></a>19759   <span class="keywordflow">else</span>
<a name="l19760"></a>19760     <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#ad62206f66abaaee749fcd19e62ca71be">file_file_name</a> (file, lh);
<a name="l19761"></a>19761 }
<a name="l19762"></a>19762 
<a name="l19763"></a>19763 
<a name="l19764"></a>19764 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structmacro__source__file.html">macro_source_file</a> *
<a name="l19765"></a><a class="code" href="dwarf2read_8c.html#af8d39cfd2d056b6852bbfafb66f384c5">19765</a> <a class="code" href="dwarf2read_8c.html#af8d39cfd2d056b6852bbfafb66f384c5">macro_start_file</a> (<span class="keywordtype">int</span> file, <span class="keywordtype">int</span> <a class="code" href="symtab_8h.html#a41ebd28ef1d7c6ade45642cb6acc1039">line</a>,
<a name="l19766"></a>19766                   <span class="keyword">struct</span> <a class="code" href="structmacro__source__file.html">macro_source_file</a> *current_file,
<a name="l19767"></a>19767                   <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir,
<a name="l19768"></a>19768                   <span class="keyword">struct</span> <a class="code" href="structline__header.html">line_header</a> *lh, <span class="keyword">struct</span> objfile *objfile)
<a name="l19769"></a>19769 {
<a name="l19770"></a>19770   <span class="comment">/* File name relative to the compilation directory of this source file.  */</span>
<a name="l19771"></a>19771   <span class="keywordtype">char</span> *file_name = <a class="code" href="dwarf2read_8c.html#ad62206f66abaaee749fcd19e62ca71be">file_file_name</a> (file, lh);
<a name="l19772"></a>19772 
<a name="l19773"></a>19773   <span class="keywordflow">if</span> (! current_file)
<a name="l19774"></a>19774     {
<a name="l19775"></a>19775       <span class="comment">/* Note: We don&#39;t create a macro table for this compilation unit</span>
<a name="l19776"></a>19776 <span class="comment">         at all until we actually get a filename.  */</span>
<a name="l19777"></a>19777       <span class="keyword">struct </span><a class="code" href="structmacro__table.html">macro_table</a> *<a class="code" href="structmacro__table.html">macro_table</a> = <a class="code" href="buildsym_8c.html#ada1273df8dc34624df4167b0041e832e">get_macro_table</a> (objfile, comp_dir);
<a name="l19778"></a>19778 
<a name="l19779"></a>19779       <span class="comment">/* If we have no current file, then this must be the start_file</span>
<a name="l19780"></a>19780 <span class="comment">         directive for the compilation unit&#39;s main source file.  */</span>
<a name="l19781"></a>19781       current_file = <a class="code" href="macrotab_8c.html#ad52744d7f1f8160ec766fca13e2cf9d3">macro_set_main</a> (macro_table, file_name);
<a name="l19782"></a>19782       <a class="code" href="macrotab_8c.html#aac16495906ac1862132d8c1834cd66bd">macro_define_special</a> (macro_table);
<a name="l19783"></a>19783     }
<a name="l19784"></a>19784   <span class="keywordflow">else</span>
<a name="l19785"></a>19785     current_file = <a class="code" href="macrotab_8c.html#af5a27fece6c008d7b71f715c47eb1999">macro_include</a> (current_file, line, file_name);
<a name="l19786"></a>19786 
<a name="l19787"></a>19787   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (file_name);
<a name="l19788"></a>19788 
<a name="l19789"></a>19789   <span class="keywordflow">return</span> current_file;
<a name="l19790"></a>19790 }
<a name="l19791"></a>19791 
<a name="l19792"></a>19792 
<a name="l19793"></a>19793 <span class="comment">/* Copy the LEN characters at BUF to a xmalloc&#39;ed block of memory,</span>
<a name="l19794"></a>19794 <span class="comment">   followed by a null byte.  */</span>
<a name="l19795"></a>19795 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l19796"></a><a class="code" href="dwarf2read_8c.html#a91a009933c23c89cf44557da96de7baf">19796</a> <a class="code" href="dwarf2read_8c.html#a91a009933c23c89cf44557da96de7baf">copy_string</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>)
<a name="l19797"></a>19797 {
<a name="l19798"></a>19798   <span class="keywordtype">char</span> *s = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (len + 1);
<a name="l19799"></a>19799 
<a name="l19800"></a>19800   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (s, buf, len);
<a name="l19801"></a>19801   s[<a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l19802"></a>19802   <span class="keywordflow">return</span> s;
<a name="l19803"></a>19803 }
<a name="l19804"></a>19804 
<a name="l19805"></a>19805 
<a name="l19806"></a>19806 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l19807"></a><a class="code" href="dwarf2read_8c.html#ad392783f8d498b2f1c40b1511930f2cd">19807</a> <a class="code" href="dwarf2read_8c.html#ad392783f8d498b2f1c40b1511930f2cd">consume_improper_spaces</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *p, <span class="keyword">const</span> <span class="keywordtype">char</span> *body)
<a name="l19808"></a>19808 {
<a name="l19809"></a>19809   <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39; &#39;</span>)
<a name="l19810"></a>19810     {
<a name="l19811"></a>19811       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l19812"></a>19812                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;macro definition contains spaces &quot;</span>
<a name="l19813"></a>19813                    <span class="stringliteral">&quot;in formal argument list:\n`%s&#39;&quot;</span>),
<a name="l19814"></a>19814                  body);
<a name="l19815"></a>19815 
<a name="l19816"></a>19816       <span class="keywordflow">while</span> (*p == <span class="charliteral">&#39; &#39;</span>)
<a name="l19817"></a>19817         p++;
<a name="l19818"></a>19818     }
<a name="l19819"></a>19819 
<a name="l19820"></a>19820   <span class="keywordflow">return</span> p;
<a name="l19821"></a>19821 }
<a name="l19822"></a>19822 
<a name="l19823"></a>19823 
<a name="l19824"></a>19824 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l19825"></a><a class="code" href="dwarf2read_8c.html#acc850c164674587d8e5c139dd37fcbae">19825</a> <a class="code" href="dwarf2read_8c.html#acc850c164674587d8e5c139dd37fcbae">parse_macro_definition</a> (<span class="keyword">struct</span> <a class="code" href="structmacro__source__file.html">macro_source_file</a> *file, <span class="keywordtype">int</span> <a class="code" href="symtab_8h.html#a41ebd28ef1d7c6ade45642cb6acc1039">line</a>,
<a name="l19826"></a>19826                         <span class="keyword">const</span> <span class="keywordtype">char</span> *body)
<a name="l19827"></a>19827 {
<a name="l19828"></a>19828   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>;
<a name="l19829"></a>19829 
<a name="l19830"></a>19830   <span class="comment">/* The body string takes one of two forms.  For object-like macro</span>
<a name="l19831"></a>19831 <span class="comment">     definitions, it should be:</span>
<a name="l19832"></a>19832 <span class="comment"></span>
<a name="l19833"></a>19833 <span class="comment">        &lt;macro name&gt; &quot; &quot; &lt;definition&gt;</span>
<a name="l19834"></a>19834 <span class="comment"></span>
<a name="l19835"></a>19835 <span class="comment">     For function-like macro definitions, it should be:</span>
<a name="l19836"></a>19836 <span class="comment"></span>
<a name="l19837"></a>19837 <span class="comment">        &lt;macro name&gt; &quot;() &quot; &lt;definition&gt;</span>
<a name="l19838"></a>19838 <span class="comment">     or</span>
<a name="l19839"></a>19839 <span class="comment">        &lt;macro name&gt; &quot;(&quot; &lt;arg name&gt; ( &quot;,&quot; &lt;arg name&gt; ) * &quot;) &quot; &lt;definition&gt;</span>
<a name="l19840"></a>19840 <span class="comment"></span>
<a name="l19841"></a>19841 <span class="comment">     Spaces may appear only where explicitly indicated, and in the</span>
<a name="l19842"></a>19842 <span class="comment">     &lt;definition&gt;.</span>
<a name="l19843"></a>19843 <span class="comment"></span>
<a name="l19844"></a>19844 <span class="comment">     The Dwarf 2 spec says that an object-like macro&#39;s name is always</span>
<a name="l19845"></a>19845 <span class="comment">     followed by a space, but versions of GCC around March 2002 omit</span>
<a name="l19846"></a>19846 <span class="comment">     the space when the macro&#39;s definition is the empty string.</span>
<a name="l19847"></a>19847 <span class="comment"></span>
<a name="l19848"></a>19848 <span class="comment">     The Dwarf 2 spec says that there should be no spaces between the</span>
<a name="l19849"></a>19849 <span class="comment">     formal arguments in a function-like macro&#39;s formal argument list,</span>
<a name="l19850"></a>19850 <span class="comment">     but versions of GCC around March 2002 include spaces after the</span>
<a name="l19851"></a>19851 <span class="comment">     commas.  */</span>
<a name="l19852"></a>19852 
<a name="l19853"></a>19853 
<a name="l19854"></a>19854   <span class="comment">/* Find the extent of the macro name.  The macro name is terminated</span>
<a name="l19855"></a>19855 <span class="comment">     by either a space or null character (for an object-like macro) or</span>
<a name="l19856"></a>19856 <span class="comment">     an opening paren (for a function-like macro).  */</span>
<a name="l19857"></a>19857   <span class="keywordflow">for</span> (p = body; *p; p++)
<a name="l19858"></a>19858     <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39; &#39;</span> || *p == <span class="charliteral">&#39;(&#39;</span>)
<a name="l19859"></a>19859       <span class="keywordflow">break</span>;
<a name="l19860"></a>19860 
<a name="l19861"></a>19861   <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39; &#39;</span> || *p == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l19862"></a>19862     {
<a name="l19863"></a>19863       <span class="comment">/* It&#39;s an object-like macro.  */</span>
<a name="l19864"></a>19864       <span class="keywordtype">int</span> name_len = p - body;
<a name="l19865"></a>19865       <span class="keywordtype">char</span> *name = <a class="code" href="dwarf2read_8c.html#a91a009933c23c89cf44557da96de7baf">copy_string</a> (body, name_len);
<a name="l19866"></a>19866       <span class="keyword">const</span> <span class="keywordtype">char</span> *replacement;
<a name="l19867"></a>19867 
<a name="l19868"></a>19868       <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39; &#39;</span>)
<a name="l19869"></a>19869         replacement = body + name_len + 1;
<a name="l19870"></a>19870       <span class="keywordflow">else</span>
<a name="l19871"></a>19871         {
<a name="l19872"></a>19872           <a class="code" href="dwarf2read_8c.html#a980629aef069b17bca95d8e60eb5f07d">dwarf2_macro_malformed_definition_complaint</a> (body);
<a name="l19873"></a>19873           replacement = body + name_len;
<a name="l19874"></a>19874         }
<a name="l19875"></a>19875 
<a name="l19876"></a>19876       <a class="code" href="macrotab_8c.html#a140759ea58c0e96083c438fc944f9d64">macro_define_object</a> (file, line, name, replacement);
<a name="l19877"></a>19877 
<a name="l19878"></a>19878       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (name);
<a name="l19879"></a>19879     }
<a name="l19880"></a>19880   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39;(&#39;</span>)
<a name="l19881"></a>19881     {
<a name="l19882"></a>19882       <span class="comment">/* It&#39;s a function-like macro.  */</span>
<a name="l19883"></a>19883       <span class="keywordtype">char</span> *name = <a class="code" href="dwarf2read_8c.html#a91a009933c23c89cf44557da96de7baf">copy_string</a> (body, p - body);
<a name="l19884"></a>19884       <span class="keywordtype">int</span> argc = 0;
<a name="l19885"></a>19885       <span class="keywordtype">int</span> argv_size = 1;
<a name="l19886"></a>19886       <span class="keywordtype">char</span> **argv = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (argv_size * <span class="keyword">sizeof</span> (*argv));
<a name="l19887"></a>19887 
<a name="l19888"></a>19888       p++;
<a name="l19889"></a>19889 
<a name="l19890"></a>19890       p = <a class="code" href="dwarf2read_8c.html#ad392783f8d498b2f1c40b1511930f2cd">consume_improper_spaces</a> (p, body);
<a name="l19891"></a>19891 
<a name="l19892"></a>19892       <span class="comment">/* Parse the formal argument list.  */</span>
<a name="l19893"></a>19893       <span class="keywordflow">while</span> (*p &amp;&amp; *p != <span class="charliteral">&#39;)&#39;</span>)
<a name="l19894"></a>19894         {
<a name="l19895"></a>19895           <span class="comment">/* Find the extent of the current argument name.  */</span>
<a name="l19896"></a>19896           <span class="keyword">const</span> <span class="keywordtype">char</span> *arg_start = p;
<a name="l19897"></a>19897 
<a name="l19898"></a>19898           <span class="keywordflow">while</span> (*p &amp;&amp; *p != <span class="charliteral">&#39;,&#39;</span> &amp;&amp; *p != <span class="charliteral">&#39;)&#39;</span> &amp;&amp; *p != <span class="charliteral">&#39; &#39;</span>)
<a name="l19899"></a>19899             p++;
<a name="l19900"></a>19900 
<a name="l19901"></a>19901           <span class="keywordflow">if</span> (! *p || p == arg_start)
<a name="l19902"></a>19902             <a class="code" href="dwarf2read_8c.html#a980629aef069b17bca95d8e60eb5f07d">dwarf2_macro_malformed_definition_complaint</a> (body);
<a name="l19903"></a>19903           <span class="keywordflow">else</span>
<a name="l19904"></a>19904             {
<a name="l19905"></a>19905               <span class="comment">/* Make sure argv has room for the new argument.  */</span>
<a name="l19906"></a>19906               <span class="keywordflow">if</span> (argc &gt;= argv_size)
<a name="l19907"></a>19907                 {
<a name="l19908"></a>19908                   argv_size *= 2;
<a name="l19909"></a>19909                   argv = <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (argv, argv_size * <span class="keyword">sizeof</span> (*argv));
<a name="l19910"></a>19910                 }
<a name="l19911"></a>19911 
<a name="l19912"></a>19912               argv[argc++] = <a class="code" href="dwarf2read_8c.html#a91a009933c23c89cf44557da96de7baf">copy_string</a> (arg_start, p - arg_start);
<a name="l19913"></a>19913             }
<a name="l19914"></a>19914 
<a name="l19915"></a>19915           p = <a class="code" href="dwarf2read_8c.html#ad392783f8d498b2f1c40b1511930f2cd">consume_improper_spaces</a> (p, body);
<a name="l19916"></a>19916 
<a name="l19917"></a>19917           <span class="comment">/* Consume the comma, if present.  */</span>
<a name="l19918"></a>19918           <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39;,&#39;</span>)
<a name="l19919"></a>19919             {
<a name="l19920"></a>19920               p++;
<a name="l19921"></a>19921 
<a name="l19922"></a>19922               p = <a class="code" href="dwarf2read_8c.html#ad392783f8d498b2f1c40b1511930f2cd">consume_improper_spaces</a> (p, body);
<a name="l19923"></a>19923             }
<a name="l19924"></a>19924         }
<a name="l19925"></a>19925 
<a name="l19926"></a>19926       <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39;)&#39;</span>)
<a name="l19927"></a>19927         {
<a name="l19928"></a>19928           p++;
<a name="l19929"></a>19929 
<a name="l19930"></a>19930           <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39; &#39;</span>)
<a name="l19931"></a>19931             <span class="comment">/* Perfectly formed definition, no complaints.  */</span>
<a name="l19932"></a>19932             <a class="code" href="macrotab_8c.html#a89403848d3a0ef72f4e78421cc9c2d40">macro_define_function</a> (file, line, name,
<a name="l19933"></a>19933                                    argc, (<span class="keyword">const</span> <span class="keywordtype">char</span> **) argv,
<a name="l19934"></a>19934                                    p + 1);
<a name="l19935"></a>19935           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l19936"></a>19936             {
<a name="l19937"></a>19937               <span class="comment">/* Complain, but do define it.  */</span>
<a name="l19938"></a>19938               <a class="code" href="dwarf2read_8c.html#a980629aef069b17bca95d8e60eb5f07d">dwarf2_macro_malformed_definition_complaint</a> (body);
<a name="l19939"></a>19939               <a class="code" href="macrotab_8c.html#a89403848d3a0ef72f4e78421cc9c2d40">macro_define_function</a> (file, line, name,
<a name="l19940"></a>19940                                      argc, (<span class="keyword">const</span> <span class="keywordtype">char</span> **) argv,
<a name="l19941"></a>19941                                      p);
<a name="l19942"></a>19942             }
<a name="l19943"></a>19943           <span class="keywordflow">else</span>
<a name="l19944"></a>19944             <span class="comment">/* Just complain.  */</span>
<a name="l19945"></a>19945             <a class="code" href="dwarf2read_8c.html#a980629aef069b17bca95d8e60eb5f07d">dwarf2_macro_malformed_definition_complaint</a> (body);
<a name="l19946"></a>19946         }
<a name="l19947"></a>19947       <span class="keywordflow">else</span>
<a name="l19948"></a>19948         <span class="comment">/* Just complain.  */</span>
<a name="l19949"></a>19949         <a class="code" href="dwarf2read_8c.html#a980629aef069b17bca95d8e60eb5f07d">dwarf2_macro_malformed_definition_complaint</a> (body);
<a name="l19950"></a>19950 
<a name="l19951"></a>19951       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (name);
<a name="l19952"></a>19952       {
<a name="l19953"></a>19953         <span class="keywordtype">int</span> i;
<a name="l19954"></a>19954 
<a name="l19955"></a>19955         <span class="keywordflow">for</span> (i = 0; i &lt; argc; i++)
<a name="l19956"></a>19956           <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (argv[i]);
<a name="l19957"></a>19957       }
<a name="l19958"></a>19958       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (argv);
<a name="l19959"></a>19959     }
<a name="l19960"></a>19960   <span class="keywordflow">else</span>
<a name="l19961"></a>19961     <a class="code" href="dwarf2read_8c.html#a980629aef069b17bca95d8e60eb5f07d">dwarf2_macro_malformed_definition_complaint</a> (body);
<a name="l19962"></a>19962 }
<a name="l19963"></a>19963 
<a name="l19964"></a>19964 <span class="comment">/* Skip some bytes from BYTES according to the form given in FORM.</span>
<a name="l19965"></a>19965 <span class="comment">   Returns the new pointer.  */</span>
<a name="l19966"></a>19966 
<a name="l19967"></a>19967 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l19968"></a><a class="code" href="dwarf2read_8c.html#a922ae5476fbc662a657ed0f314f9d8d2">19968</a> <a class="code" href="dwarf2read_8c.html#a922ae5476fbc662a657ed0f314f9d8d2">skip_form_bytes</a> (bfd *abfd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *bytes, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buffer_end,
<a name="l19969"></a>19969                  <span class="keyword">enum</span> dwarf_form form,
<a name="l19970"></a>19970                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset_size,
<a name="l19971"></a>19971                  <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section)
<a name="l19972"></a>19972 {
<a name="l19973"></a>19973   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l19974"></a>19974 
<a name="l19975"></a>19975   <span class="keywordflow">switch</span> (form)
<a name="l19976"></a>19976     {
<a name="l19977"></a>19977     <span class="keywordflow">case</span> DW_FORM_data1:
<a name="l19978"></a>19978     <span class="keywordflow">case</span> DW_FORM_flag:
<a name="l19979"></a>19979       ++bytes;
<a name="l19980"></a>19980       <span class="keywordflow">break</span>;
<a name="l19981"></a>19981 
<a name="l19982"></a>19982     <span class="keywordflow">case</span> DW_FORM_data2:
<a name="l19983"></a>19983       bytes += 2;
<a name="l19984"></a>19984       <span class="keywordflow">break</span>;
<a name="l19985"></a>19985 
<a name="l19986"></a>19986     <span class="keywordflow">case</span> DW_FORM_data4:
<a name="l19987"></a>19987       bytes += 4;
<a name="l19988"></a>19988       <span class="keywordflow">break</span>;
<a name="l19989"></a>19989 
<a name="l19990"></a>19990     <span class="keywordflow">case</span> DW_FORM_data8:
<a name="l19991"></a>19991       bytes += 8;
<a name="l19992"></a>19992       <span class="keywordflow">break</span>;
<a name="l19993"></a>19993 
<a name="l19994"></a>19994     <span class="keywordflow">case</span> DW_FORM_string:
<a name="l19995"></a>19995       <a class="code" href="dwarf2read_8c.html#a5386044c6f74a934dbd3f4a3199cf5be">read_direct_string</a> (abfd, bytes, &amp;bytes_read);
<a name="l19996"></a>19996       bytes += bytes_read;
<a name="l19997"></a>19997       <span class="keywordflow">break</span>;
<a name="l19998"></a>19998 
<a name="l19999"></a>19999     <span class="keywordflow">case</span> DW_FORM_sec_offset:
<a name="l20000"></a>20000     <span class="keywordflow">case</span> DW_FORM_strp:
<a name="l20001"></a>20001     <span class="keywordflow">case</span> DW_FORM_GNU_strp_alt:
<a name="l20002"></a>20002       bytes += offset_size;
<a name="l20003"></a>20003       <span class="keywordflow">break</span>;
<a name="l20004"></a>20004 
<a name="l20005"></a>20005     <span class="keywordflow">case</span> DW_FORM_block:
<a name="l20006"></a>20006       bytes += <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, bytes, &amp;bytes_read);
<a name="l20007"></a>20007       bytes += bytes_read;
<a name="l20008"></a>20008       <span class="keywordflow">break</span>;
<a name="l20009"></a>20009 
<a name="l20010"></a>20010     <span class="keywordflow">case</span> DW_FORM_block1:
<a name="l20011"></a>20011       bytes += 1 + <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, bytes);
<a name="l20012"></a>20012       <span class="keywordflow">break</span>;
<a name="l20013"></a>20013     <span class="keywordflow">case</span> DW_FORM_block2:
<a name="l20014"></a>20014       bytes += 2 + <a class="code" href="dwarf2read_8c.html#a35663eebf65b4217082f14bc1f782307">read_2_bytes</a> (abfd, bytes);
<a name="l20015"></a>20015       <span class="keywordflow">break</span>;
<a name="l20016"></a>20016     <span class="keywordflow">case</span> DW_FORM_block4:
<a name="l20017"></a>20017       bytes += 4 + <a class="code" href="dwarf2read_8c.html#ae129fd3fd0459f2ee992858b7647024e">read_4_bytes</a> (abfd, bytes);
<a name="l20018"></a>20018       <span class="keywordflow">break</span>;
<a name="l20019"></a>20019 
<a name="l20020"></a>20020     <span class="keywordflow">case</span> DW_FORM_sdata:
<a name="l20021"></a>20021     <span class="keywordflow">case</span> DW_FORM_udata:
<a name="l20022"></a>20022     <span class="keywordflow">case</span> DW_FORM_GNU_addr_index:
<a name="l20023"></a>20023     <span class="keywordflow">case</span> DW_FORM_GNU_str_index:
<a name="l20024"></a>20024       bytes = <a class="code" href="dwarf2expr_8h.html#a16b6da233685da29e27f3b50fd1c957f">gdb_skip_leb128</a> (bytes, buffer_end);
<a name="l20025"></a>20025       <span class="keywordflow">if</span> (bytes == NULL)
<a name="l20026"></a>20026         {
<a name="l20027"></a>20027           <a class="code" href="dwarf2read_8c.html#a8bcba8ec04ffa82ae060fb69f166920b">dwarf2_section_buffer_overflow_complaint</a> (section);
<a name="l20028"></a>20028           <span class="keywordflow">return</span> NULL;
<a name="l20029"></a>20029         }
<a name="l20030"></a>20030       <span class="keywordflow">break</span>;
<a name="l20031"></a>20031 
<a name="l20032"></a>20032     <span class="keywordflow">default</span>:
<a name="l20033"></a>20033       {
<a name="l20034"></a>20034       <a class="code" href="structcomplain.html">complain</a>:
<a name="l20035"></a>20035         <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l20036"></a>20036                    <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;invalid form 0x%x in `%s&#39;&quot;</span>),
<a name="l20037"></a>20037                    form, <a class="code" href="dwarf2read_8c.html#a206c558e28b7bc7fcf8bdad145cabef1">get_section_name</a> (section));
<a name="l20038"></a>20038         <span class="keywordflow">return</span> NULL;
<a name="l20039"></a>20039       }
<a name="l20040"></a>20040     }
<a name="l20041"></a>20041 
<a name="l20042"></a>20042   <span class="keywordflow">return</span> bytes;
<a name="l20043"></a>20043 }
<a name="l20044"></a>20044 
<a name="l20045"></a>20045 <span class="comment">/* A helper for dwarf_decode_macros that handles skipping an unknown</span>
<a name="l20046"></a>20046 <span class="comment">   opcode.  Returns an updated pointer to the macro data buffer; or,</span>
<a name="l20047"></a>20047 <span class="comment">   on error, issues a complaint and returns NULL.  */</span>
<a name="l20048"></a>20048 
<a name="l20049"></a>20049 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l20050"></a><a class="code" href="dwarf2read_8c.html#aa928dc181932c163a4f2b65102bf9a59">20050</a> <a class="code" href="dwarf2read_8c.html#aa928dc181932c163a4f2b65102bf9a59">skip_unknown_opcode</a> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> opcode,
<a name="l20051"></a>20051                      <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **opcode_definitions,
<a name="l20052"></a>20052                      <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *mac_ptr, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *mac_end,
<a name="l20053"></a>20053                      bfd *abfd,
<a name="l20054"></a>20054                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset_size,
<a name="l20055"></a>20055                      <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section)
<a name="l20056"></a>20056 {
<a name="l20057"></a>20057   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read, i;
<a name="l20058"></a>20058   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg;
<a name="l20059"></a>20059   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *defn;
<a name="l20060"></a>20060 
<a name="l20061"></a>20061   <span class="keywordflow">if</span> (opcode_definitions[opcode] == NULL)
<a name="l20062"></a>20062     {
<a name="l20063"></a>20063       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l20064"></a>20064                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unrecognized DW_MACFINO opcode 0x%x&quot;</span>),
<a name="l20065"></a>20065                  opcode);
<a name="l20066"></a>20066       <span class="keywordflow">return</span> NULL;
<a name="l20067"></a>20067     }
<a name="l20068"></a>20068 
<a name="l20069"></a>20069   defn = opcode_definitions[opcode];
<a name="l20070"></a>20070   arg = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, defn, &amp;bytes_read);
<a name="l20071"></a>20071   defn += bytes_read;
<a name="l20072"></a>20072 
<a name="l20073"></a>20073   <span class="keywordflow">for</span> (i = 0; i &lt; arg; ++i)
<a name="l20074"></a>20074     {
<a name="l20075"></a>20075       mac_ptr = <a class="code" href="dwarf2read_8c.html#a922ae5476fbc662a657ed0f314f9d8d2">skip_form_bytes</a> (abfd, mac_ptr, mac_end, defn[i], offset_size,
<a name="l20076"></a>20076                                  section);
<a name="l20077"></a>20077       <span class="keywordflow">if</span> (mac_ptr == NULL)
<a name="l20078"></a>20078         {
<a name="l20079"></a>20079           <span class="comment">/* skip_form_bytes already issued the complaint.  */</span>
<a name="l20080"></a>20080           <span class="keywordflow">return</span> NULL;
<a name="l20081"></a>20081         }
<a name="l20082"></a>20082     }
<a name="l20083"></a>20083 
<a name="l20084"></a>20084   <span class="keywordflow">return</span> mac_ptr;
<a name="l20085"></a>20085 }
<a name="l20086"></a>20086 
<a name="l20087"></a>20087 <span class="comment">/* A helper function which parses the header of a macro section.</span>
<a name="l20088"></a>20088 <span class="comment">   If the macro section is the extended (for now called &quot;GNU&quot;) type,</span>
<a name="l20089"></a>20089 <span class="comment">   then this updates *OFFSET_SIZE.  Returns a pointer to just after</span>
<a name="l20090"></a>20090 <span class="comment">   the header, or issues a complaint and returns NULL on error.  */</span>
<a name="l20091"></a>20091 
<a name="l20092"></a>20092 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l20093"></a><a class="code" href="dwarf2read_8c.html#a7cbf6e28afbf0d07a71dd93a9d2d5b10">20093</a> <a class="code" href="dwarf2read_8c.html#a7cbf6e28afbf0d07a71dd93a9d2d5b10">dwarf_parse_macro_header</a> (<span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **opcode_definitions,
<a name="l20094"></a>20094                           bfd *abfd,
<a name="l20095"></a>20095                           <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *mac_ptr,
<a name="l20096"></a>20096                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *offset_size,
<a name="l20097"></a>20097                           <span class="keywordtype">int</span> section_is_gnu)
<a name="l20098"></a>20098 {
<a name="l20099"></a>20099   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (opcode_definitions, 0, 256 * <span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *));
<a name="l20100"></a>20100 
<a name="l20101"></a>20101   <span class="keywordflow">if</span> (section_is_gnu)
<a name="l20102"></a>20102     {
<a name="l20103"></a>20103       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="version_8h.html#ac91cf940e10a61b95cabc3258a06186b">version</a>, <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>;
<a name="l20104"></a>20104 
<a name="l20105"></a>20105       version = <a class="code" href="dwarf2read_8c.html#a35663eebf65b4217082f14bc1f782307">read_2_bytes</a> (abfd, mac_ptr);
<a name="l20106"></a>20106       <span class="keywordflow">if</span> (version != 4)
<a name="l20107"></a>20107         {
<a name="l20108"></a>20108           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l20109"></a>20109                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unrecognized version `%d&#39; in .debug_macro section&quot;</span>),
<a name="l20110"></a>20110                      version);
<a name="l20111"></a>20111           <span class="keywordflow">return</span> NULL;
<a name="l20112"></a>20112         }
<a name="l20113"></a>20113       mac_ptr += 2;
<a name="l20114"></a>20114 
<a name="l20115"></a>20115       flags = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, mac_ptr);
<a name="l20116"></a>20116       ++mac_ptr;
<a name="l20117"></a>20117       *offset_size = (flags &amp; 1) ? 8 : 4;
<a name="l20118"></a>20118 
<a name="l20119"></a>20119       <span class="keywordflow">if</span> ((flags &amp; 2) != 0)
<a name="l20120"></a>20120         <span class="comment">/* We don&#39;t need the line table offset.  */</span>
<a name="l20121"></a>20121         mac_ptr += *offset_size;
<a name="l20122"></a>20122 
<a name="l20123"></a>20123       <span class="comment">/* Vendor opcode descriptions.  */</span>
<a name="l20124"></a>20124       <span class="keywordflow">if</span> ((flags &amp; 4) != 0)
<a name="l20125"></a>20125         {
<a name="l20126"></a>20126           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, count;
<a name="l20127"></a>20127 
<a name="l20128"></a>20128           count = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, mac_ptr);
<a name="l20129"></a>20129           ++mac_ptr;
<a name="l20130"></a>20130           <span class="keywordflow">for</span> (i = 0; i &lt; count; ++i)
<a name="l20131"></a>20131             {
<a name="l20132"></a>20132               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> opcode, bytes_read;
<a name="l20133"></a>20133               <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg;
<a name="l20134"></a>20134 
<a name="l20135"></a>20135               opcode = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, mac_ptr);
<a name="l20136"></a>20136               ++mac_ptr;
<a name="l20137"></a>20137               opcode_definitions[opcode] = mac_ptr;
<a name="l20138"></a>20138               arg = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, mac_ptr, &amp;bytes_read);
<a name="l20139"></a>20139               mac_ptr += bytes_read;
<a name="l20140"></a>20140               mac_ptr += arg;
<a name="l20141"></a>20141             }
<a name="l20142"></a>20142         }
<a name="l20143"></a>20143     }
<a name="l20144"></a>20144 
<a name="l20145"></a>20145   <span class="keywordflow">return</span> mac_ptr;
<a name="l20146"></a>20146 }
<a name="l20147"></a>20147 
<a name="l20148"></a>20148 <span class="comment">/* A helper for dwarf_decode_macros that handles the GNU extensions,</span>
<a name="l20149"></a>20149 <span class="comment">   including DW_MACRO_GNU_transparent_include.  */</span>
<a name="l20150"></a>20150 
<a name="l20151"></a>20151 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l20152"></a><a class="code" href="dwarf2read_8c.html#af51738e736b1f2c73c6529a658849bb3">20152</a> <a class="code" href="dwarf2read_8c.html#af51738e736b1f2c73c6529a658849bb3">dwarf_decode_macro_bytes</a> (bfd *abfd,
<a name="l20153"></a>20153                           <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *mac_ptr, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *mac_end,
<a name="l20154"></a>20154                           <span class="keyword">struct</span> <a class="code" href="structmacro__source__file.html">macro_source_file</a> *current_file,
<a name="l20155"></a>20155                           <span class="keyword">struct</span> <a class="code" href="structline__header.html">line_header</a> *lh, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structmacro__table.html#af521bc38c7526c787bd086c093d8a17c">comp_dir</a>,
<a name="l20156"></a>20156                           <span class="keyword">struct</span> <a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section,
<a name="l20157"></a>20157                           <span class="keywordtype">int</span> section_is_gnu, <span class="keywordtype">int</span> section_is_dwz,
<a name="l20158"></a>20158                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset_size,
<a name="l20159"></a>20159                           <span class="keyword">struct</span> objfile *objfile,
<a name="l20160"></a>20160                           htab_t include_hash)
<a name="l20161"></a>20161 {
<a name="l20162"></a>20162   <span class="keyword">enum</span> dwarf_macro_record_type macinfo_type;
<a name="l20163"></a>20163   <span class="keywordtype">int</span> at_commandline;
<a name="l20164"></a>20164   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *opcode_definitions[256];
<a name="l20165"></a>20165 
<a name="l20166"></a>20166   mac_ptr = <a class="code" href="dwarf2read_8c.html#a7cbf6e28afbf0d07a71dd93a9d2d5b10">dwarf_parse_macro_header</a> (opcode_definitions, abfd, mac_ptr,
<a name="l20167"></a>20167                                       &amp;offset_size, section_is_gnu);
<a name="l20168"></a>20168   <span class="keywordflow">if</span> (mac_ptr == NULL)
<a name="l20169"></a>20169     {
<a name="l20170"></a>20170       <span class="comment">/* We already issued a complaint.  */</span>
<a name="l20171"></a>20171       <span class="keywordflow">return</span>;
<a name="l20172"></a>20172     }
<a name="l20173"></a>20173 
<a name="l20174"></a>20174   <span class="comment">/* Determines if GDB is still before first DW_MACINFO_start_file.  If true</span>
<a name="l20175"></a>20175 <span class="comment">     GDB is still reading the definitions from command line.  First</span>
<a name="l20176"></a>20176 <span class="comment">     DW_MACINFO_start_file will need to be ignored as it was already executed</span>
<a name="l20177"></a>20177 <span class="comment">     to create CURRENT_FILE for the main source holding also the command line</span>
<a name="l20178"></a>20178 <span class="comment">     definitions.  On first met DW_MACINFO_start_file this flag is reset to</span>
<a name="l20179"></a>20179 <span class="comment">     normally execute all the remaining DW_MACINFO_start_file macinfos.  */</span>
<a name="l20180"></a>20180 
<a name="l20181"></a>20181   at_commandline = 1;
<a name="l20182"></a>20182 
<a name="l20183"></a>20183   <span class="keywordflow">do</span>
<a name="l20184"></a>20184     {
<a name="l20185"></a>20185       <span class="comment">/* Do we at least have room for a macinfo type byte?  */</span>
<a name="l20186"></a>20186       <span class="keywordflow">if</span> (mac_ptr &gt;= mac_end)
<a name="l20187"></a>20187         {
<a name="l20188"></a>20188           <a class="code" href="dwarf2read_8c.html#a8bcba8ec04ffa82ae060fb69f166920b">dwarf2_section_buffer_overflow_complaint</a> (section);
<a name="l20189"></a>20189           <span class="keywordflow">break</span>;
<a name="l20190"></a>20190         }
<a name="l20191"></a>20191 
<a name="l20192"></a>20192       macinfo_type = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, mac_ptr);
<a name="l20193"></a>20193       mac_ptr++;
<a name="l20194"></a>20194 
<a name="l20195"></a>20195       <span class="comment">/* Note that we rely on the fact that the corresponding GNU and</span>
<a name="l20196"></a>20196 <span class="comment">         DWARF constants are the same.  */</span>
<a name="l20197"></a>20197       <span class="keywordflow">switch</span> (macinfo_type)
<a name="l20198"></a>20198         {
<a name="l20199"></a>20199           <span class="comment">/* A zero macinfo type indicates the end of the macro</span>
<a name="l20200"></a>20200 <span class="comment">             information.  */</span>
<a name="l20201"></a>20201         <span class="keywordflow">case</span> 0:
<a name="l20202"></a>20202           <span class="keywordflow">break</span>;
<a name="l20203"></a>20203 
<a name="l20204"></a>20204         <span class="keywordflow">case</span> DW_MACRO_GNU_define:
<a name="l20205"></a>20205         <span class="keywordflow">case</span> DW_MACRO_GNU_undef:
<a name="l20206"></a>20206         <span class="keywordflow">case</span> DW_MACRO_GNU_define_indirect:
<a name="l20207"></a>20207         <span class="keywordflow">case</span> DW_MACRO_GNU_undef_indirect:
<a name="l20208"></a>20208         <span class="keywordflow">case</span> DW_MACRO_GNU_define_indirect_alt:
<a name="l20209"></a>20209         <span class="keywordflow">case</span> DW_MACRO_GNU_undef_indirect_alt:
<a name="l20210"></a>20210           {
<a name="l20211"></a>20211             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l20212"></a>20212             <span class="keywordtype">int</span> <a class="code" href="symtab_8h.html#a41ebd28ef1d7c6ade45642cb6acc1039">line</a>;
<a name="l20213"></a>20213             <span class="keyword">const</span> <span class="keywordtype">char</span> *body;
<a name="l20214"></a>20214             <span class="keywordtype">int</span> is_define;
<a name="l20215"></a>20215 
<a name="l20216"></a>20216             line = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, mac_ptr, &amp;bytes_read);
<a name="l20217"></a>20217             mac_ptr += bytes_read;
<a name="l20218"></a>20218 
<a name="l20219"></a>20219             <span class="keywordflow">if</span> (macinfo_type == DW_MACRO_GNU_define
<a name="l20220"></a>20220                 || macinfo_type == DW_MACRO_GNU_undef)
<a name="l20221"></a>20221               {
<a name="l20222"></a>20222                 body = <a class="code" href="dwarf2read_8c.html#a5386044c6f74a934dbd3f4a3199cf5be">read_direct_string</a> (abfd, mac_ptr, &amp;bytes_read);
<a name="l20223"></a>20223                 mac_ptr += bytes_read;
<a name="l20224"></a>20224               }
<a name="l20225"></a>20225             <span class="keywordflow">else</span>
<a name="l20226"></a>20226               {
<a name="l20227"></a>20227                 <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> str_offset;
<a name="l20228"></a>20228 
<a name="l20229"></a>20229                 str_offset = <a class="code" href="dwarf2read_8c.html#a7d7df1bb27bd8e2cdd3b27bafd16640b">read_offset_1</a> (abfd, mac_ptr, offset_size);
<a name="l20230"></a>20230                 mac_ptr += offset_size;
<a name="l20231"></a>20231 
<a name="l20232"></a>20232                 <span class="keywordflow">if</span> (macinfo_type == DW_MACRO_GNU_define_indirect_alt
<a name="l20233"></a>20233                     || macinfo_type == DW_MACRO_GNU_undef_indirect_alt
<a name="l20234"></a>20234                     || section_is_dwz)
<a name="l20235"></a>20235                   {
<a name="l20236"></a>20236                     <span class="keyword">struct </span><a class="code" href="structdwz__file.html">dwz_file</a> *dwz = <a class="code" href="dwarf2read_8c.html#a926306809098933a820cfda81b19864c">dwarf2_get_dwz_file</a> ();
<a name="l20237"></a>20237 
<a name="l20238"></a>20238                     body = <a class="code" href="dwarf2read_8c.html#aae8af1e5be4adc81e8945968faf67e31">read_indirect_string_from_dwz</a> (dwz, str_offset);
<a name="l20239"></a>20239                   }
<a name="l20240"></a>20240                 <span class="keywordflow">else</span>
<a name="l20241"></a>20241                   body = <a class="code" href="dwarf2read_8c.html#a872bd8fea8791345413810a1049fa68f">read_indirect_string_at_offset</a> (abfd, str_offset);
<a name="l20242"></a>20242               }
<a name="l20243"></a>20243 
<a name="l20244"></a>20244             is_define = (macinfo_type == DW_MACRO_GNU_define
<a name="l20245"></a>20245                          || macinfo_type == DW_MACRO_GNU_define_indirect
<a name="l20246"></a>20246                          || macinfo_type == DW_MACRO_GNU_define_indirect_alt);
<a name="l20247"></a>20247             <span class="keywordflow">if</span> (! current_file)
<a name="l20248"></a>20248               {
<a name="l20249"></a>20249                 <span class="comment">/* DWARF violation as no main source is present.  */</span>
<a name="l20250"></a>20250                 <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l20251"></a>20251                            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;debug info with no main source gives macro %s &quot;</span>
<a name="l20252"></a>20252                              <span class="stringliteral">&quot;on line %d: %s&quot;</span>),
<a name="l20253"></a>20253                            is_define ? <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;definition&quot;</span>) : <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;undefinition&quot;</span>),
<a name="l20254"></a>20254                            line, body);
<a name="l20255"></a>20255                 <span class="keywordflow">break</span>;
<a name="l20256"></a>20256               }
<a name="l20257"></a>20257             <span class="keywordflow">if</span> ((line == 0 &amp;&amp; !at_commandline)
<a name="l20258"></a>20258                 || (line != 0 &amp;&amp; at_commandline))
<a name="l20259"></a>20259               <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l20260"></a>20260                          <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;debug info gives %s macro %s with %s line %d: %s&quot;</span>),
<a name="l20261"></a>20261                          at_commandline ? <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;command-line&quot;</span>) : <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;in-file&quot;</span>),
<a name="l20262"></a>20262                          is_define ? <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;definition&quot;</span>) : <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;undefinition&quot;</span>),
<a name="l20263"></a>20263                          line == 0 ? <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;zero&quot;</span>) : <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;non-zero&quot;</span>), line, body);
<a name="l20264"></a>20264 
<a name="l20265"></a>20265             <span class="keywordflow">if</span> (is_define)
<a name="l20266"></a>20266               <a class="code" href="dwarf2read_8c.html#acc850c164674587d8e5c139dd37fcbae">parse_macro_definition</a> (current_file, line, body);
<a name="l20267"></a>20267             <span class="keywordflow">else</span>
<a name="l20268"></a>20268               {
<a name="l20269"></a>20269                 <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (macinfo_type == DW_MACRO_GNU_undef
<a name="l20270"></a>20270                             || macinfo_type == DW_MACRO_GNU_undef_indirect
<a name="l20271"></a>20271                             || macinfo_type == DW_MACRO_GNU_undef_indirect_alt);
<a name="l20272"></a>20272                 <a class="code" href="macrotab_8c.html#afbf71f4f9e838e45fbe3a8bd72c337bb">macro_undef</a> (current_file, line, body);
<a name="l20273"></a>20273               }
<a name="l20274"></a>20274           }
<a name="l20275"></a>20275           <span class="keywordflow">break</span>;
<a name="l20276"></a>20276 
<a name="l20277"></a>20277         <span class="keywordflow">case</span> DW_MACRO_GNU_start_file:
<a name="l20278"></a>20278           {
<a name="l20279"></a>20279             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l20280"></a>20280             <span class="keywordtype">int</span> <a class="code" href="symtab_8h.html#a41ebd28ef1d7c6ade45642cb6acc1039">line</a>, file;
<a name="l20281"></a>20281 
<a name="l20282"></a>20282             line = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, mac_ptr, &amp;bytes_read);
<a name="l20283"></a>20283             mac_ptr += bytes_read;
<a name="l20284"></a>20284             file = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, mac_ptr, &amp;bytes_read);
<a name="l20285"></a>20285             mac_ptr += bytes_read;
<a name="l20286"></a>20286 
<a name="l20287"></a>20287             <span class="keywordflow">if</span> ((line == 0 &amp;&amp; !at_commandline)
<a name="l20288"></a>20288                 || (line != 0 &amp;&amp; at_commandline))
<a name="l20289"></a>20289               <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l20290"></a>20290                          <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;debug info gives source %d included &quot;</span>
<a name="l20291"></a>20291                            <span class="stringliteral">&quot;from %s at %s line %d&quot;</span>),
<a name="l20292"></a>20292                          file, at_commandline ? <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;command-line&quot;</span>) : <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;file&quot;</span>),
<a name="l20293"></a>20293                          line == 0 ? <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;zero&quot;</span>) : <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;non-zero&quot;</span>), line);
<a name="l20294"></a>20294 
<a name="l20295"></a>20295             <span class="keywordflow">if</span> (at_commandline)
<a name="l20296"></a>20296               {
<a name="l20297"></a>20297                 <span class="comment">/* This DW_MACRO_GNU_start_file was executed in the</span>
<a name="l20298"></a>20298 <span class="comment">                   pass one.  */</span>
<a name="l20299"></a>20299                 at_commandline = 0;
<a name="l20300"></a>20300               }
<a name="l20301"></a>20301             <span class="keywordflow">else</span>
<a name="l20302"></a>20302               current_file = <a class="code" href="dwarf2read_8c.html#af8d39cfd2d056b6852bbfafb66f384c5">macro_start_file</a> (file, line,
<a name="l20303"></a>20303                                                current_file, comp_dir,
<a name="l20304"></a>20304                                                lh, objfile);
<a name="l20305"></a>20305           }
<a name="l20306"></a>20306           <span class="keywordflow">break</span>;
<a name="l20307"></a>20307 
<a name="l20308"></a>20308         <span class="keywordflow">case</span> DW_MACRO_GNU_end_file:
<a name="l20309"></a>20309           <span class="keywordflow">if</span> (! current_file)
<a name="l20310"></a>20310             <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l20311"></a>20311                        <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;macro debug info has an unmatched &quot;</span>
<a name="l20312"></a>20312                          <span class="stringliteral">&quot;`close_file&#39; directive&quot;</span>));
<a name="l20313"></a>20313           <span class="keywordflow">else</span>
<a name="l20314"></a>20314             {
<a name="l20315"></a>20315               current_file = current_file-&gt;<a class="code" href="structmacro__source__file.html#a485fe2711ebf98a3a9c240776ce71669">included_by</a>;
<a name="l20316"></a>20316               <span class="keywordflow">if</span> (! current_file)
<a name="l20317"></a>20317                 {
<a name="l20318"></a>20318                   <span class="keyword">enum</span> dwarf_macro_record_type next_type;
<a name="l20319"></a>20319 
<a name="l20320"></a>20320                   <span class="comment">/* GCC circa March 2002 doesn&#39;t produce the zero</span>
<a name="l20321"></a>20321 <span class="comment">                     type byte marking the end of the compilation</span>
<a name="l20322"></a>20322 <span class="comment">                     unit.  Complain if it&#39;s not there, but exit no</span>
<a name="l20323"></a>20323 <span class="comment">                     matter what.  */</span>
<a name="l20324"></a>20324 
<a name="l20325"></a>20325                   <span class="comment">/* Do we at least have room for a macinfo type byte?  */</span>
<a name="l20326"></a>20326                   <span class="keywordflow">if</span> (mac_ptr &gt;= mac_end)
<a name="l20327"></a>20327                     {
<a name="l20328"></a>20328                       <a class="code" href="dwarf2read_8c.html#a8bcba8ec04ffa82ae060fb69f166920b">dwarf2_section_buffer_overflow_complaint</a> (section);
<a name="l20329"></a>20329                       <span class="keywordflow">return</span>;
<a name="l20330"></a>20330                     }
<a name="l20331"></a>20331 
<a name="l20332"></a>20332                   <span class="comment">/* We don&#39;t increment mac_ptr here, so this is just</span>
<a name="l20333"></a>20333 <span class="comment">                     a look-ahead.  */</span>
<a name="l20334"></a>20334                   next_type = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, mac_ptr);
<a name="l20335"></a>20335                   <span class="keywordflow">if</span> (next_type != 0)
<a name="l20336"></a>20336                     <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l20337"></a>20337                                <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;no terminating 0-type entry for &quot;</span>
<a name="l20338"></a>20338                                  <span class="stringliteral">&quot;macros in `.debug_macinfo&#39; section&quot;</span>));
<a name="l20339"></a>20339 
<a name="l20340"></a>20340                   <span class="keywordflow">return</span>;
<a name="l20341"></a>20341                 }
<a name="l20342"></a>20342             }
<a name="l20343"></a>20343           <span class="keywordflow">break</span>;
<a name="l20344"></a>20344 
<a name="l20345"></a>20345         <span class="keywordflow">case</span> DW_MACRO_GNU_transparent_include:
<a name="l20346"></a>20346         <span class="keywordflow">case</span> DW_MACRO_GNU_transparent_include_alt:
<a name="l20347"></a>20347           {
<a name="l20348"></a>20348             <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l20349"></a>20349             <span class="keywordtype">void</span> **slot;
<a name="l20350"></a>20350             bfd *include_bfd = abfd;
<a name="l20351"></a>20351             <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *include_section = section;
<a name="l20352"></a>20352             <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> alt_section;
<a name="l20353"></a>20353             <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *include_mac_end = mac_end;
<a name="l20354"></a>20354             <span class="keywordtype">int</span> is_dwz = section_is_dwz;
<a name="l20355"></a>20355             <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *new_mac_ptr;
<a name="l20356"></a>20356 
<a name="l20357"></a>20357             offset = <a class="code" href="dwarf2read_8c.html#a7d7df1bb27bd8e2cdd3b27bafd16640b">read_offset_1</a> (abfd, mac_ptr, offset_size);
<a name="l20358"></a>20358             mac_ptr += offset_size;
<a name="l20359"></a>20359 
<a name="l20360"></a>20360             <span class="keywordflow">if</span> (macinfo_type == DW_MACRO_GNU_transparent_include_alt)
<a name="l20361"></a>20361               {
<a name="l20362"></a>20362                 <span class="keyword">struct </span><a class="code" href="structdwz__file.html">dwz_file</a> *dwz = <a class="code" href="dwarf2read_8c.html#a926306809098933a820cfda81b19864c">dwarf2_get_dwz_file</a> ();
<a name="l20363"></a>20363 
<a name="l20364"></a>20364                 <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (dwarf2_per_objfile-&gt;objfile,
<a name="l20365"></a>20365                                      &amp;dwz-&gt;<a class="code" href="structdwz__file.html#a76ea7d4cb4937ee64a3383736362e123">macro</a>);
<a name="l20366"></a>20366 
<a name="l20367"></a>20367                 include_section = &amp;dwz-&gt;<a class="code" href="structdwz__file.html#a76ea7d4cb4937ee64a3383736362e123">macro</a>;
<a name="l20368"></a>20368                 include_bfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (include_section);
<a name="l20369"></a>20369                 include_mac_end = dwz-&gt;<a class="code" href="structdwz__file.html#a76ea7d4cb4937ee64a3383736362e123">macro</a>.<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + dwz-&gt;<a class="code" href="structdwz__file.html#a76ea7d4cb4937ee64a3383736362e123">macro</a>.<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>;
<a name="l20370"></a>20370                 is_dwz = 1;
<a name="l20371"></a>20371               }
<a name="l20372"></a>20372 
<a name="l20373"></a>20373             new_mac_ptr = include_section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l20374"></a>20374             slot = htab_find_slot (include_hash, new_mac_ptr, INSERT);
<a name="l20375"></a>20375 
<a name="l20376"></a>20376             <span class="keywordflow">if</span> (*slot != NULL)
<a name="l20377"></a>20377               {
<a name="l20378"></a>20378                 <span class="comment">/* This has actually happened; see</span>
<a name="l20379"></a>20379 <span class="comment">                   http://sourceware.org/bugzilla/show_bug.cgi?id=13568.  */</span>
<a name="l20380"></a>20380                 <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l20381"></a>20381                            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;recursive DW_MACRO_GNU_transparent_include in &quot;</span>
<a name="l20382"></a>20382                              <span class="stringliteral">&quot;.debug_macro section&quot;</span>));
<a name="l20383"></a>20383               }
<a name="l20384"></a>20384             <span class="keywordflow">else</span>
<a name="l20385"></a>20385               {
<a name="l20386"></a>20386                 *slot = (<span class="keywordtype">void</span> *) new_mac_ptr;
<a name="l20387"></a>20387 
<a name="l20388"></a>20388                 <a class="code" href="dwarf2read_8c.html#af51738e736b1f2c73c6529a658849bb3">dwarf_decode_macro_bytes</a> (include_bfd, new_mac_ptr,
<a name="l20389"></a>20389                                           include_mac_end, current_file,
<a name="l20390"></a>20390                                           lh, comp_dir,
<a name="l20391"></a>20391                                           section, section_is_gnu, is_dwz,
<a name="l20392"></a>20392                                           offset_size, objfile, include_hash);
<a name="l20393"></a>20393 
<a name="l20394"></a>20394                 htab_remove_elt (include_hash, (<span class="keywordtype">void</span> *) new_mac_ptr);
<a name="l20395"></a>20395               }
<a name="l20396"></a>20396           }
<a name="l20397"></a>20397           <span class="keywordflow">break</span>;
<a name="l20398"></a>20398 
<a name="l20399"></a>20399         <span class="keywordflow">case</span> DW_MACINFO_vendor_ext:
<a name="l20400"></a>20400           <span class="keywordflow">if</span> (!section_is_gnu)
<a name="l20401"></a>20401             {
<a name="l20402"></a>20402               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l20403"></a>20403               <span class="keywordtype">int</span> constant;
<a name="l20404"></a>20404 
<a name="l20405"></a>20405               constant = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, mac_ptr, &amp;bytes_read);
<a name="l20406"></a>20406               mac_ptr += bytes_read;
<a name="l20407"></a>20407               <a class="code" href="dwarf2read_8c.html#a5386044c6f74a934dbd3f4a3199cf5be">read_direct_string</a> (abfd, mac_ptr, &amp;bytes_read);
<a name="l20408"></a>20408               mac_ptr += bytes_read;
<a name="l20409"></a>20409 
<a name="l20410"></a>20410               <span class="comment">/* We don&#39;t recognize any vendor extensions.  */</span>
<a name="l20411"></a>20411               <span class="keywordflow">break</span>;
<a name="l20412"></a>20412             }
<a name="l20413"></a>20413           <span class="comment">/* FALLTHROUGH */</span>
<a name="l20414"></a>20414 
<a name="l20415"></a>20415         <span class="keywordflow">default</span>:
<a name="l20416"></a>20416           mac_ptr = <a class="code" href="dwarf2read_8c.html#aa928dc181932c163a4f2b65102bf9a59">skip_unknown_opcode</a> (macinfo_type, opcode_definitions,
<a name="l20417"></a>20417                                          mac_ptr, mac_end, abfd, offset_size,
<a name="l20418"></a>20418                                          section);
<a name="l20419"></a>20419           <span class="keywordflow">if</span> (mac_ptr == NULL)
<a name="l20420"></a>20420             <span class="keywordflow">return</span>;
<a name="l20421"></a>20421           <span class="keywordflow">break</span>;
<a name="l20422"></a>20422         }
<a name="l20423"></a>20423     } <span class="keywordflow">while</span> (macinfo_type != 0);
<a name="l20424"></a>20424 }
<a name="l20425"></a>20425 
<a name="l20426"></a>20426 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l20427"></a><a class="code" href="dwarf2read_8c.html#ab19576b4a3ebec0b3a1e723523f2e072">20427</a> <a class="code" href="dwarf2read_8c.html#ab19576b4a3ebec0b3a1e723523f2e072">dwarf_decode_macros</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>,
<a name="l20428"></a>20428                      <span class="keyword">const</span> <span class="keywordtype">char</span> *comp_dir, <span class="keywordtype">int</span> section_is_gnu)
<a name="l20429"></a>20429 {
<a name="l20430"></a>20430   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l20431"></a>20431   <span class="keyword">struct </span><a class="code" href="structline__header.html">line_header</a> *lh = cu-&gt;<a class="code" href="structdwarf2__cu.html#a94864e6f22ffa7350c883da402931b99">line_header</a>;
<a name="l20432"></a>20432   bfd *abfd;
<a name="l20433"></a>20433   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *mac_ptr, *mac_end;
<a name="l20434"></a>20434   <span class="keyword">struct </span><a class="code" href="structmacro__source__file.html">macro_source_file</a> *current_file = 0;
<a name="l20435"></a>20435   <span class="keyword">enum</span> dwarf_macro_record_type macinfo_type;
<a name="l20436"></a>20436   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset_size = cu-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>.<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>;
<a name="l20437"></a>20437   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *opcode_definitions[256];
<a name="l20438"></a>20438   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l20439"></a>20439   htab_t include_hash;
<a name="l20440"></a>20440   <span class="keywordtype">void</span> **slot;
<a name="l20441"></a>20441   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section;
<a name="l20442"></a>20442   <span class="keyword">const</span> <span class="keywordtype">char</span> *section_name;
<a name="l20443"></a>20443 
<a name="l20444"></a>20444   <span class="keywordflow">if</span> (cu-&gt;dwo_unit != NULL)
<a name="l20445"></a>20445     {
<a name="l20446"></a>20446       <span class="keywordflow">if</span> (section_is_gnu)
<a name="l20447"></a>20447         {
<a name="l20448"></a>20448           section = &amp;cu-&gt;dwo_unit-&gt;dwo_file-&gt;sections.macro;
<a name="l20449"></a>20449           section_name = <span class="stringliteral">&quot;.debug_macro.dwo&quot;</span>;
<a name="l20450"></a>20450         }
<a name="l20451"></a>20451       <span class="keywordflow">else</span>
<a name="l20452"></a>20452         {
<a name="l20453"></a>20453           section = &amp;cu-&gt;dwo_unit-&gt;dwo_file-&gt;sections.macinfo;
<a name="l20454"></a>20454           section_name = <span class="stringliteral">&quot;.debug_macinfo.dwo&quot;</span>;
<a name="l20455"></a>20455         }
<a name="l20456"></a>20456     }
<a name="l20457"></a>20457   <span class="keywordflow">else</span>
<a name="l20458"></a>20458     {
<a name="l20459"></a>20459       <span class="keywordflow">if</span> (section_is_gnu)
<a name="l20460"></a>20460         {
<a name="l20461"></a>20461           section = &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#ab96c1115af7d65e9ca3912d1dc68803d">macro</a>;
<a name="l20462"></a>20462           section_name = <span class="stringliteral">&quot;.debug_macro&quot;</span>;
<a name="l20463"></a>20463         }
<a name="l20464"></a>20464       <span class="keywordflow">else</span>
<a name="l20465"></a>20465         {
<a name="l20466"></a>20466           section = &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a171eb0e6180390364c7907b187c923fc">macinfo</a>;
<a name="l20467"></a>20467           section_name = <span class="stringliteral">&quot;.debug_macinfo&quot;</span>;
<a name="l20468"></a>20468         }
<a name="l20469"></a>20469     }
<a name="l20470"></a>20470 
<a name="l20471"></a>20471   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (objfile, section);
<a name="l20472"></a>20472   <span class="keywordflow">if</span> (section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> == NULL)
<a name="l20473"></a>20473     {
<a name="l20474"></a>20474       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;missing %s section&quot;</span>), section_name);
<a name="l20475"></a>20475       <span class="keywordflow">return</span>;
<a name="l20476"></a>20476     }
<a name="l20477"></a>20477   abfd = <a class="code" href="dwarf2read_8c.html#a4a1d50916b974f36d2c880cdb0ac1564">get_section_bfd_owner</a> (section);
<a name="l20478"></a>20478 
<a name="l20479"></a>20479   <span class="comment">/* First pass: Find the name of the base filename.</span>
<a name="l20480"></a>20480 <span class="comment">     This filename is needed in order to process all macros whose definition</span>
<a name="l20481"></a>20481 <span class="comment">     (or undefinition) comes from the command line.  These macros are defined</span>
<a name="l20482"></a>20482 <span class="comment">     before the first DW_MACINFO_start_file entry, and yet still need to be</span>
<a name="l20483"></a>20483 <span class="comment">     associated to the base file.</span>
<a name="l20484"></a>20484 <span class="comment"></span>
<a name="l20485"></a>20485 <span class="comment">     To determine the base file name, we scan the macro definitions until we</span>
<a name="l20486"></a>20486 <span class="comment">     reach the first DW_MACINFO_start_file entry.  We then initialize</span>
<a name="l20487"></a>20487 <span class="comment">     CURRENT_FILE accordingly so that any macro definition found before the</span>
<a name="l20488"></a>20488 <span class="comment">     first DW_MACINFO_start_file can still be associated to the base file.  */</span>
<a name="l20489"></a>20489 
<a name="l20490"></a>20490   mac_ptr = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l20491"></a>20491   mac_end = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a>;
<a name="l20492"></a>20492 
<a name="l20493"></a>20493   mac_ptr = <a class="code" href="dwarf2read_8c.html#a7cbf6e28afbf0d07a71dd93a9d2d5b10">dwarf_parse_macro_header</a> (opcode_definitions, abfd, mac_ptr,
<a name="l20494"></a>20494                                       &amp;offset_size, section_is_gnu);
<a name="l20495"></a>20495   <span class="keywordflow">if</span> (mac_ptr == NULL)
<a name="l20496"></a>20496     {
<a name="l20497"></a>20497       <span class="comment">/* We already issued a complaint.  */</span>
<a name="l20498"></a>20498       <span class="keywordflow">return</span>;
<a name="l20499"></a>20499     }
<a name="l20500"></a>20500 
<a name="l20501"></a>20501   <span class="keywordflow">do</span>
<a name="l20502"></a>20502     {
<a name="l20503"></a>20503       <span class="comment">/* Do we at least have room for a macinfo type byte?  */</span>
<a name="l20504"></a>20504       <span class="keywordflow">if</span> (mac_ptr &gt;= mac_end)
<a name="l20505"></a>20505         {
<a name="l20506"></a>20506           <span class="comment">/* Complaint is printed during the second pass as GDB will probably</span>
<a name="l20507"></a>20507 <span class="comment">             stop the first pass earlier upon finding</span>
<a name="l20508"></a>20508 <span class="comment">             DW_MACINFO_start_file.  */</span>
<a name="l20509"></a>20509           <span class="keywordflow">break</span>;
<a name="l20510"></a>20510         }
<a name="l20511"></a>20511 
<a name="l20512"></a>20512       macinfo_type = <a class="code" href="dwarf2read_8c.html#a5e013d0e130142a329846ec6247e4c99">read_1_byte</a> (abfd, mac_ptr);
<a name="l20513"></a>20513       mac_ptr++;
<a name="l20514"></a>20514 
<a name="l20515"></a>20515       <span class="comment">/* Note that we rely on the fact that the corresponding GNU and</span>
<a name="l20516"></a>20516 <span class="comment">         DWARF constants are the same.  */</span>
<a name="l20517"></a>20517       <span class="keywordflow">switch</span> (macinfo_type)
<a name="l20518"></a>20518         {
<a name="l20519"></a>20519           <span class="comment">/* A zero macinfo type indicates the end of the macro</span>
<a name="l20520"></a>20520 <span class="comment">             information.  */</span>
<a name="l20521"></a>20521         <span class="keywordflow">case</span> 0:
<a name="l20522"></a>20522           <span class="keywordflow">break</span>;
<a name="l20523"></a>20523 
<a name="l20524"></a>20524         <span class="keywordflow">case</span> DW_MACRO_GNU_define:
<a name="l20525"></a>20525         <span class="keywordflow">case</span> DW_MACRO_GNU_undef:
<a name="l20526"></a>20526           <span class="comment">/* Only skip the data by MAC_PTR.  */</span>
<a name="l20527"></a>20527           {
<a name="l20528"></a>20528             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l20529"></a>20529 
<a name="l20530"></a>20530             <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, mac_ptr, &amp;bytes_read);
<a name="l20531"></a>20531             mac_ptr += bytes_read;
<a name="l20532"></a>20532             <a class="code" href="dwarf2read_8c.html#a5386044c6f74a934dbd3f4a3199cf5be">read_direct_string</a> (abfd, mac_ptr, &amp;bytes_read);
<a name="l20533"></a>20533             mac_ptr += bytes_read;
<a name="l20534"></a>20534           }
<a name="l20535"></a>20535           <span class="keywordflow">break</span>;
<a name="l20536"></a>20536 
<a name="l20537"></a>20537         <span class="keywordflow">case</span> DW_MACRO_GNU_start_file:
<a name="l20538"></a>20538           {
<a name="l20539"></a>20539             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l20540"></a>20540             <span class="keywordtype">int</span> <a class="code" href="symtab_8h.html#a41ebd28ef1d7c6ade45642cb6acc1039">line</a>, file;
<a name="l20541"></a>20541 
<a name="l20542"></a>20542             line = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, mac_ptr, &amp;bytes_read);
<a name="l20543"></a>20543             mac_ptr += bytes_read;
<a name="l20544"></a>20544             file = <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, mac_ptr, &amp;bytes_read);
<a name="l20545"></a>20545             mac_ptr += bytes_read;
<a name="l20546"></a>20546 
<a name="l20547"></a>20547             current_file = <a class="code" href="dwarf2read_8c.html#af8d39cfd2d056b6852bbfafb66f384c5">macro_start_file</a> (file, line, current_file,
<a name="l20548"></a>20548                                              comp_dir, lh, objfile);
<a name="l20549"></a>20549           }
<a name="l20550"></a>20550           <span class="keywordflow">break</span>;
<a name="l20551"></a>20551 
<a name="l20552"></a>20552         <span class="keywordflow">case</span> DW_MACRO_GNU_end_file:
<a name="l20553"></a>20553           <span class="comment">/* No data to skip by MAC_PTR.  */</span>
<a name="l20554"></a>20554           <span class="keywordflow">break</span>;
<a name="l20555"></a>20555 
<a name="l20556"></a>20556         <span class="keywordflow">case</span> DW_MACRO_GNU_define_indirect:
<a name="l20557"></a>20557         <span class="keywordflow">case</span> DW_MACRO_GNU_undef_indirect:
<a name="l20558"></a>20558         <span class="keywordflow">case</span> DW_MACRO_GNU_define_indirect_alt:
<a name="l20559"></a>20559         <span class="keywordflow">case</span> DW_MACRO_GNU_undef_indirect_alt:
<a name="l20560"></a>20560           {
<a name="l20561"></a>20561             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l20562"></a>20562 
<a name="l20563"></a>20563             <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, mac_ptr, &amp;bytes_read);
<a name="l20564"></a>20564             mac_ptr += bytes_read;
<a name="l20565"></a>20565             mac_ptr += offset_size;
<a name="l20566"></a>20566           }
<a name="l20567"></a>20567           <span class="keywordflow">break</span>;
<a name="l20568"></a>20568 
<a name="l20569"></a>20569         <span class="keywordflow">case</span> DW_MACRO_GNU_transparent_include:
<a name="l20570"></a>20570         <span class="keywordflow">case</span> DW_MACRO_GNU_transparent_include_alt:
<a name="l20571"></a>20571           <span class="comment">/* Note that, according to the spec, a transparent include</span>
<a name="l20572"></a>20572 <span class="comment">             chain cannot call DW_MACRO_GNU_start_file.  So, we can just</span>
<a name="l20573"></a>20573 <span class="comment">             skip this opcode.  */</span>
<a name="l20574"></a>20574           mac_ptr += offset_size;
<a name="l20575"></a>20575           <span class="keywordflow">break</span>;
<a name="l20576"></a>20576 
<a name="l20577"></a>20577         <span class="keywordflow">case</span> DW_MACINFO_vendor_ext:
<a name="l20578"></a>20578           <span class="comment">/* Only skip the data by MAC_PTR.  */</span>
<a name="l20579"></a>20579           <span class="keywordflow">if</span> (!section_is_gnu)
<a name="l20580"></a>20580             {
<a name="l20581"></a>20581               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bytes_read;
<a name="l20582"></a>20582 
<a name="l20583"></a>20583               <a class="code" href="dwarf2read_8c.html#ad7541bc44d34b27870a222470b87f374">read_unsigned_leb128</a> (abfd, mac_ptr, &amp;bytes_read);
<a name="l20584"></a>20584               mac_ptr += bytes_read;
<a name="l20585"></a>20585               <a class="code" href="dwarf2read_8c.html#a5386044c6f74a934dbd3f4a3199cf5be">read_direct_string</a> (abfd, mac_ptr, &amp;bytes_read);
<a name="l20586"></a>20586               mac_ptr += bytes_read;
<a name="l20587"></a>20587             }
<a name="l20588"></a>20588           <span class="comment">/* FALLTHROUGH */</span>
<a name="l20589"></a>20589 
<a name="l20590"></a>20590         <span class="keywordflow">default</span>:
<a name="l20591"></a>20591           mac_ptr = <a class="code" href="dwarf2read_8c.html#aa928dc181932c163a4f2b65102bf9a59">skip_unknown_opcode</a> (macinfo_type, opcode_definitions,
<a name="l20592"></a>20592                                          mac_ptr, mac_end, abfd, offset_size,
<a name="l20593"></a>20593                                          section);
<a name="l20594"></a>20594           <span class="keywordflow">if</span> (mac_ptr == NULL)
<a name="l20595"></a>20595             <span class="keywordflow">return</span>;
<a name="l20596"></a>20596           <span class="keywordflow">break</span>;
<a name="l20597"></a>20597         }
<a name="l20598"></a>20598     } <span class="keywordflow">while</span> (macinfo_type != 0 &amp;&amp; current_file == NULL);
<a name="l20599"></a>20599 
<a name="l20600"></a>20600   <span class="comment">/* Second pass: Process all entries.</span>
<a name="l20601"></a>20601 <span class="comment"></span>
<a name="l20602"></a>20602 <span class="comment">     Use the AT_COMMAND_LINE flag to determine whether we are still processing</span>
<a name="l20603"></a>20603 <span class="comment">     command-line macro definitions/undefinitions.  This flag is unset when we</span>
<a name="l20604"></a>20604 <span class="comment">     reach the first DW_MACINFO_start_file entry.  */</span>
<a name="l20605"></a>20605 
<a name="l20606"></a>20606   include_hash = htab_create_alloc (1, htab_hash_pointer, htab_eq_pointer,
<a name="l20607"></a>20607                                     NULL, <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a>, <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>);
<a name="l20608"></a>20608   cleanup = <a class="code" href="utils_8c.html#ad5977a7d9e282b65846100111cd95c76">make_cleanup_htab_delete</a> (include_hash);
<a name="l20609"></a>20609   mac_ptr = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l20610"></a>20610   slot = htab_find_slot (include_hash, mac_ptr, INSERT);
<a name="l20611"></a>20611   *slot = (<span class="keywordtype">void</span> *) mac_ptr;
<a name="l20612"></a>20612   <a class="code" href="dwarf2read_8c.html#af51738e736b1f2c73c6529a658849bb3">dwarf_decode_macro_bytes</a> (abfd, mac_ptr, mac_end,
<a name="l20613"></a>20613                             current_file, lh, comp_dir, section,
<a name="l20614"></a>20614                             section_is_gnu, 0,
<a name="l20615"></a>20615                             offset_size, objfile, include_hash);
<a name="l20616"></a>20616   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l20617"></a>20617 }
<a name="l20618"></a>20618 
<a name="l20619"></a>20619 <span class="comment">/* Check if the attribute&#39;s form is a DW_FORM_block*</span>
<a name="l20620"></a>20620 <span class="comment">   if so return true else false.  */</span>
<a name="l20621"></a>20621 
<a name="l20622"></a>20622 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l20623"></a><a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">20623</a> <a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr)
<a name="l20624"></a>20624 {
<a name="l20625"></a>20625   <span class="keywordflow">return</span> (attr == NULL ? 0 :
<a name="l20626"></a>20626       attr-&gt;form == DW_FORM_block1
<a name="l20627"></a>20627       || attr-&gt;form == DW_FORM_block2
<a name="l20628"></a>20628       || attr-&gt;form == DW_FORM_block4
<a name="l20629"></a>20629       || attr-&gt;form == DW_FORM_block
<a name="l20630"></a>20630       || attr-&gt;form == DW_FORM_exprloc);
<a name="l20631"></a>20631 }
<a name="l20632"></a>20632 
<a name="l20633"></a>20633 <span class="comment">/* Return non-zero if ATTR&#39;s value is a section offset --- classes</span>
<a name="l20634"></a>20634 <span class="comment">   lineptr, loclistptr, macptr or rangelistptr --- or zero, otherwise.</span>
<a name="l20635"></a>20635 <span class="comment">   You may use DW_UNSND (attr) to retrieve such offsets.</span>
<a name="l20636"></a>20636 <span class="comment"></span>
<a name="l20637"></a>20637 <span class="comment">   Section 7.5.4, &quot;Attribute Encodings&quot;, explains that no attribute</span>
<a name="l20638"></a>20638 <span class="comment">   may have a value that belongs to more than one of these classes; it</span>
<a name="l20639"></a>20639 <span class="comment">   would be ambiguous if we did, because we use the same forms for all</span>
<a name="l20640"></a>20640 <span class="comment">   of them.  */</span>
<a name="l20641"></a>20641 
<a name="l20642"></a>20642 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l20643"></a><a class="code" href="dwarf2read_8c.html#aa2b54436e7d13233cd6b866f562f637e">20643</a> <a class="code" href="dwarf2read_8c.html#aa2b54436e7d13233cd6b866f562f637e">attr_form_is_section_offset</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr)
<a name="l20644"></a>20644 {
<a name="l20645"></a>20645   <span class="keywordflow">return</span> (attr-&gt;form == DW_FORM_data4
<a name="l20646"></a>20646           || attr-&gt;form == DW_FORM_data8
<a name="l20647"></a>20647           || attr-&gt;form == DW_FORM_sec_offset);
<a name="l20648"></a>20648 }
<a name="l20649"></a>20649 
<a name="l20650"></a>20650 <span class="comment">/* Return non-zero if ATTR&#39;s value falls in the &#39;constant&#39; class, or</span>
<a name="l20651"></a>20651 <span class="comment">   zero otherwise.  When this function returns true, you can apply</span>
<a name="l20652"></a>20652 <span class="comment">   dwarf2_get_attr_constant_value to it.</span>
<a name="l20653"></a>20653 <span class="comment"></span>
<a name="l20654"></a>20654 <span class="comment">   However, note that for some attributes you must check</span>
<a name="l20655"></a>20655 <span class="comment">   attr_form_is_section_offset before using this test.  DW_FORM_data4</span>
<a name="l20656"></a>20656 <span class="comment">   and DW_FORM_data8 are members of both the constant class, and of</span>
<a name="l20657"></a>20657 <span class="comment">   the classes that contain offsets into other debug sections</span>
<a name="l20658"></a>20658 <span class="comment">   (lineptr, loclistptr, macptr or rangelistptr).  The DWARF spec says</span>
<a name="l20659"></a>20659 <span class="comment">   that, if an attribute&#39;s can be either a constant or one of the</span>
<a name="l20660"></a>20660 <span class="comment">   section offset classes, DW_FORM_data4 and DW_FORM_data8 should be</span>
<a name="l20661"></a>20661 <span class="comment">   taken as section offsets, not constants.  */</span>
<a name="l20662"></a>20662 
<a name="l20663"></a>20663 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l20664"></a><a class="code" href="dwarf2read_8c.html#a450aaabe2810df0fc34c371aae960580">20664</a> <a class="code" href="dwarf2read_8c.html#a450aaabe2810df0fc34c371aae960580">attr_form_is_constant</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr)
<a name="l20665"></a>20665 {
<a name="l20666"></a>20666   <span class="keywordflow">switch</span> (attr-&gt;form)
<a name="l20667"></a>20667     {
<a name="l20668"></a>20668     <span class="keywordflow">case</span> DW_FORM_sdata:
<a name="l20669"></a>20669     <span class="keywordflow">case</span> DW_FORM_udata:
<a name="l20670"></a>20670     <span class="keywordflow">case</span> DW_FORM_data1:
<a name="l20671"></a>20671     <span class="keywordflow">case</span> DW_FORM_data2:
<a name="l20672"></a>20672     <span class="keywordflow">case</span> DW_FORM_data4:
<a name="l20673"></a>20673     <span class="keywordflow">case</span> DW_FORM_data8:
<a name="l20674"></a>20674       <span class="keywordflow">return</span> 1;
<a name="l20675"></a>20675     <span class="keywordflow">default</span>:
<a name="l20676"></a>20676       <span class="keywordflow">return</span> 0;
<a name="l20677"></a>20677     }
<a name="l20678"></a>20678 }
<a name="l20679"></a>20679 
<a name="l20680"></a>20680 
<a name="l20681"></a>20681 <span class="comment">/* DW_ADDR is always stored already as sect_offset; despite for the forms</span>
<a name="l20682"></a>20682 <span class="comment">   besides DW_FORM_ref_addr it is stored as cu_offset in the DWARF file.  */</span>
<a name="l20683"></a>20683 
<a name="l20684"></a>20684 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l20685"></a><a class="code" href="dwarf2read_8c.html#a217d4eb87ed57947007169e88bb2a0f9">20685</a> <a class="code" href="dwarf2read_8c.html#a217d4eb87ed57947007169e88bb2a0f9">attr_form_is_ref</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr)
<a name="l20686"></a>20686 {
<a name="l20687"></a>20687   <span class="keywordflow">switch</span> (attr-&gt;form)
<a name="l20688"></a>20688     {
<a name="l20689"></a>20689     <span class="keywordflow">case</span> DW_FORM_ref_addr:
<a name="l20690"></a>20690     <span class="keywordflow">case</span> DW_FORM_ref1:
<a name="l20691"></a>20691     <span class="keywordflow">case</span> DW_FORM_ref2:
<a name="l20692"></a>20692     <span class="keywordflow">case</span> DW_FORM_ref4:
<a name="l20693"></a>20693     <span class="keywordflow">case</span> DW_FORM_ref8:
<a name="l20694"></a>20694     <span class="keywordflow">case</span> DW_FORM_ref_udata:
<a name="l20695"></a>20695     <span class="keywordflow">case</span> DW_FORM_GNU_ref_alt:
<a name="l20696"></a>20696       <span class="keywordflow">return</span> 1;
<a name="l20697"></a>20697     <span class="keywordflow">default</span>:
<a name="l20698"></a>20698       <span class="keywordflow">return</span> 0;
<a name="l20699"></a>20699     }
<a name="l20700"></a>20700 }
<a name="l20701"></a>20701 
<a name="l20702"></a>20702 <span class="comment">/* Return the .debug_loc section to use for CU.</span>
<a name="l20703"></a>20703 <span class="comment">   For DWO files use .debug_loc.dwo.  */</span>
<a name="l20704"></a>20704 
<a name="l20705"></a>20705 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *
<a name="l20706"></a><a class="code" href="dwarf2read_8c.html#a0602edab9de05571bbb11446ac16c115">20706</a> <a class="code" href="dwarf2read_8c.html#a0602edab9de05571bbb11446ac16c115">cu_debug_loc_section</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l20707"></a>20707 {
<a name="l20708"></a>20708   <span class="keywordflow">if</span> (cu-&gt;dwo_unit)
<a name="l20709"></a>20709     <span class="keywordflow">return</span> &amp;cu-&gt;dwo_unit-&gt;dwo_file-&gt;sections.loc;
<a name="l20710"></a>20710   <span class="keywordflow">return</span> &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a13750fe533c751c64de32245c5617623">loc</a>;
<a name="l20711"></a>20711 }
<a name="l20712"></a>20712 
<a name="l20713"></a>20713 <span class="comment">/* A helper function that fills in a dwarf2_loclist_baton.  */</span>
<a name="l20714"></a>20714 
<a name="l20715"></a>20715 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l20716"></a><a class="code" href="dwarf2read_8c.html#ad27262e92622f057801c24c2d248593d">20716</a> <a class="code" href="dwarf2read_8c.html#ad27262e92622f057801c24c2d248593d">fill_in_loclist_baton</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l20717"></a>20717                        <span class="keyword">struct</span> <a class="code" href="structdwarf2__loclist__baton.html">dwarf2_loclist_baton</a> *baton,
<a name="l20718"></a>20718                        <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr)
<a name="l20719"></a>20719 {
<a name="l20720"></a>20720   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section = <a class="code" href="dwarf2read_8c.html#a0602edab9de05571bbb11446ac16c115">cu_debug_loc_section</a> (cu);
<a name="l20721"></a>20721 
<a name="l20722"></a>20722   <a class="code" href="dwarf2read_8c.html#a3501a9e64a8451a203e12cb6c1ec3cdc">dwarf2_read_section</a> (dwarf2_per_objfile-&gt;objfile, section);
<a name="l20723"></a>20723 
<a name="l20724"></a>20724   baton-&gt;<a class="code" href="structdwarf2__loclist__baton.html#ac3560e87b1256d2ca35b2d12d29d0f96">per_cu</a> = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;
<a name="l20725"></a>20725   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (baton-&gt;<a class="code" href="structdwarf2__loclist__baton.html#ac3560e87b1256d2ca35b2d12d29d0f96">per_cu</a>);
<a name="l20726"></a>20726   <span class="comment">/* We don&#39;t know how long the location list is, but make sure we</span>
<a name="l20727"></a>20727 <span class="comment">     don&#39;t run off the edge of the section.  */</span>
<a name="l20728"></a>20728   baton-&gt;<a class="code" href="structdwarf2__loclist__baton.html#a8d54b42a598abdf506207f7998e5c487">size</a> = section-&gt;<a class="code" href="structdwarf2__section__info.html#acd9b6559558ad5d17c679506f578f92c">size</a> - <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l20729"></a>20729   baton-&gt;<a class="code" href="structdwarf2__loclist__baton.html#afd859a9730c897cde2682289f61f89ed">data</a> = section-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr);
<a name="l20730"></a>20730   baton-&gt;<a class="code" href="structdwarf2__loclist__baton.html#ad113bb290ce7a00cfcd6ac3eb752f214">base_address</a> = cu-&gt;<a class="code" href="structdwarf2__cu.html#a23134f383c2bf69e7c15465e6bb7c128">base_address</a>;
<a name="l20731"></a>20731   baton-&gt;<a class="code" href="structdwarf2__loclist__baton.html#add926238ae68fd8f7bd960cee41e4bfa">from_dwo</a> = cu-&gt;dwo_unit != NULL;
<a name="l20732"></a>20732 }
<a name="l20733"></a>20733 
<a name="l20734"></a>20734 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l20735"></a><a class="code" href="dwarf2read_8c.html#a097117b0b695bca7ad085fee973f5bd1">20735</a> <a class="code" href="dwarf2read_8c.html#a097117b0b695bca7ad085fee973f5bd1">dwarf2_symbol_mark_computed</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structattribute.html">attribute</a> *attr, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym,
<a name="l20736"></a>20736                              <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu, <span class="keywordtype">int</span> is_block)
<a name="l20737"></a>20737 {
<a name="l20738"></a>20738   <span class="keyword">struct </span>objfile *objfile = dwarf2_per_objfile-&gt;objfile;
<a name="l20739"></a>20739   <span class="keyword">struct </span><a class="code" href="structdwarf2__section__info.html">dwarf2_section_info</a> *section = <a class="code" href="dwarf2read_8c.html#a0602edab9de05571bbb11446ac16c115">cu_debug_loc_section</a> (cu);
<a name="l20740"></a>20740 
<a name="l20741"></a>20741   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#aa2b54436e7d13233cd6b866f562f637e">attr_form_is_section_offset</a> (attr)
<a name="l20742"></a>20742       <span class="comment">/* .debug_loc{,.dwo} may not exist at all, or the offset may be outside</span>
<a name="l20743"></a>20743 <span class="comment">         the section.  If so, fall through to the complaint in the</span>
<a name="l20744"></a>20744 <span class="comment">         other branch.  */</span>
<a name="l20745"></a>20745       &amp;&amp; <a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr) &lt; <a class="code" href="dwarf2read_8c.html#ab7078b0a27fb1b75f90d215b5d649771">dwarf2_section_size</a> (objfile, section))
<a name="l20746"></a>20746     {
<a name="l20747"></a>20747       <span class="keyword">struct </span><a class="code" href="structdwarf2__loclist__baton.html">dwarf2_loclist_baton</a> *baton;
<a name="l20748"></a>20748 
<a name="l20749"></a>20749       baton = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l20750"></a>20750                              sizeof (<span class="keyword">struct</span> <a class="code" href="structdwarf2__loclist__baton.html">dwarf2_loclist_baton</a>));
<a name="l20751"></a>20751 
<a name="l20752"></a>20752       <a class="code" href="dwarf2read_8c.html#ad27262e92622f057801c24c2d248593d">fill_in_loclist_baton</a> (cu, baton, attr);
<a name="l20753"></a>20753 
<a name="l20754"></a>20754       <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#a119974d7d2639455e745de437261ade8">base_known</a> == 0)
<a name="l20755"></a>20755         <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l20756"></a>20756                    <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Location list used without &quot;</span>
<a name="l20757"></a>20757                      <span class="stringliteral">&quot;specifying the CU base address.&quot;</span>));
<a name="l20758"></a>20758 
<a name="l20759"></a>20759       <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = (is_block
<a name="l20760"></a>20760                                    ? <a class="code" href="dwarf2read_8c.html#a5eb136e90359757c6d4c7769be39145a">dwarf2_loclist_block_index</a>
<a name="l20761"></a>20761                                    : <a class="code" href="dwarf2read_8c.html#a3e79ed48463ba20f601bd45aebff27df">dwarf2_loclist_index</a>);
<a name="l20762"></a>20762       <a class="code" href="symtab_8h.html#adf0a8c62c6a593ba1462bc338b95dadf">SYMBOL_LOCATION_BATON</a> (sym) = baton;
<a name="l20763"></a>20763     }
<a name="l20764"></a>20764   <span class="keywordflow">else</span>
<a name="l20765"></a>20765     {
<a name="l20766"></a>20766       <span class="keyword">struct </span><a class="code" href="structdwarf2__locexpr__baton.html">dwarf2_locexpr_baton</a> *baton;
<a name="l20767"></a>20767 
<a name="l20768"></a>20768       baton = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l20769"></a>20769                              sizeof (<span class="keyword">struct</span> <a class="code" href="structdwarf2__locexpr__baton.html">dwarf2_locexpr_baton</a>));
<a name="l20770"></a>20770       baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#a4f4c2fcdbde62332afde34a8a95d91fe">per_cu</a> = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;
<a name="l20771"></a>20771       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#a4f4c2fcdbde62332afde34a8a95d91fe">per_cu</a>);
<a name="l20772"></a>20772 
<a name="l20773"></a>20773       <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#a1bcc680f18e66c369f06689af7133bfd">attr_form_is_block</a> (attr))
<a name="l20774"></a>20774         {
<a name="l20775"></a>20775           <span class="comment">/* Note that we&#39;re just copying the block&#39;s data pointer</span>
<a name="l20776"></a>20776 <span class="comment">             here, not the actual data.  We&#39;re still pointing into the</span>
<a name="l20777"></a>20777 <span class="comment">             info_buffer for SYM&#39;s objfile; right now we never release</span>
<a name="l20778"></a>20778 <span class="comment">             that buffer, but when we do clean up properly this may</span>
<a name="l20779"></a>20779 <span class="comment">             need to change.  */</span>
<a name="l20780"></a>20780           baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#aad393a9f0c112b45b23fb0d30c19df07">size</a> = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;size;
<a name="l20781"></a>20781           baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#a629a2d12a13c59e34ffc1f64953b5f01">data</a> = <a class="code" href="dwarf2read_8c.html#a4ec04ce0154eefa1a99ff8d6bcbc7614">DW_BLOCK</a> (attr)-&gt;data;
<a name="l20782"></a>20782         }
<a name="l20783"></a>20783       <span class="keywordflow">else</span>
<a name="l20784"></a>20784         {
<a name="l20785"></a>20785           <a class="code" href="dwarf2read_8c.html#a0e9c948efe625df13875d3d70d218b65">dwarf2_invalid_attrib_class_complaint</a> (<span class="stringliteral">&quot;location description&quot;</span>,
<a name="l20786"></a>20786                                                  <a class="code" href="symtab_8h.html#a243e66afa96ff58a851b38f428bb3394">SYMBOL_NATURAL_NAME</a> (sym));
<a name="l20787"></a>20787           baton-&gt;<a class="code" href="structdwarf2__locexpr__baton.html#aad393a9f0c112b45b23fb0d30c19df07">size</a> = 0;
<a name="l20788"></a>20788         }
<a name="l20789"></a>20789 
<a name="l20790"></a>20790       <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = (is_block
<a name="l20791"></a>20791                                    ? <a class="code" href="dwarf2read_8c.html#a4cc0c49c12a38ac40188b11401c91db5">dwarf2_locexpr_block_index</a>
<a name="l20792"></a>20792                                    : <a class="code" href="dwarf2read_8c.html#a52b4c75a920c1e0dbff24148745bc8ca">dwarf2_locexpr_index</a>);
<a name="l20793"></a>20793       <a class="code" href="symtab_8h.html#adf0a8c62c6a593ba1462bc338b95dadf">SYMBOL_LOCATION_BATON</a> (sym) = baton;
<a name="l20794"></a>20794     }
<a name="l20795"></a>20795 }
<a name="l20796"></a>20796 
<a name="l20797"></a>20797 <span class="comment">/* Return the OBJFILE associated with the compilation unit CU.  If CU</span>
<a name="l20798"></a>20798 <span class="comment">   came from a separate debuginfo file, then the master objfile is</span>
<a name="l20799"></a>20799 <span class="comment">   returned.  */</span>
<a name="l20800"></a>20800 
<a name="l20801"></a>20801 <span class="keyword">struct </span>objfile *
<a name="l20802"></a><a class="code" href="dwarf2read_8c.html#a4355a4d3d40a9cd4a8f5fbc2e6fdc788">20802</a> <a class="code" href="dwarf2loc_8h.html#a07b033363e96dc930852363b102d80e9">dwarf2_per_cu_objfile</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l20803"></a>20803 {
<a name="l20804"></a>20804   <span class="keyword">struct </span>objfile *objfile = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>;
<a name="l20805"></a>20805 
<a name="l20806"></a>20806   <span class="comment">/* Return the master objfile, so that we can report and look up the</span>
<a name="l20807"></a>20807 <span class="comment">     correct file containing this variable.  */</span>
<a name="l20808"></a>20808   <span class="keywordflow">if</span> (objfile-&gt;<a class="code" href="structobjfile.html#a1ef5fed06f7a9c5864c9a0ce46a87710">separate_debug_objfile_backlink</a>)
<a name="l20809"></a>20809     objfile = objfile-&gt;<a class="code" href="structobjfile.html#a1ef5fed06f7a9c5864c9a0ce46a87710">separate_debug_objfile_backlink</a>;
<a name="l20810"></a>20810 
<a name="l20811"></a>20811   <span class="keywordflow">return</span> objfile;
<a name="l20812"></a>20812 }
<a name="l20813"></a>20813 
<a name="l20814"></a>20814 <span class="comment">/* Return comp_unit_head for PER_CU, either already available in PER_CU-&gt;CU</span>
<a name="l20815"></a>20815 <span class="comment">   (CU_HEADERP is unused in such case) or prepare a temporary copy at</span>
<a name="l20816"></a>20816 <span class="comment">   CU_HEADERP first.  */</span>
<a name="l20817"></a>20817 
<a name="l20818"></a>20818 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *
<a name="l20819"></a><a class="code" href="dwarf2read_8c.html#a654121c3ad601333b40f618013b55e83">20819</a> <a class="code" href="dwarf2read_8c.html#a654121c3ad601333b40f618013b55e83">per_cu_header_read_in</a> (<span class="keyword">struct</span> <a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_headerp,
<a name="l20820"></a>20820                        <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l20821"></a>20821 {
<a name="l20822"></a>20822   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *info_ptr;
<a name="l20823"></a>20823 
<a name="l20824"></a>20824   <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>)
<a name="l20825"></a>20825     <span class="keywordflow">return</span> &amp;per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ae3b3bb32643cc94e1681867baae8a3ce">header</a>;
<a name="l20826"></a>20826 
<a name="l20827"></a>20827   info_ptr = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a2e0f814cd7bde2290bef861dce40bd05">section</a>-&gt;<a class="code" href="structdwarf2__section__info.html#a5c87f03a890bdf8fa87d0409fcc98f81">buffer</a> + per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l20828"></a>20828 
<a name="l20829"></a>20829   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (cu_headerp, 0, <span class="keyword">sizeof</span> (*cu_headerp));
<a name="l20830"></a>20830   <a class="code" href="dwarf2read_8c.html#af69b698a6799f5cd7603c38c2be1cecb">read_comp_unit_head</a> (cu_headerp, info_ptr, per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>);
<a name="l20831"></a>20831 
<a name="l20832"></a>20832   <span class="keywordflow">return</span> cu_headerp;
<a name="l20833"></a>20833 }
<a name="l20834"></a>20834 
<a name="l20835"></a>20835 <span class="comment">/* Return the address size given in the compilation unit header for CU.  */</span>
<a name="l20836"></a>20836 
<a name="l20837"></a>20837 <span class="keywordtype">int</span>
<a name="l20838"></a><a class="code" href="dwarf2read_8c.html#aa2be4cf93081a15f0d36358c15dcbc87">20838</a> <a class="code" href="dwarf2loc_8h.html#a3db2cfa2cef34761da0fd5a59a54f5b6">dwarf2_per_cu_addr_size</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l20839"></a>20839 {
<a name="l20840"></a>20840   <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> cu_header_local;
<a name="l20841"></a>20841   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_headerp;
<a name="l20842"></a>20842 
<a name="l20843"></a>20843   cu_headerp = <a class="code" href="dwarf2read_8c.html#a654121c3ad601333b40f618013b55e83">per_cu_header_read_in</a> (&amp;cu_header_local, per_cu);
<a name="l20844"></a>20844 
<a name="l20845"></a>20845   <span class="keywordflow">return</span> cu_headerp-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l20846"></a>20846 }
<a name="l20847"></a>20847 
<a name="l20848"></a>20848 <span class="comment">/* Return the offset size given in the compilation unit header for CU.  */</span>
<a name="l20849"></a>20849 
<a name="l20850"></a>20850 <span class="keywordtype">int</span>
<a name="l20851"></a><a class="code" href="dwarf2read_8c.html#a13fd1bf58c5816ac202cca37937781dc">20851</a> <a class="code" href="dwarf2loc_8h.html#a57ec8491a932aa352c1b0c0f0054feb6">dwarf2_per_cu_offset_size</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l20852"></a>20852 {
<a name="l20853"></a>20853   <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> cu_header_local;
<a name="l20854"></a>20854   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_headerp;
<a name="l20855"></a>20855 
<a name="l20856"></a>20856   cu_headerp = <a class="code" href="dwarf2read_8c.html#a654121c3ad601333b40f618013b55e83">per_cu_header_read_in</a> (&amp;cu_header_local, per_cu);
<a name="l20857"></a>20857 
<a name="l20858"></a>20858   <span class="keywordflow">return</span> cu_headerp-&gt;<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>;
<a name="l20859"></a>20859 }
<a name="l20860"></a>20860 
<a name="l20861"></a>20861 <span class="comment">/* See its dwarf2loc.h declaration.  */</span>
<a name="l20862"></a>20862 
<a name="l20863"></a>20863 <span class="keywordtype">int</span>
<a name="l20864"></a><a class="code" href="dwarf2read_8c.html#a496269cc09e9ecfefb416ff4bcf4512f">20864</a> <a class="code" href="dwarf2loc_8h.html#a365ba9dfc2c414d0ef511dd5419cfe69">dwarf2_per_cu_ref_addr_size</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l20865"></a>20865 {
<a name="l20866"></a>20866   <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> cu_header_local;
<a name="l20867"></a>20867   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcomp__unit__head.html">comp_unit_head</a> *cu_headerp;
<a name="l20868"></a>20868 
<a name="l20869"></a>20869   cu_headerp = <a class="code" href="dwarf2read_8c.html#a654121c3ad601333b40f618013b55e83">per_cu_header_read_in</a> (&amp;cu_header_local, per_cu);
<a name="l20870"></a>20870 
<a name="l20871"></a>20871   <span class="keywordflow">if</span> (cu_headerp-&gt;<a class="code" href="structcomp__unit__head.html#a68d6c482c646af0266771ad56b73748d">version</a> == 2)
<a name="l20872"></a>20872     <span class="keywordflow">return</span> cu_headerp-&gt;<a class="code" href="structcomp__unit__head.html#a3cff96fe703a7b745f802c1fc8a72184">addr_size</a>;
<a name="l20873"></a>20873   <span class="keywordflow">else</span>
<a name="l20874"></a>20874     <span class="keywordflow">return</span> cu_headerp-&gt;<a class="code" href="structcomp__unit__head.html#af3f7c1c5dfb13cec91f4fb697f17e79f">offset_size</a>;
<a name="l20875"></a>20875 }
<a name="l20876"></a>20876 
<a name="l20877"></a>20877 <span class="comment">/* Return the text offset of the CU.  The returned offset comes from</span>
<a name="l20878"></a>20878 <span class="comment">   this CU&#39;s objfile.  If this objfile came from a separate debuginfo</span>
<a name="l20879"></a>20879 <span class="comment">   file, then the offset may be different from the corresponding</span>
<a name="l20880"></a>20880 <span class="comment">   offset in the parent objfile.  */</span>
<a name="l20881"></a>20881 
<a name="l20882"></a>20882 <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l20883"></a><a class="code" href="dwarf2read_8c.html#a9031b63c7056b1ab69097e4afc221a15">20883</a> <a class="code" href="dwarf2loc_8h.html#aeb4397a3d8727e0110b9c874dcc685c7">dwarf2_per_cu_text_offset</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l20884"></a>20884 {
<a name="l20885"></a>20885   <span class="keyword">struct </span>objfile *objfile = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>;
<a name="l20886"></a>20886 
<a name="l20887"></a>20887   <span class="keywordflow">return</span> <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>, <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l20888"></a>20888 }
<a name="l20889"></a>20889 
<a name="l20890"></a>20890 <span class="comment">/* Locate the .debug_info compilation unit from CU&#39;s objfile which contains</span>
<a name="l20891"></a>20891 <span class="comment">   the DIE at OFFSET.  Raises an error on failure.  */</span>
<a name="l20892"></a>20892 
<a name="l20893"></a>20893 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *
<a name="l20894"></a><a class="code" href="dwarf2read_8c.html#af3b37bdf179696b92b068cd2894de56d">20894</a> <a class="code" href="dwarf2read_8c.html#af3b37bdf179696b92b068cd2894de56d">dwarf2_find_containing_comp_unit</a> (<a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>,
<a name="l20895"></a>20895                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset_in_dwz,
<a name="l20896"></a>20896                                   <span class="keyword">struct</span> objfile *objfile)
<a name="l20897"></a>20897 {
<a name="l20898"></a>20898   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *this_cu;
<a name="l20899"></a>20899   <span class="keywordtype">int</span> low, high;
<a name="l20900"></a>20900   <span class="keyword">const</span> <a class="code" href="structsect__offset.html">sect_offset</a> *cu_off;
<a name="l20901"></a>20901 
<a name="l20902"></a>20902   low = 0;
<a name="l20903"></a>20903   high = dwarf2_per_objfile-&gt;n_comp_units - 1;
<a name="l20904"></a>20904   <span class="keywordflow">while</span> (high &gt; low)
<a name="l20905"></a>20905     {
<a name="l20906"></a>20906       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *mid_cu;
<a name="l20907"></a>20907       <span class="keywordtype">int</span> mid = low + (high - low) / 2;
<a name="l20908"></a>20908 
<a name="l20909"></a>20909       mid_cu = dwarf2_per_objfile-&gt;all_comp_units[mid];
<a name="l20910"></a>20910       cu_off = &amp;mid_cu-&gt;offset;
<a name="l20911"></a>20911       <span class="keywordflow">if</span> (mid_cu-&gt;is_dwz &gt; offset_in_dwz
<a name="l20912"></a>20912           || (mid_cu-&gt;is_dwz == offset_in_dwz
<a name="l20913"></a>20913               &amp;&amp; cu_off-&gt;<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> &gt;= offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>))
<a name="l20914"></a>20914         high = mid;
<a name="l20915"></a>20915       <span class="keywordflow">else</span>
<a name="l20916"></a>20916         low = mid + 1;
<a name="l20917"></a>20917     }
<a name="l20918"></a>20918   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (low == high);
<a name="l20919"></a>20919   this_cu = dwarf2_per_objfile-&gt;all_comp_units[low];
<a name="l20920"></a>20920   cu_off = &amp;this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>;
<a name="l20921"></a>20921   <span class="keywordflow">if</span> (this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a> != offset_in_dwz || cu_off-&gt;<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> &gt; offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>)
<a name="l20922"></a>20922     {
<a name="l20923"></a>20923       <span class="keywordflow">if</span> (low == 0 || this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a5055d59117ed7fd7e91897ef184c236e">is_dwz</a> != offset_in_dwz)
<a name="l20924"></a>20924         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf Error: could not find partial DIE containing &quot;</span>
<a name="l20925"></a>20925                <span class="stringliteral">&quot;offset 0x%lx [in module %s]&quot;</span>),
<a name="l20926"></a>20926                (<span class="keywordtype">long</span>) offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>, bfd_get_filename (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>));
<a name="l20927"></a>20927 
<a name="l20928"></a>20928       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (dwarf2_per_objfile-&gt;all_comp_units[low-1]-&gt;offset.sect_off
<a name="l20929"></a>20929                   &lt;= offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l20930"></a>20930       <span class="keywordflow">return</span> dwarf2_per_objfile-&gt;all_comp_units[low-1];
<a name="l20931"></a>20931     }
<a name="l20932"></a>20932   <span class="keywordflow">else</span>
<a name="l20933"></a>20933     {
<a name="l20934"></a>20934       this_cu = dwarf2_per_objfile-&gt;all_comp_units[low];
<a name="l20935"></a>20935       <span class="keywordflow">if</span> (low == dwarf2_per_objfile-&gt;n_comp_units - 1
<a name="l20936"></a>20936           &amp;&amp; offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> &gt;= this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> + this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a>)
<a name="l20937"></a>20937         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;invalid dwarf2 offset %u&quot;</span>), offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l20938"></a>20938       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (offset.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> &lt; this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> + this_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a>);
<a name="l20939"></a>20939       <span class="keywordflow">return</span> this_cu;
<a name="l20940"></a>20940     }
<a name="l20941"></a>20941 }
<a name="l20942"></a>20942 
<a name="l20943"></a>20943 <span class="comment">/* Initialize dwarf2_cu CU, owned by PER_CU.  */</span>
<a name="l20944"></a>20944 
<a name="l20945"></a>20945 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l20946"></a><a class="code" href="dwarf2read_8c.html#abd170e25a0f34cecee142a0252b26d82">20946</a> <a class="code" href="dwarf2read_8c.html#abd170e25a0f34cecee142a0252b26d82">init_one_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>, <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l20947"></a>20947 {
<a name="l20948"></a>20948   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (cu, 0, <span class="keyword">sizeof</span> (*cu));
<a name="l20949"></a>20949   per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> = <a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>;
<a name="l20950"></a>20950   cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a> = per_cu;
<a name="l20951"></a>20951   cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a> = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a1ce715398553b15918aa640aeb3147d6">objfile</a>;
<a name="l20952"></a>20952   obstack_init (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>);
<a name="l20953"></a>20953 }
<a name="l20954"></a>20954 
<a name="l20955"></a>20955 <span class="comment">/* Initialize basic fields of dwarf_cu CU according to DIE COMP_UNIT_DIE.  */</span>
<a name="l20956"></a>20956 
<a name="l20957"></a>20957 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l20958"></a><a class="code" href="dwarf2read_8c.html#a7a6cb8459a76588ce7ef6a56b19ef5c8">20958</a> <a class="code" href="dwarf2read_8c.html#a7a6cb8459a76588ce7ef6a56b19ef5c8">prepare_one_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>, <span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *comp_unit_die,
<a name="l20959"></a>20959                        <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> pretend_language)
<a name="l20960"></a>20960 {
<a name="l20961"></a>20961   <span class="keyword">struct </span><a class="code" href="structattribute.html">attribute</a> *attr;
<a name="l20962"></a>20962 
<a name="l20963"></a>20963   <span class="comment">/* Set the language we&#39;re debugging.  */</span>
<a name="l20964"></a>20964   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (comp_unit_die, DW_AT_language, cu);
<a name="l20965"></a>20965   <span class="keywordflow">if</span> (attr)
<a name="l20966"></a>20966     <a class="code" href="dwarf2read_8c.html#abd567fd6ea120b361c1b04ce7c20ea54">set_cu_language</a> (<a class="code" href="dwarf2read_8c.html#a3294858a62887177a589905894697d20">DW_UNSND</a> (attr), cu);
<a name="l20967"></a>20967   <span class="keywordflow">else</span>
<a name="l20968"></a>20968     {
<a name="l20969"></a>20969       cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a> = pretend_language;
<a name="l20970"></a>20970       cu-&gt;<a class="code" href="structdwarf2__cu.html#aa12f3aeef950b4457378c14f9ba16f12">language_defn</a> = <a class="code" href="language_8c.html#adba6bd079cb2f1df763354ec97abe0cd">language_def</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#ad3272e1ccb486f63b94e907cf45bdb41">language</a>);
<a name="l20971"></a>20971     }
<a name="l20972"></a>20972 
<a name="l20973"></a>20973   attr = <a class="code" href="dwarf2read_8c.html#a4324e6a96f88ae42530585a7c6c6c52d">dwarf2_attr</a> (comp_unit_die, DW_AT_producer, cu);
<a name="l20974"></a>20974   <span class="keywordflow">if</span> (attr)
<a name="l20975"></a>20975     cu-&gt;<a class="code" href="structdwarf2__cu.html#ac126062e961e17e71b4edb7298f6ecb9">producer</a> = <a class="code" href="dwarf2read_8c.html#a56e536f940933a2ee692dbad3dbdd129">DW_STRING</a> (attr);
<a name="l20976"></a>20976 }
<a name="l20977"></a>20977 
<a name="l20978"></a>20978 <span class="comment">/* Release one cached compilation unit, CU.  We unlink it from the tree</span>
<a name="l20979"></a>20979 <span class="comment">   of compilation units, but we don&#39;t remove it from the read_in_chain;</span>
<a name="l20980"></a>20980 <span class="comment">   the caller is responsible for that.</span>
<a name="l20981"></a>20981 <span class="comment">   NOTE: DATA is a void * because this function is also used as a</span>
<a name="l20982"></a>20982 <span class="comment">   cleanup routine.  */</span>
<a name="l20983"></a>20983 
<a name="l20984"></a>20984 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l20985"></a><a class="code" href="dwarf2read_8c.html#a686d2ded76f9904b6f35d4402ee17230">20985</a> <a class="code" href="dwarf2read_8c.html#a686d2ded76f9904b6f35d4402ee17230">free_heap_comp_unit</a> (<span class="keywordtype">void</span> *data)
<a name="l20986"></a>20986 {
<a name="l20987"></a>20987   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = data;
<a name="l20988"></a>20988 
<a name="l20989"></a>20989   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a> != NULL);
<a name="l20990"></a>20990   cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> = NULL;
<a name="l20991"></a>20991   cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a> = NULL;
<a name="l20992"></a>20992 
<a name="l20993"></a>20993   obstack_free (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>, NULL);
<a name="l20994"></a>20994 
<a name="l20995"></a>20995   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (cu);
<a name="l20996"></a>20996 }
<a name="l20997"></a>20997 
<a name="l20998"></a>20998 <span class="comment">/* This cleanup function is passed the address of a dwarf2_cu on the stack</span>
<a name="l20999"></a>20999 <span class="comment">   when we&#39;re finished with it.  We can&#39;t free the pointer itself, but be</span>
<a name="l21000"></a>21000 <span class="comment">   sure to unlink it from the cache.  Also release any associated storage.  */</span>
<a name="l21001"></a>21001 
<a name="l21002"></a>21002 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21003"></a><a class="code" href="dwarf2read_8c.html#ac4c57bb71ff493266c9d5a80a484dcbe">21003</a> <a class="code" href="dwarf2read_8c.html#ac4c57bb71ff493266c9d5a80a484dcbe">free_stack_comp_unit</a> (<span class="keywordtype">void</span> *data)
<a name="l21004"></a>21004 {
<a name="l21005"></a>21005   <span class="keyword">struct </span><a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu = data;
<a name="l21006"></a>21006 
<a name="l21007"></a>21007   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a> != NULL);
<a name="l21008"></a>21008   cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> = NULL;
<a name="l21009"></a>21009   cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a> = NULL;
<a name="l21010"></a>21010 
<a name="l21011"></a>21011   obstack_free (&amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>, NULL);
<a name="l21012"></a>21012   cu-&gt;<a class="code" href="structdwarf2__cu.html#a1e821881f894272409a466d336a88b1f">partial_dies</a> = NULL;
<a name="l21013"></a>21013 }
<a name="l21014"></a>21014 
<a name="l21015"></a>21015 <span class="comment">/* Free all cached compilation units.  */</span>
<a name="l21016"></a>21016 
<a name="l21017"></a>21017 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21018"></a><a class="code" href="dwarf2read_8c.html#a8fe96d50d88ef6a4b3ef501aada103ab">21018</a> <a class="code" href="dwarf2read_8c.html#a8fe96d50d88ef6a4b3ef501aada103ab">free_cached_comp_units</a> (<span class="keywordtype">void</span> *data)
<a name="l21019"></a>21019 {
<a name="l21020"></a>21020   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu, **last_chain;
<a name="l21021"></a>21021 
<a name="l21022"></a>21022   per_cu = dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a250e2511524a3122ba1489978a303221">read_in_chain</a>;
<a name="l21023"></a>21023   last_chain = &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a250e2511524a3122ba1489978a303221">read_in_chain</a>;
<a name="l21024"></a>21024   <span class="keywordflow">while</span> (per_cu != NULL)
<a name="l21025"></a>21025     {
<a name="l21026"></a>21026       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *next_cu;
<a name="l21027"></a>21027 
<a name="l21028"></a>21028       next_cu = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ad4caa7a7978fa4ca2edef259dd77a8ef">read_in_chain</a>;
<a name="l21029"></a>21029 
<a name="l21030"></a>21030       <a class="code" href="dwarf2read_8c.html#a686d2ded76f9904b6f35d4402ee17230">free_heap_comp_unit</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>);
<a name="l21031"></a>21031       *last_chain = next_cu;
<a name="l21032"></a>21032 
<a name="l21033"></a>21033       per_cu = next_cu;
<a name="l21034"></a>21034     }
<a name="l21035"></a>21035 }
<a name="l21036"></a>21036 
<a name="l21037"></a>21037 <span class="comment">/* Increase the age counter on each cached compilation unit, and free</span>
<a name="l21038"></a>21038 <span class="comment">   any that are too old.  */</span>
<a name="l21039"></a>21039 
<a name="l21040"></a>21040 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21041"></a><a class="code" href="dwarf2read_8c.html#aea3bec269cdf43d65a84eb61d8c2c48b">21041</a> <a class="code" href="dwarf2read_8c.html#aea3bec269cdf43d65a84eb61d8c2c48b">age_cached_comp_units</a> (<span class="keywordtype">void</span>)
<a name="l21042"></a>21042 {
<a name="l21043"></a>21043   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu, **last_chain;
<a name="l21044"></a>21044 
<a name="l21045"></a>21045   <a class="code" href="dwarf2read_8c.html#af10d4c7106a94f43a2be645d98da2ed8">dwarf2_clear_marks</a> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a250e2511524a3122ba1489978a303221">read_in_chain</a>);
<a name="l21046"></a>21046   per_cu = dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a250e2511524a3122ba1489978a303221">read_in_chain</a>;
<a name="l21047"></a>21047   <span class="keywordflow">while</span> (per_cu != NULL)
<a name="l21048"></a>21048     {
<a name="l21049"></a>21049       per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ae8de3b2f422c424b62543c1ef121de02">last_used</a> ++;
<a name="l21050"></a>21050       <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ae8de3b2f422c424b62543c1ef121de02">last_used</a> &lt;= <a class="code" href="dwarf2read_8c.html#a1ebe9ac2a67f2df99ca92aacf6b25163">dwarf2_max_cache_age</a>)
<a name="l21051"></a>21051         <a class="code" href="dwarf2read_8c.html#a273c1412d7b59e71060bf91b333f96e9">dwarf2_mark</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>);
<a name="l21052"></a>21052       per_cu = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ad4caa7a7978fa4ca2edef259dd77a8ef">read_in_chain</a>;
<a name="l21053"></a>21053     }
<a name="l21054"></a>21054 
<a name="l21055"></a>21055   per_cu = dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a250e2511524a3122ba1489978a303221">read_in_chain</a>;
<a name="l21056"></a>21056   last_chain = &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a250e2511524a3122ba1489978a303221">read_in_chain</a>;
<a name="l21057"></a>21057   <span class="keywordflow">while</span> (per_cu != NULL)
<a name="l21058"></a>21058     {
<a name="l21059"></a>21059       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *next_cu;
<a name="l21060"></a>21060 
<a name="l21061"></a>21061       next_cu = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ad4caa7a7978fa4ca2edef259dd77a8ef">read_in_chain</a>;
<a name="l21062"></a>21062 
<a name="l21063"></a>21063       <span class="keywordflow">if</span> (!per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;mark)
<a name="l21064"></a>21064         {
<a name="l21065"></a>21065           <a class="code" href="dwarf2read_8c.html#a686d2ded76f9904b6f35d4402ee17230">free_heap_comp_unit</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>);
<a name="l21066"></a>21066           *last_chain = next_cu;
<a name="l21067"></a>21067         }
<a name="l21068"></a>21068       <span class="keywordflow">else</span>
<a name="l21069"></a>21069         last_chain = &amp;per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ad4caa7a7978fa4ca2edef259dd77a8ef">read_in_chain</a>;
<a name="l21070"></a>21070 
<a name="l21071"></a>21071       per_cu = next_cu;
<a name="l21072"></a>21072     }
<a name="l21073"></a>21073 }
<a name="l21074"></a>21074 
<a name="l21075"></a>21075 <span class="comment">/* Remove a single compilation unit from the cache.  */</span>
<a name="l21076"></a>21076 
<a name="l21077"></a>21077 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21078"></a><a class="code" href="dwarf2read_8c.html#a88ac0ca2997594c6c41d77ceeb620711">21078</a> <a class="code" href="dwarf2read_8c.html#a88ac0ca2997594c6c41d77ceeb620711">free_one_cached_comp_unit</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *target_per_cu)
<a name="l21079"></a>21079 {
<a name="l21080"></a>21080   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu, **last_chain;
<a name="l21081"></a>21081 
<a name="l21082"></a>21082   per_cu = dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a250e2511524a3122ba1489978a303221">read_in_chain</a>;
<a name="l21083"></a>21083   last_chain = &amp;dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a250e2511524a3122ba1489978a303221">read_in_chain</a>;
<a name="l21084"></a>21084   <span class="keywordflow">while</span> (per_cu != NULL)
<a name="l21085"></a>21085     {
<a name="l21086"></a>21086       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *next_cu;
<a name="l21087"></a>21087 
<a name="l21088"></a>21088       next_cu = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ad4caa7a7978fa4ca2edef259dd77a8ef">read_in_chain</a>;
<a name="l21089"></a>21089 
<a name="l21090"></a>21090       <span class="keywordflow">if</span> (per_cu == target_per_cu)
<a name="l21091"></a>21091         {
<a name="l21092"></a>21092           <a class="code" href="dwarf2read_8c.html#a686d2ded76f9904b6f35d4402ee17230">free_heap_comp_unit</a> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>);
<a name="l21093"></a>21093           per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> = NULL;
<a name="l21094"></a>21094           *last_chain = next_cu;
<a name="l21095"></a>21095           <span class="keywordflow">break</span>;
<a name="l21096"></a>21096         }
<a name="l21097"></a>21097       <span class="keywordflow">else</span>
<a name="l21098"></a>21098         last_chain = &amp;per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ad4caa7a7978fa4ca2edef259dd77a8ef">read_in_chain</a>;
<a name="l21099"></a>21099 
<a name="l21100"></a>21100       per_cu = next_cu;
<a name="l21101"></a>21101     }
<a name="l21102"></a>21102 }
<a name="l21103"></a>21103 
<a name="l21104"></a>21104 <span class="comment">/* Release all extra memory associated with OBJFILE.  */</span>
<a name="l21105"></a>21105 
<a name="l21106"></a>21106 <span class="keywordtype">void</span>
<a name="l21107"></a><a class="code" href="symfile_8h.html#a8ab19158c75d6eba000aa839c5cab862">21107</a> <a class="code" href="dwarf2read_8c.html#a31f05f7243e0fe61d86ad46ee2e7e704">dwarf2_free_objfile</a> (<span class="keyword">struct</span> objfile *objfile)
<a name="l21108"></a>21108 {
<a name="l21109"></a>21109   dwarf2_per_objfile = objfile_data (objfile, <a class="code" href="dwarf2read_8c.html#a9fcfdd623d890b4c3b4ac0ba42e7df4b">dwarf2_objfile_data_key</a>);
<a name="l21110"></a>21110 
<a name="l21111"></a>21111   <span class="keywordflow">if</span> (dwarf2_per_objfile == NULL)
<a name="l21112"></a>21112     <span class="keywordflow">return</span>;
<a name="l21113"></a>21113 
<a name="l21114"></a>21114   <span class="comment">/* Cached DIE trees use xmalloc and the comp_unit_obstack.  */</span>
<a name="l21115"></a>21115   <a class="code" href="dwarf2read_8c.html#a8fe96d50d88ef6a4b3ef501aada103ab">free_cached_comp_units</a> (NULL);
<a name="l21116"></a>21116 
<a name="l21117"></a>21117   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#aeb96e928b0cd54363e459b10effcb0b3">quick_file_names_table</a>)
<a name="l21118"></a>21118     htab_delete (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#aeb96e928b0cd54363e459b10effcb0b3">quick_file_names_table</a>);
<a name="l21119"></a>21119 
<a name="l21120"></a>21120   <span class="comment">/* Everything else should be on the objfile obstack.  */</span>
<a name="l21121"></a>21121 }
<a name="l21122"></a>21122 
<a name="l21123"></a>21123 <span class="comment">/* A set of CU &quot;per_cu&quot; pointer, DIE offset, and GDB type pointer.</span>
<a name="l21124"></a>21124 <span class="comment">   We store these in a hash table separate from the DIEs, and preserve them</span>
<a name="l21125"></a>21125 <span class="comment">   when the DIEs are flushed out of cache.</span>
<a name="l21126"></a>21126 <span class="comment"></span>
<a name="l21127"></a>21127 <span class="comment">   The CU &quot;per_cu&quot; pointer is needed because offset alone is not enough to</span>
<a name="l21128"></a>21128 <span class="comment">   uniquely identify the type.  A file may have multiple .debug_types sections,</span>
<a name="l21129"></a>21129 <span class="comment">   or the type may come from a DWO file.  Furthermore, while it&#39;s more logical</span>
<a name="l21130"></a>21130 <span class="comment">   to use per_cu-&gt;section+offset, with Fission the section with the data is in</span>
<a name="l21131"></a>21131 <span class="comment">   the DWO file but we don&#39;t know that section at the point we need it.</span>
<a name="l21132"></a>21132 <span class="comment">   We have to use something in dwarf2_per_cu_data (or the pointer to it)</span>
<a name="l21133"></a>21133 <span class="comment">   because we can enter the lookup routine, get_die_type_at_offset, from</span>
<a name="l21134"></a>21134 <span class="comment">   outside this file, and thus won&#39;t necessarily have PER_CU-&gt;cu.</span>
<a name="l21135"></a>21135 <span class="comment">   Fortunately, PER_CU is stable for the life of the objfile.  */</span>
<a name="l21136"></a>21136 
<a name="l21137"></a><a class="code" href="structdwarf2__per__cu__offset__and__type.html">21137</a> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__offset__and__type.html">dwarf2_per_cu_offset_and_type</a>
<a name="l21138"></a>21138 {
<a name="l21139"></a><a class="code" href="structdwarf2__per__cu__offset__and__type.html#ab13515b447d359acbf8ad0bee5a504d9">21139</a>   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *<a class="code" href="structdwarf2__per__cu__offset__and__type.html#ab13515b447d359acbf8ad0bee5a504d9">per_cu</a>;
<a name="l21140"></a><a class="code" href="structdwarf2__per__cu__offset__and__type.html#a53c7cdc57bdda02be1622444151da242">21140</a>   <a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="structdwarf2__per__cu__offset__and__type.html#a53c7cdc57bdda02be1622444151da242">offset</a>;
<a name="l21141"></a><a class="code" href="structdwarf2__per__cu__offset__and__type.html#ae32e75ecadeb27e82e1a770bf7796e80">21141</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structdwarf2__per__cu__offset__and__type.html#ae32e75ecadeb27e82e1a770bf7796e80">type</a>;
<a name="l21142"></a>21142 };
<a name="l21143"></a>21143 
<a name="l21144"></a>21144 <span class="comment">/* Hash function for a dwarf2_per_cu_offset_and_type.  */</span>
<a name="l21145"></a>21145 
<a name="l21146"></a>21146 <span class="keyword">static</span> hashval_t
<a name="l21147"></a><a class="code" href="dwarf2read_8c.html#aa8e304fbd78751e849183bf7517f419f">21147</a> <a class="code" href="dwarf2read_8c.html#aa8e304fbd78751e849183bf7517f419f">per_cu_offset_and_type_hash</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item)
<a name="l21148"></a>21148 {
<a name="l21149"></a>21149   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__offset__and__type.html">dwarf2_per_cu_offset_and_type</a> *ofs = item;
<a name="l21150"></a>21150 
<a name="l21151"></a>21151   <span class="keywordflow">return</span> (uintptr_t) ofs-&gt;<a class="code" href="structdwarf2__per__cu__offset__and__type.html#ab13515b447d359acbf8ad0bee5a504d9">per_cu</a> + ofs-&gt;<a class="code" href="structdwarf2__per__cu__offset__and__type.html#a53c7cdc57bdda02be1622444151da242">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l21152"></a>21152 }
<a name="l21153"></a>21153 
<a name="l21154"></a>21154 <span class="comment">/* Equality function for a dwarf2_per_cu_offset_and_type.  */</span>
<a name="l21155"></a>21155 
<a name="l21156"></a>21156 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l21157"></a><a class="code" href="dwarf2read_8c.html#aecf27f645eaabea44cd1eff682ea5746">21157</a> <a class="code" href="dwarf2read_8c.html#aecf27f645eaabea44cd1eff682ea5746">per_cu_offset_and_type_eq</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item_lhs, <span class="keyword">const</span> <span class="keywordtype">void</span> *item_rhs)
<a name="l21158"></a>21158 {
<a name="l21159"></a>21159   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__offset__and__type.html">dwarf2_per_cu_offset_and_type</a> *ofs_lhs = item_lhs;
<a name="l21160"></a>21160   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__offset__and__type.html">dwarf2_per_cu_offset_and_type</a> *ofs_rhs = item_rhs;
<a name="l21161"></a>21161 
<a name="l21162"></a>21162   <span class="keywordflow">return</span> (ofs_lhs-&gt;<a class="code" href="structdwarf2__per__cu__offset__and__type.html#ab13515b447d359acbf8ad0bee5a504d9">per_cu</a> == ofs_rhs-&gt;<a class="code" href="structdwarf2__per__cu__offset__and__type.html#ab13515b447d359acbf8ad0bee5a504d9">per_cu</a>
<a name="l21163"></a>21163           &amp;&amp; ofs_lhs-&gt;<a class="code" href="structdwarf2__per__cu__offset__and__type.html#a53c7cdc57bdda02be1622444151da242">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> == ofs_rhs-&gt;<a class="code" href="structdwarf2__per__cu__offset__and__type.html#a53c7cdc57bdda02be1622444151da242">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l21164"></a>21164 }
<a name="l21165"></a>21165 
<a name="l21166"></a>21166 <span class="comment">/* Set the type associated with DIE to TYPE.  Save it in CU&#39;s hash</span>
<a name="l21167"></a>21167 <span class="comment">   table if necessary.  For convenience, return TYPE.</span>
<a name="l21168"></a>21168 <span class="comment"></span>
<a name="l21169"></a>21169 <span class="comment">   The DIEs reading must have careful ordering to:</span>
<a name="l21170"></a>21170 <span class="comment">    * Not cause infite loops trying to read in DIEs as a prerequisite for</span>
<a name="l21171"></a>21171 <span class="comment">      reading current DIE.</span>
<a name="l21172"></a>21172 <span class="comment">    * Not trying to dereference contents of still incompletely read in types</span>
<a name="l21173"></a>21173 <span class="comment">      while reading in other DIEs.</span>
<a name="l21174"></a>21174 <span class="comment">    * Enable referencing still incompletely read in types just by a pointer to</span>
<a name="l21175"></a>21175 <span class="comment">      the type without accessing its fields.</span>
<a name="l21176"></a>21176 <span class="comment"></span>
<a name="l21177"></a>21177 <span class="comment">   Therefore caller should follow these rules:</span>
<a name="l21178"></a>21178 <span class="comment">     * Try to fetch any prerequisite types we may need to build this DIE type</span>
<a name="l21179"></a>21179 <span class="comment">       before building the type and calling set_die_type.</span>
<a name="l21180"></a>21180 <span class="comment">     * After building type call set_die_type for current DIE as soon as</span>
<a name="l21181"></a>21181 <span class="comment">       possible before fetching more types to complete the current type.</span>
<a name="l21182"></a>21182 <span class="comment">     * Make the type as complete as possible before fetching more types.  */</span>
<a name="l21183"></a>21183 
<a name="l21184"></a>21184 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l21185"></a><a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">21185</a> <a class="code" href="dwarf2read_8c.html#a24237600948860d5730fe5e387843da9">set_die_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l21186"></a>21186 {
<a name="l21187"></a>21187   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__offset__and__type.html">dwarf2_per_cu_offset_and_type</a> **slot, ofs;
<a name="l21188"></a>21188   <span class="keyword">struct </span>objfile *objfile = cu-&gt;<a class="code" href="structdwarf2__cu.html#a3051c9fc79b506c20fe4a333dc083f0e">objfile</a>;
<a name="l21189"></a>21189 
<a name="l21190"></a>21190   <span class="comment">/* For Ada types, make sure that the gnat-specific data is always</span>
<a name="l21191"></a>21191 <span class="comment">     initialized (if not already set).  There are a few types where</span>
<a name="l21192"></a>21192 <span class="comment">     we should not be doing so, because the type-specific area is</span>
<a name="l21193"></a>21193 <span class="comment">     already used to hold some other piece of info (eg: TYPE_CODE_FLT</span>
<a name="l21194"></a>21194 <span class="comment">     where the type-specific area is used to store the floatformat).</span>
<a name="l21195"></a>21195 <span class="comment">     But this is not a problem, because the gnat-specific information</span>
<a name="l21196"></a>21196 <span class="comment">     is actually not needed for these types.  */</span>
<a name="l21197"></a>21197   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#aa6f64de62201aa04386e42862d37959c">need_gnat_info</a> (cu)
<a name="l21198"></a>21198       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>
<a name="l21199"></a>21199       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>
<a name="l21200"></a>21200       &amp;&amp; !<a class="code" href="gdbtypes_8h.html#ae599879d692c6b43f60ff21df29a89c2">HAVE_GNAT_AUX_INFO</a> (type))
<a name="l21201"></a>21201     <a class="code" href="gdbtypes_8h.html#abb11145b63a8563c0dc0a4c26229b188">INIT_GNAT_SPECIFIC</a> (type);
<a name="l21202"></a>21202 
<a name="l21203"></a>21203   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a4e97a72558a0e6cf369ede2776063aa8">die_type_hash</a> == NULL)
<a name="l21204"></a>21204     {
<a name="l21205"></a>21205       dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a4e97a72558a0e6cf369ede2776063aa8">die_type_hash</a> =
<a name="l21206"></a>21206         htab_create_alloc_ex (127,
<a name="l21207"></a>21207                               <a class="code" href="dwarf2read_8c.html#aa8e304fbd78751e849183bf7517f419f">per_cu_offset_and_type_hash</a>,
<a name="l21208"></a>21208                               <a class="code" href="dwarf2read_8c.html#aecf27f645eaabea44cd1eff682ea5746">per_cu_offset_and_type_eq</a>,
<a name="l21209"></a>21209                               NULL,
<a name="l21210"></a>21210                               &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l21211"></a>21211                               <a class="code" href="utils_8c.html#a64b0a5e317b6f45f062aa8356111644b">hashtab_obstack_allocate</a>,
<a name="l21212"></a>21212                               <a class="code" href="utils_8c.html#af32d0d55c7c49d59093e66ef695f9513">dummy_obstack_deallocate</a>);
<a name="l21213"></a>21213     }
<a name="l21214"></a>21214 
<a name="l21215"></a>21215   ofs.<a class="code" href="structdwarf2__per__cu__offset__and__type.html#ab13515b447d359acbf8ad0bee5a504d9">per_cu</a> = cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>;
<a name="l21216"></a>21216   ofs.<a class="code" href="structdwarf2__per__cu__offset__and__type.html#a53c7cdc57bdda02be1622444151da242">offset</a> = die-&gt;offset;
<a name="l21217"></a>21217   ofs.<a class="code" href="structdwarf2__per__cu__offset__and__type.html#ae32e75ecadeb27e82e1a770bf7796e80">type</a> = <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l21218"></a>21218   slot = (<span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__offset__and__type.html">dwarf2_per_cu_offset_and_type</a> **)
<a name="l21219"></a>21219     htab_find_slot (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a4e97a72558a0e6cf369ede2776063aa8">die_type_hash</a>, &amp;ofs, INSERT);
<a name="l21220"></a>21220   <span class="keywordflow">if</span> (*slot)
<a name="l21221"></a>21221     <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l21222"></a>21222                <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;A problem internal to GDB: DIE 0x%x has type already set&quot;</span>),
<a name="l21223"></a>21223                die-&gt;offset.sect_off);
<a name="l21224"></a>21224   *slot = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, sizeof (**slot));
<a name="l21225"></a>21225   **slot = ofs;
<a name="l21226"></a>21226   <span class="keywordflow">return</span> <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l21227"></a>21227 }
<a name="l21228"></a>21228 
<a name="l21229"></a>21229 <span class="comment">/* Look up the type for the die at OFFSET in PER_CU in die_type_hash,</span>
<a name="l21230"></a>21230 <span class="comment">   or return NULL if the die does not have a saved type.  */</span>
<a name="l21231"></a>21231 
<a name="l21232"></a>21232 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l21233"></a><a class="code" href="dwarf2read_8c.html#ae277955c587127c2a481663cca343437">21233</a> <a class="code" href="dwarf2read_8c.html#ae277955c587127c2a481663cca343437">get_die_type_at_offset</a> (<a class="code" href="structsect__offset.html">sect_offset</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>,
<a name="l21234"></a>21234                         <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l21235"></a>21235 {
<a name="l21236"></a>21236   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__offset__and__type.html">dwarf2_per_cu_offset_and_type</a> *slot, ofs;
<a name="l21237"></a>21237 
<a name="l21238"></a>21238   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a4e97a72558a0e6cf369ede2776063aa8">die_type_hash</a> == NULL)
<a name="l21239"></a>21239     <span class="keywordflow">return</span> NULL;
<a name="l21240"></a>21240 
<a name="l21241"></a>21241   ofs.<a class="code" href="structdwarf2__per__cu__offset__and__type.html#ab13515b447d359acbf8ad0bee5a504d9">per_cu</a> = <a class="code" href="structdwarf2__per__cu__offset__and__type.html#ab13515b447d359acbf8ad0bee5a504d9">per_cu</a>;
<a name="l21242"></a>21242   ofs.<a class="code" href="structdwarf2__per__cu__offset__and__type.html#a53c7cdc57bdda02be1622444151da242">offset</a> = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l21243"></a>21243   slot = htab_find (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a4e97a72558a0e6cf369ede2776063aa8">die_type_hash</a>, &amp;ofs);
<a name="l21244"></a>21244   <span class="keywordflow">if</span> (slot)
<a name="l21245"></a>21245     <span class="keywordflow">return</span> slot-&gt;<a class="code" href="structdwarf2__per__cu__offset__and__type.html#ae32e75ecadeb27e82e1a770bf7796e80">type</a>;
<a name="l21246"></a>21246   <span class="keywordflow">else</span>
<a name="l21247"></a>21247     <span class="keywordflow">return</span> NULL;
<a name="l21248"></a>21248 }
<a name="l21249"></a>21249 
<a name="l21250"></a>21250 <span class="comment">/* Look up the type for DIE in CU in die_type_hash,</span>
<a name="l21251"></a>21251 <span class="comment">   or return NULL if DIE does not have a saved type.  */</span>
<a name="l21252"></a>21252 
<a name="l21253"></a>21253 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l21254"></a><a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">21254</a> <a class="code" href="dwarf2read_8c.html#a3052adc4c7a90125db99b393e8dfb2a2">get_die_type</a> (<span class="keyword">struct</span> <a class="code" href="structdie__info.html">die_info</a> *die, <span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu)
<a name="l21255"></a>21255 {
<a name="l21256"></a>21256   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#ae277955c587127c2a481663cca343437">get_die_type_at_offset</a> (die-&gt;offset, cu-&gt;<a class="code" href="structdwarf2__cu.html#aa7cb1c14d44d0dc82254bffb9fe212c5">per_cu</a>);
<a name="l21257"></a>21257 }
<a name="l21258"></a>21258 
<a name="l21259"></a>21259 <span class="comment">/* Add a dependence relationship from CU to REF_PER_CU.  */</span>
<a name="l21260"></a>21260 
<a name="l21261"></a>21261 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21262"></a><a class="code" href="dwarf2read_8c.html#a718e49c311f78a8621ba62dec3084e02">21262</a> <a class="code" href="dwarf2read_8c.html#a718e49c311f78a8621ba62dec3084e02">dwarf2_add_dependence</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *cu,
<a name="l21263"></a>21263                        <span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *ref_per_cu)
<a name="l21264"></a>21264 {
<a name="l21265"></a>21265   <span class="keywordtype">void</span> **slot;
<a name="l21266"></a>21266 
<a name="l21267"></a>21267   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aba78cb69f78a0a03f004d6a25cd2dfdf">dependencies</a> == NULL)
<a name="l21268"></a>21268     cu-&gt;<a class="code" href="structdwarf2__cu.html#aba78cb69f78a0a03f004d6a25cd2dfdf">dependencies</a>
<a name="l21269"></a>21269       = htab_create_alloc_ex (5, htab_hash_pointer, htab_eq_pointer,
<a name="l21270"></a>21270                               NULL, &amp;cu-&gt;<a class="code" href="structdwarf2__cu.html#ad634f81d848cb7e721b69396bd67e609">comp_unit_obstack</a>,
<a name="l21271"></a>21271                               <a class="code" href="utils_8c.html#a64b0a5e317b6f45f062aa8356111644b">hashtab_obstack_allocate</a>,
<a name="l21272"></a>21272                               <a class="code" href="utils_8c.html#af32d0d55c7c49d59093e66ef695f9513">dummy_obstack_deallocate</a>);
<a name="l21273"></a>21273 
<a name="l21274"></a>21274   slot = htab_find_slot (cu-&gt;<a class="code" href="structdwarf2__cu.html#aba78cb69f78a0a03f004d6a25cd2dfdf">dependencies</a>, ref_per_cu, INSERT);
<a name="l21275"></a>21275   <span class="keywordflow">if</span> (*slot == NULL)
<a name="l21276"></a>21276     *slot = ref_per_cu;
<a name="l21277"></a>21277 }
<a name="l21278"></a>21278 
<a name="l21279"></a>21279 <span class="comment">/* Subroutine of dwarf2_mark to pass to htab_traverse.</span>
<a name="l21280"></a>21280 <span class="comment">   Set the mark field in every compilation unit in the</span>
<a name="l21281"></a>21281 <span class="comment">   cache that we must keep because we are keeping CU.  */</span>
<a name="l21282"></a>21282 
<a name="l21283"></a>21283 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l21284"></a><a class="code" href="dwarf2read_8c.html#aaee49837d3c6eee27ea59aa29fc02a00">21284</a> <a class="code" href="dwarf2read_8c.html#aaee49837d3c6eee27ea59aa29fc02a00">dwarf2_mark_helper</a> (<span class="keywordtype">void</span> **slot, <span class="keywordtype">void</span> *data)
<a name="l21285"></a>21285 {
<a name="l21286"></a>21286   <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu;
<a name="l21287"></a>21287 
<a name="l21288"></a>21288   per_cu = (<span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *) *slot;
<a name="l21289"></a>21289 
<a name="l21290"></a>21290   <span class="comment">/* cu-&gt;dependencies references may not yet have been ever read if QUIT aborts</span>
<a name="l21291"></a>21291 <span class="comment">     reading of the chain.  As such dependencies remain valid it is not much</span>
<a name="l21292"></a>21292 <span class="comment">     useful to track and undo them during QUIT cleanups.  */</span>
<a name="l21293"></a>21293   <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a> == NULL)
<a name="l21294"></a>21294     <span class="keywordflow">return</span> 1;
<a name="l21295"></a>21295 
<a name="l21296"></a>21296   <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;mark)
<a name="l21297"></a>21297     <span class="keywordflow">return</span> 1;
<a name="l21298"></a>21298   per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;mark = 1;
<a name="l21299"></a>21299 
<a name="l21300"></a>21300   <span class="keywordflow">if</span> (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#aba78cb69f78a0a03f004d6a25cd2dfdf">dependencies</a> != NULL)
<a name="l21301"></a>21301     htab_traverse (per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#aba78cb69f78a0a03f004d6a25cd2dfdf">dependencies</a>, <a class="code" href="dwarf2read_8c.html#aaee49837d3c6eee27ea59aa29fc02a00">dwarf2_mark_helper</a>, NULL);
<a name="l21302"></a>21302 
<a name="l21303"></a>21303   <span class="keywordflow">return</span> 1;
<a name="l21304"></a>21304 }
<a name="l21305"></a>21305 
<a name="l21306"></a>21306 <span class="comment">/* Set the mark field in CU and in every other compilation unit in the</span>
<a name="l21307"></a>21307 <span class="comment">   cache that we must keep because we are keeping CU.  */</span>
<a name="l21308"></a>21308 
<a name="l21309"></a>21309 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21310"></a><a class="code" href="dwarf2read_8c.html#a273c1412d7b59e71060bf91b333f96e9">21310</a> <a class="code" href="dwarf2read_8c.html#a273c1412d7b59e71060bf91b333f96e9">dwarf2_mark</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__cu.html">dwarf2_cu</a> *<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>)
<a name="l21311"></a>21311 {
<a name="l21312"></a>21312   <span class="keywordflow">if</span> (cu-&gt;mark)
<a name="l21313"></a>21313     <span class="keywordflow">return</span>;
<a name="l21314"></a>21314   cu-&gt;mark = 1;
<a name="l21315"></a>21315   <span class="keywordflow">if</span> (cu-&gt;<a class="code" href="structdwarf2__cu.html#aba78cb69f78a0a03f004d6a25cd2dfdf">dependencies</a> != NULL)
<a name="l21316"></a>21316     htab_traverse (cu-&gt;<a class="code" href="structdwarf2__cu.html#aba78cb69f78a0a03f004d6a25cd2dfdf">dependencies</a>, <a class="code" href="dwarf2read_8c.html#aaee49837d3c6eee27ea59aa29fc02a00">dwarf2_mark_helper</a>, NULL);
<a name="l21317"></a>21317 }
<a name="l21318"></a>21318 
<a name="l21319"></a>21319 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21320"></a><a class="code" href="dwarf2read_8c.html#af10d4c7106a94f43a2be645d98da2ed8">21320</a> <a class="code" href="dwarf2read_8c.html#af10d4c7106a94f43a2be645d98da2ed8">dwarf2_clear_marks</a> (<span class="keyword">struct</span> <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu)
<a name="l21321"></a>21321 {
<a name="l21322"></a>21322   <span class="keywordflow">while</span> (per_cu)
<a name="l21323"></a>21323     {
<a name="l21324"></a>21324       per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;mark = 0;
<a name="l21325"></a>21325       per_cu = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a01fe629b8eddca793379bae7cfa5c937">cu</a>-&gt;<a class="code" href="structdwarf2__cu.html#ad4caa7a7978fa4ca2edef259dd77a8ef">read_in_chain</a>;
<a name="l21326"></a>21326     }
<a name="l21327"></a>21327 }
<a name="l21328"></a>21328 
<a name="l21329"></a>21329 <span class="comment">/* Trivial hash function for partial_die_info: the hash value of a DIE</span>
<a name="l21330"></a>21330 <span class="comment">   is its offset in .debug_info for this objfile.  */</span>
<a name="l21331"></a>21331 
<a name="l21332"></a>21332 <span class="keyword">static</span> hashval_t
<a name="l21333"></a><a class="code" href="dwarf2read_8c.html#a7206fb65e6b70f6294edf05a454c4182">21333</a> <a class="code" href="dwarf2read_8c.html#a7206fb65e6b70f6294edf05a454c4182">partial_die_hash</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item)
<a name="l21334"></a>21334 {
<a name="l21335"></a>21335   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *part_die = item;
<a name="l21336"></a>21336 
<a name="l21337"></a>21337   <span class="keywordflow">return</span> part_die-&gt;<a class="code" href="structpartial__die__info.html#a5db48cad0baeb15b63822fdaa0136c04">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l21338"></a>21338 }
<a name="l21339"></a>21339 
<a name="l21340"></a>21340 <span class="comment">/* Trivial comparison function for partial_die_info structures: two DIEs</span>
<a name="l21341"></a>21341 <span class="comment">   are equal if they have the same offset.  */</span>
<a name="l21342"></a>21342 
<a name="l21343"></a>21343 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l21344"></a><a class="code" href="dwarf2read_8c.html#a0e8a120392cd0ef1f19e1eb86c7b43e5">21344</a> <a class="code" href="dwarf2read_8c.html#a0e8a120392cd0ef1f19e1eb86c7b43e5">partial_die_eq</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item_lhs, <span class="keyword">const</span> <span class="keywordtype">void</span> *item_rhs)
<a name="l21345"></a>21345 {
<a name="l21346"></a>21346   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *part_die_lhs = item_lhs;
<a name="l21347"></a>21347   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structpartial__die__info.html">partial_die_info</a> *part_die_rhs = item_rhs;
<a name="l21348"></a>21348 
<a name="l21349"></a>21349   <span class="keywordflow">return</span> part_die_lhs-&gt;<a class="code" href="structpartial__die__info.html#a5db48cad0baeb15b63822fdaa0136c04">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a> == part_die_rhs-&gt;<a class="code" href="structpartial__die__info.html#a5db48cad0baeb15b63822fdaa0136c04">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l21350"></a>21350 }
<a name="l21351"></a>21351 
<a name="l21352"></a><a class="code" href="dwarf2read_8c.html#a0b24337d6ae1f3e02a894bc2112be559">21352</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcmd__list__element.html">cmd_list_element</a> *<a class="code" href="dwarf2read_8c.html#a0b24337d6ae1f3e02a894bc2112be559">set_dwarf2_cmdlist</a>;
<a name="l21353"></a><a class="code" href="dwarf2read_8c.html#a6c253b247df381b8bcfe57824f55f8b0">21353</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcmd__list__element.html">cmd_list_element</a> *<a class="code" href="dwarf2read_8c.html#a6c253b247df381b8bcfe57824f55f8b0">show_dwarf2_cmdlist</a>;
<a name="l21354"></a>21354 
<a name="l21355"></a>21355 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21356"></a><a class="code" href="dwarf2read_8c.html#af7a3da8ef93e1351824eb72c3ececd99">21356</a> <a class="code" href="dwarf2read_8c.html#af7a3da8ef93e1351824eb72c3ececd99">set_dwarf2_cmd</a> (<span class="keywordtype">char</span> *args, <span class="keywordtype">int</span> from_tty)
<a name="l21357"></a>21357 {
<a name="l21358"></a>21358   <a class="code" href="cli-decode_8c.html#a2ae762f5189f3597666852868defc038">help_list</a> (set_dwarf2_cmdlist, <span class="stringliteral">&quot;maintenance set dwarf2 &quot;</span>, -1, <a class="code" href="main_8c.html#a41a2b997ba5454df787d61f051dd918c">gdb_stdout</a>);
<a name="l21359"></a>21359 }
<a name="l21360"></a>21360 
<a name="l21361"></a>21361 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21362"></a><a class="code" href="dwarf2read_8c.html#af786d765da20bc998403198a33d0b0bc">21362</a> <a class="code" href="dwarf2read_8c.html#af786d765da20bc998403198a33d0b0bc">show_dwarf2_cmd</a> (<span class="keywordtype">char</span> *args, <span class="keywordtype">int</span> from_tty)
<a name="l21363"></a>21363 {
<a name="l21364"></a>21364   <a class="code" href="cli-setshow_8c.html#acad906a9e078be9cde70874ab62b1b1e">cmd_show_list</a> (show_dwarf2_cmdlist, from_tty, <span class="stringliteral">&quot;&quot;</span>);
<a name="l21365"></a>21365 }
<a name="l21366"></a>21366 
<a name="l21367"></a>21367 <span class="comment">/* Free data associated with OBJFILE, if necessary.  */</span>
<a name="l21368"></a>21368 
<a name="l21369"></a>21369 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21370"></a><a class="code" href="dwarf2read_8c.html#a95396f8ae0015d3e5a77a6822055aa45">21370</a> <a class="code" href="dwarf2read_8c.html#a95396f8ae0015d3e5a77a6822055aa45">dwarf2_per_objfile_free</a> (<span class="keyword">struct</span> objfile *objfile, <span class="keywordtype">void</span> *d)
<a name="l21371"></a>21371 {
<a name="l21372"></a>21372   <span class="keyword">struct </span>dwarf2_per_objfile *data = d;
<a name="l21373"></a>21373   <span class="keywordtype">int</span> ix;
<a name="l21374"></a>21374 
<a name="l21375"></a>21375   <span class="comment">/* Make sure we don&#39;t accidentally use dwarf2_per_objfile while</span>
<a name="l21376"></a>21376 <span class="comment">     cleaning up.  */</span>
<a name="l21377"></a>21377   dwarf2_per_objfile = NULL;
<a name="l21378"></a>21378 
<a name="l21379"></a>21379   <span class="keywordflow">for</span> (ix = 0; ix &lt; data-&gt;n_comp_units; ++ix)
<a name="l21380"></a>21380    <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (dwarf2_per_cu_ptr, data-&gt;all_comp_units[ix]-&gt;imported_symtabs);
<a name="l21381"></a>21381 
<a name="l21382"></a>21382   <span class="keywordflow">for</span> (ix = 0; ix &lt; data-&gt;n_type_units; ++ix)
<a name="l21383"></a>21383     <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (dwarf2_per_cu_ptr,
<a name="l21384"></a>21384               data-&gt;all_type_units[ix]-&gt;per_cu.imported_symtabs);
<a name="l21385"></a>21385   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (data-&gt;all_type_units);
<a name="l21386"></a>21386 
<a name="l21387"></a>21387   <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>, data-&gt;types);
<a name="l21388"></a>21388 
<a name="l21389"></a>21389   <span class="keywordflow">if</span> (data-&gt;<a class="code" href="structdwarf2__per__objfile.html#a647f8cdf79433f5d61ed1380e038757e">dwo_files</a>)
<a name="l21390"></a>21390     <a class="code" href="dwarf2read_8c.html#a0099c774dedaf3ab2fd3a5393ef2021d">free_dwo_files</a> (data-&gt;<a class="code" href="structdwarf2__per__objfile.html#a647f8cdf79433f5d61ed1380e038757e">dwo_files</a>, objfile);
<a name="l21391"></a>21391   <span class="keywordflow">if</span> (data-&gt;<a class="code" href="structdwarf2__per__objfile.html#ad0c5cd80616059507d792e8648026317">dwp_file</a>)
<a name="l21392"></a>21392     <a class="code" href="gdb__bfd_8c.html#a1027b59a8494f937b5760901040dc125">gdb_bfd_unref</a> (data-&gt;<a class="code" href="structdwarf2__per__objfile.html#ad0c5cd80616059507d792e8648026317">dwp_file</a>-&gt;<a class="code" href="structdwp__file.html#adaac28c08d06f0daf3633e997b0abdb1">dbfd</a>);
<a name="l21393"></a>21393 
<a name="l21394"></a>21394   <span class="keywordflow">if</span> (data-&gt;<a class="code" href="structdwarf2__per__objfile.html#ad4eb71f5b2a05e7cb7426df5a13cbb50">dwz_file</a> &amp;&amp; data-&gt;<a class="code" href="structdwarf2__per__objfile.html#ad4eb71f5b2a05e7cb7426df5a13cbb50">dwz_file</a>-&gt;<a class="code" href="structdwz__file.html#a9fc9bf241da902e55d1a4ddbaa8141eb">dwz_bfd</a>)
<a name="l21395"></a>21395     <a class="code" href="gdb__bfd_8c.html#a1027b59a8494f937b5760901040dc125">gdb_bfd_unref</a> (data-&gt;<a class="code" href="structdwarf2__per__objfile.html#ad4eb71f5b2a05e7cb7426df5a13cbb50">dwz_file</a>-&gt;<a class="code" href="structdwz__file.html#a9fc9bf241da902e55d1a4ddbaa8141eb">dwz_bfd</a>);
<a name="l21396"></a>21396 }
<a name="l21397"></a>21397 
<a name="l21398"></a>21398 
<a name="l21399"></a>21399 <span class="comment">/* The &quot;save gdb-index&quot; command.  */</span>
<a name="l21400"></a>21400 
<a name="l21401"></a>21401 <span class="comment">/* The contents of the hash table we create when building the string</span>
<a name="l21402"></a>21402 <span class="comment">   table.  */</span>
<a name="l21403"></a><a class="code" href="structstrtab__entry.html">21403</a> <span class="keyword">struct </span><a class="code" href="structstrtab__entry.html">strtab_entry</a>
<a name="l21404"></a>21404 {
<a name="l21405"></a><a class="code" href="structstrtab__entry.html#a93def4137f70f738ab5de7ecf9ae3af1">21405</a>   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> <a class="code" href="structstrtab__entry.html#a93def4137f70f738ab5de7ecf9ae3af1">offset</a>;
<a name="l21406"></a><a class="code" href="structstrtab__entry.html#a31977797497cdf999aa9a7e2ceee96ea">21406</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structstrtab__entry.html#a31977797497cdf999aa9a7e2ceee96ea">str</a>;
<a name="l21407"></a>21407 };
<a name="l21408"></a>21408 
<a name="l21409"></a>21409 <span class="comment">/* Hash function for a strtab_entry.</span>
<a name="l21410"></a>21410 <span class="comment"></span>
<a name="l21411"></a>21411 <span class="comment">   Function is used only during write_hash_table so no index format backward</span>
<a name="l21412"></a>21412 <span class="comment">   compatibility is needed.  */</span>
<a name="l21413"></a>21413 
<a name="l21414"></a>21414 <span class="keyword">static</span> hashval_t
<a name="l21415"></a><a class="code" href="dwarf2read_8c.html#abb3ac1339f57a6a71069a23700137841">21415</a> <a class="code" href="dwarf2read_8c.html#abb3ac1339f57a6a71069a23700137841">hash_strtab_entry</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *e)
<a name="l21416"></a>21416 {
<a name="l21417"></a>21417   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structstrtab__entry.html">strtab_entry</a> *entry = e;
<a name="l21418"></a>21418   <span class="keywordflow">return</span> <a class="code" href="dwarf2read_8c.html#afe7f6f3e89a71fc6de454dbdbc4dd7a2">mapped_index_string_hash</a> (INT_MAX, entry-&gt;<a class="code" href="structstrtab__entry.html#a31977797497cdf999aa9a7e2ceee96ea">str</a>);
<a name="l21419"></a>21419 }
<a name="l21420"></a>21420 
<a name="l21421"></a>21421 <span class="comment">/* Equality function for a strtab_entry.  */</span>
<a name="l21422"></a>21422 
<a name="l21423"></a>21423 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l21424"></a><a class="code" href="dwarf2read_8c.html#acd796c580369fa487906df9e2c51c2e0">21424</a> <a class="code" href="dwarf2read_8c.html#acd796c580369fa487906df9e2c51c2e0">eq_strtab_entry</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)
<a name="l21425"></a>21425 {
<a name="l21426"></a>21426   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structstrtab__entry.html">strtab_entry</a> *ea = a;
<a name="l21427"></a>21427   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structstrtab__entry.html">strtab_entry</a> *eb = b;
<a name="l21428"></a>21428   <span class="keywordflow">return</span> !strcmp (ea-&gt;<a class="code" href="structstrtab__entry.html#a31977797497cdf999aa9a7e2ceee96ea">str</a>, eb-&gt;<a class="code" href="structstrtab__entry.html#a31977797497cdf999aa9a7e2ceee96ea">str</a>);
<a name="l21429"></a>21429 }
<a name="l21430"></a>21430 
<a name="l21431"></a>21431 <span class="comment">/* Create a strtab_entry hash table.  */</span>
<a name="l21432"></a>21432 
<a name="l21433"></a>21433 <span class="keyword">static</span> htab_t
<a name="l21434"></a><a class="code" href="dwarf2read_8c.html#a71365fe4e9cdb17f606f7b2dafc8f335">21434</a> <a class="code" href="dwarf2read_8c.html#a71365fe4e9cdb17f606f7b2dafc8f335">create_strtab</a> (<span class="keywordtype">void</span>)
<a name="l21435"></a>21435 {
<a name="l21436"></a>21436   <span class="keywordflow">return</span> htab_create_alloc (100, <a class="code" href="dwarf2read_8c.html#abb3ac1339f57a6a71069a23700137841">hash_strtab_entry</a>, <a class="code" href="dwarf2read_8c.html#acd796c580369fa487906df9e2c51c2e0">eq_strtab_entry</a>,
<a name="l21437"></a>21437                             <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a>, <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>);
<a name="l21438"></a>21438 }
<a name="l21439"></a>21439 
<a name="l21440"></a>21440 <span class="comment">/* Add a string to the constant pool.  Return the string&#39;s offset in</span>
<a name="l21441"></a>21441 <span class="comment">   host order.  */</span>
<a name="l21442"></a>21442 
<a name="l21443"></a>21443 <span class="keyword">static</span> <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>
<a name="l21444"></a><a class="code" href="dwarf2read_8c.html#a383041c5a2214420988bb66c89c902bb">21444</a> <a class="code" href="dwarf2read_8c.html#a383041c5a2214420988bb66c89c902bb">add_string</a> (htab_t table, <span class="keyword">struct</span> obstack *cpool, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structstrtab__entry.html#a31977797497cdf999aa9a7e2ceee96ea">str</a>)
<a name="l21445"></a>21445 {
<a name="l21446"></a>21446   <span class="keywordtype">void</span> **slot;
<a name="l21447"></a>21447   <span class="keyword">struct </span><a class="code" href="structstrtab__entry.html">strtab_entry</a> entry;
<a name="l21448"></a>21448   <span class="keyword">struct </span><a class="code" href="structstrtab__entry.html">strtab_entry</a> *result;
<a name="l21449"></a>21449 
<a name="l21450"></a>21450   entry.<a class="code" href="structstrtab__entry.html#a31977797497cdf999aa9a7e2ceee96ea">str</a> = <a class="code" href="structstrtab__entry.html#a31977797497cdf999aa9a7e2ceee96ea">str</a>;
<a name="l21451"></a>21451   slot = htab_find_slot (table, &amp;entry, INSERT);
<a name="l21452"></a>21452   <span class="keywordflow">if</span> (*slot)
<a name="l21453"></a>21453     result = *slot;
<a name="l21454"></a>21454   <span class="keywordflow">else</span>
<a name="l21455"></a>21455     {
<a name="l21456"></a>21456       result = XNEW (<span class="keyword">struct</span> <a class="code" href="structstrtab__entry.html">strtab_entry</a>);
<a name="l21457"></a>21457       result-&gt;<a class="code" href="structstrtab__entry.html#a93def4137f70f738ab5de7ecf9ae3af1">offset</a> = obstack_object_size (cpool);
<a name="l21458"></a>21458       result-&gt;<a class="code" href="structstrtab__entry.html#a31977797497cdf999aa9a7e2ceee96ea">str</a> = <a class="code" href="structstrtab__entry.html#a31977797497cdf999aa9a7e2ceee96ea">str</a>;
<a name="l21459"></a>21459       <a class="code" href="gdb__obstack_8h.html#a33a401214fbeb33af25499e39697e2b9">obstack_grow_str0</a> (cpool, str);
<a name="l21460"></a>21460       *slot = result;
<a name="l21461"></a>21461     }
<a name="l21462"></a>21462   <span class="keywordflow">return</span> result-&gt;<a class="code" href="structstrtab__entry.html#a93def4137f70f738ab5de7ecf9ae3af1">offset</a>;
<a name="l21463"></a>21463 }
<a name="l21464"></a>21464 
<a name="l21465"></a>21465 <span class="comment">/* An entry in the symbol table.  */</span>
<a name="l21466"></a><a class="code" href="structsymtab__index__entry.html">21466</a> <span class="keyword">struct </span><a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a>
<a name="l21467"></a>21467 {
<a name="l21468"></a>21468   <span class="comment">/* The name of the symbol.  */</span>
<a name="l21469"></a><a class="code" href="structsymtab__index__entry.html#a6fa1f3ff1236c409f955d9ed2c9dfa50">21469</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structsymtab__index__entry.html#a6fa1f3ff1236c409f955d9ed2c9dfa50">name</a>;
<a name="l21470"></a>21470   <span class="comment">/* The offset of the name in the constant pool.  */</span>
<a name="l21471"></a><a class="code" href="structsymtab__index__entry.html#a0397156989a50a5a80c7c875db9eec0a">21471</a>   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> <a class="code" href="structsymtab__index__entry.html#a0397156989a50a5a80c7c875db9eec0a">index_offset</a>;
<a name="l21472"></a>21472   <span class="comment">/* A sorted vector of the indices of all the CUs that hold an object</span>
<a name="l21473"></a>21473 <span class="comment">     of this name.  */</span>
<a name="l21474"></a>21474   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>) *cu_indices;
<a name="l21475"></a>21475 };
<a name="l21476"></a>21476 
<a name="l21477"></a>21477 <span class="comment">/* The symbol table.  This is a power-of-2-sized hash table.  */</span>
<a name="l21478"></a><a class="code" href="structmapped__symtab.html">21478</a> <span class="keyword">struct </span><a class="code" href="structmapped__symtab.html">mapped_symtab</a>
<a name="l21479"></a>21479 {
<a name="l21480"></a><a class="code" href="structmapped__symtab.html#aad98e844959bd45e0eb0d4fb4fa14597">21480</a>   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> <a class="code" href="structmapped__symtab.html#aad98e844959bd45e0eb0d4fb4fa14597">n_elements</a>;
<a name="l21481"></a><a class="code" href="structmapped__symtab.html#abaa4e62c0b247b89c27467fab5c64161">21481</a>   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> <a class="code" href="structmapped__symtab.html#abaa4e62c0b247b89c27467fab5c64161">size</a>;
<a name="l21482"></a><a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">21482</a>   <span class="keyword">struct </span><a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a> **<a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">data</a>;
<a name="l21483"></a>21483 };
<a name="l21484"></a>21484 
<a name="l21485"></a>21485 <span class="comment">/* Hash function for a symtab_index_entry.  */</span>
<a name="l21486"></a>21486 
<a name="l21487"></a>21487 <span class="keyword">static</span> hashval_t
<a name="l21488"></a><a class="code" href="dwarf2read_8c.html#ad12224ef04687a412e9e2698ed536be0">21488</a> <a class="code" href="dwarf2read_8c.html#ad12224ef04687a412e9e2698ed536be0">hash_symtab_entry</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *e)
<a name="l21489"></a>21489 {
<a name="l21490"></a>21490   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a> *entry = e;
<a name="l21491"></a>21491   <span class="keywordflow">return</span> iterative_hash (<a class="code" href="vec_8h.html#a99adc2006a668acc675e3758d9375ad5">VEC_address</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, entry-&gt;cu_indices),
<a name="l21492"></a>21492                          sizeof (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>) * <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>,
<a name="l21493"></a>21493                                                             entry-&gt;cu_indices),
<a name="l21494"></a>21494                          0);
<a name="l21495"></a>21495 }
<a name="l21496"></a>21496 
<a name="l21497"></a>21497 <span class="comment">/* Equality function for a symtab_index_entry.  */</span>
<a name="l21498"></a>21498 
<a name="l21499"></a>21499 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l21500"></a><a class="code" href="dwarf2read_8c.html#a5840056d267df04185522f714daf8c66">21500</a> <a class="code" href="dwarf2read_8c.html#a5840056d267df04185522f714daf8c66">eq_symtab_entry</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)
<a name="l21501"></a>21501 {
<a name="l21502"></a>21502   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a> *ea = a;
<a name="l21503"></a>21503   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a> *eb = b;
<a name="l21504"></a>21504   <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a> = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, ea-&gt;cu_indices);
<a name="l21505"></a>21505   <span class="keywordflow">if</span> (len != <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, eb-&gt;cu_indices))
<a name="l21506"></a>21506     <span class="keywordflow">return</span> 0;
<a name="l21507"></a>21507   <span class="keywordflow">return</span> !<a class="code" href="gdb__string_8h.html#a65c3e6b23d6855c86acaf147853c82cc">memcmp</a> (<a class="code" href="vec_8h.html#a99adc2006a668acc675e3758d9375ad5">VEC_address</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, ea-&gt;cu_indices),
<a name="l21508"></a>21508                   <a class="code" href="vec_8h.html#a99adc2006a668acc675e3758d9375ad5">VEC_address</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, eb-&gt;cu_indices),
<a name="l21509"></a>21509                   sizeof (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>) * len);
<a name="l21510"></a>21510 }
<a name="l21511"></a>21511 
<a name="l21512"></a>21512 <span class="comment">/* Destroy a symtab_index_entry.  */</span>
<a name="l21513"></a>21513 
<a name="l21514"></a>21514 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21515"></a><a class="code" href="dwarf2read_8c.html#a36df0214d143a38f37212c8992d4514a">21515</a> <a class="code" href="dwarf2read_8c.html#a36df0214d143a38f37212c8992d4514a">delete_symtab_entry</a> (<span class="keywordtype">void</span> *p)
<a name="l21516"></a>21516 {
<a name="l21517"></a>21517   <span class="keyword">struct </span><a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a> *entry = p;
<a name="l21518"></a>21518   <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, entry-&gt;cu_indices);
<a name="l21519"></a>21519   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (entry);
<a name="l21520"></a>21520 }
<a name="l21521"></a>21521 
<a name="l21522"></a>21522 <span class="comment">/* Create a hash table holding symtab_index_entry objects.  */</span>
<a name="l21523"></a>21523 
<a name="l21524"></a>21524 <span class="keyword">static</span> htab_t
<a name="l21525"></a><a class="code" href="dwarf2read_8c.html#ab21e5d3578c9a9ef41624b5e50d5791e">21525</a> <a class="code" href="dwarf2read_8c.html#ab21e5d3578c9a9ef41624b5e50d5791e">create_symbol_hash_table</a> (<span class="keywordtype">void</span>)
<a name="l21526"></a>21526 {
<a name="l21527"></a>21527   <span class="keywordflow">return</span> htab_create_alloc (100, <a class="code" href="dwarf2read_8c.html#ad12224ef04687a412e9e2698ed536be0">hash_symtab_entry</a>, <a class="code" href="dwarf2read_8c.html#a5840056d267df04185522f714daf8c66">eq_symtab_entry</a>,
<a name="l21528"></a>21528                             <a class="code" href="dwarf2read_8c.html#a36df0214d143a38f37212c8992d4514a">delete_symtab_entry</a>, <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a>, <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>);
<a name="l21529"></a>21529 }
<a name="l21530"></a>21530 
<a name="l21531"></a>21531 <span class="comment">/* Create a new mapped symtab object.  */</span>
<a name="l21532"></a>21532 
<a name="l21533"></a>21533 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structmapped__symtab.html">mapped_symtab</a> *
<a name="l21534"></a><a class="code" href="dwarf2read_8c.html#a28eec9306ccfc88e022de65ab9bff61b">21534</a> <a class="code" href="dwarf2read_8c.html#a28eec9306ccfc88e022de65ab9bff61b">create_mapped_symtab</a> (<span class="keywordtype">void</span>)
<a name="l21535"></a>21535 {
<a name="l21536"></a>21536   <span class="keyword">struct </span><a class="code" href="structmapped__symtab.html">mapped_symtab</a> *<a class="code" href="structsymtab.html">symtab</a> = XNEW (<span class="keyword">struct</span> <a class="code" href="structmapped__symtab.html">mapped_symtab</a>);
<a name="l21537"></a>21537   symtab-&gt;<a class="code" href="structmapped__symtab.html#aad98e844959bd45e0eb0d4fb4fa14597">n_elements</a> = 0;
<a name="l21538"></a>21538   symtab-&gt;<a class="code" href="structmapped__symtab.html#abaa4e62c0b247b89c27467fab5c64161">size</a> = 1024;
<a name="l21539"></a>21539   symtab-&gt;<a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">data</a> = XCNEWVEC (<span class="keyword">struct</span> <a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a> *, symtab-&gt;<a class="code" href="structmapped__symtab.html#abaa4e62c0b247b89c27467fab5c64161">size</a>);
<a name="l21540"></a>21540   <span class="keywordflow">return</span> symtab;
<a name="l21541"></a>21541 }
<a name="l21542"></a>21542 
<a name="l21543"></a>21543 <span class="comment">/* Destroy a mapped_symtab.  */</span>
<a name="l21544"></a>21544 
<a name="l21545"></a>21545 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21546"></a><a class="code" href="dwarf2read_8c.html#a1ab7924ea5a66c31266d3980df74bc28">21546</a> <a class="code" href="dwarf2read_8c.html#a1ab7924ea5a66c31266d3980df74bc28">cleanup_mapped_symtab</a> (<span class="keywordtype">void</span> *p)
<a name="l21547"></a>21547 {
<a name="l21548"></a>21548   <span class="keyword">struct </span><a class="code" href="structmapped__symtab.html">mapped_symtab</a> *<a class="code" href="structsymtab.html">symtab</a> = p;
<a name="l21549"></a>21549   <span class="comment">/* The contents of the array are freed when the other hash table is</span>
<a name="l21550"></a>21550 <span class="comment">     destroyed.  */</span>
<a name="l21551"></a>21551   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (symtab-&gt;<a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">data</a>);
<a name="l21552"></a>21552   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (symtab);
<a name="l21553"></a>21553 }
<a name="l21554"></a>21554 
<a name="l21555"></a>21555 <span class="comment">/* Find a slot in SYMTAB for the symbol NAME.  Returns a pointer to</span>
<a name="l21556"></a>21556 <span class="comment">   the slot.</span>
<a name="l21557"></a>21557 <span class="comment">   </span>
<a name="l21558"></a>21558 <span class="comment">   Function is used only during write_hash_table so no index format backward</span>
<a name="l21559"></a>21559 <span class="comment">   compatibility is needed.  */</span>
<a name="l21560"></a>21560 
<a name="l21561"></a>21561 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a> **
<a name="l21562"></a><a class="code" href="dwarf2read_8c.html#a12b2a11215be4fcc2d8fb889ece73851">21562</a> <a class="code" href="dwarf2read_8c.html#a12b2a11215be4fcc2d8fb889ece73851">find_slot</a> (<span class="keyword">struct</span> <a class="code" href="structmapped__symtab.html">mapped_symtab</a> *<a class="code" href="structsymtab.html">symtab</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l21563"></a>21563 {
<a name="l21564"></a>21564   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> index, step, <a class="code" href="bcache_8c.html#a680b4550cc69a0827af4a7169fe3c372">hash</a> = <a class="code" href="dwarf2read_8c.html#afe7f6f3e89a71fc6de454dbdbc4dd7a2">mapped_index_string_hash</a> (INT_MAX, name);
<a name="l21565"></a>21565 
<a name="l21566"></a>21566   index = hash &amp; (symtab-&gt;<a class="code" href="structmapped__symtab.html#abaa4e62c0b247b89c27467fab5c64161">size</a> - 1);
<a name="l21567"></a>21567   step = ((hash * 17) &amp; (symtab-&gt;<a class="code" href="structmapped__symtab.html#abaa4e62c0b247b89c27467fab5c64161">size</a> - 1)) | 1;
<a name="l21568"></a>21568 
<a name="l21569"></a>21569   <span class="keywordflow">for</span> (;;)
<a name="l21570"></a>21570     {
<a name="l21571"></a>21571       <span class="keywordflow">if</span> (!symtab-&gt;<a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">data</a>[index] || !strcmp (name, symtab-&gt;<a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">data</a>[index]-&gt;<a class="code" href="structsymtab__index__entry.html#a6fa1f3ff1236c409f955d9ed2c9dfa50">name</a>))
<a name="l21572"></a>21572         <span class="keywordflow">return</span> &amp;symtab-&gt;<a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">data</a>[index];
<a name="l21573"></a>21573       index = (index + step) &amp; (symtab-&gt;<a class="code" href="structmapped__symtab.html#abaa4e62c0b247b89c27467fab5c64161">size</a> - 1);
<a name="l21574"></a>21574     }
<a name="l21575"></a>21575 }
<a name="l21576"></a>21576 
<a name="l21577"></a>21577 <span class="comment">/* Expand SYMTAB&#39;s hash table.  */</span>
<a name="l21578"></a>21578 
<a name="l21579"></a>21579 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21580"></a><a class="code" href="dwarf2read_8c.html#ac4f6e702e59a81957f27522ec7b54531">21580</a> <a class="code" href="dwarf2read_8c.html#ac4f6e702e59a81957f27522ec7b54531">hash_expand</a> (<span class="keyword">struct</span> <a class="code" href="structmapped__symtab.html">mapped_symtab</a> *<a class="code" href="structsymtab.html">symtab</a>)
<a name="l21581"></a>21581 {
<a name="l21582"></a>21582   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> old_size = symtab-&gt;<a class="code" href="structmapped__symtab.html#abaa4e62c0b247b89c27467fab5c64161">size</a>;
<a name="l21583"></a>21583   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> i;
<a name="l21584"></a>21584   <span class="keyword">struct </span><a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a> **old_entries = symtab-&gt;<a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">data</a>;
<a name="l21585"></a>21585 
<a name="l21586"></a>21586   symtab-&gt;<a class="code" href="structmapped__symtab.html#abaa4e62c0b247b89c27467fab5c64161">size</a> *= 2;
<a name="l21587"></a>21587   symtab-&gt;<a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">data</a> = XCNEWVEC (<span class="keyword">struct</span> <a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a> *, symtab-&gt;<a class="code" href="structmapped__symtab.html#abaa4e62c0b247b89c27467fab5c64161">size</a>);
<a name="l21588"></a>21588 
<a name="l21589"></a>21589   <span class="keywordflow">for</span> (i = 0; i &lt; old_size; ++i)
<a name="l21590"></a>21590     {
<a name="l21591"></a>21591       <span class="keywordflow">if</span> (old_entries[i])
<a name="l21592"></a>21592         {
<a name="l21593"></a>21593           <span class="keyword">struct </span><a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a> **slot = <a class="code" href="dwarf2read_8c.html#a12b2a11215be4fcc2d8fb889ece73851">find_slot</a> (symtab,
<a name="l21594"></a>21594                                                         old_entries[i]-&gt;name);
<a name="l21595"></a>21595           *slot = old_entries[i];
<a name="l21596"></a>21596         }
<a name="l21597"></a>21597     }
<a name="l21598"></a>21598 
<a name="l21599"></a>21599   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (old_entries);
<a name="l21600"></a>21600 }
<a name="l21601"></a>21601 
<a name="l21602"></a>21602 <span class="comment">/* Add an entry to SYMTAB.  NAME is the name of the symbol.</span>
<a name="l21603"></a>21603 <span class="comment">   CU_INDEX is the index of the CU in which the symbol appears.</span>
<a name="l21604"></a>21604 <span class="comment">   IS_STATIC is one if the symbol is static, otherwise zero (global).  */</span>
<a name="l21605"></a>21605 
<a name="l21606"></a>21606 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21607"></a><a class="code" href="dwarf2read_8c.html#af1182c3a512b0b3cf061b1c6b4fc8857">21607</a> <a class="code" href="dwarf2read_8c.html#af1182c3a512b0b3cf061b1c6b4fc8857">add_index_entry</a> (<span class="keyword">struct</span> <a class="code" href="structmapped__symtab.html">mapped_symtab</a> *<a class="code" href="structsymtab.html">symtab</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l21608"></a>21608                  <span class="keywordtype">int</span> is_static, gdb_index_symbol_kind kind,
<a name="l21609"></a>21609                  <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> cu_index)
<a name="l21610"></a>21610 {
<a name="l21611"></a>21611   <span class="keyword">struct </span><a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a> **slot;
<a name="l21612"></a>21612   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> cu_index_and_attrs;
<a name="l21613"></a>21613 
<a name="l21614"></a>21614   ++symtab-&gt;<a class="code" href="structmapped__symtab.html#aad98e844959bd45e0eb0d4fb4fa14597">n_elements</a>;
<a name="l21615"></a>21615   <span class="keywordflow">if</span> (4 * symtab-&gt;<a class="code" href="structmapped__symtab.html#aad98e844959bd45e0eb0d4fb4fa14597">n_elements</a> / 3 &gt;= symtab-&gt;<a class="code" href="structmapped__symtab.html#abaa4e62c0b247b89c27467fab5c64161">size</a>)
<a name="l21616"></a>21616     <a class="code" href="dwarf2read_8c.html#ac4f6e702e59a81957f27522ec7b54531">hash_expand</a> (symtab);
<a name="l21617"></a>21617 
<a name="l21618"></a>21618   slot = <a class="code" href="dwarf2read_8c.html#a12b2a11215be4fcc2d8fb889ece73851">find_slot</a> (symtab, name);
<a name="l21619"></a>21619   <span class="keywordflow">if</span> (!*slot)
<a name="l21620"></a>21620     {
<a name="l21621"></a>21621       *slot = XNEW (<span class="keyword">struct</span> <a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a>);
<a name="l21622"></a>21622       (*slot)-&gt;name = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l21623"></a>21623       <span class="comment">/* index_offset is set later.  */</span>
<a name="l21624"></a>21624       (*slot)-&gt;cu_indices = NULL;
<a name="l21625"></a>21625     }
<a name="l21626"></a>21626 
<a name="l21627"></a>21627   cu_index_and_attrs = 0;
<a name="l21628"></a>21628   <a class="code" href="dwarf2read_8c.html#aa3a7f3b66e193362a9af82eaebd585d1">DW2_GDB_INDEX_CU_SET_VALUE</a> (cu_index_and_attrs, cu_index);
<a name="l21629"></a>21629   <a class="code" href="dwarf2read_8c.html#a26eda357e574747a050ac7622002f3cd">DW2_GDB_INDEX_SYMBOL_STATIC_SET_VALUE</a> (cu_index_and_attrs, is_static);
<a name="l21630"></a>21630   <a class="code" href="dwarf2read_8c.html#a601a861ff857c55b64e41f2c78684641">DW2_GDB_INDEX_SYMBOL_KIND_SET_VALUE</a> (cu_index_and_attrs, kind);
<a name="l21631"></a>21631 
<a name="l21632"></a>21632   <span class="comment">/* We don&#39;t want to record an index value twice as we want to avoid the</span>
<a name="l21633"></a>21633 <span class="comment">     duplication.</span>
<a name="l21634"></a>21634 <span class="comment">     We process all global symbols and then all static symbols</span>
<a name="l21635"></a>21635 <span class="comment">     (which would allow us to avoid the duplication by only having to check</span>
<a name="l21636"></a>21636 <span class="comment">     the last entry pushed), but a symbol could have multiple kinds in one CU.</span>
<a name="l21637"></a>21637 <span class="comment">     To keep things simple we don&#39;t worry about the duplication here and</span>
<a name="l21638"></a>21638 <span class="comment">     sort and uniqufy the list after we&#39;ve processed all symbols.  */</span>
<a name="l21639"></a>21639   <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, (*slot)-&gt;cu_indices, cu_index_and_attrs);
<a name="l21640"></a>21640 }
<a name="l21641"></a>21641 
<a name="l21642"></a>21642 <span class="comment">/* qsort helper routine for uniquify_cu_indices.  */</span>
<a name="l21643"></a>21643 
<a name="l21644"></a>21644 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l21645"></a><a class="code" href="dwarf2read_8c.html#a2f8724e5a4d1367b776661c8c4eca1ed">21645</a> <a class="code" href="dwarf2read_8c.html#a2f8724e5a4d1367b776661c8c4eca1ed">offset_type_compare</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *ap, <span class="keyword">const</span> <span class="keywordtype">void</span> *bp)
<a name="l21646"></a>21646 {
<a name="l21647"></a>21647   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> a = *(<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> *) ap;
<a name="l21648"></a>21648   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> b = *(<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> *) bp;
<a name="l21649"></a>21649 
<a name="l21650"></a>21650   <span class="keywordflow">return</span> (a &gt; b) - (b &gt; a);
<a name="l21651"></a>21651 }
<a name="l21652"></a>21652 
<a name="l21653"></a>21653 <span class="comment">/* Sort and remove duplicates of all symbols&#39; cu_indices lists.  */</span>
<a name="l21654"></a>21654 
<a name="l21655"></a>21655 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21656"></a><a class="code" href="dwarf2read_8c.html#afe6f61ccb238d225749074df42ba2140">21656</a> <a class="code" href="dwarf2read_8c.html#afe6f61ccb238d225749074df42ba2140">uniquify_cu_indices</a> (<span class="keyword">struct</span> <a class="code" href="structmapped__symtab.html">mapped_symtab</a> *<a class="code" href="structsymtab.html">symtab</a>)
<a name="l21657"></a>21657 {
<a name="l21658"></a>21658   <span class="keywordtype">int</span> i;
<a name="l21659"></a>21659 
<a name="l21660"></a>21660   <span class="keywordflow">for</span> (i = 0; i &lt; symtab-&gt;<a class="code" href="structmapped__symtab.html#abaa4e62c0b247b89c27467fab5c64161">size</a>; ++i)
<a name="l21661"></a>21661     {
<a name="l21662"></a>21662       <span class="keyword">struct </span><a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a> *entry = symtab-&gt;<a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">data</a>[i];
<a name="l21663"></a>21663 
<a name="l21664"></a>21664       <span class="keywordflow">if</span> (entry
<a name="l21665"></a>21665           &amp;&amp; entry-&gt;cu_indices != NULL)
<a name="l21666"></a>21666         {
<a name="l21667"></a>21667           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> next_to_insert, next_to_check;
<a name="l21668"></a>21668           <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> last_value;
<a name="l21669"></a>21669 
<a name="l21670"></a>21670           <a class="code" href="ada-exp_8c.html#a849e2297facde4d3c80dc4f45f8abbdb">qsort</a> (<a class="code" href="vec_8h.html#a99adc2006a668acc675e3758d9375ad5">VEC_address</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, entry-&gt;cu_indices),
<a name="l21671"></a>21671                  <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, entry-&gt;cu_indices),
<a name="l21672"></a>21672                  sizeof (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>), <a class="code" href="dwarf2read_8c.html#a2f8724e5a4d1367b776661c8c4eca1ed">offset_type_compare</a>);
<a name="l21673"></a>21673 
<a name="l21674"></a>21674           last_value = <a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, entry-&gt;cu_indices, 0);
<a name="l21675"></a>21675           next_to_insert = 1;
<a name="l21676"></a>21676           <span class="keywordflow">for</span> (next_to_check = 1;
<a name="l21677"></a>21677                next_to_check &lt; <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, entry-&gt;cu_indices);
<a name="l21678"></a>21678                ++next_to_check)
<a name="l21679"></a>21679             {
<a name="l21680"></a>21680               <span class="keywordflow">if</span> (<a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, entry-&gt;cu_indices, next_to_check)
<a name="l21681"></a>21681                   != last_value)
<a name="l21682"></a>21682                 {
<a name="l21683"></a>21683                   last_value = <a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, entry-&gt;cu_indices,
<a name="l21684"></a>21684                                           next_to_check);
<a name="l21685"></a>21685                   <a class="code" href="vec_8h.html#ae898349bda7814bcf92db36c0550a10f">VEC_replace</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, entry-&gt;cu_indices, next_to_insert,
<a name="l21686"></a>21686                                last_value);
<a name="l21687"></a>21687                   ++next_to_insert;
<a name="l21688"></a>21688                 }
<a name="l21689"></a>21689             }
<a name="l21690"></a>21690           <a class="code" href="vec_8h.html#a7b3dd1d44acb431cf333c2406e1c000d">VEC_truncate</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, entry-&gt;cu_indices, next_to_insert);
<a name="l21691"></a>21691         }
<a name="l21692"></a>21692     }
<a name="l21693"></a>21693 }
<a name="l21694"></a>21694 
<a name="l21695"></a>21695 <span class="comment">/* Add a vector of indices to the constant pool.  */</span>
<a name="l21696"></a>21696 
<a name="l21697"></a>21697 <span class="keyword">static</span> <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>
<a name="l21698"></a><a class="code" href="dwarf2read_8c.html#abdda2d1bb1e8ae51fdedb8201e7412f3">21698</a> <a class="code" href="dwarf2read_8c.html#abdda2d1bb1e8ae51fdedb8201e7412f3">add_indices_to_cpool</a> (htab_t symbol_hash_table, <span class="keyword">struct</span> obstack *cpool,
<a name="l21699"></a>21699                       <span class="keyword">struct</span> <a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a> *entry)
<a name="l21700"></a>21700 {
<a name="l21701"></a>21701   <span class="keywordtype">void</span> **slot;
<a name="l21702"></a>21702 
<a name="l21703"></a>21703   slot = htab_find_slot (symbol_hash_table, entry, INSERT);
<a name="l21704"></a>21704   <span class="keywordflow">if</span> (!*slot)
<a name="l21705"></a>21705     {
<a name="l21706"></a>21706       <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a> = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, entry-&gt;cu_indices);
<a name="l21707"></a>21707       <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> val = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (len);
<a name="l21708"></a>21708       <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> iter;
<a name="l21709"></a>21709       <span class="keywordtype">int</span> i;
<a name="l21710"></a>21710 
<a name="l21711"></a>21711       *slot = entry;
<a name="l21712"></a>21712       entry-&gt;<a class="code" href="structsymtab__index__entry.html#a0397156989a50a5a80c7c875db9eec0a">index_offset</a> = obstack_object_size (cpool);
<a name="l21713"></a>21713 
<a name="l21714"></a>21714       obstack_grow (cpool, &amp;val, <span class="keyword">sizeof</span> (val));
<a name="l21715"></a>21715       <span class="keywordflow">for</span> (i = 0;
<a name="l21716"></a>21716            <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>, entry-&gt;cu_indices, i, iter);
<a name="l21717"></a>21717            ++i)
<a name="l21718"></a>21718         {
<a name="l21719"></a>21719           val = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (iter);
<a name="l21720"></a>21720           obstack_grow (cpool, &amp;val, <span class="keyword">sizeof</span> (val));
<a name="l21721"></a>21721         }
<a name="l21722"></a>21722     }
<a name="l21723"></a>21723   <span class="keywordflow">else</span>
<a name="l21724"></a>21724     {
<a name="l21725"></a>21725       <span class="keyword">struct </span><a class="code" href="structsymtab__index__entry.html">symtab_index_entry</a> *old_entry = *slot;
<a name="l21726"></a>21726       entry-&gt;<a class="code" href="structsymtab__index__entry.html#a0397156989a50a5a80c7c875db9eec0a">index_offset</a> = old_entry-&gt;<a class="code" href="structsymtab__index__entry.html#a0397156989a50a5a80c7c875db9eec0a">index_offset</a>;
<a name="l21727"></a>21727       entry = old_entry;
<a name="l21728"></a>21728     }
<a name="l21729"></a>21729   <span class="keywordflow">return</span> entry-&gt;<a class="code" href="structsymtab__index__entry.html#a0397156989a50a5a80c7c875db9eec0a">index_offset</a>;
<a name="l21730"></a>21730 }
<a name="l21731"></a>21731 
<a name="l21732"></a>21732 <span class="comment">/* Write the mapped hash table SYMTAB to the obstack OUTPUT, with</span>
<a name="l21733"></a>21733 <span class="comment">   constant pool entries going into the obstack CPOOL.  */</span>
<a name="l21734"></a>21734 
<a name="l21735"></a>21735 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21736"></a><a class="code" href="dwarf2read_8c.html#a383d7fbf2fe0852a2b143f840650dd08">21736</a> <a class="code" href="dwarf2read_8c.html#a383d7fbf2fe0852a2b143f840650dd08">write_hash_table</a> (<span class="keyword">struct</span> <a class="code" href="structmapped__symtab.html">mapped_symtab</a> *<a class="code" href="structsymtab.html">symtab</a>,
<a name="l21737"></a>21737                   <span class="keyword">struct</span> obstack *output, <span class="keyword">struct</span> obstack *cpool)
<a name="l21738"></a>21738 {
<a name="l21739"></a>21739   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> i;
<a name="l21740"></a>21740   htab_t symbol_hash_table;
<a name="l21741"></a>21741   htab_t str_table;
<a name="l21742"></a>21742 
<a name="l21743"></a>21743   symbol_hash_table = <a class="code" href="dwarf2read_8c.html#ab21e5d3578c9a9ef41624b5e50d5791e">create_symbol_hash_table</a> ();
<a name="l21744"></a>21744   str_table = <a class="code" href="dwarf2read_8c.html#a71365fe4e9cdb17f606f7b2dafc8f335">create_strtab</a> ();
<a name="l21745"></a>21745 
<a name="l21746"></a>21746   <span class="comment">/* We add all the index vectors to the constant pool first, to</span>
<a name="l21747"></a>21747 <span class="comment">     ensure alignment is ok.  */</span>
<a name="l21748"></a>21748   <span class="keywordflow">for</span> (i = 0; i &lt; symtab-&gt;<a class="code" href="structmapped__symtab.html#abaa4e62c0b247b89c27467fab5c64161">size</a>; ++i)
<a name="l21749"></a>21749     {
<a name="l21750"></a>21750       <span class="keywordflow">if</span> (symtab-&gt;<a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">data</a>[i])
<a name="l21751"></a>21751         <a class="code" href="dwarf2read_8c.html#abdda2d1bb1e8ae51fdedb8201e7412f3">add_indices_to_cpool</a> (symbol_hash_table, cpool, symtab-&gt;<a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">data</a>[i]);
<a name="l21752"></a>21752     }
<a name="l21753"></a>21753 
<a name="l21754"></a>21754   <span class="comment">/* Now write out the hash table.  */</span>
<a name="l21755"></a>21755   <span class="keywordflow">for</span> (i = 0; i &lt; symtab-&gt;<a class="code" href="structmapped__symtab.html#abaa4e62c0b247b89c27467fab5c64161">size</a>; ++i)
<a name="l21756"></a>21756     {
<a name="l21757"></a>21757       <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> str_off, vec_off;
<a name="l21758"></a>21758 
<a name="l21759"></a>21759       <span class="keywordflow">if</span> (symtab-&gt;<a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">data</a>[i])
<a name="l21760"></a>21760         {
<a name="l21761"></a>21761           str_off = <a class="code" href="dwarf2read_8c.html#a383041c5a2214420988bb66c89c902bb">add_string</a> (str_table, cpool, symtab-&gt;<a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">data</a>[i]-&gt;<a class="code" href="structsymtab__index__entry.html#a6fa1f3ff1236c409f955d9ed2c9dfa50">name</a>);
<a name="l21762"></a>21762           vec_off = symtab-&gt;<a class="code" href="structmapped__symtab.html#ae26af072b372e4f14c37d7a202834de4">data</a>[i]-&gt;<a class="code" href="structsymtab__index__entry.html#a0397156989a50a5a80c7c875db9eec0a">index_offset</a>;
<a name="l21763"></a>21763         }
<a name="l21764"></a>21764       <span class="keywordflow">else</span>
<a name="l21765"></a>21765         {
<a name="l21766"></a>21766           <span class="comment">/* While 0 is a valid constant pool index, it is not valid</span>
<a name="l21767"></a>21767 <span class="comment">             to have 0 for both offsets.  */</span>
<a name="l21768"></a>21768           str_off = 0;
<a name="l21769"></a>21769           vec_off = 0;
<a name="l21770"></a>21770         }
<a name="l21771"></a>21771 
<a name="l21772"></a>21772       str_off = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (str_off);
<a name="l21773"></a>21773       vec_off = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (vec_off);
<a name="l21774"></a>21774 
<a name="l21775"></a>21775       obstack_grow (output, &amp;str_off, <span class="keyword">sizeof</span> (str_off));
<a name="l21776"></a>21776       obstack_grow (output, &amp;vec_off, <span class="keyword">sizeof</span> (vec_off));
<a name="l21777"></a>21777     }
<a name="l21778"></a>21778 
<a name="l21779"></a>21779   htab_delete (str_table);
<a name="l21780"></a>21780   htab_delete (symbol_hash_table);
<a name="l21781"></a>21781 }
<a name="l21782"></a>21782 
<a name="l21783"></a>21783 <span class="comment">/* Struct to map psymtab to CU index in the index file.  */</span>
<a name="l21784"></a><a class="code" href="structpsymtab__cu__index__map.html">21784</a> <span class="keyword">struct </span><a class="code" href="structpsymtab__cu__index__map.html">psymtab_cu_index_map</a>
<a name="l21785"></a>21785 {
<a name="l21786"></a><a class="code" href="structpsymtab__cu__index__map.html#a5894f16783cf71485a240f412dd181bc">21786</a>   <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *<a class="code" href="structpsymtab__cu__index__map.html#a5894f16783cf71485a240f412dd181bc">psymtab</a>;
<a name="l21787"></a><a class="code" href="structpsymtab__cu__index__map.html#a1138336df6054423ba2723751cb8ff65">21787</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structpsymtab__cu__index__map.html#a1138336df6054423ba2723751cb8ff65">cu_index</a>;
<a name="l21788"></a>21788 };
<a name="l21789"></a>21789 
<a name="l21790"></a>21790 <span class="keyword">static</span> hashval_t
<a name="l21791"></a><a class="code" href="dwarf2read_8c.html#a5f9ea395391a7daa77fdde1eeab962bf">21791</a> <a class="code" href="dwarf2read_8c.html#a5f9ea395391a7daa77fdde1eeab962bf">hash_psymtab_cu_index</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item)
<a name="l21792"></a>21792 {
<a name="l21793"></a>21793   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structpsymtab__cu__index__map.html">psymtab_cu_index_map</a> *map = item;
<a name="l21794"></a>21794 
<a name="l21795"></a>21795   <span class="keywordflow">return</span> htab_hash_pointer (map-&gt;<a class="code" href="structpsymtab__cu__index__map.html#a5894f16783cf71485a240f412dd181bc">psymtab</a>);
<a name="l21796"></a>21796 }
<a name="l21797"></a>21797 
<a name="l21798"></a>21798 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l21799"></a><a class="code" href="dwarf2read_8c.html#a53f5efec47f1f3e396e972c437105a6b">21799</a> <a class="code" href="dwarf2read_8c.html#a53f5efec47f1f3e396e972c437105a6b">eq_psymtab_cu_index</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *item_lhs, <span class="keyword">const</span> <span class="keywordtype">void</span> *item_rhs)
<a name="l21800"></a>21800 {
<a name="l21801"></a>21801   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structpsymtab__cu__index__map.html">psymtab_cu_index_map</a> *lhs = item_lhs;
<a name="l21802"></a>21802   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structpsymtab__cu__index__map.html">psymtab_cu_index_map</a> *rhs = item_rhs;
<a name="l21803"></a>21803 
<a name="l21804"></a>21804   <span class="keywordflow">return</span> lhs-&gt;<a class="code" href="structpsymtab__cu__index__map.html#a5894f16783cf71485a240f412dd181bc">psymtab</a> == rhs-&gt;<a class="code" href="structpsymtab__cu__index__map.html#a5894f16783cf71485a240f412dd181bc">psymtab</a>;
<a name="l21805"></a>21805 }
<a name="l21806"></a>21806 
<a name="l21807"></a>21807 <span class="comment">/* Helper struct for building the address table.  */</span>
<a name="l21808"></a><a class="code" href="structaddrmap__index__data.html">21808</a> <span class="keyword">struct </span><a class="code" href="structaddrmap__index__data.html">addrmap_index_data</a>
<a name="l21809"></a>21809 {
<a name="l21810"></a><a class="code" href="structaddrmap__index__data.html#a13e7efe62da3d2927de51d2f1956f694">21810</a>   <span class="keyword">struct </span>objfile *<a class="code" href="structaddrmap__index__data.html#a13e7efe62da3d2927de51d2f1956f694">objfile</a>;
<a name="l21811"></a><a class="code" href="structaddrmap__index__data.html#aca0cf830678931ae0b3c4f2a166fb7d6">21811</a>   <span class="keyword">struct </span>obstack *<a class="code" href="structaddrmap__index__data.html#aca0cf830678931ae0b3c4f2a166fb7d6">addr_obstack</a>;
<a name="l21812"></a><a class="code" href="structaddrmap__index__data.html#ade53dd9cfda83a8b3c3040619e235a80">21812</a>   htab_t <a class="code" href="structaddrmap__index__data.html#ade53dd9cfda83a8b3c3040619e235a80">cu_index_htab</a>;
<a name="l21813"></a>21813 
<a name="l21814"></a>21814   <span class="comment">/* Non-zero if the previous_* fields are valid.</span>
<a name="l21815"></a>21815 <span class="comment">     We can&#39;t write an entry until we see the next entry (since it is only then</span>
<a name="l21816"></a>21816 <span class="comment">     that we know the end of the entry).  */</span>
<a name="l21817"></a><a class="code" href="structaddrmap__index__data.html#abd3c55fbc423b5c3f2451e3f60c5faaf">21817</a>   <span class="keywordtype">int</span> <a class="code" href="structaddrmap__index__data.html#abd3c55fbc423b5c3f2451e3f60c5faaf">previous_valid</a>;
<a name="l21818"></a>21818   <span class="comment">/* Index of the CU in the table of all CUs in the index file.  */</span>
<a name="l21819"></a><a class="code" href="structaddrmap__index__data.html#ae9323d00cd76481e6f07d0a82211c01e">21819</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structaddrmap__index__data.html#ae9323d00cd76481e6f07d0a82211c01e">previous_cu_index</a>;
<a name="l21820"></a>21820   <span class="comment">/* Start address of the CU.  */</span>
<a name="l21821"></a><a class="code" href="structaddrmap__index__data.html#a8bf1559c8c9616f04ba998af0396687c">21821</a>   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structaddrmap__index__data.html#a8bf1559c8c9616f04ba998af0396687c">previous_cu_start</a>;
<a name="l21822"></a>21822 };
<a name="l21823"></a>21823 
<a name="l21824"></a>21824 <span class="comment">/* Write an address entry to OBSTACK.  */</span>
<a name="l21825"></a>21825 
<a name="l21826"></a>21826 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21827"></a><a class="code" href="dwarf2read_8c.html#a50fb8e72ca00e7659b6169b8615c82e3">21827</a> <a class="code" href="dwarf2read_8c.html#a50fb8e72ca00e7659b6169b8615c82e3">add_address_entry</a> (<span class="keyword">struct</span> objfile *objfile, <span class="keyword">struct</span> obstack *obstack,
<a name="l21828"></a>21828                    <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> end, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cu_index)
<a name="l21829"></a>21829 {
<a name="l21830"></a>21830   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> cu_index_to_write;
<a name="l21831"></a>21831   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> addr[8];
<a name="l21832"></a>21832   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> baseaddr;
<a name="l21833"></a>21833 
<a name="l21834"></a>21834   baseaddr = <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>, <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l21835"></a>21835 
<a name="l21836"></a>21836   <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (addr, 8, BFD_ENDIAN_LITTLE, start - baseaddr);
<a name="l21837"></a>21837   obstack_grow (obstack, addr, 8);
<a name="l21838"></a>21838   <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (addr, 8, BFD_ENDIAN_LITTLE, end - baseaddr);
<a name="l21839"></a>21839   obstack_grow (obstack, addr, 8);
<a name="l21840"></a>21840   cu_index_to_write = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (cu_index);
<a name="l21841"></a>21841   obstack_grow (obstack, &amp;cu_index_to_write, <span class="keyword">sizeof</span> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>));
<a name="l21842"></a>21842 }
<a name="l21843"></a>21843 
<a name="l21844"></a>21844 <span class="comment">/* Worker function for traversing an addrmap to build the address table.  */</span>
<a name="l21845"></a>21845 
<a name="l21846"></a>21846 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l21847"></a><a class="code" href="dwarf2read_8c.html#a61a256233ed817a667e9b2f9be2b4c9b">21847</a> <a class="code" href="dwarf2read_8c.html#a61a256233ed817a667e9b2f9be2b4c9b">add_address_entry_worker</a> (<span class="keywordtype">void</span> *datap, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_addr, <span class="keywordtype">void</span> *obj)
<a name="l21848"></a>21848 {
<a name="l21849"></a>21849   <span class="keyword">struct </span><a class="code" href="structaddrmap__index__data.html">addrmap_index_data</a> *data = datap;
<a name="l21850"></a>21850   <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *pst = obj;
<a name="l21851"></a>21851 
<a name="l21852"></a>21852   <span class="keywordflow">if</span> (data-&gt;<a class="code" href="structaddrmap__index__data.html#abd3c55fbc423b5c3f2451e3f60c5faaf">previous_valid</a>)
<a name="l21853"></a>21853     <a class="code" href="dwarf2read_8c.html#a50fb8e72ca00e7659b6169b8615c82e3">add_address_entry</a> (data-&gt;<a class="code" href="structaddrmap__index__data.html#a13e7efe62da3d2927de51d2f1956f694">objfile</a>, data-&gt;<a class="code" href="structaddrmap__index__data.html#aca0cf830678931ae0b3c4f2a166fb7d6">addr_obstack</a>,
<a name="l21854"></a>21854                        data-&gt;<a class="code" href="structaddrmap__index__data.html#a8bf1559c8c9616f04ba998af0396687c">previous_cu_start</a>, start_addr,
<a name="l21855"></a>21855                        data-&gt;<a class="code" href="structaddrmap__index__data.html#ae9323d00cd76481e6f07d0a82211c01e">previous_cu_index</a>);
<a name="l21856"></a>21856 
<a name="l21857"></a>21857   data-&gt;<a class="code" href="structaddrmap__index__data.html#a8bf1559c8c9616f04ba998af0396687c">previous_cu_start</a> = start_addr;
<a name="l21858"></a>21858   <span class="keywordflow">if</span> (pst != NULL)
<a name="l21859"></a>21859     {
<a name="l21860"></a>21860       <span class="keyword">struct </span><a class="code" href="structpsymtab__cu__index__map.html">psymtab_cu_index_map</a> find_map, *map;
<a name="l21861"></a>21861       find_map.<a class="code" href="structpsymtab__cu__index__map.html#a5894f16783cf71485a240f412dd181bc">psymtab</a> = pst;
<a name="l21862"></a>21862       map = htab_find (data-&gt;<a class="code" href="structaddrmap__index__data.html#ade53dd9cfda83a8b3c3040619e235a80">cu_index_htab</a>, &amp;find_map);
<a name="l21863"></a>21863       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (map != NULL);
<a name="l21864"></a>21864       data-&gt;<a class="code" href="structaddrmap__index__data.html#ae9323d00cd76481e6f07d0a82211c01e">previous_cu_index</a> = map-&gt;<a class="code" href="structpsymtab__cu__index__map.html#a1138336df6054423ba2723751cb8ff65">cu_index</a>;
<a name="l21865"></a>21865       data-&gt;<a class="code" href="structaddrmap__index__data.html#abd3c55fbc423b5c3f2451e3f60c5faaf">previous_valid</a> = 1;
<a name="l21866"></a>21866     }
<a name="l21867"></a>21867   <span class="keywordflow">else</span>
<a name="l21868"></a>21868       data-&gt;<a class="code" href="structaddrmap__index__data.html#abd3c55fbc423b5c3f2451e3f60c5faaf">previous_valid</a> = 0;
<a name="l21869"></a>21869 
<a name="l21870"></a>21870   <span class="keywordflow">return</span> 0;
<a name="l21871"></a>21871 }
<a name="l21872"></a>21872 
<a name="l21873"></a>21873 <span class="comment">/* Write OBJFILE&#39;s address map to OBSTACK.</span>
<a name="l21874"></a>21874 <span class="comment">   CU_INDEX_HTAB is used to map addrmap entries to their CU indices</span>
<a name="l21875"></a>21875 <span class="comment">   in the index file.  */</span>
<a name="l21876"></a>21876 
<a name="l21877"></a>21877 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21878"></a><a class="code" href="dwarf2read_8c.html#a5836184f67e2eae2a7b1c74ac3f2bfad">21878</a> <a class="code" href="dwarf2read_8c.html#a5836184f67e2eae2a7b1c74ac3f2bfad">write_address_map</a> (<span class="keyword">struct</span> objfile *objfile, <span class="keyword">struct</span> obstack *obstack,
<a name="l21879"></a>21879                    htab_t cu_index_htab)
<a name="l21880"></a>21880 {
<a name="l21881"></a>21881   <span class="keyword">struct </span><a class="code" href="structaddrmap__index__data.html">addrmap_index_data</a> addrmap_index_data;
<a name="l21882"></a>21882 
<a name="l21883"></a>21883   <span class="comment">/* When writing the address table, we have to cope with the fact that</span>
<a name="l21884"></a>21884 <span class="comment">     the addrmap iterator only provides the start of a region; we have to</span>
<a name="l21885"></a>21885 <span class="comment">     wait until the next invocation to get the start of the next region.  */</span>
<a name="l21886"></a>21886 
<a name="l21887"></a>21887   addrmap_index_data.<a class="code" href="structaddrmap__index__data.html#a13e7efe62da3d2927de51d2f1956f694">objfile</a> = <a class="code" href="structaddrmap__index__data.html#a13e7efe62da3d2927de51d2f1956f694">objfile</a>;
<a name="l21888"></a>21888   addrmap_index_data.<a class="code" href="structaddrmap__index__data.html#aca0cf830678931ae0b3c4f2a166fb7d6">addr_obstack</a> = obstack;
<a name="l21889"></a>21889   addrmap_index_data.<a class="code" href="structaddrmap__index__data.html#ade53dd9cfda83a8b3c3040619e235a80">cu_index_htab</a> = <a class="code" href="structaddrmap__index__data.html#ade53dd9cfda83a8b3c3040619e235a80">cu_index_htab</a>;
<a name="l21890"></a>21890   addrmap_index_data.<a class="code" href="structaddrmap__index__data.html#abd3c55fbc423b5c3f2451e3f60c5faaf">previous_valid</a> = 0;
<a name="l21891"></a>21891 
<a name="l21892"></a>21892   <a class="code" href="addrmap_8c.html#ac13e5b4b0e06241f1407cd9a00315031">addrmap_foreach</a> (objfile-&gt;<a class="code" href="structobjfile.html#ae7c792f2cd4efcff86d84d7bd3e15b26">psymtabs_addrmap</a>, <a class="code" href="dwarf2read_8c.html#a61a256233ed817a667e9b2f9be2b4c9b">add_address_entry_worker</a>,
<a name="l21893"></a>21893                    &amp;addrmap_index_data);
<a name="l21894"></a>21894 
<a name="l21895"></a>21895   <span class="comment">/* It&#39;s highly unlikely the last entry (end address = 0xff...ff)</span>
<a name="l21896"></a>21896 <span class="comment">     is valid, but we should still handle it.</span>
<a name="l21897"></a>21897 <span class="comment">     The end address is recorded as the start of the next region, but that</span>
<a name="l21898"></a>21898 <span class="comment">     doesn&#39;t work here.  To cope we pass 0xff...ff, this is a rare situation</span>
<a name="l21899"></a>21899 <span class="comment">     anyway.  */</span>
<a name="l21900"></a>21900   <span class="keywordflow">if</span> (addrmap_index_data.<a class="code" href="structaddrmap__index__data.html#abd3c55fbc423b5c3f2451e3f60c5faaf">previous_valid</a>)
<a name="l21901"></a>21901     <a class="code" href="dwarf2read_8c.html#a50fb8e72ca00e7659b6169b8615c82e3">add_address_entry</a> (objfile, obstack,
<a name="l21902"></a>21902                        addrmap_index_data.<a class="code" href="structaddrmap__index__data.html#a8bf1559c8c9616f04ba998af0396687c">previous_cu_start</a>, (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) -1,
<a name="l21903"></a>21903                        addrmap_index_data.<a class="code" href="structaddrmap__index__data.html#ae9323d00cd76481e6f07d0a82211c01e">previous_cu_index</a>);
<a name="l21904"></a>21904 }
<a name="l21905"></a>21905 
<a name="l21906"></a>21906 <span class="comment">/* Return the symbol kind of PSYM.  */</span>
<a name="l21907"></a>21907 
<a name="l21908"></a>21908 <span class="keyword">static</span> gdb_index_symbol_kind
<a name="l21909"></a><a class="code" href="dwarf2read_8c.html#a73bc3b8f484e295bdf4639f79613508f">21909</a> <a class="code" href="dwarf2read_8c.html#a73bc3b8f484e295bdf4639f79613508f">symbol_kind</a> (<span class="keyword">struct</span> <a class="code" href="structpartial__symbol.html">partial_symbol</a> *psym)
<a name="l21910"></a>21910 {
<a name="l21911"></a>21911   <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> domain = <a class="code" href="psympriv_8h.html#a86c7a1603b0e6af0457e79b5d9af71e6">PSYMBOL_DOMAIN</a> (psym);
<a name="l21912"></a>21912   <span class="keyword">enum</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3">address_class</a> aclass = <a class="code" href="psympriv_8h.html#acb5399267e28b8e4b2d8294ae490e700">PSYMBOL_CLASS</a> (psym);
<a name="l21913"></a>21913 
<a name="l21914"></a>21914   <span class="keywordflow">switch</span> (domain)
<a name="l21915"></a>21915     {
<a name="l21916"></a>21916     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>:
<a name="l21917"></a>21917       <span class="keywordflow">switch</span> (aclass)
<a name="l21918"></a>21918         {
<a name="l21919"></a>21919         <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>:
<a name="l21920"></a>21920           <span class="keywordflow">return</span> GDB_INDEX_SYMBOL_KIND_FUNCTION;
<a name="l21921"></a>21921         <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>:
<a name="l21922"></a>21922           <span class="keywordflow">return</span> GDB_INDEX_SYMBOL_KIND_TYPE;
<a name="l21923"></a>21923         <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3afd4303a25cda7805900ce8212c67ed45">LOC_COMPUTED</a>:
<a name="l21924"></a>21924         <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a74c269ff88b13d3497422a9ebfd98b2d">LOC_CONST_BYTES</a>:
<a name="l21925"></a>21925         <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3aa4f37f80c900ee253911325c30b8a60f">LOC_OPTIMIZED_OUT</a>:
<a name="l21926"></a>21926         <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a154b256439f7acd7ec7f6257d5881a0f">LOC_STATIC</a>:
<a name="l21927"></a>21927           <span class="keywordflow">return</span> GDB_INDEX_SYMBOL_KIND_VARIABLE;
<a name="l21928"></a>21928         <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a5268309778a6727d08106ff9f2966e54">LOC_CONST</a>:
<a name="l21929"></a>21929           <span class="comment">/* Note: It&#39;s currently impossible to recognize psyms as enum values</span>
<a name="l21930"></a>21930 <span class="comment">             short of reading the type info.  For now punt.  */</span>
<a name="l21931"></a>21931           <span class="keywordflow">return</span> GDB_INDEX_SYMBOL_KIND_VARIABLE;
<a name="l21932"></a>21932         <span class="keywordflow">default</span>:
<a name="l21933"></a>21933           <span class="comment">/* There are other LOC_FOO values that one might want to classify</span>
<a name="l21934"></a>21934 <span class="comment">             as variables, but dwarf2read.c doesn&#39;t currently use them.  */</span>
<a name="l21935"></a>21935           <span class="keywordflow">return</span> GDB_INDEX_SYMBOL_KIND_OTHER;
<a name="l21936"></a>21936         }
<a name="l21937"></a>21937     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa1f05a16e681efd2e892974878c353f11">STRUCT_DOMAIN</a>:
<a name="l21938"></a>21938       <span class="keywordflow">return</span> GDB_INDEX_SYMBOL_KIND_TYPE;
<a name="l21939"></a>21939     <span class="keywordflow">default</span>:
<a name="l21940"></a>21940       <span class="keywordflow">return</span> GDB_INDEX_SYMBOL_KIND_OTHER;
<a name="l21941"></a>21941     }
<a name="l21942"></a>21942 }
<a name="l21943"></a>21943 
<a name="l21944"></a>21944 <span class="comment">/* Add a list of partial symbols to SYMTAB.  */</span>
<a name="l21945"></a>21945 
<a name="l21946"></a>21946 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21947"></a><a class="code" href="dwarf2read_8c.html#a030e1e76b7ec6f63bf0813066befab2d">21947</a> <a class="code" href="dwarf2read_8c.html#a030e1e76b7ec6f63bf0813066befab2d">write_psymbols</a> (<span class="keyword">struct</span> <a class="code" href="structmapped__symtab.html">mapped_symtab</a> *<a class="code" href="structsymtab.html">symtab</a>,
<a name="l21948"></a>21948                 htab_t psyms_seen,
<a name="l21949"></a>21949                 <span class="keyword">struct</span> <a class="code" href="structpartial__symbol.html">partial_symbol</a> **psymp,
<a name="l21950"></a>21950                 <span class="keywordtype">int</span> count,
<a name="l21951"></a>21951                 <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> cu_index,
<a name="l21952"></a>21952                 <span class="keywordtype">int</span> is_static)
<a name="l21953"></a>21953 {
<a name="l21954"></a>21954   <span class="keywordflow">for</span> (; count-- &gt; 0; ++psymp)
<a name="l21955"></a>21955     {
<a name="l21956"></a>21956       <span class="keyword">struct </span><a class="code" href="structpartial__symbol.html">partial_symbol</a> *psym = *psymp;
<a name="l21957"></a>21957       <span class="keywordtype">void</span> **slot;
<a name="l21958"></a>21958 
<a name="l21959"></a>21959       <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a82fc22e60b1007c826a5ebf7d6593e78">SYMBOL_LANGUAGE</a> (psym) == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l21960"></a>21960         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Ada is not currently supported by the index&quot;</span>));
<a name="l21961"></a>21961 
<a name="l21962"></a>21962       <span class="comment">/* Only add a given psymbol once.  */</span>
<a name="l21963"></a>21963       slot = htab_find_slot (psyms_seen, psym, INSERT);
<a name="l21964"></a>21964       <span class="keywordflow">if</span> (!*slot)
<a name="l21965"></a>21965         {
<a name="l21966"></a>21966           gdb_index_symbol_kind kind = <a class="code" href="dwarf2read_8c.html#a73bc3b8f484e295bdf4639f79613508f">symbol_kind</a> (psym);
<a name="l21967"></a>21967 
<a name="l21968"></a>21968           *slot = psym;
<a name="l21969"></a>21969           <a class="code" href="dwarf2read_8c.html#af1182c3a512b0b3cf061b1c6b4fc8857">add_index_entry</a> (symtab, <a class="code" href="symtab_8h.html#a16e484ff2bd09d4f0400caf5e3f8c3eb">SYMBOL_SEARCH_NAME</a> (psym),
<a name="l21970"></a>21970                            is_static, kind, cu_index);
<a name="l21971"></a>21971         }
<a name="l21972"></a>21972     }
<a name="l21973"></a>21973 }
<a name="l21974"></a>21974 
<a name="l21975"></a>21975 <span class="comment">/* Write the contents of an (&quot;unfinished&quot;) obstack to FILE.  Throw an</span>
<a name="l21976"></a>21976 <span class="comment">   exception if there is an error.  */</span>
<a name="l21977"></a>21977 
<a name="l21978"></a>21978 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21979"></a><a class="code" href="dwarf2read_8c.html#a9c741afe71c1d3a778355734c1a0fc22">21979</a> <a class="code" href="dwarf2read_8c.html#a9c741afe71c1d3a778355734c1a0fc22">write_obstack</a> (FILE *file, <span class="keyword">struct</span> obstack *obstack)
<a name="l21980"></a>21980 {
<a name="l21981"></a>21981   <span class="keywordflow">if</span> (fwrite (obstack_base (obstack), 1, obstack_object_size (obstack),
<a name="l21982"></a>21982               file)
<a name="l21983"></a>21983       != obstack_object_size (obstack))
<a name="l21984"></a>21984     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;couldn&#39;t data write to file&quot;</span>));
<a name="l21985"></a>21985 }
<a name="l21986"></a>21986 
<a name="l21987"></a>21987 <span class="comment">/* Unlink a file if the argument is not NULL.  */</span>
<a name="l21988"></a>21988 
<a name="l21989"></a>21989 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l21990"></a><a class="code" href="dwarf2read_8c.html#a3bc661e019bd850277fd10c5a517e145">21990</a> <a class="code" href="dwarf2read_8c.html#a3bc661e019bd850277fd10c5a517e145">unlink_if_set</a> (<span class="keywordtype">void</span> *p)
<a name="l21991"></a>21991 {
<a name="l21992"></a>21992   <span class="keywordtype">char</span> **filename = p;
<a name="l21993"></a>21993   <span class="keywordflow">if</span> (*filename)
<a name="l21994"></a>21994     unlink (*filename);
<a name="l21995"></a>21995 }
<a name="l21996"></a>21996 
<a name="l21997"></a>21997 <span class="comment">/* A helper struct used when iterating over debug_types.  */</span>
<a name="l21998"></a><a class="code" href="structsignatured__type__index__data.html">21998</a> <span class="keyword">struct </span><a class="code" href="structsignatured__type__index__data.html">signatured_type_index_data</a>
<a name="l21999"></a>21999 {
<a name="l22000"></a><a class="code" href="structsignatured__type__index__data.html#ad915509477d97f5c33017ee9616c487d">22000</a>   <span class="keyword">struct </span>objfile *<a class="code" href="structsignatured__type__index__data.html#ad915509477d97f5c33017ee9616c487d">objfile</a>;
<a name="l22001"></a><a class="code" href="structsignatured__type__index__data.html#a6ebbf9c9c2f05ebd8a5ecb671a935141">22001</a>   <span class="keyword">struct </span><a class="code" href="structmapped__symtab.html">mapped_symtab</a> *<a class="code" href="structsignatured__type__index__data.html#a6ebbf9c9c2f05ebd8a5ecb671a935141">symtab</a>;
<a name="l22002"></a><a class="code" href="structsignatured__type__index__data.html#a4566ce574c198566f6dd7740841c4092">22002</a>   <span class="keyword">struct </span>obstack *<a class="code" href="structsignatured__type__index__data.html#a4566ce574c198566f6dd7740841c4092">types_list</a>;
<a name="l22003"></a><a class="code" href="structsignatured__type__index__data.html#a78b117a7038864c44493286c83925a5c">22003</a>   htab_t <a class="code" href="structsignatured__type__index__data.html#a78b117a7038864c44493286c83925a5c">psyms_seen</a>;
<a name="l22004"></a><a class="code" href="structsignatured__type__index__data.html#a1120970c4b5c29600e11b304d5c591a1">22004</a>   <span class="keywordtype">int</span> <a class="code" href="structsignatured__type__index__data.html#a1120970c4b5c29600e11b304d5c591a1">cu_index</a>;
<a name="l22005"></a>22005 };
<a name="l22006"></a>22006 
<a name="l22007"></a>22007 <span class="comment">/* A helper function that writes a single signatured_type to an</span>
<a name="l22008"></a>22008 <span class="comment">   obstack.  */</span>
<a name="l22009"></a>22009 
<a name="l22010"></a>22010 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l22011"></a><a class="code" href="dwarf2read_8c.html#ad29c841c0b5cdf2597f441b66c8f19b8">22011</a> <a class="code" href="dwarf2read_8c.html#ad29c841c0b5cdf2597f441b66c8f19b8">write_one_signatured_type</a> (<span class="keywordtype">void</span> **slot, <span class="keywordtype">void</span> *d)
<a name="l22012"></a>22012 {
<a name="l22013"></a>22013   <span class="keyword">struct </span><a class="code" href="structsignatured__type__index__data.html">signatured_type_index_data</a> *info = d;
<a name="l22014"></a>22014   <span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *entry = (<span class="keyword">struct </span><a class="code" href="structsignatured__type.html">signatured_type</a> *) *slot;
<a name="l22015"></a>22015   <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *psymtab = entry-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a>;
<a name="l22016"></a>22016   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> val[8];
<a name="l22017"></a>22017 
<a name="l22018"></a>22018   <a class="code" href="dwarf2read_8c.html#a030e1e76b7ec6f63bf0813066befab2d">write_psymbols</a> (info-&gt;<a class="code" href="structsignatured__type__index__data.html#a6ebbf9c9c2f05ebd8a5ecb671a935141">symtab</a>,
<a name="l22019"></a>22019                   info-&gt;<a class="code" href="structsignatured__type__index__data.html#a78b117a7038864c44493286c83925a5c">psyms_seen</a>,
<a name="l22020"></a>22020                   info-&gt;<a class="code" href="structsignatured__type__index__data.html#ad915509477d97f5c33017ee9616c487d">objfile</a>-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#ac618c483c3ff07162cdfe508abd6034d">list</a>
<a name="l22021"></a>22021                   + psymtab-&gt;<a class="code" href="structpartial__symtab.html#ae11f1094416fd506398f4a58fe4fa405">globals_offset</a>,
<a name="l22022"></a>22022                   psymtab-&gt;<a class="code" href="structpartial__symtab.html#ab26039959ff434afcf130049cfa8d27d">n_global_syms</a>, info-&gt;<a class="code" href="structsignatured__type__index__data.html#a1120970c4b5c29600e11b304d5c591a1">cu_index</a>,
<a name="l22023"></a>22023                   0);
<a name="l22024"></a>22024   <a class="code" href="dwarf2read_8c.html#a030e1e76b7ec6f63bf0813066befab2d">write_psymbols</a> (info-&gt;<a class="code" href="structsignatured__type__index__data.html#a6ebbf9c9c2f05ebd8a5ecb671a935141">symtab</a>,
<a name="l22025"></a>22025                   info-&gt;<a class="code" href="structsignatured__type__index__data.html#a78b117a7038864c44493286c83925a5c">psyms_seen</a>,
<a name="l22026"></a>22026                   info-&gt;<a class="code" href="structsignatured__type__index__data.html#ad915509477d97f5c33017ee9616c487d">objfile</a>-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#ac618c483c3ff07162cdfe508abd6034d">list</a>
<a name="l22027"></a>22027                   + psymtab-&gt;<a class="code" href="structpartial__symtab.html#a36b8c771ea2906e413b8f1fffe1f4d10">statics_offset</a>,
<a name="l22028"></a>22028                   psymtab-&gt;<a class="code" href="structpartial__symtab.html#a0fd67e243d440beaf6cc4757a97ff9b0">n_static_syms</a>, info-&gt;<a class="code" href="structsignatured__type__index__data.html#a1120970c4b5c29600e11b304d5c591a1">cu_index</a>,
<a name="l22029"></a>22029                   1);
<a name="l22030"></a>22030 
<a name="l22031"></a>22031   <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (val, 8, BFD_ENDIAN_LITTLE,
<a name="l22032"></a>22032                           entry-&gt;<a class="code" href="structsignatured__type.html#a85b1fda548ae3b3bcc1c6d5e2687480d">per_cu</a>.<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l22033"></a>22033   obstack_grow (info-&gt;<a class="code" href="structsignatured__type__index__data.html#a4566ce574c198566f6dd7740841c4092">types_list</a>, val, 8);
<a name="l22034"></a>22034   <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (val, 8, BFD_ENDIAN_LITTLE,
<a name="l22035"></a>22035                           entry-&gt;<a class="code" href="structsignatured__type.html#ab152a3e1f687ff6464b369502ce745a9">type_offset_in_tu</a>.<a class="code" href="structcu__offset.html#a19224b0dc5f0bc49babd2b7701a8d63e">cu_off</a>);
<a name="l22036"></a>22036   obstack_grow (info-&gt;<a class="code" href="structsignatured__type__index__data.html#a4566ce574c198566f6dd7740841c4092">types_list</a>, val, 8);
<a name="l22037"></a>22037   <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (val, 8, BFD_ENDIAN_LITTLE, entry-&gt;<a class="code" href="structsignatured__type.html#a832f2f2c05892d38980e7aebdeec1b05">signature</a>);
<a name="l22038"></a>22038   obstack_grow (info-&gt;<a class="code" href="structsignatured__type__index__data.html#a4566ce574c198566f6dd7740841c4092">types_list</a>, val, 8);
<a name="l22039"></a>22039 
<a name="l22040"></a>22040   ++info-&gt;<a class="code" href="structsignatured__type__index__data.html#a1120970c4b5c29600e11b304d5c591a1">cu_index</a>;
<a name="l22041"></a>22041 
<a name="l22042"></a>22042   <span class="keywordflow">return</span> 1;
<a name="l22043"></a>22043 }
<a name="l22044"></a>22044 
<a name="l22045"></a>22045 <span class="comment">/* Recurse into all &quot;included&quot; dependencies and write their symbols as</span>
<a name="l22046"></a>22046 <span class="comment">   if they appeared in this psymtab.  */</span>
<a name="l22047"></a>22047 
<a name="l22048"></a>22048 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l22049"></a><a class="code" href="dwarf2read_8c.html#a1774c9a904ac009c4b1b31bc861b1778">22049</a> <a class="code" href="dwarf2read_8c.html#a1774c9a904ac009c4b1b31bc861b1778">recursively_write_psymbols</a> (<span class="keyword">struct</span> objfile *objfile,
<a name="l22050"></a>22050                             <span class="keyword">struct</span> <a class="code" href="structpartial__symtab.html">partial_symtab</a> *psymtab,
<a name="l22051"></a>22051                             <span class="keyword">struct</span> <a class="code" href="structmapped__symtab.html">mapped_symtab</a> *<a class="code" href="structsymtab.html">symtab</a>,
<a name="l22052"></a>22052                             htab_t psyms_seen,
<a name="l22053"></a>22053                             <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> cu_index)
<a name="l22054"></a>22054 {
<a name="l22055"></a>22055   <span class="keywordtype">int</span> i;
<a name="l22056"></a>22056 
<a name="l22057"></a>22057   <span class="keywordflow">for</span> (i = 0; i &lt; psymtab-&gt;<a class="code" href="structpartial__symtab.html#a917b503a5e1f7c2bb60feb6ff1e3b197">number_of_dependencies</a>; ++i)
<a name="l22058"></a>22058     <span class="keywordflow">if</span> (psymtab-&gt;<a class="code" href="structpartial__symtab.html#a0b7bd5bada02a362357552790b111c23">dependencies</a>[i]-&gt;<a class="code" href="structpartial__symtab.html#a0609b1a2e29b3419dc25520e7d7293f0">user</a> != NULL)
<a name="l22059"></a>22059       <a class="code" href="dwarf2read_8c.html#a1774c9a904ac009c4b1b31bc861b1778">recursively_write_psymbols</a> (objfile, psymtab-&gt;<a class="code" href="structpartial__symtab.html#a0b7bd5bada02a362357552790b111c23">dependencies</a>[i],
<a name="l22060"></a>22060                                   symtab, psyms_seen, cu_index);
<a name="l22061"></a>22061 
<a name="l22062"></a>22062   <a class="code" href="dwarf2read_8c.html#a030e1e76b7ec6f63bf0813066befab2d">write_psymbols</a> (symtab,
<a name="l22063"></a>22063                   psyms_seen,
<a name="l22064"></a>22064                   objfile-&gt;<a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#ac618c483c3ff07162cdfe508abd6034d">list</a> + psymtab-&gt;<a class="code" href="structpartial__symtab.html#ae11f1094416fd506398f4a58fe4fa405">globals_offset</a>,
<a name="l22065"></a>22065                   psymtab-&gt;<a class="code" href="structpartial__symtab.html#ab26039959ff434afcf130049cfa8d27d">n_global_syms</a>, cu_index,
<a name="l22066"></a>22066                   0);
<a name="l22067"></a>22067   <a class="code" href="dwarf2read_8c.html#a030e1e76b7ec6f63bf0813066befab2d">write_psymbols</a> (symtab,
<a name="l22068"></a>22068                   psyms_seen,
<a name="l22069"></a>22069                   objfile-&gt;<a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>.<a class="code" href="structpsymbol__allocation__list.html#ac618c483c3ff07162cdfe508abd6034d">list</a> + psymtab-&gt;<a class="code" href="structpartial__symtab.html#a36b8c771ea2906e413b8f1fffe1f4d10">statics_offset</a>,
<a name="l22070"></a>22070                   psymtab-&gt;<a class="code" href="structpartial__symtab.html#a0fd67e243d440beaf6cc4757a97ff9b0">n_static_syms</a>, cu_index,
<a name="l22071"></a>22071                   1);
<a name="l22072"></a>22072 }
<a name="l22073"></a>22073 
<a name="l22074"></a>22074 <span class="comment">/* Create an index file for OBJFILE in the directory DIR.  */</span>
<a name="l22075"></a>22075 
<a name="l22076"></a>22076 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l22077"></a><a class="code" href="dwarf2read_8c.html#a321f2f42d6bc7f8dc6b9525163d2cb21">22077</a> <a class="code" href="dwarf2read_8c.html#a321f2f42d6bc7f8dc6b9525163d2cb21">write_psymtabs_to_index</a> (<span class="keyword">struct</span> objfile *objfile, <span class="keyword">const</span> <span class="keywordtype">char</span> *dir)
<a name="l22078"></a>22078 {
<a name="l22079"></a>22079   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l22080"></a>22080   <span class="keywordtype">char</span> *filename, *cleanup_filename;
<a name="l22081"></a>22081   <span class="keyword">struct </span>obstack contents, addr_obstack, constant_pool, symtab_obstack;
<a name="l22082"></a>22082   <span class="keyword">struct </span>obstack cu_list, types_cu_list;
<a name="l22083"></a>22083   <span class="keywordtype">int</span> i;
<a name="l22084"></a>22084   FILE *out_file;
<a name="l22085"></a>22085   <span class="keyword">struct </span><a class="code" href="structmapped__symtab.html">mapped_symtab</a> *<a class="code" href="structsymtab.html">symtab</a>;
<a name="l22086"></a>22086   <a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a> val, size_of_contents, total_len;
<a name="l22087"></a>22087   <span class="keyword">struct </span>stat st;
<a name="l22088"></a>22088   htab_t psyms_seen;
<a name="l22089"></a>22089   htab_t cu_index_htab;
<a name="l22090"></a>22090   <span class="keyword">struct </span><a class="code" href="structpsymtab__cu__index__map.html">psymtab_cu_index_map</a> *<a class="code" href="structpsymtab__cu__index__map.html">psymtab_cu_index_map</a>;
<a name="l22091"></a>22091 
<a name="l22092"></a>22092   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;<a class="code" href="structdwarf2__per__objfile.html#a97f5365395e68bcd9efd6132d2cc0387">using_index</a>)
<a name="l22093"></a>22093     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot use an index to create the index&quot;</span>));
<a name="l22094"></a>22094 
<a name="l22095"></a>22095   <span class="keywordflow">if</span> (<a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structdwarf2__section__info.html">dwarf2_section_info_def</a>, dwarf2_per_objfile-&gt;types) &gt; 1)
<a name="l22096"></a>22096     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot make an index when the file has multiple .debug_types sections&quot;</span>));
<a name="l22097"></a>22097 
<a name="l22098"></a>22098   <span class="keywordflow">if</span> (!objfile-&gt;<a class="code" href="structobjfile.html#a4dcbf92348a83fa9d6d5d2d08cb59eb5">psymtabs</a> || !objfile-&gt;<a class="code" href="structobjfile.html#ae7c792f2cd4efcff86d84d7bd3e15b26">psymtabs_addrmap</a>)
<a name="l22099"></a>22099     <span class="keywordflow">return</span>;
<a name="l22100"></a>22100 
<a name="l22101"></a>22101   <span class="keywordflow">if</span> (stat (<a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile), &amp;st) &lt; 0)
<a name="l22102"></a>22102     <a class="code" href="utils_8c.html#a14801ceb45147833b8ce111c89ea0d5f">perror_with_name</a> (<a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l22103"></a>22103 
<a name="l22104"></a>22104   filename = concat (dir, SLASH_STRING, lbasename (<a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile)),
<a name="l22105"></a>22105                      <a class="code" href="dwarf2read_8c.html#a4d599eea3e3f09271468360062eb330e">INDEX_SUFFIX</a>, (<span class="keywordtype">char</span> *) NULL);
<a name="l22106"></a>22106   cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, filename);
<a name="l22107"></a>22107 
<a name="l22108"></a>22108   out_file = <a class="code" href="filestuff_8c.html#a32975d9389800b8d2c632083293e8960">gdb_fopen_cloexec</a> (filename, <span class="stringliteral">&quot;wb&quot;</span>);
<a name="l22109"></a>22109   <span class="keywordflow">if</span> (!out_file)
<a name="l22110"></a>22110     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Can&#39;t open `%s&#39; for writing&quot;</span>), filename);
<a name="l22111"></a>22111 
<a name="l22112"></a>22112   cleanup_filename = filename;
<a name="l22113"></a>22113   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#a3bc661e019bd850277fd10c5a517e145">unlink_if_set</a>, &amp;cleanup_filename);
<a name="l22114"></a>22114 
<a name="l22115"></a>22115   symtab = <a class="code" href="dwarf2read_8c.html#a28eec9306ccfc88e022de65ab9bff61b">create_mapped_symtab</a> ();
<a name="l22116"></a>22116   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="dwarf2read_8c.html#a1ab7924ea5a66c31266d3980df74bc28">cleanup_mapped_symtab</a>, symtab);
<a name="l22117"></a>22117 
<a name="l22118"></a>22118   obstack_init (&amp;addr_obstack);
<a name="l22119"></a>22119   <a class="code" href="utils_8c.html#a8aa2f0be9d477ee015e9e9bac43c005d">make_cleanup_obstack_free</a> (&amp;addr_obstack);
<a name="l22120"></a>22120 
<a name="l22121"></a>22121   obstack_init (&amp;cu_list);
<a name="l22122"></a>22122   <a class="code" href="utils_8c.html#a8aa2f0be9d477ee015e9e9bac43c005d">make_cleanup_obstack_free</a> (&amp;cu_list);
<a name="l22123"></a>22123 
<a name="l22124"></a>22124   obstack_init (&amp;types_cu_list);
<a name="l22125"></a>22125   <a class="code" href="utils_8c.html#a8aa2f0be9d477ee015e9e9bac43c005d">make_cleanup_obstack_free</a> (&amp;types_cu_list);
<a name="l22126"></a>22126 
<a name="l22127"></a>22127   psyms_seen = htab_create_alloc (100, htab_hash_pointer, htab_eq_pointer,
<a name="l22128"></a>22128                                   NULL, <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a>, <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>);
<a name="l22129"></a>22129   <a class="code" href="utils_8c.html#ad5977a7d9e282b65846100111cd95c76">make_cleanup_htab_delete</a> (psyms_seen);
<a name="l22130"></a>22130 
<a name="l22131"></a>22131   <span class="comment">/* While we&#39;re scanning CU&#39;s create a table that maps a psymtab pointer</span>
<a name="l22132"></a>22132 <span class="comment">     (which is what addrmap records) to its index (which is what is recorded</span>
<a name="l22133"></a>22133 <span class="comment">     in the index file).  This will later be needed to write the address</span>
<a name="l22134"></a>22134 <span class="comment">     table.  */</span>
<a name="l22135"></a>22135   cu_index_htab = htab_create_alloc (100,
<a name="l22136"></a>22136                                      <a class="code" href="dwarf2read_8c.html#a5f9ea395391a7daa77fdde1eeab962bf">hash_psymtab_cu_index</a>,
<a name="l22137"></a>22137                                      <a class="code" href="dwarf2read_8c.html#a53f5efec47f1f3e396e972c437105a6b">eq_psymtab_cu_index</a>,
<a name="l22138"></a>22138                                      NULL, <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a>, <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>);
<a name="l22139"></a>22139   <a class="code" href="utils_8c.html#ad5977a7d9e282b65846100111cd95c76">make_cleanup_htab_delete</a> (cu_index_htab);
<a name="l22140"></a>22140   psymtab_cu_index_map = (<span class="keyword">struct </span>psymtab_cu_index_map *)
<a name="l22141"></a>22141     <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> psymtab_cu_index_map)
<a name="l22142"></a>22142              * dwarf2_per_objfile-&gt;n_comp_units);
<a name="l22143"></a>22143   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, psymtab_cu_index_map);
<a name="l22144"></a>22144 
<a name="l22145"></a>22145   <span class="comment">/* The CU list is already sorted, so we don&#39;t need to do additional</span>
<a name="l22146"></a>22146 <span class="comment">     work here.  Also, the debug_types entries do not appear in</span>
<a name="l22147"></a>22147 <span class="comment">     all_comp_units, but only in their own hash table.  */</span>
<a name="l22148"></a>22148   <span class="keywordflow">for</span> (i = 0; i &lt; dwarf2_per_objfile-&gt;n_comp_units; ++i)
<a name="l22149"></a>22149     {
<a name="l22150"></a>22150       <span class="keyword">struct </span><a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu
<a name="l22151"></a>22151         = dwarf2_per_objfile-&gt;all_comp_units[i];
<a name="l22152"></a>22152       <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *psymtab = per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#a09b3bba3200183e3acbd8913fda32d16">v</a>.<a class="code" href="structdwarf2__per__cu__data.html#afa429719dcbda6bd8c947dacb7638b4d">psymtab</a>;
<a name="l22153"></a>22153       <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> val[8];
<a name="l22154"></a>22154       <span class="keyword">struct </span>psymtab_cu_index_map *map;
<a name="l22155"></a>22155       <span class="keywordtype">void</span> **slot;
<a name="l22156"></a>22156 
<a name="l22157"></a>22157       <span class="comment">/* CU of a shared file from &#39;dwz -m&#39; may be unused by this main file.</span>
<a name="l22158"></a>22158 <span class="comment">         It may be referenced from a local scope but in such case it does not</span>
<a name="l22159"></a>22159 <span class="comment">         need to be present in .gdb_index.  */</span>
<a name="l22160"></a>22160       <span class="keywordflow">if</span> (psymtab == NULL)
<a name="l22161"></a>22161         <span class="keywordflow">continue</span>;
<a name="l22162"></a>22162 
<a name="l22163"></a>22163       <span class="keywordflow">if</span> (psymtab-&gt;<a class="code" href="structpartial__symtab.html#a0609b1a2e29b3419dc25520e7d7293f0">user</a> == NULL)
<a name="l22164"></a>22164         <a class="code" href="dwarf2read_8c.html#a1774c9a904ac009c4b1b31bc861b1778">recursively_write_psymbols</a> (objfile, psymtab, symtab, psyms_seen, i);
<a name="l22165"></a>22165 
<a name="l22166"></a>22166       map = &amp;psymtab_cu_index_map[i];
<a name="l22167"></a>22167       map-&gt;<a class="code" href="structpsymtab__cu__index__map.html#a5894f16783cf71485a240f412dd181bc">psymtab</a> = <a class="code" href="structpsymtab__cu__index__map.html#a5894f16783cf71485a240f412dd181bc">psymtab</a>;
<a name="l22168"></a>22168       map-&gt;<a class="code" href="structpsymtab__cu__index__map.html#a1138336df6054423ba2723751cb8ff65">cu_index</a> = i;
<a name="l22169"></a>22169       slot = htab_find_slot (cu_index_htab, map, INSERT);
<a name="l22170"></a>22170       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (slot != NULL);
<a name="l22171"></a>22171       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (*slot == NULL);
<a name="l22172"></a>22172       *slot = map;
<a name="l22173"></a>22173 
<a name="l22174"></a>22174       <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (val, 8, BFD_ENDIAN_LITTLE,
<a name="l22175"></a>22175                               per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad08112ceda067b8668cf4fa2102255c1">offset</a>.<a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>);
<a name="l22176"></a>22176       obstack_grow (&amp;cu_list, val, 8);
<a name="l22177"></a>22177       <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (val, 8, BFD_ENDIAN_LITTLE, per_cu-&gt;<a class="code" href="structdwarf2__per__cu__data.html#ad66e6a11efd2060d203c962007c9e06e">length</a>);
<a name="l22178"></a>22178       obstack_grow (&amp;cu_list, val, 8);
<a name="l22179"></a>22179     }
<a name="l22180"></a>22180 
<a name="l22181"></a>22181   <span class="comment">/* Dump the address map.  */</span>
<a name="l22182"></a>22182   <a class="code" href="dwarf2read_8c.html#a5836184f67e2eae2a7b1c74ac3f2bfad">write_address_map</a> (objfile, &amp;addr_obstack, cu_index_htab);
<a name="l22183"></a>22183 
<a name="l22184"></a>22184   <span class="comment">/* Write out the .debug_type entries, if any.  */</span>
<a name="l22185"></a>22185   <span class="keywordflow">if</span> (dwarf2_per_objfile-&gt;signatured_types)
<a name="l22186"></a>22186     {
<a name="l22187"></a>22187       <span class="keyword">struct </span><a class="code" href="structsignatured__type__index__data.html">signatured_type_index_data</a> sig_data;
<a name="l22188"></a>22188 
<a name="l22189"></a>22189       sig_data.<a class="code" href="structsignatured__type__index__data.html#ad915509477d97f5c33017ee9616c487d">objfile</a> = <a class="code" href="structsignatured__type__index__data.html#ad915509477d97f5c33017ee9616c487d">objfile</a>;
<a name="l22190"></a>22190       sig_data.<a class="code" href="structsignatured__type__index__data.html#a6ebbf9c9c2f05ebd8a5ecb671a935141">symtab</a> = <a class="code" href="structsignatured__type__index__data.html#a6ebbf9c9c2f05ebd8a5ecb671a935141">symtab</a>;
<a name="l22191"></a>22191       sig_data.<a class="code" href="structsignatured__type__index__data.html#a4566ce574c198566f6dd7740841c4092">types_list</a> = &amp;types_cu_list;
<a name="l22192"></a>22192       sig_data.<a class="code" href="structsignatured__type__index__data.html#a78b117a7038864c44493286c83925a5c">psyms_seen</a> = <a class="code" href="structsignatured__type__index__data.html#a78b117a7038864c44493286c83925a5c">psyms_seen</a>;
<a name="l22193"></a>22193       sig_data.<a class="code" href="structsignatured__type__index__data.html#a1120970c4b5c29600e11b304d5c591a1">cu_index</a> = dwarf2_per_objfile-&gt;n_comp_units;
<a name="l22194"></a>22194       htab_traverse_noresize (dwarf2_per_objfile-&gt;signatured_types,
<a name="l22195"></a>22195                               <a class="code" href="dwarf2read_8c.html#ad29c841c0b5cdf2597f441b66c8f19b8">write_one_signatured_type</a>, &amp;sig_data);
<a name="l22196"></a>22196     }
<a name="l22197"></a>22197 
<a name="l22198"></a>22198   <span class="comment">/* Now that we&#39;ve processed all symbols we can shrink their cu_indices</span>
<a name="l22199"></a>22199 <span class="comment">     lists.  */</span>
<a name="l22200"></a>22200   <a class="code" href="dwarf2read_8c.html#afe6f61ccb238d225749074df42ba2140">uniquify_cu_indices</a> (symtab);
<a name="l22201"></a>22201 
<a name="l22202"></a>22202   obstack_init (&amp;constant_pool);
<a name="l22203"></a>22203   <a class="code" href="utils_8c.html#a8aa2f0be9d477ee015e9e9bac43c005d">make_cleanup_obstack_free</a> (&amp;constant_pool);
<a name="l22204"></a>22204   obstack_init (&amp;symtab_obstack);
<a name="l22205"></a>22205   <a class="code" href="utils_8c.html#a8aa2f0be9d477ee015e9e9bac43c005d">make_cleanup_obstack_free</a> (&amp;symtab_obstack);
<a name="l22206"></a>22206   <a class="code" href="dwarf2read_8c.html#a383d7fbf2fe0852a2b143f840650dd08">write_hash_table</a> (symtab, &amp;symtab_obstack, &amp;constant_pool);
<a name="l22207"></a>22207 
<a name="l22208"></a>22208   obstack_init (&amp;contents);
<a name="l22209"></a>22209   <a class="code" href="utils_8c.html#a8aa2f0be9d477ee015e9e9bac43c005d">make_cleanup_obstack_free</a> (&amp;contents);
<a name="l22210"></a>22210   size_of_contents = 6 * <span class="keyword">sizeof</span> (<a class="code" href="dwarf2read_8c.html#a7c8d8fe172cfe1f05bbdd4bfd5a4b51c">offset_type</a>);
<a name="l22211"></a>22211   total_len = size_of_contents;
<a name="l22212"></a>22212 
<a name="l22213"></a>22213   <span class="comment">/* The version number.  */</span>
<a name="l22214"></a>22214   val = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (8);
<a name="l22215"></a>22215   obstack_grow (&amp;contents, &amp;val, <span class="keyword">sizeof</span> (val));
<a name="l22216"></a>22216 
<a name="l22217"></a>22217   <span class="comment">/* The offset of the CU list from the start of the file.  */</span>
<a name="l22218"></a>22218   val = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (total_len);
<a name="l22219"></a>22219   obstack_grow (&amp;contents, &amp;val, <span class="keyword">sizeof</span> (val));
<a name="l22220"></a>22220   total_len += obstack_object_size (&amp;cu_list);
<a name="l22221"></a>22221 
<a name="l22222"></a>22222   <span class="comment">/* The offset of the types CU list from the start of the file.  */</span>
<a name="l22223"></a>22223   val = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (total_len);
<a name="l22224"></a>22224   obstack_grow (&amp;contents, &amp;val, <span class="keyword">sizeof</span> (val));
<a name="l22225"></a>22225   total_len += obstack_object_size (&amp;types_cu_list);
<a name="l22226"></a>22226 
<a name="l22227"></a>22227   <span class="comment">/* The offset of the address table from the start of the file.  */</span>
<a name="l22228"></a>22228   val = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (total_len);
<a name="l22229"></a>22229   obstack_grow (&amp;contents, &amp;val, <span class="keyword">sizeof</span> (val));
<a name="l22230"></a>22230   total_len += obstack_object_size (&amp;addr_obstack);
<a name="l22231"></a>22231 
<a name="l22232"></a>22232   <span class="comment">/* The offset of the symbol table from the start of the file.  */</span>
<a name="l22233"></a>22233   val = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (total_len);
<a name="l22234"></a>22234   obstack_grow (&amp;contents, &amp;val, <span class="keyword">sizeof</span> (val));
<a name="l22235"></a>22235   total_len += obstack_object_size (&amp;symtab_obstack);
<a name="l22236"></a>22236 
<a name="l22237"></a>22237   <span class="comment">/* The offset of the constant pool from the start of the file.  */</span>
<a name="l22238"></a>22238   val = <a class="code" href="dwarf2read_8c.html#a12391f9a9e44d2e2ef6079f8131c47e1">MAYBE_SWAP</a> (total_len);
<a name="l22239"></a>22239   obstack_grow (&amp;contents, &amp;val, <span class="keyword">sizeof</span> (val));
<a name="l22240"></a>22240   total_len += obstack_object_size (&amp;constant_pool);
<a name="l22241"></a>22241 
<a name="l22242"></a>22242   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (obstack_object_size (&amp;contents) == size_of_contents);
<a name="l22243"></a>22243 
<a name="l22244"></a>22244   <a class="code" href="dwarf2read_8c.html#a9c741afe71c1d3a778355734c1a0fc22">write_obstack</a> (out_file, &amp;contents);
<a name="l22245"></a>22245   <a class="code" href="dwarf2read_8c.html#a9c741afe71c1d3a778355734c1a0fc22">write_obstack</a> (out_file, &amp;cu_list);
<a name="l22246"></a>22246   <a class="code" href="dwarf2read_8c.html#a9c741afe71c1d3a778355734c1a0fc22">write_obstack</a> (out_file, &amp;types_cu_list);
<a name="l22247"></a>22247   <a class="code" href="dwarf2read_8c.html#a9c741afe71c1d3a778355734c1a0fc22">write_obstack</a> (out_file, &amp;addr_obstack);
<a name="l22248"></a>22248   <a class="code" href="dwarf2read_8c.html#a9c741afe71c1d3a778355734c1a0fc22">write_obstack</a> (out_file, &amp;symtab_obstack);
<a name="l22249"></a>22249   <a class="code" href="dwarf2read_8c.html#a9c741afe71c1d3a778355734c1a0fc22">write_obstack</a> (out_file, &amp;constant_pool);
<a name="l22250"></a>22250 
<a name="l22251"></a>22251   fclose (out_file);
<a name="l22252"></a>22252 
<a name="l22253"></a>22253   <span class="comment">/* We want to keep the file, so we set cleanup_filename to NULL</span>
<a name="l22254"></a>22254 <span class="comment">     here.  See unlink_if_set.  */</span>
<a name="l22255"></a>22255   cleanup_filename = NULL;
<a name="l22256"></a>22256 
<a name="l22257"></a>22257   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l22258"></a>22258 }
<a name="l22259"></a>22259 
<a name="l22260"></a>22260 <span class="comment">/* Implementation of the `save gdb-index&#39; command.</span>
<a name="l22261"></a>22261 <span class="comment">   </span>
<a name="l22262"></a>22262 <span class="comment">   Note that the file format used by this command is documented in the</span>
<a name="l22263"></a>22263 <span class="comment">   GDB manual.  Any changes here must be documented there.  */</span>
<a name="l22264"></a>22264 
<a name="l22265"></a>22265 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l22266"></a><a class="code" href="dwarf2read_8c.html#ad72239689bc9e301102475f81b601926">22266</a> <a class="code" href="dwarf2read_8c.html#ad72239689bc9e301102475f81b601926">save_gdb_index_command</a> (<span class="keywordtype">char</span> *arg, <span class="keywordtype">int</span> from_tty)
<a name="l22267"></a>22267 {
<a name="l22268"></a>22268   <span class="keyword">struct </span>objfile *objfile;
<a name="l22269"></a>22269 
<a name="l22270"></a>22270   <span class="keywordflow">if</span> (!arg || !*arg)
<a name="l22271"></a>22271     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;usage: save gdb-index DIRECTORY&quot;</span>));
<a name="l22272"></a>22272 
<a name="l22273"></a>22273   <a class="code" href="objfiles_8h.html#a8efee3b85a322006131a6056d45058b3">ALL_OBJFILES</a> (objfile)
<a name="l22274"></a>22274   {
<a name="l22275"></a>22275     <span class="keyword">struct </span>stat st;
<a name="l22276"></a>22276 
<a name="l22277"></a>22277     <span class="comment">/* If the objfile does not correspond to an actual file, skip it.  */</span>
<a name="l22278"></a>22278     <span class="keywordflow">if</span> (stat (<a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile), &amp;st) &lt; 0)
<a name="l22279"></a>22279       <span class="keywordflow">continue</span>;
<a name="l22280"></a>22280 
<a name="l22281"></a>22281     dwarf2_per_objfile = objfile_data (objfile, <a class="code" href="dwarf2read_8c.html#a9fcfdd623d890b4c3b4ac0ba42e7df4b">dwarf2_objfile_data_key</a>);
<a name="l22282"></a>22282     <span class="keywordflow">if</span> (dwarf2_per_objfile)
<a name="l22283"></a>22283       {
<a name="l22284"></a>22284         <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> except;
<a name="l22285"></a>22285 
<a name="l22286"></a>22286         <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l22287"></a>22287           {
<a name="l22288"></a>22288             <a class="code" href="dwarf2read_8c.html#a321f2f42d6bc7f8dc6b9525163d2cb21">write_psymtabs_to_index</a> (objfile, arg);
<a name="l22289"></a>22289           }
<a name="l22290"></a>22290         <span class="keywordflow">if</span> (except.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0)
<a name="l22291"></a>22291           <a class="code" href="exceptions_8c.html#ae1dffc77e3a96d17e813da7d2165b16d">exception_fprintf</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, except,
<a name="l22292"></a>22292                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Error while writing index for `%s&#39;: &quot;</span>),
<a name="l22293"></a>22293                              <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l22294"></a>22294       }
<a name="l22295"></a>22295   }
<a name="l22296"></a>22296 }
<a name="l22297"></a>22297 
<a name="l22298"></a>22298 
<a name="l22299"></a>22299 
<a name="l22300"></a><a class="code" href="dwarf2read_8c.html#ac8ed1ea7833a69429da4f2fac55cb0a4">22300</a> <span class="keywordtype">int</span> <a class="code" href="dwarf2loc_8c.html#ac8ed1ea7833a69429da4f2fac55cb0a4">dwarf2_always_disassemble</a>;
<a name="l22301"></a>22301 
<a name="l22302"></a>22302 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l22303"></a><a class="code" href="dwarf2read_8c.html#a318675240d651634b7ea4a0bc51f39db">22303</a> <a class="code" href="dwarf2read_8c.html#a318675240d651634b7ea4a0bc51f39db">show_dwarf2_always_disassemble</a> (<span class="keyword">struct</span> <a class="code" href="structui__file.html">ui_file</a> *file, <span class="keywordtype">int</span> from_tty,
<a name="l22304"></a>22304                                 <span class="keyword">struct</span> <a class="code" href="structcmd__list__element.html">cmd_list_element</a> *c, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structvalue.html">value</a>)
<a name="l22305"></a>22305 {
<a name="l22306"></a>22306   <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (file,
<a name="l22307"></a>22307                     <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Whether to always disassemble &quot;</span>
<a name="l22308"></a>22308                       <span class="stringliteral">&quot;DWARF expressions is %s.\n&quot;</span>),
<a name="l22309"></a>22309                     value);
<a name="l22310"></a>22310 }
<a name="l22311"></a>22311 
<a name="l22312"></a>22312 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l22313"></a><a class="code" href="dwarf2read_8c.html#a34cdc651c467dd5b197ca21c67443d38">22313</a> <a class="code" href="dwarf2read_8c.html#a34cdc651c467dd5b197ca21c67443d38">show_check_physname</a> (<span class="keyword">struct</span> <a class="code" href="structui__file.html">ui_file</a> *file, <span class="keywordtype">int</span> from_tty,
<a name="l22314"></a>22314                      <span class="keyword">struct</span> <a class="code" href="structcmd__list__element.html">cmd_list_element</a> *c, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structvalue.html">value</a>)
<a name="l22315"></a>22315 {
<a name="l22316"></a>22316   <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (file,
<a name="l22317"></a>22317                     <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Whether to check \&quot;physname\&quot; is %s.\n&quot;</span>),
<a name="l22318"></a>22318                     value);
<a name="l22319"></a>22319 }
<a name="l22320"></a>22320 
<a name="l22321"></a>22321 <span class="keywordtype">void</span> <a class="code" href="init_8c.html#ab68120a227aeffd8ebc6cae2972215e5">_initialize_dwarf2_read</a> (<span class="keywordtype">void</span>);
<a name="l22322"></a>22322 
<a name="l22323"></a>22323 <span class="keywordtype">void</span>
<a name="l22324"></a><a class="code" href="init_8c.html#ab68120a227aeffd8ebc6cae2972215e5">22324</a> <a class="code" href="init_8c.html#ab68120a227aeffd8ebc6cae2972215e5">_initialize_dwarf2_read</a> (<span class="keywordtype">void</span>)
<a name="l22325"></a>22325 {
<a name="l22326"></a>22326   <span class="keyword">struct </span><a class="code" href="structcmd__list__element.html">cmd_list_element</a> *c;
<a name="l22327"></a>22327 
<a name="l22328"></a>22328   <a class="code" href="dwarf2read_8c.html#a9fcfdd623d890b4c3b4ac0ba42e7df4b">dwarf2_objfile_data_key</a>
<a name="l22329"></a>22329     = register_objfile_data_with_cleanup (NULL, <a class="code" href="dwarf2read_8c.html#a95396f8ae0015d3e5a77a6822055aa45">dwarf2_per_objfile_free</a>);
<a name="l22330"></a>22330 
<a name="l22331"></a>22331   <a class="code" href="cli-decode_8c.html#a8abc1e9af59eb3cb12bb03977d5e8e5a">add_prefix_cmd</a> (<span class="stringliteral">&quot;dwarf2&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a502c7b57c7172ac88ef735f68070bb59">class_maintenance</a>, <a class="code" href="dwarf2read_8c.html#af7a3da8ef93e1351824eb72c3ececd99">set_dwarf2_cmd</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22332"></a>22332 <span class="stringliteral">Set DWARF 2 specific variables.\n\</span>
<a name="l22333"></a>22333 <span class="stringliteral">Configure DWARF 2 variables such as the cache size&quot;</span>),
<a name="l22334"></a>22334                   &amp;set_dwarf2_cmdlist, <span class="stringliteral">&quot;maintenance set dwarf2 &quot;</span>,
<a name="l22335"></a>22335                   0<span class="comment">/*allow-unknown*/</span>, &amp;<a class="code" href="gdbcmd_8h.html#aa27d743f250ffebe48c59f2d5d90fe56">maintenance_set_cmdlist</a>);
<a name="l22336"></a>22336 
<a name="l22337"></a>22337   <a class="code" href="cli-decode_8c.html#a8abc1e9af59eb3cb12bb03977d5e8e5a">add_prefix_cmd</a> (<span class="stringliteral">&quot;dwarf2&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a502c7b57c7172ac88ef735f68070bb59">class_maintenance</a>, <a class="code" href="dwarf2read_8c.html#af786d765da20bc998403198a33d0b0bc">show_dwarf2_cmd</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22338"></a>22338 <span class="stringliteral">Show DWARF 2 specific variables\n\</span>
<a name="l22339"></a>22339 <span class="stringliteral">Show DWARF 2 variables such as the cache size&quot;</span>),
<a name="l22340"></a>22340                   &amp;show_dwarf2_cmdlist, <span class="stringliteral">&quot;maintenance show dwarf2 &quot;</span>,
<a name="l22341"></a>22341                   0<span class="comment">/*allow-unknown*/</span>, &amp;<a class="code" href="gdbcmd_8h.html#a1e64d63cab9816ec282e5369fb2743af">maintenance_show_cmdlist</a>);
<a name="l22342"></a>22342 
<a name="l22343"></a>22343   <a class="code" href="cli-decode_8c.html#abe99e440fc306f22620b97664e584cff">add_setshow_zinteger_cmd</a> (<span class="stringliteral">&quot;max-cache-age&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a4994a96ac693a93b56bf997637605172">class_obscure</a>,
<a name="l22344"></a>22344                             &amp;<a class="code" href="dwarf2read_8c.html#a1ebe9ac2a67f2df99ca92aacf6b25163">dwarf2_max_cache_age</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22345"></a>22345 <span class="stringliteral">Set the upper bound on the age of cached dwarf2 compilation units.&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22346"></a>22346 <span class="stringliteral">Show the upper bound on the age of cached dwarf2 compilation units.&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22347"></a>22347 <span class="stringliteral">A higher limit means that cached compilation units will be stored\n\</span>
<a name="l22348"></a>22348 <span class="stringliteral">in memory longer, and more total memory will be used.  Zero disables\n\</span>
<a name="l22349"></a>22349 <span class="stringliteral">caching, which can slow down startup.&quot;</span>),
<a name="l22350"></a>22350                             NULL,
<a name="l22351"></a>22351                             <a class="code" href="dwarf2read_8c.html#a7eec2ffafc31c744a6d30109558f32d7">show_dwarf2_max_cache_age</a>,
<a name="l22352"></a>22352                             &amp;set_dwarf2_cmdlist,
<a name="l22353"></a>22353                             &amp;show_dwarf2_cmdlist);
<a name="l22354"></a>22354 
<a name="l22355"></a>22355   <a class="code" href="cli-decode_8c.html#ad86a0f135b6c546ae7ffbb41fd72e14f">add_setshow_boolean_cmd</a> (<span class="stringliteral">&quot;always-disassemble&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a4994a96ac693a93b56bf997637605172">class_obscure</a>,
<a name="l22356"></a>22356                            &amp;dwarf2_always_disassemble, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22357"></a>22357 <span class="stringliteral">Set whether `info address&#39; always disassembles DWARF expressions.&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22358"></a>22358 <span class="stringliteral">Show whether `info address&#39; always disassembles DWARF expressions.&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22359"></a>22359 <span class="stringliteral">When enabled, DWARF expressions are always printed in an assembly-like\n\</span>
<a name="l22360"></a>22360 <span class="stringliteral">syntax.  When disabled, expressions will be printed in a more\n\</span>
<a name="l22361"></a>22361 <span class="stringliteral">conversational style, when possible.&quot;</span>),
<a name="l22362"></a>22362                            NULL,
<a name="l22363"></a>22363                            <a class="code" href="dwarf2read_8c.html#a318675240d651634b7ea4a0bc51f39db">show_dwarf2_always_disassemble</a>,
<a name="l22364"></a>22364                            &amp;set_dwarf2_cmdlist,
<a name="l22365"></a>22365                            &amp;show_dwarf2_cmdlist);
<a name="l22366"></a>22366 
<a name="l22367"></a>22367   <a class="code" href="cli-decode_8c.html#ad86a0f135b6c546ae7ffbb41fd72e14f">add_setshow_boolean_cmd</a> (<span class="stringliteral">&quot;dwarf2-read&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49afbf489a4abce7e8770b178aa54f0908b">no_class</a>, &amp;<a class="code" href="dwarf2read_8c.html#a56f6198ce7cc8a9e0c6cb55cd4d7dfb1">dwarf2_read_debug</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22368"></a>22368 <span class="stringliteral">Set debugging of the dwarf2 reader.&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22369"></a>22369 <span class="stringliteral">Show debugging of the dwarf2 reader.&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22370"></a>22370 <span class="stringliteral">When enabled, debugging messages are printed during dwarf2 reading\n\</span>
<a name="l22371"></a>22371 <span class="stringliteral">and symtab expansion.&quot;</span>),
<a name="l22372"></a>22372                             NULL,
<a name="l22373"></a>22373                             NULL,
<a name="l22374"></a>22374                             &amp;<a class="code" href="cli-cmds_8c.html#ae5f16c782e4a29124f3175f4a6285244">setdebuglist</a>, &amp;<a class="code" href="cli-cmds_8c.html#a7e2eed475764f70df1e9c0f5d2476a11">showdebuglist</a>);
<a name="l22375"></a>22375 
<a name="l22376"></a>22376   <a class="code" href="cli-decode_8c.html#ae32b914a6e0676efa41e6281007a75c1">add_setshow_zuinteger_cmd</a> (<span class="stringliteral">&quot;dwarf2-die&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49afbf489a4abce7e8770b178aa54f0908b">no_class</a>, &amp;<a class="code" href="dwarf2read_8c.html#a1a718830b2084a029498b587ad66aeae">dwarf2_die_debug</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22377"></a>22377 <span class="stringliteral">Set debugging of the dwarf2 DIE reader.&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22378"></a>22378 <span class="stringliteral">Show debugging of the dwarf2 DIE reader.&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22379"></a>22379 <span class="stringliteral">When enabled (non-zero), DIEs are dumped after they are read in.\n\</span>
<a name="l22380"></a>22380 <span class="stringliteral">The value is the maximum depth to print.&quot;</span>),
<a name="l22381"></a>22381                              NULL,
<a name="l22382"></a>22382                              NULL,
<a name="l22383"></a>22383                              &amp;<a class="code" href="cli-cmds_8c.html#ae5f16c782e4a29124f3175f4a6285244">setdebuglist</a>, &amp;<a class="code" href="cli-cmds_8c.html#a7e2eed475764f70df1e9c0f5d2476a11">showdebuglist</a>);
<a name="l22384"></a>22384 
<a name="l22385"></a>22385   <a class="code" href="cli-decode_8c.html#ad86a0f135b6c546ae7ffbb41fd72e14f">add_setshow_boolean_cmd</a> (<span class="stringliteral">&quot;check-physname&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49afbf489a4abce7e8770b178aa54f0908b">no_class</a>, &amp;<a class="code" href="dwarf2read_8c.html#ab19a913cb7d8473545da6cb3149bc1ad">check_physname</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22386"></a>22386 <span class="stringliteral">Set cross-checking of \&quot;physname\&quot; code against demangler.&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22387"></a>22387 <span class="stringliteral">Show cross-checking of \&quot;physname\&quot; code against demangler.&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22388"></a>22388 <span class="stringliteral">When enabled, GDB&#39;s internal \&quot;physname\&quot; code is checked against\n\</span>
<a name="l22389"></a>22389 <span class="stringliteral">the demangler.&quot;</span>),
<a name="l22390"></a>22390                            NULL, <a class="code" href="dwarf2read_8c.html#a34cdc651c467dd5b197ca21c67443d38">show_check_physname</a>,
<a name="l22391"></a>22391                            &amp;<a class="code" href="cli-cmds_8c.html#ae5f16c782e4a29124f3175f4a6285244">setdebuglist</a>, &amp;<a class="code" href="cli-cmds_8c.html#a7e2eed475764f70df1e9c0f5d2476a11">showdebuglist</a>);
<a name="l22392"></a>22392 
<a name="l22393"></a>22393   <a class="code" href="cli-decode_8c.html#ad86a0f135b6c546ae7ffbb41fd72e14f">add_setshow_boolean_cmd</a> (<span class="stringliteral">&quot;use-deprecated-index-sections&quot;</span>,
<a name="l22394"></a>22394                            <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49afbf489a4abce7e8770b178aa54f0908b">no_class</a>, &amp;<a class="code" href="dwarf2read_8c.html#a0a43a194f055955e1de1eb7be957096f">use_deprecated_index_sections</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22395"></a>22395 <span class="stringliteral">Set whether to use deprecated gdb_index sections.&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22396"></a>22396 <span class="stringliteral">Show whether to use deprecated gdb_index sections.&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22397"></a>22397 <span class="stringliteral">When enabled, deprecated .gdb_index sections are used anyway.\n\</span>
<a name="l22398"></a>22398 <span class="stringliteral">Normally they are ignored either because of a missing feature or\n\</span>
<a name="l22399"></a>22399 <span class="stringliteral">performance issue.\n\</span>
<a name="l22400"></a>22400 <span class="stringliteral">Warning: This option must be enabled before gdb reads the file.&quot;</span>),
<a name="l22401"></a>22401                            NULL,
<a name="l22402"></a>22402                            NULL,
<a name="l22403"></a>22403                            &amp;<a class="code" href="cli-cmds_8c.html#a723e0174d833cba0aa82fb936a56c8fa">setlist</a>, &amp;<a class="code" href="cli-cmds_8c.html#a003932aa76fd3f41763ecc6bee5e2ca8">showlist</a>);
<a name="l22404"></a>22404 
<a name="l22405"></a>22405   c = <a class="code" href="cli-decode_8c.html#ab87b0ba51ed9aa4c8aac0c96373537f8">add_cmd</a> (<span class="stringliteral">&quot;gdb-index&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49aea9c092d047271fd884ae32149463054">class_files</a>, <a class="code" href="dwarf2read_8c.html#ad72239689bc9e301102475f81b601926">save_gdb_index_command</a>,
<a name="l22406"></a>22406                <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l22407"></a>22407 <span class="stringliteral">Save a gdb-index file.\n\</span>
<a name="l22408"></a>22408 <span class="stringliteral">Usage: save gdb-index DIRECTORY&quot;</span>),
<a name="l22409"></a>22409                &amp;<a class="code" href="gdbcmd_8h.html#aa9a6709904be4a4e00f298a5642fe94d">save_cmdlist</a>);
<a name="l22410"></a>22410   <a class="code" href="command_8h.html#abe42a75e35cfa78e2574e94904d86713">set_cmd_completer</a> (c, filename_completer);
<a name="l22411"></a>22411 
<a name="l22412"></a>22412   <a class="code" href="dwarf2read_8c.html#a52b4c75a920c1e0dbff24148745bc8ca">dwarf2_locexpr_index</a> = <a class="code" href="symtab_8c.html#a37b32d626a0e02f0962d0346ec48f7b3">register_symbol_computed_impl</a> (<a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3afd4303a25cda7805900ce8212c67ed45">LOC_COMPUTED</a>,
<a name="l22413"></a>22413                                                         &amp;<a class="code" href="dwarf2loc_8c.html#a021ed37c90b827c41e9d72c587cd010c">dwarf2_locexpr_funcs</a>);
<a name="l22414"></a>22414   <a class="code" href="dwarf2read_8c.html#a3e79ed48463ba20f601bd45aebff27df">dwarf2_loclist_index</a> = <a class="code" href="symtab_8c.html#a37b32d626a0e02f0962d0346ec48f7b3">register_symbol_computed_impl</a> (<a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3afd4303a25cda7805900ce8212c67ed45">LOC_COMPUTED</a>,
<a name="l22415"></a>22415                                                         &amp;<a class="code" href="dwarf2loc_8c.html#a0f31346b783e6ee204e70124ed00374e">dwarf2_loclist_funcs</a>);
<a name="l22416"></a>22416 
<a name="l22417"></a>22417   <a class="code" href="dwarf2read_8c.html#a4cc0c49c12a38ac40188b11401c91db5">dwarf2_locexpr_block_index</a> = <a class="code" href="symtab_8c.html#a27dc3b928a1aa9915e8e7313e7fe69fb">register_symbol_block_impl</a> (<a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>,
<a name="l22418"></a>22418                                         &amp;<a class="code" href="dwarf2loc_8c.html#a9bbf30bfc7d8c4b8cb8870149c38fd7a">dwarf2_block_frame_base_locexpr_funcs</a>);
<a name="l22419"></a>22419   <a class="code" href="dwarf2read_8c.html#a5eb136e90359757c6d4c7769be39145a">dwarf2_loclist_block_index</a> = <a class="code" href="symtab_8c.html#a27dc3b928a1aa9915e8e7313e7fe69fb">register_symbol_block_impl</a> (<a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>,
<a name="l22420"></a>22420                                         &amp;<a class="code" href="dwarf2loc_8c.html#aee8e99475e8c370802f4c69eb603e83f">dwarf2_block_frame_base_loclist_funcs</a>);
<a name="l22421"></a>22421 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:13:25 for GDB (xrefs) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
