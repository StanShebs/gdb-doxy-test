<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (xrefs): /home/stan/gdb/src/gdb/varobj.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (xrefs)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/varobj.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="varobj_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Implementation of the GDB variable objects API.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 1999-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00006"></a>00006 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00007"></a>00007 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00008"></a>00008 <span class="comment">   (at your option) any later version.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00011"></a>00011 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00013"></a>00013 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00016"></a>00016 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;<a class="code" href="exceptions_8h.html">exceptions.h</a>&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="value_8h.html">value.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="expression_8h.html">expression.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="frame_8h.html">frame.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="language_8h.html">language.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="gdbcmd_8h.html">gdbcmd.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="block_8h.html">block.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="valprint_8h.html">valprint.h</a>&quot;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="gdb__assert_8h.html">gdb_assert.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="gdb__string_8h.html">gdb_string.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="gdb__regex_8h.html">gdb_regex.h</a>&quot;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="varobj_8h.html">varobj.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="vec_8h.html">vec.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="gdbthread_8h.html">gdbthread.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="inferior_8h.html">inferior.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="ada-varobj_8h.html">ada-varobj.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="ada-lang_8h.html">ada-lang.h</a>&quot;</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#if HAVE_PYTHON</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="python_8h.html">python/python.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="python-internal_8h.html">python/python-internal.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#else</span>
<a name="l00043"></a><a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">00043</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a>;
<a name="l00044"></a>00044 <span class="preprocessor">#endif</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>
<a name="l00046"></a>00046 <span class="comment">/* The names of varobjs representing anonymous structs or unions.  */</span>
<a name="l00047"></a><a class="code" href="varobj_8c.html#a1ded4c9d095bc960dfd094a418fe154e">00047</a> <span class="preprocessor">#define ANONYMOUS_STRUCT_NAME _(&quot;&lt;anonymous struct&gt;&quot;)</span>
<a name="l00048"></a><a class="code" href="varobj_8c.html#a291131d840192a1a42d0af2aa94f24bc">00048</a> <span class="preprocessor"></span><span class="preprocessor">#define ANONYMOUS_UNION_NAME _(&quot;&lt;anonymous union&gt;&quot;)</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span>
<a name="l00050"></a>00050 <span class="comment">/* Non-zero if we want to see trace of varobj level stuff.  */</span>
<a name="l00051"></a>00051 
<a name="l00052"></a><a class="code" href="varobj_8c.html#afc68a4a5062c47438bdd85051db7b6db">00052</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="mi-cmd-var_8c.html#afc68a4a5062c47438bdd85051db7b6db">varobjdebug</a> = 0;
<a name="l00053"></a>00053 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00054"></a><a class="code" href="varobj_8c.html#a971ec565816c402eae3ba1e56ff778a1">00054</a> <a class="code" href="varobj_8c.html#a971ec565816c402eae3ba1e56ff778a1">show_varobjdebug</a> (<span class="keyword">struct</span> <a class="code" href="structui__file.html">ui_file</a> *file, <span class="keywordtype">int</span> from_tty,
<a name="l00055"></a>00055                   <span class="keyword">struct</span> <a class="code" href="structcmd__list__element.html">cmd_list_element</a> *c, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structvalue.html">value</a>)
<a name="l00056"></a>00056 {
<a name="l00057"></a>00057   <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (file, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Varobj debugging is %s.\n&quot;</span>), value);
<a name="l00058"></a>00058 }
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="comment">/* String representations of gdb&#39;s format codes.  */</span>
<a name="l00061"></a><a class="code" href="varobj_8h.html#a31223293050509d6118ae831bab8d7b9">00061</a> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a31223293050509d6118ae831bab8d7b9">varobj_format_string</a>[] =
<a name="l00062"></a>00062   { <span class="stringliteral">&quot;natural&quot;</span>, <span class="stringliteral">&quot;binary&quot;</span>, <span class="stringliteral">&quot;decimal&quot;</span>, <span class="stringliteral">&quot;hexadecimal&quot;</span>, <span class="stringliteral">&quot;octal&quot;</span> };
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="comment">/* String representations of gdb&#39;s known languages.  */</span>
<a name="l00065"></a><a class="code" href="varobj_8h.html#afeced3dcbf22460533a28c4fbc986cae">00065</a> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#afeced3dcbf22460533a28c4fbc986cae">varobj_language_string</a>[] = { <span class="stringliteral">&quot;C&quot;</span>, <span class="stringliteral">&quot;C++&quot;</span>, <span class="stringliteral">&quot;Java&quot;</span> };
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="comment">/* True if we want to allow Python-based pretty-printing.  */</span>
<a name="l00068"></a><a class="code" href="varobj_8c.html#a2d0bd70e54ff2fa9e274811bcba8c6d4">00068</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#a2d0bd70e54ff2fa9e274811bcba8c6d4">pretty_printing</a> = 0;
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="keywordtype">void</span>
<a name="l00071"></a><a class="code" href="varobj_8h.html#a4b57ef86e077d648e49375d7962a9568">00071</a> <a class="code" href="varobj_8c.html#a4b57ef86e077d648e49375d7962a9568">varobj_enable_pretty_printing</a> (<span class="keywordtype">void</span>)
<a name="l00072"></a>00072 {
<a name="l00073"></a>00073   <a class="code" href="varobj_8c.html#a2d0bd70e54ff2fa9e274811bcba8c6d4">pretty_printing</a> = 1;
<a name="l00074"></a>00074 }
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 <span class="comment">/* Data structures */</span>
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="comment">/* Every root variable has one of these structures saved in its</span>
<a name="l00079"></a>00079 <span class="comment">   varobj.  Members which must be free&#39;d are noted.  */</span>
<a name="l00080"></a><a class="code" href="structvarobj__root.html">00080</a> <span class="keyword">struct </span><a class="code" href="structvarobj__root.html">varobj_root</a>
<a name="l00081"></a>00081 {
<a name="l00082"></a>00082 
<a name="l00083"></a>00083   <span class="comment">/* Alloc&#39;d expression for this parent.  */</span>
<a name="l00084"></a><a class="code" href="structvarobj__root.html#abb9c5396c5675b77105d7efd2c3572bd">00084</a>   <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *<a class="code" href="structvarobj__root.html#abb9c5396c5675b77105d7efd2c3572bd">exp</a>;
<a name="l00085"></a>00085 
<a name="l00086"></a>00086   <span class="comment">/* Block for which this expression is valid.  */</span>
<a name="l00087"></a><a class="code" href="structvarobj__root.html#a89718f4a2aa6dae685b475b76acb4ff3">00087</a>   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *<a class="code" href="structvarobj__root.html#a89718f4a2aa6dae685b475b76acb4ff3">valid_block</a>;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089   <span class="comment">/* The frame for this expression.  This field is set iff valid_block is</span>
<a name="l00090"></a>00090 <span class="comment">     not NULL.  */</span>
<a name="l00091"></a><a class="code" href="structvarobj__root.html#a59c4f568ee0ad41cfb78b2b57962212d">00091</a>   <span class="keyword">struct </span><a class="code" href="structframe__id.html">frame_id</a> <a class="code" href="structvarobj__root.html#a59c4f568ee0ad41cfb78b2b57962212d">frame</a>;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093   <span class="comment">/* The thread ID that this varobj_root belong to.  This field</span>
<a name="l00094"></a>00094 <span class="comment">     is only valid if valid_block is not NULL.</span>
<a name="l00095"></a>00095 <span class="comment">     When not 0, indicates which thread &#39;frame&#39; belongs to.</span>
<a name="l00096"></a>00096 <span class="comment">     When 0, indicates that the thread list was empty when the varobj_root</span>
<a name="l00097"></a>00097 <span class="comment">     was created.  */</span>
<a name="l00098"></a><a class="code" href="structvarobj__root.html#a08a1c7e9d5401654a7fa5fc5350dbd8d">00098</a>   <span class="keywordtype">int</span> <a class="code" href="structvarobj__root.html#a08a1c7e9d5401654a7fa5fc5350dbd8d">thread_id</a>;
<a name="l00099"></a>00099 
<a name="l00100"></a>00100   <span class="comment">/* If 1, the -var-update always recomputes the value in the</span>
<a name="l00101"></a>00101 <span class="comment">     current thread and frame.  Otherwise, variable object is</span>
<a name="l00102"></a>00102 <span class="comment">     always updated in the specific scope/thread/frame.  */</span>
<a name="l00103"></a><a class="code" href="structvarobj__root.html#ac463a0879fc5da996795332abce6357e">00103</a>   <span class="keywordtype">int</span> <a class="code" href="structvarobj__root.html#ac463a0879fc5da996795332abce6357e">floating</a>;
<a name="l00104"></a>00104 
<a name="l00105"></a>00105   <span class="comment">/* Flag that indicates validity: set to 0 when this varobj_root refers </span>
<a name="l00106"></a>00106 <span class="comment">     to symbols that do not exist anymore.  */</span>
<a name="l00107"></a><a class="code" href="structvarobj__root.html#a731ef8f5e5cd14c4b7b79e07207f3557">00107</a>   <span class="keywordtype">int</span> <a class="code" href="structvarobj__root.html#a731ef8f5e5cd14c4b7b79e07207f3557">is_valid</a>;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109   <span class="comment">/* Language info for this variable and its children.  */</span>
<a name="l00110"></a><a class="code" href="structvarobj__root.html#a39a1bc807d2c22964ce2b0748aa664ec">00110</a>   <span class="keyword">struct </span><a class="code" href="structlanguage__specific.html">language_specific</a> *<a class="code" href="structvarobj__root.html#a39a1bc807d2c22964ce2b0748aa664ec">lang</a>;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112   <span class="comment">/* The varobj for this root node.  */</span>
<a name="l00113"></a><a class="code" href="structvarobj__root.html#a97dad6ede27c5d6c37095510fa9ce93e">00113</a>   <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvarobj__root.html#a97dad6ede27c5d6c37095510fa9ce93e">rootvar</a>;
<a name="l00114"></a>00114 
<a name="l00115"></a>00115   <span class="comment">/* Next root variable */</span>
<a name="l00116"></a><a class="code" href="structvarobj__root.html#ad97dab9a8e9ac5c39caa4bf667d0e1c9">00116</a>   <span class="keyword">struct </span><a class="code" href="structvarobj__root.html">varobj_root</a> *<a class="code" href="structvarobj__root.html#ad97dab9a8e9ac5c39caa4bf667d0e1c9">next</a>;
<a name="l00117"></a>00117 };
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="comment">/* Every variable in the system has a structure of this type defined</span>
<a name="l00120"></a>00120 <span class="comment">   for it.  This structure holds all information necessary to manipulate</span>
<a name="l00121"></a>00121 <span class="comment">   a particular object variable.  Members which must be freed are noted.  */</span>
<a name="l00122"></a><a class="code" href="structvarobj.html">00122</a> <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a>
<a name="l00123"></a>00123 {
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   <span class="comment">/* Alloc&#39;d name of the variable for this object.  If this variable is a</span>
<a name="l00126"></a>00126 <span class="comment">     child, then this name will be the child&#39;s source name.</span>
<a name="l00127"></a>00127 <span class="comment">     (bar, not foo.bar).  */</span>
<a name="l00128"></a>00128   <span class="comment">/* NOTE: This is the &quot;expression&quot;.  */</span>
<a name="l00129"></a><a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">00129</a>   <span class="keywordtype">char</span> *<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>;
<a name="l00130"></a>00130 
<a name="l00131"></a>00131   <span class="comment">/* Alloc&#39;d expression for this child.  Can be used to create a</span>
<a name="l00132"></a>00132 <span class="comment">     root variable corresponding to this child.  */</span>
<a name="l00133"></a><a class="code" href="structvarobj.html#ab61f8b5cf72e56285b2c14a89aafc7ff">00133</a>   <span class="keywordtype">char</span> *<a class="code" href="structvarobj.html#ab61f8b5cf72e56285b2c14a89aafc7ff">path_expr</a>;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135   <span class="comment">/* The alloc&#39;d name for this variable&#39;s object.  This is here for</span>
<a name="l00136"></a>00136 <span class="comment">     convenience when constructing this object&#39;s children.  */</span>
<a name="l00137"></a><a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">00137</a>   <span class="keywordtype">char</span> *<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139   <span class="comment">/* Index of this variable in its parent or -1.  */</span>
<a name="l00140"></a><a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">00140</a>   <span class="keywordtype">int</span> <a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a>;
<a name="l00141"></a>00141 
<a name="l00142"></a>00142   <span class="comment">/* The type of this variable.  This can be NULL</span>
<a name="l00143"></a>00143 <span class="comment">     for artifial variable objects -- currently, the &quot;accessibility&quot; </span>
<a name="l00144"></a>00144 <span class="comment">     variable objects in C++.  */</span>
<a name="l00145"></a><a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">00145</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>;
<a name="l00146"></a>00146 
<a name="l00147"></a>00147   <span class="comment">/* The value of this expression or subexpression.  A NULL value</span>
<a name="l00148"></a>00148 <span class="comment">     indicates there was an error getting this value.</span>
<a name="l00149"></a>00149 <span class="comment">     Invariant: if varobj_value_is_changeable_p (this) is non-zero, </span>
<a name="l00150"></a>00150 <span class="comment">     the value is either NULL, or not lazy.  */</span>
<a name="l00151"></a><a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">00151</a>   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153   <span class="comment">/* The number of (immediate) children this variable has.  */</span>
<a name="l00154"></a><a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">00154</a>   <span class="keywordtype">int</span> <a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a>;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   <span class="comment">/* If this object is a child, this points to its immediate parent.  */</span>
<a name="l00157"></a><a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">00157</a>   <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159   <span class="comment">/* Children of this object.  */</span>
<a name="l00160"></a>00160   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj.html">varobj_p</a>) *children;
<a name="l00161"></a>00161 
<a name="l00162"></a>00162   <span class="comment">/* Whether the children of this varobj were requested.  This field is</span>
<a name="l00163"></a>00163 <span class="comment">     used to decide if dynamic varobj should recompute their children.</span>
<a name="l00164"></a>00164 <span class="comment">     In the event that the frontend never asked for the children, we</span>
<a name="l00165"></a>00165 <span class="comment">     can avoid that.  */</span>
<a name="l00166"></a>00166   <span class="keywordtype">int</span> children_requested;
<a name="l00167"></a>00167 
<a name="l00168"></a>00168   <span class="comment">/* Description of the root variable.  Points to root variable for</span>
<a name="l00169"></a>00169 <span class="comment">     children.  */</span>
<a name="l00170"></a>00170   <span class="keyword">struct </span><a class="code" href="structvarobj__root.html">varobj_root</a> *root;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172   <span class="comment">/* The format of the output for this object.  */</span>
<a name="l00173"></a>00173   <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format;
<a name="l00174"></a>00174 
<a name="l00175"></a>00175   <span class="comment">/* Was this variable updated via a varobj_set_value operation.  */</span>
<a name="l00176"></a>00176   <span class="keywordtype">int</span> updated;
<a name="l00177"></a>00177 
<a name="l00178"></a>00178   <span class="comment">/* Last print value.  */</span>
<a name="l00179"></a>00179   <span class="keywordtype">char</span> *print_value;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181   <span class="comment">/* Is this variable frozen.  Frozen variables are never implicitly</span>
<a name="l00182"></a>00182 <span class="comment">     updated by -var-update * </span>
<a name="l00183"></a>00183 <span class="comment">     or -var-update &lt;direct-or-indirect-parent&gt;.  */</span>
<a name="l00184"></a>00184   <span class="keywordtype">int</span> frozen;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186   <span class="comment">/* Is the value of this variable intentionally not fetched?  It is</span>
<a name="l00187"></a>00187 <span class="comment">     not fetched if either the variable is frozen, or any parents is</span>
<a name="l00188"></a>00188 <span class="comment">     frozen.  */</span>
<a name="l00189"></a>00189   <span class="keywordtype">int</span> not_fetched;
<a name="l00190"></a>00190 
<a name="l00191"></a>00191   <span class="comment">/* Sub-range of children which the MI consumer has requested.  If</span>
<a name="l00192"></a>00192 <span class="comment">     FROM &lt; 0 or TO &lt; 0, means that all children have been</span>
<a name="l00193"></a>00193 <span class="comment">     requested.  */</span>
<a name="l00194"></a>00194   <span class="keywordtype">int</span> <a class="code" href="varobj_8h.html#a43396decd62b46fa01cc6c66a84cbba1">from</a>;
<a name="l00195"></a>00195   <span class="keywordtype">int</span> <a class="code" href="varobj_8h.html#ae2a2635825813434f3201bf8ace439d2">to</a>;
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   <span class="comment">/* The pretty-printer constructor.  If NULL, then the default</span>
<a name="l00198"></a>00198 <span class="comment">     pretty-printer will be looked up.  If None, then no</span>
<a name="l00199"></a>00199 <span class="comment">     pretty-printer will be installed.  */</span>
<a name="l00200"></a>00200   <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *constructor;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202   <span class="comment">/* The pretty-printer that has been constructed.  If NULL, then a</span>
<a name="l00203"></a>00203 <span class="comment">     new printer object is needed, and one will be constructed.  */</span>
<a name="l00204"></a>00204   <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *pretty_printer;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206   <span class="comment">/* The iterator returned by the printer&#39;s &#39;children&#39; method, or NULL</span>
<a name="l00207"></a>00207 <span class="comment">     if not available.  */</span>
<a name="l00208"></a>00208   <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *child_iter;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210   <span class="comment">/* We request one extra item from the iterator, so that we can</span>
<a name="l00211"></a>00211 <span class="comment">     report to the caller whether there are more items than we have</span>
<a name="l00212"></a>00212 <span class="comment">     already reported.  However, we don&#39;t want to install this value</span>
<a name="l00213"></a>00213 <span class="comment">     when we read it, because that will mess up future updates.  So,</span>
<a name="l00214"></a>00214 <span class="comment">     we stash it here instead.  */</span>
<a name="l00215"></a>00215   <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *saved_item;
<a name="l00216"></a>00216 };
<a name="l00217"></a>00217 
<a name="l00218"></a><a class="code" href="structcpstack.html">00218</a> <span class="keyword">struct </span><a class="code" href="structcpstack.html">cpstack</a>
<a name="l00219"></a>00219 {
<a name="l00220"></a><a class="code" href="structcpstack.html#ad3a04b9c0df5fcbc898c4870fa40228c">00220</a>   <span class="keywordtype">char</span> *<a class="code" href="structcpstack.html#ad3a04b9c0df5fcbc898c4870fa40228c">name</a>;
<a name="l00221"></a><a class="code" href="structcpstack.html#af3f2cee7f0e4215ac2baf41ccd155abd">00221</a>   <span class="keyword">struct </span><a class="code" href="structcpstack.html">cpstack</a> *<a class="code" href="structcpstack.html#af3f2cee7f0e4215ac2baf41ccd155abd">next</a>;
<a name="l00222"></a>00222 };
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="comment">/* A list of varobjs */</span>
<a name="l00225"></a>00225 
<a name="l00226"></a><a class="code" href="structvlist.html">00226</a> <span class="keyword">struct </span><a class="code" href="structvlist.html">vlist</a>
<a name="l00227"></a>00227 {
<a name="l00228"></a><a class="code" href="structvlist.html#a989a752791ea1c5e6a39f54d5c3e95ea">00228</a>   <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvlist.html#a989a752791ea1c5e6a39f54d5c3e95ea">var</a>;
<a name="l00229"></a><a class="code" href="structvlist.html#a7dd37f43fcb9fdd0b9be8120351ecd35">00229</a>   <span class="keyword">struct </span><a class="code" href="structvlist.html">vlist</a> *<a class="code" href="structvlist.html#a7dd37f43fcb9fdd0b9be8120351ecd35">next</a>;
<a name="l00230"></a>00230 };
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="comment">/* Private function prototypes */</span>
<a name="l00233"></a>00233 
<a name="l00234"></a>00234 <span class="comment">/* Helper functions for the above subcommands.  */</span>
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#a5bac0fb8c5ac5ede15933184f2f89773">delete_variable</a> (<span class="keyword">struct</span> <a class="code" href="structcpstack.html">cpstack</a> **, <span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *, <span class="keywordtype">int</span>);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="varobj_8c.html#a063f79374b8c6be2c1c874f0d206bfa1">delete_variable_1</a> (<span class="keyword">struct</span> <a class="code" href="structcpstack.html">cpstack</a> **, <span class="keywordtype">int</span> *,
<a name="l00239"></a>00239                                <span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#add625a61acb44538c0b77386e3ee3549">install_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *);
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="varobj_8c.html#a264e1d570d50a82637b9db01b6942b8c">uninstall_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *);
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="varobj_8c.html#a71f5081f79774cddee55f2f21e2cbd89">create_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *, <span class="keywordtype">int</span>, <span class="keywordtype">char</span> *);
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *
<a name="l00248"></a>00248 <a class="code" href="varobj_8c.html#acfb70e4ed6d65d2a5c4f3d52704ba120">create_child_with_value</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>, <span class="keywordtype">int</span> <a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a>, <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>,
<a name="l00249"></a>00249                          <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html">value</a>);
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="comment">/* Utility routines */</span>
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="varobj_8c.html#a774a73e3ab9589f011263b9f2e73373f">new_variable</a> (<span class="keywordtype">void</span>);
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="varobj_8c.html#aa0e604dda78dda203375d9a8b4eaec13">new_root_variable</a> (<span class="keywordtype">void</span>);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="varobj_8c.html#aae21f5f363047cc373a24db2068908a2">free_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="varobj_8c.html#ac48cf109645d59e26f82fef51512080e">make_cleanup_free_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="varobj_8c.html#a5baa378edebe1c85afe1e15b83cb7036">get_type</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="varobj_8c.html#adfcd4a24453cf037bb031b39a4a87051">get_value_type</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="varobj_8c.html#a85a491516094c4258b1fb5251108ac56">get_target_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> <a class="code" href="varobj_8c.html#a1d817018a901fd63af42784cfcdff001">variable_default_display</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *);
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="varobj_8c.html#ae93a42ae116f3c1fba220ffee78bb823">cppush</a> (<span class="keyword">struct</span> <a class="code" href="structcpstack.html">cpstack</a> **pstack, <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>);
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#add31048dd86ce1966513b25acf18a1f5">cppop</a> (<span class="keyword">struct</span> <a class="code" href="structcpstack.html">cpstack</a> **pstack);
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#a8de9d1ed628fd6139ef82609d3b3460a">update_type_if_necessary</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var,
<a name="l00274"></a>00274                                      <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *new_value);
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#acb8313007f98eac3c62634057219329d">install_new_value</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html">value</a>, 
<a name="l00277"></a>00277                               <span class="keywordtype">int</span> initial);
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="comment">/* Language-specific routines.  */</span>
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a8f290bc3f9b2441d6fd55bd85dd774bb">varobj_languages</a> <a class="code" href="varobj_8c.html#a2e77519a3fba8c0ddec2cf0418d7a9a4">variable_language</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#a32afd58f9f6ae8fb1e404873904dee3b">number_of_children</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *);
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a740212f7a93a8de29f093ae56681a75f">name_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *);
<a name="l00286"></a>00286 
<a name="l00287"></a>00287 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#aa197bbfcee05a8c063d1a0ec7469686d">name_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *, <span class="keywordtype">int</span>);
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="varobj_8c.html#ad9e8c230e67c9e52f1f4aaaceae075f0">value_of_root</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> **var_handle, <span class="keywordtype">int</span> *);
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="varobj_8c.html#af2a5adec143186b5712eb28d0e415b18">value_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvalue.html#ac5784dc092188f21d4d2a0e041a8eeb8">parent</a>, <span class="keywordtype">int</span> index);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a2af60930bf1939550552e6c1fc1096eb">my_value_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var,
<a name="l00294"></a>00294                                    <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format);
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a371cbd65da3254826f01cbf5fd49380c">value_get_print_value</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html">value</a>,
<a name="l00297"></a>00297                                     <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format,
<a name="l00298"></a>00298                                     <span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#a176f5fae4079ee6acd5df422bd0e8f4c">varobj_value_is_changeable_p</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#ac5da1ead02d1559acf6836dcc1dbc4cc">is_root_p</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="preprocessor">#if HAVE_PYTHON</span>
<a name="l00305"></a>00305 <span class="preprocessor"></span>
<a name="l00306"></a>00306 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *varobj_add_child (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var,
<a name="l00307"></a>00307                                         <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>,
<a name="l00308"></a>00308                                         <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html">value</a>);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_PYTHON */</span>
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#af62c3759117b3e5c21282af5feebf900">default_value_is_changeable_p</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="comment">/* C implementation */</span>
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#a93be4a4467a71d4ae477004e046cd9c4">c_number_of_children</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a2bc7d2f38b881b4804eaa48689157f86">c_name_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>);
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a523e2edf45a9d7224dd794e5b565eb9f">c_name_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>, <span class="keywordtype">int</span> <a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a>);
<a name="l00321"></a>00321 
<a name="l00322"></a>00322 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a1677912a52e03718e5bbc35994d798c0">c_path_expr_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *child);
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="varobj_8c.html#a636a775a47d725845dc1789f239c38a3">c_value_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvalue.html#ac5784dc092188f21d4d2a0e041a8eeb8">parent</a>, <span class="keywordtype">int</span> index);
<a name="l00325"></a>00325 
<a name="l00326"></a>00326 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="varobj_8c.html#a3ebc9804af884141b5b629f44240474a">c_type_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index);
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#afca0a4e2739302b7e3765b109534456b">c_value_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var,
<a name="l00329"></a>00329                                   <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format);
<a name="l00330"></a>00330 
<a name="l00331"></a>00331 <span class="comment">/* C++ implementation */</span>
<a name="l00332"></a>00332 
<a name="l00333"></a>00333 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#a4d07d53309859f9d2ed11280ac02bca2">cplus_number_of_children</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="varobj_8c.html#a50fade750b99399700ac5cd7b8f323b7">cplus_class_num_children</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keywordtype">int</span> children[3]);
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#abad2466059754f7294840f7443314f28">cplus_name_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent);
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#aaff0d8a45eea54f86008630023672eed">cplus_name_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index);
<a name="l00340"></a>00340 
<a name="l00341"></a>00341 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a6197ee374a6131e8b922143c68a77d2d">cplus_path_expr_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *child);
<a name="l00342"></a>00342 
<a name="l00343"></a>00343 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="varobj_8c.html#a09425460afc0835494e6ed80e3242f96">cplus_value_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvalue.html#ac5784dc092188f21d4d2a0e041a8eeb8">parent</a>, <span class="keywordtype">int</span> index);
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="varobj_8c.html#abe513c2ef410c2f8ac7e47ac72fe63f2">cplus_type_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index);
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a7c20f6a85a26760a76cd2c64fa7de576">cplus_value_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var,
<a name="l00348"></a>00348                                       <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 <span class="comment">/* Java implementation */</span>
<a name="l00351"></a>00351 
<a name="l00352"></a>00352 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#ad63b2017cbb7326cd7932c7a8b3f58f0">java_number_of_children</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a07b77d8926dd890a75fbac58048feeba">java_name_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent);
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a964e240730875329f131fc30a7c8cef5">java_name_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index);
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a706fb98989fdc56fe395dec277e4ec6b">java_path_expr_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *child);
<a name="l00359"></a>00359 
<a name="l00360"></a>00360 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="varobj_8c.html#a72046d52de1c043aa0e32bd706ec1ff2">java_value_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvalue.html#ac5784dc092188f21d4d2a0e041a8eeb8">parent</a>, <span class="keywordtype">int</span> index);
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="varobj_8c.html#a90610da40cc2e3efa2b9068e2b346f73">java_type_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a455f4af866f3640d08dec9bfe34f1788">java_value_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var,
<a name="l00365"></a>00365                                      <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format);
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 <span class="comment">/* Ada implementation */</span>
<a name="l00368"></a>00368 
<a name="l00369"></a>00369 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#aeadc13ce28b31041f0e96a73d85307a5">ada_number_of_children</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#ac67f2fc0cf079e0f0316d3276a6d710a">ada_name_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent);
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a6ba428c3a41023df8391fd361826e58a">ada_name_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index);
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a20ee53aa83e0d6303420eb92e484ee41">ada_path_expr_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *child);
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="varobj_8c.html#ada56bb6b78f2b50b76b1fb7cd26a450f">ada_value_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvalue.html#ac5784dc092188f21d4d2a0e041a8eeb8">parent</a>, <span class="keywordtype">int</span> index);
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="varobj_8c.html#afe0ad236431f504db5d4fbef9752d9fc">ada_type_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index);
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="varobj_8c.html#a9600d2bf586a6b5171f53189566b2386">ada_value_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var,
<a name="l00382"></a>00382                                     <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format);
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#a0649356dd5db401f7860403e675526e9">ada_value_is_changeable_p</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00385"></a>00385 
<a name="l00386"></a>00386 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#a74d9c9a183ca53bac1e660f541030e45">ada_value_has_mutated</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *new_val,
<a name="l00387"></a>00387                                   <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="mdebugread_8c.html#ab1ece714ac6020a52b26279dfc1b20d7">new_type</a>);
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 <span class="comment">/* The language specific vector */</span>
<a name="l00390"></a>00390 
<a name="l00391"></a><a class="code" href="structlanguage__specific.html">00391</a> <span class="keyword">struct </span><a class="code" href="structlanguage__specific.html">language_specific</a>
<a name="l00392"></a>00392 {
<a name="l00393"></a>00393   <span class="comment">/* The number of children of PARENT.  */</span>
<a name="l00394"></a><a class="code" href="structlanguage__specific.html#aa12184e87ff8749720eeca588e68a204">00394</a>   <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structlanguage__specific.html#aa12184e87ff8749720eeca588e68a204">number_of_children</a>) (<span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> * <a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>);
<a name="l00395"></a>00395 
<a name="l00396"></a>00396   <span class="comment">/* The name (expression) of a root varobj.  */</span>
<a name="l00397"></a><a class="code" href="structlanguage__specific.html#af82761efdc01eb33d791e96f000ab79a">00397</a>   <span class="keywordtype">char</span> *(*name_of_variable) (<span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> * <a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>);
<a name="l00398"></a>00398 
<a name="l00399"></a>00399   <span class="comment">/* The name of the INDEX&#39;th child of PARENT.  */</span>
<a name="l00400"></a><a class="code" href="structlanguage__specific.html#a8e3584174ed3e953e82d34fe76a5b68e">00400</a>   <span class="keywordtype">char</span> *(*name_of_child) (<span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> * <a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>, <span class="keywordtype">int</span> <a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a>);
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   <span class="comment">/* Returns the rooted expression of CHILD, which is a variable</span>
<a name="l00403"></a>00403 <span class="comment">     obtain that has some parent.  */</span>
<a name="l00404"></a><a class="code" href="structlanguage__specific.html#ad06a6c9fa2030ed4ac6449b3965070d3">00404</a>   <span class="keywordtype">char</span> *(*path_expr_of_child) (<span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> * child);
<a name="l00405"></a>00405 
<a name="l00406"></a>00406   <span class="comment">/* The ``struct value *&#39;&#39; of the INDEX&#39;th child of PARENT.  */</span>
<a name="l00407"></a><a class="code" href="structlanguage__specific.html#a918c0b4866333f13d13c9fddb22404ec">00407</a>   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *(*value_of_child) (<span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> * <a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>, <span class="keywordtype">int</span> <a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a>);
<a name="l00408"></a>00408 
<a name="l00409"></a>00409   <span class="comment">/* The type of the INDEX&#39;th child of PARENT.  */</span>
<a name="l00410"></a><a class="code" href="structlanguage__specific.html#af526c121ba014f63fad23148a36e67f7">00410</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *(*type_of_child) (<span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> * <a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>, <span class="keywordtype">int</span> <a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a>);
<a name="l00411"></a>00411 
<a name="l00412"></a>00412   <span class="comment">/* The current value of VAR.  */</span>
<a name="l00413"></a><a class="code" href="structlanguage__specific.html#a92401663ab81dc8a20b84a59cde0990c">00413</a>   <span class="keywordtype">char</span> *(*value_of_variable) (<span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> * var,
<a name="l00414"></a>00414                               <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format);
<a name="l00415"></a>00415 
<a name="l00416"></a>00416   <span class="comment">/* Return non-zero if changes in value of VAR must be detected and</span>
<a name="l00417"></a>00417 <span class="comment">     reported by -var-update.  Return zero if -var-update should never</span>
<a name="l00418"></a>00418 <span class="comment">     report changes of such values.  This makes sense for structures</span>
<a name="l00419"></a>00419 <span class="comment">     (since the changes in children values will be reported separately),</span>
<a name="l00420"></a>00420 <span class="comment">     or for artifical objects (like &#39;public&#39; pseudo-field in C++).</span>
<a name="l00421"></a>00421 <span class="comment"></span>
<a name="l00422"></a>00422 <span class="comment">     Return value of 0 means that gdb need not call value_fetch_lazy</span>
<a name="l00423"></a>00423 <span class="comment">     for the value of this variable object.  */</span>
<a name="l00424"></a><a class="code" href="structlanguage__specific.html#adf27bea4c24dd4b67cbe6b296c9cd39f">00424</a>   <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structlanguage__specific.html#adf27bea4c24dd4b67cbe6b296c9cd39f">value_is_changeable_p</a>) (<span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *var);
<a name="l00425"></a>00425 
<a name="l00426"></a>00426   <span class="comment">/* Return nonzero if the type of VAR has mutated.</span>
<a name="l00427"></a>00427 <span class="comment"></span>
<a name="l00428"></a>00428 <span class="comment">     VAR&#39;s value is still the varobj&#39;s previous value, while NEW_VALUE</span>
<a name="l00429"></a>00429 <span class="comment">     is VAR&#39;s new value and NEW_TYPE is the var&#39;s new type.  NEW_VALUE</span>
<a name="l00430"></a>00430 <span class="comment">     may be NULL indicating that there is no value available (the varobj</span>
<a name="l00431"></a>00431 <span class="comment">     may be out of scope, of may be the child of a null pointer, for</span>
<a name="l00432"></a>00432 <span class="comment">     instance).  NEW_TYPE, on the other hand, must never be NULL.</span>
<a name="l00433"></a>00433 <span class="comment"></span>
<a name="l00434"></a>00434 <span class="comment">     This function should also be able to assume that var&#39;s number of</span>
<a name="l00435"></a>00435 <span class="comment">     children is set (not &lt; 0).</span>
<a name="l00436"></a>00436 <span class="comment"></span>
<a name="l00437"></a>00437 <span class="comment">     Languages where types do not mutate can set this to NULL.  */</span>
<a name="l00438"></a><a class="code" href="structlanguage__specific.html#a8e450a9e2a3249d4935bb1656dec59ef">00438</a>   <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structlanguage__specific.html#a8e450a9e2a3249d4935bb1656dec59ef">value_has_mutated</a>) (<span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *var, <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *new_value,
<a name="l00439"></a>00439                             <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="mdebugread_8c.html#ab1ece714ac6020a52b26279dfc1b20d7">new_type</a>);
<a name="l00440"></a>00440 };
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="comment">/* Array of known source language routines.  */</span>
<a name="l00443"></a><a class="code" href="varobj_8c.html#ae0c280bf4be18e0be1c77423198ddcd2">00443</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structlanguage__specific.html">language_specific</a> <a class="code" href="varobj_8c.html#ae0c280bf4be18e0be1c77423198ddcd2">languages</a>[<a class="code" href="varobj_8h.html#a8f290bc3f9b2441d6fd55bd85dd774bbaeaeedd1b5d44d3f5691023e287f1d2a8">vlang_end</a>] = {
<a name="l00444"></a>00444   <span class="comment">/* C */</span>
<a name="l00445"></a>00445   {
<a name="l00446"></a>00446    <a class="code" href="varobj_8c.html#a93be4a4467a71d4ae477004e046cd9c4">c_number_of_children</a>,
<a name="l00447"></a>00447    <a class="code" href="varobj_8c.html#a2bc7d2f38b881b4804eaa48689157f86">c_name_of_variable</a>,
<a name="l00448"></a>00448    <a class="code" href="varobj_8c.html#a523e2edf45a9d7224dd794e5b565eb9f">c_name_of_child</a>,
<a name="l00449"></a>00449    <a class="code" href="varobj_8c.html#a1677912a52e03718e5bbc35994d798c0">c_path_expr_of_child</a>,
<a name="l00450"></a>00450    <a class="code" href="varobj_8c.html#a636a775a47d725845dc1789f239c38a3">c_value_of_child</a>,
<a name="l00451"></a>00451    <a class="code" href="varobj_8c.html#a3ebc9804af884141b5b629f44240474a">c_type_of_child</a>,
<a name="l00452"></a>00452    <a class="code" href="varobj_8c.html#afca0a4e2739302b7e3765b109534456b">c_value_of_variable</a>,
<a name="l00453"></a>00453    <a class="code" href="varobj_8c.html#af62c3759117b3e5c21282af5feebf900">default_value_is_changeable_p</a>,
<a name="l00454"></a>00454    NULL <span class="comment">/* value_has_mutated */</span>}
<a name="l00455"></a>00455   ,
<a name="l00456"></a>00456   <span class="comment">/* C++ */</span>
<a name="l00457"></a>00457   {
<a name="l00458"></a>00458    <a class="code" href="varobj_8c.html#a4d07d53309859f9d2ed11280ac02bca2">cplus_number_of_children</a>,
<a name="l00459"></a>00459    <a class="code" href="varobj_8c.html#abad2466059754f7294840f7443314f28">cplus_name_of_variable</a>,
<a name="l00460"></a>00460    <a class="code" href="varobj_8c.html#aaff0d8a45eea54f86008630023672eed">cplus_name_of_child</a>,
<a name="l00461"></a>00461    <a class="code" href="varobj_8c.html#a6197ee374a6131e8b922143c68a77d2d">cplus_path_expr_of_child</a>,
<a name="l00462"></a>00462    <a class="code" href="varobj_8c.html#a09425460afc0835494e6ed80e3242f96">cplus_value_of_child</a>,
<a name="l00463"></a>00463    <a class="code" href="varobj_8c.html#abe513c2ef410c2f8ac7e47ac72fe63f2">cplus_type_of_child</a>,
<a name="l00464"></a>00464    <a class="code" href="varobj_8c.html#a7c20f6a85a26760a76cd2c64fa7de576">cplus_value_of_variable</a>,
<a name="l00465"></a>00465    <a class="code" href="varobj_8c.html#af62c3759117b3e5c21282af5feebf900">default_value_is_changeable_p</a>,
<a name="l00466"></a>00466    NULL <span class="comment">/* value_has_mutated */</span>}
<a name="l00467"></a>00467   ,
<a name="l00468"></a>00468   <span class="comment">/* Java */</span>
<a name="l00469"></a>00469   {
<a name="l00470"></a>00470    <a class="code" href="varobj_8c.html#ad63b2017cbb7326cd7932c7a8b3f58f0">java_number_of_children</a>,
<a name="l00471"></a>00471    <a class="code" href="varobj_8c.html#a07b77d8926dd890a75fbac58048feeba">java_name_of_variable</a>,
<a name="l00472"></a>00472    <a class="code" href="varobj_8c.html#a964e240730875329f131fc30a7c8cef5">java_name_of_child</a>,
<a name="l00473"></a>00473    <a class="code" href="varobj_8c.html#a706fb98989fdc56fe395dec277e4ec6b">java_path_expr_of_child</a>,
<a name="l00474"></a>00474    <a class="code" href="varobj_8c.html#a72046d52de1c043aa0e32bd706ec1ff2">java_value_of_child</a>,
<a name="l00475"></a>00475    <a class="code" href="varobj_8c.html#a90610da40cc2e3efa2b9068e2b346f73">java_type_of_child</a>,
<a name="l00476"></a>00476    <a class="code" href="varobj_8c.html#a455f4af866f3640d08dec9bfe34f1788">java_value_of_variable</a>,
<a name="l00477"></a>00477    <a class="code" href="varobj_8c.html#af62c3759117b3e5c21282af5feebf900">default_value_is_changeable_p</a>,
<a name="l00478"></a>00478    NULL <span class="comment">/* value_has_mutated */</span>},
<a name="l00479"></a>00479   <span class="comment">/* Ada */</span>
<a name="l00480"></a>00480   {
<a name="l00481"></a>00481    <a class="code" href="varobj_8c.html#aeadc13ce28b31041f0e96a73d85307a5">ada_number_of_children</a>,
<a name="l00482"></a>00482    <a class="code" href="varobj_8c.html#ac67f2fc0cf079e0f0316d3276a6d710a">ada_name_of_variable</a>,
<a name="l00483"></a>00483    <a class="code" href="varobj_8c.html#a6ba428c3a41023df8391fd361826e58a">ada_name_of_child</a>,
<a name="l00484"></a>00484    <a class="code" href="varobj_8c.html#a20ee53aa83e0d6303420eb92e484ee41">ada_path_expr_of_child</a>,
<a name="l00485"></a>00485    <a class="code" href="varobj_8c.html#ada56bb6b78f2b50b76b1fb7cd26a450f">ada_value_of_child</a>,
<a name="l00486"></a>00486    <a class="code" href="varobj_8c.html#afe0ad236431f504db5d4fbef9752d9fc">ada_type_of_child</a>,
<a name="l00487"></a>00487    <a class="code" href="varobj_8c.html#a9600d2bf586a6b5171f53189566b2386">ada_value_of_variable</a>,
<a name="l00488"></a>00488    <a class="code" href="varobj_8c.html#a0649356dd5db401f7860403e675526e9">ada_value_is_changeable_p</a>,
<a name="l00489"></a>00489    <a class="code" href="varobj_8c.html#a74d9c9a183ca53bac1e660f541030e45">ada_value_has_mutated</a>}
<a name="l00490"></a>00490 };
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 <span class="comment">/* A little convenience enum for dealing with C++/Java.  */</span>
<a name="l00493"></a><a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984">00493</a> <span class="keyword">enum</span> <a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984">vsections</a>
<a name="l00494"></a>00494 {
<a name="l00495"></a><a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984aded822271e6e2ca89807fc505617d2d4">00495</a>   <a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984aded822271e6e2ca89807fc505617d2d4">v_public</a> = 0, <a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984ab64e583fec7c654b8870660c15d7fefa">v_private</a>, <a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984a1ac503b9138f4438afe3faf53fd55311">v_protected</a>
<a name="l00496"></a>00496 };
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 <span class="comment">/* Private data */</span>
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 <span class="comment">/* Mappings of varobj_display_formats enums to gdb&#39;s format codes.  */</span>
<a name="l00501"></a><a class="code" href="varobj_8c.html#adc4d9de429cbfa905ad9962a7e4daf8e">00501</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="varobj_8c.html#adc4d9de429cbfa905ad9962a7e4daf8e">format_code</a>[] = { 0, <span class="charliteral">&#39;t&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;o&#39;</span> };
<a name="l00502"></a>00502 
<a name="l00503"></a>00503 <span class="comment">/* Header of the list of root variable objects.  */</span>
<a name="l00504"></a><a class="code" href="varobj_8c.html#a01b646c8a559f17017d7326f4c885f63">00504</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvarobj__root.html">varobj_root</a> *<a class="code" href="varobj_8c.html#a01b646c8a559f17017d7326f4c885f63">rootlist</a>;
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 <span class="comment">/* Prime number indicating the number of buckets in the hash table.  */</span>
<a name="l00507"></a>00507 <span class="comment">/* A prime large enough to avoid too many colisions.  */</span>
<a name="l00508"></a><a class="code" href="varobj_8c.html#a3e3ade9793c5199bc838ac530297268d">00508</a> <span class="preprocessor">#define VAROBJ_TABLE_SIZE 227</span>
<a name="l00509"></a>00509 <span class="preprocessor"></span>
<a name="l00510"></a>00510 <span class="comment">/* Pointer to the varobj hash table (built at run time).  */</span>
<a name="l00511"></a><a class="code" href="varobj_8c.html#a48000b5dcf830755100f4c6d0eb1bec0">00511</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvlist.html">vlist</a> **<a class="code" href="varobj_8c.html#a48000b5dcf830755100f4c6d0eb1bec0">varobj_table</a>;
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 <span class="comment">/* Is the variable X one of our &quot;fake&quot; children?  */</span>
<a name="l00514"></a><a class="code" href="varobj_8c.html#a0af68d4c2837464c18ae1eb457749c7d">00514</a> <span class="preprocessor">#define CPLUS_FAKE_CHILD(x) \</span>
<a name="l00515"></a>00515 <span class="preprocessor">((x) != NULL &amp;&amp; (x)-&gt;type == NULL &amp;&amp; (x)-&gt;value == NULL)</span>
<a name="l00516"></a>00516 <span class="preprocessor"></span>
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 <span class="comment">/* API Implementation */</span>
<a name="l00519"></a>00519 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00520"></a><a class="code" href="varobj_8c.html#ac5da1ead02d1559acf6836dcc1dbc4cc">00520</a> <a class="code" href="varobj_8c.html#ac5da1ead02d1559acf6836dcc1dbc4cc">is_root_p</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvlist.html#a989a752791ea1c5e6a39f54d5c3e95ea">var</a>)
<a name="l00521"></a>00521 {
<a name="l00522"></a>00522   <span class="keywordflow">return</span> (var-&gt;root-&gt;rootvar == var);
<a name="l00523"></a>00523 }
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 <span class="preprocessor">#ifdef HAVE_PYTHON</span>
<a name="l00526"></a>00526 <span class="preprocessor"></span><span class="comment">/* Helper function to install a Python environment suitable for</span>
<a name="l00527"></a>00527 <span class="comment">   use during operations on VAR.  */</span>
<a name="l00528"></a>00528 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *
<a name="l00529"></a>00529 varobj_ensure_python_env (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l00530"></a>00530 {
<a name="l00531"></a>00531   <span class="keywordflow">return</span> <a class="code" href="python-internal_8h.html#a8994190914eb4c5664e90ffd7823b488">ensure_python_env</a> (var-&gt;root-&gt;exp-&gt;gdbarch,
<a name="l00532"></a>00532                             var-&gt;root-&gt;exp-&gt;language_defn);
<a name="l00533"></a>00533 }
<a name="l00534"></a>00534 <span class="preprocessor">#endif</span>
<a name="l00535"></a>00535 <span class="preprocessor"></span>
<a name="l00536"></a>00536 <span class="comment">/* Creates a varobj (not its children).  */</span>
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 <span class="comment">/* Return the full FRAME which corresponds to the given CORE_ADDR</span>
<a name="l00539"></a>00539 <span class="comment">   or NULL if no FRAME on the chain corresponds to CORE_ADDR.  */</span>
<a name="l00540"></a>00540 
<a name="l00541"></a>00541 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structframe__info.html">frame_info</a> *
<a name="l00542"></a><a class="code" href="varobj_8c.html#ae631b5413d57e2b619a610e3f64a1a08">00542</a> <a class="code" href="varobj_8c.html#ae631b5413d57e2b619a610e3f64a1a08">find_frame_addr_in_frame_chain</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> frame_addr)
<a name="l00543"></a>00543 {
<a name="l00544"></a>00544   <span class="keyword">struct </span><a class="code" href="structframe__info.html">frame_info</a> *frame = NULL;
<a name="l00545"></a>00545 
<a name="l00546"></a>00546   <span class="keywordflow">if</span> (frame_addr == (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 0)
<a name="l00547"></a>00547     <span class="keywordflow">return</span> NULL;
<a name="l00548"></a>00548 
<a name="l00549"></a>00549   <span class="keywordflow">for</span> (frame = <a class="code" href="frame_8c.html#a5ab254510728049878a232ed1b889820">get_current_frame</a> ();
<a name="l00550"></a>00550        frame != NULL;
<a name="l00551"></a>00551        frame = <a class="code" href="frame_8c.html#a7dc158f329065de426029f24f5578838">get_prev_frame</a> (frame))
<a name="l00552"></a>00552     {
<a name="l00553"></a>00553       <span class="comment">/* The CORE_ADDR we get as argument was parsed from a string GDB</span>
<a name="l00554"></a>00554 <span class="comment">         output as $fp.  This output got truncated to gdbarch_addr_bit.</span>
<a name="l00555"></a>00555 <span class="comment">         Truncate the frame base address in the same manner before</span>
<a name="l00556"></a>00556 <span class="comment">         comparing it against our argument.  */</span>
<a name="l00557"></a>00557       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structframe__base.html">frame_base</a> = <a class="code" href="frame_8c.html#a60d77c864e08611335bc224ce4bde537">get_frame_base_address</a> (frame);
<a name="l00558"></a>00558       <span class="keywordtype">int</span> addr_bit = <a class="code" href="gdbarch_8c.html#a3ee335ac98782b6633ab7fc235182cc9">gdbarch_addr_bit</a> (<a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (frame));
<a name="l00559"></a>00559 
<a name="l00560"></a>00560       <span class="keywordflow">if</span> (addr_bit &lt; (<span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) * <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>))
<a name="l00561"></a>00561         frame_base &amp;= ((<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 1 &lt;&lt; addr_bit) - 1;
<a name="l00562"></a>00562 
<a name="l00563"></a>00563       <span class="keywordflow">if</span> (frame_base == frame_addr)
<a name="l00564"></a>00564         <span class="keywordflow">return</span> frame;
<a name="l00565"></a>00565     }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567   <span class="keywordflow">return</span> NULL;
<a name="l00568"></a>00568 }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *
<a name="l00571"></a><a class="code" href="varobj_8h.html#aa0cbdb998dfbf2469c767968ecf2c333">00571</a> <a class="code" href="varobj_8c.html#aa0cbdb998dfbf2469c767968ecf2c333">varobj_create</a> (<span class="keywordtype">char</span> *objname,
<a name="l00572"></a>00572                <span class="keywordtype">char</span> *<a class="code" href="structexpression.html">expression</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> frame, <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a1a5e81372ed6f07cbe8792bf36af015f">varobj_type</a> <a class="code" href="structtype.html">type</a>)
<a name="l00573"></a>00573 {
<a name="l00574"></a>00574   <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *var;
<a name="l00575"></a>00575   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_chain;
<a name="l00576"></a>00576 
<a name="l00577"></a>00577   <span class="comment">/* Fill out a varobj structure for the (root) variable being constructed.  */</span>
<a name="l00578"></a>00578   var = <a class="code" href="varobj_8c.html#aa0e604dda78dda203375d9a8b4eaec13">new_root_variable</a> ();
<a name="l00579"></a>00579   old_chain = <a class="code" href="varobj_8c.html#ac48cf109645d59e26f82fef51512080e">make_cleanup_free_variable</a> (var);
<a name="l00580"></a>00580 
<a name="l00581"></a>00581   <span class="keywordflow">if</span> (expression != NULL)
<a name="l00582"></a>00582     {
<a name="l00583"></a>00583       <span class="keyword">struct </span><a class="code" href="structframe__info.html">frame_info</a> *fi;
<a name="l00584"></a>00584       <span class="keyword">struct </span><a class="code" href="structframe__id.html">frame_id</a> old_id = <a class="code" href="frame_8c.html#a0e92fecdd3b01549ccdc07795de2afee">null_frame_id</a>;
<a name="l00585"></a>00585       <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>;
<a name="l00586"></a>00586       <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>;
<a name="l00587"></a>00587       <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a8f290bc3f9b2441d6fd55bd85dd774bb">varobj_languages</a> lang;
<a name="l00588"></a>00588       <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html">value</a> = NULL;
<a name="l00589"></a>00589       <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> except;
<a name="l00590"></a>00590       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc;
<a name="l00591"></a>00591 
<a name="l00592"></a>00592       <span class="comment">/* Parse and evaluate the expression, filling in as much of the</span>
<a name="l00593"></a>00593 <span class="comment">         variable&#39;s data as possible.  */</span>
<a name="l00594"></a>00594 
<a name="l00595"></a>00595       <span class="keywordflow">if</span> (<a class="code" href="frame_8c.html#ad1e8bd5ac45df219a168640934f891cc">has_stack_frames</a> ())
<a name="l00596"></a>00596         {
<a name="l00597"></a>00597           <span class="comment">/* Allow creator to specify context of variable.  */</span>
<a name="l00598"></a>00598           <span class="keywordflow">if</span> ((type == <a class="code" href="varobj_8h.html#a1a5e81372ed6f07cbe8792bf36af015fa002ba5a273b14670d24ed63fc9b95381">USE_CURRENT_FRAME</a>) || (type == <a class="code" href="varobj_8h.html#a1a5e81372ed6f07cbe8792bf36af015fa33a1b3efb7304b9480dd0cfbcdf0606f">USE_SELECTED_FRAME</a>))
<a name="l00599"></a>00599             fi = <a class="code" href="frame_8c.html#a8b714a78478670e14a297eba8d1a9915">get_selected_frame</a> (NULL);
<a name="l00600"></a>00600           <span class="keywordflow">else</span>
<a name="l00601"></a>00601             <span class="comment">/* FIXME: cagney/2002-11-23: This code should be doing a</span>
<a name="l00602"></a>00602 <span class="comment">               lookup using the frame ID and not just the frame&#39;s</span>
<a name="l00603"></a>00603 <span class="comment">               ``address&#39;&#39;.  This, of course, means an interface</span>
<a name="l00604"></a>00604 <span class="comment">               change.  However, with out that interface change ISAs,</span>
<a name="l00605"></a>00605 <span class="comment">               such as the ia64 with its two stacks, won&#39;t work.</span>
<a name="l00606"></a>00606 <span class="comment">               Similar goes for the case where there is a frameless</span>
<a name="l00607"></a>00607 <span class="comment">               function.  */</span>
<a name="l00608"></a>00608             fi = <a class="code" href="varobj_8c.html#ae631b5413d57e2b619a610e3f64a1a08">find_frame_addr_in_frame_chain</a> (frame);
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610       <span class="keywordflow">else</span>
<a name="l00611"></a>00611         fi = NULL;
<a name="l00612"></a>00612 
<a name="l00613"></a>00613       <span class="comment">/* frame = -2 means always use selected frame.  */</span>
<a name="l00614"></a>00614       <span class="keywordflow">if</span> (type == <a class="code" href="varobj_8h.html#a1a5e81372ed6f07cbe8792bf36af015fa33a1b3efb7304b9480dd0cfbcdf0606f">USE_SELECTED_FRAME</a>)
<a name="l00615"></a>00615         var-&gt;root-&gt;floating = 1;
<a name="l00616"></a>00616 
<a name="l00617"></a>00617       pc = 0;
<a name="l00618"></a>00618       block = NULL;
<a name="l00619"></a>00619       <span class="keywordflow">if</span> (fi != NULL)
<a name="l00620"></a>00620         {
<a name="l00621"></a>00621           block = <a class="code" href="blockframe_8c.html#a48cd98610b3a7f167334b616336cadfb">get_frame_block</a> (fi, 0);
<a name="l00622"></a>00622           pc = <a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a> (fi);
<a name="l00623"></a>00623         }
<a name="l00624"></a>00624 
<a name="l00625"></a>00625       p = expression;
<a name="l00626"></a>00626       <a class="code" href="expression_8h.html#a6b2028f35010cd9648aa5d5e8f7d653d">innermost_block</a> = NULL;
<a name="l00627"></a>00627       <span class="comment">/* Wrap the call to parse expression, so we can </span>
<a name="l00628"></a>00628 <span class="comment">         return a sensible error.  */</span>
<a name="l00629"></a>00629       <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l00630"></a>00630         {
<a name="l00631"></a>00631           var-&gt;root-&gt;exp = <a class="code" href="expression_8h.html#abdad295cc4b5351f6e6ec024ab665475">parse_exp_1</a> (&amp;p, pc, block, 0);
<a name="l00632"></a>00632         }
<a name="l00633"></a>00633 
<a name="l00634"></a>00634       <span class="keywordflow">if</span> (except.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0)
<a name="l00635"></a>00635         {
<a name="l00636"></a>00636           <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l00637"></a>00637           <span class="keywordflow">return</span> NULL;
<a name="l00638"></a>00638         }
<a name="l00639"></a>00639 
<a name="l00640"></a>00640       <span class="comment">/* Don&#39;t allow variables to be created for types.  */</span>
<a name="l00641"></a>00641       <span class="keywordflow">if</span> (var-&gt;root-&gt;exp-&gt;elts[0].opcode == OP_TYPE
<a name="l00642"></a>00642           || var-&gt;root-&gt;exp-&gt;elts[0].opcode == OP_TYPEOF
<a name="l00643"></a>00643           || var-&gt;root-&gt;exp-&gt;elts[0].opcode == OP_DECLTYPE)
<a name="l00644"></a>00644         {
<a name="l00645"></a>00645           <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l00646"></a>00646           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, <span class="stringliteral">&quot;Attempt to use a type name&quot;</span>
<a name="l00647"></a>00647                               <span class="stringliteral">&quot; as an expression.\n&quot;</span>);
<a name="l00648"></a>00648           <span class="keywordflow">return</span> NULL;
<a name="l00649"></a>00649         }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651       var-&gt;format = <a class="code" href="varobj_8c.html#a1d817018a901fd63af42784cfcdff001">variable_default_display</a> (var);
<a name="l00652"></a>00652       var-&gt;root-&gt;valid_block = <a class="code" href="expression_8h.html#a6b2028f35010cd9648aa5d5e8f7d653d">innermost_block</a>;
<a name="l00653"></a>00653       var-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a> = xstrdup (expression);
<a name="l00654"></a>00654       <span class="comment">/* For a root var, the name and the expr are the same.  */</span>
<a name="l00655"></a>00655       var-&gt;<a class="code" href="structvarobj.html#ab61f8b5cf72e56285b2c14a89aafc7ff">path_expr</a> = xstrdup (expression);
<a name="l00656"></a>00656 
<a name="l00657"></a>00657       <span class="comment">/* When the frame is different from the current frame, </span>
<a name="l00658"></a>00658 <span class="comment">         we must select the appropriate frame before parsing</span>
<a name="l00659"></a>00659 <span class="comment">         the expression, otherwise the value will not be current.</span>
<a name="l00660"></a>00660 <span class="comment">         Since select_frame is so benign, just call it for all cases.  */</span>
<a name="l00661"></a>00661       <span class="keywordflow">if</span> (<a class="code" href="expression_8h.html#a6b2028f35010cd9648aa5d5e8f7d653d">innermost_block</a>)
<a name="l00662"></a>00662         {
<a name="l00663"></a>00663           <span class="comment">/* User could specify explicit FRAME-ADDR which was not found but</span>
<a name="l00664"></a>00664 <span class="comment">             EXPRESSION is frame specific and we would not be able to evaluate</span>
<a name="l00665"></a>00665 <span class="comment">             it correctly next time.  With VALID_BLOCK set we must also set</span>
<a name="l00666"></a>00666 <span class="comment">             FRAME and THREAD_ID.  */</span>
<a name="l00667"></a>00667           <span class="keywordflow">if</span> (fi == NULL)
<a name="l00668"></a>00668             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Failed to find the specified frame&quot;</span>));
<a name="l00669"></a>00669 
<a name="l00670"></a>00670           var-&gt;root-&gt;frame = <a class="code" href="frame_8c.html#a4d69effe10c03fa7c702d490081012bf">get_frame_id</a> (fi);
<a name="l00671"></a>00671           var-&gt;root-&gt;thread_id = <a class="code" href="gdbthread_8h.html#a3dbd3518561f91d8aa7621a65d39f305">pid_to_thread_id</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>);
<a name="l00672"></a>00672           old_id = <a class="code" href="frame_8c.html#a4d69effe10c03fa7c702d490081012bf">get_frame_id</a> (<a class="code" href="frame_8c.html#a8b714a78478670e14a297eba8d1a9915">get_selected_frame</a> (NULL));
<a name="l00673"></a>00673           <a class="code" href="frame_8c.html#a400fa273ac86863322cdc65683ef2356">select_frame</a> (fi);     
<a name="l00674"></a>00674         }
<a name="l00675"></a>00675 
<a name="l00676"></a>00676       <span class="comment">/* We definitely need to catch errors here.</span>
<a name="l00677"></a>00677 <span class="comment">         If evaluate_expression succeeds we got the value we wanted.</span>
<a name="l00678"></a>00678 <span class="comment">         But if it fails, we still go on with a call to evaluate_type().  */</span>
<a name="l00679"></a>00679       <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l00680"></a>00680         {
<a name="l00681"></a>00681           value = <a class="code" href="eval_8c.html#ab50151ccba3ea3184c114121d6bed422">evaluate_expression</a> (var-&gt;root-&gt;exp);
<a name="l00682"></a>00682         }
<a name="l00683"></a>00683 
<a name="l00684"></a>00684       <span class="keywordflow">if</span> (except.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0)
<a name="l00685"></a>00685         {
<a name="l00686"></a>00686           <span class="comment">/* Error getting the value.  Try to at least get the</span>
<a name="l00687"></a>00687 <span class="comment">             right type.  */</span>
<a name="l00688"></a>00688           <span class="keyword">struct </span>value *type_only_value = <a class="code" href="eval_8c.html#aae8f92c8e1cc2f3844384361c7a50e9b">evaluate_type</a> (var-&gt;root-&gt;exp);
<a name="l00689"></a>00689 
<a name="l00690"></a>00690           var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a> = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (type_only_value);
<a name="l00691"></a>00691         }
<a name="l00692"></a>00692         <span class="keywordflow">else</span>
<a name="l00693"></a>00693           {
<a name="l00694"></a>00694             <span class="keywordtype">int</span> real_type_found = 0;
<a name="l00695"></a>00695 
<a name="l00696"></a>00696             var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a> = <a class="code" href="value_8c.html#aad0d3b9452bbb8b01fb2f0cc5f1bf093">value_actual_type</a> (value, 0, &amp;real_type_found);
<a name="l00697"></a>00697             <span class="keywordflow">if</span> (real_type_found)
<a name="l00698"></a>00698               value = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>, value);
<a name="l00699"></a>00699           }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701       <span class="comment">/* Set language info */</span>
<a name="l00702"></a>00702       lang = <a class="code" href="varobj_8c.html#a2e77519a3fba8c0ddec2cf0418d7a9a4">variable_language</a> (var);
<a name="l00703"></a>00703       var-&gt;root-&gt;lang = &amp;languages[lang];
<a name="l00704"></a>00704 
<a name="l00705"></a>00705       <a class="code" href="varobj_8c.html#acb8313007f98eac3c62634057219329d">install_new_value</a> (var, value, 1 <span class="comment">/* Initial assignment */</span>);
<a name="l00706"></a>00706 
<a name="l00707"></a>00707       <span class="comment">/* Set ourselves as our root.  */</span>
<a name="l00708"></a>00708       var-&gt;root-&gt;rootvar = var;
<a name="l00709"></a>00709 
<a name="l00710"></a>00710       <span class="comment">/* Reset the selected frame.  */</span>
<a name="l00711"></a>00711       <span class="keywordflow">if</span> (<a class="code" href="frame_8c.html#ad6cfc1ab3a8482a76d8e2862b3fc6542">frame_id_p</a> (old_id))
<a name="l00712"></a>00712         <a class="code" href="frame_8c.html#a400fa273ac86863322cdc65683ef2356">select_frame</a> (<a class="code" href="frame_8c.html#a09616280d1811c8f06c46e26a8e07960">frame_find_by_id</a> (old_id));
<a name="l00713"></a>00713     }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715   <span class="comment">/* If the variable object name is null, that means this</span>
<a name="l00716"></a>00716 <span class="comment">     is a temporary variable, so don&#39;t install it.  */</span>
<a name="l00717"></a>00717 
<a name="l00718"></a>00718   <span class="keywordflow">if</span> ((var != NULL) &amp;&amp; (objname != NULL))
<a name="l00719"></a>00719     {
<a name="l00720"></a>00720       var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a> = xstrdup (objname);
<a name="l00721"></a>00721 
<a name="l00722"></a>00722       <span class="comment">/* If a varobj name is duplicated, the install will fail so</span>
<a name="l00723"></a>00723 <span class="comment">         we must cleanup.  */</span>
<a name="l00724"></a>00724       <span class="keywordflow">if</span> (!<a class="code" href="varobj_8c.html#add625a61acb44538c0b77386e3ee3549">install_variable</a> (var))
<a name="l00725"></a>00725         {
<a name="l00726"></a>00726           <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l00727"></a>00727           <span class="keywordflow">return</span> NULL;
<a name="l00728"></a>00728         }
<a name="l00729"></a>00729     }
<a name="l00730"></a>00730 
<a name="l00731"></a>00731   <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (old_chain);
<a name="l00732"></a>00732   <span class="keywordflow">return</span> var;
<a name="l00733"></a>00733 }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735 <span class="comment">/* Generates an unique name that can be used for a varobj.  */</span>
<a name="l00736"></a>00736 
<a name="l00737"></a>00737 <span class="keywordtype">char</span> *
<a name="l00738"></a><a class="code" href="varobj_8h.html#a9c7cdf09bca9c9ee0b2ee27d7458188c">00738</a> <a class="code" href="varobj_8c.html#a9c7cdf09bca9c9ee0b2ee27d7458188c">varobj_gen_name</a> (<span class="keywordtype">void</span>)
<a name="l00739"></a>00739 {
<a name="l00740"></a>00740   <span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span> = 0;
<a name="l00741"></a>00741   <span class="keywordtype">char</span> *obj_name;
<a name="l00742"></a>00742 
<a name="l00743"></a>00743   <span class="comment">/* Generate a name for this object.  */</span>
<a name="l00744"></a>00744   <span class="keywordtype">id</span>++;
<a name="l00745"></a>00745   obj_name = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;var%d&quot;</span>, <span class="keywordtype">id</span>);
<a name="l00746"></a>00746 
<a name="l00747"></a>00747   <span class="keywordflow">return</span> obj_name;
<a name="l00748"></a>00748 }
<a name="l00749"></a>00749 
<a name="l00750"></a>00750 <span class="comment">/* Given an OBJNAME, returns the pointer to the corresponding varobj.  Call</span>
<a name="l00751"></a>00751 <span class="comment">   error if OBJNAME cannot be found.  */</span>
<a name="l00752"></a>00752 
<a name="l00753"></a>00753 <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *
<a name="l00754"></a><a class="code" href="varobj_8h.html#a0ea6d18db6713a8dfec94afe7e9e4600">00754</a> <a class="code" href="varobj_8c.html#a7bfb2ead667d3cc5760cd63f5f02a46f">varobj_get_handle</a> (<span class="keywordtype">char</span> *objname)
<a name="l00755"></a>00755 {
<a name="l00756"></a>00756   <span class="keyword">struct </span><a class="code" href="structvlist.html">vlist</a> *cv;
<a name="l00757"></a>00757   <span class="keyword">const</span> <span class="keywordtype">char</span> *chp;
<a name="l00758"></a>00758   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 0;
<a name="l00759"></a>00759   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1;
<a name="l00760"></a>00760 
<a name="l00761"></a>00761   <span class="keywordflow">for</span> (chp = objname; *chp; chp++)
<a name="l00762"></a>00762     {
<a name="l00763"></a>00763       index = (index + (i++ * (<span class="keywordtype">unsigned</span> <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>) *chp)) % <a class="code" href="varobj_8c.html#a3e3ade9793c5199bc838ac530297268d">VAROBJ_TABLE_SIZE</a>;
<a name="l00764"></a>00764     }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766   cv = *(varobj_table + index);
<a name="l00767"></a>00767   <span class="keywordflow">while</span> ((cv != NULL) &amp;&amp; (strcmp (cv-&gt;<a class="code" href="structvlist.html#a989a752791ea1c5e6a39f54d5c3e95ea">var</a>-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>, objname) != 0))
<a name="l00768"></a>00768     cv = cv-&gt;<a class="code" href="structvlist.html#a7dd37f43fcb9fdd0b9be8120351ecd35">next</a>;
<a name="l00769"></a>00769 
<a name="l00770"></a>00770   <span class="keywordflow">if</span> (cv == NULL)
<a name="l00771"></a>00771     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Variable object not found&quot;</span>));
<a name="l00772"></a>00772 
<a name="l00773"></a>00773   <span class="keywordflow">return</span> cv-&gt;<a class="code" href="structvlist.html#a989a752791ea1c5e6a39f54d5c3e95ea">var</a>;
<a name="l00774"></a>00774 }
<a name="l00775"></a>00775 
<a name="l00776"></a>00776 <span class="comment">/* Given the handle, return the name of the object.  */</span>
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 <span class="keywordtype">char</span> *
<a name="l00779"></a><a class="code" href="varobj_8h.html#a39766cb57db2021852b460fbddaeae52">00779</a> <a class="code" href="varobj_8c.html#a39766cb57db2021852b460fbddaeae52">varobj_get_objname</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvlist.html#a989a752791ea1c5e6a39f54d5c3e95ea">var</a>)
<a name="l00780"></a>00780 {
<a name="l00781"></a>00781   <span class="keywordflow">return</span> var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>;
<a name="l00782"></a>00782 }
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 <span class="comment">/* Given the handle, return the expression represented by the object.  */</span>
<a name="l00785"></a>00785 
<a name="l00786"></a>00786 <span class="keywordtype">char</span> *
<a name="l00787"></a><a class="code" href="varobj_8h.html#a9892b966026301a1350abda399b18731">00787</a> <a class="code" href="varobj_8c.html#a9892b966026301a1350abda399b18731">varobj_get_expression</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvlist.html#a989a752791ea1c5e6a39f54d5c3e95ea">var</a>)
<a name="l00788"></a>00788 {
<a name="l00789"></a>00789   <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#a740212f7a93a8de29f093ae56681a75f">name_of_variable</a> (var);
<a name="l00790"></a>00790 }
<a name="l00791"></a>00791 
<a name="l00792"></a>00792 <span class="comment">/* Deletes a varobj and all its children if only_children == 0,</span>
<a name="l00793"></a>00793 <span class="comment">   otherwise deletes only the children; returns a malloc&#39;ed list of</span>
<a name="l00794"></a>00794 <span class="comment">   all the (malloc&#39;ed) names of the variables that have been deleted</span>
<a name="l00795"></a>00795 <span class="comment">   (NULL terminated).  */</span>
<a name="l00796"></a>00796 
<a name="l00797"></a>00797 <span class="keywordtype">int</span>
<a name="l00798"></a><a class="code" href="varobj_8h.html#aad58751b29b14a5eeb8b9879df27683d">00798</a> <a class="code" href="varobj_8c.html#aad58751b29b14a5eeb8b9879df27683d">varobj_delete</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvlist.html#a989a752791ea1c5e6a39f54d5c3e95ea">var</a>, <span class="keywordtype">char</span> ***dellist, <span class="keywordtype">int</span> only_children)
<a name="l00799"></a>00799 {
<a name="l00800"></a>00800   <span class="keywordtype">int</span> delcount;
<a name="l00801"></a>00801   <span class="keywordtype">int</span> mycount;
<a name="l00802"></a>00802   <span class="keyword">struct </span><a class="code" href="structcpstack.html">cpstack</a> *result = NULL;
<a name="l00803"></a>00803   <span class="keywordtype">char</span> **cp;
<a name="l00804"></a>00804 
<a name="l00805"></a>00805   <span class="comment">/* Initialize a stack for temporary results.  */</span>
<a name="l00806"></a>00806   <a class="code" href="varobj_8c.html#ae93a42ae116f3c1fba220ffee78bb823">cppush</a> (&amp;result, NULL);
<a name="l00807"></a>00807 
<a name="l00808"></a>00808   <span class="keywordflow">if</span> (only_children)
<a name="l00809"></a>00809     <span class="comment">/* Delete only the variable children.  */</span>
<a name="l00810"></a>00810     delcount = <a class="code" href="varobj_8c.html#a5bac0fb8c5ac5ede15933184f2f89773">delete_variable</a> (&amp;result, var, 1 <span class="comment">/* only the children */</span> );
<a name="l00811"></a>00811   <span class="keywordflow">else</span>
<a name="l00812"></a>00812     <span class="comment">/* Delete the variable and all its children.  */</span>
<a name="l00813"></a>00813     delcount = <a class="code" href="varobj_8c.html#a5bac0fb8c5ac5ede15933184f2f89773">delete_variable</a> (&amp;result, var, 0 <span class="comment">/* parent+children */</span> );
<a name="l00814"></a>00814 
<a name="l00815"></a>00815   <span class="comment">/* We may have been asked to return a list of what has been deleted.  */</span>
<a name="l00816"></a>00816   <span class="keywordflow">if</span> (dellist != NULL)
<a name="l00817"></a>00817     {
<a name="l00818"></a>00818       *dellist = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> ((delcount + 1) * <span class="keyword">sizeof</span> (<span class="keywordtype">char</span> *));
<a name="l00819"></a>00819 
<a name="l00820"></a>00820       cp = *dellist;
<a name="l00821"></a>00821       mycount = delcount;
<a name="l00822"></a>00822       *cp = <a class="code" href="varobj_8c.html#add31048dd86ce1966513b25acf18a1f5">cppop</a> (&amp;result);
<a name="l00823"></a>00823       <span class="keywordflow">while</span> ((*cp != NULL) &amp;&amp; (mycount &gt; 0))
<a name="l00824"></a>00824         {
<a name="l00825"></a>00825           mycount--;
<a name="l00826"></a>00826           cp++;
<a name="l00827"></a>00827           *cp = <a class="code" href="varobj_8c.html#add31048dd86ce1966513b25acf18a1f5">cppop</a> (&amp;result);
<a name="l00828"></a>00828         }
<a name="l00829"></a>00829 
<a name="l00830"></a>00830       <span class="keywordflow">if</span> (mycount || (*cp != NULL))
<a name="l00831"></a>00831         <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;varobj_delete: assertion failed - mycount(=%d) &lt;&gt; 0&quot;</span>),
<a name="l00832"></a>00832                  mycount);
<a name="l00833"></a>00833     }
<a name="l00834"></a>00834 
<a name="l00835"></a>00835   <span class="keywordflow">return</span> delcount;
<a name="l00836"></a>00836 }
<a name="l00837"></a>00837 
<a name="l00838"></a>00838 <span class="preprocessor">#if HAVE_PYTHON</span>
<a name="l00839"></a>00839 <span class="preprocessor"></span>
<a name="l00840"></a>00840 <span class="comment">/* Convenience function for varobj_set_visualizer.  Instantiate a</span>
<a name="l00841"></a>00841 <span class="comment">   pretty-printer for a given value.  */</span>
<a name="l00842"></a>00842 <span class="keyword">static</span> <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *
<a name="l00843"></a>00843 instantiate_pretty_printer (<a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *constructor, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html">value</a>)
<a name="l00844"></a>00844 {
<a name="l00845"></a>00845   <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *val_obj = NULL; 
<a name="l00846"></a>00846   <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *printer;
<a name="l00847"></a>00847 
<a name="l00848"></a>00848   val_obj = <a class="code" href="python-internal_8h.html#ae5c07c92590470b1a6e921de62f3f824">value_to_value_object</a> (value);
<a name="l00849"></a>00849   <span class="keywordflow">if</span> (! val_obj)
<a name="l00850"></a>00850     <span class="keywordflow">return</span> NULL;
<a name="l00851"></a>00851 
<a name="l00852"></a>00852   printer = PyObject_CallFunctionObjArgs (constructor, val_obj, NULL);
<a name="l00853"></a>00853   <a class="code" href="python-internal_8h.html#a19be7acd3e9a57b82c7be99b8594d293">Py_DECREF</a> (val_obj);
<a name="l00854"></a>00854   <span class="keywordflow">return</span> printer;
<a name="l00855"></a>00855 }
<a name="l00856"></a>00856 
<a name="l00857"></a>00857 <span class="preprocessor">#endif</span>
<a name="l00858"></a>00858 <span class="preprocessor"></span>
<a name="l00859"></a>00859 <span class="comment">/* Set/Get variable object display format.  */</span>
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a>
<a name="l00862"></a><a class="code" href="varobj_8h.html#aef7f65ebb432fb8d3305159e4bf7a4b7">00862</a> <a class="code" href="varobj_8c.html#aef7f65ebb432fb8d3305159e4bf7a4b7">varobj_set_display_format</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var,
<a name="l00863"></a>00863                            <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format)
<a name="l00864"></a>00864 {
<a name="l00865"></a>00865   <span class="keywordflow">switch</span> (format)
<a name="l00866"></a>00866     {
<a name="l00867"></a>00867     <span class="keywordflow">case</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bfaa12483e615405ce026f1e9555fdb2b67">FORMAT_NATURAL</a>:
<a name="l00868"></a>00868     <span class="keywordflow">case</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bfade8872737c865b964ec387d4353454c9">FORMAT_BINARY</a>:
<a name="l00869"></a>00869     <span class="keywordflow">case</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bfa09d6c064e73b9a122ddadc1c21e63140">FORMAT_DECIMAL</a>:
<a name="l00870"></a>00870     <span class="keywordflow">case</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bfa915a98f0b3832f0d12ec0dc406cd5703">FORMAT_HEXADECIMAL</a>:
<a name="l00871"></a>00871     <span class="keywordflow">case</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bfac8f7274d1af2b429f41f8976959412b1">FORMAT_OCTAL</a>:
<a name="l00872"></a>00872       var-&gt;format = format;
<a name="l00873"></a>00873       <span class="keywordflow">break</span>;
<a name="l00874"></a>00874 
<a name="l00875"></a>00875     <span class="keywordflow">default</span>:
<a name="l00876"></a>00876       var-&gt;format = <a class="code" href="varobj_8c.html#a1d817018a901fd63af42784cfcdff001">variable_default_display</a> (var);
<a name="l00877"></a>00877     }
<a name="l00878"></a>00878 
<a name="l00879"></a>00879   <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a176f5fae4079ee6acd5df422bd0e8f4c">varobj_value_is_changeable_p</a> (var) 
<a name="l00880"></a>00880       &amp;&amp; var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a> &amp;&amp; !<a class="code" href="value_8c.html#aa60bc8ecf77867a2d16bec57a4ccf983">value_lazy</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>))
<a name="l00881"></a>00881     {
<a name="l00882"></a>00882       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (var-&gt;print_value);
<a name="l00883"></a>00883       var-&gt;print_value = <a class="code" href="varobj_8c.html#a371cbd65da3254826f01cbf5fd49380c">value_get_print_value</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>, var-&gt;format, var);
<a name="l00884"></a>00884     }
<a name="l00885"></a>00885 
<a name="l00886"></a>00886   <span class="keywordflow">return</span> var-&gt;format;
<a name="l00887"></a>00887 }
<a name="l00888"></a>00888 
<a name="l00889"></a>00889 <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a>
<a name="l00890"></a><a class="code" href="varobj_8h.html#affdc7559ed200c9da8f0a8a714ebfa4d">00890</a> <a class="code" href="varobj_8c.html#affdc7559ed200c9da8f0a8a714ebfa4d">varobj_get_display_format</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l00891"></a>00891 {
<a name="l00892"></a>00892   <span class="keywordflow">return</span> var-&gt;format;
<a name="l00893"></a>00893 }
<a name="l00894"></a>00894 
<a name="l00895"></a>00895 <span class="keywordtype">char</span> *
<a name="l00896"></a><a class="code" href="varobj_8h.html#a14cc6be00bbcd7b84a807e34dc94e96a">00896</a> <a class="code" href="varobj_8c.html#a14cc6be00bbcd7b84a807e34dc94e96a">varobj_get_display_hint</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l00897"></a>00897 {
<a name="l00898"></a>00898   <span class="keywordtype">char</span> *result = NULL;
<a name="l00899"></a>00899 
<a name="l00900"></a>00900 <span class="preprocessor">#if HAVE_PYTHON</span>
<a name="l00901"></a>00901 <span class="preprocessor"></span>  <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to;
<a name="l00902"></a>00902 
<a name="l00903"></a>00903   <span class="keywordflow">if</span> (!<a class="code" href="python-internal_8h.html#a2f9782caf78c6a6f300ce14c165d9605">gdb_python_initialized</a>)
<a name="l00904"></a>00904     <span class="keywordflow">return</span> NULL;
<a name="l00905"></a>00905 
<a name="l00906"></a>00906   back_to = varobj_ensure_python_env (var);
<a name="l00907"></a>00907 
<a name="l00908"></a>00908   <span class="keywordflow">if</span> (var-&gt;pretty_printer)
<a name="l00909"></a>00909     result = <a class="code" href="python-internal_8h.html#a52ec91554ac239169da1e5e23b612436">gdbpy_get_display_hint</a> (var-&gt;pretty_printer);
<a name="l00910"></a>00910 
<a name="l00911"></a>00911   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l00912"></a>00912 <span class="preprocessor">#endif</span>
<a name="l00913"></a>00913 <span class="preprocessor"></span>
<a name="l00914"></a>00914   <span class="keywordflow">return</span> result;
<a name="l00915"></a>00915 }
<a name="l00916"></a>00916 
<a name="l00917"></a>00917 <span class="comment">/* Return true if the varobj has items after TO, false otherwise.  */</span>
<a name="l00918"></a>00918 
<a name="l00919"></a>00919 <span class="keywordtype">int</span>
<a name="l00920"></a><a class="code" href="varobj_8h.html#af87ce7009f492b002fc8f6fdc085a5d6">00920</a> <a class="code" href="varobj_8c.html#af87ce7009f492b002fc8f6fdc085a5d6">varobj_has_more</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keywordtype">int</span> <a class="code" href="varobj_8h.html#ae2a2635825813434f3201bf8ace439d2">to</a>)
<a name="l00921"></a>00921 {
<a name="l00922"></a>00922   <span class="keywordflow">if</span> (<a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children) &gt; to)
<a name="l00923"></a>00923     <span class="keywordflow">return</span> 1;
<a name="l00924"></a>00924   <span class="keywordflow">return</span> ((to == -1 || <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children) == to)
<a name="l00925"></a>00925           &amp;&amp; var-&gt;saved_item != NULL);
<a name="l00926"></a>00926 }
<a name="l00927"></a>00927 
<a name="l00928"></a>00928 <span class="comment">/* If the variable object is bound to a specific thread, that</span>
<a name="l00929"></a>00929 <span class="comment">   is its evaluation can always be done in context of a frame</span>
<a name="l00930"></a>00930 <span class="comment">   inside that thread, returns GDB id of the thread -- which</span>
<a name="l00931"></a>00931 <span class="comment">   is always positive.  Otherwise, returns -1.  */</span>
<a name="l00932"></a>00932 <span class="keywordtype">int</span>
<a name="l00933"></a><a class="code" href="varobj_8h.html#a2afb05ab6b5c64cbdd4fa771a19add2d">00933</a> <a class="code" href="varobj_8c.html#a2afb05ab6b5c64cbdd4fa771a19add2d">varobj_get_thread_id</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l00934"></a>00934 {
<a name="l00935"></a>00935   <span class="keywordflow">if</span> (var-&gt;root-&gt;valid_block &amp;&amp; var-&gt;root-&gt;thread_id &gt; 0)
<a name="l00936"></a>00936     <span class="keywordflow">return</span> var-&gt;root-&gt;thread_id;
<a name="l00937"></a>00937   <span class="keywordflow">else</span>
<a name="l00938"></a>00938     <span class="keywordflow">return</span> -1;
<a name="l00939"></a>00939 }
<a name="l00940"></a>00940 
<a name="l00941"></a>00941 <span class="keywordtype">void</span>
<a name="l00942"></a><a class="code" href="varobj_8h.html#a964b47a9d216f4236aec2a0bc63d6bcf">00942</a> <a class="code" href="varobj_8c.html#a964b47a9d216f4236aec2a0bc63d6bcf">varobj_set_frozen</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keywordtype">int</span> frozen)
<a name="l00943"></a>00943 {
<a name="l00944"></a>00944   <span class="comment">/* When a variable is unfrozen, we don&#39;t fetch its value.</span>
<a name="l00945"></a>00945 <span class="comment">     The &#39;not_fetched&#39; flag remains set, so next -var-update</span>
<a name="l00946"></a>00946 <span class="comment">     won&#39;t complain.</span>
<a name="l00947"></a>00947 <span class="comment"></span>
<a name="l00948"></a>00948 <span class="comment">     We don&#39;t fetch the value, because for structures the client</span>
<a name="l00949"></a>00949 <span class="comment">     should do -var-update anyway.  It would be bad to have different</span>
<a name="l00950"></a>00950 <span class="comment">     client-size logic for structure and other types.  */</span>
<a name="l00951"></a>00951   var-&gt;frozen = frozen;
<a name="l00952"></a>00952 }
<a name="l00953"></a>00953 
<a name="l00954"></a>00954 <span class="keywordtype">int</span>
<a name="l00955"></a><a class="code" href="varobj_8h.html#a6e41fdd8b81286d262d203b3d9cea056">00955</a> <a class="code" href="varobj_8c.html#a6e41fdd8b81286d262d203b3d9cea056">varobj_get_frozen</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l00956"></a>00956 {
<a name="l00957"></a>00957   <span class="keywordflow">return</span> var-&gt;frozen;
<a name="l00958"></a>00958 }
<a name="l00959"></a>00959 
<a name="l00960"></a>00960 <span class="comment">/* A helper function that restricts a range to what is actually</span>
<a name="l00961"></a>00961 <span class="comment">   available in a VEC.  This follows the usual rules for the meaning</span>
<a name="l00962"></a>00962 <span class="comment">   of FROM and TO -- if either is negative, the entire range is</span>
<a name="l00963"></a>00963 <span class="comment">   used.  */</span>
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00966"></a><a class="code" href="varobj_8c.html#afde0b8827029c1be162daa485403f344">00966</a> <a class="code" href="varobj_8c.html#afde0b8827029c1be162daa485403f344">restrict_range</a> (<a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj.html">varobj_p</a>) *children, <span class="keywordtype">int</span> *<a class="code" href="varobj_8h.html#a43396decd62b46fa01cc6c66a84cbba1">from</a>, <span class="keywordtype">int</span> *<a class="code" href="varobj_8h.html#ae2a2635825813434f3201bf8ace439d2">to</a>)
<a name="l00967"></a>00967 {
<a name="l00968"></a>00968   <span class="keywordflow">if</span> (*from &lt; 0 || *to &lt; 0)
<a name="l00969"></a>00969     {
<a name="l00970"></a>00970       *from = 0;
<a name="l00971"></a>00971       *to = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, children);
<a name="l00972"></a>00972     }
<a name="l00973"></a>00973   <span class="keywordflow">else</span>
<a name="l00974"></a>00974     {
<a name="l00975"></a>00975       <span class="keywordflow">if</span> (*from &gt; <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, children))
<a name="l00976"></a>00976         *from = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, children);
<a name="l00977"></a>00977       <span class="keywordflow">if</span> (*to &gt; <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, children))
<a name="l00978"></a>00978         *to = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, children);
<a name="l00979"></a>00979       <span class="keywordflow">if</span> (*from &gt; *to)
<a name="l00980"></a>00980         *from = *<a class="code" href="varobj_8h.html#ae2a2635825813434f3201bf8ace439d2">to</a>;
<a name="l00981"></a>00981     }
<a name="l00982"></a>00982 }
<a name="l00983"></a>00983 
<a name="l00984"></a>00984 <span class="preprocessor">#if HAVE_PYTHON</span>
<a name="l00985"></a>00985 <span class="preprocessor"></span>
<a name="l00986"></a>00986 <span class="comment">/* A helper for update_dynamic_varobj_children that installs a new</span>
<a name="l00987"></a>00987 <span class="comment">   child when needed.  */</span>
<a name="l00988"></a>00988 
<a name="l00989"></a>00989 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00990"></a>00990 install_dynamic_child (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var,
<a name="l00991"></a>00991                        <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj.html">varobj_p</a>) **changed,
<a name="l00992"></a>00992                        <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj.html">varobj_p</a>) **type_changed,
<a name="l00993"></a>00993                        <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj.html">varobj_p</a>) **<span class="keyword">new</span>,
<a name="l00994"></a>00994                        <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj.html">varobj_p</a>) **unchanged,
<a name="l00995"></a>00995                        <span class="keywordtype">int</span> *cchanged,
<a name="l00996"></a>00996                        <span class="keywordtype">int</span> index,
<a name="l00997"></a>00997                        <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>,
<a name="l00998"></a>00998                        <span class="keyword">struct</span> value *value)
<a name="l00999"></a>00999 {
<a name="l01000"></a>01000   <span class="keywordflow">if</span> (<a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children) &lt; index + 1)
<a name="l01001"></a>01001     {
<a name="l01002"></a>01002       <span class="comment">/* There&#39;s no child yet.  */</span>
<a name="l01003"></a>01003       <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *child = varobj_add_child (var, name, value);
<a name="l01004"></a>01004 
<a name="l01005"></a>01005       <span class="keywordflow">if</span> (<span class="keyword">new</span>)
<a name="l01006"></a>01006         {
<a name="l01007"></a>01007           <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj.html">varobj_p</a>, *<span class="keyword">new</span>, child);
<a name="l01008"></a>01008           *cchanged = 1;
<a name="l01009"></a>01009         }
<a name="l01010"></a>01010     }
<a name="l01011"></a>01011   <span class="keywordflow">else</span>
<a name="l01012"></a>01012     {
<a name="l01013"></a>01013       <a class="code" href="structvarobj.html">varobj_p</a> existing = <a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children, index);
<a name="l01014"></a>01014       <span class="keywordtype">int</span> type_updated = <a class="code" href="varobj_8c.html#a8de9d1ed628fd6139ef82609d3b3460a">update_type_if_necessary</a> (existing, value);
<a name="l01015"></a>01015 
<a name="l01016"></a>01016       <span class="keywordflow">if</span> (type_updated)
<a name="l01017"></a>01017         {
<a name="l01018"></a>01018           <span class="keywordflow">if</span> (type_changed)
<a name="l01019"></a>01019             <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj.html">varobj_p</a>, *type_changed, existing);
<a name="l01020"></a>01020         }
<a name="l01021"></a>01021       <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#acb8313007f98eac3c62634057219329d">install_new_value</a> (existing, value, 0))
<a name="l01022"></a>01022         {
<a name="l01023"></a>01023           <span class="keywordflow">if</span> (!type_updated &amp;&amp; changed)
<a name="l01024"></a>01024             <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj.html">varobj_p</a>, *changed, existing);
<a name="l01025"></a>01025         }
<a name="l01026"></a>01026       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!type_updated &amp;&amp; unchanged)
<a name="l01027"></a>01027         <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj.html">varobj_p</a>, *unchanged, existing);
<a name="l01028"></a>01028     }
<a name="l01029"></a>01029 }
<a name="l01030"></a>01030 
<a name="l01031"></a>01031 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01032"></a>01032 dynamic_varobj_has_child_method (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l01033"></a>01033 {
<a name="l01034"></a>01034   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to;
<a name="l01035"></a>01035   <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *printer = var-&gt;pretty_printer;
<a name="l01036"></a>01036   <span class="keywordtype">int</span> result;
<a name="l01037"></a>01037 
<a name="l01038"></a>01038   <span class="keywordflow">if</span> (!gdb_python_initialized)
<a name="l01039"></a>01039     <span class="keywordflow">return</span> 0;
<a name="l01040"></a>01040 
<a name="l01041"></a>01041   back_to = varobj_ensure_python_env (var);
<a name="l01042"></a>01042   result = PyObject_HasAttr (printer, gdbpy_children_cst);
<a name="l01043"></a>01043   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l01044"></a>01044   <span class="keywordflow">return</span> result;
<a name="l01045"></a>01045 }
<a name="l01046"></a>01046 
<a name="l01047"></a>01047 <span class="preprocessor">#endif</span>
<a name="l01048"></a>01048 <span class="preprocessor"></span>
<a name="l01049"></a>01049 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01050"></a><a class="code" href="varobj_8c.html#ace5c357c603bf2568bded643d6101c1d">01050</a> <a class="code" href="varobj_8c.html#ace5c357c603bf2568bded643d6101c1d">update_dynamic_varobj_children</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var,
<a name="l01051"></a>01051                                 <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj.html">varobj_p</a>) **changed,
<a name="l01052"></a>01052                                 <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj.html">varobj_p</a>) **type_changed,
<a name="l01053"></a>01053                                 <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj.html">varobj_p</a>) **<span class="keyword">new</span>,
<a name="l01054"></a>01054                                 <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj.html">varobj_p</a>) **unchanged,
<a name="l01055"></a>01055                                 <span class="keywordtype">int</span> *cchanged,
<a name="l01056"></a>01056                                 <span class="keywordtype">int</span> update_children,
<a name="l01057"></a>01057                                 <span class="keywordtype">int</span> <a class="code" href="varobj_8h.html#a43396decd62b46fa01cc6c66a84cbba1">from</a>,
<a name="l01058"></a>01058                                 <span class="keywordtype">int</span> <a class="code" href="varobj_8h.html#ae2a2635825813434f3201bf8ace439d2">to</a>)
<a name="l01059"></a>01059 {
<a name="l01060"></a>01060 <span class="preprocessor">#if HAVE_PYTHON</span>
<a name="l01061"></a>01061 <span class="preprocessor"></span>  <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to;
<a name="l01062"></a>01062   <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *children;
<a name="l01063"></a>01063   <span class="keywordtype">int</span> i;
<a name="l01064"></a>01064   <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *printer = var-&gt;pretty_printer;
<a name="l01065"></a>01065 
<a name="l01066"></a>01066   <span class="keywordflow">if</span> (!<a class="code" href="python-internal_8h.html#a2f9782caf78c6a6f300ce14c165d9605">gdb_python_initialized</a>)
<a name="l01067"></a>01067     <span class="keywordflow">return</span> 0;
<a name="l01068"></a>01068 
<a name="l01069"></a>01069   back_to = varobj_ensure_python_env (var);
<a name="l01070"></a>01070 
<a name="l01071"></a>01071   *cchanged = 0;
<a name="l01072"></a>01072   <span class="keywordflow">if</span> (!PyObject_HasAttr (printer, <a class="code" href="python-internal_8h.html#a500c0e191f05fc2b3974f0c6394051ed">gdbpy_children_cst</a>))
<a name="l01073"></a>01073     {
<a name="l01074"></a>01074       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l01075"></a>01075       <span class="keywordflow">return</span> 0;
<a name="l01076"></a>01076     }
<a name="l01077"></a>01077 
<a name="l01078"></a>01078   <span class="keywordflow">if</span> (update_children || !var-&gt;child_iter)
<a name="l01079"></a>01079     {
<a name="l01080"></a>01080       children = PyObject_CallMethodObjArgs (printer, <a class="code" href="python-internal_8h.html#a500c0e191f05fc2b3974f0c6394051ed">gdbpy_children_cst</a>,
<a name="l01081"></a>01081                                              NULL);
<a name="l01082"></a>01082 
<a name="l01083"></a>01083       <span class="keywordflow">if</span> (!children)
<a name="l01084"></a>01084         {
<a name="l01085"></a>01085           <a class="code" href="python-internal_8h.html#a0547cdf5b8063543c37589085a7cfe31">gdbpy_print_stack</a> ();
<a name="l01086"></a>01086           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Null value returned for children&quot;</span>));
<a name="l01087"></a>01087         }
<a name="l01088"></a>01088 
<a name="l01089"></a>01089       <a class="code" href="py-utils_8c.html#a58ef2184225d9f93b45b203dde2c5bc7">make_cleanup_py_decref</a> (children);
<a name="l01090"></a>01090 
<a name="l01091"></a>01091       Py_XDECREF (var-&gt;child_iter);
<a name="l01092"></a>01092       var-&gt;child_iter = PyObject_GetIter (children);
<a name="l01093"></a>01093       <span class="keywordflow">if</span> (!var-&gt;child_iter)
<a name="l01094"></a>01094         {
<a name="l01095"></a>01095           <a class="code" href="python-internal_8h.html#a0547cdf5b8063543c37589085a7cfe31">gdbpy_print_stack</a> ();
<a name="l01096"></a>01096           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Could not get children iterator&quot;</span>));
<a name="l01097"></a>01097         }
<a name="l01098"></a>01098 
<a name="l01099"></a>01099       Py_XDECREF (var-&gt;saved_item);
<a name="l01100"></a>01100       var-&gt;saved_item = NULL;
<a name="l01101"></a>01101 
<a name="l01102"></a>01102       i = 0;
<a name="l01103"></a>01103     }
<a name="l01104"></a>01104   <span class="keywordflow">else</span>
<a name="l01105"></a>01105     i = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children);
<a name="l01106"></a>01106 
<a name="l01107"></a>01107   <span class="comment">/* We ask for one extra child, so that MI can report whether there</span>
<a name="l01108"></a>01108 <span class="comment">     are more children.  */</span>
<a name="l01109"></a>01109   <span class="keywordflow">for</span> (; to &lt; 0 || i &lt; to + 1; ++i)
<a name="l01110"></a>01110     {
<a name="l01111"></a>01111       <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *item;
<a name="l01112"></a>01112       <span class="keywordtype">int</span> force_done = 0;
<a name="l01113"></a>01113 
<a name="l01114"></a>01114       <span class="comment">/* See if there was a leftover from last time.  */</span>
<a name="l01115"></a>01115       <span class="keywordflow">if</span> (var-&gt;saved_item)
<a name="l01116"></a>01116         {
<a name="l01117"></a>01117           item = var-&gt;saved_item;
<a name="l01118"></a>01118           var-&gt;saved_item = NULL;
<a name="l01119"></a>01119         }
<a name="l01120"></a>01120       <span class="keywordflow">else</span>
<a name="l01121"></a>01121         item = PyIter_Next (var-&gt;child_iter);
<a name="l01122"></a>01122 
<a name="l01123"></a>01123       <span class="keywordflow">if</span> (!item)
<a name="l01124"></a>01124         {
<a name="l01125"></a>01125           <span class="comment">/* Normal end of iteration.  */</span>
<a name="l01126"></a>01126           <span class="keywordflow">if</span> (!PyErr_Occurred ())
<a name="l01127"></a>01127             <span class="keywordflow">break</span>;
<a name="l01128"></a>01128 
<a name="l01129"></a>01129           <span class="comment">/* If we got a memory error, just use the text as the</span>
<a name="l01130"></a>01130 <span class="comment">             item.  */</span>
<a name="l01131"></a>01131           <span class="keywordflow">if</span> (PyErr_ExceptionMatches (<a class="code" href="python-internal_8h.html#a77e7ad6114acf56d0b369b43027f9bc1">gdbpy_gdb_memory_error</a>))
<a name="l01132"></a>01132             {
<a name="l01133"></a>01133               <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>, *value, *trace;
<a name="l01134"></a>01134               <span class="keywordtype">char</span> *name_str, *value_str;
<a name="l01135"></a>01135 
<a name="l01136"></a>01136               PyErr_Fetch (&amp;type, &amp;value, &amp;trace);
<a name="l01137"></a>01137               value_str = <a class="code" href="py-utils_8c.html#a2398e6193533e8a2f33aa57491aea865">gdbpy_exception_to_string</a> (type, value);
<a name="l01138"></a>01138               Py_XDECREF (type);
<a name="l01139"></a>01139               Py_XDECREF (value);
<a name="l01140"></a>01140               Py_XDECREF (trace);
<a name="l01141"></a>01141               <span class="keywordflow">if</span> (!value_str)
<a name="l01142"></a>01142                 {
<a name="l01143"></a>01143                   <a class="code" href="python-internal_8h.html#a0547cdf5b8063543c37589085a7cfe31">gdbpy_print_stack</a> ();
<a name="l01144"></a>01144                   <span class="keywordflow">break</span>;
<a name="l01145"></a>01145                 }
<a name="l01146"></a>01146 
<a name="l01147"></a>01147               name_str = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;&lt;error at %d&gt;&quot;</span>, i);
<a name="l01148"></a>01148               item = Py_BuildValue (<span class="stringliteral">&quot;(ss)&quot;</span>, name_str, value_str);
<a name="l01149"></a>01149               <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (name_str);
<a name="l01150"></a>01150               <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (value_str);
<a name="l01151"></a>01151               <span class="keywordflow">if</span> (!item)
<a name="l01152"></a>01152                 {
<a name="l01153"></a>01153                   <a class="code" href="python-internal_8h.html#a0547cdf5b8063543c37589085a7cfe31">gdbpy_print_stack</a> ();
<a name="l01154"></a>01154                   <span class="keywordflow">break</span>;
<a name="l01155"></a>01155                 }
<a name="l01156"></a>01156 
<a name="l01157"></a>01157               force_done = 1;
<a name="l01158"></a>01158             }
<a name="l01159"></a>01159           <span class="keywordflow">else</span>
<a name="l01160"></a>01160             {
<a name="l01161"></a>01161               <span class="comment">/* Any other kind of error.  */</span>
<a name="l01162"></a>01162               <a class="code" href="python-internal_8h.html#a0547cdf5b8063543c37589085a7cfe31">gdbpy_print_stack</a> ();
<a name="l01163"></a>01163               <span class="keywordflow">break</span>;
<a name="l01164"></a>01164             }
<a name="l01165"></a>01165         }
<a name="l01166"></a>01166 
<a name="l01167"></a>01167       <span class="comment">/* We don&#39;t want to push the extra child on any report list.  */</span>
<a name="l01168"></a>01168       <span class="keywordflow">if</span> (to &lt; 0 || i &lt; to)
<a name="l01169"></a>01169         {
<a name="l01170"></a>01170           <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *py_v;
<a name="l01171"></a>01171           <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01172"></a>01172           <span class="keyword">struct </span>value *v;
<a name="l01173"></a>01173           <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *inner;
<a name="l01174"></a>01174           <span class="keywordtype">int</span> can_mention = from &lt; 0 || i &gt;= <a class="code" href="varobj_8h.html#a43396decd62b46fa01cc6c66a84cbba1">from</a>;
<a name="l01175"></a>01175 
<a name="l01176"></a>01176           inner = <a class="code" href="py-utils_8c.html#a58ef2184225d9f93b45b203dde2c5bc7">make_cleanup_py_decref</a> (item);
<a name="l01177"></a>01177 
<a name="l01178"></a>01178           <span class="keywordflow">if</span> (!PyArg_ParseTuple (item, <span class="stringliteral">&quot;sO&quot;</span>, &amp;name, &amp;py_v))
<a name="l01179"></a>01179             {
<a name="l01180"></a>01180               <a class="code" href="python-internal_8h.html#a0547cdf5b8063543c37589085a7cfe31">gdbpy_print_stack</a> ();
<a name="l01181"></a>01181               <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Invalid item from the child list&quot;</span>));
<a name="l01182"></a>01182             }
<a name="l01183"></a>01183 
<a name="l01184"></a>01184           v = <a class="code" href="python-internal_8h.html#aecb1fd83178450d8153154e027258b38">convert_value_from_python</a> (py_v);
<a name="l01185"></a>01185           <span class="keywordflow">if</span> (v == NULL)
<a name="l01186"></a>01186             <a class="code" href="python-internal_8h.html#a0547cdf5b8063543c37589085a7cfe31">gdbpy_print_stack</a> ();
<a name="l01187"></a>01187           install_dynamic_child (var, can_mention ? changed : NULL,
<a name="l01188"></a>01188                                  can_mention ? type_changed : NULL,
<a name="l01189"></a>01189                                  can_mention ? <span class="keyword">new</span> : NULL,
<a name="l01190"></a>01190                                  can_mention ? unchanged : NULL,
<a name="l01191"></a>01191                                  can_mention ? cchanged : NULL, i,
<a name="l01192"></a>01192                                  xstrdup (name), v);
<a name="l01193"></a>01193           <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (inner);
<a name="l01194"></a>01194         }
<a name="l01195"></a>01195       <span class="keywordflow">else</span>
<a name="l01196"></a>01196         {
<a name="l01197"></a>01197           Py_XDECREF (var-&gt;saved_item);
<a name="l01198"></a>01198           var-&gt;saved_item = item;
<a name="l01199"></a>01199 
<a name="l01200"></a>01200           <span class="comment">/* We want to truncate the child list just before this</span>
<a name="l01201"></a>01201 <span class="comment">             element.  */</span>
<a name="l01202"></a>01202           <span class="keywordflow">break</span>;
<a name="l01203"></a>01203         }
<a name="l01204"></a>01204 
<a name="l01205"></a>01205       <span class="keywordflow">if</span> (force_done)
<a name="l01206"></a>01206         <span class="keywordflow">break</span>;
<a name="l01207"></a>01207     }
<a name="l01208"></a>01208 
<a name="l01209"></a>01209   <span class="keywordflow">if</span> (i &lt; <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children))
<a name="l01210"></a>01210     {
<a name="l01211"></a>01211       <span class="keywordtype">int</span> j;
<a name="l01212"></a>01212 
<a name="l01213"></a>01213       *cchanged = 1;
<a name="l01214"></a>01214       <span class="keywordflow">for</span> (j = i; j &lt; <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children); ++j)
<a name="l01215"></a>01215         <a class="code" href="varobj_8c.html#aad58751b29b14a5eeb8b9879df27683d">varobj_delete</a> (<a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children, j), NULL, 0);
<a name="l01216"></a>01216       <a class="code" href="vec_8h.html#a7b3dd1d44acb431cf333c2406e1c000d">VEC_truncate</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children, i);
<a name="l01217"></a>01217     }
<a name="l01218"></a>01218 
<a name="l01219"></a>01219   <span class="comment">/* If there are fewer children than requested, note that the list of</span>
<a name="l01220"></a>01220 <span class="comment">     children changed.  */</span>
<a name="l01221"></a>01221   <span class="keywordflow">if</span> (to &gt;= 0 &amp;&amp; <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children) &lt; to)
<a name="l01222"></a>01222     *cchanged = 1;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224   var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a> = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children);
<a name="l01225"></a>01225  
<a name="l01226"></a>01226   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l01227"></a>01227 
<a name="l01228"></a>01228   <span class="keywordflow">return</span> 1;
<a name="l01229"></a>01229 <span class="preprocessor">#else</span>
<a name="l01230"></a>01230 <span class="preprocessor"></span>  <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;should never be called if Python is not enabled&quot;</span>);
<a name="l01231"></a>01231 <span class="preprocessor">#endif</span>
<a name="l01232"></a>01232 <span class="preprocessor"></span>}
<a name="l01233"></a>01233 
<a name="l01234"></a>01234 <span class="keywordtype">int</span>
<a name="l01235"></a><a class="code" href="varobj_8h.html#ac82d83fcd4bc8043c08444c97da1c292">01235</a> <a class="code" href="varobj_8c.html#ac82d83fcd4bc8043c08444c97da1c292">varobj_get_num_children</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l01236"></a>01236 {
<a name="l01237"></a>01237   <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a> == -1)
<a name="l01238"></a>01238     {
<a name="l01239"></a>01239       <span class="keywordflow">if</span> (var-&gt;pretty_printer)
<a name="l01240"></a>01240         {
<a name="l01241"></a>01241           <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a36fb645a916cd19d79712e75c47b8d03">dummy</a>;
<a name="l01242"></a>01242 
<a name="l01243"></a>01243           <span class="comment">/* If we have a dynamic varobj, don&#39;t report -1 children.</span>
<a name="l01244"></a>01244 <span class="comment">             So, try to fetch some children first.  */</span>
<a name="l01245"></a>01245           <a class="code" href="varobj_8c.html#ace5c357c603bf2568bded643d6101c1d">update_dynamic_varobj_children</a> (var, NULL, NULL, NULL, NULL, &amp;dummy,
<a name="l01246"></a>01246                                           0, 0, 0);
<a name="l01247"></a>01247         }
<a name="l01248"></a>01248       <span class="keywordflow">else</span>
<a name="l01249"></a>01249         var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a> = <a class="code" href="varobj_8c.html#a32afd58f9f6ae8fb1e404873904dee3b">number_of_children</a> (var);
<a name="l01250"></a>01250     }
<a name="l01251"></a>01251 
<a name="l01252"></a>01252   <span class="keywordflow">return</span> var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a> &gt;= 0 ? var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a> : 0;
<a name="l01253"></a>01253 }
<a name="l01254"></a>01254 
<a name="l01255"></a>01255 <span class="comment">/* Creates a list of the immediate children of a variable object;</span>
<a name="l01256"></a>01256 <span class="comment">   the return code is the number of such children or -1 on error.  */</span>
<a name="l01257"></a>01257 
<a name="l01258"></a><a class="code" href="varobj_8c.html#abbf462048715ffb19d1fdbbe99b6b091">01258</a> <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj.html">varobj_p</a>)*
<a name="l01259"></a>01259 varobj_list_children (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keywordtype">int</span> *<a class="code" href="varobj_8h.html#a43396decd62b46fa01cc6c66a84cbba1">from</a>, <span class="keywordtype">int</span> *<a class="code" href="varobj_8h.html#ae2a2635825813434f3201bf8ace439d2">to</a>)
<a name="l01260"></a>01260 {
<a name="l01261"></a>01261   <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01262"></a>01262   <span class="keywordtype">int</span> i, children_changed;
<a name="l01263"></a>01263 
<a name="l01264"></a>01264   var-&gt;children_requested = 1;
<a name="l01265"></a>01265 
<a name="l01266"></a>01266   <span class="keywordflow">if</span> (var-&gt;pretty_printer)
<a name="l01267"></a>01267     {
<a name="l01268"></a>01268       <span class="comment">/* This, in theory, can result in the number of children changing without</span>
<a name="l01269"></a>01269 <span class="comment">         frontend noticing.  But well, calling -var-list-children on the same</span>
<a name="l01270"></a>01270 <span class="comment">         varobj twice is not something a sane frontend would do.  */</span>
<a name="l01271"></a>01271       <a class="code" href="varobj_8c.html#ace5c357c603bf2568bded643d6101c1d">update_dynamic_varobj_children</a> (var, NULL, NULL, NULL, NULL,
<a name="l01272"></a>01272                                       &amp;children_changed, 0, 0, *to);
<a name="l01273"></a>01273       <a class="code" href="varobj_8c.html#afde0b8827029c1be162daa485403f344">restrict_range</a> (var-&gt;children, from, to);
<a name="l01274"></a>01274       <span class="keywordflow">return</span> var-&gt;children;
<a name="l01275"></a>01275     }
<a name="l01276"></a>01276 
<a name="l01277"></a>01277   <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a> == -1)
<a name="l01278"></a>01278     var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a> = <a class="code" href="varobj_8c.html#a32afd58f9f6ae8fb1e404873904dee3b">number_of_children</a> (var);
<a name="l01279"></a>01279 
<a name="l01280"></a>01280   <span class="comment">/* If that failed, give up.  */</span>
<a name="l01281"></a>01281   <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a> == -1)
<a name="l01282"></a>01282     <span class="keywordflow">return</span> var-&gt;children;
<a name="l01283"></a>01283 
<a name="l01284"></a>01284   <span class="comment">/* If we&#39;re called when the list of children is not yet initialized,</span>
<a name="l01285"></a>01285 <span class="comment">     allocate enough elements in it.  */</span>
<a name="l01286"></a>01286   <span class="keywordflow">while</span> (<a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children) &lt; var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a>)
<a name="l01287"></a>01287     <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children, NULL);
<a name="l01288"></a>01288 
<a name="l01289"></a>01289   <span class="keywordflow">for</span> (i = 0; i &lt; var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a>; i++)
<a name="l01290"></a>01290     {
<a name="l01291"></a>01291       <a class="code" href="structvarobj.html">varobj_p</a> existing = <a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children, i);
<a name="l01292"></a>01292 
<a name="l01293"></a>01293       <span class="keywordflow">if</span> (existing == NULL)
<a name="l01294"></a>01294         {
<a name="l01295"></a>01295           <span class="comment">/* Either it&#39;s the first call to varobj_list_children for</span>
<a name="l01296"></a>01296 <span class="comment">             this variable object, and the child was never created,</span>
<a name="l01297"></a>01297 <span class="comment">             or it was explicitly deleted by the client.  */</span>
<a name="l01298"></a>01298           name = <a class="code" href="varobj_8c.html#aa197bbfcee05a8c063d1a0ec7469686d">name_of_child</a> (var, i);
<a name="l01299"></a>01299           existing = <a class="code" href="varobj_8c.html#a71f5081f79774cddee55f2f21e2cbd89">create_child</a> (var, i, name);
<a name="l01300"></a>01300           <a class="code" href="vec_8h.html#ae898349bda7814bcf92db36c0550a10f">VEC_replace</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children, i, existing);
<a name="l01301"></a>01301         }
<a name="l01302"></a>01302     }
<a name="l01303"></a>01303 
<a name="l01304"></a>01304   <a class="code" href="varobj_8c.html#afde0b8827029c1be162daa485403f344">restrict_range</a> (var-&gt;children, from, to);
<a name="l01305"></a>01305   <span class="keywordflow">return</span> var-&gt;children;
<a name="l01306"></a>01306 }
<a name="l01307"></a>01307 
<a name="l01308"></a>01308 <span class="preprocessor">#if HAVE_PYTHON</span>
<a name="l01309"></a>01309 <span class="preprocessor"></span>
<a name="l01310"></a>01310 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *
<a name="l01311"></a>01311 varobj_add_child (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> value *value)
<a name="l01312"></a>01312 {
<a name="l01313"></a>01313   <a class="code" href="structvarobj.html">varobj_p</a> v = <a class="code" href="varobj_8c.html#acfb70e4ed6d65d2a5c4f3d52704ba120">create_child_with_value</a> (var, 
<a name="l01314"></a>01314                                         <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children), 
<a name="l01315"></a>01315                                         name, value);
<a name="l01316"></a>01316 
<a name="l01317"></a>01317   <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children, v);
<a name="l01318"></a>01318   <span class="keywordflow">return</span> v;
<a name="l01319"></a>01319 }
<a name="l01320"></a>01320 
<a name="l01321"></a>01321 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_PYTHON */</span>
<a name="l01322"></a>01322 
<a name="l01323"></a>01323 <span class="comment">/* Obtain the type of an object Variable as a string similar to the one gdb</span>
<a name="l01324"></a>01324 <span class="comment">   prints on the console.  */</span>
<a name="l01325"></a>01325 
<a name="l01326"></a>01326 <span class="keywordtype">char</span> *
<a name="l01327"></a><a class="code" href="varobj_8h.html#abbed36957b6c4795bb3f37ab04f32122">01327</a> <a class="code" href="varobj_8c.html#abbed36957b6c4795bb3f37ab04f32122">varobj_get_type</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l01328"></a>01328 {
<a name="l01329"></a>01329   <span class="comment">/* For the &quot;fake&quot; variables, do not return a type.  (It&#39;s type is</span>
<a name="l01330"></a>01330 <span class="comment">     NULL, too.)</span>
<a name="l01331"></a>01331 <span class="comment">     Do not return a type for invalid variables as well.  */</span>
<a name="l01332"></a>01332   <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a0af68d4c2837464c18ae1eb457749c7d">CPLUS_FAKE_CHILD</a> (var) || !var-&gt;root-&gt;is_valid)
<a name="l01333"></a>01333     <span class="keywordflow">return</span> NULL;
<a name="l01334"></a>01334 
<a name="l01335"></a>01335   <span class="keywordflow">return</span> <a class="code" href="typeprint_8c.html#ac7fc7b5499b2197aaa69091c39b64d53">type_to_string</a> (var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>);
<a name="l01336"></a>01336 }
<a name="l01337"></a>01337 
<a name="l01338"></a>01338 <span class="comment">/* Obtain the type of an object variable.  */</span>
<a name="l01339"></a>01339 
<a name="l01340"></a>01340 <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l01341"></a><a class="code" href="varobj_8h.html#a9e23120924e8ca4248585f8f3915daa4">01341</a> <a class="code" href="varobj_8c.html#a9e23120924e8ca4248585f8f3915daa4">varobj_get_gdb_type</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l01342"></a>01342 {
<a name="l01343"></a>01343   <span class="keywordflow">return</span> var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>;
<a name="l01344"></a>01344 }
<a name="l01345"></a>01345 
<a name="l01346"></a>01346 <span class="comment">/* Is VAR a path expression parent, i.e., can it be used to construct</span>
<a name="l01347"></a>01347 <span class="comment">   a valid path expression?  */</span>
<a name="l01348"></a>01348 
<a name="l01349"></a>01349 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01350"></a><a class="code" href="varobj_8c.html#a53c9ae0c5fab21351aadde65dedee8ee">01350</a> <a class="code" href="varobj_8c.html#a53c9ae0c5fab21351aadde65dedee8ee">is_path_expr_parent</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l01351"></a>01351 {
<a name="l01352"></a>01352   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l01353"></a>01353 
<a name="l01354"></a>01354   <span class="comment">/* &quot;Fake&quot; children are not path_expr parents.  */</span>
<a name="l01355"></a>01355   <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a0af68d4c2837464c18ae1eb457749c7d">CPLUS_FAKE_CHILD</a> (var))
<a name="l01356"></a>01356     <span class="keywordflow">return</span> 0;
<a name="l01357"></a>01357 
<a name="l01358"></a>01358   type = <a class="code" href="varobj_8c.html#adfcd4a24453cf037bb031b39a4a87051">get_value_type</a> (var);
<a name="l01359"></a>01359 
<a name="l01360"></a>01360   <span class="comment">/* Anonymous unions and structs are also not path_expr parents.  */</span>
<a name="l01361"></a>01361   <span class="keywordflow">return</span> !((<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l01362"></a>01362             || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l01363"></a>01363            &amp;&amp; <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) == NULL);
<a name="l01364"></a>01364 }
<a name="l01365"></a>01365 
<a name="l01366"></a>01366 <span class="comment">/* Return the path expression parent for VAR.  */</span>
<a name="l01367"></a>01367 
<a name="l01368"></a>01368 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *
<a name="l01369"></a><a class="code" href="varobj_8c.html#a3f79cdc2c6e352fcdc731099f1f73dee">01369</a> <a class="code" href="varobj_8c.html#a3f79cdc2c6e352fcdc731099f1f73dee">get_path_expr_parent</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l01370"></a>01370 {
<a name="l01371"></a>01371   <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a> = var;
<a name="l01372"></a>01372 
<a name="l01373"></a>01373   <span class="keywordflow">while</span> (!<a class="code" href="varobj_8c.html#ac5da1ead02d1559acf6836dcc1dbc4cc">is_root_p</a> (parent) &amp;&amp; !<a class="code" href="varobj_8c.html#a53c9ae0c5fab21351aadde65dedee8ee">is_path_expr_parent</a> (parent))
<a name="l01374"></a>01374     parent = parent-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>;
<a name="l01375"></a>01375 
<a name="l01376"></a>01376   <span class="keywordflow">return</span> <a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>;
<a name="l01377"></a>01377 }
<a name="l01378"></a>01378 
<a name="l01379"></a>01379 <span class="comment">/* Return a pointer to the full rooted expression of varobj VAR.</span>
<a name="l01380"></a>01380 <span class="comment">   If it has not been computed yet, compute it.  */</span>
<a name="l01381"></a>01381 <span class="keywordtype">char</span> *
<a name="l01382"></a><a class="code" href="varobj_8h.html#a2fc03eff6c70500f410ef940f05bbc06">01382</a> <a class="code" href="varobj_8c.html#a2fc03eff6c70500f410ef940f05bbc06">varobj_get_path_expr</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l01383"></a>01383 {
<a name="l01384"></a>01384   <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#ab61f8b5cf72e56285b2c14a89aafc7ff">path_expr</a> != NULL)
<a name="l01385"></a>01385     <span class="keywordflow">return</span> var-&gt;<a class="code" href="structvarobj.html#ab61f8b5cf72e56285b2c14a89aafc7ff">path_expr</a>;
<a name="l01386"></a>01386   <span class="keywordflow">else</span> 
<a name="l01387"></a>01387     {
<a name="l01388"></a>01388       <span class="comment">/* For root varobjs, we initialize path_expr</span>
<a name="l01389"></a>01389 <span class="comment">         when creating varobj, so here it should be</span>
<a name="l01390"></a>01390 <span class="comment">         child varobj.  */</span>
<a name="l01391"></a>01391       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!<a class="code" href="varobj_8c.html#ac5da1ead02d1559acf6836dcc1dbc4cc">is_root_p</a> (var));
<a name="l01392"></a>01392       <span class="keywordflow">return</span> (*var-&gt;root-&gt;lang-&gt;path_expr_of_child) (var);
<a name="l01393"></a>01393     }
<a name="l01394"></a>01394 }
<a name="l01395"></a>01395 
<a name="l01396"></a>01396 <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a8f290bc3f9b2441d6fd55bd85dd774bb">varobj_languages</a>
<a name="l01397"></a><a class="code" href="varobj_8h.html#a54ba3885f3845e25150d1e6460e58115">01397</a> <a class="code" href="varobj_8c.html#a54ba3885f3845e25150d1e6460e58115">varobj_get_language</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l01398"></a>01398 {
<a name="l01399"></a>01399   <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#a2e77519a3fba8c0ddec2cf0418d7a9a4">variable_language</a> (var);
<a name="l01400"></a>01400 }
<a name="l01401"></a>01401 
<a name="l01402"></a>01402 <span class="keywordtype">int</span>
<a name="l01403"></a><a class="code" href="varobj_8h.html#ab4c7b9d0909046bc26e3c3d50cfb85a7">01403</a> <a class="code" href="varobj_8c.html#ab4c7b9d0909046bc26e3c3d50cfb85a7">varobj_get_attributes</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l01404"></a>01404 {
<a name="l01405"></a>01405   <span class="keywordtype">int</span> <a class="code" href="ada-lex_8c.html#a2e26e57e474983fafbadfd3fd3563dad">attributes</a> = 0;
<a name="l01406"></a>01406 
<a name="l01407"></a>01407   <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a1a38528222361cdfcfe2648d7afaef74">varobj_editable_p</a> (var))
<a name="l01408"></a>01408     <span class="comment">/* FIXME: define masks for attributes.  */</span>
<a name="l01409"></a>01409     attributes |= 0x00000001;   <span class="comment">/* Editable */</span>
<a name="l01410"></a>01410 
<a name="l01411"></a>01411   <span class="keywordflow">return</span> <a class="code" href="ada-lex_8c.html#a2e26e57e474983fafbadfd3fd3563dad">attributes</a>;
<a name="l01412"></a>01412 }
<a name="l01413"></a>01413 
<a name="l01414"></a>01414 <span class="keywordtype">int</span>
<a name="l01415"></a><a class="code" href="varobj_8h.html#a6b47c329dca79d70824e30c4611df84a">01415</a> <a class="code" href="varobj_8c.html#a6b47c329dca79d70824e30c4611df84a">varobj_pretty_printed_p</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l01416"></a>01416 {
<a name="l01417"></a>01417   <span class="keywordflow">return</span> var-&gt;pretty_printer != NULL;
<a name="l01418"></a>01418 }
<a name="l01419"></a>01419 
<a name="l01420"></a>01420 <span class="keywordtype">char</span> *
<a name="l01421"></a><a class="code" href="varobj_8h.html#a585ea8c4f285a048d4a62c5a8b71b100">01421</a> <a class="code" href="varobj_8c.html#a585ea8c4f285a048d4a62c5a8b71b100">varobj_get_formatted_value</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var,
<a name="l01422"></a>01422                             <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format)
<a name="l01423"></a>01423 {
<a name="l01424"></a>01424   <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#a2af60930bf1939550552e6c1fc1096eb">my_value_of_variable</a> (var, format);
<a name="l01425"></a>01425 }
<a name="l01426"></a>01426 
<a name="l01427"></a>01427 <span class="keywordtype">char</span> *
<a name="l01428"></a><a class="code" href="varobj_8h.html#a09fa3b3a1181f521778ea8d1bda33979">01428</a> <a class="code" href="varobj_8c.html#a09fa3b3a1181f521778ea8d1bda33979">varobj_get_value</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l01429"></a>01429 {
<a name="l01430"></a>01430   <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#a2af60930bf1939550552e6c1fc1096eb">my_value_of_variable</a> (var, var-&gt;format);
<a name="l01431"></a>01431 }
<a name="l01432"></a>01432 
<a name="l01433"></a>01433 <span class="comment">/* Set the value of an object variable (if it is editable) to the</span>
<a name="l01434"></a>01434 <span class="comment">   value of the given expression.  */</span>
<a name="l01435"></a>01435 <span class="comment">/* Note: Invokes functions that can call error().  */</span>
<a name="l01436"></a>01436 
<a name="l01437"></a>01437 <span class="keywordtype">int</span>
<a name="l01438"></a><a class="code" href="varobj_8h.html#ac4995b907357067a6f408a985139315e">01438</a> <a class="code" href="varobj_8c.html#ac4995b907357067a6f408a985139315e">varobj_set_value</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keywordtype">char</span> *<a class="code" href="structexpression.html">expression</a>)
<a name="l01439"></a>01439 {
<a name="l01440"></a>01440   <span class="keyword">struct </span>value *val = NULL; <span class="comment">/* Initialize to keep gcc happy.  */</span>
<a name="l01441"></a>01441   <span class="comment">/* The argument &quot;expression&quot; contains the variable&#39;s new value.</span>
<a name="l01442"></a>01442 <span class="comment">     We need to first construct a legal expression for this -- ugh!  */</span>
<a name="l01443"></a>01443   <span class="comment">/* Does this cover all the bases?  */</span>
<a name="l01444"></a>01444   <span class="keyword">struct </span>expression *exp;
<a name="l01445"></a>01445   <span class="keyword">struct </span>value *value = NULL; <span class="comment">/* Initialize to keep gcc happy.  */</span>
<a name="l01446"></a>01446   <span class="keywordtype">int</span> saved_input_radix = <a class="code" href="defs_8h.html#a64e476dca2e961ebe24ba32289c77c4e">input_radix</a>;
<a name="l01447"></a>01447   <span class="keyword">const</span> <span class="keywordtype">char</span> *s = expression;
<a name="l01448"></a>01448   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> except;
<a name="l01449"></a>01449 
<a name="l01450"></a>01450   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="varobj_8c.html#a1a38528222361cdfcfe2648d7afaef74">varobj_editable_p</a> (var));
<a name="l01451"></a>01451 
<a name="l01452"></a>01452   <a class="code" href="defs_8h.html#a64e476dca2e961ebe24ba32289c77c4e">input_radix</a> = 10;             <span class="comment">/* ALWAYS reset to decimal temporarily.  */</span>
<a name="l01453"></a>01453   exp = <a class="code" href="expression_8h.html#abdad295cc4b5351f6e6ec024ab665475">parse_exp_1</a> (&amp;s, 0, 0, 0);
<a name="l01454"></a>01454   <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l01455"></a>01455     {
<a name="l01456"></a>01456       value = <a class="code" href="eval_8c.html#ab50151ccba3ea3184c114121d6bed422">evaluate_expression</a> (exp);
<a name="l01457"></a>01457     }
<a name="l01458"></a>01458 
<a name="l01459"></a>01459   <span class="keywordflow">if</span> (except.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0)
<a name="l01460"></a>01460     {
<a name="l01461"></a>01461       <span class="comment">/* We cannot proceed without a valid expression.  */</span>
<a name="l01462"></a>01462       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (exp);
<a name="l01463"></a>01463       <span class="keywordflow">return</span> 0;
<a name="l01464"></a>01464     }
<a name="l01465"></a>01465 
<a name="l01466"></a>01466   <span class="comment">/* All types that are editable must also be changeable.  */</span>
<a name="l01467"></a>01467   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="varobj_8c.html#a176f5fae4079ee6acd5df422bd0e8f4c">varobj_value_is_changeable_p</a> (var));
<a name="l01468"></a>01468 
<a name="l01469"></a>01469   <span class="comment">/* The value of a changeable variable object must not be lazy.  */</span>
<a name="l01470"></a>01470   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!<a class="code" href="value_8c.html#aa60bc8ecf77867a2d16bec57a4ccf983">value_lazy</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>));
<a name="l01471"></a>01471 
<a name="l01472"></a>01472   <span class="comment">/* Need to coerce the input.  We want to check if the</span>
<a name="l01473"></a>01473 <span class="comment">     value of the variable object will be different</span>
<a name="l01474"></a>01474 <span class="comment">     after assignment, and the first thing value_assign</span>
<a name="l01475"></a>01475 <span class="comment">     does is coerce the input.</span>
<a name="l01476"></a>01476 <span class="comment">     For example, if we are assigning an array to a pointer variable we</span>
<a name="l01477"></a>01477 <span class="comment">     should compare the pointer with the array&#39;s address, not with the</span>
<a name="l01478"></a>01478 <span class="comment">     array&#39;s content.  */</span>
<a name="l01479"></a>01479   value = <a class="code" href="value_8c.html#a773e1b64380b836763411d405aa758f1">coerce_array</a> (value);
<a name="l01480"></a>01480 
<a name="l01481"></a>01481   <span class="comment">/* The new value may be lazy.  value_assign, or</span>
<a name="l01482"></a>01482 <span class="comment">     rather value_contents, will take care of this.  */</span>
<a name="l01483"></a>01483   <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l01484"></a>01484     {
<a name="l01485"></a>01485       val = <a class="code" href="valops_8c.html#a1357019ae48dabe7c46916ab0cf04ba2">value_assign</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>, value);
<a name="l01486"></a>01486     }
<a name="l01487"></a>01487 
<a name="l01488"></a>01488   <span class="keywordflow">if</span> (except.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0)
<a name="l01489"></a>01489     <span class="keywordflow">return</span> 0;
<a name="l01490"></a>01490 
<a name="l01491"></a>01491   <span class="comment">/* If the value has changed, record it, so that next -var-update can</span>
<a name="l01492"></a>01492 <span class="comment">     report this change.  If a variable had a value of &#39;1&#39;, we&#39;ve set it</span>
<a name="l01493"></a>01493 <span class="comment">     to &#39;333&#39; and then set again to &#39;1&#39;, when -var-update will report this</span>
<a name="l01494"></a>01494 <span class="comment">     variable as changed -- because the first assignment has set the</span>
<a name="l01495"></a>01495 <span class="comment">     &#39;updated&#39; flag.  There&#39;s no need to optimize that, because return value</span>
<a name="l01496"></a>01496 <span class="comment">     of -var-update should be considered an approximation.  */</span>
<a name="l01497"></a>01497   var-&gt;updated = <a class="code" href="varobj_8c.html#acb8313007f98eac3c62634057219329d">install_new_value</a> (var, val, 0 <span class="comment">/* Compare values.  */</span>);
<a name="l01498"></a>01498   <a class="code" href="defs_8h.html#a64e476dca2e961ebe24ba32289c77c4e">input_radix</a> = saved_input_radix;
<a name="l01499"></a>01499   <span class="keywordflow">return</span> 1;
<a name="l01500"></a>01500 }
<a name="l01501"></a>01501 
<a name="l01502"></a>01502 <span class="preprocessor">#if HAVE_PYTHON</span>
<a name="l01503"></a>01503 <span class="preprocessor"></span>
<a name="l01504"></a>01504 <span class="comment">/* A helper function to install a constructor function and visualizer</span>
<a name="l01505"></a>01505 <span class="comment">   in a varobj.  */</span>
<a name="l01506"></a>01506 
<a name="l01507"></a>01507 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01508"></a>01508 install_visualizer (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *constructor,
<a name="l01509"></a>01509                     <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *visualizer)
<a name="l01510"></a>01510 {
<a name="l01511"></a>01511   Py_XDECREF (var-&gt;constructor);
<a name="l01512"></a>01512   var-&gt;constructor = constructor;
<a name="l01513"></a>01513 
<a name="l01514"></a>01514   Py_XDECREF (var-&gt;pretty_printer);
<a name="l01515"></a>01515   var-&gt;pretty_printer = visualizer;
<a name="l01516"></a>01516 
<a name="l01517"></a>01517   Py_XDECREF (var-&gt;child_iter);
<a name="l01518"></a>01518   var-&gt;child_iter = NULL;
<a name="l01519"></a>01519 }
<a name="l01520"></a>01520 
<a name="l01521"></a>01521 <span class="comment">/* Install the default visualizer for VAR.  */</span>
<a name="l01522"></a>01522 
<a name="l01523"></a>01523 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01524"></a>01524 install_default_visualizer (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l01525"></a>01525 {
<a name="l01526"></a>01526   <span class="comment">/* Do not install a visualizer on a CPLUS_FAKE_CHILD.  */</span>
<a name="l01527"></a>01527   <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a0af68d4c2837464c18ae1eb457749c7d">CPLUS_FAKE_CHILD</a> (var))
<a name="l01528"></a>01528     <span class="keywordflow">return</span>;
<a name="l01529"></a>01529 
<a name="l01530"></a>01530   <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a2d0bd70e54ff2fa9e274811bcba8c6d4">pretty_printing</a>)
<a name="l01531"></a>01531     {
<a name="l01532"></a>01532       <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *pretty_printer = NULL;
<a name="l01533"></a>01533 
<a name="l01534"></a>01534       <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>)
<a name="l01535"></a>01535         {
<a name="l01536"></a>01536           pretty_printer = <a class="code" href="python-internal_8h.html#a6a52cc09caafaace4075dfbb35b50f0e">gdbpy_get_varobj_pretty_printer</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>);
<a name="l01537"></a>01537           <span class="keywordflow">if</span> (! pretty_printer)
<a name="l01538"></a>01538             {
<a name="l01539"></a>01539               <a class="code" href="python-internal_8h.html#a0547cdf5b8063543c37589085a7cfe31">gdbpy_print_stack</a> ();
<a name="l01540"></a>01540               <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot instantiate printer for default visualizer&quot;</span>));
<a name="l01541"></a>01541             }
<a name="l01542"></a>01542         }
<a name="l01543"></a>01543       
<a name="l01544"></a>01544       <span class="keywordflow">if</span> (pretty_printer == Py_None)
<a name="l01545"></a>01545         {
<a name="l01546"></a>01546           <a class="code" href="python-internal_8h.html#a19be7acd3e9a57b82c7be99b8594d293">Py_DECREF</a> (pretty_printer);
<a name="l01547"></a>01547           pretty_printer = NULL;
<a name="l01548"></a>01548         }
<a name="l01549"></a>01549   
<a name="l01550"></a>01550       install_visualizer (var, NULL, pretty_printer);
<a name="l01551"></a>01551     }
<a name="l01552"></a>01552 }
<a name="l01553"></a>01553 
<a name="l01554"></a>01554 <span class="comment">/* Instantiate and install a visualizer for VAR using CONSTRUCTOR to</span>
<a name="l01555"></a>01555 <span class="comment">   make a new object.  */</span>
<a name="l01556"></a>01556 
<a name="l01557"></a>01557 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01558"></a>01558 construct_visualizer (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *constructor)
<a name="l01559"></a>01559 {
<a name="l01560"></a>01560   <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *pretty_printer;
<a name="l01561"></a>01561 
<a name="l01562"></a>01562   <span class="comment">/* Do not install a visualizer on a CPLUS_FAKE_CHILD.  */</span>
<a name="l01563"></a>01563   <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a0af68d4c2837464c18ae1eb457749c7d">CPLUS_FAKE_CHILD</a> (var))
<a name="l01564"></a>01564     <span class="keywordflow">return</span>;
<a name="l01565"></a>01565 
<a name="l01566"></a>01566   Py_INCREF (constructor);
<a name="l01567"></a>01567   <span class="keywordflow">if</span> (constructor == Py_None)
<a name="l01568"></a>01568     pretty_printer = NULL;
<a name="l01569"></a>01569   <span class="keywordflow">else</span>
<a name="l01570"></a>01570     {
<a name="l01571"></a>01571       pretty_printer = instantiate_pretty_printer (constructor, var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>);
<a name="l01572"></a>01572       <span class="keywordflow">if</span> (! pretty_printer)
<a name="l01573"></a>01573         {
<a name="l01574"></a>01574           <a class="code" href="python-internal_8h.html#a0547cdf5b8063543c37589085a7cfe31">gdbpy_print_stack</a> ();
<a name="l01575"></a>01575           <a class="code" href="python-internal_8h.html#a19be7acd3e9a57b82c7be99b8594d293">Py_DECREF</a> (constructor);
<a name="l01576"></a>01576           constructor = Py_None;
<a name="l01577"></a>01577           Py_INCREF (constructor);
<a name="l01578"></a>01578         }
<a name="l01579"></a>01579 
<a name="l01580"></a>01580       <span class="keywordflow">if</span> (pretty_printer == Py_None)
<a name="l01581"></a>01581         {
<a name="l01582"></a>01582           <a class="code" href="python-internal_8h.html#a19be7acd3e9a57b82c7be99b8594d293">Py_DECREF</a> (pretty_printer);
<a name="l01583"></a>01583           pretty_printer = NULL;
<a name="l01584"></a>01584         }
<a name="l01585"></a>01585     }
<a name="l01586"></a>01586 
<a name="l01587"></a>01587   install_visualizer (var, constructor, pretty_printer);
<a name="l01588"></a>01588 }
<a name="l01589"></a>01589 
<a name="l01590"></a>01590 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_PYTHON */</span>
<a name="l01591"></a>01591 
<a name="l01592"></a>01592 <span class="comment">/* A helper function for install_new_value.  This creates and installs</span>
<a name="l01593"></a>01593 <span class="comment">   a visualizer for VAR, if appropriate.  */</span>
<a name="l01594"></a>01594 
<a name="l01595"></a>01595 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01596"></a><a class="code" href="varobj_8c.html#abcda26aa3f31d641a2e56f186c32ea2e">01596</a> <a class="code" href="varobj_8c.html#abcda26aa3f31d641a2e56f186c32ea2e">install_new_value_visualizer</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l01597"></a>01597 {
<a name="l01598"></a>01598 <span class="preprocessor">#if HAVE_PYTHON</span>
<a name="l01599"></a>01599 <span class="preprocessor"></span>  <span class="comment">/* If the constructor is None, then we want the raw value.  If VAR</span>
<a name="l01600"></a>01600 <span class="comment">     does not have a value, just skip this.  */</span>
<a name="l01601"></a>01601   <span class="keywordflow">if</span> (!<a class="code" href="python-internal_8h.html#a2f9782caf78c6a6f300ce14c165d9605">gdb_python_initialized</a>)
<a name="l01602"></a>01602     <span class="keywordflow">return</span>;
<a name="l01603"></a>01603 
<a name="l01604"></a>01604   <span class="keywordflow">if</span> (var-&gt;constructor != Py_None &amp;&amp; var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>)
<a name="l01605"></a>01605     {
<a name="l01606"></a>01606       <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l01607"></a>01607 
<a name="l01608"></a>01608       cleanup = varobj_ensure_python_env (var);
<a name="l01609"></a>01609 
<a name="l01610"></a>01610       <span class="keywordflow">if</span> (!var-&gt;constructor)
<a name="l01611"></a>01611         install_default_visualizer (var);
<a name="l01612"></a>01612       <span class="keywordflow">else</span>
<a name="l01613"></a>01613         construct_visualizer (var, var-&gt;constructor);
<a name="l01614"></a>01614 
<a name="l01615"></a>01615       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l01616"></a>01616     }
<a name="l01617"></a>01617 <span class="preprocessor">#else</span>
<a name="l01618"></a>01618 <span class="preprocessor"></span>  <span class="comment">/* Do nothing.  */</span>
<a name="l01619"></a>01619 <span class="preprocessor">#endif</span>
<a name="l01620"></a>01620 <span class="preprocessor"></span>}
<a name="l01621"></a>01621 
<a name="l01622"></a>01622 <span class="comment">/* When using RTTI to determine variable type it may be changed in runtime when</span>
<a name="l01623"></a>01623 <span class="comment">   the variable value is changed.  This function checks whether type of varobj</span>
<a name="l01624"></a>01624 <span class="comment">   VAR will change when a new value NEW_VALUE is assigned and if it is so</span>
<a name="l01625"></a>01625 <span class="comment">   updates the type of VAR.  */</span>
<a name="l01626"></a>01626 
<a name="l01627"></a>01627 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01628"></a><a class="code" href="varobj_8c.html#a8de9d1ed628fd6139ef82609d3b3460a">01628</a> <a class="code" href="varobj_8c.html#a8de9d1ed628fd6139ef82609d3b3460a">update_type_if_necessary</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keyword">struct</span> value *new_value)
<a name="l01629"></a>01629 {
<a name="l01630"></a>01630   <span class="keywordflow">if</span> (new_value)
<a name="l01631"></a>01631     {
<a name="l01632"></a>01632       <span class="keyword">struct </span><a class="code" href="structvalue__print__options.html">value_print_options</a> opts;
<a name="l01633"></a>01633 
<a name="l01634"></a>01634       <a class="code" href="valprint_8c.html#aa2d4dfe4b11841ccafc4d0c0d410095d">get_user_print_options</a> (&amp;opts);
<a name="l01635"></a>01635       <span class="keywordflow">if</span> (opts.<a class="code" href="structvalue__print__options.html#a57721e2ef5660a31f4151ec00d831b13">objectprint</a>)
<a name="l01636"></a>01636         {
<a name="l01637"></a>01637           <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="mdebugread_8c.html#ab1ece714ac6020a52b26279dfc1b20d7">new_type</a>;
<a name="l01638"></a>01638           <span class="keywordtype">char</span> *curr_type_str, *new_type_str;
<a name="l01639"></a>01639 
<a name="l01640"></a>01640           new_type = <a class="code" href="value_8c.html#aad0d3b9452bbb8b01fb2f0cc5f1bf093">value_actual_type</a> (new_value, 0, 0);
<a name="l01641"></a>01641           new_type_str = <a class="code" href="typeprint_8c.html#ac7fc7b5499b2197aaa69091c39b64d53">type_to_string</a> (new_type);
<a name="l01642"></a>01642           curr_type_str = <a class="code" href="varobj_8c.html#abbed36957b6c4795bb3f37ab04f32122">varobj_get_type</a> (var);
<a name="l01643"></a>01643           <span class="keywordflow">if</span> (strcmp (curr_type_str, new_type_str) != 0)
<a name="l01644"></a>01644             {
<a name="l01645"></a>01645               var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a> = <a class="code" href="mdebugread_8c.html#ab1ece714ac6020a52b26279dfc1b20d7">new_type</a>;
<a name="l01646"></a>01646 
<a name="l01647"></a>01647               <span class="comment">/* This information may be not valid for a new type.  */</span>
<a name="l01648"></a>01648               <a class="code" href="varobj_8c.html#aad58751b29b14a5eeb8b9879df27683d">varobj_delete</a> (var, NULL, 1);
<a name="l01649"></a>01649               <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children);
<a name="l01650"></a>01650               var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a> = -1;
<a name="l01651"></a>01651               <span class="keywordflow">return</span> 1;
<a name="l01652"></a>01652             }
<a name="l01653"></a>01653         }
<a name="l01654"></a>01654     }
<a name="l01655"></a>01655 
<a name="l01656"></a>01656   <span class="keywordflow">return</span> 0;
<a name="l01657"></a>01657 }
<a name="l01658"></a>01658 
<a name="l01659"></a>01659 <span class="comment">/* Assign a new value to a variable object.  If INITIAL is non-zero,</span>
<a name="l01660"></a>01660 <span class="comment">   this is the first assignement after the variable object was just</span>
<a name="l01661"></a>01661 <span class="comment">   created, or changed type.  In that case, just assign the value </span>
<a name="l01662"></a>01662 <span class="comment">   and return 0.</span>
<a name="l01663"></a>01663 <span class="comment">   Otherwise, assign the new value, and return 1 if the value is</span>
<a name="l01664"></a>01664 <span class="comment">   different from the current one, 0 otherwise.  The comparison is</span>
<a name="l01665"></a>01665 <span class="comment">   done on textual representation of value.  Therefore, some types</span>
<a name="l01666"></a>01666 <span class="comment">   need not be compared.  E.g.  for structures the reported value is</span>
<a name="l01667"></a>01667 <span class="comment">   always &quot;{...}&quot;, so no comparison is necessary here.  If the old</span>
<a name="l01668"></a>01668 <span class="comment">   value was NULL and new one is not, or vice versa, we always return 1.</span>
<a name="l01669"></a>01669 <span class="comment"></span>
<a name="l01670"></a>01670 <span class="comment">   The VALUE parameter should not be released -- the function will</span>
<a name="l01671"></a>01671 <span class="comment">   take care of releasing it when needed.  */</span>
<a name="l01672"></a>01672 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01673"></a><a class="code" href="varobj_8c.html#acb8313007f98eac3c62634057219329d">01673</a> <a class="code" href="varobj_8c.html#acb8313007f98eac3c62634057219329d">install_new_value</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keyword">struct</span> value *value, <span class="keywordtype">int</span> initial)
<a name="l01674"></a>01674 { 
<a name="l01675"></a>01675   <span class="keywordtype">int</span> changeable;
<a name="l01676"></a>01676   <span class="keywordtype">int</span> need_to_fetch;
<a name="l01677"></a>01677   <span class="keywordtype">int</span> changed = 0;
<a name="l01678"></a>01678   <span class="keywordtype">int</span> intentionally_not_fetched = 0;
<a name="l01679"></a>01679   <span class="keywordtype">char</span> *print_value = NULL;
<a name="l01680"></a>01680 
<a name="l01681"></a>01681   <span class="comment">/* We need to know the varobj&#39;s type to decide if the value should</span>
<a name="l01682"></a>01682 <span class="comment">     be fetched or not.  C++ fake children (public/protected/private)</span>
<a name="l01683"></a>01683 <span class="comment">     don&#39;t have a type.  */</span>
<a name="l01684"></a>01684   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a> || <a class="code" href="varobj_8c.html#a0af68d4c2837464c18ae1eb457749c7d">CPLUS_FAKE_CHILD</a> (var));
<a name="l01685"></a>01685   changeable = <a class="code" href="varobj_8c.html#a176f5fae4079ee6acd5df422bd0e8f4c">varobj_value_is_changeable_p</a> (var);
<a name="l01686"></a>01686 
<a name="l01687"></a>01687   <span class="comment">/* If the type has custom visualizer, we consider it to be always</span>
<a name="l01688"></a>01688 <span class="comment">     changeable.  FIXME: need to make sure this behaviour will not</span>
<a name="l01689"></a>01689 <span class="comment">     mess up read-sensitive values.  */</span>
<a name="l01690"></a>01690   <span class="keywordflow">if</span> (var-&gt;pretty_printer)
<a name="l01691"></a>01691     changeable = 1;
<a name="l01692"></a>01692 
<a name="l01693"></a>01693   need_to_fetch = changeable;
<a name="l01694"></a>01694 
<a name="l01695"></a>01695   <span class="comment">/* We are not interested in the address of references, and given</span>
<a name="l01696"></a>01696 <span class="comment">     that in C++ a reference is not rebindable, it cannot</span>
<a name="l01697"></a>01697 <span class="comment">     meaningfully change.  So, get hold of the real value.  */</span>
<a name="l01698"></a>01698   <span class="keywordflow">if</span> (value)
<a name="l01699"></a>01699     value = <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (value);
<a name="l01700"></a>01700 
<a name="l01701"></a>01701   <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a> &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l01702"></a>01702     <span class="comment">/* For unions, we need to fetch the value implicitly because</span>
<a name="l01703"></a>01703 <span class="comment">       of implementation of union member fetch.  When gdb</span>
<a name="l01704"></a>01704 <span class="comment">       creates a value for a field and the value of the enclosing</span>
<a name="l01705"></a>01705 <span class="comment">       structure is not lazy,  it immediately copies the necessary</span>
<a name="l01706"></a>01706 <span class="comment">       bytes from the enclosing values.  If the enclosing value is</span>
<a name="l01707"></a>01707 <span class="comment">       lazy, the call to value_fetch_lazy on the field will read</span>
<a name="l01708"></a>01708 <span class="comment">       the data from memory.  For unions, that means we&#39;ll read the</span>
<a name="l01709"></a>01709 <span class="comment">       same memory more than once, which is not desirable.  So</span>
<a name="l01710"></a>01710 <span class="comment">       fetch now.  */</span>
<a name="l01711"></a>01711     need_to_fetch = 1;
<a name="l01712"></a>01712 
<a name="l01713"></a>01713   <span class="comment">/* The new value might be lazy.  If the type is changeable,</span>
<a name="l01714"></a>01714 <span class="comment">     that is we&#39;ll be comparing values of this type, fetch the</span>
<a name="l01715"></a>01715 <span class="comment">     value now.  Otherwise, on the next update the old value</span>
<a name="l01716"></a>01716 <span class="comment">     will be lazy, which means we&#39;ve lost that old value.  */</span>
<a name="l01717"></a>01717   <span class="keywordflow">if</span> (need_to_fetch &amp;&amp; value &amp;&amp; <a class="code" href="value_8c.html#aa60bc8ecf77867a2d16bec57a4ccf983">value_lazy</a> (value))
<a name="l01718"></a>01718     {
<a name="l01719"></a>01719       <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a> = var-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>;
<a name="l01720"></a>01720       <span class="keywordtype">int</span> frozen = var-&gt;frozen;
<a name="l01721"></a>01721 
<a name="l01722"></a>01722       <span class="keywordflow">for</span> (; !frozen &amp;&amp; <a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>; parent = parent-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>)
<a name="l01723"></a>01723         frozen |= parent-&gt;frozen;
<a name="l01724"></a>01724 
<a name="l01725"></a>01725       if (frozen &amp;&amp; initial)
<a name="l01726"></a>01726         {
<a name="l01727"></a>01727           <span class="comment">/* For variables that are frozen, or are children of frozen</span>
<a name="l01728"></a>01728 <span class="comment">             variables, we don&#39;t do fetch on initial assignment.</span>
<a name="l01729"></a>01729 <span class="comment">             For non-initial assignemnt we do the fetch, since it means we&#39;re</span>
<a name="l01730"></a>01730 <span class="comment">             explicitly asked to compare the new value with the old one.  */</span>
<a name="l01731"></a>01731           intentionally_not_fetched = 1;
<a name="l01732"></a>01732         }
<a name="l01733"></a>01733       <span class="keywordflow">else</span>
<a name="l01734"></a>01734         {
<a name="l01735"></a>01735           <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> except;
<a name="l01736"></a>01736 
<a name="l01737"></a>01737           <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l01738"></a>01738             {
<a name="l01739"></a>01739               <a class="code" href="value_8c.html#a27ee2d69678b458a82ac350e2e2132d8">value_fetch_lazy</a> (value);
<a name="l01740"></a>01740             }
<a name="l01741"></a>01741 
<a name="l01742"></a>01742           <span class="keywordflow">if</span> (except.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0)
<a name="l01743"></a>01743             {
<a name="l01744"></a>01744               <span class="comment">/* Set the value to NULL, so that for the next -var-update,</span>
<a name="l01745"></a>01745 <span class="comment">                 we don&#39;t try to compare the new value with this value,</span>
<a name="l01746"></a>01746 <span class="comment">                 that we couldn&#39;t even read.  */</span>
<a name="l01747"></a>01747               value = NULL;
<a name="l01748"></a>01748             }
<a name="l01749"></a>01749         }
<a name="l01750"></a>01750     }
<a name="l01751"></a>01751 
<a name="l01752"></a>01752   <span class="comment">/* Get a reference now, before possibly passing it to any Python</span>
<a name="l01753"></a>01753 <span class="comment">     code that might release it.  */</span>
<a name="l01754"></a>01754   <span class="keywordflow">if</span> (value != NULL)
<a name="l01755"></a>01755     <a class="code" href="value_8c.html#aa275c12b833e50f508ab05a42559a0d8">value_incref</a> (value);
<a name="l01756"></a>01756 
<a name="l01757"></a>01757   <span class="comment">/* Below, we&#39;ll be comparing string rendering of old and new</span>
<a name="l01758"></a>01758 <span class="comment">     values.  Don&#39;t get string rendering if the value is</span>
<a name="l01759"></a>01759 <span class="comment">     lazy -- if it is, the code above has decided that the value</span>
<a name="l01760"></a>01760 <span class="comment">     should not be fetched.  */</span>
<a name="l01761"></a>01761   <span class="keywordflow">if</span> (value &amp;&amp; !<a class="code" href="value_8c.html#aa60bc8ecf77867a2d16bec57a4ccf983">value_lazy</a> (value) &amp;&amp; !var-&gt;pretty_printer)
<a name="l01762"></a>01762     print_value = <a class="code" href="varobj_8c.html#a371cbd65da3254826f01cbf5fd49380c">value_get_print_value</a> (value, var-&gt;format, var);
<a name="l01763"></a>01763 
<a name="l01764"></a>01764   <span class="comment">/* If the type is changeable, compare the old and the new values.</span>
<a name="l01765"></a>01765 <span class="comment">     If this is the initial assignment, we don&#39;t have any old value</span>
<a name="l01766"></a>01766 <span class="comment">     to compare with.  */</span>
<a name="l01767"></a>01767   <span class="keywordflow">if</span> (!initial &amp;&amp; changeable)
<a name="l01768"></a>01768     {
<a name="l01769"></a>01769       <span class="comment">/* If the value of the varobj was changed by -var-set-value,</span>
<a name="l01770"></a>01770 <span class="comment">         then the value in the varobj and in the target is the same.</span>
<a name="l01771"></a>01771 <span class="comment">         However, that value is different from the value that the</span>
<a name="l01772"></a>01772 <span class="comment">         varobj had after the previous -var-update.  So need to the</span>
<a name="l01773"></a>01773 <span class="comment">         varobj as changed.  */</span>
<a name="l01774"></a>01774       <span class="keywordflow">if</span> (var-&gt;updated)
<a name="l01775"></a>01775         {
<a name="l01776"></a>01776           changed = 1;
<a name="l01777"></a>01777         }
<a name="l01778"></a>01778       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (! var-&gt;pretty_printer)
<a name="l01779"></a>01779         {
<a name="l01780"></a>01780           <span class="comment">/* Try to compare the values.  That requires that both</span>
<a name="l01781"></a>01781 <span class="comment">             values are non-lazy.  */</span>
<a name="l01782"></a>01782           <span class="keywordflow">if</span> (var-&gt;not_fetched &amp;&amp; <a class="code" href="value_8c.html#aa60bc8ecf77867a2d16bec57a4ccf983">value_lazy</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>))
<a name="l01783"></a>01783             {
<a name="l01784"></a>01784               <span class="comment">/* This is a frozen varobj and the value was never read.</span>
<a name="l01785"></a>01785 <span class="comment">                 Presumably, UI shows some &quot;never read&quot; indicator.</span>
<a name="l01786"></a>01786 <span class="comment">                 Now that we&#39;ve fetched the real value, we need to report</span>
<a name="l01787"></a>01787 <span class="comment">                 this varobj as changed so that UI can show the real</span>
<a name="l01788"></a>01788 <span class="comment">                 value.  */</span>
<a name="l01789"></a>01789               changed = 1;
<a name="l01790"></a>01790             }
<a name="l01791"></a>01791           <span class="keywordflow">else</span>  <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a> == NULL &amp;&amp; value == NULL)
<a name="l01792"></a>01792             <span class="comment">/* Equal.  */</span>
<a name="l01793"></a>01793             ;
<a name="l01794"></a>01794           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a> == NULL || value == NULL)
<a name="l01795"></a>01795             {
<a name="l01796"></a>01796               changed = 1;
<a name="l01797"></a>01797             }
<a name="l01798"></a>01798           <span class="keywordflow">else</span>
<a name="l01799"></a>01799             {
<a name="l01800"></a>01800               <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!<a class="code" href="value_8c.html#aa60bc8ecf77867a2d16bec57a4ccf983">value_lazy</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>));
<a name="l01801"></a>01801               <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!<a class="code" href="value_8c.html#aa60bc8ecf77867a2d16bec57a4ccf983">value_lazy</a> (value));
<a name="l01802"></a>01802 
<a name="l01803"></a>01803               <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (var-&gt;print_value != NULL &amp;&amp; print_value != NULL);
<a name="l01804"></a>01804               <span class="keywordflow">if</span> (strcmp (var-&gt;print_value, print_value) != 0)
<a name="l01805"></a>01805                 changed = 1;
<a name="l01806"></a>01806             }
<a name="l01807"></a>01807         }
<a name="l01808"></a>01808     }
<a name="l01809"></a>01809 
<a name="l01810"></a>01810   <span class="keywordflow">if</span> (!initial &amp;&amp; !changeable)
<a name="l01811"></a>01811     {
<a name="l01812"></a>01812       <span class="comment">/* For values that are not changeable, we don&#39;t compare the values.</span>
<a name="l01813"></a>01813 <span class="comment">         However, we want to notice if a value was not NULL and now is NULL,</span>
<a name="l01814"></a>01814 <span class="comment">         or vise versa, so that we report when top-level varobjs come in scope</span>
<a name="l01815"></a>01815 <span class="comment">         and leave the scope.  */</span>
<a name="l01816"></a>01816       changed = (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a> != NULL) != (value != NULL);
<a name="l01817"></a>01817     }
<a name="l01818"></a>01818 
<a name="l01819"></a>01819   <span class="comment">/* We must always keep the new value, since children depend on it.  */</span>
<a name="l01820"></a>01820   <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a> != NULL &amp;&amp; var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a> != value)
<a name="l01821"></a>01821     <a class="code" href="value_8c.html#a1f9b3ee232ece65ddc75c2407b97a50d">value_free</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>);
<a name="l01822"></a>01822   var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a> = value;
<a name="l01823"></a>01823   <span class="keywordflow">if</span> (value &amp;&amp; <a class="code" href="value_8c.html#aa60bc8ecf77867a2d16bec57a4ccf983">value_lazy</a> (value) &amp;&amp; intentionally_not_fetched)
<a name="l01824"></a>01824     var-&gt;not_fetched = 1;
<a name="l01825"></a>01825   <span class="keywordflow">else</span>
<a name="l01826"></a>01826     var-&gt;not_fetched = 0;
<a name="l01827"></a>01827   var-&gt;updated = 0;
<a name="l01828"></a>01828 
<a name="l01829"></a>01829   <a class="code" href="varobj_8c.html#abcda26aa3f31d641a2e56f186c32ea2e">install_new_value_visualizer</a> (var);
<a name="l01830"></a>01830 
<a name="l01831"></a>01831   <span class="comment">/* If we installed a pretty-printer, re-compare the printed version</span>
<a name="l01832"></a>01832 <span class="comment">     to see if the variable changed.  */</span>
<a name="l01833"></a>01833   <span class="keywordflow">if</span> (var-&gt;pretty_printer)
<a name="l01834"></a>01834     {
<a name="l01835"></a>01835       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (print_value);
<a name="l01836"></a>01836       print_value = <a class="code" href="varobj_8c.html#a371cbd65da3254826f01cbf5fd49380c">value_get_print_value</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>, var-&gt;format, var);
<a name="l01837"></a>01837       <span class="keywordflow">if</span> ((var-&gt;print_value == NULL &amp;&amp; print_value != NULL)
<a name="l01838"></a>01838           || (var-&gt;print_value != NULL &amp;&amp; print_value == NULL)
<a name="l01839"></a>01839           || (var-&gt;print_value != NULL &amp;&amp; print_value != NULL
<a name="l01840"></a>01840               &amp;&amp; strcmp (var-&gt;print_value, print_value) != 0))
<a name="l01841"></a>01841         changed = 1;
<a name="l01842"></a>01842     }
<a name="l01843"></a>01843   <span class="keywordflow">if</span> (var-&gt;print_value)
<a name="l01844"></a>01844     <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (var-&gt;print_value);
<a name="l01845"></a>01845   var-&gt;print_value = print_value;
<a name="l01846"></a>01846 
<a name="l01847"></a>01847   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a> || <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>));
<a name="l01848"></a>01848 
<a name="l01849"></a>01849   <span class="keywordflow">return</span> changed;
<a name="l01850"></a>01850 }
<a name="l01851"></a>01851 
<a name="l01852"></a>01852 <span class="comment">/* Return the requested range for a varobj.  VAR is the varobj.  FROM</span>
<a name="l01853"></a>01853 <span class="comment">   and TO are out parameters; *FROM and *TO will be set to the</span>
<a name="l01854"></a>01854 <span class="comment">   selected sub-range of VAR.  If no range was selected using</span>
<a name="l01855"></a>01855 <span class="comment">   -var-set-update-range, then both will be -1.  */</span>
<a name="l01856"></a>01856 <span class="keywordtype">void</span>
<a name="l01857"></a><a class="code" href="varobj_8h.html#ac047b61eebc6196aa5f13f016a155d23">01857</a> <a class="code" href="varobj_8c.html#ac047b61eebc6196aa5f13f016a155d23">varobj_get_child_range</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keywordtype">int</span> *<a class="code" href="varobj_8h.html#a43396decd62b46fa01cc6c66a84cbba1">from</a>, <span class="keywordtype">int</span> *<a class="code" href="varobj_8h.html#ae2a2635825813434f3201bf8ace439d2">to</a>)
<a name="l01858"></a>01858 {
<a name="l01859"></a>01859   *from = var-&gt;from;
<a name="l01860"></a>01860   *to = var-&gt;to;
<a name="l01861"></a>01861 }
<a name="l01862"></a>01862 
<a name="l01863"></a>01863 <span class="comment">/* Set the selected sub-range of children of VAR to start at index</span>
<a name="l01864"></a>01864 <span class="comment">   FROM and end at index TO.  If either FROM or TO is less than zero,</span>
<a name="l01865"></a>01865 <span class="comment">   this is interpreted as a request for all children.  */</span>
<a name="l01866"></a>01866 <span class="keywordtype">void</span>
<a name="l01867"></a><a class="code" href="varobj_8h.html#a5c54022a8d2040aae11daf21e4451b5d">01867</a> <a class="code" href="varobj_8c.html#a5c54022a8d2040aae11daf21e4451b5d">varobj_set_child_range</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keywordtype">int</span> <a class="code" href="varobj_8h.html#a43396decd62b46fa01cc6c66a84cbba1">from</a>, <span class="keywordtype">int</span> <a class="code" href="varobj_8h.html#ae2a2635825813434f3201bf8ace439d2">to</a>)
<a name="l01868"></a>01868 {
<a name="l01869"></a>01869   var-&gt;from = <a class="code" href="varobj_8h.html#a43396decd62b46fa01cc6c66a84cbba1">from</a>;
<a name="l01870"></a>01870   var-&gt;to = <a class="code" href="varobj_8h.html#ae2a2635825813434f3201bf8ace439d2">to</a>;
<a name="l01871"></a>01871 }
<a name="l01872"></a>01872 
<a name="l01873"></a>01873 <span class="keywordtype">void</span> 
<a name="l01874"></a><a class="code" href="varobj_8h.html#aa37f6fdebce885e6d9162986315c7365">01874</a> <a class="code" href="varobj_8c.html#aa37f6fdebce885e6d9162986315c7365">varobj_set_visualizer</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keyword">const</span> <span class="keywordtype">char</span> *visualizer)
<a name="l01875"></a>01875 {
<a name="l01876"></a>01876 <span class="preprocessor">#if HAVE_PYTHON</span>
<a name="l01877"></a>01877 <span class="preprocessor"></span>  <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *mainmod, *globals, *constructor;
<a name="l01878"></a>01878   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to;
<a name="l01879"></a>01879 
<a name="l01880"></a>01880   <span class="keywordflow">if</span> (!<a class="code" href="python-internal_8h.html#a2f9782caf78c6a6f300ce14c165d9605">gdb_python_initialized</a>)
<a name="l01881"></a>01881     <span class="keywordflow">return</span>;
<a name="l01882"></a>01882 
<a name="l01883"></a>01883   back_to = varobj_ensure_python_env (var);
<a name="l01884"></a>01884 
<a name="l01885"></a>01885   mainmod = PyImport_AddModule (<span class="stringliteral">&quot;__main__&quot;</span>);
<a name="l01886"></a>01886   globals = PyModule_GetDict (mainmod);
<a name="l01887"></a>01887   Py_INCREF (globals);
<a name="l01888"></a>01888   <a class="code" href="py-utils_8c.html#a58ef2184225d9f93b45b203dde2c5bc7">make_cleanup_py_decref</a> (globals);
<a name="l01889"></a>01889 
<a name="l01890"></a>01890   constructor = PyRun_String (visualizer, Py_eval_input, globals, globals);
<a name="l01891"></a>01891 
<a name="l01892"></a>01892   <span class="keywordflow">if</span> (! constructor)
<a name="l01893"></a>01893     {
<a name="l01894"></a>01894       <a class="code" href="python-internal_8h.html#a0547cdf5b8063543c37589085a7cfe31">gdbpy_print_stack</a> ();
<a name="l01895"></a>01895       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Could not evaluate visualizer expression: %s&quot;</span>), visualizer);
<a name="l01896"></a>01896     }
<a name="l01897"></a>01897 
<a name="l01898"></a>01898   construct_visualizer (var, constructor);
<a name="l01899"></a>01899   Py_XDECREF (constructor);
<a name="l01900"></a>01900 
<a name="l01901"></a>01901   <span class="comment">/* If there are any children now, wipe them.  */</span>
<a name="l01902"></a>01902   <a class="code" href="varobj_8c.html#aad58751b29b14a5eeb8b9879df27683d">varobj_delete</a> (var, NULL, 1 <span class="comment">/* children only */</span>);
<a name="l01903"></a>01903   var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a> = -1;
<a name="l01904"></a>01904 
<a name="l01905"></a>01905   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l01906"></a>01906 <span class="preprocessor">#else</span>
<a name="l01907"></a>01907 <span class="preprocessor"></span>  <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Python support required&quot;</span>));
<a name="l01908"></a>01908 <span class="preprocessor">#endif</span>
<a name="l01909"></a>01909 <span class="preprocessor"></span>}
<a name="l01910"></a>01910 
<a name="l01911"></a>01911 <span class="comment">/* If NEW_VALUE is the new value of the given varobj (var), return</span>
<a name="l01912"></a>01912 <span class="comment">   non-zero if var has mutated.  In other words, if the type of</span>
<a name="l01913"></a>01913 <span class="comment">   the new value is different from the type of the varobj&#39;s old</span>
<a name="l01914"></a>01914 <span class="comment">   value.</span>
<a name="l01915"></a>01915 <span class="comment"></span>
<a name="l01916"></a>01916 <span class="comment">   NEW_VALUE may be NULL, if the varobj is now out of scope.  */</span>
<a name="l01917"></a>01917 
<a name="l01918"></a>01918 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01919"></a><a class="code" href="varobj_8c.html#a0d90582139f279de93a66edda42b95d1">01919</a> <a class="code" href="varobj_8c.html#a0d90582139f279de93a66edda42b95d1">varobj_value_has_mutated</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keyword">struct</span> value *new_value,
<a name="l01920"></a>01920                           <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="mdebugread_8c.html#ab1ece714ac6020a52b26279dfc1b20d7">new_type</a>)
<a name="l01921"></a>01921 {
<a name="l01922"></a>01922   <span class="comment">/* If we haven&#39;t previously computed the number of children in var,</span>
<a name="l01923"></a>01923 <span class="comment">     it does not matter from the front-end&#39;s perspective whether</span>
<a name="l01924"></a>01924 <span class="comment">     the type has mutated or not.  For all intents and purposes,</span>
<a name="l01925"></a>01925 <span class="comment">     it has not mutated.  */</span>
<a name="l01926"></a>01926   <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a> &lt; 0)
<a name="l01927"></a>01927     <span class="keywordflow">return</span> 0;
<a name="l01928"></a>01928 
<a name="l01929"></a>01929   <span class="keywordflow">if</span> (var-&gt;root-&gt;lang-&gt;value_has_mutated)
<a name="l01930"></a>01930     <span class="keywordflow">return</span> var-&gt;root-&gt;lang-&gt;value_has_mutated (var, new_value, new_type);
<a name="l01931"></a>01931   <span class="keywordflow">else</span>
<a name="l01932"></a>01932     <span class="keywordflow">return</span> 0;
<a name="l01933"></a>01933 }
<a name="l01934"></a>01934 
<a name="l01935"></a>01935 <span class="comment">/* Update the values for a variable and its children.  This is a</span>
<a name="l01936"></a>01936 <span class="comment">   two-pronged attack.  First, re-parse the value for the root&#39;s</span>
<a name="l01937"></a>01937 <span class="comment">   expression to see if it&#39;s changed.  Then go all the way</span>
<a name="l01938"></a>01938 <span class="comment">   through its children, reconstructing them and noting if they&#39;ve</span>
<a name="l01939"></a>01939 <span class="comment">   changed.</span>
<a name="l01940"></a>01940 <span class="comment"></span>
<a name="l01941"></a>01941 <span class="comment">   The EXPLICIT parameter specifies if this call is result</span>
<a name="l01942"></a>01942 <span class="comment">   of MI request to update this specific variable, or </span>
<a name="l01943"></a>01943 <span class="comment">   result of implicit -var-update *.  For implicit request, we don&#39;t</span>
<a name="l01944"></a>01944 <span class="comment">   update frozen variables.</span>
<a name="l01945"></a>01945 <span class="comment"></span>
<a name="l01946"></a>01946 <span class="comment">   NOTE: This function may delete the caller&#39;s varobj.  If it</span>
<a name="l01947"></a>01947 <span class="comment">   returns TYPE_CHANGED, then it has done this and VARP will be modified</span>
<a name="l01948"></a>01948 <span class="comment">   to point to the new varobj.  */</span>
<a name="l01949"></a>01949 
<a name="l01950"></a><a class="code" href="varobj_8c.html#a4729743b70141a42b8c01c95e8c1fd0b">01950</a> <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a>(<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>) *
<a name="l01951"></a>01951 varobj_update (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> **varp, <span class="keywordtype">int</span> <span class="keyword">explicit</span>)
<a name="l01952"></a>01952 {
<a name="l01953"></a>01953   <span class="keywordtype">int</span> type_changed = 0;
<a name="l01954"></a>01954   <span class="keywordtype">int</span> i;
<a name="l01955"></a>01955   <span class="keyword">struct </span>value *<span class="keyword">new</span>;
<a name="l01956"></a>01956   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>) *<a class="code" href="structvalue.html#a1d1b2de52c04f606f83de97afd5296c1">stack</a> = NULL;
<a name="l01957"></a>01957   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>) *result = NULL;
<a name="l01958"></a>01958 
<a name="l01959"></a>01959   <span class="comment">/* Frozen means frozen -- we don&#39;t check for any change in</span>
<a name="l01960"></a>01960 <span class="comment">     this varobj, including its going out of scope, or</span>
<a name="l01961"></a>01961 <span class="comment">     changing type.  One use case for frozen varobjs is</span>
<a name="l01962"></a>01962 <span class="comment">     retaining previously evaluated expressions, and we don&#39;t</span>
<a name="l01963"></a>01963 <span class="comment">     want them to be reevaluated at all.  */</span>
<a name="l01964"></a>01964   <span class="keywordflow">if</span> (!<span class="keyword">explicit</span> &amp;&amp; (*varp)-&gt;frozen)
<a name="l01965"></a>01965     <span class="keywordflow">return</span> result;
<a name="l01966"></a>01966 
<a name="l01967"></a>01967   <span class="keywordflow">if</span> (!(*varp)-&gt;root-&gt;is_valid)
<a name="l01968"></a>01968     {
<a name="l01969"></a>01969       <a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a> r = {0};
<a name="l01970"></a>01970 
<a name="l01971"></a>01971       r.<a class="code" href="structvarobj__update__result__t.html#abcd32164b1e57aed747f8d04f9086b4c">varobj</a> = *varp;
<a name="l01972"></a>01972       r.<a class="code" href="structvarobj__update__result__t.html#abe65395c12c55f7094e5e22df14279e2">status</a> = <a class="code" href="varobj_8h.html#aa237162c4b841ca099857f944a53314fab9756c8ddf176d588fe90fc26f823a1d">VAROBJ_INVALID</a>;
<a name="l01973"></a>01973       <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, result, &amp;r);
<a name="l01974"></a>01974       <span class="keywordflow">return</span> result;
<a name="l01975"></a>01975     }
<a name="l01976"></a>01976 
<a name="l01977"></a>01977   <span class="keywordflow">if</span> ((*varp)-&gt;root-&gt;rootvar == *varp)
<a name="l01978"></a>01978     {
<a name="l01979"></a>01979       <a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a> r = {0};
<a name="l01980"></a>01980 
<a name="l01981"></a>01981       r.<a class="code" href="structvarobj__update__result__t.html#abcd32164b1e57aed747f8d04f9086b4c">varobj</a> = *varp;
<a name="l01982"></a>01982       r.<a class="code" href="structvarobj__update__result__t.html#abe65395c12c55f7094e5e22df14279e2">status</a> = <a class="code" href="varobj_8h.html#aa237162c4b841ca099857f944a53314fafc2d845fb089cdef4c4578eb172a9972">VAROBJ_IN_SCOPE</a>;
<a name="l01983"></a>01983 
<a name="l01984"></a>01984       <span class="comment">/* Update the root variable.  value_of_root can return NULL</span>
<a name="l01985"></a>01985 <span class="comment">         if the variable is no longer around, i.e. we stepped out of</span>
<a name="l01986"></a>01986 <span class="comment">         the frame in which a local existed.  We are letting the </span>
<a name="l01987"></a>01987 <span class="comment">         value_of_root variable dispose of the varobj if the type</span>
<a name="l01988"></a>01988 <span class="comment">         has changed.  */</span>
<a name="l01989"></a>01989       <span class="keyword">new</span> = <a class="code" href="varobj_8c.html#ad9e8c230e67c9e52f1f4aaaceae075f0">value_of_root</a> (varp, &amp;type_changed);
<a name="l01990"></a>01990       <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a8de9d1ed628fd6139ef82609d3b3460a">update_type_if_necessary</a>(*varp, <span class="keyword">new</span>))
<a name="l01991"></a>01991           type_changed = 1;
<a name="l01992"></a>01992       r.<a class="code" href="structvarobj__update__result__t.html#abcd32164b1e57aed747f8d04f9086b4c">varobj</a> = *varp;
<a name="l01993"></a>01993       r.<a class="code" href="structvarobj__update__result__t.html#ac56206c4858d5eb90de8cdff9d8ec681">type_changed</a> = type_changed;
<a name="l01994"></a>01994       <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#acb8313007f98eac3c62634057219329d">install_new_value</a> ((*varp), <span class="keyword">new</span>, type_changed))
<a name="l01995"></a>01995         r.<a class="code" href="structvarobj__update__result__t.html#aff77bcfa77e2f5e894a965c0c75d1628">changed</a> = 1;
<a name="l01996"></a>01996       
<a name="l01997"></a>01997       <span class="keywordflow">if</span> (<span class="keyword">new</span> == NULL)
<a name="l01998"></a>01998         r.<a class="code" href="structvarobj__update__result__t.html#abe65395c12c55f7094e5e22df14279e2">status</a> = <a class="code" href="varobj_8h.html#aa237162c4b841ca099857f944a53314fa9a003df658fd36e3a14715901c827ade">VAROBJ_NOT_IN_SCOPE</a>;
<a name="l01999"></a>01999       r.<a class="code" href="structvarobj__update__result__t.html#a8852e1493393aade3750543b05026825">value_installed</a> = 1;
<a name="l02000"></a>02000 
<a name="l02001"></a>02001       <span class="keywordflow">if</span> (r.<a class="code" href="structvarobj__update__result__t.html#abe65395c12c55f7094e5e22df14279e2">status</a> == <a class="code" href="varobj_8h.html#aa237162c4b841ca099857f944a53314fa9a003df658fd36e3a14715901c827ade">VAROBJ_NOT_IN_SCOPE</a>)
<a name="l02002"></a>02002         {
<a name="l02003"></a>02003           <span class="keywordflow">if</span> (r.<a class="code" href="structvarobj__update__result__t.html#ac56206c4858d5eb90de8cdff9d8ec681">type_changed</a> || r.<a class="code" href="structvarobj__update__result__t.html#aff77bcfa77e2f5e894a965c0c75d1628">changed</a>)
<a name="l02004"></a>02004             <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, result, &amp;r);
<a name="l02005"></a>02005           <span class="keywordflow">return</span> result;
<a name="l02006"></a>02006         }
<a name="l02007"></a>02007             
<a name="l02008"></a>02008       <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, <a class="code" href="structvalue.html#a1d1b2de52c04f606f83de97afd5296c1">stack</a>, &amp;r);
<a name="l02009"></a>02009     }
<a name="l02010"></a>02010   <span class="keywordflow">else</span>
<a name="l02011"></a>02011     {
<a name="l02012"></a>02012       <a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a> r = {0};
<a name="l02013"></a>02013 
<a name="l02014"></a>02014       r.<a class="code" href="structvarobj__update__result__t.html#abcd32164b1e57aed747f8d04f9086b4c">varobj</a> = *varp;
<a name="l02015"></a>02015       <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, <a class="code" href="structvalue.html#a1d1b2de52c04f606f83de97afd5296c1">stack</a>, &amp;r);
<a name="l02016"></a>02016     }
<a name="l02017"></a>02017 
<a name="l02018"></a>02018   <span class="comment">/* Walk through the children, reconstructing them all.  */</span>
<a name="l02019"></a>02019   <span class="keywordflow">while</span> (!<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, <a class="code" href="structvalue.html#a1d1b2de52c04f606f83de97afd5296c1">stack</a>))
<a name="l02020"></a>02020     {
<a name="l02021"></a>02021       <a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a> r = *(<a class="code" href="vec_8h.html#a052f53853ecb73bd3c5251a6939b6c08">VEC_last</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, <a class="code" href="structvalue.html#a1d1b2de52c04f606f83de97afd5296c1">stack</a>));
<a name="l02022"></a>02022       <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *v = r.<a class="code" href="structvarobj__update__result__t.html#abcd32164b1e57aed747f8d04f9086b4c">varobj</a>;
<a name="l02023"></a>02023 
<a name="l02024"></a>02024       <a class="code" href="vec_8h.html#a0a57ad58141d88d36b1f3229dba6f0e7">VEC_pop</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, stack);
<a name="l02025"></a>02025 
<a name="l02026"></a>02026       <span class="comment">/* Update this variable, unless it&#39;s a root, which is already</span>
<a name="l02027"></a>02027 <span class="comment">         updated.  */</span>
<a name="l02028"></a>02028       <span class="keywordflow">if</span> (!r.<a class="code" href="structvarobj__update__result__t.html#a8852e1493393aade3750543b05026825">value_installed</a>)
<a name="l02029"></a>02029         {
<a name="l02030"></a>02030           <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="mdebugread_8c.html#ab1ece714ac6020a52b26279dfc1b20d7">new_type</a>;
<a name="l02031"></a>02031 
<a name="l02032"></a>02032           <span class="keyword">new</span> = <a class="code" href="varobj_8c.html#af2a5adec143186b5712eb28d0e415b18">value_of_child</a> (v-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>, v-&gt;<a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a>);
<a name="l02033"></a>02033           <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a8de9d1ed628fd6139ef82609d3b3460a">update_type_if_necessary</a>(v, <span class="keyword">new</span>))
<a name="l02034"></a>02034             r.<a class="code" href="structvarobj__update__result__t.html#ac56206c4858d5eb90de8cdff9d8ec681">type_changed</a> = 1;
<a name="l02035"></a>02035           <span class="keywordflow">if</span> (<span class="keyword">new</span>)
<a name="l02036"></a>02036             new_type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (<span class="keyword">new</span>);
<a name="l02037"></a>02037           <span class="keywordflow">else</span>
<a name="l02038"></a>02038             new_type = v-&gt;root-&gt;lang-&gt;type_of_child (v-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>, v-&gt;<a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a>);
<a name="l02039"></a>02039 
<a name="l02040"></a>02040           <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a0d90582139f279de93a66edda42b95d1">varobj_value_has_mutated</a> (v, <span class="keyword">new</span>, new_type))
<a name="l02041"></a>02041             {
<a name="l02042"></a>02042               <span class="comment">/* The children are no longer valid; delete them now.</span>
<a name="l02043"></a>02043 <span class="comment">                 Report the fact that its type changed as well.  */</span>
<a name="l02044"></a>02044               <a class="code" href="varobj_8c.html#aad58751b29b14a5eeb8b9879df27683d">varobj_delete</a> (v, NULL, 1 <span class="comment">/* only_children */</span>);
<a name="l02045"></a>02045               v-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a> = -1;
<a name="l02046"></a>02046               v-&gt;to = -1;
<a name="l02047"></a>02047               v-&gt;from = -1;
<a name="l02048"></a>02048               v-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a> = <a class="code" href="mdebugread_8c.html#ab1ece714ac6020a52b26279dfc1b20d7">new_type</a>;
<a name="l02049"></a>02049               r.<a class="code" href="structvarobj__update__result__t.html#ac56206c4858d5eb90de8cdff9d8ec681">type_changed</a> = 1;
<a name="l02050"></a>02050             }
<a name="l02051"></a>02051 
<a name="l02052"></a>02052           <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#acb8313007f98eac3c62634057219329d">install_new_value</a> (v, <span class="keyword">new</span>, r.<a class="code" href="structvarobj__update__result__t.html#ac56206c4858d5eb90de8cdff9d8ec681">type_changed</a>))
<a name="l02053"></a>02053             {
<a name="l02054"></a>02054               r.<a class="code" href="structvarobj__update__result__t.html#aff77bcfa77e2f5e894a965c0c75d1628">changed</a> = 1;
<a name="l02055"></a>02055               v-&gt;updated = 0;
<a name="l02056"></a>02056             }
<a name="l02057"></a>02057         }
<a name="l02058"></a>02058 
<a name="l02059"></a>02059       <span class="comment">/* We probably should not get children of a varobj that has a</span>
<a name="l02060"></a>02060 <span class="comment">         pretty-printer, but for which -var-list-children was never</span>
<a name="l02061"></a>02061 <span class="comment">         invoked.  */</span>
<a name="l02062"></a>02062       <span class="keywordflow">if</span> (v-&gt;pretty_printer)
<a name="l02063"></a>02063         {
<a name="l02064"></a>02064           <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj.html">varobj_p</a>) *changed = 0, *type_changed = 0, *unchanged = 0;
<a name="l02065"></a>02065           <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structvarobj.html">varobj_p</a>) *<span class="keyword">new</span> = 0;
<a name="l02066"></a>02066           <span class="keywordtype">int</span> i, children_changed = 0;
<a name="l02067"></a>02067 
<a name="l02068"></a>02068           <span class="keywordflow">if</span> (v-&gt;frozen)
<a name="l02069"></a>02069             <span class="keywordflow">continue</span>;
<a name="l02070"></a>02070 
<a name="l02071"></a>02071           <span class="keywordflow">if</span> (!v-&gt;children_requested)
<a name="l02072"></a>02072             {
<a name="l02073"></a>02073               <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a36fb645a916cd19d79712e75c47b8d03">dummy</a>;
<a name="l02074"></a>02074 
<a name="l02075"></a>02075               <span class="comment">/* If we initially did not have potential children, but</span>
<a name="l02076"></a>02076 <span class="comment">                 now we do, consider the varobj as changed.</span>
<a name="l02077"></a>02077 <span class="comment">                 Otherwise, if children were never requested, consider</span>
<a name="l02078"></a>02078 <span class="comment">                 it as unchanged -- presumably, such varobj is not yet</span>
<a name="l02079"></a>02079 <span class="comment">                 expanded in the UI, so we need not bother getting</span>
<a name="l02080"></a>02080 <span class="comment">                 it.  */</span>
<a name="l02081"></a>02081               <span class="keywordflow">if</span> (!<a class="code" href="varobj_8c.html#af87ce7009f492b002fc8f6fdc085a5d6">varobj_has_more</a> (v, 0))
<a name="l02082"></a>02082                 {
<a name="l02083"></a>02083                   <a class="code" href="varobj_8c.html#ace5c357c603bf2568bded643d6101c1d">update_dynamic_varobj_children</a> (v, NULL, NULL, NULL, NULL,
<a name="l02084"></a>02084                                                   &amp;dummy, 0, 0, 0);
<a name="l02085"></a>02085                   <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#af87ce7009f492b002fc8f6fdc085a5d6">varobj_has_more</a> (v, 0))
<a name="l02086"></a>02086                     r.<a class="code" href="structvarobj__update__result__t.html#aff77bcfa77e2f5e894a965c0c75d1628">changed</a> = 1;
<a name="l02087"></a>02087                 }
<a name="l02088"></a>02088 
<a name="l02089"></a>02089               <span class="keywordflow">if</span> (r.<a class="code" href="structvarobj__update__result__t.html#aff77bcfa77e2f5e894a965c0c75d1628">changed</a>)
<a name="l02090"></a>02090                 <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, result, &amp;r);
<a name="l02091"></a>02091 
<a name="l02092"></a>02092               <span class="keywordflow">continue</span>;
<a name="l02093"></a>02093             }
<a name="l02094"></a>02094 
<a name="l02095"></a>02095           <span class="comment">/* If update_dynamic_varobj_children returns 0, then we have</span>
<a name="l02096"></a>02096 <span class="comment">             a non-conforming pretty-printer, so we skip it.  */</span>
<a name="l02097"></a>02097           <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#ace5c357c603bf2568bded643d6101c1d">update_dynamic_varobj_children</a> (v, &amp;changed, &amp;type_changed, &amp;<span class="keyword">new</span>,
<a name="l02098"></a>02098                                               &amp;unchanged, &amp;children_changed, 1,
<a name="l02099"></a>02099                                               v-&gt;from, v-&gt;to))
<a name="l02100"></a>02100             {
<a name="l02101"></a>02101               <span class="keywordflow">if</span> (children_changed || <span class="keyword">new</span>)
<a name="l02102"></a>02102                 {
<a name="l02103"></a>02103                   r.<a class="code" href="structvarobj__update__result__t.html#a56df9e3b8b273c88f2777907f01e7624">children_changed</a> = 1;
<a name="l02104"></a>02104                   r.new = <span class="keyword">new</span>;
<a name="l02105"></a>02105                 }
<a name="l02106"></a>02106               <span class="comment">/* Push in reverse order so that the first child is</span>
<a name="l02107"></a>02107 <span class="comment">                 popped from the work stack first, and so will be</span>
<a name="l02108"></a>02108 <span class="comment">                 added to result first.  This does not affect</span>
<a name="l02109"></a>02109 <span class="comment">                 correctness, just &quot;nicer&quot;.  */</span>
<a name="l02110"></a>02110               <span class="keywordflow">for</span> (i = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, type_changed) - 1; i &gt;= 0; --i)
<a name="l02111"></a>02111                 {
<a name="l02112"></a>02112                   <a class="code" href="structvarobj.html">varobj_p</a> tmp = <a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="structvarobj.html">varobj_p</a>, type_changed, i);
<a name="l02113"></a>02113                   <a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a> r = {0};
<a name="l02114"></a>02114 
<a name="l02115"></a>02115                   <span class="comment">/* Type may change only if value was changed.  */</span>
<a name="l02116"></a>02116                   r.<a class="code" href="structvarobj__update__result__t.html#abcd32164b1e57aed747f8d04f9086b4c">varobj</a> = tmp;
<a name="l02117"></a>02117                   r.<a class="code" href="structvarobj__update__result__t.html#aff77bcfa77e2f5e894a965c0c75d1628">changed</a> = 1;
<a name="l02118"></a>02118                   r.<a class="code" href="structvarobj__update__result__t.html#ac56206c4858d5eb90de8cdff9d8ec681">type_changed</a> = 1;
<a name="l02119"></a>02119                   r.<a class="code" href="structvarobj__update__result__t.html#a8852e1493393aade3750543b05026825">value_installed</a> = 1;
<a name="l02120"></a>02120                   <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, stack, &amp;r);
<a name="l02121"></a>02121                 }
<a name="l02122"></a>02122               <span class="keywordflow">for</span> (i = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, changed) - 1; i &gt;= 0; --i)
<a name="l02123"></a>02123                 {
<a name="l02124"></a>02124                   <a class="code" href="structvarobj.html">varobj_p</a> tmp = <a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="structvarobj.html">varobj_p</a>, changed, i);
<a name="l02125"></a>02125                   <a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a> r = {0};
<a name="l02126"></a>02126 
<a name="l02127"></a>02127                   r.<a class="code" href="structvarobj__update__result__t.html#abcd32164b1e57aed747f8d04f9086b4c">varobj</a> = tmp;
<a name="l02128"></a>02128                   r.<a class="code" href="structvarobj__update__result__t.html#aff77bcfa77e2f5e894a965c0c75d1628">changed</a> = 1;
<a name="l02129"></a>02129                   r.<a class="code" href="structvarobj__update__result__t.html#a8852e1493393aade3750543b05026825">value_installed</a> = 1;
<a name="l02130"></a>02130                   <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, stack, &amp;r);
<a name="l02131"></a>02131                 }
<a name="l02132"></a>02132               <span class="keywordflow">for</span> (i = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, unchanged) - 1; i &gt;= 0; --i)
<a name="l02133"></a>02133                 {
<a name="l02134"></a>02134                   <a class="code" href="structvarobj.html">varobj_p</a> tmp = <a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="structvarobj.html">varobj_p</a>, unchanged, i);
<a name="l02135"></a>02135 
<a name="l02136"></a>02136                   <span class="keywordflow">if</span> (!tmp-&gt;frozen)
<a name="l02137"></a>02137                     {
<a name="l02138"></a>02138                       <a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a> r = {0};
<a name="l02139"></a>02139 
<a name="l02140"></a>02140                       r.<a class="code" href="structvarobj__update__result__t.html#abcd32164b1e57aed747f8d04f9086b4c">varobj</a> = tmp;
<a name="l02141"></a>02141                       r.<a class="code" href="structvarobj__update__result__t.html#a8852e1493393aade3750543b05026825">value_installed</a> = 1;
<a name="l02142"></a>02142                       <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, stack, &amp;r);
<a name="l02143"></a>02143                     }
<a name="l02144"></a>02144                 }
<a name="l02145"></a>02145               <span class="keywordflow">if</span> (r.<a class="code" href="structvarobj__update__result__t.html#aff77bcfa77e2f5e894a965c0c75d1628">changed</a> || r.<a class="code" href="structvarobj__update__result__t.html#a56df9e3b8b273c88f2777907f01e7624">children_changed</a>)
<a name="l02146"></a>02146                 <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, result, &amp;r);
<a name="l02147"></a>02147 
<a name="l02148"></a>02148               <span class="comment">/* Free CHANGED, TYPE_CHANGED and UNCHANGED, but not NEW,</span>
<a name="l02149"></a>02149 <span class="comment">                 because NEW has been put into the result vector.  */</span>
<a name="l02150"></a>02150               <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structvarobj.html">varobj_p</a>, changed);
<a name="l02151"></a>02151               <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structvarobj.html">varobj_p</a>, type_changed);
<a name="l02152"></a>02152               <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structvarobj.html">varobj_p</a>, unchanged);
<a name="l02153"></a>02153 
<a name="l02154"></a>02154               <span class="keywordflow">continue</span>;
<a name="l02155"></a>02155             }
<a name="l02156"></a>02156         }
<a name="l02157"></a>02157 
<a name="l02158"></a>02158       <span class="comment">/* Push any children.  Use reverse order so that the first</span>
<a name="l02159"></a>02159 <span class="comment">         child is popped from the work stack first, and so</span>
<a name="l02160"></a>02160 <span class="comment">         will be added to result first.  This does not</span>
<a name="l02161"></a>02161 <span class="comment">         affect correctness, just &quot;nicer&quot;.  */</span>
<a name="l02162"></a>02162       <span class="keywordflow">for</span> (i = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, v-&gt;children)-1; i &gt;= 0; --i)
<a name="l02163"></a>02163         {
<a name="l02164"></a>02164           <a class="code" href="structvarobj.html">varobj_p</a> c = <a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="structvarobj.html">varobj_p</a>, v-&gt;children, i);
<a name="l02165"></a>02165 
<a name="l02166"></a>02166           <span class="comment">/* Child may be NULL if explicitly deleted by -var-delete.  */</span>
<a name="l02167"></a>02167           <span class="keywordflow">if</span> (c != NULL &amp;&amp; !c-&gt;frozen)
<a name="l02168"></a>02168             {
<a name="l02169"></a>02169               <a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a> r = {0};
<a name="l02170"></a>02170 
<a name="l02171"></a>02171               r.<a class="code" href="structvarobj__update__result__t.html#abcd32164b1e57aed747f8d04f9086b4c">varobj</a> = c;
<a name="l02172"></a>02172               <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, stack, &amp;r);
<a name="l02173"></a>02173             }
<a name="l02174"></a>02174         }
<a name="l02175"></a>02175 
<a name="l02176"></a>02176       <span class="keywordflow">if</span> (r.<a class="code" href="structvarobj__update__result__t.html#aff77bcfa77e2f5e894a965c0c75d1628">changed</a> || r.<a class="code" href="structvarobj__update__result__t.html#ac56206c4858d5eb90de8cdff9d8ec681">type_changed</a>)
<a name="l02177"></a>02177         <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, result, &amp;r);
<a name="l02178"></a>02178     }
<a name="l02179"></a>02179 
<a name="l02180"></a>02180   <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structvarobj__update__result__t.html">varobj_update_result</a>, stack);
<a name="l02181"></a>02181 
<a name="l02182"></a>02182   <span class="keywordflow">return</span> result;
<a name="l02183"></a>02183 }
<a name="l02184"></a>02184 
<a name="l02185"></a>02185 
<a name="l02186"></a>02186 <span class="comment">/* Helper functions */</span>
<a name="l02187"></a>02187 
<a name="l02188"></a>02188 <span class="comment">/*</span>
<a name="l02189"></a>02189 <span class="comment"> * Variable object construction/destruction</span>
<a name="l02190"></a>02190 <span class="comment"> */</span>
<a name="l02191"></a>02191 
<a name="l02192"></a>02192 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02193"></a><a class="code" href="varobj_8c.html#a5bac0fb8c5ac5ede15933184f2f89773">02193</a> <a class="code" href="varobj_8c.html#a5bac0fb8c5ac5ede15933184f2f89773">delete_variable</a> (<span class="keyword">struct</span> <a class="code" href="structcpstack.html">cpstack</a> **resultp, <span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var,
<a name="l02194"></a>02194                  <span class="keywordtype">int</span> only_children_p)
<a name="l02195"></a>02195 {
<a name="l02196"></a>02196   <span class="keywordtype">int</span> delcount = 0;
<a name="l02197"></a>02197 
<a name="l02198"></a>02198   <a class="code" href="varobj_8c.html#a063f79374b8c6be2c1c874f0d206bfa1">delete_variable_1</a> (resultp, &amp;delcount, var,
<a name="l02199"></a>02199                      only_children_p, 1 <span class="comment">/* remove_from_parent_p */</span> );
<a name="l02200"></a>02200 
<a name="l02201"></a>02201   <span class="keywordflow">return</span> delcount;
<a name="l02202"></a>02202 }
<a name="l02203"></a>02203 
<a name="l02204"></a>02204 <span class="comment">/* Delete the variable object VAR and its children.  */</span>
<a name="l02205"></a>02205 <span class="comment">/* IMPORTANT NOTE: If we delete a variable which is a child</span>
<a name="l02206"></a>02206 <span class="comment">   and the parent is not removed we dump core.  It must be always</span>
<a name="l02207"></a>02207 <span class="comment">   initially called with remove_from_parent_p set.  */</span>
<a name="l02208"></a>02208 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02209"></a><a class="code" href="varobj_8c.html#a063f79374b8c6be2c1c874f0d206bfa1">02209</a> <a class="code" href="varobj_8c.html#a063f79374b8c6be2c1c874f0d206bfa1">delete_variable_1</a> (<span class="keyword">struct</span> <a class="code" href="structcpstack.html">cpstack</a> **resultp, <span class="keywordtype">int</span> *delcountp,
<a name="l02210"></a>02210                    <span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keywordtype">int</span> only_children_p,
<a name="l02211"></a>02211                    <span class="keywordtype">int</span> remove_from_parent_p)
<a name="l02212"></a>02212 {
<a name="l02213"></a>02213   <span class="keywordtype">int</span> i;
<a name="l02214"></a>02214 
<a name="l02215"></a>02215   <span class="comment">/* Delete any children of this variable, too.  */</span>
<a name="l02216"></a>02216   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children); ++i)
<a name="l02217"></a>02217     {   
<a name="l02218"></a>02218       <a class="code" href="structvarobj.html">varobj_p</a> child = <a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children, i);
<a name="l02219"></a>02219 
<a name="l02220"></a>02220       <span class="keywordflow">if</span> (!child)
<a name="l02221"></a>02221         <span class="keywordflow">continue</span>;
<a name="l02222"></a>02222       <span class="keywordflow">if</span> (!remove_from_parent_p)
<a name="l02223"></a>02223         child-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a> = NULL;
<a name="l02224"></a>02224       <a class="code" href="varobj_8c.html#a063f79374b8c6be2c1c874f0d206bfa1">delete_variable_1</a> (resultp, delcountp, child, 0, only_children_p);
<a name="l02225"></a>02225     }
<a name="l02226"></a>02226   <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children);
<a name="l02227"></a>02227 
<a name="l02228"></a>02228   <span class="comment">/* if we were called to delete only the children we are done here.  */</span>
<a name="l02229"></a>02229   <span class="keywordflow">if</span> (only_children_p)
<a name="l02230"></a>02230     <span class="keywordflow">return</span>;
<a name="l02231"></a>02231 
<a name="l02232"></a>02232   <span class="comment">/* Otherwise, add it to the list of deleted ones and proceed to do so.  */</span>
<a name="l02233"></a>02233   <span class="comment">/* If the name is null, this is a temporary variable, that has not</span>
<a name="l02234"></a>02234 <span class="comment">     yet been installed, don&#39;t report it, it belongs to the caller...  */</span>
<a name="l02235"></a>02235   <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a> != NULL)
<a name="l02236"></a>02236     {
<a name="l02237"></a>02237       <a class="code" href="varobj_8c.html#ae93a42ae116f3c1fba220ffee78bb823">cppush</a> (resultp, xstrdup (var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>));
<a name="l02238"></a>02238       *delcountp = *delcountp + 1;
<a name="l02239"></a>02239     }
<a name="l02240"></a>02240 
<a name="l02241"></a>02241   <span class="comment">/* If this variable has a parent, remove it from its parent&#39;s list.  */</span>
<a name="l02242"></a>02242   <span class="comment">/* OPTIMIZATION: if the parent of this variable is also being deleted, </span>
<a name="l02243"></a>02243 <span class="comment">     (as indicated by remove_from_parent_p) we don&#39;t bother doing an</span>
<a name="l02244"></a>02244 <span class="comment">     expensive list search to find the element to remove when we are</span>
<a name="l02245"></a>02245 <span class="comment">     discarding the list afterwards.  */</span>
<a name="l02246"></a>02246   <span class="keywordflow">if</span> ((remove_from_parent_p) &amp;&amp; (var-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a> != NULL))
<a name="l02247"></a>02247     {
<a name="l02248"></a>02248       <a class="code" href="vec_8h.html#ae898349bda7814bcf92db36c0550a10f">VEC_replace</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>-&gt;children, var-&gt;<a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a>, NULL);
<a name="l02249"></a>02249     }
<a name="l02250"></a>02250 
<a name="l02251"></a>02251   <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a> != NULL)
<a name="l02252"></a>02252     <a class="code" href="varobj_8c.html#a264e1d570d50a82637b9db01b6942b8c">uninstall_variable</a> (var);
<a name="l02253"></a>02253 
<a name="l02254"></a>02254   <span class="comment">/* Free memory associated with this variable.  */</span>
<a name="l02255"></a>02255   <a class="code" href="varobj_8c.html#aae21f5f363047cc373a24db2068908a2">free_variable</a> (var);
<a name="l02256"></a>02256 }
<a name="l02257"></a>02257 
<a name="l02258"></a>02258 <span class="comment">/* Install the given variable VAR with the object name VAR-&gt;OBJ_NAME.  */</span>
<a name="l02259"></a>02259 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02260"></a><a class="code" href="varobj_8c.html#add625a61acb44538c0b77386e3ee3549">02260</a> <a class="code" href="varobj_8c.html#add625a61acb44538c0b77386e3ee3549">install_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l02261"></a>02261 {
<a name="l02262"></a>02262   <span class="keyword">struct </span><a class="code" href="structvlist.html">vlist</a> *cv;
<a name="l02263"></a>02263   <span class="keyword">struct </span><a class="code" href="structvlist.html">vlist</a> *newvl;
<a name="l02264"></a>02264   <span class="keyword">const</span> <span class="keywordtype">char</span> *chp;
<a name="l02265"></a>02265   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 0;
<a name="l02266"></a>02266   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1;
<a name="l02267"></a>02267 
<a name="l02268"></a>02268   <span class="keywordflow">for</span> (chp = var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>; *chp; chp++)
<a name="l02269"></a>02269     {
<a name="l02270"></a>02270       index = (index + (i++ * (<span class="keywordtype">unsigned</span> <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>) *chp)) % <a class="code" href="varobj_8c.html#a3e3ade9793c5199bc838ac530297268d">VAROBJ_TABLE_SIZE</a>;
<a name="l02271"></a>02271     }
<a name="l02272"></a>02272 
<a name="l02273"></a>02273   cv = *(varobj_table + index);
<a name="l02274"></a>02274   <span class="keywordflow">while</span> ((cv != NULL) &amp;&amp; (strcmp (cv-&gt;<a class="code" href="structvlist.html#a989a752791ea1c5e6a39f54d5c3e95ea">var</a>-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>, var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>) != 0))
<a name="l02275"></a>02275     cv = cv-&gt;<a class="code" href="structvlist.html#a7dd37f43fcb9fdd0b9be8120351ecd35">next</a>;
<a name="l02276"></a>02276 
<a name="l02277"></a>02277   <span class="keywordflow">if</span> (cv != NULL)
<a name="l02278"></a>02278     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Duplicate variable object name&quot;</span>));
<a name="l02279"></a>02279 
<a name="l02280"></a>02280   <span class="comment">/* Add varobj to hash table.  */</span>
<a name="l02281"></a>02281   newvl = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structvlist.html">vlist</a>));
<a name="l02282"></a>02282   newvl-&gt;<a class="code" href="structvlist.html#a7dd37f43fcb9fdd0b9be8120351ecd35">next</a> = *(varobj_table + index);
<a name="l02283"></a>02283   newvl-&gt;<a class="code" href="structvlist.html#a989a752791ea1c5e6a39f54d5c3e95ea">var</a> = <a class="code" href="structvlist.html#a989a752791ea1c5e6a39f54d5c3e95ea">var</a>;
<a name="l02284"></a>02284   *(varobj_table + index) = newvl;
<a name="l02285"></a>02285 
<a name="l02286"></a>02286   <span class="comment">/* If root, add varobj to root list.  */</span>
<a name="l02287"></a>02287   <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#ac5da1ead02d1559acf6836dcc1dbc4cc">is_root_p</a> (var))
<a name="l02288"></a>02288     {
<a name="l02289"></a>02289       <span class="comment">/* Add to list of root variables.  */</span>
<a name="l02290"></a>02290       <span class="keywordflow">if</span> (rootlist == NULL)
<a name="l02291"></a>02291         var-&gt;root-&gt;next = NULL;
<a name="l02292"></a>02292       <span class="keywordflow">else</span>
<a name="l02293"></a>02293         var-&gt;root-&gt;next = <a class="code" href="varobj_8c.html#a01b646c8a559f17017d7326f4c885f63">rootlist</a>;
<a name="l02294"></a>02294       rootlist = var-&gt;root;
<a name="l02295"></a>02295     }
<a name="l02296"></a>02296 
<a name="l02297"></a>02297   <span class="keywordflow">return</span> 1;                     <span class="comment">/* OK */</span>
<a name="l02298"></a>02298 }
<a name="l02299"></a>02299 
<a name="l02300"></a>02300 <span class="comment">/* Unistall the object VAR.  */</span>
<a name="l02301"></a>02301 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02302"></a><a class="code" href="varobj_8c.html#a264e1d570d50a82637b9db01b6942b8c">02302</a> <a class="code" href="varobj_8c.html#a264e1d570d50a82637b9db01b6942b8c">uninstall_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l02303"></a>02303 {
<a name="l02304"></a>02304   <span class="keyword">struct </span><a class="code" href="structvlist.html">vlist</a> *cv;
<a name="l02305"></a>02305   <span class="keyword">struct </span><a class="code" href="structvlist.html">vlist</a> *prev;
<a name="l02306"></a>02306   <span class="keyword">struct </span><a class="code" href="structvarobj__root.html">varobj_root</a> *cr;
<a name="l02307"></a>02307   <span class="keyword">struct </span><a class="code" href="structvarobj__root.html">varobj_root</a> *prer;
<a name="l02308"></a>02308   <span class="keyword">const</span> <span class="keywordtype">char</span> *chp;
<a name="l02309"></a>02309   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 0;
<a name="l02310"></a>02310   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1;
<a name="l02311"></a>02311 
<a name="l02312"></a>02312   <span class="comment">/* Remove varobj from hash table.  */</span>
<a name="l02313"></a>02313   <span class="keywordflow">for</span> (chp = var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>; *chp; chp++)
<a name="l02314"></a>02314     {
<a name="l02315"></a>02315       index = (index + (i++ * (<span class="keywordtype">unsigned</span> <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>) *chp)) % <a class="code" href="varobj_8c.html#a3e3ade9793c5199bc838ac530297268d">VAROBJ_TABLE_SIZE</a>;
<a name="l02316"></a>02316     }
<a name="l02317"></a>02317 
<a name="l02318"></a>02318   cv = *(varobj_table + index);
<a name="l02319"></a>02319   prev = NULL;
<a name="l02320"></a>02320   <span class="keywordflow">while</span> ((cv != NULL) &amp;&amp; (strcmp (cv-&gt;<a class="code" href="structvlist.html#a989a752791ea1c5e6a39f54d5c3e95ea">var</a>-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>, var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>) != 0))
<a name="l02321"></a>02321     {
<a name="l02322"></a>02322       prev = cv;
<a name="l02323"></a>02323       cv = cv-&gt;<a class="code" href="structvlist.html#a7dd37f43fcb9fdd0b9be8120351ecd35">next</a>;
<a name="l02324"></a>02324     }
<a name="l02325"></a>02325 
<a name="l02326"></a>02326   <span class="keywordflow">if</span> (<a class="code" href="mi-cmd-var_8c.html#afc68a4a5062c47438bdd85051db7b6db">varobjdebug</a>)
<a name="l02327"></a>02327     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;Deleting %s\n&quot;</span>, var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>);
<a name="l02328"></a>02328 
<a name="l02329"></a>02329   <span class="keywordflow">if</span> (cv == NULL)
<a name="l02330"></a>02330     {
<a name="l02331"></a>02331       <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a>
<a name="l02332"></a>02332         (<span class="stringliteral">&quot;Assertion failed: Could not find variable object \&quot;%s\&quot; to delete&quot;</span>,
<a name="l02333"></a>02333          var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>);
<a name="l02334"></a>02334       <span class="keywordflow">return</span>;
<a name="l02335"></a>02335     }
<a name="l02336"></a>02336 
<a name="l02337"></a>02337   <span class="keywordflow">if</span> (prev == NULL)
<a name="l02338"></a>02338     *(varobj_table + index) = cv-&gt;<a class="code" href="structvlist.html#a7dd37f43fcb9fdd0b9be8120351ecd35">next</a>;
<a name="l02339"></a>02339   <span class="keywordflow">else</span>
<a name="l02340"></a>02340     prev-&gt;<a class="code" href="structvlist.html#a7dd37f43fcb9fdd0b9be8120351ecd35">next</a> = cv-&gt;<a class="code" href="structvlist.html#a7dd37f43fcb9fdd0b9be8120351ecd35">next</a>;
<a name="l02341"></a>02341 
<a name="l02342"></a>02342   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (cv);
<a name="l02343"></a>02343 
<a name="l02344"></a>02344   <span class="comment">/* If root, remove varobj from root list.  */</span>
<a name="l02345"></a>02345   <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#ac5da1ead02d1559acf6836dcc1dbc4cc">is_root_p</a> (var))
<a name="l02346"></a>02346     {
<a name="l02347"></a>02347       <span class="comment">/* Remove from list of root variables.  */</span>
<a name="l02348"></a>02348       <span class="keywordflow">if</span> (rootlist == var-&gt;root)
<a name="l02349"></a>02349         rootlist = var-&gt;root-&gt;next;
<a name="l02350"></a>02350       <span class="keywordflow">else</span>
<a name="l02351"></a>02351         {
<a name="l02352"></a>02352           prer = NULL;
<a name="l02353"></a>02353           cr = <a class="code" href="varobj_8c.html#a01b646c8a559f17017d7326f4c885f63">rootlist</a>;
<a name="l02354"></a>02354           <span class="keywordflow">while</span> ((cr != NULL) &amp;&amp; (cr-&gt;<a class="code" href="structvarobj__root.html#a97dad6ede27c5d6c37095510fa9ce93e">rootvar</a> != var))
<a name="l02355"></a>02355             {
<a name="l02356"></a>02356               prer = cr;
<a name="l02357"></a>02357               cr = cr-&gt;<a class="code" href="structvarobj__root.html#ad97dab9a8e9ac5c39caa4bf667d0e1c9">next</a>;
<a name="l02358"></a>02358             }
<a name="l02359"></a>02359           <span class="keywordflow">if</span> (cr == NULL)
<a name="l02360"></a>02360             {
<a name="l02361"></a>02361               <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Assertion failed: Could not find &quot;</span>
<a name="l02362"></a>02362                          <span class="stringliteral">&quot;varobj \&quot;%s\&quot; in root list&quot;</span>),
<a name="l02363"></a>02363                        var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>);
<a name="l02364"></a>02364               <span class="keywordflow">return</span>;
<a name="l02365"></a>02365             }
<a name="l02366"></a>02366           <span class="keywordflow">if</span> (prer == NULL)
<a name="l02367"></a>02367             rootlist = NULL;
<a name="l02368"></a>02368           <span class="keywordflow">else</span>
<a name="l02369"></a>02369             prer-&gt;<a class="code" href="structvarobj__root.html#ad97dab9a8e9ac5c39caa4bf667d0e1c9">next</a> = cr-&gt;<a class="code" href="structvarobj__root.html#ad97dab9a8e9ac5c39caa4bf667d0e1c9">next</a>;
<a name="l02370"></a>02370         }
<a name="l02371"></a>02371     }
<a name="l02372"></a>02372 
<a name="l02373"></a>02373 }
<a name="l02374"></a>02374 
<a name="l02375"></a>02375 <span class="comment">/* Create and install a child of the parent of the given name.  */</span>
<a name="l02376"></a>02376 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *
<a name="l02377"></a><a class="code" href="varobj_8c.html#a71f5081f79774cddee55f2f21e2cbd89">02377</a> <a class="code" href="varobj_8c.html#a71f5081f79774cddee55f2f21e2cbd89">create_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>, <span class="keywordtype">int</span> index, <span class="keywordtype">char</span> *name)
<a name="l02378"></a>02378 {
<a name="l02379"></a>02379   <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#acfb70e4ed6d65d2a5c4f3d52704ba120">create_child_with_value</a> (parent, index, name, 
<a name="l02380"></a>02380                                   <a class="code" href="varobj_8c.html#af2a5adec143186b5712eb28d0e415b18">value_of_child</a> (parent, index));
<a name="l02381"></a>02381 }
<a name="l02382"></a>02382 
<a name="l02383"></a>02383 <span class="comment">/* Does CHILD represent a child with no name?  This happens when</span>
<a name="l02384"></a>02384 <span class="comment">   the child is an anonmous struct or union and it has no field name</span>
<a name="l02385"></a>02385 <span class="comment">   in its parent variable.</span>
<a name="l02386"></a>02386 <span class="comment"></span>
<a name="l02387"></a>02387 <span class="comment">   This has already been determined by *_describe_child. The easiest</span>
<a name="l02388"></a>02388 <span class="comment">   thing to do is to compare the child&#39;s name with ANONYMOUS_*_NAME.  */</span>
<a name="l02389"></a>02389 
<a name="l02390"></a>02390 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02391"></a><a class="code" href="varobj_8c.html#a2f560540401c310cd82f97e78324770b">02391</a> <a class="code" href="varobj_8c.html#a2f560540401c310cd82f97e78324770b">is_anonymous_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *child)
<a name="l02392"></a>02392 {
<a name="l02393"></a>02393   <span class="keywordflow">return</span> (strcmp (child-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>, <a class="code" href="varobj_8c.html#a1ded4c9d095bc960dfd094a418fe154e">ANONYMOUS_STRUCT_NAME</a>) == 0
<a name="l02394"></a>02394           || strcmp (child-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>, <a class="code" href="varobj_8c.html#a291131d840192a1a42d0af2aa94f24bc">ANONYMOUS_UNION_NAME</a>) == 0);
<a name="l02395"></a>02395 }
<a name="l02396"></a>02396 
<a name="l02397"></a>02397 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *
<a name="l02398"></a><a class="code" href="varobj_8c.html#acfb70e4ed6d65d2a5c4f3d52704ba120">02398</a> <a class="code" href="varobj_8c.html#acfb70e4ed6d65d2a5c4f3d52704ba120">create_child_with_value</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>, <span class="keywordtype">int</span> index, <span class="keywordtype">char</span> *name,
<a name="l02399"></a>02399                          <span class="keyword">struct</span> value *value)
<a name="l02400"></a>02400 {
<a name="l02401"></a>02401   <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *child;
<a name="l02402"></a>02402   <span class="keywordtype">char</span> *childs_name;
<a name="l02403"></a>02403 
<a name="l02404"></a>02404   child = <a class="code" href="varobj_8c.html#a774a73e3ab9589f011263b9f2e73373f">new_variable</a> ();
<a name="l02405"></a>02405 
<a name="l02406"></a>02406   <span class="comment">/* NAME is allocated by caller.  */</span>
<a name="l02407"></a>02407   child-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a> = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l02408"></a>02408   child-&gt;<a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a> = <a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a>;
<a name="l02409"></a>02409   child-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a> = <a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>;
<a name="l02410"></a>02410   child-&gt;root = parent-&gt;root;
<a name="l02411"></a>02411 
<a name="l02412"></a>02412   <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a2f560540401c310cd82f97e78324770b">is_anonymous_child</a> (child))
<a name="l02413"></a>02413     childs_name = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;%s.%d_anonymous&quot;</span>, parent-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>, index);
<a name="l02414"></a>02414   <span class="keywordflow">else</span>
<a name="l02415"></a>02415     childs_name = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;%s.%s&quot;</span>, parent-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>, name);
<a name="l02416"></a>02416   child-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a> = childs_name;
<a name="l02417"></a>02417 
<a name="l02418"></a>02418   <a class="code" href="varobj_8c.html#add625a61acb44538c0b77386e3ee3549">install_variable</a> (child);
<a name="l02419"></a>02419 
<a name="l02420"></a>02420   <span class="comment">/* Compute the type of the child.  Must do this before</span>
<a name="l02421"></a>02421 <span class="comment">     calling install_new_value.  */</span>
<a name="l02422"></a>02422   <span class="keywordflow">if</span> (value != NULL)
<a name="l02423"></a>02423     <span class="comment">/* If the child had no evaluation errors, var-&gt;value</span>
<a name="l02424"></a>02424 <span class="comment">       will be non-NULL and contain a valid type.  */</span>
<a name="l02425"></a>02425     child-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a> = <a class="code" href="value_8c.html#aad0d3b9452bbb8b01fb2f0cc5f1bf093">value_actual_type</a> (value, 0, NULL);
<a name="l02426"></a>02426   <span class="keywordflow">else</span>
<a name="l02427"></a>02427     <span class="comment">/* Otherwise, we must compute the type.  */</span>
<a name="l02428"></a>02428     child-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a> = (*child-&gt;root-&gt;lang-&gt;type_of_child) (child-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>, 
<a name="l02429"></a>02429                                                        child-&gt;<a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a>);
<a name="l02430"></a>02430   <a class="code" href="varobj_8c.html#acb8313007f98eac3c62634057219329d">install_new_value</a> (child, value, 1);
<a name="l02431"></a>02431 
<a name="l02432"></a>02432   <span class="keywordflow">return</span> child;
<a name="l02433"></a>02433 }
<a name="l02434"></a>02434 
<a name="l02435"></a>02435 
<a name="l02436"></a>02436 <span class="comment">/*</span>
<a name="l02437"></a>02437 <span class="comment"> * Miscellaneous utility functions.</span>
<a name="l02438"></a>02438 <span class="comment"> */</span>
<a name="l02439"></a>02439 
<a name="l02440"></a>02440 <span class="comment">/* Allocate memory and initialize a new variable.  */</span>
<a name="l02441"></a>02441 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *
<a name="l02442"></a><a class="code" href="varobj_8c.html#a774a73e3ab9589f011263b9f2e73373f">02442</a> <a class="code" href="varobj_8c.html#a774a73e3ab9589f011263b9f2e73373f">new_variable</a> (<span class="keywordtype">void</span>)
<a name="l02443"></a>02443 {
<a name="l02444"></a>02444   <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *var;
<a name="l02445"></a>02445 
<a name="l02446"></a>02446   var = (<span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *) <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a>));
<a name="l02447"></a>02447   var-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a> = NULL;
<a name="l02448"></a>02448   var-&gt;<a class="code" href="structvarobj.html#ab61f8b5cf72e56285b2c14a89aafc7ff">path_expr</a> = NULL;
<a name="l02449"></a>02449   var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a> = NULL;
<a name="l02450"></a>02450   var-&gt;<a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a> = -1;
<a name="l02451"></a>02451   var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a> = NULL;
<a name="l02452"></a>02452   var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a> = NULL;
<a name="l02453"></a>02453   var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a> = -1;
<a name="l02454"></a>02454   var-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a> = NULL;
<a name="l02455"></a>02455   var-&gt;children = NULL;
<a name="l02456"></a>02456   var-&gt;format = 0;
<a name="l02457"></a>02457   var-&gt;root = NULL;
<a name="l02458"></a>02458   var-&gt;updated = 0;
<a name="l02459"></a>02459   var-&gt;print_value = NULL;
<a name="l02460"></a>02460   var-&gt;frozen = 0;
<a name="l02461"></a>02461   var-&gt;not_fetched = 0;
<a name="l02462"></a>02462   var-&gt;children_requested = 0;
<a name="l02463"></a>02463   var-&gt;from = -1;
<a name="l02464"></a>02464   var-&gt;to = -1;
<a name="l02465"></a>02465   var-&gt;constructor = 0;
<a name="l02466"></a>02466   var-&gt;pretty_printer = 0;
<a name="l02467"></a>02467   var-&gt;child_iter = 0;
<a name="l02468"></a>02468   var-&gt;saved_item = 0;
<a name="l02469"></a>02469 
<a name="l02470"></a>02470   <span class="keywordflow">return</span> var;
<a name="l02471"></a>02471 }
<a name="l02472"></a>02472 
<a name="l02473"></a>02473 <span class="comment">/* Allocate memory and initialize a new root variable.  */</span>
<a name="l02474"></a>02474 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *
<a name="l02475"></a><a class="code" href="varobj_8c.html#aa0e604dda78dda203375d9a8b4eaec13">02475</a> <a class="code" href="varobj_8c.html#aa0e604dda78dda203375d9a8b4eaec13">new_root_variable</a> (<span class="keywordtype">void</span>)
<a name="l02476"></a>02476 {
<a name="l02477"></a>02477   <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *var = <a class="code" href="varobj_8c.html#a774a73e3ab9589f011263b9f2e73373f">new_variable</a> ();
<a name="l02478"></a>02478 
<a name="l02479"></a>02479   var-&gt;root = (<span class="keyword">struct </span><a class="code" href="structvarobj__root.html">varobj_root</a> *) <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structvarobj__root.html">varobj_root</a>));
<a name="l02480"></a>02480   var-&gt;root-&gt;lang = NULL;
<a name="l02481"></a>02481   var-&gt;root-&gt;exp = NULL;
<a name="l02482"></a>02482   var-&gt;root-&gt;valid_block = NULL;
<a name="l02483"></a>02483   var-&gt;root-&gt;frame = <a class="code" href="frame_8c.html#a0e92fecdd3b01549ccdc07795de2afee">null_frame_id</a>;
<a name="l02484"></a>02484   var-&gt;root-&gt;floating = 0;
<a name="l02485"></a>02485   var-&gt;root-&gt;rootvar = NULL;
<a name="l02486"></a>02486   var-&gt;root-&gt;is_valid = 1;
<a name="l02487"></a>02487 
<a name="l02488"></a>02488   <span class="keywordflow">return</span> var;
<a name="l02489"></a>02489 }
<a name="l02490"></a>02490 
<a name="l02491"></a>02491 <span class="comment">/* Free any allocated memory associated with VAR.  */</span>
<a name="l02492"></a>02492 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02493"></a><a class="code" href="varobj_8c.html#aae21f5f363047cc373a24db2068908a2">02493</a> <a class="code" href="varobj_8c.html#aae21f5f363047cc373a24db2068908a2">free_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l02494"></a>02494 {
<a name="l02495"></a>02495 <span class="preprocessor">#if HAVE_PYTHON</span>
<a name="l02496"></a>02496 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (var-&gt;pretty_printer)
<a name="l02497"></a>02497     {
<a name="l02498"></a>02498       <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a> = varobj_ensure_python_env (var);
<a name="l02499"></a>02499       Py_XDECREF (var-&gt;constructor);
<a name="l02500"></a>02500       Py_XDECREF (var-&gt;pretty_printer);
<a name="l02501"></a>02501       Py_XDECREF (var-&gt;child_iter);
<a name="l02502"></a>02502       Py_XDECREF (var-&gt;saved_item);
<a name="l02503"></a>02503       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l02504"></a>02504     }
<a name="l02505"></a>02505 <span class="preprocessor">#endif</span>
<a name="l02506"></a>02506 <span class="preprocessor"></span>
<a name="l02507"></a>02507   <a class="code" href="value_8c.html#a1f9b3ee232ece65ddc75c2407b97a50d">value_free</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>);
<a name="l02508"></a>02508 
<a name="l02509"></a>02509   <span class="comment">/* Free the expression if this is a root variable.  */</span>
<a name="l02510"></a>02510   <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#ac5da1ead02d1559acf6836dcc1dbc4cc">is_root_p</a> (var))
<a name="l02511"></a>02511     {
<a name="l02512"></a>02512       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (var-&gt;root-&gt;exp);
<a name="l02513"></a>02513       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (var-&gt;root);
<a name="l02514"></a>02514     }
<a name="l02515"></a>02515 
<a name="l02516"></a>02516   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (var-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>);
<a name="l02517"></a>02517   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>);
<a name="l02518"></a>02518   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (var-&gt;print_value);
<a name="l02519"></a>02519   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (var-&gt;<a class="code" href="structvarobj.html#ab61f8b5cf72e56285b2c14a89aafc7ff">path_expr</a>);
<a name="l02520"></a>02520   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (var);
<a name="l02521"></a>02521 }
<a name="l02522"></a>02522 
<a name="l02523"></a>02523 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02524"></a><a class="code" href="varobj_8c.html#a9e34786997f1ff76c9691fba3669554b">02524</a> <a class="code" href="varobj_8c.html#a9e34786997f1ff76c9691fba3669554b">do_free_variable_cleanup</a> (<span class="keywordtype">void</span> *var)
<a name="l02525"></a>02525 {
<a name="l02526"></a>02526   <a class="code" href="varobj_8c.html#aae21f5f363047cc373a24db2068908a2">free_variable</a> (var);
<a name="l02527"></a>02527 }
<a name="l02528"></a>02528 
<a name="l02529"></a>02529 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *
<a name="l02530"></a><a class="code" href="varobj_8c.html#ac48cf109645d59e26f82fef51512080e">02530</a> <a class="code" href="varobj_8c.html#ac48cf109645d59e26f82fef51512080e">make_cleanup_free_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l02531"></a>02531 {
<a name="l02532"></a>02532   <span class="keywordflow">return</span> <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="varobj_8c.html#a9e34786997f1ff76c9691fba3669554b">do_free_variable_cleanup</a>, var);
<a name="l02533"></a>02533 }
<a name="l02534"></a>02534 
<a name="l02535"></a>02535 <span class="comment">/* This returns the type of the variable.  It also skips past typedefs</span>
<a name="l02536"></a>02536 <span class="comment">   to return the real type of the variable.</span>
<a name="l02537"></a>02537 <span class="comment"></span>
<a name="l02538"></a>02538 <span class="comment">   NOTE: TYPE_TARGET_TYPE should NOT be used anywhere in this file</span>
<a name="l02539"></a>02539 <span class="comment">   except within get_target_type and get_type.  */</span>
<a name="l02540"></a>02540 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l02541"></a><a class="code" href="varobj_8c.html#a5baa378edebe1c85afe1e15b83cb7036">02541</a> <a class="code" href="varobj_8c.html#a5baa378edebe1c85afe1e15b83cb7036">get_type</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l02542"></a>02542 {
<a name="l02543"></a>02543   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l02544"></a>02544 
<a name="l02545"></a>02545   type = var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>;
<a name="l02546"></a>02546   <span class="keywordflow">if</span> (type != NULL)
<a name="l02547"></a>02547     type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (type);
<a name="l02548"></a>02548 
<a name="l02549"></a>02549   <span class="keywordflow">return</span> <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l02550"></a>02550 }
<a name="l02551"></a>02551 
<a name="l02552"></a>02552 <span class="comment">/* Return the type of the value that&#39;s stored in VAR,</span>
<a name="l02553"></a>02553 <span class="comment">   or that would have being stored there if the</span>
<a name="l02554"></a>02554 <span class="comment">   value were accessible.</span>
<a name="l02555"></a>02555 <span class="comment"></span>
<a name="l02556"></a>02556 <span class="comment">   This differs from VAR-&gt;type in that VAR-&gt;type is always</span>
<a name="l02557"></a>02557 <span class="comment">   the true type of the expession in the source language.</span>
<a name="l02558"></a>02558 <span class="comment">   The return value of this function is the type we&#39;re</span>
<a name="l02559"></a>02559 <span class="comment">   actually storing in varobj, and using for displaying</span>
<a name="l02560"></a>02560 <span class="comment">   the values and for comparing previous and new values.</span>
<a name="l02561"></a>02561 <span class="comment"></span>
<a name="l02562"></a>02562 <span class="comment">   For example, top-level references are always stripped.  */</span>
<a name="l02563"></a>02563 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l02564"></a><a class="code" href="varobj_8c.html#adfcd4a24453cf037bb031b39a4a87051">02564</a> <a class="code" href="varobj_8c.html#adfcd4a24453cf037bb031b39a4a87051">get_value_type</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l02565"></a>02565 {
<a name="l02566"></a>02566   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l02567"></a>02567 
<a name="l02568"></a>02568   <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>)
<a name="l02569"></a>02569     type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>);
<a name="l02570"></a>02570   <span class="keywordflow">else</span>
<a name="l02571"></a>02571     type = var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>;
<a name="l02572"></a>02572 
<a name="l02573"></a>02573   type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (type);
<a name="l02574"></a>02574 
<a name="l02575"></a>02575   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l02576"></a>02576     type = <a class="code" href="varobj_8c.html#a85a491516094c4258b1fb5251108ac56">get_target_type</a> (type);
<a name="l02577"></a>02577 
<a name="l02578"></a>02578   type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (type);
<a name="l02579"></a>02579 
<a name="l02580"></a>02580   <span class="keywordflow">return</span> <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l02581"></a>02581 }
<a name="l02582"></a>02582 
<a name="l02583"></a>02583 <span class="comment">/* This returns the target type (or NULL) of TYPE, also skipping</span>
<a name="l02584"></a>02584 <span class="comment">   past typedefs, just like get_type ().</span>
<a name="l02585"></a>02585 <span class="comment"></span>
<a name="l02586"></a>02586 <span class="comment">   NOTE: TYPE_TARGET_TYPE should NOT be used anywhere in this file</span>
<a name="l02587"></a>02587 <span class="comment">   except within get_target_type and get_type.  */</span>
<a name="l02588"></a>02588 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l02589"></a><a class="code" href="varobj_8c.html#a85a491516094c4258b1fb5251108ac56">02589</a> <a class="code" href="varobj_8c.html#a85a491516094c4258b1fb5251108ac56">get_target_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>)
<a name="l02590"></a>02590 {
<a name="l02591"></a>02591   <span class="keywordflow">if</span> (type != NULL)
<a name="l02592"></a>02592     {
<a name="l02593"></a>02593       type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l02594"></a>02594       <span class="keywordflow">if</span> (type != NULL)
<a name="l02595"></a>02595         type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (type);
<a name="l02596"></a>02596     }
<a name="l02597"></a>02597 
<a name="l02598"></a>02598   <span class="keywordflow">return</span> <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l02599"></a>02599 }
<a name="l02600"></a>02600 
<a name="l02601"></a>02601 <span class="comment">/* What is the default display for this variable? We assume that</span>
<a name="l02602"></a>02602 <span class="comment">   everything is &quot;natural&quot;.  Any exceptions?  */</span>
<a name="l02603"></a>02603 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a>
<a name="l02604"></a><a class="code" href="varobj_8c.html#a1d817018a901fd63af42784cfcdff001">02604</a> <a class="code" href="varobj_8c.html#a1d817018a901fd63af42784cfcdff001">variable_default_display</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l02605"></a>02605 {
<a name="l02606"></a>02606   <span class="keywordflow">return</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bfaa12483e615405ce026f1e9555fdb2b67">FORMAT_NATURAL</a>;
<a name="l02607"></a>02607 }
<a name="l02608"></a>02608 
<a name="l02609"></a>02609 <span class="comment">/* FIXME: The following should be generic for any pointer.  */</span>
<a name="l02610"></a>02610 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02611"></a><a class="code" href="varobj_8c.html#ae93a42ae116f3c1fba220ffee78bb823">02611</a> <a class="code" href="varobj_8c.html#ae93a42ae116f3c1fba220ffee78bb823">cppush</a> (<span class="keyword">struct</span> <a class="code" href="structcpstack.html">cpstack</a> **pstack, <span class="keywordtype">char</span> *name)
<a name="l02612"></a>02612 {
<a name="l02613"></a>02613   <span class="keyword">struct </span><a class="code" href="structcpstack.html">cpstack</a> *s;
<a name="l02614"></a>02614 
<a name="l02615"></a>02615   s = (<span class="keyword">struct </span><a class="code" href="structcpstack.html">cpstack</a> *) <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structcpstack.html">cpstack</a>));
<a name="l02616"></a>02616   s-&gt;<a class="code" href="structcpstack.html#ad3a04b9c0df5fcbc898c4870fa40228c">name</a> = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l02617"></a>02617   s-&gt;<a class="code" href="structcpstack.html#af3f2cee7f0e4215ac2baf41ccd155abd">next</a> = *pstack;
<a name="l02618"></a>02618   *pstack = s;
<a name="l02619"></a>02619 }
<a name="l02620"></a>02620 
<a name="l02621"></a>02621 <span class="comment">/* FIXME: The following should be generic for any pointer.  */</span>
<a name="l02622"></a>02622 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l02623"></a><a class="code" href="varobj_8c.html#add31048dd86ce1966513b25acf18a1f5">02623</a> <a class="code" href="varobj_8c.html#add31048dd86ce1966513b25acf18a1f5">cppop</a> (<span class="keyword">struct</span> <a class="code" href="structcpstack.html">cpstack</a> **pstack)
<a name="l02624"></a>02624 {
<a name="l02625"></a>02625   <span class="keyword">struct </span><a class="code" href="structcpstack.html">cpstack</a> *s;
<a name="l02626"></a>02626   <span class="keywordtype">char</span> *v;
<a name="l02627"></a>02627 
<a name="l02628"></a>02628   <span class="keywordflow">if</span> ((*pstack)-&gt;name == NULL &amp;&amp; (*pstack)-&gt;next == NULL)
<a name="l02629"></a>02629     <span class="keywordflow">return</span> NULL;
<a name="l02630"></a>02630 
<a name="l02631"></a>02631   s = *pstack;
<a name="l02632"></a>02632   v = s-&gt;<a class="code" href="structcpstack.html#ad3a04b9c0df5fcbc898c4870fa40228c">name</a>;
<a name="l02633"></a>02633   *pstack = (*pstack)-&gt;<a class="code" href="structcpstack.html#af3f2cee7f0e4215ac2baf41ccd155abd">next</a>;
<a name="l02634"></a>02634   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (s);
<a name="l02635"></a>02635 
<a name="l02636"></a>02636   <span class="keywordflow">return</span> v;
<a name="l02637"></a>02637 }
<a name="l02638"></a>02638 
<a name="l02639"></a>02639 <span class="comment">/*</span>
<a name="l02640"></a>02640 <span class="comment"> * Language-dependencies</span>
<a name="l02641"></a>02641 <span class="comment"> */</span>
<a name="l02642"></a>02642 
<a name="l02643"></a>02643 <span class="comment">/* Common entry points */</span>
<a name="l02644"></a>02644 
<a name="l02645"></a>02645 <span class="comment">/* Get the language of variable VAR.  */</span>
<a name="l02646"></a>02646 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a8f290bc3f9b2441d6fd55bd85dd774bb">varobj_languages</a>
<a name="l02647"></a><a class="code" href="varobj_8c.html#a2e77519a3fba8c0ddec2cf0418d7a9a4">02647</a> <a class="code" href="varobj_8c.html#a2e77519a3fba8c0ddec2cf0418d7a9a4">variable_language</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l02648"></a>02648 {
<a name="l02649"></a>02649   <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a8f290bc3f9b2441d6fd55bd85dd774bb">varobj_languages</a> lang;
<a name="l02650"></a>02650 
<a name="l02651"></a>02651   <span class="keywordflow">switch</span> (var-&gt;root-&gt;exp-&gt;language_defn-&gt;la_language)
<a name="l02652"></a>02652     {
<a name="l02653"></a>02653     <span class="keywordflow">default</span>:
<a name="l02654"></a>02654     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202ad300f80a4c96edb04defba2280620a49">language_c</a>:
<a name="l02655"></a>02655       lang = <a class="code" href="varobj_8h.html#a8f290bc3f9b2441d6fd55bd85dd774bbacee5e0384c1ca1c3515cec4e6fa266c0">vlang_c</a>;
<a name="l02656"></a>02656       <span class="keywordflow">break</span>;
<a name="l02657"></a>02657     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>:
<a name="l02658"></a>02658       lang = <a class="code" href="varobj_8h.html#a8f290bc3f9b2441d6fd55bd85dd774bbae7303315b2a6e4c87bdd837690dadb4e">vlang_cplus</a>;
<a name="l02659"></a>02659       <span class="keywordflow">break</span>;
<a name="l02660"></a>02660     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a12d69481f6d247081bff8287275979ae">language_java</a>:
<a name="l02661"></a>02661       lang = <a class="code" href="varobj_8h.html#a8f290bc3f9b2441d6fd55bd85dd774bba5e15a66480fc2ce2907941013bec0dd4">vlang_java</a>;
<a name="l02662"></a>02662       <span class="keywordflow">break</span>;
<a name="l02663"></a>02663     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>:
<a name="l02664"></a>02664       lang = <a class="code" href="varobj_8h.html#a8f290bc3f9b2441d6fd55bd85dd774bba2e93db8f20d3b4b23dc765a6b941d9be">vlang_ada</a>;
<a name="l02665"></a>02665       <span class="keywordflow">break</span>;
<a name="l02666"></a>02666     }
<a name="l02667"></a>02667 
<a name="l02668"></a>02668   <span class="keywordflow">return</span> lang;
<a name="l02669"></a>02669 }
<a name="l02670"></a>02670 
<a name="l02671"></a>02671 <span class="comment">/* Return the number of children for a given variable.</span>
<a name="l02672"></a>02672 <span class="comment">   The result of this function is defined by the language</span>
<a name="l02673"></a>02673 <span class="comment">   implementation.  The number of children returned by this function</span>
<a name="l02674"></a>02674 <span class="comment">   is the number of children that the user will see in the variable</span>
<a name="l02675"></a>02675 <span class="comment">   display.  */</span>
<a name="l02676"></a>02676 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02677"></a><a class="code" href="varobj_8c.html#a32afd58f9f6ae8fb1e404873904dee3b">02677</a> <a class="code" href="varobj_8c.html#a32afd58f9f6ae8fb1e404873904dee3b">number_of_children</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l02678"></a>02678 {
<a name="l02679"></a>02679   <span class="keywordflow">return</span> (*var-&gt;root-&gt;lang-&gt;number_of_children) (var);
<a name="l02680"></a>02680 }
<a name="l02681"></a>02681 
<a name="l02682"></a>02682 <span class="comment">/* What is the expression for the root varobj VAR? Returns a malloc&#39;d</span>
<a name="l02683"></a>02683 <span class="comment">   string.  */</span>
<a name="l02684"></a>02684 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l02685"></a><a class="code" href="varobj_8c.html#a740212f7a93a8de29f093ae56681a75f">02685</a> <a class="code" href="varobj_8c.html#a740212f7a93a8de29f093ae56681a75f">name_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l02686"></a>02686 {
<a name="l02687"></a>02687   <span class="keywordflow">return</span> (*var-&gt;root-&gt;lang-&gt;name_of_variable) (var);
<a name="l02688"></a>02688 }
<a name="l02689"></a>02689 
<a name="l02690"></a>02690 <span class="comment">/* What is the name of the INDEX&#39;th child of VAR? Returns a malloc&#39;d</span>
<a name="l02691"></a>02691 <span class="comment">   string.  */</span>
<a name="l02692"></a>02692 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l02693"></a><a class="code" href="varobj_8c.html#aa197bbfcee05a8c063d1a0ec7469686d">02693</a> <a class="code" href="varobj_8c.html#aa197bbfcee05a8c063d1a0ec7469686d">name_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keywordtype">int</span> index)
<a name="l02694"></a>02694 {
<a name="l02695"></a>02695   <span class="keywordflow">return</span> (*var-&gt;root-&gt;lang-&gt;name_of_child) (var, index);
<a name="l02696"></a>02696 }
<a name="l02697"></a>02697 
<a name="l02698"></a>02698 <span class="comment">/* If frame associated with VAR can be found, switch</span>
<a name="l02699"></a>02699 <span class="comment">   to it and return 1.  Otherwise, return 0.  */</span>
<a name="l02700"></a>02700 
<a name="l02701"></a>02701 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02702"></a><a class="code" href="varobj_8c.html#a1f2e96e4abc96c488bed8e0db8579a2e">02702</a> <a class="code" href="varobj_8c.html#a1f2e96e4abc96c488bed8e0db8579a2e">check_scope</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l02703"></a>02703 {
<a name="l02704"></a>02704   <span class="keyword">struct </span><a class="code" href="structframe__info.html">frame_info</a> *fi;
<a name="l02705"></a>02705   <span class="keywordtype">int</span> scope;
<a name="l02706"></a>02706 
<a name="l02707"></a>02707   fi = <a class="code" href="frame_8c.html#a09616280d1811c8f06c46e26a8e07960">frame_find_by_id</a> (var-&gt;root-&gt;frame);
<a name="l02708"></a>02708   scope = fi != NULL;
<a name="l02709"></a>02709 
<a name="l02710"></a>02710   <span class="keywordflow">if</span> (fi)
<a name="l02711"></a>02711     {
<a name="l02712"></a>02712       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc = <a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a> (fi);
<a name="l02713"></a>02713 
<a name="l02714"></a>02714       <span class="keywordflow">if</span> (pc &lt;  <a class="code" href="block_8h.html#a08fdff319bcd75e92b61c79139592af6">BLOCK_START</a> (var-&gt;root-&gt;valid_block) ||
<a name="l02715"></a>02715           pc &gt;= <a class="code" href="block_8h.html#a61fcc8934fd274ea984eab2e0f787b6d">BLOCK_END</a> (var-&gt;root-&gt;valid_block))
<a name="l02716"></a>02716         scope = 0;
<a name="l02717"></a>02717       <span class="keywordflow">else</span>
<a name="l02718"></a>02718         <a class="code" href="frame_8c.html#a400fa273ac86863322cdc65683ef2356">select_frame</a> (fi);
<a name="l02719"></a>02719     }
<a name="l02720"></a>02720   <span class="keywordflow">return</span> scope;
<a name="l02721"></a>02721 }
<a name="l02722"></a>02722 
<a name="l02723"></a>02723 <span class="comment">/* Helper function to value_of_root.  */</span>
<a name="l02724"></a>02724 
<a name="l02725"></a>02725 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l02726"></a><a class="code" href="varobj_8c.html#a3b3c26a38e29360f60779098ebbe7417">02726</a> <a class="code" href="varobj_8c.html#a3b3c26a38e29360f60779098ebbe7417">value_of_root_1</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> **var_handle)
<a name="l02727"></a>02727 {
<a name="l02728"></a>02728   <span class="keyword">struct </span>value *new_val = NULL;
<a name="l02729"></a>02729   <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *var = *var_handle;
<a name="l02730"></a>02730   <span class="keywordtype">int</span> within_scope = 0;
<a name="l02731"></a>02731   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to;
<a name="l02732"></a>02732                                                                  
<a name="l02733"></a>02733   <span class="comment">/*  Only root variables can be updated...  */</span>
<a name="l02734"></a>02734   <span class="keywordflow">if</span> (!<a class="code" href="varobj_8c.html#ac5da1ead02d1559acf6836dcc1dbc4cc">is_root_p</a> (var))
<a name="l02735"></a>02735     <span class="comment">/* Not a root var.  */</span>
<a name="l02736"></a>02736     <span class="keywordflow">return</span> NULL;
<a name="l02737"></a>02737 
<a name="l02738"></a>02738   back_to = <a class="code" href="gdbthread_8h.html#a7a784124700d19ad7da32e2c20d3b0c6">make_cleanup_restore_current_thread</a> ();
<a name="l02739"></a>02739 
<a name="l02740"></a>02740   <span class="comment">/* Determine whether the variable is still around.  */</span>
<a name="l02741"></a>02741   <span class="keywordflow">if</span> (var-&gt;root-&gt;valid_block == NULL || var-&gt;root-&gt;floating)
<a name="l02742"></a>02742     within_scope = 1;
<a name="l02743"></a>02743   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (var-&gt;root-&gt;thread_id == 0)
<a name="l02744"></a>02744     {
<a name="l02745"></a>02745       <span class="comment">/* The program was single-threaded when the variable object was</span>
<a name="l02746"></a>02746 <span class="comment">         created.  Technically, it&#39;s possible that the program became</span>
<a name="l02747"></a>02747 <span class="comment">         multi-threaded since then, but we don&#39;t support such</span>
<a name="l02748"></a>02748 <span class="comment">         scenario yet.  */</span>
<a name="l02749"></a>02749       within_scope = <a class="code" href="varobj_8c.html#a1f2e96e4abc96c488bed8e0db8579a2e">check_scope</a> (var);   
<a name="l02750"></a>02750     }
<a name="l02751"></a>02751   <span class="keywordflow">else</span>
<a name="l02752"></a>02752     {
<a name="l02753"></a>02753       <a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a> = <a class="code" href="gdbthread_8h.html#a94339815b47745a9d391923804bcce51">thread_id_to_pid</a> (var-&gt;root-&gt;thread_id);
<a name="l02754"></a>02754       <span class="keywordflow">if</span> (<a class="code" href="gdbthread_8h.html#a75cff5779f03e4119723fd41a5583fa7">in_thread_list</a> (ptid))
<a name="l02755"></a>02755         {
<a name="l02756"></a>02756           <a class="code" href="gdbthread_8h.html#aee26ee8d9825599b321b73d2ecb5ac54">switch_to_thread</a> (ptid);
<a name="l02757"></a>02757           within_scope = <a class="code" href="varobj_8c.html#a1f2e96e4abc96c488bed8e0db8579a2e">check_scope</a> (var);
<a name="l02758"></a>02758         }
<a name="l02759"></a>02759     }
<a name="l02760"></a>02760 
<a name="l02761"></a>02761   <span class="keywordflow">if</span> (within_scope)
<a name="l02762"></a>02762     {
<a name="l02763"></a>02763       <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> except;
<a name="l02764"></a>02764 
<a name="l02765"></a>02765       <span class="comment">/* We need to catch errors here, because if evaluate</span>
<a name="l02766"></a>02766 <span class="comment">         expression fails we want to just return NULL.  */</span>
<a name="l02767"></a>02767       <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l02768"></a>02768         {
<a name="l02769"></a>02769           new_val = <a class="code" href="eval_8c.html#ab50151ccba3ea3184c114121d6bed422">evaluate_expression</a> (var-&gt;root-&gt;exp);
<a name="l02770"></a>02770         }
<a name="l02771"></a>02771     }
<a name="l02772"></a>02772 
<a name="l02773"></a>02773   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l02774"></a>02774 
<a name="l02775"></a>02775   <span class="keywordflow">return</span> new_val;
<a name="l02776"></a>02776 }
<a name="l02777"></a>02777 
<a name="l02778"></a>02778 <span class="comment">/* What is the ``struct value *&#39;&#39; of the root variable VAR?</span>
<a name="l02779"></a>02779 <span class="comment">   For floating variable object, evaluation can get us a value</span>
<a name="l02780"></a>02780 <span class="comment">   of different type from what is stored in varobj already.  In</span>
<a name="l02781"></a>02781 <span class="comment">   that case:</span>
<a name="l02782"></a>02782 <span class="comment">   - *type_changed will be set to 1</span>
<a name="l02783"></a>02783 <span class="comment">   - old varobj will be freed, and new one will be</span>
<a name="l02784"></a>02784 <span class="comment">   created, with the same name.</span>
<a name="l02785"></a>02785 <span class="comment">   - *var_handle will be set to the new varobj </span>
<a name="l02786"></a>02786 <span class="comment">   Otherwise, *type_changed will be set to 0.  */</span>
<a name="l02787"></a>02787 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l02788"></a><a class="code" href="varobj_8c.html#ad9e8c230e67c9e52f1f4aaaceae075f0">02788</a> <a class="code" href="varobj_8c.html#ad9e8c230e67c9e52f1f4aaaceae075f0">value_of_root</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> **var_handle, <span class="keywordtype">int</span> *type_changed)
<a name="l02789"></a>02789 {
<a name="l02790"></a>02790   <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *var;
<a name="l02791"></a>02791 
<a name="l02792"></a>02792   <span class="keywordflow">if</span> (var_handle == NULL)
<a name="l02793"></a>02793     <span class="keywordflow">return</span> NULL;
<a name="l02794"></a>02794 
<a name="l02795"></a>02795   var = *var_handle;
<a name="l02796"></a>02796 
<a name="l02797"></a>02797   <span class="comment">/* This should really be an exception, since this should</span>
<a name="l02798"></a>02798 <span class="comment">     only get called with a root variable.  */</span>
<a name="l02799"></a>02799 
<a name="l02800"></a>02800   <span class="keywordflow">if</span> (!<a class="code" href="varobj_8c.html#ac5da1ead02d1559acf6836dcc1dbc4cc">is_root_p</a> (var))
<a name="l02801"></a>02801     <span class="keywordflow">return</span> NULL;
<a name="l02802"></a>02802 
<a name="l02803"></a>02803   <span class="keywordflow">if</span> (var-&gt;root-&gt;floating)
<a name="l02804"></a>02804     {
<a name="l02805"></a>02805       <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *tmp_var;
<a name="l02806"></a>02806       <span class="keywordtype">char</span> *old_type, *<a class="code" href="mdebugread_8c.html#ab1ece714ac6020a52b26279dfc1b20d7">new_type</a>;
<a name="l02807"></a>02807 
<a name="l02808"></a>02808       tmp_var = <a class="code" href="varobj_8c.html#aa0cbdb998dfbf2469c767968ecf2c333">varobj_create</a> (NULL, var-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>, (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 0,
<a name="l02809"></a>02809                                <a class="code" href="varobj_8h.html#a1a5e81372ed6f07cbe8792bf36af015fa33a1b3efb7304b9480dd0cfbcdf0606f">USE_SELECTED_FRAME</a>);
<a name="l02810"></a>02810       <span class="keywordflow">if</span> (tmp_var == NULL)
<a name="l02811"></a>02811         {
<a name="l02812"></a>02812           <span class="keywordflow">return</span> NULL;
<a name="l02813"></a>02813         }
<a name="l02814"></a>02814       old_type = <a class="code" href="varobj_8c.html#abbed36957b6c4795bb3f37ab04f32122">varobj_get_type</a> (var);
<a name="l02815"></a>02815       new_type = <a class="code" href="varobj_8c.html#abbed36957b6c4795bb3f37ab04f32122">varobj_get_type</a> (tmp_var);
<a name="l02816"></a>02816       <span class="keywordflow">if</span> (strcmp (old_type, new_type) == 0)
<a name="l02817"></a>02817         {
<a name="l02818"></a>02818           <span class="comment">/* The expression presently stored inside var-&gt;root-&gt;exp</span>
<a name="l02819"></a>02819 <span class="comment">             remembers the locations of local variables relatively to</span>
<a name="l02820"></a>02820 <span class="comment">             the frame where the expression was created (in DWARF location</span>
<a name="l02821"></a>02821 <span class="comment">             button, for example).  Naturally, those locations are not</span>
<a name="l02822"></a>02822 <span class="comment">             correct in other frames, so update the expression.  */</span>
<a name="l02823"></a>02823 
<a name="l02824"></a>02824          <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *tmp_exp = var-&gt;root-&gt;exp;
<a name="l02825"></a>02825 
<a name="l02826"></a>02826          var-&gt;root-&gt;exp = tmp_var-&gt;root-&gt;exp;
<a name="l02827"></a>02827          tmp_var-&gt;root-&gt;exp = tmp_exp;
<a name="l02828"></a>02828 
<a name="l02829"></a>02829           <a class="code" href="varobj_8c.html#aad58751b29b14a5eeb8b9879df27683d">varobj_delete</a> (tmp_var, NULL, 0);
<a name="l02830"></a>02830           *type_changed = 0;
<a name="l02831"></a>02831         }
<a name="l02832"></a>02832       <span class="keywordflow">else</span>
<a name="l02833"></a>02833         {
<a name="l02834"></a>02834           tmp_var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a> = xstrdup (var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>);
<a name="l02835"></a>02835           tmp_var-&gt;from = var-&gt;from;
<a name="l02836"></a>02836           tmp_var-&gt;to = var-&gt;to;
<a name="l02837"></a>02837           <a class="code" href="varobj_8c.html#aad58751b29b14a5eeb8b9879df27683d">varobj_delete</a> (var, NULL, 0);
<a name="l02838"></a>02838 
<a name="l02839"></a>02839           <a class="code" href="varobj_8c.html#add625a61acb44538c0b77386e3ee3549">install_variable</a> (tmp_var);
<a name="l02840"></a>02840           *var_handle = tmp_var;
<a name="l02841"></a>02841           var = *var_handle;
<a name="l02842"></a>02842           *type_changed = 1;
<a name="l02843"></a>02843         }
<a name="l02844"></a>02844       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (old_type);
<a name="l02845"></a>02845       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (new_type);
<a name="l02846"></a>02846     }
<a name="l02847"></a>02847   <span class="keywordflow">else</span>
<a name="l02848"></a>02848     {
<a name="l02849"></a>02849       *type_changed = 0;
<a name="l02850"></a>02850     }
<a name="l02851"></a>02851 
<a name="l02852"></a>02852   {
<a name="l02853"></a>02853     <span class="keyword">struct </span>value *value;
<a name="l02854"></a>02854 
<a name="l02855"></a>02855     value = <a class="code" href="varobj_8c.html#a3b3c26a38e29360f60779098ebbe7417">value_of_root_1</a> (var_handle);
<a name="l02856"></a>02856     <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a> == NULL || value == NULL)
<a name="l02857"></a>02857       {
<a name="l02858"></a>02858         <span class="comment">/* For root varobj-s, a NULL value indicates a scoping issue.</span>
<a name="l02859"></a>02859 <span class="comment">           So, nothing to do in terms of checking for mutations.  */</span>
<a name="l02860"></a>02860       }
<a name="l02861"></a>02861     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a0d90582139f279de93a66edda42b95d1">varobj_value_has_mutated</a> (var, value, <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (value)))
<a name="l02862"></a>02862       {
<a name="l02863"></a>02863         <span class="comment">/* The type has mutated, so the children are no longer valid.</span>
<a name="l02864"></a>02864 <span class="comment">           Just delete them, and tell our caller that the type has</span>
<a name="l02865"></a>02865 <span class="comment">           changed.  */</span>
<a name="l02866"></a>02866         <a class="code" href="varobj_8c.html#aad58751b29b14a5eeb8b9879df27683d">varobj_delete</a> (var, NULL, 1 <span class="comment">/* only_children */</span>);
<a name="l02867"></a>02867         var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a> = -1;
<a name="l02868"></a>02868         var-&gt;to = -1;
<a name="l02869"></a>02869         var-&gt;from = -1;
<a name="l02870"></a>02870         *type_changed = 1;
<a name="l02871"></a>02871       }
<a name="l02872"></a>02872     <span class="keywordflow">return</span> value;
<a name="l02873"></a>02873   }
<a name="l02874"></a>02874 }
<a name="l02875"></a>02875 
<a name="l02876"></a>02876 <span class="comment">/* What is the ``struct value *&#39;&#39; for the INDEX&#39;th child of PARENT?  */</span>
<a name="l02877"></a>02877 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l02878"></a><a class="code" href="varobj_8c.html#af2a5adec143186b5712eb28d0e415b18">02878</a> <a class="code" href="varobj_8c.html#af2a5adec143186b5712eb28d0e415b18">value_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvalue.html#ac5784dc092188f21d4d2a0e041a8eeb8">parent</a>, <span class="keywordtype">int</span> index)
<a name="l02879"></a>02879 {
<a name="l02880"></a>02880   <span class="keyword">struct </span>value *value;
<a name="l02881"></a>02881 
<a name="l02882"></a>02882   value = (*parent-&gt;root-&gt;lang-&gt;value_of_child) (parent, index);
<a name="l02883"></a>02883 
<a name="l02884"></a>02884   <span class="keywordflow">return</span> value;
<a name="l02885"></a>02885 }
<a name="l02886"></a>02886 
<a name="l02887"></a>02887 <span class="comment">/* GDB already has a command called &quot;value_of_variable&quot;.  Sigh.  */</span>
<a name="l02888"></a>02888 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l02889"></a><a class="code" href="varobj_8c.html#a2af60930bf1939550552e6c1fc1096eb">02889</a> <a class="code" href="varobj_8c.html#a2af60930bf1939550552e6c1fc1096eb">my_value_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format)
<a name="l02890"></a>02890 {
<a name="l02891"></a>02891   <span class="keywordflow">if</span> (var-&gt;root-&gt;is_valid)
<a name="l02892"></a>02892     {
<a name="l02893"></a>02893       <span class="keywordflow">if</span> (var-&gt;pretty_printer)
<a name="l02894"></a>02894         <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#a371cbd65da3254826f01cbf5fd49380c">value_get_print_value</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>, var-&gt;format, var);
<a name="l02895"></a>02895       <span class="keywordflow">return</span> (*var-&gt;root-&gt;lang-&gt;value_of_variable) (var, format);
<a name="l02896"></a>02896     }
<a name="l02897"></a>02897   <span class="keywordflow">else</span>
<a name="l02898"></a>02898     <span class="keywordflow">return</span> NULL;
<a name="l02899"></a>02899 }
<a name="l02900"></a>02900 
<a name="l02901"></a>02901 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l02902"></a><a class="code" href="varobj_8c.html#a371cbd65da3254826f01cbf5fd49380c">02902</a> <a class="code" href="varobj_8c.html#a371cbd65da3254826f01cbf5fd49380c">value_get_print_value</a> (<span class="keyword">struct</span> value *value, <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format,
<a name="l02903"></a>02903                        <span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l02904"></a>02904 {
<a name="l02905"></a>02905   <span class="keyword">struct </span><a class="code" href="structui__file.html">ui_file</a> *stb;
<a name="l02906"></a>02906   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_chain;
<a name="l02907"></a>02907   <span class="keywordtype">char</span> *thevalue = NULL;
<a name="l02908"></a>02908   <span class="keyword">struct </span><a class="code" href="structvalue__print__options.html">value_print_options</a> opts;
<a name="l02909"></a>02909   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = NULL;
<a name="l02910"></a>02910   <span class="keywordtype">long</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a> = 0;
<a name="l02911"></a>02911   <span class="keywordtype">char</span> *<a class="code" href="remote-mips_8c.html#a6054357a716d1736062d17be60d31a02">encoding</a> = NULL;
<a name="l02912"></a>02912   <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = NULL;
<a name="l02913"></a>02913   <span class="comment">/* Initialize it just to avoid a GCC false warning.  */</span>
<a name="l02914"></a>02914   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> str_addr = 0;
<a name="l02915"></a>02915   <span class="keywordtype">int</span> string_print = 0;
<a name="l02916"></a>02916 
<a name="l02917"></a>02917   <span class="keywordflow">if</span> (value == NULL)
<a name="l02918"></a>02918     <span class="keywordflow">return</span> NULL;
<a name="l02919"></a>02919 
<a name="l02920"></a>02920   stb = <a class="code" href="ui-file_8c.html#a340771735f105582d314e191a399a45c">mem_fileopen</a> ();
<a name="l02921"></a>02921   old_chain = <a class="code" href="utils_8c.html#a94dc56baeb57791e114136764f7763aa">make_cleanup_ui_file_delete</a> (stb);
<a name="l02922"></a>02922 
<a name="l02923"></a>02923   gdbarch = <a class="code" href="gdbtypes_8c.html#a84ca61a6d58c2bd2c7dcedf19d56a39d">get_type_arch</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (value));
<a name="l02924"></a>02924 <span class="preprocessor">#if HAVE_PYTHON</span>
<a name="l02925"></a>02925 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="python-internal_8h.html#a2f9782caf78c6a6f300ce14c165d9605">gdb_python_initialized</a>)
<a name="l02926"></a>02926     {
<a name="l02927"></a>02927       <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *value_formatter = var-&gt;pretty_printer;
<a name="l02928"></a>02928 
<a name="l02929"></a>02929       varobj_ensure_python_env (var);
<a name="l02930"></a>02930 
<a name="l02931"></a>02931       <span class="keywordflow">if</span> (value_formatter)
<a name="l02932"></a>02932         {
<a name="l02933"></a>02933           <span class="comment">/* First check to see if we have any children at all.  If so,</span>
<a name="l02934"></a>02934 <span class="comment">             we simply return {...}.  */</span>
<a name="l02935"></a>02935           <span class="keywordflow">if</span> (dynamic_varobj_has_child_method (var))
<a name="l02936"></a>02936             {
<a name="l02937"></a>02937               <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l02938"></a>02938               <span class="keywordflow">return</span> xstrdup (<span class="stringliteral">&quot;{...}&quot;</span>);
<a name="l02939"></a>02939             }
<a name="l02940"></a>02940 
<a name="l02941"></a>02941           <span class="keywordflow">if</span> (PyObject_HasAttr (value_formatter, <a class="code" href="python-internal_8h.html#ab630d8d83284fb96008ec492c6b2e084">gdbpy_to_string_cst</a>))
<a name="l02942"></a>02942             {
<a name="l02943"></a>02943               <span class="keyword">struct </span>value *replacement;
<a name="l02944"></a>02944               <a class="code" href="varobj_8c.html#acf2acb6d745ed9adf8d9575f603d7a58">PyObject</a> *output = NULL;
<a name="l02945"></a>02945 
<a name="l02946"></a>02946               output = <a class="code" href="python-internal_8h.html#a9d364cd4b21dd41b13091fe54b90243e">apply_varobj_pretty_printer</a> (value_formatter,
<a name="l02947"></a>02947                                                     &amp;replacement,
<a name="l02948"></a>02948                                                     stb);
<a name="l02949"></a>02949 
<a name="l02950"></a>02950               <span class="comment">/* If we have string like output ...  */</span>
<a name="l02951"></a>02951               <span class="keywordflow">if</span> (output)
<a name="l02952"></a>02952                 {
<a name="l02953"></a>02953                   <a class="code" href="py-utils_8c.html#a58ef2184225d9f93b45b203dde2c5bc7">make_cleanup_py_decref</a> (output);
<a name="l02954"></a>02954 
<a name="l02955"></a>02955                   <span class="comment">/* If this is a lazy string, extract it.  For lazy</span>
<a name="l02956"></a>02956 <span class="comment">                     strings we always print as a string, so set</span>
<a name="l02957"></a>02957 <span class="comment">                     string_print.  */</span>
<a name="l02958"></a>02958                   <span class="keywordflow">if</span> (<a class="code" href="py-lazy-string_8c.html#a56363d42397d810be92d4ed8a3818617">gdbpy_is_lazy_string</a> (output))
<a name="l02959"></a>02959                     {
<a name="l02960"></a>02960                       <a class="code" href="py-lazy-string_8c.html#a72c5c6e787539657f9a6aa1d408d9aca">gdbpy_extract_lazy_string</a> (output, &amp;str_addr, &amp;type,
<a name="l02961"></a>02961                                                  &amp;len, &amp;encoding);
<a name="l02962"></a>02962                       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="utils_8c.html#a6d8c21606d3f67a431a7bfbb1f47d12e">free_current_contents</a>, &amp;encoding);
<a name="l02963"></a>02963                       string_print = 1;
<a name="l02964"></a>02964                     }
<a name="l02965"></a>02965                   <span class="keywordflow">else</span>
<a name="l02966"></a>02966                     {
<a name="l02967"></a>02967                       <span class="comment">/* If it is a regular (non-lazy) string, extract</span>
<a name="l02968"></a>02968 <span class="comment">                         it and copy the contents into THEVALUE.  If the</span>
<a name="l02969"></a>02969 <span class="comment">                         hint says to print it as a string, set</span>
<a name="l02970"></a>02970 <span class="comment">                         string_print.  Otherwise just return the extracted</span>
<a name="l02971"></a>02971 <span class="comment">                         string as a value.  */</span>
<a name="l02972"></a>02972 
<a name="l02973"></a>02973                       <span class="keywordtype">char</span> *s = <a class="code" href="py-utils_8c.html#a604708bdbaf37a634d5a01980f26d02b">python_string_to_target_string</a> (output);
<a name="l02974"></a>02974 
<a name="l02975"></a>02975                       <span class="keywordflow">if</span> (s)
<a name="l02976"></a>02976                         {
<a name="l02977"></a>02977                           <span class="keywordtype">char</span> *hint;
<a name="l02978"></a>02978 
<a name="l02979"></a>02979                           hint = <a class="code" href="python-internal_8h.html#a52ec91554ac239169da1e5e23b612436">gdbpy_get_display_hint</a> (value_formatter);
<a name="l02980"></a>02980                           <span class="keywordflow">if</span> (hint)
<a name="l02981"></a>02981                             {
<a name="l02982"></a>02982                               <span class="keywordflow">if</span> (!strcmp (hint, <span class="stringliteral">&quot;string&quot;</span>))
<a name="l02983"></a>02983                                 string_print = 1;
<a name="l02984"></a>02984                               <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (hint);
<a name="l02985"></a>02985                             }
<a name="l02986"></a>02986 
<a name="l02987"></a>02987                           len = strlen (s);
<a name="l02988"></a>02988                           thevalue = xmemdup (s, len + 1, len + 1);
<a name="l02989"></a>02989                           type = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#aaf6738aff8469bfe0b9d5d3793a3b59b">builtin_char</a>;
<a name="l02990"></a>02990                           <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (s);
<a name="l02991"></a>02991 
<a name="l02992"></a>02992                           <span class="keywordflow">if</span> (!string_print)
<a name="l02993"></a>02993                             {
<a name="l02994"></a>02994                               <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l02995"></a>02995                               <span class="keywordflow">return</span> thevalue;
<a name="l02996"></a>02996                             }
<a name="l02997"></a>02997 
<a name="l02998"></a>02998                           <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, thevalue);
<a name="l02999"></a>02999                         }
<a name="l03000"></a>03000                       <span class="keywordflow">else</span>
<a name="l03001"></a>03001                         <a class="code" href="python-internal_8h.html#a0547cdf5b8063543c37589085a7cfe31">gdbpy_print_stack</a> ();
<a name="l03002"></a>03002                     }
<a name="l03003"></a>03003                 }
<a name="l03004"></a>03004               <span class="comment">/* If the printer returned a replacement value, set VALUE</span>
<a name="l03005"></a>03005 <span class="comment">                 to REPLACEMENT.  If there is not a replacement value,</span>
<a name="l03006"></a>03006 <span class="comment">                 just use the value passed to this function.  */</span>
<a name="l03007"></a>03007               <span class="keywordflow">if</span> (replacement)
<a name="l03008"></a>03008                 value = replacement;
<a name="l03009"></a>03009             }
<a name="l03010"></a>03010         }
<a name="l03011"></a>03011     }
<a name="l03012"></a>03012 <span class="preprocessor">#endif</span>
<a name="l03013"></a>03013 <span class="preprocessor"></span>
<a name="l03014"></a>03014   <a class="code" href="valprint_8c.html#a1177f66ae5a60db2a75604f268dba57f">get_formatted_print_options</a> (&amp;opts, <a class="code" href="varobj_8c.html#adc4d9de429cbfa905ad9962a7e4daf8e">format_code</a>[(<span class="keywordtype">int</span>) format]);
<a name="l03015"></a>03015   opts.<a class="code" href="structvalue__print__options.html#a60ebf7f26982bd56f13befa7ef7cc686">deref_ref</a> = 0;
<a name="l03016"></a>03016   opts.<a class="code" href="structvalue__print__options.html#a906b0433c8e9bad5a42fa6430026e8cc">raw</a> = 1;
<a name="l03017"></a>03017 
<a name="l03018"></a>03018   <span class="comment">/* If the THEVALUE has contents, it is a regular string.  */</span>
<a name="l03019"></a>03019   <span class="keywordflow">if</span> (thevalue)
<a name="l03020"></a>03020     <a class="code" href="language_8h.html#af15836dc43db6e9c2d240423fc712599">LA_PRINT_STRING</a> (stb, type, (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *) thevalue, len, encoding, 0, &amp;opts);
<a name="l03021"></a>03021   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (string_print)
<a name="l03022"></a>03022     <span class="comment">/* Otherwise, if string_print is set, and it is not a regular</span>
<a name="l03023"></a>03023 <span class="comment">       string, it is a lazy string.  */</span>
<a name="l03024"></a>03024     <a class="code" href="valprint_8c.html#a95c390f3325bc0a8a50068a6cf17d28c">val_print_string</a> (type, encoding, str_addr, len, stb, &amp;opts);
<a name="l03025"></a>03025   <span class="keywordflow">else</span>
<a name="l03026"></a>03026     <span class="comment">/* All other cases.  */</span>
<a name="l03027"></a>03027     <a class="code" href="valprint_8c.html#a3b8220f1b9270a2f8b8f4e197f2be9db">common_val_print</a> (value, stb, 0, &amp;opts, <a class="code" href="language_8c.html#acd2505a014a95629da9c836f8914fc79">current_language</a>);
<a name="l03028"></a>03028 
<a name="l03029"></a>03029   thevalue = <a class="code" href="ui-file_8c.html#a995485039ce5a1d994a1863cd76a5356">ui_file_xstrdup</a> (stb, NULL);
<a name="l03030"></a>03030 
<a name="l03031"></a>03031   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l03032"></a>03032   <span class="keywordflow">return</span> thevalue;
<a name="l03033"></a>03033 }
<a name="l03034"></a>03034 
<a name="l03035"></a>03035 <span class="keywordtype">int</span>
<a name="l03036"></a><a class="code" href="varobj_8h.html#a1a38528222361cdfcfe2648d7afaef74">03036</a> <a class="code" href="varobj_8c.html#a1a38528222361cdfcfe2648d7afaef74">varobj_editable_p</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l03037"></a>03037 {
<a name="l03038"></a>03038   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l03039"></a>03039 
<a name="l03040"></a>03040   <span class="keywordflow">if</span> (!(var-&gt;root-&gt;is_valid &amp;&amp; var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a> &amp;&amp; <a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>)))
<a name="l03041"></a>03041     <span class="keywordflow">return</span> 0;
<a name="l03042"></a>03042 
<a name="l03043"></a>03043   type = <a class="code" href="varobj_8c.html#adfcd4a24453cf037bb031b39a4a87051">get_value_type</a> (var);
<a name="l03044"></a>03044 
<a name="l03045"></a>03045   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l03046"></a>03046     {
<a name="l03047"></a>03047     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l03048"></a>03048     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>:
<a name="l03049"></a>03049     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>:
<a name="l03050"></a>03050     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>:
<a name="l03051"></a>03051     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a581771a1410949e8b505dd51426949e9">TYPE_CODE_METHOD</a>:
<a name="l03052"></a>03052       <span class="keywordflow">return</span> 0;
<a name="l03053"></a>03053       <span class="keywordflow">break</span>;
<a name="l03054"></a>03054 
<a name="l03055"></a>03055     <span class="keywordflow">default</span>:
<a name="l03056"></a>03056       <span class="keywordflow">return</span> 1;
<a name="l03057"></a>03057       <span class="keywordflow">break</span>;
<a name="l03058"></a>03058     }
<a name="l03059"></a>03059 }
<a name="l03060"></a>03060 
<a name="l03061"></a>03061 <span class="comment">/* Call VAR&#39;s value_is_changeable_p language-specific callback.  */</span>
<a name="l03062"></a>03062 
<a name="l03063"></a>03063 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03064"></a><a class="code" href="varobj_8c.html#a176f5fae4079ee6acd5df422bd0e8f4c">03064</a> <a class="code" href="varobj_8c.html#a176f5fae4079ee6acd5df422bd0e8f4c">varobj_value_is_changeable_p</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l03065"></a>03065 {
<a name="l03066"></a>03066   <span class="keywordflow">return</span> var-&gt;root-&gt;lang-&gt;value_is_changeable_p (var);
<a name="l03067"></a>03067 }
<a name="l03068"></a>03068 
<a name="l03069"></a>03069 <span class="comment">/* Return 1 if that varobj is floating, that is is always evaluated in the</span>
<a name="l03070"></a>03070 <span class="comment">   selected frame, and not bound to thread/frame.  Such variable objects</span>
<a name="l03071"></a>03071 <span class="comment">   are created using &#39;@&#39; as frame specifier to -var-create.  */</span>
<a name="l03072"></a>03072 <span class="keywordtype">int</span>
<a name="l03073"></a><a class="code" href="varobj_8h.html#a4ce8787b50ff4cd3d82b17717f877b29">03073</a> <a class="code" href="varobj_8c.html#a4ce8787b50ff4cd3d82b17717f877b29">varobj_floating_p</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l03074"></a>03074 {
<a name="l03075"></a>03075   <span class="keywordflow">return</span> var-&gt;root-&gt;floating;
<a name="l03076"></a>03076 }
<a name="l03077"></a>03077 
<a name="l03078"></a>03078 <span class="comment">/* Given the value and the type of a variable object,</span>
<a name="l03079"></a>03079 <span class="comment">   adjust the value and type to those necessary</span>
<a name="l03080"></a>03080 <span class="comment">   for getting children of the variable object.</span>
<a name="l03081"></a>03081 <span class="comment">   This includes dereferencing top-level references</span>
<a name="l03082"></a>03082 <span class="comment">   to all types and dereferencing pointers to</span>
<a name="l03083"></a>03083 <span class="comment">   structures.</span>
<a name="l03084"></a>03084 <span class="comment"></span>
<a name="l03085"></a>03085 <span class="comment">   If LOOKUP_ACTUAL_TYPE is set the enclosing type of the</span>
<a name="l03086"></a>03086 <span class="comment">   value will be fetched and if it differs from static type</span>
<a name="l03087"></a>03087 <span class="comment">   the value will be casted to it.</span>
<a name="l03088"></a>03088 <span class="comment"></span>
<a name="l03089"></a>03089 <span class="comment">   Both TYPE and *TYPE should be non-null.  VALUE</span>
<a name="l03090"></a>03090 <span class="comment">   can be null if we want to only translate type.</span>
<a name="l03091"></a>03091 <span class="comment">   *VALUE can be null as well -- if the parent</span>
<a name="l03092"></a>03092 <span class="comment">   value is not known.</span>
<a name="l03093"></a>03093 <span class="comment"></span>
<a name="l03094"></a>03094 <span class="comment">   If WAS_PTR is not NULL, set *WAS_PTR to 0 or 1</span>
<a name="l03095"></a>03095 <span class="comment">   depending on whether pointer was dereferenced</span>
<a name="l03096"></a>03096 <span class="comment">   in this function.  */</span>
<a name="l03097"></a>03097 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03098"></a><a class="code" href="varobj_8c.html#a23aab7856e76fa75914b2f89d885e3ee">03098</a> <a class="code" href="varobj_8c.html#a23aab7856e76fa75914b2f89d885e3ee">adjust_value_for_child_access</a> (<span class="keyword">struct</span> value **value,
<a name="l03099"></a>03099                                   <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **<a class="code" href="structtype.html">type</a>,
<a name="l03100"></a>03100                                   <span class="keywordtype">int</span> *was_ptr,
<a name="l03101"></a>03101                                   <span class="keywordtype">int</span> lookup_actual_type)
<a name="l03102"></a>03102 {
<a name="l03103"></a>03103   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (type &amp;&amp; *type);
<a name="l03104"></a>03104 
<a name="l03105"></a>03105   <span class="keywordflow">if</span> (was_ptr)
<a name="l03106"></a>03106     *was_ptr = 0;
<a name="l03107"></a>03107 
<a name="l03108"></a>03108   *type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (*type);
<a name="l03109"></a>03109   
<a name="l03110"></a>03110   <span class="comment">/* The type of value stored in varobj, that is passed</span>
<a name="l03111"></a>03111 <span class="comment">     to us, is already supposed to be</span>
<a name="l03112"></a>03112 <span class="comment">     reference-stripped.  */</span>
<a name="l03113"></a>03113 
<a name="l03114"></a>03114   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (*type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>);
<a name="l03115"></a>03115 
<a name="l03116"></a>03116   <span class="comment">/* Pointers to structures are treated just like</span>
<a name="l03117"></a>03117 <span class="comment">     structures when accessing children.  Don&#39;t</span>
<a name="l03118"></a>03118 <span class="comment">     dererences pointers to other types.  */</span>
<a name="l03119"></a>03119   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (*type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l03120"></a>03120     {
<a name="l03121"></a>03121       <span class="keyword">struct </span>type *target_type = <a class="code" href="varobj_8c.html#a85a491516094c4258b1fb5251108ac56">get_target_type</a> (*type);
<a name="l03122"></a>03122       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (target_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l03123"></a>03123           || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (target_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l03124"></a>03124         {
<a name="l03125"></a>03125           <span class="keywordflow">if</span> (value &amp;&amp; *value)
<a name="l03126"></a>03126             {
<a name="l03127"></a>03127               <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> except;
<a name="l03128"></a>03128 
<a name="l03129"></a>03129               <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l03130"></a>03130                 {
<a name="l03131"></a>03131                   *value = <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (*value);
<a name="l03132"></a>03132                 }
<a name="l03133"></a>03133 
<a name="l03134"></a>03134               <span class="keywordflow">if</span> (except.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0)
<a name="l03135"></a>03135                 *value = NULL;
<a name="l03136"></a>03136             }
<a name="l03137"></a>03137           *type = target_type;
<a name="l03138"></a>03138           <span class="keywordflow">if</span> (was_ptr)
<a name="l03139"></a>03139             *was_ptr = 1;
<a name="l03140"></a>03140         }
<a name="l03141"></a>03141     }
<a name="l03142"></a>03142 
<a name="l03143"></a>03143   <span class="comment">/* The &#39;get_target_type&#39; function calls check_typedef on</span>
<a name="l03144"></a>03144 <span class="comment">     result, so we can immediately check type code.  No</span>
<a name="l03145"></a>03145 <span class="comment">     need to call check_typedef here.  */</span>
<a name="l03146"></a>03146 
<a name="l03147"></a>03147   <span class="comment">/* Access a real type of the value (if necessary and possible).  */</span>
<a name="l03148"></a>03148   <span class="keywordflow">if</span> (value &amp;&amp; *value &amp;&amp; lookup_actual_type)
<a name="l03149"></a>03149     {
<a name="l03150"></a>03150       <span class="keyword">struct </span>type *enclosing_type;
<a name="l03151"></a>03151       <span class="keywordtype">int</span> real_type_found = 0;
<a name="l03152"></a>03152 
<a name="l03153"></a>03153       enclosing_type = <a class="code" href="value_8c.html#aad0d3b9452bbb8b01fb2f0cc5f1bf093">value_actual_type</a> (*value, 1, &amp;real_type_found);
<a name="l03154"></a>03154       <span class="keywordflow">if</span> (real_type_found)
<a name="l03155"></a>03155         {
<a name="l03156"></a>03156           *type = enclosing_type;
<a name="l03157"></a>03157           *value = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (enclosing_type, *value);
<a name="l03158"></a>03158         }
<a name="l03159"></a>03159     }
<a name="l03160"></a>03160 }
<a name="l03161"></a>03161 
<a name="l03162"></a>03162 <span class="comment">/* Implement the &quot;value_is_changeable_p&quot; varobj callback for most</span>
<a name="l03163"></a>03163 <span class="comment">   languages.  */</span>
<a name="l03164"></a>03164 
<a name="l03165"></a>03165 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03166"></a><a class="code" href="varobj_8c.html#af62c3759117b3e5c21282af5feebf900">03166</a> <a class="code" href="varobj_8c.html#af62c3759117b3e5c21282af5feebf900">default_value_is_changeable_p</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l03167"></a>03167 {
<a name="l03168"></a>03168   <span class="keywordtype">int</span> r;
<a name="l03169"></a>03169   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l03170"></a>03170 
<a name="l03171"></a>03171   <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a0af68d4c2837464c18ae1eb457749c7d">CPLUS_FAKE_CHILD</a> (var))
<a name="l03172"></a>03172     <span class="keywordflow">return</span> 0;
<a name="l03173"></a>03173 
<a name="l03174"></a>03174   type = <a class="code" href="varobj_8c.html#adfcd4a24453cf037bb031b39a4a87051">get_value_type</a> (var);
<a name="l03175"></a>03175 
<a name="l03176"></a>03176   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l03177"></a>03177     {
<a name="l03178"></a>03178     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l03179"></a>03179     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>:
<a name="l03180"></a>03180     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>:
<a name="l03181"></a>03181       r = 0;
<a name="l03182"></a>03182       <span class="keywordflow">break</span>;
<a name="l03183"></a>03183 
<a name="l03184"></a>03184     <span class="keywordflow">default</span>:
<a name="l03185"></a>03185       r = 1;
<a name="l03186"></a>03186     }
<a name="l03187"></a>03187 
<a name="l03188"></a>03188   <span class="keywordflow">return</span> r;
<a name="l03189"></a>03189 }
<a name="l03190"></a>03190 
<a name="l03191"></a>03191 <span class="comment">/* C */</span>
<a name="l03192"></a>03192 
<a name="l03193"></a>03193 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03194"></a><a class="code" href="varobj_8c.html#a93be4a4467a71d4ae477004e046cd9c4">03194</a> <a class="code" href="varobj_8c.html#a93be4a4467a71d4ae477004e046cd9c4">c_number_of_children</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l03195"></a>03195 {
<a name="l03196"></a>03196   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = <a class="code" href="varobj_8c.html#adfcd4a24453cf037bb031b39a4a87051">get_value_type</a> (var);
<a name="l03197"></a>03197   <span class="keywordtype">int</span> children = 0;
<a name="l03198"></a>03198   <span class="keyword">struct </span>type *target;
<a name="l03199"></a>03199 
<a name="l03200"></a>03200   <a class="code" href="varobj_8c.html#a23aab7856e76fa75914b2f89d885e3ee">adjust_value_for_child_access</a> (NULL, &amp;type, NULL, 0);
<a name="l03201"></a>03201   target = <a class="code" href="varobj_8c.html#a85a491516094c4258b1fb5251108ac56">get_target_type</a> (type);
<a name="l03202"></a>03202 
<a name="l03203"></a>03203   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l03204"></a>03204     {
<a name="l03205"></a>03205     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>:
<a name="l03206"></a>03206       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) &gt; 0 &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (target) &gt; 0
<a name="l03207"></a>03207           &amp;&amp; !<a class="code" href="gdbtypes_8h.html#a54487ac042b1fcfca60cf43c158af526">TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED</a> (type))
<a name="l03208"></a>03208         children = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) / <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (target);
<a name="l03209"></a>03209       <span class="keywordflow">else</span>
<a name="l03210"></a>03210         <span class="comment">/* If we don&#39;t know how many elements there are, don&#39;t display</span>
<a name="l03211"></a>03211 <span class="comment">           any.  */</span>
<a name="l03212"></a>03212         children = 0;
<a name="l03213"></a>03213       <span class="keywordflow">break</span>;
<a name="l03214"></a>03214 
<a name="l03215"></a>03215     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l03216"></a>03216     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>:
<a name="l03217"></a>03217       children = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type);
<a name="l03218"></a>03218       <span class="keywordflow">break</span>;
<a name="l03219"></a>03219 
<a name="l03220"></a>03220     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>:
<a name="l03221"></a>03221       <span class="comment">/* The type here is a pointer to non-struct.  Typically, pointers</span>
<a name="l03222"></a>03222 <span class="comment">         have one child, except for function ptrs, which have no children,</span>
<a name="l03223"></a>03223 <span class="comment">         and except for void*, as we don&#39;t know what to show.</span>
<a name="l03224"></a>03224 <span class="comment"></span>
<a name="l03225"></a>03225 <span class="comment">         We can show char* so we allow it to be dereferenced.  If you decide</span>
<a name="l03226"></a>03226 <span class="comment">         to test for it, please mind that a little magic is necessary to</span>
<a name="l03227"></a>03227 <span class="comment">         properly identify it: char* has TYPE_CODE == TYPE_CODE_INT and </span>
<a name="l03228"></a>03228 <span class="comment">         TYPE_NAME == &quot;char&quot;.  */</span>
<a name="l03229"></a>03229       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (target) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>
<a name="l03230"></a>03230           || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (target) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>)
<a name="l03231"></a>03231         children = 0;
<a name="l03232"></a>03232       <span class="keywordflow">else</span>
<a name="l03233"></a>03233         children = 1;
<a name="l03234"></a>03234       <span class="keywordflow">break</span>;
<a name="l03235"></a>03235 
<a name="l03236"></a>03236     <span class="keywordflow">default</span>:
<a name="l03237"></a>03237       <span class="comment">/* Other types have no children.  */</span>
<a name="l03238"></a>03238       <span class="keywordflow">break</span>;
<a name="l03239"></a>03239     }
<a name="l03240"></a>03240 
<a name="l03241"></a>03241   <span class="keywordflow">return</span> children;
<a name="l03242"></a>03242 }
<a name="l03243"></a>03243 
<a name="l03244"></a>03244 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l03245"></a><a class="code" href="varobj_8c.html#a2bc7d2f38b881b4804eaa48689157f86">03245</a> <a class="code" href="varobj_8c.html#a2bc7d2f38b881b4804eaa48689157f86">c_name_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent)
<a name="l03246"></a>03246 {
<a name="l03247"></a>03247   <span class="keywordflow">return</span> xstrdup (parent-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>);
<a name="l03248"></a>03248 }
<a name="l03249"></a>03249 
<a name="l03250"></a>03250 <span class="comment">/* Return the value of element TYPE_INDEX of a structure</span>
<a name="l03251"></a>03251 <span class="comment">   value VALUE.  VALUE&#39;s type should be a structure,</span>
<a name="l03252"></a>03252 <span class="comment">   or union, or a typedef to struct/union.</span>
<a name="l03253"></a>03253 <span class="comment"></span>
<a name="l03254"></a>03254 <span class="comment">   Returns NULL if getting the value fails.  Never throws.  */</span>
<a name="l03255"></a>03255 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l03256"></a><a class="code" href="varobj_8c.html#ac132b95ff9b4b32e26fbb3d06b341086">03256</a> <a class="code" href="varobj_8c.html#ac132b95ff9b4b32e26fbb3d06b341086">value_struct_element_index</a> (<span class="keyword">struct</span> value *value, <span class="keywordtype">int</span> type_index)
<a name="l03257"></a>03257 {
<a name="l03258"></a>03258   <span class="keyword">struct </span>value *result = NULL;
<a name="l03259"></a>03259   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> e;
<a name="l03260"></a>03260   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (value);
<a name="l03261"></a>03261 
<a name="l03262"></a>03262   type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (type);
<a name="l03263"></a>03263 
<a name="l03264"></a>03264   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l03265"></a>03265               || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>);
<a name="l03266"></a>03266 
<a name="l03267"></a>03267   <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (e, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l03268"></a>03268     {
<a name="l03269"></a>03269       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#a38a5ce3cc244d3f0618908f9a7ceca62">field_is_static</a> (&amp;<a class="code" href="gdbtypes_8h.html#a8beaef20f443a0d98c7b445bbcfcf031">TYPE_FIELD</a> (type, type_index)))
<a name="l03270"></a>03270         result = <a class="code" href="value_8c.html#ad227db366076082564a611a5da413d8a">value_static_field</a> (type, type_index);
<a name="l03271"></a>03271       <span class="keywordflow">else</span>
<a name="l03272"></a>03272         result = <a class="code" href="value_8c.html#ac6e677d5cd8f7c40c20448fd7418b01c">value_primitive_field</a> (value, 0, type_index, type);
<a name="l03273"></a>03273     }
<a name="l03274"></a>03274   <span class="keywordflow">if</span> (e.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0)
<a name="l03275"></a>03275     {
<a name="l03276"></a>03276       <span class="keywordflow">return</span> NULL;
<a name="l03277"></a>03277     }
<a name="l03278"></a>03278   <span class="keywordflow">else</span>
<a name="l03279"></a>03279     {
<a name="l03280"></a>03280       <span class="keywordflow">return</span> result;
<a name="l03281"></a>03281     }
<a name="l03282"></a>03282 }
<a name="l03283"></a>03283 
<a name="l03284"></a>03284 <span class="comment">/* Obtain the information about child INDEX of the variable</span>
<a name="l03285"></a>03285 <span class="comment">   object PARENT.</span>
<a name="l03286"></a>03286 <span class="comment">   If CNAME is not null, sets *CNAME to the name of the child relative</span>
<a name="l03287"></a>03287 <span class="comment">   to the parent.</span>
<a name="l03288"></a>03288 <span class="comment">   If CVALUE is not null, sets *CVALUE to the value of the child.</span>
<a name="l03289"></a>03289 <span class="comment">   If CTYPE is not null, sets *CTYPE to the type of the child.</span>
<a name="l03290"></a>03290 <span class="comment"></span>
<a name="l03291"></a>03291 <span class="comment">   If any of CNAME, CVALUE, or CTYPE is not null, but the corresponding</span>
<a name="l03292"></a>03292 <span class="comment">   information cannot be determined, set *CNAME, *CVALUE, or *CTYPE</span>
<a name="l03293"></a>03293 <span class="comment">   to NULL.  */</span>
<a name="l03294"></a>03294 <span class="keyword">static</span> <span class="keywordtype">void</span> 
<a name="l03295"></a><a class="code" href="varobj_8c.html#a15d69cde24abd7098aade876e10c5639">03295</a> <a class="code" href="varobj_8c.html#a15d69cde24abd7098aade876e10c5639">c_describe_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index,
<a name="l03296"></a>03296                   <span class="keywordtype">char</span> **cname, <span class="keyword">struct</span> value **cvalue, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **ctype,
<a name="l03297"></a>03297                   <span class="keywordtype">char</span> **cfull_expression)
<a name="l03298"></a>03298 {
<a name="l03299"></a>03299   <span class="keyword">struct </span>value *value = parent-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>;
<a name="l03300"></a>03300   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = <a class="code" href="varobj_8c.html#adfcd4a24453cf037bb031b39a4a87051">get_value_type</a> (parent);
<a name="l03301"></a>03301   <span class="keywordtype">char</span> *parent_expression = NULL;
<a name="l03302"></a>03302   <span class="keywordtype">int</span> was_ptr;
<a name="l03303"></a>03303   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> except;
<a name="l03304"></a>03304 
<a name="l03305"></a>03305   <span class="keywordflow">if</span> (cname)
<a name="l03306"></a>03306     *cname = NULL;
<a name="l03307"></a>03307   <span class="keywordflow">if</span> (cvalue)
<a name="l03308"></a>03308     *cvalue = NULL;
<a name="l03309"></a>03309   <span class="keywordflow">if</span> (ctype)
<a name="l03310"></a>03310     *ctype = NULL;
<a name="l03311"></a>03311   <span class="keywordflow">if</span> (cfull_expression)
<a name="l03312"></a>03312     {
<a name="l03313"></a>03313       *cfull_expression = NULL;
<a name="l03314"></a>03314       parent_expression = <a class="code" href="varobj_8c.html#a2fc03eff6c70500f410ef940f05bbc06">varobj_get_path_expr</a> (<a class="code" href="varobj_8c.html#a3f79cdc2c6e352fcdc731099f1f73dee">get_path_expr_parent</a> (parent));
<a name="l03315"></a>03315     }
<a name="l03316"></a>03316   <a class="code" href="varobj_8c.html#a23aab7856e76fa75914b2f89d885e3ee">adjust_value_for_child_access</a> (&amp;value, &amp;type, &amp;was_ptr, 0);
<a name="l03317"></a>03317       
<a name="l03318"></a>03318   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l03319"></a>03319     {
<a name="l03320"></a>03320     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>:
<a name="l03321"></a>03321       <span class="keywordflow">if</span> (cname)
<a name="l03322"></a>03322         *cname
<a name="l03323"></a>03323           = xstrdup (<a class="code" href="utils_8c.html#a3ce8e8de91440036fe0ce3f1e00b5666">int_string</a> (index 
<a name="l03324"></a>03324                                  + <a class="code" href="gdbtypes_8h.html#a8a35064d1a955f191b0a63b03755689b">TYPE_LOW_BOUND</a> (<a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (type)),
<a name="l03325"></a>03325                                  10, 1, 0, 0));
<a name="l03326"></a>03326 
<a name="l03327"></a>03327       <span class="keywordflow">if</span> (cvalue &amp;&amp; value)
<a name="l03328"></a>03328         {
<a name="l03329"></a>03329           <span class="keywordtype">int</span> real_index = index + <a class="code" href="gdbtypes_8h.html#a8a35064d1a955f191b0a63b03755689b">TYPE_LOW_BOUND</a> (<a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (type));
<a name="l03330"></a>03330 
<a name="l03331"></a>03331           <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l03332"></a>03332             {
<a name="l03333"></a>03333               *cvalue = <a class="code" href="valarith_8c.html#a7d54cbfda0e6179b9e818951b91916d3">value_subscript</a> (value, real_index);
<a name="l03334"></a>03334             }
<a name="l03335"></a>03335         }
<a name="l03336"></a>03336 
<a name="l03337"></a>03337       <span class="keywordflow">if</span> (ctype)
<a name="l03338"></a>03338         *ctype = <a class="code" href="varobj_8c.html#a85a491516094c4258b1fb5251108ac56">get_target_type</a> (type);
<a name="l03339"></a>03339 
<a name="l03340"></a>03340       <span class="keywordflow">if</span> (cfull_expression)
<a name="l03341"></a>03341         *cfull_expression = 
<a name="l03342"></a>03342           <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;(%s)[%s]&quot;</span>, parent_expression, 
<a name="l03343"></a>03343                       <a class="code" href="utils_8c.html#a3ce8e8de91440036fe0ce3f1e00b5666">int_string</a> (index
<a name="l03344"></a>03344                                   + <a class="code" href="gdbtypes_8h.html#a8a35064d1a955f191b0a63b03755689b">TYPE_LOW_BOUND</a> (<a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (type)),
<a name="l03345"></a>03345                                   10, 1, 0, 0));
<a name="l03346"></a>03346 
<a name="l03347"></a>03347 
<a name="l03348"></a>03348       <span class="keywordflow">break</span>;
<a name="l03349"></a>03349 
<a name="l03350"></a>03350     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l03351"></a>03351     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>:
<a name="l03352"></a>03352       {
<a name="l03353"></a>03353         <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="py-type_8c.html#a1042b6e635f9f4eeca3f79047e2cf2c1">field_name</a>;
<a name="l03354"></a>03354 
<a name="l03355"></a>03355         <span class="comment">/* If the type is anonymous and the field has no name,</span>
<a name="l03356"></a>03356 <span class="comment">           set an appropriate name.  */</span>
<a name="l03357"></a>03357         field_name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, index);
<a name="l03358"></a>03358         <span class="keywordflow">if</span> (field_name == NULL || *field_name == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l03359"></a>03359           {
<a name="l03360"></a>03360             <span class="keywordflow">if</span> (cname)
<a name="l03361"></a>03361               {
<a name="l03362"></a>03362                 <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, index))
<a name="l03363"></a>03363                     == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>)
<a name="l03364"></a>03364                   *cname = xstrdup (<a class="code" href="varobj_8c.html#a1ded4c9d095bc960dfd094a418fe154e">ANONYMOUS_STRUCT_NAME</a>);
<a name="l03365"></a>03365                 <span class="keywordflow">else</span>
<a name="l03366"></a>03366                   *cname = xstrdup (<a class="code" href="varobj_8c.html#a291131d840192a1a42d0af2aa94f24bc">ANONYMOUS_UNION_NAME</a>);
<a name="l03367"></a>03367               }
<a name="l03368"></a>03368 
<a name="l03369"></a>03369             <span class="keywordflow">if</span> (cfull_expression)
<a name="l03370"></a>03370               *cfull_expression = xstrdup (<span class="stringliteral">&quot;&quot;</span>);
<a name="l03371"></a>03371           }
<a name="l03372"></a>03372         <span class="keywordflow">else</span>
<a name="l03373"></a>03373           {
<a name="l03374"></a>03374             <span class="keywordflow">if</span> (cname)
<a name="l03375"></a>03375               *cname = xstrdup (field_name);
<a name="l03376"></a>03376 
<a name="l03377"></a>03377             <span class="keywordflow">if</span> (cfull_expression)
<a name="l03378"></a>03378               {
<a name="l03379"></a>03379                 <span class="keywordtype">char</span> *join = was_ptr ? <span class="stringliteral">&quot;-&gt;&quot;</span> : <span class="stringliteral">&quot;.&quot;</span>;
<a name="l03380"></a>03380 
<a name="l03381"></a>03381                 *cfull_expression = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;(%s)%s%s&quot;</span>, parent_expression,
<a name="l03382"></a>03382                                                 join, field_name);
<a name="l03383"></a>03383               }
<a name="l03384"></a>03384           }
<a name="l03385"></a>03385 
<a name="l03386"></a>03386         <span class="keywordflow">if</span> (cvalue &amp;&amp; value)
<a name="l03387"></a>03387           {
<a name="l03388"></a>03388             <span class="comment">/* For C, varobj index is the same as type index.  */</span>
<a name="l03389"></a>03389             *cvalue = <a class="code" href="varobj_8c.html#ac132b95ff9b4b32e26fbb3d06b341086">value_struct_element_index</a> (value, index);
<a name="l03390"></a>03390           }
<a name="l03391"></a>03391 
<a name="l03392"></a>03392         <span class="keywordflow">if</span> (ctype)
<a name="l03393"></a>03393           *ctype = <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, index);
<a name="l03394"></a>03394       }
<a name="l03395"></a>03395       <span class="keywordflow">break</span>;
<a name="l03396"></a>03396 
<a name="l03397"></a>03397     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>:
<a name="l03398"></a>03398       <span class="keywordflow">if</span> (cname)
<a name="l03399"></a>03399         *cname = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;*%s&quot;</span>, parent-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>);
<a name="l03400"></a>03400 
<a name="l03401"></a>03401       <span class="keywordflow">if</span> (cvalue &amp;&amp; value)
<a name="l03402"></a>03402         {
<a name="l03403"></a>03403           <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l03404"></a>03404             {
<a name="l03405"></a>03405               *cvalue = <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (value);
<a name="l03406"></a>03406             }
<a name="l03407"></a>03407 
<a name="l03408"></a>03408           <span class="keywordflow">if</span> (except.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0)
<a name="l03409"></a>03409             *cvalue = NULL;
<a name="l03410"></a>03410         }
<a name="l03411"></a>03411 
<a name="l03412"></a>03412       <span class="comment">/* Don&#39;t use get_target_type because it calls</span>
<a name="l03413"></a>03413 <span class="comment">         check_typedef and here, we want to show the true</span>
<a name="l03414"></a>03414 <span class="comment">         declared type of the variable.  */</span>
<a name="l03415"></a>03415       <span class="keywordflow">if</span> (ctype)
<a name="l03416"></a>03416         *ctype = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l03417"></a>03417 
<a name="l03418"></a>03418       <span class="keywordflow">if</span> (cfull_expression)
<a name="l03419"></a>03419         *cfull_expression = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;*(%s)&quot;</span>, parent_expression);
<a name="l03420"></a>03420       
<a name="l03421"></a>03421       <span class="keywordflow">break</span>;
<a name="l03422"></a>03422 
<a name="l03423"></a>03423     <span class="keywordflow">default</span>:
<a name="l03424"></a>03424       <span class="comment">/* This should not happen.  */</span>
<a name="l03425"></a>03425       <span class="keywordflow">if</span> (cname)
<a name="l03426"></a>03426         *cname = xstrdup (<span class="stringliteral">&quot;???&quot;</span>);
<a name="l03427"></a>03427       <span class="keywordflow">if</span> (cfull_expression)
<a name="l03428"></a>03428         *cfull_expression = xstrdup (<span class="stringliteral">&quot;???&quot;</span>);
<a name="l03429"></a>03429       <span class="comment">/* Don&#39;t set value and type, we don&#39;t know then.  */</span>
<a name="l03430"></a>03430     }
<a name="l03431"></a>03431 }
<a name="l03432"></a>03432 
<a name="l03433"></a>03433 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l03434"></a><a class="code" href="varobj_8c.html#a523e2edf45a9d7224dd794e5b565eb9f">03434</a> <a class="code" href="varobj_8c.html#a523e2edf45a9d7224dd794e5b565eb9f">c_name_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index)
<a name="l03435"></a>03435 {
<a name="l03436"></a>03436   <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l03437"></a>03437 
<a name="l03438"></a>03438   <a class="code" href="varobj_8c.html#a15d69cde24abd7098aade876e10c5639">c_describe_child</a> (parent, index, &amp;name, NULL, NULL, NULL);
<a name="l03439"></a>03439   <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l03440"></a>03440 }
<a name="l03441"></a>03441 
<a name="l03442"></a>03442 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l03443"></a><a class="code" href="varobj_8c.html#a1677912a52e03718e5bbc35994d798c0">03443</a> <a class="code" href="varobj_8c.html#a1677912a52e03718e5bbc35994d798c0">c_path_expr_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *child)
<a name="l03444"></a>03444 {
<a name="l03445"></a>03445   <a class="code" href="varobj_8c.html#a15d69cde24abd7098aade876e10c5639">c_describe_child</a> (child-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>, child-&gt;<a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a>, NULL, NULL, NULL, 
<a name="l03446"></a>03446                     &amp;child-&gt;<a class="code" href="structvarobj.html#ab61f8b5cf72e56285b2c14a89aafc7ff">path_expr</a>);
<a name="l03447"></a>03447   <span class="keywordflow">return</span> child-&gt;<a class="code" href="structvarobj.html#ab61f8b5cf72e56285b2c14a89aafc7ff">path_expr</a>;
<a name="l03448"></a>03448 }
<a name="l03449"></a>03449 
<a name="l03450"></a>03450 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l03451"></a><a class="code" href="varobj_8c.html#a636a775a47d725845dc1789f239c38a3">03451</a> <a class="code" href="varobj_8c.html#a636a775a47d725845dc1789f239c38a3">c_value_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvalue.html#ac5784dc092188f21d4d2a0e041a8eeb8">parent</a>, <span class="keywordtype">int</span> index)
<a name="l03452"></a>03452 {
<a name="l03453"></a>03453   <span class="keyword">struct </span>value *value = NULL;
<a name="l03454"></a>03454 
<a name="l03455"></a>03455   <a class="code" href="varobj_8c.html#a15d69cde24abd7098aade876e10c5639">c_describe_child</a> (parent, index, NULL, &amp;value, NULL, NULL);
<a name="l03456"></a>03456   <span class="keywordflow">return</span> value;
<a name="l03457"></a>03457 }
<a name="l03458"></a>03458 
<a name="l03459"></a>03459 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l03460"></a><a class="code" href="varobj_8c.html#a3ebc9804af884141b5b629f44240474a">03460</a> <a class="code" href="varobj_8c.html#a3ebc9804af884141b5b629f44240474a">c_type_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index)
<a name="l03461"></a>03461 {
<a name="l03462"></a>03462   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = NULL;
<a name="l03463"></a>03463 
<a name="l03464"></a>03464   <a class="code" href="varobj_8c.html#a15d69cde24abd7098aade876e10c5639">c_describe_child</a> (parent, index, NULL, NULL, &amp;type, NULL);
<a name="l03465"></a>03465   <span class="keywordflow">return</span> <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l03466"></a>03466 }
<a name="l03467"></a>03467 
<a name="l03468"></a>03468 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l03469"></a><a class="code" href="varobj_8c.html#afca0a4e2739302b7e3765b109534456b">03469</a> <a class="code" href="varobj_8c.html#afca0a4e2739302b7e3765b109534456b">c_value_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format)
<a name="l03470"></a>03470 {
<a name="l03471"></a>03471   <span class="comment">/* BOGUS: if val_print sees a struct/class, or a reference to one,</span>
<a name="l03472"></a>03472 <span class="comment">     it will print out its children instead of &quot;{...}&quot;.  So we need to</span>
<a name="l03473"></a>03473 <span class="comment">     catch that case explicitly.  */</span>
<a name="l03474"></a>03474   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = <a class="code" href="varobj_8c.html#a5baa378edebe1c85afe1e15b83cb7036">get_type</a> (var);
<a name="l03475"></a>03475 
<a name="l03476"></a>03476   <span class="comment">/* Strip top-level references.  */</span>
<a name="l03477"></a>03477   <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l03478"></a>03478     type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type));
<a name="l03479"></a>03479 
<a name="l03480"></a>03480   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l03481"></a>03481     {
<a name="l03482"></a>03482     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l03483"></a>03483     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>:
<a name="l03484"></a>03484       <span class="keywordflow">return</span> xstrdup (<span class="stringliteral">&quot;{...}&quot;</span>);
<a name="l03485"></a>03485       <span class="comment">/* break; */</span>
<a name="l03486"></a>03486 
<a name="l03487"></a>03487     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>:
<a name="l03488"></a>03488       {
<a name="l03489"></a>03489         <span class="keywordtype">char</span> *number;
<a name="l03490"></a>03490 
<a name="l03491"></a>03491         number = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;[%d]&quot;</span>, var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a>);
<a name="l03492"></a>03492         <span class="keywordflow">return</span> (number);
<a name="l03493"></a>03493       }
<a name="l03494"></a>03494       <span class="comment">/* break; */</span>
<a name="l03495"></a>03495 
<a name="l03496"></a>03496     <span class="keywordflow">default</span>:
<a name="l03497"></a>03497       {
<a name="l03498"></a>03498         <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a> == NULL)
<a name="l03499"></a>03499           {
<a name="l03500"></a>03500             <span class="comment">/* This can happen if we attempt to get the value of a struct</span>
<a name="l03501"></a>03501 <span class="comment">               member when the parent is an invalid pointer.  This is an</span>
<a name="l03502"></a>03502 <span class="comment">               error condition, so we should tell the caller.  */</span>
<a name="l03503"></a>03503             <span class="keywordflow">return</span> NULL;
<a name="l03504"></a>03504           }
<a name="l03505"></a>03505         <span class="keywordflow">else</span>
<a name="l03506"></a>03506           {
<a name="l03507"></a>03507             <span class="keywordflow">if</span> (var-&gt;not_fetched &amp;&amp; <a class="code" href="value_8c.html#aa60bc8ecf77867a2d16bec57a4ccf983">value_lazy</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>))
<a name="l03508"></a>03508               <span class="comment">/* Frozen variable and no value yet.  We don&#39;t</span>
<a name="l03509"></a>03509 <span class="comment">                 implicitly fetch the value.  MI response will</span>
<a name="l03510"></a>03510 <span class="comment">                 use empty string for the value, which is OK.  */</span>
<a name="l03511"></a>03511               <span class="keywordflow">return</span> NULL;
<a name="l03512"></a>03512 
<a name="l03513"></a>03513             <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="varobj_8c.html#a176f5fae4079ee6acd5df422bd0e8f4c">varobj_value_is_changeable_p</a> (var));
<a name="l03514"></a>03514             <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!<a class="code" href="value_8c.html#aa60bc8ecf77867a2d16bec57a4ccf983">value_lazy</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>));
<a name="l03515"></a>03515             
<a name="l03516"></a>03516             <span class="comment">/* If the specified format is the current one,</span>
<a name="l03517"></a>03517 <span class="comment">               we can reuse print_value.  */</span>
<a name="l03518"></a>03518             <span class="keywordflow">if</span> (format == var-&gt;format)
<a name="l03519"></a>03519               <span class="keywordflow">return</span> xstrdup (var-&gt;print_value);
<a name="l03520"></a>03520             <span class="keywordflow">else</span>
<a name="l03521"></a>03521               <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#a371cbd65da3254826f01cbf5fd49380c">value_get_print_value</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>, format, var);
<a name="l03522"></a>03522           }
<a name="l03523"></a>03523       }
<a name="l03524"></a>03524     }
<a name="l03525"></a>03525 }
<a name="l03526"></a>03526 
<a name="l03527"></a>03527 
<a name="l03528"></a>03528 <span class="comment">/* C++ */</span>
<a name="l03529"></a>03529 
<a name="l03530"></a>03530 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03531"></a><a class="code" href="varobj_8c.html#a4d07d53309859f9d2ed11280ac02bca2">03531</a> <a class="code" href="varobj_8c.html#a4d07d53309859f9d2ed11280ac02bca2">cplus_number_of_children</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l03532"></a>03532 {
<a name="l03533"></a>03533   <span class="keyword">struct </span>value *value = NULL;
<a name="l03534"></a>03534   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l03535"></a>03535   <span class="keywordtype">int</span> children, dont_know;
<a name="l03536"></a>03536   <span class="keywordtype">int</span> lookup_actual_type = 0;
<a name="l03537"></a>03537   <span class="keyword">struct </span><a class="code" href="structvalue__print__options.html">value_print_options</a> opts;
<a name="l03538"></a>03538 
<a name="l03539"></a>03539   dont_know = 1;
<a name="l03540"></a>03540   children = 0;
<a name="l03541"></a>03541 
<a name="l03542"></a>03542   <a class="code" href="valprint_8c.html#aa2d4dfe4b11841ccafc4d0c0d410095d">get_user_print_options</a> (&amp;opts);
<a name="l03543"></a>03543 
<a name="l03544"></a>03544   <span class="keywordflow">if</span> (!<a class="code" href="varobj_8c.html#a0af68d4c2837464c18ae1eb457749c7d">CPLUS_FAKE_CHILD</a> (var))
<a name="l03545"></a>03545     {
<a name="l03546"></a>03546       type = <a class="code" href="varobj_8c.html#adfcd4a24453cf037bb031b39a4a87051">get_value_type</a> (var);
<a name="l03547"></a>03547 
<a name="l03548"></a>03548       <span class="comment">/* It is necessary to access a real type (via RTTI).  */</span>
<a name="l03549"></a>03549       <span class="keywordflow">if</span> (opts.<a class="code" href="structvalue__print__options.html#a57721e2ef5660a31f4151ec00d831b13">objectprint</a>)
<a name="l03550"></a>03550         {
<a name="l03551"></a>03551           value = var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>;
<a name="l03552"></a>03552           lookup_actual_type = (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>
<a name="l03553"></a>03553                                 || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>);
<a name="l03554"></a>03554         }
<a name="l03555"></a>03555       <a class="code" href="varobj_8c.html#a23aab7856e76fa75914b2f89d885e3ee">adjust_value_for_child_access</a> (&amp;value, &amp;type, NULL, lookup_actual_type);
<a name="l03556"></a>03556 
<a name="l03557"></a>03557       <span class="keywordflow">if</span> (((<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>) ||
<a name="l03558"></a>03558           ((<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>))
<a name="l03559"></a>03559         {
<a name="l03560"></a>03560           <span class="keywordtype">int</span> kids[3];
<a name="l03561"></a>03561 
<a name="l03562"></a>03562           <a class="code" href="varobj_8c.html#a50fade750b99399700ac5cd7b8f323b7">cplus_class_num_children</a> (type, kids);
<a name="l03563"></a>03563           <span class="keywordflow">if</span> (kids[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984aded822271e6e2ca89807fc505617d2d4">v_public</a>] != 0)
<a name="l03564"></a>03564             children++;
<a name="l03565"></a>03565           <span class="keywordflow">if</span> (kids[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984ab64e583fec7c654b8870660c15d7fefa">v_private</a>] != 0)
<a name="l03566"></a>03566             children++;
<a name="l03567"></a>03567           <span class="keywordflow">if</span> (kids[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984a1ac503b9138f4438afe3faf53fd55311">v_protected</a>] != 0)
<a name="l03568"></a>03568             children++;
<a name="l03569"></a>03569 
<a name="l03570"></a>03570           <span class="comment">/* Add any baseclasses.  */</span>
<a name="l03571"></a>03571           children += <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (type);
<a name="l03572"></a>03572           dont_know = 0;
<a name="l03573"></a>03573 
<a name="l03574"></a>03574           <span class="comment">/* FIXME: save children in var.  */</span>
<a name="l03575"></a>03575         }
<a name="l03576"></a>03576     }
<a name="l03577"></a>03577   <span class="keywordflow">else</span>
<a name="l03578"></a>03578     {
<a name="l03579"></a>03579       <span class="keywordtype">int</span> kids[3];
<a name="l03580"></a>03580 
<a name="l03581"></a>03581       type = <a class="code" href="varobj_8c.html#adfcd4a24453cf037bb031b39a4a87051">get_value_type</a> (var-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>);
<a name="l03582"></a>03582 
<a name="l03583"></a>03583       <span class="comment">/* It is necessary to access a real type (via RTTI).  */</span>
<a name="l03584"></a>03584       <span class="keywordflow">if</span> (opts.<a class="code" href="structvalue__print__options.html#a57721e2ef5660a31f4151ec00d831b13">objectprint</a>)
<a name="l03585"></a>03585         {
<a name="l03586"></a>03586           <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a> = var-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>;
<a name="l03587"></a>03587 
<a name="l03588"></a>03588           value = parent-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>;
<a name="l03589"></a>03589           lookup_actual_type = (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>
<a name="l03590"></a>03590                                 || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>);
<a name="l03591"></a>03591         }
<a name="l03592"></a>03592       <a class="code" href="varobj_8c.html#a23aab7856e76fa75914b2f89d885e3ee">adjust_value_for_child_access</a> (&amp;value, &amp;type, NULL, lookup_actual_type);
<a name="l03593"></a>03593 
<a name="l03594"></a>03594       <a class="code" href="varobj_8c.html#a50fade750b99399700ac5cd7b8f323b7">cplus_class_num_children</a> (type, kids);
<a name="l03595"></a>03595       <span class="keywordflow">if</span> (strcmp (var-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>, <span class="stringliteral">&quot;public&quot;</span>) == 0)
<a name="l03596"></a>03596         children = kids[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984aded822271e6e2ca89807fc505617d2d4">v_public</a>];
<a name="l03597"></a>03597       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (var-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>, <span class="stringliteral">&quot;private&quot;</span>) == 0)
<a name="l03598"></a>03598         children = kids[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984ab64e583fec7c654b8870660c15d7fefa">v_private</a>];
<a name="l03599"></a>03599       <span class="keywordflow">else</span>
<a name="l03600"></a>03600         children = kids[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984a1ac503b9138f4438afe3faf53fd55311">v_protected</a>];
<a name="l03601"></a>03601       dont_know = 0;
<a name="l03602"></a>03602     }
<a name="l03603"></a>03603 
<a name="l03604"></a>03604   <span class="keywordflow">if</span> (dont_know)
<a name="l03605"></a>03605     children = <a class="code" href="varobj_8c.html#a93be4a4467a71d4ae477004e046cd9c4">c_number_of_children</a> (var);
<a name="l03606"></a>03606 
<a name="l03607"></a>03607   <span class="keywordflow">return</span> children;
<a name="l03608"></a>03608 }
<a name="l03609"></a>03609 
<a name="l03610"></a>03610 <span class="comment">/* Compute # of public, private, and protected variables in this class.</span>
<a name="l03611"></a>03611 <span class="comment">   That means we need to descend into all baseclasses and find out</span>
<a name="l03612"></a>03612 <span class="comment">   how many are there, too.  */</span>
<a name="l03613"></a>03613 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03614"></a><a class="code" href="varobj_8c.html#a50fade750b99399700ac5cd7b8f323b7">03614</a> <a class="code" href="varobj_8c.html#a50fade750b99399700ac5cd7b8f323b7">cplus_class_num_children</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keywordtype">int</span> children[3])
<a name="l03615"></a>03615 {
<a name="l03616"></a>03616   <span class="keywordtype">int</span> i, vptr_fieldno;
<a name="l03617"></a>03617   <span class="keyword">struct </span>type *basetype = NULL;
<a name="l03618"></a>03618 
<a name="l03619"></a>03619   children[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984aded822271e6e2ca89807fc505617d2d4">v_public</a>] = 0;
<a name="l03620"></a>03620   children[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984ab64e583fec7c654b8870660c15d7fefa">v_private</a>] = 0;
<a name="l03621"></a>03621   children[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984a1ac503b9138f4438afe3faf53fd55311">v_protected</a>] = 0;
<a name="l03622"></a>03622 
<a name="l03623"></a>03623   vptr_fieldno = <a class="code" href="gdbtypes_8c.html#ac29bc4d1a96b9275c1f4522d734fb14b">get_vptr_fieldno</a> (type, &amp;basetype);
<a name="l03624"></a>03624   <span class="keywordflow">for</span> (i = <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (type); i &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type); i++)
<a name="l03625"></a>03625     {
<a name="l03626"></a>03626       <span class="comment">/* If we have a virtual table pointer, omit it.  Even if virtual</span>
<a name="l03627"></a>03627 <span class="comment">         table pointers are not specifically marked in the debug info,</span>
<a name="l03628"></a>03628 <span class="comment">         they should be artificial.  */</span>
<a name="l03629"></a>03629       <span class="keywordflow">if</span> ((type == basetype &amp;&amp; i == vptr_fieldno)
<a name="l03630"></a>03630           || <a class="code" href="gdbtypes_8h.html#aa2bb2f58f95f604830c665368481946d">TYPE_FIELD_ARTIFICIAL</a> (type, i))
<a name="l03631"></a>03631         <span class="keywordflow">continue</span>;
<a name="l03632"></a>03632 
<a name="l03633"></a>03633       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aaecb2d14e5db468b2a0d30d80453fe76">TYPE_FIELD_PROTECTED</a> (type, i))
<a name="l03634"></a>03634         children[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984a1ac503b9138f4438afe3faf53fd55311">v_protected</a>]++;
<a name="l03635"></a>03635       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#ae0f6510d214ef484caa50da98e4de773">TYPE_FIELD_PRIVATE</a> (type, i))
<a name="l03636"></a>03636         children[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984ab64e583fec7c654b8870660c15d7fefa">v_private</a>]++;
<a name="l03637"></a>03637       <span class="keywordflow">else</span>
<a name="l03638"></a>03638         children[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984aded822271e6e2ca89807fc505617d2d4">v_public</a>]++;
<a name="l03639"></a>03639     }
<a name="l03640"></a>03640 }
<a name="l03641"></a>03641 
<a name="l03642"></a>03642 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l03643"></a><a class="code" href="varobj_8c.html#abad2466059754f7294840f7443314f28">03643</a> <a class="code" href="varobj_8c.html#abad2466059754f7294840f7443314f28">cplus_name_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent)
<a name="l03644"></a>03644 {
<a name="l03645"></a>03645   <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#a2bc7d2f38b881b4804eaa48689157f86">c_name_of_variable</a> (parent);
<a name="l03646"></a>03646 }
<a name="l03647"></a>03647 
<a name="l03648"></a><a class="code" href="varobj_8c.html#aae8d404a2a5336a8518d8bbe132a8cafa9b6b344fbbd0c6f68e70b3cd6e97687a">03648</a> <span class="keyword">enum</span> <a class="code" href="varobj_8c.html#aae8d404a2a5336a8518d8bbe132a8caf">accessibility</a> { <a class="code" href="varobj_8c.html#aae8d404a2a5336a8518d8bbe132a8cafaa7990013ac12e25e65ed04595efdaec9">private_field</a>, <a class="code" href="varobj_8c.html#aae8d404a2a5336a8518d8bbe132a8cafa34b9d04b9879a649b426d9ee4f70389c">protected_field</a>, <a class="code" href="varobj_8c.html#aae8d404a2a5336a8518d8bbe132a8cafa9b6b344fbbd0c6f68e70b3cd6e97687a">public_field</a> };
<a name="l03649"></a>03649 
<a name="l03650"></a>03650 <span class="comment">/* Check if field INDEX of TYPE has the specified accessibility.</span>
<a name="l03651"></a>03651 <span class="comment">   Return 0 if so and 1 otherwise.  */</span>
<a name="l03652"></a>03652 <span class="keyword">static</span> <span class="keywordtype">int</span> 
<a name="l03653"></a><a class="code" href="varobj_8c.html#af8b0c7bd620949b5b979a3707a8632cf">03653</a> <a class="code" href="varobj_8c.html#af8b0c7bd620949b5b979a3707a8632cf">match_accessibility</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keywordtype">int</span> index, <span class="keyword">enum</span> <a class="code" href="varobj_8c.html#aae8d404a2a5336a8518d8bbe132a8caf">accessibility</a> acc)
<a name="l03654"></a>03654 {
<a name="l03655"></a>03655   <span class="keywordflow">if</span> (acc == <a class="code" href="varobj_8c.html#aae8d404a2a5336a8518d8bbe132a8cafaa7990013ac12e25e65ed04595efdaec9">private_field</a> &amp;&amp; <a class="code" href="gdbtypes_8h.html#ae0f6510d214ef484caa50da98e4de773">TYPE_FIELD_PRIVATE</a> (type, index))
<a name="l03656"></a>03656     <span class="keywordflow">return</span> 1;
<a name="l03657"></a>03657   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (acc == <a class="code" href="varobj_8c.html#aae8d404a2a5336a8518d8bbe132a8cafa34b9d04b9879a649b426d9ee4f70389c">protected_field</a> &amp;&amp; <a class="code" href="gdbtypes_8h.html#aaecb2d14e5db468b2a0d30d80453fe76">TYPE_FIELD_PROTECTED</a> (type, index))
<a name="l03658"></a>03658     <span class="keywordflow">return</span> 1;
<a name="l03659"></a>03659   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (acc == <a class="code" href="varobj_8c.html#aae8d404a2a5336a8518d8bbe132a8cafa9b6b344fbbd0c6f68e70b3cd6e97687a">public_field</a> &amp;&amp; !<a class="code" href="gdbtypes_8h.html#ae0f6510d214ef484caa50da98e4de773">TYPE_FIELD_PRIVATE</a> (type, index)
<a name="l03660"></a>03660            &amp;&amp; !<a class="code" href="gdbtypes_8h.html#aaecb2d14e5db468b2a0d30d80453fe76">TYPE_FIELD_PROTECTED</a> (type, index))
<a name="l03661"></a>03661     <span class="keywordflow">return</span> 1;
<a name="l03662"></a>03662   <span class="keywordflow">else</span>
<a name="l03663"></a>03663     <span class="keywordflow">return</span> 0;
<a name="l03664"></a>03664 }
<a name="l03665"></a>03665 
<a name="l03666"></a>03666 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03667"></a><a class="code" href="varobj_8c.html#a6b3eb49d02aec923b3a74f79fc4c77a7">03667</a> <a class="code" href="varobj_8c.html#a6b3eb49d02aec923b3a74f79fc4c77a7">cplus_describe_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index,
<a name="l03668"></a>03668                       <span class="keywordtype">char</span> **cname, <span class="keyword">struct</span> value **cvalue, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **ctype,
<a name="l03669"></a>03669                       <span class="keywordtype">char</span> **cfull_expression)
<a name="l03670"></a>03670 {
<a name="l03671"></a>03671   <span class="keyword">struct </span>value *value;
<a name="l03672"></a>03672   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l03673"></a>03673   <span class="keywordtype">int</span> was_ptr;
<a name="l03674"></a>03674   <span class="keywordtype">int</span> lookup_actual_type = 0;
<a name="l03675"></a>03675   <span class="keywordtype">char</span> *parent_expression = NULL;
<a name="l03676"></a>03676   <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *var;
<a name="l03677"></a>03677   <span class="keyword">struct </span><a class="code" href="structvalue__print__options.html">value_print_options</a> opts;
<a name="l03678"></a>03678 
<a name="l03679"></a>03679   <span class="keywordflow">if</span> (cname)
<a name="l03680"></a>03680     *cname = NULL;
<a name="l03681"></a>03681   <span class="keywordflow">if</span> (cvalue)
<a name="l03682"></a>03682     *cvalue = NULL;
<a name="l03683"></a>03683   <span class="keywordflow">if</span> (ctype)
<a name="l03684"></a>03684     *ctype = NULL;
<a name="l03685"></a>03685   <span class="keywordflow">if</span> (cfull_expression)
<a name="l03686"></a>03686     *cfull_expression = NULL;
<a name="l03687"></a>03687 
<a name="l03688"></a>03688   <a class="code" href="valprint_8c.html#aa2d4dfe4b11841ccafc4d0c0d410095d">get_user_print_options</a> (&amp;opts);
<a name="l03689"></a>03689 
<a name="l03690"></a>03690   var = (<a class="code" href="varobj_8c.html#a0af68d4c2837464c18ae1eb457749c7d">CPLUS_FAKE_CHILD</a> (parent)) ? parent-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a> : parent;
<a name="l03691"></a>03691   if (opts.<a class="code" href="structvalue__print__options.html#a57721e2ef5660a31f4151ec00d831b13">objectprint</a>)
<a name="l03692"></a>03692     lookup_actual_type = (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>
<a name="l03693"></a>03693                           || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>);
<a name="l03694"></a>03694   value = var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>;
<a name="l03695"></a>03695   type = <a class="code" href="varobj_8c.html#adfcd4a24453cf037bb031b39a4a87051">get_value_type</a> (var);
<a name="l03696"></a>03696   <span class="keywordflow">if</span> (cfull_expression)
<a name="l03697"></a>03697     parent_expression = <a class="code" href="varobj_8c.html#a2fc03eff6c70500f410ef940f05bbc06">varobj_get_path_expr</a> (<a class="code" href="varobj_8c.html#a3f79cdc2c6e352fcdc731099f1f73dee">get_path_expr_parent</a> (var));
<a name="l03698"></a>03698 
<a name="l03699"></a>03699   <a class="code" href="varobj_8c.html#a23aab7856e76fa75914b2f89d885e3ee">adjust_value_for_child_access</a> (&amp;value, &amp;type, &amp;was_ptr, lookup_actual_type);
<a name="l03700"></a>03700 
<a name="l03701"></a>03701   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l03702"></a>03702       || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l03703"></a>03703     {
<a name="l03704"></a>03704       <span class="keywordtype">char</span> *join = was_ptr ? <span class="stringliteral">&quot;-&gt;&quot;</span> : <span class="stringliteral">&quot;.&quot;</span>;
<a name="l03705"></a>03705 
<a name="l03706"></a>03706       <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a0af68d4c2837464c18ae1eb457749c7d">CPLUS_FAKE_CHILD</a> (parent))
<a name="l03707"></a>03707         {
<a name="l03708"></a>03708           <span class="comment">/* The fields of the class type are ordered as they</span>
<a name="l03709"></a>03709 <span class="comment">             appear in the class.  We are given an index for a</span>
<a name="l03710"></a>03710 <span class="comment">             particular access control type (&quot;public&quot;,&quot;protected&quot;,</span>
<a name="l03711"></a>03711 <span class="comment">             or &quot;private&quot;).  We must skip over fields that don&#39;t</span>
<a name="l03712"></a>03712 <span class="comment">             have the access control we are looking for to properly</span>
<a name="l03713"></a>03713 <span class="comment">             find the indexed field.  */</span>
<a name="l03714"></a>03714           <span class="keywordtype">int</span> type_index = <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (type);
<a name="l03715"></a>03715           <span class="keyword">enum</span> <a class="code" href="varobj_8c.html#aae8d404a2a5336a8518d8bbe132a8caf">accessibility</a> acc = <a class="code" href="varobj_8c.html#aae8d404a2a5336a8518d8bbe132a8cafa9b6b344fbbd0c6f68e70b3cd6e97687a">public_field</a>;
<a name="l03716"></a>03716           <span class="keywordtype">int</span> vptr_fieldno;
<a name="l03717"></a>03717           <span class="keyword">struct </span>type *basetype = NULL;
<a name="l03718"></a>03718           <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="py-type_8c.html#a1042b6e635f9f4eeca3f79047e2cf2c1">field_name</a>;
<a name="l03719"></a>03719 
<a name="l03720"></a>03720           vptr_fieldno = <a class="code" href="gdbtypes_8c.html#ac29bc4d1a96b9275c1f4522d734fb14b">get_vptr_fieldno</a> (type, &amp;basetype);
<a name="l03721"></a>03721           <span class="keywordflow">if</span> (strcmp (parent-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>, <span class="stringliteral">&quot;private&quot;</span>) == 0)
<a name="l03722"></a>03722             acc = <a class="code" href="varobj_8c.html#aae8d404a2a5336a8518d8bbe132a8cafaa7990013ac12e25e65ed04595efdaec9">private_field</a>;
<a name="l03723"></a>03723           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (parent-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>, <span class="stringliteral">&quot;protected&quot;</span>) == 0)
<a name="l03724"></a>03724             acc = <a class="code" href="varobj_8c.html#aae8d404a2a5336a8518d8bbe132a8cafa34b9d04b9879a649b426d9ee4f70389c">protected_field</a>;
<a name="l03725"></a>03725 
<a name="l03726"></a>03726           <span class="keywordflow">while</span> (index &gt;= 0)
<a name="l03727"></a>03727             {
<a name="l03728"></a>03728               <span class="keywordflow">if</span> ((type == basetype &amp;&amp; type_index == vptr_fieldno)
<a name="l03729"></a>03729                   || <a class="code" href="gdbtypes_8h.html#aa2bb2f58f95f604830c665368481946d">TYPE_FIELD_ARTIFICIAL</a> (type, type_index))
<a name="l03730"></a>03730                 ; <span class="comment">/* ignore vptr */</span>
<a name="l03731"></a>03731               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#af8b0c7bd620949b5b979a3707a8632cf">match_accessibility</a> (type, type_index, acc))
<a name="l03732"></a>03732                     --index;
<a name="l03733"></a>03733                   ++type_index;
<a name="l03734"></a>03734             }
<a name="l03735"></a>03735           --type_index;
<a name="l03736"></a>03736 
<a name="l03737"></a>03737           <span class="comment">/* If the type is anonymous and the field has no name,</span>
<a name="l03738"></a>03738 <span class="comment">             set an appopriate name.  */</span>
<a name="l03739"></a>03739           field_name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, type_index);
<a name="l03740"></a>03740           <span class="keywordflow">if</span> (field_name == NULL || *field_name == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l03741"></a>03741             {
<a name="l03742"></a>03742               <span class="keywordflow">if</span> (cname)
<a name="l03743"></a>03743                 {
<a name="l03744"></a>03744                   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, type_index))
<a name="l03745"></a>03745                       == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>)
<a name="l03746"></a>03746                     *cname = xstrdup (<a class="code" href="varobj_8c.html#a1ded4c9d095bc960dfd094a418fe154e">ANONYMOUS_STRUCT_NAME</a>);
<a name="l03747"></a>03747                   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, type_index))
<a name="l03748"></a>03748                            == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l03749"></a>03749                     *cname = xstrdup (<a class="code" href="varobj_8c.html#a291131d840192a1a42d0af2aa94f24bc">ANONYMOUS_UNION_NAME</a>);
<a name="l03750"></a>03750                 }
<a name="l03751"></a>03751 
<a name="l03752"></a>03752               <span class="keywordflow">if</span> (cfull_expression)
<a name="l03753"></a>03753                 *cfull_expression = xstrdup (<span class="stringliteral">&quot;&quot;</span>);
<a name="l03754"></a>03754             }
<a name="l03755"></a>03755           <span class="keywordflow">else</span>
<a name="l03756"></a>03756             {
<a name="l03757"></a>03757               <span class="keywordflow">if</span> (cname)
<a name="l03758"></a>03758                 *cname = xstrdup (<a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, type_index));
<a name="l03759"></a>03759 
<a name="l03760"></a>03760               <span class="keywordflow">if</span> (cfull_expression)
<a name="l03761"></a>03761                 *cfull_expression
<a name="l03762"></a>03762                   = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;((%s)%s%s)&quot;</span>, parent_expression, join,
<a name="l03763"></a>03763                                 field_name);
<a name="l03764"></a>03764             }
<a name="l03765"></a>03765 
<a name="l03766"></a>03766           <span class="keywordflow">if</span> (cvalue &amp;&amp; value)
<a name="l03767"></a>03767             *cvalue = <a class="code" href="varobj_8c.html#ac132b95ff9b4b32e26fbb3d06b341086">value_struct_element_index</a> (value, type_index);
<a name="l03768"></a>03768 
<a name="l03769"></a>03769           <span class="keywordflow">if</span> (ctype)
<a name="l03770"></a>03770             *ctype = <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, type_index);
<a name="l03771"></a>03771         }
<a name="l03772"></a>03772       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (index &lt; <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (type))
<a name="l03773"></a>03773         {
<a name="l03774"></a>03774           <span class="comment">/* This is a baseclass.  */</span>
<a name="l03775"></a>03775           <span class="keywordflow">if</span> (cname)
<a name="l03776"></a>03776             *cname = xstrdup (<a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, index));
<a name="l03777"></a>03777 
<a name="l03778"></a>03778           <span class="keywordflow">if</span> (cvalue &amp;&amp; value)
<a name="l03779"></a>03779             *cvalue = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, index), value);
<a name="l03780"></a>03780 
<a name="l03781"></a>03781           <span class="keywordflow">if</span> (ctype)
<a name="l03782"></a>03782             {
<a name="l03783"></a>03783               *ctype = <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, index);
<a name="l03784"></a>03784             }
<a name="l03785"></a>03785 
<a name="l03786"></a>03786           <span class="keywordflow">if</span> (cfull_expression)
<a name="l03787"></a>03787             {
<a name="l03788"></a>03788               <span class="keywordtype">char</span> *ptr = was_ptr ? <span class="stringliteral">&quot;*&quot;</span> : <span class="stringliteral">&quot;&quot;</span>;
<a name="l03789"></a>03789 
<a name="l03790"></a>03790               <span class="comment">/* Cast the parent to the base&#39; type.  Note that in gdb,</span>
<a name="l03791"></a>03791 <span class="comment">                 expression like </span>
<a name="l03792"></a>03792 <span class="comment">                         (Base1)d</span>
<a name="l03793"></a>03793 <span class="comment">                 will create an lvalue, for all appearences, so we don&#39;t</span>
<a name="l03794"></a>03794 <span class="comment">                 need to use more fancy:</span>
<a name="l03795"></a>03795 <span class="comment">                         *(Base1*)(&amp;d)</span>
<a name="l03796"></a>03796 <span class="comment">                 construct.</span>
<a name="l03797"></a>03797 <span class="comment"></span>
<a name="l03798"></a>03798 <span class="comment">                 When we are in the scope of the base class or of one</span>
<a name="l03799"></a>03799 <span class="comment">                 of its children, the type field name will be interpreted</span>
<a name="l03800"></a>03800 <span class="comment">                 as a constructor, if it exists.  Therefore, we must</span>
<a name="l03801"></a>03801 <span class="comment">                 indicate that the name is a class name by using the</span>
<a name="l03802"></a>03802 <span class="comment">                 &#39;class&#39; keyword.  See PR mi/11912  */</span>
<a name="l03803"></a>03803               *cfull_expression = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;(%s(class %s%s) %s)&quot;</span>, 
<a name="l03804"></a>03804                                               ptr, 
<a name="l03805"></a>03805                                               <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, index),
<a name="l03806"></a>03806                                               ptr,
<a name="l03807"></a>03807                                               parent_expression);
<a name="l03808"></a>03808             }
<a name="l03809"></a>03809         }
<a name="l03810"></a>03810       <span class="keywordflow">else</span>
<a name="l03811"></a>03811         {
<a name="l03812"></a>03812           <span class="keywordtype">char</span> *access = NULL;
<a name="l03813"></a>03813           <span class="keywordtype">int</span> children[3];
<a name="l03814"></a>03814 
<a name="l03815"></a>03815           <a class="code" href="varobj_8c.html#a50fade750b99399700ac5cd7b8f323b7">cplus_class_num_children</a> (type, children);
<a name="l03816"></a>03816 
<a name="l03817"></a>03817           <span class="comment">/* Everything beyond the baseclasses can</span>
<a name="l03818"></a>03818 <span class="comment">             only be &quot;public&quot;, &quot;private&quot;, or &quot;protected&quot;</span>
<a name="l03819"></a>03819 <span class="comment"></span>
<a name="l03820"></a>03820 <span class="comment">             The special &quot;fake&quot; children are always output by varobj in</span>
<a name="l03821"></a>03821 <span class="comment">             this order.  So if INDEX == 2, it MUST be &quot;protected&quot;.  */</span>
<a name="l03822"></a>03822           index -= <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (type);
<a name="l03823"></a>03823           <span class="keywordflow">switch</span> (index)
<a name="l03824"></a>03824             {
<a name="l03825"></a>03825             <span class="keywordflow">case</span> 0:
<a name="l03826"></a>03826               <span class="keywordflow">if</span> (children[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984aded822271e6e2ca89807fc505617d2d4">v_public</a>] &gt; 0)
<a name="l03827"></a>03827                 access = <span class="stringliteral">&quot;public&quot;</span>;
<a name="l03828"></a>03828               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (children[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984ab64e583fec7c654b8870660c15d7fefa">v_private</a>] &gt; 0)
<a name="l03829"></a>03829                 access = <span class="stringliteral">&quot;private&quot;</span>;
<a name="l03830"></a>03830               <span class="keywordflow">else</span> 
<a name="l03831"></a>03831                 access = <span class="stringliteral">&quot;protected&quot;</span>;
<a name="l03832"></a>03832               <span class="keywordflow">break</span>;
<a name="l03833"></a>03833             <span class="keywordflow">case</span> 1:
<a name="l03834"></a>03834               <span class="keywordflow">if</span> (children[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984aded822271e6e2ca89807fc505617d2d4">v_public</a>] &gt; 0)
<a name="l03835"></a>03835                 {
<a name="l03836"></a>03836                   <span class="keywordflow">if</span> (children[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984ab64e583fec7c654b8870660c15d7fefa">v_private</a>] &gt; 0)
<a name="l03837"></a>03837                     access = <span class="stringliteral">&quot;private&quot;</span>;
<a name="l03838"></a>03838                   <span class="keywordflow">else</span>
<a name="l03839"></a>03839                     access = <span class="stringliteral">&quot;protected&quot;</span>;
<a name="l03840"></a>03840                 }
<a name="l03841"></a>03841               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (children[<a class="code" href="varobj_8c.html#a488335fe38f2d76430ddbd7997560984ab64e583fec7c654b8870660c15d7fefa">v_private</a>] &gt; 0)
<a name="l03842"></a>03842                 access = <span class="stringliteral">&quot;protected&quot;</span>;
<a name="l03843"></a>03843               <span class="keywordflow">break</span>;
<a name="l03844"></a>03844             <span class="keywordflow">case</span> 2:
<a name="l03845"></a>03845               <span class="comment">/* Must be protected.  */</span>
<a name="l03846"></a>03846               access = <span class="stringliteral">&quot;protected&quot;</span>;
<a name="l03847"></a>03847               <span class="keywordflow">break</span>;
<a name="l03848"></a>03848             <span class="keywordflow">default</span>:
<a name="l03849"></a>03849               <span class="comment">/* error!  */</span>
<a name="l03850"></a>03850               <span class="keywordflow">break</span>;
<a name="l03851"></a>03851             }
<a name="l03852"></a>03852 
<a name="l03853"></a>03853           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (access);
<a name="l03854"></a>03854           <span class="keywordflow">if</span> (cname)
<a name="l03855"></a>03855             *cname = xstrdup (access);
<a name="l03856"></a>03856 
<a name="l03857"></a>03857           <span class="comment">/* Value and type and full expression are null here.  */</span>
<a name="l03858"></a>03858         }
<a name="l03859"></a>03859     }
<a name="l03860"></a>03860   <span class="keywordflow">else</span>
<a name="l03861"></a>03861     {
<a name="l03862"></a>03862       <a class="code" href="varobj_8c.html#a15d69cde24abd7098aade876e10c5639">c_describe_child</a> (parent, index, cname, cvalue, ctype, cfull_expression);
<a name="l03863"></a>03863     }  
<a name="l03864"></a>03864 }
<a name="l03865"></a>03865 
<a name="l03866"></a>03866 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l03867"></a><a class="code" href="varobj_8c.html#aaff0d8a45eea54f86008630023672eed">03867</a> <a class="code" href="varobj_8c.html#aaff0d8a45eea54f86008630023672eed">cplus_name_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index)
<a name="l03868"></a>03868 {
<a name="l03869"></a>03869   <span class="keywordtype">char</span> *name = NULL;
<a name="l03870"></a>03870 
<a name="l03871"></a>03871   <a class="code" href="varobj_8c.html#a6b3eb49d02aec923b3a74f79fc4c77a7">cplus_describe_child</a> (parent, index, &amp;name, NULL, NULL, NULL);
<a name="l03872"></a>03872   <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l03873"></a>03873 }
<a name="l03874"></a>03874 
<a name="l03875"></a>03875 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l03876"></a><a class="code" href="varobj_8c.html#a6197ee374a6131e8b922143c68a77d2d">03876</a> <a class="code" href="varobj_8c.html#a6197ee374a6131e8b922143c68a77d2d">cplus_path_expr_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *child)
<a name="l03877"></a>03877 {
<a name="l03878"></a>03878   <a class="code" href="varobj_8c.html#a6b3eb49d02aec923b3a74f79fc4c77a7">cplus_describe_child</a> (child-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>, child-&gt;<a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a>, NULL, NULL, NULL, 
<a name="l03879"></a>03879                         &amp;child-&gt;<a class="code" href="structvarobj.html#ab61f8b5cf72e56285b2c14a89aafc7ff">path_expr</a>);
<a name="l03880"></a>03880   <span class="keywordflow">return</span> child-&gt;<a class="code" href="structvarobj.html#ab61f8b5cf72e56285b2c14a89aafc7ff">path_expr</a>;
<a name="l03881"></a>03881 }
<a name="l03882"></a>03882 
<a name="l03883"></a>03883 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l03884"></a><a class="code" href="varobj_8c.html#a09425460afc0835494e6ed80e3242f96">03884</a> <a class="code" href="varobj_8c.html#a09425460afc0835494e6ed80e3242f96">cplus_value_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvalue.html#ac5784dc092188f21d4d2a0e041a8eeb8">parent</a>, <span class="keywordtype">int</span> index)
<a name="l03885"></a>03885 {
<a name="l03886"></a>03886   <span class="keyword">struct </span>value *value = NULL;
<a name="l03887"></a>03887 
<a name="l03888"></a>03888   <a class="code" href="varobj_8c.html#a6b3eb49d02aec923b3a74f79fc4c77a7">cplus_describe_child</a> (parent, index, NULL, &amp;value, NULL, NULL);
<a name="l03889"></a>03889   <span class="keywordflow">return</span> value;
<a name="l03890"></a>03890 }
<a name="l03891"></a>03891 
<a name="l03892"></a>03892 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l03893"></a><a class="code" href="varobj_8c.html#abe513c2ef410c2f8ac7e47ac72fe63f2">03893</a> <a class="code" href="varobj_8c.html#abe513c2ef410c2f8ac7e47ac72fe63f2">cplus_type_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index)
<a name="l03894"></a>03894 {
<a name="l03895"></a>03895   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = NULL;
<a name="l03896"></a>03896 
<a name="l03897"></a>03897   <a class="code" href="varobj_8c.html#a6b3eb49d02aec923b3a74f79fc4c77a7">cplus_describe_child</a> (parent, index, NULL, NULL, &amp;type, NULL);
<a name="l03898"></a>03898   <span class="keywordflow">return</span> <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l03899"></a>03899 }
<a name="l03900"></a>03900 
<a name="l03901"></a>03901 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l03902"></a><a class="code" href="varobj_8c.html#a7c20f6a85a26760a76cd2c64fa7de576">03902</a> <a class="code" href="varobj_8c.html#a7c20f6a85a26760a76cd2c64fa7de576">cplus_value_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, 
<a name="l03903"></a>03903                          <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format)
<a name="l03904"></a>03904 {
<a name="l03905"></a>03905 
<a name="l03906"></a>03906   <span class="comment">/* If we have one of our special types, don&#39;t print out</span>
<a name="l03907"></a>03907 <span class="comment">     any value.  */</span>
<a name="l03908"></a>03908   <span class="keywordflow">if</span> (<a class="code" href="varobj_8c.html#a0af68d4c2837464c18ae1eb457749c7d">CPLUS_FAKE_CHILD</a> (var))
<a name="l03909"></a>03909     <span class="keywordflow">return</span> xstrdup (<span class="stringliteral">&quot;&quot;</span>);
<a name="l03910"></a>03910 
<a name="l03911"></a>03911   <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#afca0a4e2739302b7e3765b109534456b">c_value_of_variable</a> (var, format);
<a name="l03912"></a>03912 }
<a name="l03913"></a>03913 
<a name="l03914"></a>03914 <span class="comment">/* Java */</span>
<a name="l03915"></a>03915 
<a name="l03916"></a>03916 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03917"></a><a class="code" href="varobj_8c.html#ad63b2017cbb7326cd7932c7a8b3f58f0">03917</a> <a class="code" href="varobj_8c.html#ad63b2017cbb7326cd7932c7a8b3f58f0">java_number_of_children</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l03918"></a>03918 {
<a name="l03919"></a>03919   <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#a4d07d53309859f9d2ed11280ac02bca2">cplus_number_of_children</a> (var);
<a name="l03920"></a>03920 }
<a name="l03921"></a>03921 
<a name="l03922"></a>03922 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l03923"></a><a class="code" href="varobj_8c.html#a07b77d8926dd890a75fbac58048feeba">03923</a> <a class="code" href="varobj_8c.html#a07b77d8926dd890a75fbac58048feeba">java_name_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent)
<a name="l03924"></a>03924 {
<a name="l03925"></a>03925   <span class="keywordtype">char</span> *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>, *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l03926"></a>03926 
<a name="l03927"></a>03927   name = <a class="code" href="varobj_8c.html#abad2466059754f7294840f7443314f28">cplus_name_of_variable</a> (parent);
<a name="l03928"></a>03928   <span class="comment">/* If  the name has &quot;-&quot; in it, it is because we</span>
<a name="l03929"></a>03929 <span class="comment">     needed to escape periods in the name...  */</span>
<a name="l03930"></a>03930   p = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l03931"></a>03931 
<a name="l03932"></a>03932   <span class="keywordflow">while</span> (*p != <span class="charliteral">&#39;\000&#39;</span>)
<a name="l03933"></a>03933     {
<a name="l03934"></a>03934       <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39;-&#39;</span>)
<a name="l03935"></a>03935         *p = <span class="charliteral">&#39;.&#39;</span>;
<a name="l03936"></a>03936       p++;
<a name="l03937"></a>03937     }
<a name="l03938"></a>03938 
<a name="l03939"></a>03939   <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l03940"></a>03940 }
<a name="l03941"></a>03941 
<a name="l03942"></a>03942 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l03943"></a><a class="code" href="varobj_8c.html#a964e240730875329f131fc30a7c8cef5">03943</a> <a class="code" href="varobj_8c.html#a964e240730875329f131fc30a7c8cef5">java_name_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index)
<a name="l03944"></a>03944 {
<a name="l03945"></a>03945   <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>;
<a name="l03946"></a>03946 
<a name="l03947"></a>03947   name = <a class="code" href="varobj_8c.html#aaff0d8a45eea54f86008630023672eed">cplus_name_of_child</a> (parent, index);
<a name="l03948"></a>03948   <span class="comment">/* Escape any periods in the name...  */</span>
<a name="l03949"></a>03949   p = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l03950"></a>03950 
<a name="l03951"></a>03951   <span class="keywordflow">while</span> (*p != <span class="charliteral">&#39;\000&#39;</span>)
<a name="l03952"></a>03952     {
<a name="l03953"></a>03953       <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39;.&#39;</span>)
<a name="l03954"></a>03954         *p = <span class="charliteral">&#39;-&#39;</span>;
<a name="l03955"></a>03955       p++;
<a name="l03956"></a>03956     }
<a name="l03957"></a>03957 
<a name="l03958"></a>03958   <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l03959"></a>03959 }
<a name="l03960"></a>03960 
<a name="l03961"></a>03961 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l03962"></a><a class="code" href="varobj_8c.html#a706fb98989fdc56fe395dec277e4ec6b">03962</a> <a class="code" href="varobj_8c.html#a706fb98989fdc56fe395dec277e4ec6b">java_path_expr_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *child)
<a name="l03963"></a>03963 {
<a name="l03964"></a>03964   <span class="keywordflow">return</span> NULL;
<a name="l03965"></a>03965 }
<a name="l03966"></a>03966 
<a name="l03967"></a>03967 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l03968"></a><a class="code" href="varobj_8c.html#a72046d52de1c043aa0e32bd706ec1ff2">03968</a> <a class="code" href="varobj_8c.html#a72046d52de1c043aa0e32bd706ec1ff2">java_value_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvalue.html#ac5784dc092188f21d4d2a0e041a8eeb8">parent</a>, <span class="keywordtype">int</span> index)
<a name="l03969"></a>03969 {
<a name="l03970"></a>03970   <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#a09425460afc0835494e6ed80e3242f96">cplus_value_of_child</a> (parent, index);
<a name="l03971"></a>03971 }
<a name="l03972"></a>03972 
<a name="l03973"></a>03973 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l03974"></a><a class="code" href="varobj_8c.html#a90610da40cc2e3efa2b9068e2b346f73">03974</a> <a class="code" href="varobj_8c.html#a90610da40cc2e3efa2b9068e2b346f73">java_type_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index)
<a name="l03975"></a>03975 {
<a name="l03976"></a>03976   <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#abe513c2ef410c2f8ac7e47ac72fe63f2">cplus_type_of_child</a> (parent, index);
<a name="l03977"></a>03977 }
<a name="l03978"></a>03978 
<a name="l03979"></a>03979 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l03980"></a><a class="code" href="varobj_8c.html#a455f4af866f3640d08dec9bfe34f1788">03980</a> <a class="code" href="varobj_8c.html#a455f4af866f3640d08dec9bfe34f1788">java_value_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format)
<a name="l03981"></a>03981 {
<a name="l03982"></a>03982   <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#a7c20f6a85a26760a76cd2c64fa7de576">cplus_value_of_variable</a> (var, format);
<a name="l03983"></a>03983 }
<a name="l03984"></a>03984 
<a name="l03985"></a>03985 <span class="comment">/* Ada specific callbacks for VAROBJs.  */</span>
<a name="l03986"></a>03986 
<a name="l03987"></a>03987 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03988"></a><a class="code" href="varobj_8c.html#aeadc13ce28b31041f0e96a73d85307a5">03988</a> <a class="code" href="varobj_8c.html#aeadc13ce28b31041f0e96a73d85307a5">ada_number_of_children</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l03989"></a>03989 {
<a name="l03990"></a>03990   <span class="keywordflow">return</span> <a class="code" href="ada-varobj_8c.html#a8c77dcd297321f684638fc12196e3f25">ada_varobj_get_number_of_children</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>, var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>);
<a name="l03991"></a>03991 }
<a name="l03992"></a>03992 
<a name="l03993"></a>03993 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l03994"></a><a class="code" href="varobj_8c.html#ac67f2fc0cf079e0f0316d3276a6d710a">03994</a> <a class="code" href="varobj_8c.html#ac67f2fc0cf079e0f0316d3276a6d710a">ada_name_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent)
<a name="l03995"></a>03995 {
<a name="l03996"></a>03996   <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#a2bc7d2f38b881b4804eaa48689157f86">c_name_of_variable</a> (parent);
<a name="l03997"></a>03997 }
<a name="l03998"></a>03998 
<a name="l03999"></a>03999 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l04000"></a><a class="code" href="varobj_8c.html#a6ba428c3a41023df8391fd361826e58a">04000</a> <a class="code" href="varobj_8c.html#a6ba428c3a41023df8391fd361826e58a">ada_name_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index)
<a name="l04001"></a>04001 {
<a name="l04002"></a>04002   <span class="keywordflow">return</span> <a class="code" href="ada-varobj_8c.html#abb148477cda76581ccc494bb000624d8">ada_varobj_get_name_of_child</a> (parent-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>, parent-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>,
<a name="l04003"></a>04003                                        parent-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>, index);
<a name="l04004"></a>04004 }
<a name="l04005"></a>04005 
<a name="l04006"></a>04006 <span class="keyword">static</span> <span class="keywordtype">char</span>*
<a name="l04007"></a><a class="code" href="varobj_8c.html#a20ee53aa83e0d6303420eb92e484ee41">04007</a> <a class="code" href="varobj_8c.html#a20ee53aa83e0d6303420eb92e484ee41">ada_path_expr_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *child)
<a name="l04008"></a>04008 {
<a name="l04009"></a>04009   <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a> = child-&gt;<a class="code" href="structvarobj.html#ae88a5be679d060acea85f0b9c05279fe">parent</a>;
<a name="l04010"></a>04010   <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_path_expr = <a class="code" href="varobj_8c.html#a2fc03eff6c70500f410ef940f05bbc06">varobj_get_path_expr</a> (parent);
<a name="l04011"></a>04011 
<a name="l04012"></a>04012   <span class="keywordflow">return</span> <a class="code" href="ada-varobj_8c.html#a8124f346b33174f15fd041712bc2be57">ada_varobj_get_path_expr_of_child</a> (parent-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>,
<a name="l04013"></a>04013                                             parent-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>,
<a name="l04014"></a>04014                                             parent-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>,
<a name="l04015"></a>04015                                             parent_path_expr,
<a name="l04016"></a>04016                                             child-&gt;<a class="code" href="structvarobj.html#a35bd4026f5a8e423b0001f2275b66742">index</a>);
<a name="l04017"></a>04017 }
<a name="l04018"></a>04018 
<a name="l04019"></a>04019 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l04020"></a><a class="code" href="varobj_8c.html#ada56bb6b78f2b50b76b1fb7cd26a450f">04020</a> <a class="code" href="varobj_8c.html#ada56bb6b78f2b50b76b1fb7cd26a450f">ada_value_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *<a class="code" href="structvalue.html#ac5784dc092188f21d4d2a0e041a8eeb8">parent</a>, <span class="keywordtype">int</span> index)
<a name="l04021"></a>04021 {
<a name="l04022"></a>04022   <span class="keywordflow">return</span> <a class="code" href="ada-varobj_8c.html#a8ee908fde7b8689fe09edc3b714f1211">ada_varobj_get_value_of_child</a> (parent-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>, parent-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>,
<a name="l04023"></a>04023                                         parent-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>, index);
<a name="l04024"></a>04024 }
<a name="l04025"></a>04025 
<a name="l04026"></a>04026 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l04027"></a><a class="code" href="varobj_8c.html#afe0ad236431f504db5d4fbef9752d9fc">04027</a> <a class="code" href="varobj_8c.html#afe0ad236431f504db5d4fbef9752d9fc">ada_type_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *parent, <span class="keywordtype">int</span> index)
<a name="l04028"></a>04028 {
<a name="l04029"></a>04029   <span class="keywordflow">return</span> <a class="code" href="ada-varobj_8c.html#aa7831b9c200ae8b7acc6cc76aaa15845">ada_varobj_get_type_of_child</a> (parent-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>, parent-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>,
<a name="l04030"></a>04030                                        index);
<a name="l04031"></a>04031 }
<a name="l04032"></a>04032 
<a name="l04033"></a>04033 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l04034"></a><a class="code" href="varobj_8c.html#a9600d2bf586a6b5171f53189566b2386">04034</a> <a class="code" href="varobj_8c.html#a9600d2bf586a6b5171f53189566b2386">ada_value_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keyword">enum</span> <a class="code" href="varobj_8h.html#a09e5ca891b4a226bc62a9006f087b0bf">varobj_display_formats</a> format)
<a name="l04035"></a>04035 {
<a name="l04036"></a>04036   <span class="keyword">struct </span><a class="code" href="structvalue__print__options.html">value_print_options</a> opts;
<a name="l04037"></a>04037 
<a name="l04038"></a>04038   <a class="code" href="valprint_8c.html#a1177f66ae5a60db2a75604f268dba57f">get_formatted_print_options</a> (&amp;opts, <a class="code" href="varobj_8c.html#adc4d9de429cbfa905ad9962a7e4daf8e">format_code</a>[(<span class="keywordtype">int</span>) format]);
<a name="l04039"></a>04039   opts.<a class="code" href="structvalue__print__options.html#a60ebf7f26982bd56f13befa7ef7cc686">deref_ref</a> = 0;
<a name="l04040"></a>04040   opts.<a class="code" href="structvalue__print__options.html#a906b0433c8e9bad5a42fa6430026e8cc">raw</a> = 1;
<a name="l04041"></a>04041 
<a name="l04042"></a>04042   <span class="keywordflow">return</span> <a class="code" href="ada-varobj_8c.html#a877e7c58702364a66a5f4a71b14e88f9">ada_varobj_get_value_of_variable</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>, var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>, &amp;opts);
<a name="l04043"></a>04043 }
<a name="l04044"></a>04044 
<a name="l04045"></a>04045 <span class="comment">/* Implement the &quot;value_is_changeable_p&quot; routine for Ada.  */</span>
<a name="l04046"></a>04046 
<a name="l04047"></a>04047 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04048"></a><a class="code" href="varobj_8c.html#a0649356dd5db401f7860403e675526e9">04048</a> <a class="code" href="varobj_8c.html#a0649356dd5db401f7860403e675526e9">ada_value_is_changeable_p</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var)
<a name="l04049"></a>04049 {
<a name="l04050"></a>04050   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a> ? <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (var-&gt;<a class="code" href="structvarobj.html#a49211626aaacc99963cf33b998ee2816">value</a>) : var-&gt;<a class="code" href="structvarobj.html#ad1a0f639b6f315cdcd9f51feb512d4eb">type</a>;
<a name="l04051"></a>04051 
<a name="l04052"></a>04052   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (type)
<a name="l04053"></a>04053       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>)
<a name="l04054"></a>04054     {
<a name="l04055"></a>04055       <span class="comment">/* This is in reality a pointer to an unconstrained array.</span>
<a name="l04056"></a>04056 <span class="comment">         its value is changeable.  */</span>
<a name="l04057"></a>04057       <span class="keywordflow">return</span> 1;
<a name="l04058"></a>04058     }
<a name="l04059"></a>04059 
<a name="l04060"></a>04060   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a18f24b5d515fb07617cf7905f26d9067">ada_is_string_type</a> (type))
<a name="l04061"></a>04061     {
<a name="l04062"></a>04062       <span class="comment">/* We display the contents of the string in the array&#39;s</span>
<a name="l04063"></a>04063 <span class="comment">         &quot;value&quot; field.  The contents can change, so consider</span>
<a name="l04064"></a>04064 <span class="comment">         that the array is changeable.  */</span>
<a name="l04065"></a>04065       <span class="keywordflow">return</span> 1;
<a name="l04066"></a>04066     }
<a name="l04067"></a>04067 
<a name="l04068"></a>04068   <span class="keywordflow">return</span> <a class="code" href="varobj_8c.html#af62c3759117b3e5c21282af5feebf900">default_value_is_changeable_p</a> (var);
<a name="l04069"></a>04069 }
<a name="l04070"></a>04070 
<a name="l04071"></a>04071 <span class="comment">/* Implement the &quot;value_has_mutated&quot; routine for Ada.  */</span>
<a name="l04072"></a>04072 
<a name="l04073"></a>04073 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04074"></a><a class="code" href="varobj_8c.html#a74d9c9a183ca53bac1e660f541030e45">04074</a> <a class="code" href="varobj_8c.html#a74d9c9a183ca53bac1e660f541030e45">ada_value_has_mutated</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keyword">struct</span> value *new_val,
<a name="l04075"></a>04075                        <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="mdebugread_8c.html#ab1ece714ac6020a52b26279dfc1b20d7">new_type</a>)
<a name="l04076"></a>04076 {
<a name="l04077"></a>04077   <span class="keywordtype">int</span> i;
<a name="l04078"></a>04078   <span class="keywordtype">int</span> <a class="code" href="varobj_8h.html#a43396decd62b46fa01cc6c66a84cbba1">from</a> = -1;
<a name="l04079"></a>04079   <span class="keywordtype">int</span> <a class="code" href="varobj_8h.html#ae2a2635825813434f3201bf8ace439d2">to</a> = -1;
<a name="l04080"></a>04080 
<a name="l04081"></a>04081   <span class="comment">/* If the number of fields have changed, then for sure the type</span>
<a name="l04082"></a>04082 <span class="comment">     has mutated.  */</span>
<a name="l04083"></a>04083   <span class="keywordflow">if</span> (<a class="code" href="ada-varobj_8c.html#a8c77dcd297321f684638fc12196e3f25">ada_varobj_get_number_of_children</a> (new_val, new_type)
<a name="l04084"></a>04084       != var-&gt;<a class="code" href="structvarobj.html#a2dc9d89453ddea218b4ca5560a3e359f">num_children</a>)
<a name="l04085"></a>04085     <span class="keywordflow">return</span> 1;
<a name="l04086"></a>04086 
<a name="l04087"></a>04087   <span class="comment">/* If the number of fields have remained the same, then we need</span>
<a name="l04088"></a>04088 <span class="comment">     to check the name of each field.  If they remain the same,</span>
<a name="l04089"></a>04089 <span class="comment">     then chances are the type hasn&#39;t mutated.  This is technically</span>
<a name="l04090"></a>04090 <span class="comment">     an incomplete test, as the child&#39;s type might have changed</span>
<a name="l04091"></a>04091 <span class="comment">     despite the fact that the name remains the same.  But we&#39;ll</span>
<a name="l04092"></a>04092 <span class="comment">     handle this situation by saying that the child has mutated,</span>
<a name="l04093"></a>04093 <span class="comment">     not this value.</span>
<a name="l04094"></a>04094 <span class="comment"></span>
<a name="l04095"></a>04095 <span class="comment">     If only part (or none!) of the children have been fetched,</span>
<a name="l04096"></a>04096 <span class="comment">     then only check the ones we fetched.  It does not matter</span>
<a name="l04097"></a>04097 <span class="comment">     to the frontend whether a child that it has not fetched yet</span>
<a name="l04098"></a>04098 <span class="comment">     has mutated or not. So just assume it hasn&#39;t.  */</span>
<a name="l04099"></a>04099 
<a name="l04100"></a>04100   <a class="code" href="varobj_8c.html#afde0b8827029c1be162daa485403f344">restrict_range</a> (var-&gt;children, &amp;from, &amp;to);
<a name="l04101"></a>04101   <span class="keywordflow">for</span> (i = from; i &lt; <a class="code" href="varobj_8h.html#ae2a2635825813434f3201bf8ace439d2">to</a>; i++)
<a name="l04102"></a>04102     <span class="keywordflow">if</span> (strcmp (<a class="code" href="ada-varobj_8c.html#abb148477cda76581ccc494bb000624d8">ada_varobj_get_name_of_child</a> (new_val, new_type,
<a name="l04103"></a>04103                                               var-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>, i),
<a name="l04104"></a>04104                 <a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="structvarobj.html">varobj_p</a>, var-&gt;children, i)-&gt;name) != 0)
<a name="l04105"></a>04105       <span class="keywordflow">return</span> 1;
<a name="l04106"></a>04106 
<a name="l04107"></a>04107   <span class="keywordflow">return</span> 0;
<a name="l04108"></a>04108 }
<a name="l04109"></a>04109 
<a name="l04110"></a>04110 <span class="comment">/* Iterate all the existing _root_ VAROBJs and call the FUNC callback for them</span>
<a name="l04111"></a>04111 <span class="comment">   with an arbitrary caller supplied DATA pointer.  */</span>
<a name="l04112"></a>04112 
<a name="l04113"></a>04113 <span class="keywordtype">void</span>
<a name="l04114"></a><a class="code" href="varobj_8h.html#a88fd549387b998df9e5612282cf84e3b">04114</a> <a class="code" href="varobj_8c.html#a88fd549387b998df9e5612282cf84e3b">all_root_varobjs</a> (<span class="keywordtype">void</span> (*<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>) (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keywordtype">void</span> *data), <span class="keywordtype">void</span> *data)
<a name="l04115"></a>04115 {
<a name="l04116"></a>04116   <span class="keyword">struct </span><a class="code" href="structvarobj__root.html">varobj_root</a> *var_root, *var_root_next;
<a name="l04117"></a>04117 
<a name="l04118"></a>04118   <span class="comment">/* Iterate &quot;safely&quot; - handle if the callee deletes its passed VAROBJ.  */</span>
<a name="l04119"></a>04119 
<a name="l04120"></a>04120   <span class="keywordflow">for</span> (var_root = rootlist; var_root != NULL; var_root = var_root_next)
<a name="l04121"></a>04121     {
<a name="l04122"></a>04122       var_root_next = var_root-&gt;<a class="code" href="structvarobj__root.html#ad97dab9a8e9ac5c39caa4bf667d0e1c9">next</a>;
<a name="l04123"></a>04123 
<a name="l04124"></a>04124       (*func) (var_root-&gt;<a class="code" href="structvarobj__root.html#a97dad6ede27c5d6c37095510fa9ce93e">rootvar</a>, data);
<a name="l04125"></a>04125     }
<a name="l04126"></a>04126 }
<a name="l04127"></a>04127 
<a name="l04128"></a>04128 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="init_8c.html#a119b2b15c22efbf92ef4cbf44eaa6f76">_initialize_varobj</a> (<span class="keywordtype">void</span>);
<a name="l04129"></a>04129 <span class="keywordtype">void</span>
<a name="l04130"></a><a class="code" href="init_8c.html#a119b2b15c22efbf92ef4cbf44eaa6f76">04130</a> <a class="code" href="init_8c.html#a119b2b15c22efbf92ef4cbf44eaa6f76">_initialize_varobj</a> (<span class="keywordtype">void</span>)
<a name="l04131"></a>04131 {
<a name="l04132"></a>04132   <span class="keywordtype">int</span> sizeof_table = <span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structvlist.html">vlist</a> *) * <a class="code" href="varobj_8c.html#a3e3ade9793c5199bc838ac530297268d">VAROBJ_TABLE_SIZE</a>;
<a name="l04133"></a>04133 
<a name="l04134"></a>04134   varobj_table = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (sizeof_table);
<a name="l04135"></a>04135   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (varobj_table, 0, sizeof_table);
<a name="l04136"></a>04136 
<a name="l04137"></a>04137   <a class="code" href="cli-decode_8c.html#ae32b914a6e0676efa41e6281007a75c1">add_setshow_zuinteger_cmd</a> (<span class="stringliteral">&quot;debugvarobj&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a502c7b57c7172ac88ef735f68070bb59">class_maintenance</a>,
<a name="l04138"></a>04138                              &amp;<a class="code" href="mi-cmd-var_8c.html#afc68a4a5062c47438bdd85051db7b6db">varobjdebug</a>,
<a name="l04139"></a>04139                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Set varobj debugging.&quot;</span>),
<a name="l04140"></a>04140                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Show varobj debugging.&quot;</span>),
<a name="l04141"></a>04141                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;When non-zero, varobj debugging is enabled.&quot;</span>),
<a name="l04142"></a>04142                              NULL, <a class="code" href="varobj_8c.html#a971ec565816c402eae3ba1e56ff778a1">show_varobjdebug</a>,
<a name="l04143"></a>04143                              &amp;<a class="code" href="cli-cmds_8c.html#a723e0174d833cba0aa82fb936a56c8fa">setlist</a>, &amp;<a class="code" href="cli-cmds_8c.html#a003932aa76fd3f41763ecc6bee5e2ca8">showlist</a>);
<a name="l04144"></a>04144 }
<a name="l04145"></a>04145 
<a name="l04146"></a>04146 <span class="comment">/* Invalidate varobj VAR if it is tied to locals and re-create it if it is</span>
<a name="l04147"></a>04147 <span class="comment">   defined on globals.  It is a helper for varobj_invalidate.</span>
<a name="l04148"></a>04148 <span class="comment"></span>
<a name="l04149"></a>04149 <span class="comment">   This function is called after changing the symbol file, in this case the</span>
<a name="l04150"></a>04150 <span class="comment">   pointers to &quot;struct type&quot; stored by the varobj are no longer valid.  All</span>
<a name="l04151"></a>04151 <span class="comment">   varobj must be either re-evaluated, or marked as invalid here.  */</span>
<a name="l04152"></a>04152 
<a name="l04153"></a>04153 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04154"></a><a class="code" href="varobj_8c.html#a195aaa714b978e01b1e355e46bc6016f">04154</a> <a class="code" href="varobj_8c.html#a195aaa714b978e01b1e355e46bc6016f">varobj_invalidate_iter</a> (<span class="keyword">struct</span> <a class="code" href="structvarobj.html">varobj</a> *var, <span class="keywordtype">void</span> *unused)
<a name="l04155"></a>04155 {
<a name="l04156"></a>04156   <span class="comment">/* global and floating var must be re-evaluated.  */</span>
<a name="l04157"></a>04157   <span class="keywordflow">if</span> (var-&gt;root-&gt;floating || var-&gt;root-&gt;valid_block == NULL)
<a name="l04158"></a>04158     {
<a name="l04159"></a>04159       <span class="keyword">struct </span><a class="code" href="structvarobj.html">varobj</a> *tmp_var;
<a name="l04160"></a>04160 
<a name="l04161"></a>04161       <span class="comment">/* Try to create a varobj with same expression.  If we succeed</span>
<a name="l04162"></a>04162 <span class="comment">         replace the old varobj, otherwise invalidate it.  */</span>
<a name="l04163"></a>04163       tmp_var = <a class="code" href="varobj_8c.html#aa0cbdb998dfbf2469c767968ecf2c333">varobj_create</a> (NULL, var-&gt;<a class="code" href="structvarobj.html#a52ebbc2f8356ac69f4f17395965067b8">name</a>, (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 0,
<a name="l04164"></a>04164                                <a class="code" href="varobj_8h.html#a1a5e81372ed6f07cbe8792bf36af015fa002ba5a273b14670d24ed63fc9b95381">USE_CURRENT_FRAME</a>);
<a name="l04165"></a>04165       <span class="keywordflow">if</span> (tmp_var != NULL) 
<a name="l04166"></a>04166         { 
<a name="l04167"></a>04167           tmp_var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a> = xstrdup (var-&gt;<a class="code" href="structvarobj.html#a91467023454e44b2657268f910514795">obj_name</a>);
<a name="l04168"></a>04168           <a class="code" href="varobj_8c.html#aad58751b29b14a5eeb8b9879df27683d">varobj_delete</a> (var, NULL, 0);
<a name="l04169"></a>04169           <a class="code" href="varobj_8c.html#add625a61acb44538c0b77386e3ee3549">install_variable</a> (tmp_var);
<a name="l04170"></a>04170         }
<a name="l04171"></a>04171       <span class="keywordflow">else</span>
<a name="l04172"></a>04172         var-&gt;root-&gt;is_valid = 0;
<a name="l04173"></a>04173     }
<a name="l04174"></a>04174   <span class="keywordflow">else</span> <span class="comment">/* locals must be invalidated.  */</span>
<a name="l04175"></a>04175     var-&gt;root-&gt;is_valid = 0;
<a name="l04176"></a>04176 }
<a name="l04177"></a>04177 
<a name="l04178"></a>04178 <span class="comment">/* Invalidate the varobjs that are tied to locals and re-create the ones that</span>
<a name="l04179"></a>04179 <span class="comment">   are defined on globals.</span>
<a name="l04180"></a>04180 <span class="comment">   Invalidated varobjs will be always printed in_scope=&quot;invalid&quot;.  */</span>
<a name="l04181"></a>04181 
<a name="l04182"></a>04182 <span class="keywordtype">void</span> 
<a name="l04183"></a><a class="code" href="varobj_8h.html#a2c8c60552bb8d8936dbae21bb0078859">04183</a> <a class="code" href="varobj_8c.html#a2c8c60552bb8d8936dbae21bb0078859">varobj_invalidate</a> (<span class="keywordtype">void</span>)
<a name="l04184"></a>04184 {
<a name="l04185"></a>04185   <a class="code" href="varobj_8c.html#a88fd549387b998df9e5612282cf84e3b">all_root_varobjs</a> (<a class="code" href="varobj_8c.html#a195aaa714b978e01b1e355e46bc6016f">varobj_invalidate_iter</a>, NULL);
<a name="l04186"></a>04186 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:13:36 for GDB (xrefs) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
