<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (xrefs): /home/stan/gdb/src/gdb/gdbtypes.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (xrefs)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/gdbtypes.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="gdbtypes_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Internal type definitions for GDB.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 1992-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   Contributed by Cygnus Support, using pieces from other GDB modules.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This file is part of GDB.</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00010"></a>00010 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00011"></a>00011 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00012"></a>00012 <span class="comment">   (at your option) any later version.</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00015"></a>00015 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00016"></a>00016 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00017"></a>00017 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00020"></a>00020 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#if !defined (GDBTYPES_H)</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#define GDBTYPES_H 1</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;hashtab.h&quot;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment">/* Forward declarations for prototypes.  */</span>
<a name="l00028"></a>00028 <span class="keyword">struct </span>field;
<a name="l00029"></a>00029 <span class="keyword">struct </span><a class="code" href="structblock.html">block</a>;
<a name="l00030"></a>00030 <span class="keyword">struct </span><a class="code" href="structvalue__print__options.html">value_print_options</a>;
<a name="l00031"></a>00031 <span class="keyword">struct </span><a class="code" href="structlanguage__defn.html">language_defn</a>;
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="comment">/* These declarations are DWARF-specific as some of the gdbtypes.h data types</span>
<a name="l00034"></a>00034 <span class="comment">   are already DWARF-specific.  */</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="comment">/* Offset relative to the start of its containing CU (compilation unit).  */</span>
<a name="l00037"></a><a class="code" href="structcu__offset.html">00037</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00038"></a>00038 {
<a name="l00039"></a><a class="code" href="structcu__offset.html#a19224b0dc5f0bc49babd2b7701a8d63e">00039</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structcu__offset.html#a19224b0dc5f0bc49babd2b7701a8d63e">cu_off</a>;
<a name="l00040"></a>00040 } <a class="code" href="structcu__offset.html">cu_offset</a>;
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="comment">/* Offset relative to the start of its .debug_info or .debug_types section.  */</span>
<a name="l00043"></a><a class="code" href="structsect__offset.html">00043</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00044"></a>00044 {
<a name="l00045"></a><a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">00045</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structsect__offset.html#ae7985c322779b7a07d87792bf78a1f06">sect_off</a>;
<a name="l00046"></a>00046 } <a class="code" href="structsect__offset.html">sect_offset</a>;
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="comment">/* Some macros for char-based bitfields.  */</span>
<a name="l00049"></a>00049 
<a name="l00050"></a><a class="code" href="gdbtypes_8h.html#aadd764bdfb3fff0d5e826ba8bbe75518">00050</a> <span class="preprocessor">#define B_SET(a,x)      ((a)[(x)&gt;&gt;3] |= (1 &lt;&lt; ((x)&amp;7)))</span>
<a name="l00051"></a><a class="code" href="gdbtypes_8h.html#a0e66d732084d91a33b0dd60aea9702dd">00051</a> <span class="preprocessor"></span><span class="preprocessor">#define B_CLR(a,x)      ((a)[(x)&gt;&gt;3] &amp;= ~(1 &lt;&lt; ((x)&amp;7)))</span>
<a name="l00052"></a><a class="code" href="gdbtypes_8h.html#a5d23037051210f2a4efbba86e1c47400">00052</a> <span class="preprocessor"></span><span class="preprocessor">#define B_TST(a,x)      ((a)[(x)&gt;&gt;3] &amp; (1 &lt;&lt; ((x)&amp;7)))</span>
<a name="l00053"></a><a class="code" href="gdbtypes_8h.html#a4a576bae886fea0085ee73676f852bb8">00053</a> <span class="preprocessor"></span><span class="preprocessor">#define B_TYPE          unsigned char</span>
<a name="l00054"></a><a class="code" href="gdbtypes_8h.html#a35237d59cbade1ff0de8adb7f45d8d18">00054</a> <span class="preprocessor"></span><span class="preprocessor">#define B_BYTES(x)      ( 1 + ((x)&gt;&gt;3) )</span>
<a name="l00055"></a><a class="code" href="gdbtypes_8h.html#a4a5774aee98a1f89f90d9dd1d800bca1">00055</a> <span class="preprocessor"></span><span class="preprocessor">#define B_CLRALL(a,x)   memset ((a), 0, B_BYTES(x))</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>
<a name="l00057"></a>00057 <span class="comment">/* Different kinds of data types are distinguished by the `code&#39; field.  */</span>
<a name="l00058"></a>00058 
<a name="l00059"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">00059</a> <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a>
<a name="l00060"></a>00060   {
<a name="l00061"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a74d961bf3f28597b74d926defb06bde5">00061</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a74d961bf3f28597b74d926defb06bde5">TYPE_CODE_BITSTRING</a> = -1,   <span class="comment">/* Deprecated  */</span>
<a name="l00062"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ac0ed09886a958d1a94646893440004a8">00062</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ac0ed09886a958d1a94646893440004a8">TYPE_CODE_UNDEF</a> = 0,        <span class="comment">/* Not used; catches errors */</span>
<a name="l00063"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">00063</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>,              <span class="comment">/* Pointer type */</span>
<a name="l00064"></a>00064 
<a name="l00065"></a>00065     <span class="comment">/* Array type with lower &amp; upper bounds.</span>
<a name="l00066"></a>00066 <span class="comment"></span>
<a name="l00067"></a>00067 <span class="comment">       Regardless of the language, GDB represents multidimensional</span>
<a name="l00068"></a>00068 <span class="comment">       array types the way C does: as arrays of arrays.  So an</span>
<a name="l00069"></a>00069 <span class="comment">       instance of a GDB array type T can always be seen as a series</span>
<a name="l00070"></a>00070 <span class="comment">       of instances of TYPE_TARGET_TYPE (T) laid out sequentially in</span>
<a name="l00071"></a>00071 <span class="comment">       memory.</span>
<a name="l00072"></a>00072 <span class="comment"></span>
<a name="l00073"></a>00073 <span class="comment">       Row-major languages like C lay out multi-dimensional arrays so</span>
<a name="l00074"></a>00074 <span class="comment">       that incrementing the rightmost index in a subscripting</span>
<a name="l00075"></a>00075 <span class="comment">       expression results in the smallest change in the address of the</span>
<a name="l00076"></a>00076 <span class="comment">       element referred to.  Column-major languages like Fortran lay</span>
<a name="l00077"></a>00077 <span class="comment">       them out so that incrementing the leftmost index results in the</span>
<a name="l00078"></a>00078 <span class="comment">       smallest change.</span>
<a name="l00079"></a>00079 <span class="comment"></span>
<a name="l00080"></a>00080 <span class="comment">       This means that, in column-major languages, working our way</span>
<a name="l00081"></a>00081 <span class="comment">       from type to target type corresponds to working through indices</span>
<a name="l00082"></a>00082 <span class="comment">       from right to left, not left to right.  */</span>
<a name="l00083"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">00083</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>,
<a name="l00084"></a>00084 
<a name="l00085"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">00085</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>,           <span class="comment">/* C struct or Pascal record */</span>
<a name="l00086"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">00086</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>,            <span class="comment">/* C union or Pascal variant part */</span>
<a name="l00087"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">00087</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>,             <span class="comment">/* Enumeration type */</span>
<a name="l00088"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ab9ceda9934dbdad598b6b28b166a9176">00088</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ab9ceda9934dbdad598b6b28b166a9176">TYPE_CODE_FLAGS</a>,            <span class="comment">/* Bit flags type */</span>
<a name="l00089"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">00089</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>,             <span class="comment">/* Function type */</span>
<a name="l00090"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">00090</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>,              <span class="comment">/* Integer type */</span>
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     <span class="comment">/* Floating type.  This is *NOT* a complex type.  Beware, there are parts</span>
<a name="l00093"></a>00093 <span class="comment">       of GDB which bogusly assume that TYPE_CODE_FLT can mean complex.  */</span>
<a name="l00094"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">00094</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>,
<a name="l00095"></a>00095 
<a name="l00096"></a>00096     <span class="comment">/* Void type.  The length field specifies the length (probably always</span>
<a name="l00097"></a>00097 <span class="comment">       one) which is used in pointer arithmetic involving pointers to</span>
<a name="l00098"></a>00098 <span class="comment">       this type, but actually dereferencing such a pointer is invalid;</span>
<a name="l00099"></a>00099 <span class="comment">       a void type has no length and no actual representation in memory</span>
<a name="l00100"></a>00100 <span class="comment">       or registers.  A pointer to a void type is a generic pointer.  */</span>
<a name="l00101"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">00101</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>,
<a name="l00102"></a>00102 
<a name="l00103"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a216bf69a8ff9dd9c986dab10f4fe6894">00103</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a216bf69a8ff9dd9c986dab10f4fe6894">TYPE_CODE_SET</a>,              <span class="comment">/* Pascal sets */</span>
<a name="l00104"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">00104</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>,            <span class="comment">/* Range (integers within spec&#39;d bounds).  */</span>
<a name="l00105"></a>00105 
<a name="l00106"></a>00106     <span class="comment">/* A string type which is like an array of character but prints</span>
<a name="l00107"></a>00107 <span class="comment">       differently (at least for (the deleted) CHILL).  It does not</span>
<a name="l00108"></a>00108 <span class="comment">       contain a length field as Pascal strings (for many Pascals,</span>
<a name="l00109"></a>00109 <span class="comment">       anyway) do; if we want to deal with such strings, we should use</span>
<a name="l00110"></a>00110 <span class="comment">       a new type code.  */</span>
<a name="l00111"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a956ce01e5c83060e05208c9404fedca2">00111</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a956ce01e5c83060e05208c9404fedca2">TYPE_CODE_STRING</a>,
<a name="l00112"></a>00112 
<a name="l00113"></a>00113     <span class="comment">/* Unknown type.  The length field is valid if we were able to</span>
<a name="l00114"></a>00114 <span class="comment">       deduce that much about the type, or 0 if we don&#39;t even know that.  */</span>
<a name="l00115"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a36e1735c46b31ec7fc392e40606f8f65">00115</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a36e1735c46b31ec7fc392e40606f8f65">TYPE_CODE_ERROR</a>,
<a name="l00116"></a>00116 
<a name="l00117"></a>00117     <span class="comment">/* C++ */</span>
<a name="l00118"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a581771a1410949e8b505dd51426949e9">00118</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a581771a1410949e8b505dd51426949e9">TYPE_CODE_METHOD</a>,           <span class="comment">/* Method type */</span>
<a name="l00119"></a>00119 
<a name="l00120"></a>00120     <span class="comment">/* Pointer-to-member-function type.  This describes how to access a</span>
<a name="l00121"></a>00121 <span class="comment">       particular member function of a class (possibly a virtual</span>
<a name="l00122"></a>00122 <span class="comment">       member function).  The representation may vary between different</span>
<a name="l00123"></a>00123 <span class="comment">       C++ ABIs.  */</span>
<a name="l00124"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462adec2c2388675220f922bae85d149f170">00124</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462adec2c2388675220f922bae85d149f170">TYPE_CODE_METHODPTR</a>,
<a name="l00125"></a>00125 
<a name="l00126"></a>00126     <span class="comment">/* Pointer-to-member type.  This is the offset within a class to some</span>
<a name="l00127"></a>00127 <span class="comment">       particular data member.  The only currently supported representation</span>
<a name="l00128"></a>00128 <span class="comment">       uses an unbiased offset, with -1 representing NULL; this is used</span>
<a name="l00129"></a>00129 <span class="comment">       by the Itanium C++ ABI (used by GCC on all platforms).  */</span>
<a name="l00130"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a0311d6e6980a50c23e68350f1b8fb5ae">00130</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a0311d6e6980a50c23e68350f1b8fb5ae">TYPE_CODE_MEMBERPTR</a>,
<a name="l00131"></a>00131 
<a name="l00132"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">00132</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>,              <span class="comment">/* C++ Reference types */</span>
<a name="l00133"></a>00133 
<a name="l00134"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae991dd7ea70631f3e1b67a1a75020b5f">00134</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae991dd7ea70631f3e1b67a1a75020b5f">TYPE_CODE_CHAR</a>,             <span class="comment">/* *real* character type */</span>
<a name="l00135"></a>00135 
<a name="l00136"></a>00136     <span class="comment">/* Boolean type.  0 is false, 1 is true, and other values are non-boolean</span>
<a name="l00137"></a>00137 <span class="comment">       (e.g. FORTRAN &quot;logical&quot; used as unsigned int).  */</span>
<a name="l00138"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462afbf0aa0241df408e1017ae7ff8e6798c">00138</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462afbf0aa0241df408e1017ae7ff8e6798c">TYPE_CODE_BOOL</a>,
<a name="l00139"></a>00139 
<a name="l00140"></a>00140     <span class="comment">/* Fortran */</span>
<a name="l00141"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad8de4d143b624cd2bcab740a51a04658">00141</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad8de4d143b624cd2bcab740a51a04658">TYPE_CODE_COMPLEX</a>,          <span class="comment">/* Complex float */</span>
<a name="l00142"></a>00142 
<a name="l00143"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">00143</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>,
<a name="l00144"></a>00144 
<a name="l00145"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae5cdf73186d3029211503380f64949b6">00145</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae5cdf73186d3029211503380f64949b6">TYPE_CODE_NAMESPACE</a>,        <span class="comment">/* C++ namespace.  */</span>
<a name="l00146"></a>00146 
<a name="l00147"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ace4e1a5aff0ea601f04c6f25eb8ed47b">00147</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ace4e1a5aff0ea601f04c6f25eb8ed47b">TYPE_CODE_DECFLOAT</a>,         <span class="comment">/* Decimal floating point.  */</span>
<a name="l00148"></a>00148 
<a name="l00149"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a3da7187b0222a7bd83581aff68c8cd63">00149</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a3da7187b0222a7bd83581aff68c8cd63">TYPE_CODE_MODULE</a>,           <span class="comment">/* Fortran module.  */</span>
<a name="l00150"></a>00150 
<a name="l00151"></a>00151     <span class="comment">/* Internal function type.  */</span>
<a name="l00152"></a><a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a5d698fd1c5c048c06f19bb245a856fbb">00152</a>     <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a5d698fd1c5c048c06f19bb245a856fbb">TYPE_CODE_INTERNAL_FUNCTION</a>
<a name="l00153"></a>00153   };
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 <span class="comment">/* For now allow source to use TYPE_CODE_CLASS for C++ classes, as an</span>
<a name="l00156"></a>00156 <span class="comment">   alias for TYPE_CODE_STRUCT.  This is for DWARF, which has a distinct</span>
<a name="l00157"></a>00157 <span class="comment">   &quot;class&quot; attribute.  Perhaps we should actually have a separate TYPE_CODE</span>
<a name="l00158"></a>00158 <span class="comment">   so that we can print &quot;class&quot; or &quot;struct&quot; depending on what the debug</span>
<a name="l00159"></a>00159 <span class="comment">   info said.  It&#39;s not clear we should bother.  */</span>
<a name="l00160"></a>00160 
<a name="l00161"></a><a class="code" href="gdbtypes_8h.html#a9f70b67b4d14548a879667f544eab4ef">00161</a> <span class="preprocessor">#define TYPE_CODE_CLASS TYPE_CODE_STRUCT</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span>
<a name="l00163"></a>00163 <span class="comment">/* Some constants representing each bit field in the main_type.  See</span>
<a name="l00164"></a>00164 <span class="comment">   the bit-field-specific macros, below, for documentation of each</span>
<a name="l00165"></a>00165 <span class="comment">   constant in this enum.  These enum values are only used with</span>
<a name="l00166"></a>00166 <span class="comment">   init_type.  Note that the values are chosen not to conflict with</span>
<a name="l00167"></a>00167 <span class="comment">   type_instance_flag_value; this lets init_type error-check its</span>
<a name="l00168"></a>00168 <span class="comment">   input.  */</span>
<a name="l00169"></a>00169 
<a name="l00170"></a><a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9">00170</a> <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9">type_flag_value</a>
<a name="l00171"></a>00171 {
<a name="l00172"></a><a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9aa6b8e0a7b0ed2628130fd531fe22d596">00172</a>   <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9aa6b8e0a7b0ed2628130fd531fe22d596">TYPE_FLAG_UNSIGNED</a> = (1 &lt;&lt; 8),
<a name="l00173"></a><a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a68257ce550f2c93cdd5c1cc7eef0d146">00173</a>   <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a68257ce550f2c93cdd5c1cc7eef0d146">TYPE_FLAG_NOSIGN</a> = (1 &lt;&lt; 9),
<a name="l00174"></a><a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9ae5002ab594e75bee4208a8bdf65be94d">00174</a>   <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9ae5002ab594e75bee4208a8bdf65be94d">TYPE_FLAG_STUB</a> = (1 &lt;&lt; 10),
<a name="l00175"></a><a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a8b821aa79807aa1534d00eb24e37fdc6">00175</a>   <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a8b821aa79807aa1534d00eb24e37fdc6">TYPE_FLAG_TARGET_STUB</a> = (1 &lt;&lt; 11),
<a name="l00176"></a><a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a710127d8f5d1c507f76cf58a54809812">00176</a>   <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a710127d8f5d1c507f76cf58a54809812">TYPE_FLAG_STATIC</a> = (1 &lt;&lt; 12),
<a name="l00177"></a><a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a68a7906de27a1e90480a59543ca278fe">00177</a>   <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a68a7906de27a1e90480a59543ca278fe">TYPE_FLAG_PROTOTYPED</a> = (1 &lt;&lt; 13),
<a name="l00178"></a><a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a9bc9eca648940375a7180f6d08a1b34d">00178</a>   <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a9bc9eca648940375a7180f6d08a1b34d">TYPE_FLAG_INCOMPLETE</a> = (1 &lt;&lt; 14),
<a name="l00179"></a><a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9ab5e3c5ce69de6d9121dd271ae876a8ce">00179</a>   <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9ab5e3c5ce69de6d9121dd271ae876a8ce">TYPE_FLAG_VARARGS</a> = (1 &lt;&lt; 15),
<a name="l00180"></a><a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a9b8ba59ed7c9518f3f19e65b742b12dd">00180</a>   <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a9b8ba59ed7c9518f3f19e65b742b12dd">TYPE_FLAG_VECTOR</a> = (1 &lt;&lt; 16),
<a name="l00181"></a><a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a90385027c4da227156c7afb8efc9bf1e">00181</a>   <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a90385027c4da227156c7afb8efc9bf1e">TYPE_FLAG_FIXED_INSTANCE</a> = (1 &lt;&lt; 17),
<a name="l00182"></a><a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9aabb4b68ae797dff283da7312323ebb2f">00182</a>   <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9aabb4b68ae797dff283da7312323ebb2f">TYPE_FLAG_STUB_SUPPORTED</a> = (1 &lt;&lt; 18),
<a name="l00183"></a><a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a2c540ac9437bf975d1c7e5e03f30f177">00183</a>   <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a2c540ac9437bf975d1c7e5e03f30f177">TYPE_FLAG_GNU_IFUNC</a> = (1 &lt;&lt; 19),
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   <span class="comment">/* Used for error-checking.  */</span>
<a name="l00186"></a><a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a81e09a3751e7209dc294393ac23b7408">00186</a>   <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9a81e09a3751e7209dc294393ac23b7408">TYPE_FLAG_MIN</a> = <a class="code" href="gdbtypes_8h.html#aea951af1b432d9ffd2c95eaa944568c9aa6b8e0a7b0ed2628130fd531fe22d596">TYPE_FLAG_UNSIGNED</a>
<a name="l00187"></a>00187 };
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="comment">/* Some bits for the type&#39;s instance_flags word.  See the macros below</span>
<a name="l00190"></a>00190 <span class="comment">   for documentation on each bit.  Note that if you add a value here,</span>
<a name="l00191"></a>00191 <span class="comment">   you must update the enum type_flag_value as well.  */</span>
<a name="l00192"></a><a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029">00192</a> <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029">type_instance_flag_value</a>
<a name="l00193"></a>00193 {
<a name="l00194"></a><a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029a42a1b4a85f9410a10989b94661ed88eb">00194</a>   <a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029a42a1b4a85f9410a10989b94661ed88eb">TYPE_INSTANCE_FLAG_CONST</a> = (1 &lt;&lt; 0),
<a name="l00195"></a><a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029a43c3c8efcccc5b51b8e2b7f10da0cfe0">00195</a>   <a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029a43c3c8efcccc5b51b8e2b7f10da0cfe0">TYPE_INSTANCE_FLAG_VOLATILE</a> = (1 &lt;&lt; 1),
<a name="l00196"></a><a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029a0e4a3fa2f7d0a5aeed0db61c69187d9d">00196</a>   <a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029a0e4a3fa2f7d0a5aeed0db61c69187d9d">TYPE_INSTANCE_FLAG_CODE_SPACE</a> = (1 &lt;&lt; 2),
<a name="l00197"></a><a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029a611cd67bb929730abba72e55e07eeb0b">00197</a>   <a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029a611cd67bb929730abba72e55e07eeb0b">TYPE_INSTANCE_FLAG_DATA_SPACE</a> = (1 &lt;&lt; 3),
<a name="l00198"></a><a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029ae85ffd953771426c2ad732e51d8d0e84">00198</a>   <a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029ae85ffd953771426c2ad732e51d8d0e84">TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1</a> = (1 &lt;&lt; 4),
<a name="l00199"></a><a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029a629e7d49a24a6ad0d0ad3ddaee3ed2fe">00199</a>   <a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029a629e7d49a24a6ad0d0ad3ddaee3ed2fe">TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2</a> = (1 &lt;&lt; 5),
<a name="l00200"></a><a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029afe94301013c06ee5113ea36ca84e0f94">00200</a>   <a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029afe94301013c06ee5113ea36ca84e0f94">TYPE_INSTANCE_FLAG_NOTTEXT</a> = (1 &lt;&lt; 6),
<a name="l00201"></a><a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029a61fedca136ec422466c92400ee85848d">00201</a>   <a class="code" href="gdbtypes_8h.html#a390c31e15117ac7eda1a5d1341967029a61fedca136ec422466c92400ee85848d">TYPE_INSTANCE_FLAG_RESTRICT</a> = (1 &lt;&lt; 7)
<a name="l00202"></a>00202 };
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="comment">/* Unsigned integer type.  If this is not set for a TYPE_CODE_INT, the</span>
<a name="l00205"></a>00205 <span class="comment">   type is signed (unless TYPE_FLAG_NOSIGN (below) is set).  */</span>
<a name="l00206"></a>00206 
<a name="l00207"></a><a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">00207</a> <span class="preprocessor">#define TYPE_UNSIGNED(t)        (TYPE_MAIN_TYPE (t)-&gt;flag_unsigned)</span>
<a name="l00208"></a>00208 <span class="preprocessor"></span>
<a name="l00209"></a>00209 <span class="comment">/* No sign for this type.  In C++, &quot;char&quot;, &quot;signed char&quot;, and &quot;unsigned</span>
<a name="l00210"></a>00210 <span class="comment">   char&quot; are distinct types; so we need an extra flag to indicate the</span>
<a name="l00211"></a>00211 <span class="comment">   absence of a sign!  */</span>
<a name="l00212"></a>00212 
<a name="l00213"></a><a class="code" href="gdbtypes_8h.html#a072c2a4284516f56accc85be90546a30">00213</a> <span class="preprocessor">#define TYPE_NOSIGN(t)          (TYPE_MAIN_TYPE (t)-&gt;flag_nosign)</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span>
<a name="l00215"></a>00215 <span class="comment">/* This appears in a type&#39;s flags word if it is a stub type (e.g., if</span>
<a name="l00216"></a>00216 <span class="comment">   someone referenced a type that wasn&#39;t defined in a source file</span>
<a name="l00217"></a>00217 <span class="comment">   via (struct sir_not_appearing_in_this_film *)).  */</span>
<a name="l00218"></a>00218 
<a name="l00219"></a><a class="code" href="gdbtypes_8h.html#aec5d0569d60af8ecfc5d2c7edae87d9c">00219</a> <span class="preprocessor">#define TYPE_STUB(t)            (TYPE_MAIN_TYPE (t)-&gt;flag_stub)</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span>
<a name="l00221"></a>00221 <span class="comment">/* The target type of this type is a stub type, and this type needs to</span>
<a name="l00222"></a>00222 <span class="comment">   be updated if it gets un-stubbed in check_typedef.</span>
<a name="l00223"></a>00223 <span class="comment">   Used for arrays and ranges, in which TYPE_LENGTH of the array/range</span>
<a name="l00224"></a>00224 <span class="comment">   gets set based on the TYPE_LENGTH of the target type.</span>
<a name="l00225"></a>00225 <span class="comment">   Also, set for TYPE_CODE_TYPEDEF.  */</span>
<a name="l00226"></a>00226 
<a name="l00227"></a><a class="code" href="gdbtypes_8h.html#ab2fa79a7afa98ab43f22d8520bf45397">00227</a> <span class="preprocessor">#define TYPE_TARGET_STUB(t)     (TYPE_MAIN_TYPE (t)-&gt;flag_target_stub)</span>
<a name="l00228"></a>00228 <span class="preprocessor"></span>
<a name="l00229"></a>00229 <span class="comment">/* Static type.  If this is set, the corresponding type had </span>
<a name="l00230"></a>00230 <span class="comment">   a static modifier.</span>
<a name="l00231"></a>00231 <span class="comment">   Note: This may be unnecessary, since static data members</span>
<a name="l00232"></a>00232 <span class="comment">   are indicated by other means (bitpos == -1).  */</span>
<a name="l00233"></a>00233 
<a name="l00234"></a><a class="code" href="gdbtypes_8h.html#ab220e2aef85a5f10093f1f494eaa0c3b">00234</a> <span class="preprocessor">#define TYPE_STATIC(t)          (TYPE_MAIN_TYPE (t)-&gt;flag_static)</span>
<a name="l00235"></a>00235 <span class="preprocessor"></span>
<a name="l00236"></a>00236 <span class="comment">/* This is a function type which appears to have a prototype.  We need</span>
<a name="l00237"></a>00237 <span class="comment">   this for function calls in order to tell us if it&#39;s necessary to</span>
<a name="l00238"></a>00238 <span class="comment">   coerce the args, or to just do the standard conversions.  This is</span>
<a name="l00239"></a>00239 <span class="comment">   used with a short field.  */</span>
<a name="l00240"></a>00240 
<a name="l00241"></a><a class="code" href="gdbtypes_8h.html#a5d2347eac0eaeab1f00b01beaeb65d2d">00241</a> <span class="preprocessor">#define TYPE_PROTOTYPED(t)      (TYPE_MAIN_TYPE (t)-&gt;flag_prototyped)</span>
<a name="l00242"></a>00242 <span class="preprocessor"></span>
<a name="l00243"></a>00243 <span class="comment">/* This flag is used to indicate that processing for this type</span>
<a name="l00244"></a>00244 <span class="comment">   is incomplete.</span>
<a name="l00245"></a>00245 <span class="comment"></span>
<a name="l00246"></a>00246 <span class="comment">   (Mostly intended for HP platforms, where class methods, for</span>
<a name="l00247"></a>00247 <span class="comment">   instance, can be encountered before their classes in the debug</span>
<a name="l00248"></a>00248 <span class="comment">   info; the incomplete type has to be marked so that the class and</span>
<a name="l00249"></a>00249 <span class="comment">   the method can be assigned correct types.)  */</span>
<a name="l00250"></a>00250 
<a name="l00251"></a><a class="code" href="gdbtypes_8h.html#a64e838016763c324988a9c232493f95c">00251</a> <span class="preprocessor">#define TYPE_INCOMPLETE(t)      (TYPE_MAIN_TYPE (t)-&gt;flag_incomplete)</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span>
<a name="l00253"></a>00253 <span class="comment">/* FIXME drow/2002-06-03:  Only used for methods, but applies as well</span>
<a name="l00254"></a>00254 <span class="comment">   to functions.  */</span>
<a name="l00255"></a>00255 
<a name="l00256"></a><a class="code" href="gdbtypes_8h.html#ac64534be7706a7ed40f5b2de42df4371">00256</a> <span class="preprocessor">#define TYPE_VARARGS(t)         (TYPE_MAIN_TYPE (t)-&gt;flag_varargs)</span>
<a name="l00257"></a>00257 <span class="preprocessor"></span>
<a name="l00258"></a>00258 <span class="comment">/* Identify a vector type.  Gcc is handling this by adding an extra</span>
<a name="l00259"></a>00259 <span class="comment">   attribute to the array type.  We slurp that in as a new flag of a</span>
<a name="l00260"></a>00260 <span class="comment">   type.  This is used only in dwarf2read.c.  */</span>
<a name="l00261"></a><a class="code" href="gdbtypes_8h.html#a68a23253bcb233221400208f4c21c406">00261</a> <span class="preprocessor">#define TYPE_VECTOR(t)          (TYPE_MAIN_TYPE (t)-&gt;flag_vector)</span>
<a name="l00262"></a>00262 <span class="preprocessor"></span>
<a name="l00263"></a>00263 <span class="comment">/* The debugging formats (especially STABS) do not contain enough information</span>
<a name="l00264"></a>00264 <span class="comment">   to represent all Ada types---especially those whose size depends on</span>
<a name="l00265"></a>00265 <span class="comment">   dynamic quantities.  Therefore, the GNAT Ada compiler includes</span>
<a name="l00266"></a>00266 <span class="comment">   extra information in the form of additional type definitions</span>
<a name="l00267"></a>00267 <span class="comment">   connected by naming conventions.  This flag indicates that the </span>
<a name="l00268"></a>00268 <span class="comment">   type is an ordinary (unencoded) GDB type that has been created from </span>
<a name="l00269"></a>00269 <span class="comment">   the necessary run-time information, and does not need further </span>
<a name="l00270"></a>00270 <span class="comment">   interpretation.  Optionally marks ordinary, fixed-size GDB type.  */</span>
<a name="l00271"></a>00271 
<a name="l00272"></a><a class="code" href="gdbtypes_8h.html#a82cbfd363fdf782853ce90946f81c355">00272</a> <span class="preprocessor">#define TYPE_FIXED_INSTANCE(t) (TYPE_MAIN_TYPE (t)-&gt;flag_fixed_instance)</span>
<a name="l00273"></a>00273 <span class="preprocessor"></span>
<a name="l00274"></a>00274 <span class="comment">/* This debug target supports TYPE_STUB(t).  In the unsupported case we have to</span>
<a name="l00275"></a>00275 <span class="comment">   rely on NFIELDS to be zero etc., see TYPE_IS_OPAQUE ().</span>
<a name="l00276"></a>00276 <span class="comment">   TYPE_STUB(t) with !TYPE_STUB_SUPPORTED(t) may exist if we only guessed</span>
<a name="l00277"></a>00277 <span class="comment">   the TYPE_STUB(t) value (see dwarfread.c).  */</span>
<a name="l00278"></a>00278 
<a name="l00279"></a><a class="code" href="gdbtypes_8h.html#aac7e4f35d6b06664e65106ffd57b31ad">00279</a> <span class="preprocessor">#define TYPE_STUB_SUPPORTED(t)   (TYPE_MAIN_TYPE (t)-&gt;flag_stub_supported)</span>
<a name="l00280"></a>00280 <span class="preprocessor"></span>
<a name="l00281"></a>00281 <span class="comment">/* Not textual.  By default, GDB treats all single byte integers as</span>
<a name="l00282"></a>00282 <span class="comment">   characters (or elements of strings) unless this flag is set.  */</span>
<a name="l00283"></a>00283 
<a name="l00284"></a><a class="code" href="gdbtypes_8h.html#ad14de12dcfa1f444b2af33bff0574ad6">00284</a> <span class="preprocessor">#define TYPE_NOTTEXT(t) (TYPE_INSTANCE_FLAGS (t) &amp; TYPE_INSTANCE_FLAG_NOTTEXT)</span>
<a name="l00285"></a>00285 <span class="preprocessor"></span>
<a name="l00286"></a>00286 <span class="comment">/* Used only for TYPE_CODE_FUNC where it specifies the real function</span>
<a name="l00287"></a>00287 <span class="comment">   address is returned by this function call.  TYPE_TARGET_TYPE determines the</span>
<a name="l00288"></a>00288 <span class="comment">   final returned function type to be presented to user.  */</span>
<a name="l00289"></a>00289 
<a name="l00290"></a><a class="code" href="gdbtypes_8h.html#a7f4dd1784f286a82d4525c3a2175f9c9">00290</a> <span class="preprocessor">#define TYPE_GNU_IFUNC(t)       (TYPE_MAIN_TYPE (t)-&gt;flag_gnu_ifunc)</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span>
<a name="l00292"></a>00292 <span class="comment">/* Type owner.  If TYPE_OBJFILE_OWNED is true, the type is owned by</span>
<a name="l00293"></a>00293 <span class="comment">   the objfile retrieved as TYPE_OBJFILE.  Otherweise, the type is</span>
<a name="l00294"></a>00294 <span class="comment">   owned by an architecture; TYPE_OBJFILE is NULL in this case.  */</span>
<a name="l00295"></a>00295 
<a name="l00296"></a><a class="code" href="gdbtypes_8h.html#a098c3a2b00d9407d4c8732b8bd7c4f68">00296</a> <span class="preprocessor">#define TYPE_OBJFILE_OWNED(t) (TYPE_MAIN_TYPE (t)-&gt;flag_objfile_owned)</span>
<a name="l00297"></a><a class="code" href="gdbtypes_8h.html#ad5d690e5887a7eba5b4d0859933de766">00297</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_OWNER(t) TYPE_MAIN_TYPE(t)-&gt;owner</span>
<a name="l00298"></a><a class="code" href="gdbtypes_8h.html#aff6665865a3226d047330d04c05bcb3d">00298</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_OBJFILE(t) (TYPE_OBJFILE_OWNED(t)? TYPE_OWNER(t).objfile : NULL)</span>
<a name="l00299"></a>00299 <span class="preprocessor"></span>
<a name="l00300"></a>00300 <span class="comment">/* True if this type was declared using the &quot;class&quot; keyword.  This is</span>
<a name="l00301"></a>00301 <span class="comment">   only valid for C++ structure types, and only used for displaying</span>
<a name="l00302"></a>00302 <span class="comment">   the type.  If false, the structure was declared as a &quot;struct&quot;.  */</span>
<a name="l00303"></a>00303 
<a name="l00304"></a><a class="code" href="gdbtypes_8h.html#a2e97f1db4e928a613e3526dfb0346922">00304</a> <span class="preprocessor">#define TYPE_DECLARED_CLASS(t) (TYPE_MAIN_TYPE (t)-&gt;flag_declared_class)</span>
<a name="l00305"></a>00305 <span class="preprocessor"></span>
<a name="l00306"></a>00306 <span class="comment">/* True if this type is a &quot;flag&quot; enum.  A flag enum is one where all</span>
<a name="l00307"></a>00307 <span class="comment">   the values are pairwise disjoint when &quot;and&quot;ed together.  This</span>
<a name="l00308"></a>00308 <span class="comment">   affects how enum values are printed.  */</span>
<a name="l00309"></a>00309 
<a name="l00310"></a><a class="code" href="gdbtypes_8h.html#aa20f304bcdb858552e049e0fdfd04bac">00310</a> <span class="preprocessor">#define TYPE_FLAG_ENUM(t) (TYPE_MAIN_TYPE (t)-&gt;flag_flag_enum)</span>
<a name="l00311"></a>00311 <span class="preprocessor"></span>
<a name="l00312"></a>00312 <span class="comment">/* Constant type.  If this is set, the corresponding type has a</span>
<a name="l00313"></a>00313 <span class="comment">   const modifier.  */</span>
<a name="l00314"></a>00314 
<a name="l00315"></a><a class="code" href="gdbtypes_8h.html#a82b926a1727ba5c6b856145197495a34">00315</a> <span class="preprocessor">#define TYPE_CONST(t) (TYPE_INSTANCE_FLAGS (t) &amp; TYPE_INSTANCE_FLAG_CONST)</span>
<a name="l00316"></a>00316 <span class="preprocessor"></span>
<a name="l00317"></a>00317 <span class="comment">/* Volatile type.  If this is set, the corresponding type has a</span>
<a name="l00318"></a>00318 <span class="comment">   volatile modifier.  */</span>
<a name="l00319"></a>00319 
<a name="l00320"></a><a class="code" href="gdbtypes_8h.html#a85371642c55e599b0d13fc95d0108ad1">00320</a> <span class="preprocessor">#define TYPE_VOLATILE(t) \</span>
<a name="l00321"></a>00321 <span class="preprocessor">  (TYPE_INSTANCE_FLAGS (t) &amp; TYPE_INSTANCE_FLAG_VOLATILE)</span>
<a name="l00322"></a>00322 <span class="preprocessor"></span>
<a name="l00323"></a>00323 <span class="comment">/* Restrict type.  If this is set, the corresponding type has a</span>
<a name="l00324"></a>00324 <span class="comment">   restrict modifier.  */</span>
<a name="l00325"></a>00325 
<a name="l00326"></a><a class="code" href="gdbtypes_8h.html#a3b59018943ce4bdc4ec8a05cb02c096d">00326</a> <span class="preprocessor">#define TYPE_RESTRICT(t) \</span>
<a name="l00327"></a>00327 <span class="preprocessor">  (TYPE_INSTANCE_FLAGS (t) &amp; TYPE_INSTANCE_FLAG_RESTRICT)</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span>
<a name="l00329"></a>00329 <span class="comment">/* Instruction-space delimited type.  This is for Harvard architectures</span>
<a name="l00330"></a>00330 <span class="comment">   which have separate instruction and data address spaces (and perhaps</span>
<a name="l00331"></a>00331 <span class="comment">   others).</span>
<a name="l00332"></a>00332 <span class="comment"></span>
<a name="l00333"></a>00333 <span class="comment">   GDB usually defines a flat address space that is a superset of the</span>
<a name="l00334"></a>00334 <span class="comment">   architecture&#39;s two (or more) address spaces, but this is an extension</span>
<a name="l00335"></a>00335 <span class="comment">   of the architecture&#39;s model.</span>
<a name="l00336"></a>00336 <span class="comment"></span>
<a name="l00337"></a>00337 <span class="comment">   If TYPE_FLAG_INST is set, an object of the corresponding type</span>
<a name="l00338"></a>00338 <span class="comment">   resides in instruction memory, even if its address (in the extended</span>
<a name="l00339"></a>00339 <span class="comment">   flat address space) does not reflect this.</span>
<a name="l00340"></a>00340 <span class="comment"></span>
<a name="l00341"></a>00341 <span class="comment">   Similarly, if TYPE_FLAG_DATA is set, then an object of the </span>
<a name="l00342"></a>00342 <span class="comment">   corresponding type resides in the data memory space, even if</span>
<a name="l00343"></a>00343 <span class="comment">   this is not indicated by its (flat address space) address.</span>
<a name="l00344"></a>00344 <span class="comment"></span>
<a name="l00345"></a>00345 <span class="comment">   If neither flag is set, the default space for functions / methods</span>
<a name="l00346"></a>00346 <span class="comment">   is instruction space, and for data objects is data memory.  */</span>
<a name="l00347"></a>00347 
<a name="l00348"></a><a class="code" href="gdbtypes_8h.html#ae19e562fa8c4081f26ac130602744e7a">00348</a> <span class="preprocessor">#define TYPE_CODE_SPACE(t) \</span>
<a name="l00349"></a>00349 <span class="preprocessor">  (TYPE_INSTANCE_FLAGS (t) &amp; TYPE_INSTANCE_FLAG_CODE_SPACE)</span>
<a name="l00350"></a>00350 <span class="preprocessor"></span>
<a name="l00351"></a><a class="code" href="gdbtypes_8h.html#a693e17a8d1e051855069fa0560b47f26">00351</a> <span class="preprocessor">#define TYPE_DATA_SPACE(t) \</span>
<a name="l00352"></a>00352 <span class="preprocessor">  (TYPE_INSTANCE_FLAGS (t) &amp; TYPE_INSTANCE_FLAG_DATA_SPACE)</span>
<a name="l00353"></a>00353 <span class="preprocessor"></span>
<a name="l00354"></a>00354 <span class="comment">/* Address class flags.  Some environments provide for pointers whose</span>
<a name="l00355"></a>00355 <span class="comment">   size is different from that of a normal pointer or address types</span>
<a name="l00356"></a>00356 <span class="comment">   where the bits are interpreted differently than normal addresses.  The</span>
<a name="l00357"></a>00357 <span class="comment">   TYPE_FLAG_ADDRESS_CLASS_n flags may be used in target specific</span>
<a name="l00358"></a>00358 <span class="comment">   ways to represent these different types of address classes.  */</span>
<a name="l00359"></a><a class="code" href="gdbtypes_8h.html#a6cf300892a28f0f7657fae944de060ac">00359</a> <span class="preprocessor">#define TYPE_ADDRESS_CLASS_1(t) (TYPE_INSTANCE_FLAGS(t) \</span>
<a name="l00360"></a>00360 <span class="preprocessor">                                 &amp; TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1)</span>
<a name="l00361"></a><a class="code" href="gdbtypes_8h.html#aadbe61909ea6cd1c97508be929e803e9">00361</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_ADDRESS_CLASS_2(t) (TYPE_INSTANCE_FLAGS(t) \</span>
<a name="l00362"></a>00362 <span class="preprocessor">                                 &amp; TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2)</span>
<a name="l00363"></a><a class="code" href="gdbtypes_8h.html#a4b64ded0184f9920f572a0f4636e9883">00363</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL \</span>
<a name="l00364"></a>00364 <span class="preprocessor">  (TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1 | TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2)</span>
<a name="l00365"></a><a class="code" href="gdbtypes_8h.html#a59de20021c9125eb573d6506aef13281">00365</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_ADDRESS_CLASS_ALL(t) (TYPE_INSTANCE_FLAGS(t) \</span>
<a name="l00366"></a>00366 <span class="preprocessor">                                   &amp; TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL)</span>
<a name="l00367"></a>00367 <span class="preprocessor"></span>
<a name="l00368"></a>00368 <span class="comment">/* Determine which field of the union main_type.fields[x].loc is used.  */</span>
<a name="l00369"></a>00369 
<a name="l00370"></a><a class="code" href="gdbtypes_8h.html#a3eb0e1253afc7850dc90da0d4ba5b487">00370</a> <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a3eb0e1253afc7850dc90da0d4ba5b487">field_loc_kind</a>
<a name="l00371"></a>00371   {
<a name="l00372"></a><a class="code" href="gdbtypes_8h.html#a3eb0e1253afc7850dc90da0d4ba5b487a14a13da1c64b4e4819eb2dcfb0faa110">00372</a>     <a class="code" href="gdbtypes_8h.html#a3eb0e1253afc7850dc90da0d4ba5b487a14a13da1c64b4e4819eb2dcfb0faa110">FIELD_LOC_KIND_BITPOS</a>,      <span class="comment">/* bitpos */</span>
<a name="l00373"></a><a class="code" href="gdbtypes_8h.html#a3eb0e1253afc7850dc90da0d4ba5b487a76a7756ad51dec8909eaf39d6ba14b8a">00373</a>     <a class="code" href="gdbtypes_8h.html#a3eb0e1253afc7850dc90da0d4ba5b487a76a7756ad51dec8909eaf39d6ba14b8a">FIELD_LOC_KIND_ENUMVAL</a>,     <span class="comment">/* enumval */</span>
<a name="l00374"></a><a class="code" href="gdbtypes_8h.html#a3eb0e1253afc7850dc90da0d4ba5b487a95e68b1aee10e328fe3a4d66455118b3">00374</a>     <a class="code" href="gdbtypes_8h.html#a3eb0e1253afc7850dc90da0d4ba5b487a95e68b1aee10e328fe3a4d66455118b3">FIELD_LOC_KIND_PHYSADDR</a>,    <span class="comment">/* physaddr */</span>
<a name="l00375"></a><a class="code" href="gdbtypes_8h.html#a3eb0e1253afc7850dc90da0d4ba5b487a5f1cabbe416664df2991053364934267">00375</a>     <a class="code" href="gdbtypes_8h.html#a3eb0e1253afc7850dc90da0d4ba5b487a5f1cabbe416664df2991053364934267">FIELD_LOC_KIND_PHYSNAME</a>,    <span class="comment">/* physname */</span>
<a name="l00376"></a><a class="code" href="gdbtypes_8h.html#a3eb0e1253afc7850dc90da0d4ba5b487ace3b14c3078b378f1d919ed7447b759b">00376</a>     <a class="code" href="gdbtypes_8h.html#a3eb0e1253afc7850dc90da0d4ba5b487ace3b14c3078b378f1d919ed7447b759b">FIELD_LOC_KIND_DWARF_BLOCK</a>  <span class="comment">/* dwarf_block */</span>
<a name="l00377"></a>00377   };
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 <span class="comment">/* A discriminant to determine which field in the main_type.type_specific</span>
<a name="l00380"></a>00380 <span class="comment">   union is being used, if any.</span>
<a name="l00381"></a>00381 <span class="comment"></span>
<a name="l00382"></a>00382 <span class="comment">   For types such as TYPE_CODE_FLT or TYPE_CODE_FUNC, the use of this</span>
<a name="l00383"></a>00383 <span class="comment">   discriminant is really redundant, as we know from the type code</span>
<a name="l00384"></a>00384 <span class="comment">   which field is going to be used.  As such, it would be possible to</span>
<a name="l00385"></a>00385 <span class="comment">   reduce the size of this enum in order to save a bit or two for</span>
<a name="l00386"></a>00386 <span class="comment">   other fields of struct main_type.  But, since we still have extra</span>
<a name="l00387"></a>00387 <span class="comment">   room , and for the sake of clarity and consistency, we treat all fields</span>
<a name="l00388"></a>00388 <span class="comment">   of the union the same way.  */</span>
<a name="l00389"></a>00389 
<a name="l00390"></a><a class="code" href="gdbtypes_8h.html#a00bc36dc8a79068ece166a2dfe444b44">00390</a> <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a00bc36dc8a79068ece166a2dfe444b44">type_specific_kind</a>
<a name="l00391"></a>00391 {
<a name="l00392"></a><a class="code" href="gdbtypes_8h.html#a00bc36dc8a79068ece166a2dfe444b44a80e4d4dbaae519c2bd52313ea4f614af">00392</a>   <a class="code" href="gdbtypes_8h.html#a00bc36dc8a79068ece166a2dfe444b44a80e4d4dbaae519c2bd52313ea4f614af">TYPE_SPECIFIC_NONE</a>,
<a name="l00393"></a><a class="code" href="gdbtypes_8h.html#a00bc36dc8a79068ece166a2dfe444b44a9fd9bab69de224d9751a1a79c3021142">00393</a>   <a class="code" href="gdbtypes_8h.html#a00bc36dc8a79068ece166a2dfe444b44a9fd9bab69de224d9751a1a79c3021142">TYPE_SPECIFIC_CPLUS_STUFF</a>,
<a name="l00394"></a><a class="code" href="gdbtypes_8h.html#a00bc36dc8a79068ece166a2dfe444b44a72971845e99489e698bb328ecdef292f">00394</a>   <a class="code" href="gdbtypes_8h.html#a00bc36dc8a79068ece166a2dfe444b44a72971845e99489e698bb328ecdef292f">TYPE_SPECIFIC_GNAT_STUFF</a>,
<a name="l00395"></a><a class="code" href="gdbtypes_8h.html#a00bc36dc8a79068ece166a2dfe444b44a0b5e86547bfd06ddaf5e14607ae9076e">00395</a>   <a class="code" href="gdbtypes_8h.html#a00bc36dc8a79068ece166a2dfe444b44a0b5e86547bfd06ddaf5e14607ae9076e">TYPE_SPECIFIC_FLOATFORMAT</a>,
<a name="l00396"></a><a class="code" href="gdbtypes_8h.html#a00bc36dc8a79068ece166a2dfe444b44a9d72036dd591a9e613f2b1ebd1968535">00396</a>   <a class="code" href="gdbtypes_8h.html#a00bc36dc8a79068ece166a2dfe444b44a9d72036dd591a9e613f2b1ebd1968535">TYPE_SPECIFIC_FUNC</a>
<a name="l00397"></a>00397 };
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 <span class="comment">/* This structure is space-critical.</span>
<a name="l00400"></a>00400 <span class="comment">   Its layout has been tweaked to reduce the space used.  */</span>
<a name="l00401"></a>00401 
<a name="l00402"></a><a class="code" href="structmain__type.html">00402</a> <span class="keyword">struct </span><a class="code" href="structmain__type.html">main_type</a>
<a name="l00403"></a>00403 {
<a name="l00404"></a>00404   <span class="comment">/* Code for kind of type.  */</span>
<a name="l00405"></a>00405 
<a name="l00406"></a><a class="code" href="structmain__type.html#ac1f67ccf5107ad88cb3c5b62c3f02a73">00406</a>   ENUM_BITFIELD(<a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a>) <a class="code" href="ser-unix_8c.html#a45a5b7c00a796a23f01673cef1dbe0a9">code</a> : 8;
<a name="l00407"></a>00407 
<a name="l00408"></a>00408   <span class="comment">/* Flags about this type.  These fields appear at this location</span>
<a name="l00409"></a>00409 <span class="comment">     because they packs nicely here.  See the TYPE_* macros for</span>
<a name="l00410"></a>00410 <span class="comment">     documentation about these fields.  */</span>
<a name="l00411"></a>00411 
<a name="l00412"></a>00412   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#ac1f67ccf5107ad88cb3c5b62c3f02a73">flag_unsigned</a> : 1;
<a name="l00413"></a><a class="code" href="structmain__type.html#a7f3c02e9b502120a2cb7911002fa2fb9">00413</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a7f3c02e9b502120a2cb7911002fa2fb9">flag_nosign</a> : 1;
<a name="l00414"></a><a class="code" href="structmain__type.html#a20c2eb7e5934e82268c64c8027f034c8">00414</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a20c2eb7e5934e82268c64c8027f034c8">flag_stub</a> : 1;
<a name="l00415"></a><a class="code" href="structmain__type.html#a5444fcd9c08604f069bcf9def76363b1">00415</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a5444fcd9c08604f069bcf9def76363b1">flag_target_stub</a> : 1;
<a name="l00416"></a><a class="code" href="structmain__type.html#a413b3e4ebc3394d721ea272348074250">00416</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a413b3e4ebc3394d721ea272348074250">flag_static</a> : 1;
<a name="l00417"></a><a class="code" href="structmain__type.html#ad026388599038a5fcae2151e573cad95">00417</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#ad026388599038a5fcae2151e573cad95">flag_prototyped</a> : 1;
<a name="l00418"></a><a class="code" href="structmain__type.html#a2d436e94daf14dcea7cbc0e64f71a0fa">00418</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a2d436e94daf14dcea7cbc0e64f71a0fa">flag_incomplete</a> : 1;
<a name="l00419"></a><a class="code" href="structmain__type.html#a55e85724b8f5c56112348f787f31a83d">00419</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a55e85724b8f5c56112348f787f31a83d">flag_varargs</a> : 1;
<a name="l00420"></a><a class="code" href="structmain__type.html#abe91b01881ecd3b847ef6b52fa5fbc37">00420</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#abe91b01881ecd3b847ef6b52fa5fbc37">flag_vector</a> : 1;
<a name="l00421"></a><a class="code" href="structmain__type.html#af7aeb255aa344466fa21d0511088682d">00421</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#af7aeb255aa344466fa21d0511088682d">flag_stub_supported</a> : 1;
<a name="l00422"></a><a class="code" href="structmain__type.html#a0f70cd78895efc0654ef09273b7b8d75">00422</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a0f70cd78895efc0654ef09273b7b8d75">flag_gnu_ifunc</a> : 1;
<a name="l00423"></a><a class="code" href="structmain__type.html#a6b1c9c3bc073cae3c42e53e682cfe5b0">00423</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a6b1c9c3bc073cae3c42e53e682cfe5b0">flag_fixed_instance</a> : 1;
<a name="l00424"></a><a class="code" href="structmain__type.html#a00152ebe42bbd335e89104f17f6f0507">00424</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a00152ebe42bbd335e89104f17f6f0507">flag_objfile_owned</a> : 1;
<a name="l00425"></a>00425   <span class="comment">/* True if this type was declared with &quot;class&quot; rather than</span>
<a name="l00426"></a>00426 <span class="comment">     &quot;struct&quot;.  */</span>
<a name="l00427"></a><a class="code" href="structmain__type.html#a45e3d04bb6b2a09d1d16345574f634e0">00427</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a45e3d04bb6b2a09d1d16345574f634e0">flag_declared_class</a> : 1;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="comment">/* True if this is an enum type with disjoint values.  This affects</span>
<a name="l00430"></a>00430 <span class="comment">     how the enum is printed.  */</span>
<a name="l00431"></a>00431 
<a name="l00432"></a><a class="code" href="structmain__type.html#a1ea2a0e359ad7be22eb37961200367b8">00432</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a1ea2a0e359ad7be22eb37961200367b8">flag_flag_enum</a> : 1;
<a name="l00433"></a>00433 
<a name="l00434"></a>00434   <span class="comment">/* A discriminant telling us which field of the type_specific union</span>
<a name="l00435"></a>00435 <span class="comment">     is being used for this type, if any.  */</span>
<a name="l00436"></a><a class="code" href="structmain__type.html#a6980e6e4f874e6352adfeb595437e54a">00436</a>   ENUM_BITFIELD(<a class="code" href="gdbtypes_8h.html#a00bc36dc8a79068ece166a2dfe444b44">type_specific_kind</a>) type_specific_field : 3;
<a name="l00437"></a>00437 
<a name="l00438"></a>00438   <span class="comment">/* Number of fields described for this type.  This field appears at</span>
<a name="l00439"></a>00439 <span class="comment">     this location because it packs nicely here.  */</span>
<a name="l00440"></a>00440 
<a name="l00441"></a>00441   <span class="keywordtype">short</span> <a class="code" href="structmain__type.html#a6980e6e4f874e6352adfeb595437e54a">nfields</a>;
<a name="l00442"></a>00442 
<a name="l00443"></a>00443   <span class="comment">/* Field number of the virtual function table pointer in</span>
<a name="l00444"></a>00444 <span class="comment">     VPTR_BASETYPE.  If -1, we were unable to find the virtual</span>
<a name="l00445"></a>00445 <span class="comment">     function table pointer in initial symbol reading, and</span>
<a name="l00446"></a>00446 <span class="comment">     get_vptr_fieldno should be called to find it if possible.</span>
<a name="l00447"></a>00447 <span class="comment">     get_vptr_fieldno will update this field if possible.</span>
<a name="l00448"></a>00448 <span class="comment">     Otherwise the value is left at -1.</span>
<a name="l00449"></a>00449 <span class="comment"></span>
<a name="l00450"></a>00450 <span class="comment">     Unused if this type does not have virtual functions.</span>
<a name="l00451"></a>00451 <span class="comment"></span>
<a name="l00452"></a>00452 <span class="comment">     This field appears at this location because it packs nicely here.  */</span>
<a name="l00453"></a>00453 
<a name="l00454"></a><a class="code" href="structmain__type.html#ae0594d1eacfd617b6b3ae4afd1595a19">00454</a>   <span class="keywordtype">short</span> <a class="code" href="structmain__type.html#ae0594d1eacfd617b6b3ae4afd1595a19">vptr_fieldno</a>;
<a name="l00455"></a>00455 
<a name="l00456"></a>00456   <span class="comment">/* Name of this type, or NULL if none.</span>
<a name="l00457"></a>00457 <span class="comment"></span>
<a name="l00458"></a>00458 <span class="comment">     This is used for printing only, except by poorly designed C++ code.</span>
<a name="l00459"></a>00459 <span class="comment">     For looking up a name, look for a symbol in the VAR_DOMAIN.</span>
<a name="l00460"></a>00460 <span class="comment">     This is generally allocated in the objfile&#39;s obstack.</span>
<a name="l00461"></a>00461 <span class="comment">     However coffread.c uses malloc.  */</span>
<a name="l00462"></a>00462 
<a name="l00463"></a><a class="code" href="structmain__type.html#ac6545878d5e92b3dfdc799e3980e5b6e">00463</a>   <a class="code" href="p-lang_8h.html#a21296fc6f36ba2fc4d9780fdd126acb5">const</a> <span class="keywordtype">char</span> *<a class="code" href="structmain__type.html#ac6545878d5e92b3dfdc799e3980e5b6e">name</a>;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465   <span class="comment">/* Tag name for this type, or NULL if none.  This means that the</span>
<a name="l00466"></a>00466 <span class="comment">     name of the type consists of a keyword followed by the tag name.</span>
<a name="l00467"></a>00467 <span class="comment">     Which keyword is determined by the type code (&quot;struct&quot; for</span>
<a name="l00468"></a>00468 <span class="comment">     TYPE_CODE_STRUCT, etc.).  As far as I know C/C++ are the only languages</span>
<a name="l00469"></a>00469 <span class="comment">     with this feature.</span>
<a name="l00470"></a>00470 <span class="comment"></span>
<a name="l00471"></a>00471 <span class="comment">     This is used for printing only, except by poorly designed C++ code.</span>
<a name="l00472"></a>00472 <span class="comment">     For looking up a name, look for a symbol in the STRUCT_DOMAIN.</span>
<a name="l00473"></a>00473 <span class="comment">     One more legitimate use is that if TYPE_FLAG_STUB is set, this is</span>
<a name="l00474"></a>00474 <span class="comment">     the name to use to look for definitions in other files.  */</span>
<a name="l00475"></a>00475 
<a name="l00476"></a><a class="code" href="structmain__type.html#a7c054234381509e5b9b7bef3254ffdd1">00476</a>   <a class="code" href="p-lang_8h.html#a21296fc6f36ba2fc4d9780fdd126acb5">const</a> <span class="keywordtype">char</span> *<a class="code" href="structmain__type.html#a7c054234381509e5b9b7bef3254ffdd1">tag_name</a>;
<a name="l00477"></a>00477 
<a name="l00478"></a>00478   <span class="comment">/* Every type is now associated with a particular objfile, and the</span>
<a name="l00479"></a>00479 <span class="comment">     type is allocated on the objfile_obstack for that objfile.  One problem</span>
<a name="l00480"></a>00480 <span class="comment">     however, is that there are times when gdb allocates new types while</span>
<a name="l00481"></a>00481 <span class="comment">     it is not in the process of reading symbols from a particular objfile.</span>
<a name="l00482"></a>00482 <span class="comment">     Fortunately, these happen when the type being created is a derived</span>
<a name="l00483"></a>00483 <span class="comment">     type of an existing type, such as in lookup_pointer_type().  So</span>
<a name="l00484"></a>00484 <span class="comment">     we can just allocate the new type using the same objfile as the</span>
<a name="l00485"></a>00485 <span class="comment">     existing type, but to do this we need a backpointer to the objfile</span>
<a name="l00486"></a>00486 <span class="comment">     from the existing type.  Yes this is somewhat ugly, but without</span>
<a name="l00487"></a>00487 <span class="comment">     major overhaul of the internal type system, it can&#39;t be avoided</span>
<a name="l00488"></a>00488 <span class="comment">     for now.  */</span>
<a name="l00489"></a>00489 
<a name="l00490"></a><a class="code" href="unionmain__type_1_1type__owner.html">00490</a>   union <a class="code" href="unionmain__type_1_1type__owner.html">type_owner</a>
<a name="l00491"></a>00491     {
<a name="l00492"></a><a class="code" href="unionmain__type_1_1type__owner.html#a8ebc54151bed83c88606c2176a642deb">00492</a>       <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="unionmain__type_1_1type__owner.html#a8ebc54151bed83c88606c2176a642deb">objfile</a>;
<a name="l00493"></a><a class="code" href="unionmain__type_1_1type__owner.html#a7385b6f5e57e22aa07031f5e879eab0b">00493</a>       <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="unionmain__type_1_1type__owner.html#a7385b6f5e57e22aa07031f5e879eab0b">gdbarch</a>;
<a name="l00494"></a>00494     } <a class="code" href="structmain__type.html#ac51ee0a5b744345485bc3c84caa087df">owner</a>;
<a name="l00495"></a>00495 
<a name="l00496"></a>00496   <span class="comment">/* For a pointer type, describes the type of object pointed to.</span>
<a name="l00497"></a>00497 <span class="comment">     For an array type, describes the type of the elements.</span>
<a name="l00498"></a>00498 <span class="comment">     For a function or method type, describes the type of the return value.</span>
<a name="l00499"></a>00499 <span class="comment">     For a range type, describes the type of the full range.</span>
<a name="l00500"></a>00500 <span class="comment">     For a complex type, describes the type of each coordinate.</span>
<a name="l00501"></a>00501 <span class="comment">     For a special record or union type encoding a dynamic-sized type</span>
<a name="l00502"></a>00502 <span class="comment">     in GNAT, a memoized pointer to a corresponding static version of</span>
<a name="l00503"></a>00503 <span class="comment">     the type.</span>
<a name="l00504"></a>00504 <span class="comment">     Unused otherwise.  */</span>
<a name="l00505"></a>00505 
<a name="l00506"></a><a class="code" href="structmain__type.html#a08105ec9a2e9d6b7a0008cb01ccc3a80">00506</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structmain__type.html#a08105ec9a2e9d6b7a0008cb01ccc3a80">target_type</a>;
<a name="l00507"></a>00507 
<a name="l00508"></a>00508   <span class="comment">/* For structure and union types, a description of each field.</span>
<a name="l00509"></a>00509 <span class="comment">     For set and pascal array types, there is one &quot;field&quot;,</span>
<a name="l00510"></a>00510 <span class="comment">     whose type is the domain type of the set or array.</span>
<a name="l00511"></a>00511 <span class="comment">     For range types, there are two &quot;fields&quot;,</span>
<a name="l00512"></a>00512 <span class="comment">     the minimum and maximum values (both inclusive).</span>
<a name="l00513"></a>00513 <span class="comment">     For enum types, each possible value is described by one &quot;field&quot;.</span>
<a name="l00514"></a>00514 <span class="comment">     For a function or method type, a &quot;field&quot; for each parameter.</span>
<a name="l00515"></a>00515 <span class="comment">     For C++ classes, there is one field for each base class (if it is</span>
<a name="l00516"></a>00516 <span class="comment">     a derived class) plus one field for each class data member.  Member</span>
<a name="l00517"></a>00517 <span class="comment">     functions are recorded elsewhere.</span>
<a name="l00518"></a>00518 <span class="comment"></span>
<a name="l00519"></a>00519 <span class="comment">     Using a pointer to a separate array of fields</span>
<a name="l00520"></a>00520 <span class="comment">     allows all types to have the same size, which is useful</span>
<a name="l00521"></a>00521 <span class="comment">     because we can allocate the space for a type before</span>
<a name="l00522"></a>00522 <span class="comment">     we know what to put in it.  */</span>
<a name="l00523"></a>00523 
<a name="l00524"></a>00524   <span class="keyword">union </span>
<a name="l00525"></a>00525   {
<a name="l00526"></a>00526     <span class="keyword">struct </span>field
<a name="l00527"></a>00527     {
<a name="l00528"></a>00528       <span class="keyword">union </span>field_location
<a name="l00529"></a>00529       {
<a name="l00530"></a>00530         <span class="comment">/* Position of this field, counting in bits from start of</span>
<a name="l00531"></a>00531 <span class="comment">           containing structure.  For gdbarch_bits_big_endian=1</span>
<a name="l00532"></a>00532 <span class="comment">           targets, it is the bit offset to the MSB.  For</span>
<a name="l00533"></a>00533 <span class="comment">           gdbarch_bits_big_endian=0 targets, it is the bit offset to</span>
<a name="l00534"></a>00534 <span class="comment">           the LSB.  */</span>
<a name="l00535"></a>00535 
<a name="l00536"></a><a class="code" href="structmain__type.html#a12a99669f6e1e5b4360fb6423658d497">00536</a>         <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a12a99669f6e1e5b4360fb6423658d497">bitpos</a>;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538         <span class="comment">/* Enum value.  */</span>
<a name="l00539"></a><a class="code" href="structmain__type.html#a1e3c02457b3e85d2612214dfbc3d930d">00539</a>         <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="structmain__type.html#a1e3c02457b3e85d2612214dfbc3d930d">enumval</a>;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541         <span class="comment">/* For a static field, if TYPE_FIELD_STATIC_HAS_ADDR then physaddr</span>
<a name="l00542"></a>00542 <span class="comment">           is the location (in the target) of the static field.</span>
<a name="l00543"></a>00543 <span class="comment">           Otherwise, physname is the mangled label of the static field.  */</span>
<a name="l00544"></a>00544 
<a name="l00545"></a><a class="code" href="structmain__type.html#aad097fc8230f418cb4ddfc39e75197b5">00545</a>         <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structmain__type.html#aad097fc8230f418cb4ddfc39e75197b5">physaddr</a>;
<a name="l00546"></a><a class="code" href="structmain__type.html#a0fc5935d90b1985ff115b8dacb8d2b56">00546</a>         <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structmain__type.html#a0fc5935d90b1985ff115b8dacb8d2b56">physname</a>;
<a name="l00547"></a>00547 
<a name="l00548"></a>00548         <span class="comment">/* The field location can be computed by evaluating the following DWARF</span>
<a name="l00549"></a>00549 <span class="comment">           block.  Its DATA is allocated on objfile_obstack - no CU load is</span>
<a name="l00550"></a>00550 <span class="comment">           needed to access it.  */</span>
<a name="l00551"></a>00551 
<a name="l00552"></a><a class="code" href="structmain__type.html#ace173cc4805ef122fafa458d9d4cf043">00552</a>         <span class="keyword">struct </span><a class="code" href="structdwarf2__locexpr__baton.html">dwarf2_locexpr_baton</a> *<a class="code" href="structmain__type.html#ace173cc4805ef122fafa458d9d4cf043">dwarf_block</a>;
<a name="l00553"></a>00553       }
<a name="l00554"></a>00554       <a class="code" href="structmain__type.html#a9113423c837b4868e46cb015ea351738">loc</a>;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556       <span class="comment">/* For a function or member type, this is 1 if the argument is marked</span>
<a name="l00557"></a>00557 <span class="comment">         artificial.  Artificial arguments should not be shown to the</span>
<a name="l00558"></a>00558 <span class="comment">         user.  For TYPE_CODE_RANGE it is set if the specific bound is not</span>
<a name="l00559"></a>00559 <span class="comment">         defined.  */</span>
<a name="l00560"></a><a class="code" href="structmain__type.html#a27b5700196425fc77a9ea4852cbd0cbe">00560</a>       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a27b5700196425fc77a9ea4852cbd0cbe">artificial</a> : 1;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562       <span class="comment">/* Discriminant for union field_location.  */</span>
<a name="l00563"></a><a class="code" href="structmain__type.html#a70e5fddb92ac13bb66a20c778d37cb48">00563</a>       ENUM_BITFIELD(<a class="code" href="gdbtypes_8h.html#a3eb0e1253afc7850dc90da0d4ba5b487">field_loc_kind</a>) loc_kind : 3;
<a name="l00564"></a>00564 
<a name="l00565"></a>00565       <span class="comment">/* Size of this field, in bits, or zero if not packed.</span>
<a name="l00566"></a>00566 <span class="comment">         If non-zero in an array type, indicates the element size in</span>
<a name="l00567"></a>00567 <span class="comment">         bits (used only in Ada at the moment).</span>
<a name="l00568"></a>00568 <span class="comment">         For an unpacked field, the field&#39;s type&#39;s length</span>
<a name="l00569"></a>00569 <span class="comment">         says how many bytes the field occupies.  */</span>
<a name="l00570"></a>00570 
<a name="l00571"></a>00571       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a70e5fddb92ac13bb66a20c778d37cb48">bitsize</a> : 28;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573       <span class="comment">/* In a struct or union type, type of this field.</span>
<a name="l00574"></a>00574 <span class="comment">         In a function or member type, type of this argument.</span>
<a name="l00575"></a>00575 <span class="comment">         In an array type, the domain-type of the array.  */</span>
<a name="l00576"></a>00576 
<a name="l00577"></a><a class="code" href="structmain__type.html#a0f82304f9be5128ce54cd566a3f533dd">00577</a>       struct <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>;
<a name="l00578"></a>00578 
<a name="l00579"></a>00579       <span class="comment">/* Name of field, value or argument.</span>
<a name="l00580"></a>00580 <span class="comment">         NULL for range bounds, array domains, and member function</span>
<a name="l00581"></a>00581 <span class="comment">         arguments.  */</span>
<a name="l00582"></a>00582 
<a name="l00583"></a>00583       <a class="code" href="p-lang_8h.html#a21296fc6f36ba2fc4d9780fdd126acb5">const</a> <span class="keywordtype">char</span> *<a class="code" href="structmain__type.html#ac6545878d5e92b3dfdc799e3980e5b6e">name</a>;
<a name="l00584"></a>00584     } *<a class="code" href="structmain__type.html#afb3acfddb9a96f5fe647e3054ce96aa9">fields</a>;
<a name="l00585"></a>00585 
<a name="l00586"></a>00586     <span class="comment">/* Union member used for range types.  */</span>
<a name="l00587"></a>00587 
<a name="l00588"></a>00588     struct range_bounds
<a name="l00589"></a>00589     {
<a name="l00590"></a>00590       <span class="comment">/* Low bound of range.  */</span>
<a name="l00591"></a>00591 
<a name="l00592"></a><a class="code" href="structmain__type.html#ac03456b92280b0eade37bec64fff157d">00592</a>       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="structmain__type.html#ac03456b92280b0eade37bec64fff157d">low</a>;
<a name="l00593"></a>00593 
<a name="l00594"></a>00594       <span class="comment">/* High bound of range.  */</span>
<a name="l00595"></a>00595 
<a name="l00596"></a><a class="code" href="structmain__type.html#ab5cf45ee1fa2f89a65b81ebbf3960607">00596</a>       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="structmain__type.html#ab5cf45ee1fa2f89a65b81ebbf3960607">high</a>;
<a name="l00597"></a>00597 
<a name="l00598"></a>00598       <span class="comment">/* Flags indicating whether the values of low and high are</span>
<a name="l00599"></a>00599 <span class="comment">         valid.  When true, the respective range value is</span>
<a name="l00600"></a>00600 <span class="comment">         undefined.  Currently used only for FORTRAN arrays.  */</span>
<a name="l00601"></a>00601            
<a name="l00602"></a><a class="code" href="structmain__type.html#a9d83a61b03808d51272a2e312dd6a330">00602</a>       <span class="keywordtype">char</span> <a class="code" href="structmain__type.html#a9d83a61b03808d51272a2e312dd6a330">low_undefined</a>;
<a name="l00603"></a><a class="code" href="structmain__type.html#a1e67f21934c84d88507104a835686023">00603</a>       <span class="keywordtype">char</span> <a class="code" href="structmain__type.html#a1e67f21934c84d88507104a835686023">high_undefined</a>;
<a name="l00604"></a>00604 
<a name="l00605"></a>00605     } *<a class="code" href="structmain__type.html#a79e95edf3f023ea1aa42ad166e14c547">bounds</a>;
<a name="l00606"></a>00606 
<a name="l00607"></a>00607   } <a class="code" href="structmain__type.html#afb402f3e746cb60c8acd1840fb3673f2">flds_bnds</a>;
<a name="l00608"></a>00608 
<a name="l00609"></a>00609   <span class="comment">/* For types with virtual functions (TYPE_CODE_STRUCT), VPTR_BASETYPE</span>
<a name="l00610"></a>00610 <span class="comment">     is the base class which defined the virtual function table pointer.  </span>
<a name="l00611"></a>00611 <span class="comment"></span>
<a name="l00612"></a>00612 <span class="comment">     For types that are pointer to member types (TYPE_CODE_METHODPTR,</span>
<a name="l00613"></a>00613 <span class="comment">     TYPE_CODE_MEMBERPTR), VPTR_BASETYPE is the type that this pointer</span>
<a name="l00614"></a>00614 <span class="comment">     is a member of.</span>
<a name="l00615"></a>00615 <span class="comment"></span>
<a name="l00616"></a>00616 <span class="comment">     For method types (TYPE_CODE_METHOD), VPTR_BASETYPE is the aggregate</span>
<a name="l00617"></a>00617 <span class="comment">     type that contains the method.</span>
<a name="l00618"></a>00618 <span class="comment"></span>
<a name="l00619"></a>00619 <span class="comment">     Unused otherwise.  */</span>
<a name="l00620"></a>00620 
<a name="l00621"></a><a class="code" href="structmain__type.html#aae17c5266c32644a57afa3e5a9a1631a">00621</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structmain__type.html#aae17c5266c32644a57afa3e5a9a1631a">vptr_basetype</a>;
<a name="l00622"></a>00622 
<a name="l00623"></a>00623   <span class="comment">/* Slot to point to additional language-specific fields of this type.  */</span>
<a name="l00624"></a>00624 
<a name="l00625"></a><a class="code" href="unionmain__type_1_1type__specific.html">00625</a>   <span class="keyword">union </span><a class="code" href="unionmain__type_1_1type__specific.html">type_specific</a>
<a name="l00626"></a>00626   {
<a name="l00627"></a>00627     <span class="comment">/* CPLUS_STUFF is for TYPE_CODE_STRUCT.  It is initialized to point to</span>
<a name="l00628"></a>00628 <span class="comment">       cplus_struct_default, a default static instance of a struct</span>
<a name="l00629"></a>00629 <span class="comment">       cplus_struct_type.  */</span>
<a name="l00630"></a>00630 
<a name="l00631"></a><a class="code" href="unionmain__type_1_1type__specific.html#a66604adcb33c525fcc6e015c383616de">00631</a>     <span class="keyword">struct </span><a class="code" href="structcplus__struct__type.html">cplus_struct_type</a> *<a class="code" href="unionmain__type_1_1type__specific.html#a66604adcb33c525fcc6e015c383616de">cplus_stuff</a>;
<a name="l00632"></a>00632 
<a name="l00633"></a>00633     <span class="comment">/* GNAT_STUFF is for types for which the GNAT Ada compiler</span>
<a name="l00634"></a>00634 <span class="comment">       provides additional information.  */</span>
<a name="l00635"></a><a class="code" href="unionmain__type_1_1type__specific.html#acabf22f848f583d25a38882f86fd7d27">00635</a>     <span class="keyword">struct </span><a class="code" href="structgnat__aux__type.html">gnat_aux_type</a> *<a class="code" href="unionmain__type_1_1type__specific.html#acabf22f848f583d25a38882f86fd7d27">gnat_stuff</a>;
<a name="l00636"></a>00636 
<a name="l00637"></a>00637     <span class="comment">/* FLOATFORMAT is for TYPE_CODE_FLT.  It is a pointer to two</span>
<a name="l00638"></a>00638 <span class="comment">       floatformat objects that describe the floating-point value</span>
<a name="l00639"></a>00639 <span class="comment">       that resides within the type.  The first is for big endian</span>
<a name="l00640"></a>00640 <span class="comment">       targets and the second is for little endian targets.  */</span>
<a name="l00641"></a>00641 
<a name="l00642"></a><a class="code" href="unionmain__type_1_1type__specific.html#a674f3948d35c2f35c91d91f2ca3eba35">00642</a>     <span class="keyword">const</span> <span class="keyword">struct </span>floatformat **<a class="code" href="unionmain__type_1_1type__specific.html#a674f3948d35c2f35c91d91f2ca3eba35">floatformat</a>;
<a name="l00643"></a>00643 
<a name="l00644"></a>00644     <span class="comment">/* For TYPE_CODE_FUNC types,  */</span>
<a name="l00645"></a><a class="code" href="unionmain__type_1_1type__specific.html#a2de3781798bbc0b2ae332e6b0d123b30">00645</a>     <span class="keyword">struct </span><a class="code" href="structfunc__type.html">func_type</a> *<a class="code" href="unionmain__type_1_1type__specific.html#a2de3781798bbc0b2ae332e6b0d123b30">func_stuff</a>;
<a name="l00646"></a>00646   } <a class="code" href="structmain__type.html#a8b9bfa74a58e306c6264d35507ef5a03">type_specific</a>;
<a name="l00647"></a>00647 };
<a name="l00648"></a>00648 
<a name="l00649"></a>00649 <span class="comment">/* A ``struct type&#39;&#39; describes a particular instance of a type, with</span>
<a name="l00650"></a>00650 <span class="comment">   some particular qualification.  */</span>
<a name="l00651"></a><a class="code" href="structtype.html">00651</a> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a>
<a name="l00652"></a>00652 {
<a name="l00653"></a>00653   <span class="comment">/* Type that is a pointer to this type.</span>
<a name="l00654"></a>00654 <span class="comment">     NULL if no such pointer-to type is known yet.</span>
<a name="l00655"></a>00655 <span class="comment">     The debugger may add the address of such a type</span>
<a name="l00656"></a>00656 <span class="comment">     if it has to construct one later.  */</span>
<a name="l00657"></a>00657 
<a name="l00658"></a><a class="code" href="structtype.html#a7c74f95fc408f02013d4a5e812b71395">00658</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html#a7c74f95fc408f02013d4a5e812b71395">pointer_type</a>;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660   <span class="comment">/* C++: also need a reference type.  */</span>
<a name="l00661"></a>00661 
<a name="l00662"></a><a class="code" href="structtype.html#ac5c75abe04bd3163dd9169cdcdd8795d">00662</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html#ac5c75abe04bd3163dd9169cdcdd8795d">reference_type</a>;
<a name="l00663"></a>00663 
<a name="l00664"></a>00664   <span class="comment">/* Variant chain.  This points to a type that differs from this one only</span>
<a name="l00665"></a>00665 <span class="comment">     in qualifiers and length.  Currently, the possible qualifiers are</span>
<a name="l00666"></a>00666 <span class="comment">     const, volatile, code-space, data-space, and address class.  The</span>
<a name="l00667"></a>00667 <span class="comment">     length may differ only when one of the address class flags are set.</span>
<a name="l00668"></a>00668 <span class="comment">     The variants are linked in a circular ring and share MAIN_TYPE.  */</span>
<a name="l00669"></a><a class="code" href="structtype.html#a95d3c2101fbf183aac55976a1a9a378a">00669</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html#a95d3c2101fbf183aac55976a1a9a378a">chain</a>;
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   <span class="comment">/* Flags specific to this instance of the type, indicating where</span>
<a name="l00672"></a>00672 <span class="comment">     on the ring we are.</span>
<a name="l00673"></a>00673 <span class="comment"></span>
<a name="l00674"></a>00674 <span class="comment">     For TYPE_CODE_TYPEDEF the flags of the typedef type should be binary</span>
<a name="l00675"></a>00675 <span class="comment">     or-ed with the target type, with a special case for address class and</span>
<a name="l00676"></a>00676 <span class="comment">     space class.  For example if this typedef does not specify any new</span>
<a name="l00677"></a>00677 <span class="comment">     qualifiers, TYPE_INSTANCE_FLAGS is 0 and the instance flags are</span>
<a name="l00678"></a>00678 <span class="comment">     completely inherited from the target type.  No qualifiers can be cleared</span>
<a name="l00679"></a>00679 <span class="comment">     by the typedef.  See also check_typedef.  */</span>
<a name="l00680"></a><a class="code" href="structtype.html#a198f022be9a1967526e9242198f27474">00680</a>   <span class="keywordtype">int</span> <a class="code" href="structtype.html#a198f022be9a1967526e9242198f27474">instance_flags</a>;
<a name="l00681"></a>00681 
<a name="l00682"></a>00682   <span class="comment">/* Length of storage for a value of this type.  This is what</span>
<a name="l00683"></a>00683 <span class="comment">     sizeof(type) would return; use it for address arithmetic,</span>
<a name="l00684"></a>00684 <span class="comment">     memory reads and writes, etc.  This size includes padding.  For</span>
<a name="l00685"></a>00685 <span class="comment">     example, an i386 extended-precision floating point value really</span>
<a name="l00686"></a>00686 <span class="comment">     only occupies ten bytes, but most ABI&#39;s declare its size to be</span>
<a name="l00687"></a>00687 <span class="comment">     12 bytes, to preserve alignment.  A `struct type&#39; representing</span>
<a name="l00688"></a>00688 <span class="comment">     such a floating-point type would have a `length&#39; value of 12,</span>
<a name="l00689"></a>00689 <span class="comment">     even though the last two bytes are unused.</span>
<a name="l00690"></a>00690 <span class="comment"></span>
<a name="l00691"></a>00691 <span class="comment">     There&#39;s a bit of a host/target mess here, if you&#39;re concerned</span>
<a name="l00692"></a>00692 <span class="comment">     about machines whose bytes aren&#39;t eight bits long, or who don&#39;t</span>
<a name="l00693"></a>00693 <span class="comment">     have byte-addressed memory.  Various places pass this to memcpy</span>
<a name="l00694"></a>00694 <span class="comment">     and such, meaning it must be in units of host bytes.  Various</span>
<a name="l00695"></a>00695 <span class="comment">     other places expect they can calculate addresses by adding it</span>
<a name="l00696"></a>00696 <span class="comment">     and such, meaning it must be in units of target bytes.  For</span>
<a name="l00697"></a>00697 <span class="comment">     some DSP targets, in which HOST_CHAR_BIT will (presumably) be 8</span>
<a name="l00698"></a>00698 <span class="comment">     and TARGET_CHAR_BIT will be (say) 32, this is a problem.</span>
<a name="l00699"></a>00699 <span class="comment"></span>
<a name="l00700"></a>00700 <span class="comment">     One fix would be to make this field in bits (requiring that it</span>
<a name="l00701"></a>00701 <span class="comment">     always be a multiple of HOST_CHAR_BIT and TARGET_CHAR_BIT) ---</span>
<a name="l00702"></a>00702 <span class="comment">     the other choice would be to make it consistently in units of</span>
<a name="l00703"></a>00703 <span class="comment">     HOST_CHAR_BIT.  However, this would still fail to address</span>
<a name="l00704"></a>00704 <span class="comment">     machines based on a ternary or decimal representation.  */</span>
<a name="l00705"></a>00705   
<a name="l00706"></a><a class="code" href="structtype.html#a73598608f0395a10828a7f69cb843d70">00706</a>   <span class="keywordtype">unsigned</span> <a class="code" href="structtype.html#a73598608f0395a10828a7f69cb843d70">length</a>;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708   <span class="comment">/* Core type, shared by a group of qualified types.  */</span>
<a name="l00709"></a><a class="code" href="structtype.html#a3887777864d74411d6e6c39c9a4bc2f4">00709</a>   <span class="keyword">struct </span><a class="code" href="structmain__type.html">main_type</a> *<a class="code" href="structtype.html#a3887777864d74411d6e6c39c9a4bc2f4">main_type</a>;
<a name="l00710"></a>00710 };
<a name="l00711"></a>00711 
<a name="l00712"></a><a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">00712</a> <span class="preprocessor">#define NULL_TYPE ((struct type *) 0)</span>
<a name="l00713"></a>00713 <span class="preprocessor"></span>
<a name="l00714"></a>00714 <span class="comment">/* C++ language-specific information for TYPE_CODE_STRUCT and TYPE_CODE_UNION</span>
<a name="l00715"></a>00715 <span class="comment">   nodes.  */</span>
<a name="l00716"></a>00716 
<a name="l00717"></a><a class="code" href="structcplus__struct__type.html">00717</a> <span class="keyword">struct </span><a class="code" href="structcplus__struct__type.html">cplus_struct_type</a>
<a name="l00718"></a>00718   {
<a name="l00719"></a>00719     <span class="comment">/* Number of base classes this type derives from.  The baseclasses are</span>
<a name="l00720"></a>00720 <span class="comment">       stored in the first N_BASECLASSES fields (i.e. the `fields&#39; field of</span>
<a name="l00721"></a>00721 <span class="comment">       the struct type).  I think only the `type&#39; field of such a field has</span>
<a name="l00722"></a>00722 <span class="comment">       any meaning.  */</span>
<a name="l00723"></a>00723 
<a name="l00724"></a><a class="code" href="structcplus__struct__type.html#a215e9f1ef74fd86f208f56d48a1500cf">00724</a>     <span class="keywordtype">short</span> <a class="code" href="structcplus__struct__type.html#a215e9f1ef74fd86f208f56d48a1500cf">n_baseclasses</a>;
<a name="l00725"></a>00725 
<a name="l00726"></a>00726     <span class="comment">/* Number of methods with unique names.  All overloaded methods with</span>
<a name="l00727"></a>00727 <span class="comment">       the same name count only once.  */</span>
<a name="l00728"></a>00728 
<a name="l00729"></a><a class="code" href="structcplus__struct__type.html#a23177c271aca7903eea58895089cfe75">00729</a>     <span class="keywordtype">short</span> <a class="code" href="structcplus__struct__type.html#a23177c271aca7903eea58895089cfe75">nfn_fields</a>;
<a name="l00730"></a>00730 
<a name="l00731"></a>00731     <span class="comment">/* Number of template arguments.  */</span>
<a name="l00732"></a><a class="code" href="structcplus__struct__type.html#abb2428d7402fe56a791f395f3b59924d">00732</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="structcplus__struct__type.html#abb2428d7402fe56a791f395f3b59924d">n_template_arguments</a>;
<a name="l00733"></a>00733 
<a name="l00734"></a>00734     <span class="comment">/* One if this struct is a dynamic class, as defined by the</span>
<a name="l00735"></a>00735 <span class="comment">       Itanium C++ ABI: if it requires a virtual table pointer,</span>
<a name="l00736"></a>00736 <span class="comment">       because it or any of its base classes have one or more virtual</span>
<a name="l00737"></a>00737 <span class="comment">       member functions or virtual base classes.  Minus one if not</span>
<a name="l00738"></a>00738 <span class="comment">       dynamic.  Zero if not yet computed.  */</span>
<a name="l00739"></a><a class="code" href="structcplus__struct__type.html#adb914178c4e1b1c41cd6b9228931b291">00739</a>     <span class="keywordtype">int</span> is_dynamic : 2;
<a name="l00740"></a>00740 
<a name="l00741"></a>00741     <span class="comment">/* Non-zero if this type came from a Java CU.  */</span>
<a name="l00742"></a><a class="code" href="structcplus__struct__type.html#a7e7a4e787f36b0be43c37a8f3588f728">00742</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_java : 1;
<a name="l00743"></a>00743 
<a name="l00744"></a>00744     <span class="comment">/* For derived classes, the number of base classes is given by</span>
<a name="l00745"></a>00745 <span class="comment">       n_baseclasses and virtual_field_bits is a bit vector containing</span>
<a name="l00746"></a>00746 <span class="comment">       one bit per base class.  If the base class is virtual, the</span>
<a name="l00747"></a>00747 <span class="comment">       corresponding bit will be set.</span>
<a name="l00748"></a>00748 <span class="comment">       I.E, given:</span>
<a name="l00749"></a>00749 <span class="comment"></span>
<a name="l00750"></a>00750 <span class="comment">       class A{};</span>
<a name="l00751"></a>00751 <span class="comment">       class B{};</span>
<a name="l00752"></a>00752 <span class="comment">       class C : public B, public virtual A {};</span>
<a name="l00753"></a>00753 <span class="comment"></span>
<a name="l00754"></a>00754 <span class="comment">       B is a baseclass of C; A is a virtual baseclass for C.</span>
<a name="l00755"></a>00755 <span class="comment">       This is a C++ 2.0 language feature.  */</span>
<a name="l00756"></a>00756 
<a name="l00757"></a><a class="code" href="structcplus__struct__type.html#a8a0336bc378ff6d1b89de64bd62273f1">00757</a>     <a class="code" href="gdbtypes_8h.html#a4a576bae886fea0085ee73676f852bb8">B_TYPE</a> *<a class="code" href="structcplus__struct__type.html#a8a0336bc378ff6d1b89de64bd62273f1">virtual_field_bits</a>;
<a name="l00758"></a>00758 
<a name="l00759"></a>00759     <span class="comment">/* For classes with private fields, the number of fields is given by</span>
<a name="l00760"></a>00760 <span class="comment">       nfields and private_field_bits is a bit vector containing one bit</span>
<a name="l00761"></a>00761 <span class="comment">       per field.</span>
<a name="l00762"></a>00762 <span class="comment">       If the field is private, the corresponding bit will be set.  */</span>
<a name="l00763"></a>00763 
<a name="l00764"></a><a class="code" href="structcplus__struct__type.html#ab95367d9c1ceb96667db236ebc6c4daf">00764</a>     <a class="code" href="gdbtypes_8h.html#a4a576bae886fea0085ee73676f852bb8">B_TYPE</a> *<a class="code" href="structcplus__struct__type.html#ab95367d9c1ceb96667db236ebc6c4daf">private_field_bits</a>;
<a name="l00765"></a>00765 
<a name="l00766"></a>00766     <span class="comment">/* For classes with protected fields, the number of fields is given by</span>
<a name="l00767"></a>00767 <span class="comment">       nfields and protected_field_bits is a bit vector containing one bit</span>
<a name="l00768"></a>00768 <span class="comment">       per field.</span>
<a name="l00769"></a>00769 <span class="comment">       If the field is private, the corresponding bit will be set.  */</span>
<a name="l00770"></a>00770 
<a name="l00771"></a><a class="code" href="structcplus__struct__type.html#adab69e927951ec7ee98e9a8171a196df">00771</a>     <a class="code" href="gdbtypes_8h.html#a4a576bae886fea0085ee73676f852bb8">B_TYPE</a> *<a class="code" href="structcplus__struct__type.html#adab69e927951ec7ee98e9a8171a196df">protected_field_bits</a>;
<a name="l00772"></a>00772 
<a name="l00773"></a>00773     <span class="comment">/* For classes with fields to be ignored, either this is optimized out</span>
<a name="l00774"></a>00774 <span class="comment">       or this field has length 0.  */</span>
<a name="l00775"></a>00775 
<a name="l00776"></a><a class="code" href="structcplus__struct__type.html#af3fd1f11c40b2c3d9fef5a0e29ab17c1">00776</a>     <a class="code" href="gdbtypes_8h.html#a4a576bae886fea0085ee73676f852bb8">B_TYPE</a> *<a class="code" href="structcplus__struct__type.html#af3fd1f11c40b2c3d9fef5a0e29ab17c1">ignore_field_bits</a>;
<a name="l00777"></a>00777 
<a name="l00778"></a>00778     <span class="comment">/* For classes, structures, and unions, a description of each field,</span>
<a name="l00779"></a>00779 <span class="comment">       which consists of an overloaded name, followed by the types of</span>
<a name="l00780"></a>00780 <span class="comment">       arguments that the method expects, and then the name after it</span>
<a name="l00781"></a>00781 <span class="comment">       has been renamed to make it distinct.</span>
<a name="l00782"></a>00782 <span class="comment"></span>
<a name="l00783"></a>00783 <span class="comment">       fn_fieldlists points to an array of nfn_fields of these.  */</span>
<a name="l00784"></a>00784 
<a name="l00785"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist.html">00785</a>     <span class="keyword">struct </span><a class="code" href="structcplus__struct__type_1_1fn__fieldlist.html">fn_fieldlist</a>
<a name="l00786"></a>00786       {
<a name="l00787"></a>00787 
<a name="l00788"></a>00788         <span class="comment">/* The overloaded name.</span>
<a name="l00789"></a>00789 <span class="comment">           This is generally allocated in the objfile&#39;s obstack.</span>
<a name="l00790"></a>00790 <span class="comment">           However stabsread.c sometimes uses malloc.  */</span>
<a name="l00791"></a>00791 
<a name="l00792"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist.html#af8eef0903c5313ab7986af5f1f63dba2">00792</a>         <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structcplus__struct__type_1_1fn__fieldlist.html#af8eef0903c5313ab7986af5f1f63dba2">name</a>;
<a name="l00793"></a>00793 
<a name="l00794"></a>00794         <span class="comment">/* The number of methods with this name.  */</span>
<a name="l00795"></a>00795 
<a name="l00796"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist.html#a3d11576985e58ae0da3da31092172f13">00796</a>         <span class="keywordtype">int</span> <a class="code" href="structcplus__struct__type_1_1fn__fieldlist.html#a3d11576985e58ae0da3da31092172f13">length</a>;
<a name="l00797"></a>00797 
<a name="l00798"></a>00798         <span class="comment">/* The list of methods.  */</span>
<a name="l00799"></a>00799 
<a name="l00800"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html">00800</a>         <span class="keyword">struct </span><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html">fn_field</a>
<a name="l00801"></a>00801           {
<a name="l00802"></a>00802 
<a name="l00803"></a>00803             <span class="comment">/* If is_stub is clear, this is the mangled name which we can</span>
<a name="l00804"></a>00804 <span class="comment">               look up to find the address of the method (FIXME: it would</span>
<a name="l00805"></a>00805 <span class="comment">               be cleaner to have a pointer to the struct symbol here</span>
<a name="l00806"></a>00806 <span class="comment">               instead).  */</span>
<a name="l00807"></a>00807 
<a name="l00808"></a>00808             <span class="comment">/* If is_stub is set, this is the portion of the mangled</span>
<a name="l00809"></a>00809 <span class="comment">               name which specifies the arguments.  For example, &quot;ii&quot;,</span>
<a name="l00810"></a>00810 <span class="comment">               if there are two int arguments, or &quot;&quot; if there are no</span>
<a name="l00811"></a>00811 <span class="comment">               arguments.  See gdb_mangle_name for the conversion from this</span>
<a name="l00812"></a>00812 <span class="comment">               format to the one used if is_stub is clear.  */</span>
<a name="l00813"></a>00813 
<a name="l00814"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a03fe21e36f46a7439b1f48ef64fc8599">00814</a>             <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a03fe21e36f46a7439b1f48ef64fc8599">physname</a>;
<a name="l00815"></a>00815 
<a name="l00816"></a>00816             <span class="comment">/* The function type for the method.</span>
<a name="l00817"></a>00817 <span class="comment">               (This comment used to say &quot;The return value of the method&quot;,</span>
<a name="l00818"></a>00818 <span class="comment">               but that&#39;s wrong.  The function type </span>
<a name="l00819"></a>00819 <span class="comment">               is expected here, i.e. something with TYPE_CODE_FUNC,</span>
<a name="l00820"></a>00820 <span class="comment">               and *not* the return-value type).  */</span>
<a name="l00821"></a>00821 
<a name="l00822"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a046bc6666acbafe3deb57f7bed0f3fc2">00822</a>             <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a046bc6666acbafe3deb57f7bed0f3fc2">type</a>;
<a name="l00823"></a>00823 
<a name="l00824"></a>00824             <span class="comment">/* For virtual functions.</span>
<a name="l00825"></a>00825 <span class="comment">               First baseclass that defines this virtual function.  */</span>
<a name="l00826"></a>00826 
<a name="l00827"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#adc333434555fefb9850b7806c58a74a2">00827</a>             <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#adc333434555fefb9850b7806c58a74a2">fcontext</a>;
<a name="l00828"></a>00828 
<a name="l00829"></a>00829             <span class="comment">/* Attributes.  */</span>
<a name="l00830"></a>00830 
<a name="l00831"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#ae2f9387be0bd57d8efd26495bba7a513">00831</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_const:1;
<a name="l00832"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a057491b5df8b36bcd50068e9330832b8">00832</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_volatile:1;
<a name="l00833"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a000c0d0ef31e78e781ee7a7c6aa89bdb">00833</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_private:1;
<a name="l00834"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#aaf6de908dbb5917bdf253a0523204cf1">00834</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_protected:1;
<a name="l00835"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#ac153b737fb8c37b7fac30745f46ab87a">00835</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_public:1;
<a name="l00836"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a4e1d0e3e8bf66cb261ac36ce393af198">00836</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_abstract:1;
<a name="l00837"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a84285f7049fc9d3372e471888ad6ef55">00837</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_static:1;
<a name="l00838"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a3350dbfbbad51a189be577c00c0d7460">00838</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_final:1;
<a name="l00839"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a2051ef766736b88b87cb6a6f875325fc">00839</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_synchronized:1;
<a name="l00840"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a3aece68604b843d8bb55884d95e9ba3e">00840</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_native:1;
<a name="l00841"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a16bf647e27b8b48fbb1acb5caa8d1032">00841</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_artificial:1;
<a name="l00842"></a>00842 
<a name="l00843"></a>00843             <span class="comment">/* A stub method only has some fields valid (but they are enough</span>
<a name="l00844"></a>00844 <span class="comment">               to reconstruct the rest of the fields).  */</span>
<a name="l00845"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a5ff8953eaaa9b983741646702ad86ab0">00845</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is_stub:1;
<a name="l00846"></a>00846 
<a name="l00847"></a>00847             <span class="comment">/* True if this function is a constructor, false</span>
<a name="l00848"></a>00848 <span class="comment">               otherwise.  */</span>
<a name="l00849"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a45ddc32b6a4af0ec3817116729a39d18">00849</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacecleanup__check.html#affbc9beede7a62b1ea0bc0fe0a642ca1">is_constructor</a> : 1;
<a name="l00850"></a>00850 
<a name="l00851"></a>00851             <span class="comment">/* Unused.  */</span>
<a name="l00852"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#ad2ae7a184c89f059b447d458f7838a3e">00852</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a36fb645a916cd19d79712e75c47b8d03">dummy</a>:3;
<a name="l00853"></a>00853 
<a name="l00854"></a>00854             <span class="comment">/* Index into that baseclass&#39;s virtual function table,</span>
<a name="l00855"></a>00855 <span class="comment">               minus 2; else if static: VOFFSET_STATIC; else: 0.  */</span>
<a name="l00856"></a>00856 
<a name="l00857"></a><a class="code" href="structcplus__struct__type_1_1fn__fieldlist_1_1fn__field.html#a56aa12971d8d0c5a8f1e034a0534c703">00857</a>             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> voffset:16;
<a name="l00858"></a>00858 
<a name="l00859"></a><a class="code" href="gdbtypes_8h.html#a85e928e0e3afd7fddf0557087312c663">00859</a> <span class="preprocessor">#define VOFFSET_STATIC 1</span>
<a name="l00860"></a>00860 <span class="preprocessor"></span>
<a name="l00861"></a>00861           }
<a name="l00862"></a>00862          *fn_fields;
<a name="l00863"></a>00863 
<a name="l00864"></a>00864       }
<a name="l00865"></a>00865      *fn_fieldlists;
<a name="l00866"></a>00866 
<a name="l00867"></a>00867     <span class="comment">/* typedefs defined inside this class.  TYPEDEF_FIELD points to an array of</span>
<a name="l00868"></a>00868 <span class="comment">       TYPEDEF_FIELD_COUNT elements.  */</span>
<a name="l00869"></a><a class="code" href="structcplus__struct__type_1_1typedef__field.html">00869</a>     <span class="keyword">struct </span><a class="code" href="structcplus__struct__type_1_1typedef__field.html">typedef_field</a>
<a name="l00870"></a>00870       {
<a name="l00871"></a>00871         <span class="comment">/* Unqualified name to be prefixed by owning class qualified name.  */</span>
<a name="l00872"></a><a class="code" href="structcplus__struct__type_1_1typedef__field.html#a784280c49b9dbce387259c2e70e03a8a">00872</a>         <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structcplus__struct__type_1_1typedef__field.html#a784280c49b9dbce387259c2e70e03a8a">name</a>;
<a name="l00873"></a>00873 
<a name="l00874"></a>00874         <span class="comment">/* Type this typedef named NAME represents.  */</span>
<a name="l00875"></a><a class="code" href="structcplus__struct__type_1_1typedef__field.html#a521273e645d6cf7b80781351ee3daaa0">00875</a>         <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structcplus__struct__type_1_1typedef__field.html#a521273e645d6cf7b80781351ee3daaa0">type</a>;
<a name="l00876"></a>00876       }
<a name="l00877"></a>00877     *<a class="code" href="structcplus__struct__type_1_1typedef__field.html">typedef_field</a>;
<a name="l00878"></a><a class="code" href="structcplus__struct__type.html#a597dc2e64c17527c46c5af37ded73314">00878</a>     <span class="keywordtype">unsigned</span> <a class="code" href="structcplus__struct__type.html#a597dc2e64c17527c46c5af37ded73314">typedef_field_count</a>;
<a name="l00879"></a>00879 
<a name="l00880"></a>00880     <span class="comment">/* The template arguments.  This is an array with</span>
<a name="l00881"></a>00881 <span class="comment">       N_TEMPLATE_ARGUMENTS elements.  This is NULL for non-template</span>
<a name="l00882"></a>00882 <span class="comment">       classes.  */</span>
<a name="l00883"></a><a class="code" href="structcplus__struct__type.html#ac39e6d9e58f918d266cd861ad1027e75">00883</a>     <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> **<a class="code" href="structcplus__struct__type.html#ac39e6d9e58f918d266cd861ad1027e75">template_arguments</a>;
<a name="l00884"></a>00884   };
<a name="l00885"></a>00885 
<a name="l00886"></a>00886 <span class="comment">/* Struct used to store conversion rankings.  */</span>
<a name="l00887"></a><a class="code" href="structrank.html">00887</a> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a>
<a name="l00888"></a>00888   {
<a name="l00889"></a><a class="code" href="structrank.html#adcce1bc7082298591f12271d5d62b199">00889</a>     <span class="keywordtype">short</span> <a class="code" href="structrank.html#adcce1bc7082298591f12271d5d62b199">rank</a>;
<a name="l00890"></a>00890 
<a name="l00891"></a>00891     <span class="comment">/* When two conversions are of the same type and therefore have the same</span>
<a name="l00892"></a>00892 <span class="comment">       rank, subrank is used to differentiate the two.</span>
<a name="l00893"></a>00893 <span class="comment">       Eg: Two derived-class-pointer to base-class-pointer conversions would</span>
<a name="l00894"></a>00894 <span class="comment">       both have base pointer conversion rank, but the conversion with the</span>
<a name="l00895"></a>00895 <span class="comment">       shorter distance to the ancestor is preferable.  &#39;subrank&#39; would be used</span>
<a name="l00896"></a>00896 <span class="comment">       to reflect that.  */</span>
<a name="l00897"></a><a class="code" href="structrank.html#a7b9c54c73049bddfc6dacd8e63306476">00897</a>     <span class="keywordtype">short</span> <a class="code" href="structrank.html#a7b9c54c73049bddfc6dacd8e63306476">subrank</a>;
<a name="l00898"></a>00898   };
<a name="l00899"></a>00899 
<a name="l00900"></a>00900 <span class="comment">/* Struct used for ranking a function for overload resolution.  */</span>
<a name="l00901"></a><a class="code" href="structbadness__vector.html">00901</a> <span class="keyword">struct </span><a class="code" href="structbadness__vector.html">badness_vector</a>
<a name="l00902"></a>00902   {
<a name="l00903"></a><a class="code" href="structbadness__vector.html#ad8e78a0aeb979a41aa4b2070683f83dc">00903</a>     <span class="keywordtype">int</span> <a class="code" href="structbadness__vector.html#ad8e78a0aeb979a41aa4b2070683f83dc">length</a>;
<a name="l00904"></a><a class="code" href="structbadness__vector.html#ac94061a09806133279a0696ad36c8bd2">00904</a>     <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> *<a class="code" href="structbadness__vector.html#ac94061a09806133279a0696ad36c8bd2">rank</a>;
<a name="l00905"></a>00905   };
<a name="l00906"></a>00906 
<a name="l00907"></a>00907 <span class="comment">/* GNAT Ada-specific information for various Ada types.  */</span>
<a name="l00908"></a><a class="code" href="structgnat__aux__type.html">00908</a> <span class="keyword">struct </span><a class="code" href="structgnat__aux__type.html">gnat_aux_type</a>
<a name="l00909"></a>00909   {
<a name="l00910"></a>00910     <span class="comment">/* Parallel type used to encode information about dynamic types</span>
<a name="l00911"></a>00911 <span class="comment">       used in Ada (such as variant records, variable-size array,</span>
<a name="l00912"></a>00912 <span class="comment">       etc).  */</span>
<a name="l00913"></a><a class="code" href="structgnat__aux__type.html#af882fa5bb09238ccfd23ac1cc4b90801">00913</a>     <span class="keyword">struct </span><a class="code" href="structtype.html">type</a>* <a class="code" href="structgnat__aux__type.html#af882fa5bb09238ccfd23ac1cc4b90801">descriptive_type</a>;
<a name="l00914"></a>00914   };
<a name="l00915"></a>00915 
<a name="l00916"></a>00916 <span class="comment">/* For TYPE_CODE_FUNC types,  */</span>
<a name="l00917"></a><a class="code" href="structfunc__type.html">00917</a> <span class="keyword">struct </span><a class="code" href="structfunc__type.html">func_type</a>
<a name="l00918"></a>00918   {
<a name="l00919"></a>00919     <span class="comment">/* The calling convention for targets supporting multiple ABIs.  Right now</span>
<a name="l00920"></a>00920 <span class="comment">       this is only fetched from the Dwarf-2 DW_AT_calling_convention</span>
<a name="l00921"></a>00921 <span class="comment">       attribute.  */</span>
<a name="l00922"></a><a class="code" href="structfunc__type.html#a79751124265bc7684b3e205ad975cb37">00922</a>     <span class="keywordtype">unsigned</span> <a class="code" href="structfunc__type.html#a79751124265bc7684b3e205ad975cb37">calling_convention</a>;
<a name="l00923"></a>00923 
<a name="l00924"></a>00924     <span class="comment">/* Only those DW_TAG_GNU_call_site&#39;s in this function that have</span>
<a name="l00925"></a>00925 <span class="comment">       DW_AT_GNU_tail_call set are linked in this list.  Function without its</span>
<a name="l00926"></a>00926 <span class="comment">       tail call list complete (DW_AT_GNU_all_tail_call_sites or its superset</span>
<a name="l00927"></a>00927 <span class="comment">       DW_AT_GNU_all_call_sites) has TAIL_CALL_LIST NULL, even if some</span>
<a name="l00928"></a>00928 <span class="comment">       DW_TAG_GNU_call_site&#39;s exist in such function. */</span>
<a name="l00929"></a><a class="code" href="structfunc__type.html#ac6816bfdd90c72902c2840274511f848">00929</a>     <span class="keyword">struct </span><a class="code" href="structcall__site.html">call_site</a> *<a class="code" href="structfunc__type.html#ac6816bfdd90c72902c2840274511f848">tail_call_list</a>;
<a name="l00930"></a>00930   };
<a name="l00931"></a>00931 
<a name="l00932"></a>00932 <span class="comment">/* struct call_site_parameter can be referenced in callees by several ways.  */</span>
<a name="l00933"></a>00933 
<a name="l00934"></a><a class="code" href="gdbtypes_8h.html#abc3720e18b62534187c1c6b6e4677a28">00934</a> <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#abc3720e18b62534187c1c6b6e4677a28">call_site_parameter_kind</a>
<a name="l00935"></a>00935 {
<a name="l00936"></a>00936   <span class="comment">/* Use field call_site_parameter.u.dwarf_reg.  */</span>
<a name="l00937"></a><a class="code" href="gdbtypes_8h.html#abc3720e18b62534187c1c6b6e4677a28ac7ee57235687368b997a828d75a1699a">00937</a>   <a class="code" href="gdbtypes_8h.html#abc3720e18b62534187c1c6b6e4677a28ac7ee57235687368b997a828d75a1699a">CALL_SITE_PARAMETER_DWARF_REG</a>,
<a name="l00938"></a>00938 
<a name="l00939"></a>00939   <span class="comment">/* Use field call_site_parameter.u.fb_offset.  */</span>
<a name="l00940"></a><a class="code" href="gdbtypes_8h.html#abc3720e18b62534187c1c6b6e4677a28a1269dcc44cae916985c5bebc6780b0be">00940</a>   <a class="code" href="gdbtypes_8h.html#abc3720e18b62534187c1c6b6e4677a28a1269dcc44cae916985c5bebc6780b0be">CALL_SITE_PARAMETER_FB_OFFSET</a>,
<a name="l00941"></a>00941 
<a name="l00942"></a>00942   <span class="comment">/* Use field call_site_parameter.u.param_offset.  */</span>
<a name="l00943"></a><a class="code" href="gdbtypes_8h.html#abc3720e18b62534187c1c6b6e4677a28adc3c86b822ec65d2d128ac78af3113df">00943</a>   <a class="code" href="gdbtypes_8h.html#abc3720e18b62534187c1c6b6e4677a28adc3c86b822ec65d2d128ac78af3113df">CALL_SITE_PARAMETER_PARAM_OFFSET</a>
<a name="l00944"></a>00944 };
<a name="l00945"></a>00945 
<a name="l00946"></a>00946 <span class="comment">/* A place where a function gets called from, represented by</span>
<a name="l00947"></a>00947 <span class="comment">   DW_TAG_GNU_call_site.  It can be looked up from symtab-&gt;call_site_htab.  */</span>
<a name="l00948"></a>00948 
<a name="l00949"></a><a class="code" href="structcall__site.html">00949</a> <span class="keyword">struct </span><a class="code" href="structcall__site.html">call_site</a>
<a name="l00950"></a>00950   {
<a name="l00951"></a>00951     <span class="comment">/* Address of the first instruction after this call.  It must be the first</span>
<a name="l00952"></a>00952 <span class="comment">       field as we overload core_addr_hash and core_addr_eq for it.  */</span>
<a name="l00953"></a><a class="code" href="structcall__site.html#ae6f3db49fe991fa24591a0185f3ffa01">00953</a>     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structcall__site.html#ae6f3db49fe991fa24591a0185f3ffa01">pc</a>;
<a name="l00954"></a>00954 
<a name="l00955"></a>00955     <span class="comment">/* List successor with head in FUNC_TYPE.TAIL_CALL_LIST.  */</span>
<a name="l00956"></a><a class="code" href="structcall__site.html#ac7b21bc370832490b6dbacd76894c1a1">00956</a>     <span class="keyword">struct </span><a class="code" href="structcall__site.html">call_site</a> *<a class="code" href="structcall__site.html#ac7b21bc370832490b6dbacd76894c1a1">tail_call_next</a>;
<a name="l00957"></a>00957 
<a name="l00958"></a>00958     <span class="comment">/* Describe DW_AT_GNU_call_site_target.  Missing attribute uses</span>
<a name="l00959"></a>00959 <span class="comment">       FIELD_LOC_KIND_DWARF_BLOCK with FIELD_DWARF_BLOCK == NULL.  */</span>
<a name="l00960"></a>00960     <span class="keyword">struct</span>
<a name="l00961"></a>00961       {
<a name="l00962"></a><a class="code" href="structcall__site.html#a94c3c54c512e82132c77d7330ccb5cf1">00962</a>         <span class="keyword">union </span>field_location <a class="code" href="structmain__type.html#a9113423c837b4868e46cb015ea351738">loc</a>;
<a name="l00963"></a>00963 
<a name="l00964"></a>00964         <span class="comment">/* Discriminant for union field_location.  */</span>
<a name="l00965"></a>00965         ENUM_BITFIELD(<a class="code" href="gdbtypes_8h.html#a3eb0e1253afc7850dc90da0d4ba5b487">field_loc_kind</a>) loc_kind : 3;
<a name="l00966"></a>00966       }
<a name="l00967"></a>00967     target;
<a name="l00968"></a>00968 
<a name="l00969"></a>00969     <span class="comment">/* Size of the PARAMETER array.  */</span>
<a name="l00970"></a><a class="code" href="structcall__site.html#a13d30c155964d25c96863e9046d443b3">00970</a>     <span class="keywordtype">unsigned</span> parameter_count;
<a name="l00971"></a>00971 
<a name="l00972"></a>00972     <span class="comment">/* CU of the function where the call is located.  It gets used for DWARF</span>
<a name="l00973"></a>00973 <span class="comment">       blocks execution in the parameter array below.  */</span>
<a name="l00974"></a><a class="code" href="structcall__site.html#ab1b6ca82dfc73d704a961f0617883bc7">00974</a>     struct <a class="code" href="structdwarf2__per__cu__data.html">dwarf2_per_cu_data</a> *per_cu;
<a name="l00975"></a>00975 
<a name="l00976"></a>00976     <span class="comment">/* Describe DW_TAG_GNU_call_site&#39;s DW_TAG_formal_parameter.  */</span>
<a name="l00977"></a><a class="code" href="structcall__site_1_1call__site__parameter.html">00977</a>     struct <a class="code" href="structcall__site_1_1call__site__parameter.html">call_site_parameter</a>
<a name="l00978"></a>00978       {
<a name="l00979"></a>00979         ENUM_BITFIELD (<a class="code" href="gdbtypes_8h.html#abc3720e18b62534187c1c6b6e4677a28">call_site_parameter_kind</a>) kind : 2;
<a name="l00980"></a>00980 
<a name="l00981"></a><a class="code" href="unioncall__site_1_1call__site__parameter_1_1call__site__parameter__u.html">00981</a>         <span class="keyword">union </span><a class="code" href="unioncall__site_1_1call__site__parameter_1_1call__site__parameter__u.html">call_site_parameter_u</a>
<a name="l00982"></a>00982           {
<a name="l00983"></a>00983             <span class="comment">/* DW_TAG_formal_parameter&#39;s DW_AT_location&#39;s DW_OP_regX as DWARF</span>
<a name="l00984"></a>00984 <span class="comment">               register number, for register passed parameters.  */</span>
<a name="l00985"></a><a class="code" href="unioncall__site_1_1call__site__parameter_1_1call__site__parameter__u.html#ae090e1818d1ffaf52245c589ad22e2da">00985</a>             <span class="keywordtype">int</span> <a class="code" href="unioncall__site_1_1call__site__parameter_1_1call__site__parameter__u.html#ae090e1818d1ffaf52245c589ad22e2da">dwarf_reg</a>;
<a name="l00986"></a>00986 
<a name="l00987"></a>00987             <span class="comment">/* Offset from the callee&#39;s frame base, for stack passed parameters.</span>
<a name="l00988"></a>00988 <span class="comment">               This equals offset from the caller&#39;s stack pointer.  */</span>
<a name="l00989"></a><a class="code" href="unioncall__site_1_1call__site__parameter_1_1call__site__parameter__u.html#a234e086c1688d54e2ba9f0c010bef2fc">00989</a>             <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="unioncall__site_1_1call__site__parameter_1_1call__site__parameter__u.html#a234e086c1688d54e2ba9f0c010bef2fc">fb_offset</a>;
<a name="l00990"></a>00990 
<a name="l00991"></a>00991             <span class="comment">/* Offset relative to the start of this PER_CU to</span>
<a name="l00992"></a>00992 <span class="comment">               DW_TAG_formal_parameter which is referenced by both caller and</span>
<a name="l00993"></a>00993 <span class="comment">               the callee.  */</span>
<a name="l00994"></a><a class="code" href="unioncall__site_1_1call__site__parameter_1_1call__site__parameter__u.html#a4b08688c36026ddf106a7c0f2bfa383b">00994</a>             <a class="code" href="structcu__offset.html">cu_offset</a> <a class="code" href="unioncall__site_1_1call__site__parameter_1_1call__site__parameter__u.html#a4b08688c36026ddf106a7c0f2bfa383b">param_offset</a>;
<a name="l00995"></a>00995           }
<a name="l00996"></a>00996         u;
<a name="l00997"></a>00997 
<a name="l00998"></a>00998         <span class="comment">/* DW_TAG_formal_parameter&#39;s DW_AT_GNU_call_site_value.  It is never</span>
<a name="l00999"></a>00999 <span class="comment">           NULL.  */</span>
<a name="l01000"></a><a class="code" href="structcall__site_1_1call__site__parameter.html#aa18b6cfc7849ddca4a0f3c82103d4d2d">01000</a>         <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structcall__site_1_1call__site__parameter.html#aa18b6cfc7849ddca4a0f3c82103d4d2d">value</a>;
<a name="l01001"></a><a class="code" href="structcall__site_1_1call__site__parameter.html#a547ec7c48ea27f70999044c6758a1f15">01001</a>         <span class="keywordtype">size_t</span> <a class="code" href="structcall__site_1_1call__site__parameter.html#a547ec7c48ea27f70999044c6758a1f15">value_size</a>;
<a name="l01002"></a>01002 
<a name="l01003"></a>01003         <span class="comment">/* DW_TAG_formal_parameter&#39;s DW_AT_GNU_call_site_data_value.  It may be</span>
<a name="l01004"></a>01004 <span class="comment">           NULL if not provided by DWARF.  */</span>
<a name="l01005"></a><a class="code" href="structcall__site_1_1call__site__parameter.html#ac33bd478979e37b8253a9ba336565079">01005</a>         <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structcall__site_1_1call__site__parameter.html#ac33bd478979e37b8253a9ba336565079">data_value</a>;
<a name="l01006"></a><a class="code" href="structcall__site_1_1call__site__parameter.html#ab04d00c231ae705a7f7fd83b4217378f">01006</a>         <span class="keywordtype">size_t</span> <a class="code" href="structcall__site_1_1call__site__parameter.html#ab04d00c231ae705a7f7fd83b4217378f">data_value_size</a>;
<a name="l01007"></a>01007       }
<a name="l01008"></a>01008     parameter[1];
<a name="l01009"></a>01009   };
<a name="l01010"></a>01010 
<a name="l01011"></a>01011 <span class="comment">/* The default value of TYPE_CPLUS_SPECIFIC(T) points to the</span>
<a name="l01012"></a>01012 <span class="comment">   this shared static structure.  */</span>
<a name="l01013"></a>01013 
<a name="l01014"></a>01014 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structcplus__struct__type.html">cplus_struct_type</a> <a class="code" href="gdbtypes_8c.html#a9641eae5968c80178d504416fc6e60b5">cplus_struct_default</a>;
<a name="l01015"></a>01015 
<a name="l01016"></a>01016 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="gdbtypes_8c.html#a34d772a08736ff4b285d60b6637589e1">allocate_cplus_struct_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01017"></a>01017 
<a name="l01018"></a><a class="code" href="gdbtypes_8h.html#abce922c83265a58f62b491513b7a5aea">01018</a> <span class="preprocessor">#define INIT_CPLUS_SPECIFIC(type) \</span>
<a name="l01019"></a>01019 <span class="preprocessor">  (TYPE_SPECIFIC_FIELD (type) = TYPE_SPECIFIC_CPLUS_STUFF, \</span>
<a name="l01020"></a>01020 <span class="preprocessor">   TYPE_RAW_CPLUS_SPECIFIC (type) = (struct cplus_struct_type*) \</span>
<a name="l01021"></a>01021 <span class="preprocessor">   &amp;cplus_struct_default)</span>
<a name="l01022"></a>01022 <span class="preprocessor"></span>
<a name="l01023"></a><a class="code" href="gdbtypes_8h.html#a39116f69533c29b08fc5504b4d6986c0">01023</a> <span class="preprocessor">#define ALLOCATE_CPLUS_STRUCT_TYPE(type) allocate_cplus_struct_type (type)</span>
<a name="l01024"></a>01024 <span class="preprocessor"></span>
<a name="l01025"></a><a class="code" href="gdbtypes_8h.html#aa057ef3e6916cbe12060099547c3f76a">01025</a> <span class="preprocessor">#define HAVE_CPLUS_STRUCT(type) \</span>
<a name="l01026"></a>01026 <span class="preprocessor">  (TYPE_SPECIFIC_FIELD (type) == TYPE_SPECIFIC_CPLUS_STUFF \</span>
<a name="l01027"></a>01027 <span class="preprocessor">   &amp;&amp; TYPE_RAW_CPLUS_SPECIFIC (type) !=  &amp;cplus_struct_default)</span>
<a name="l01028"></a>01028 <span class="preprocessor"></span>
<a name="l01029"></a>01029 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structgnat__aux__type.html">gnat_aux_type</a> <a class="code" href="gdbtypes_8c.html#ab95707a7dff8c8c13a19916422416a8b">gnat_aux_default</a>;
<a name="l01030"></a>01030 
<a name="l01031"></a>01031 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="gdbtypes_8c.html#a3d4ffa716068f704a92fb8724a39598b">allocate_gnat_aux_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01032"></a>01032 
<a name="l01033"></a><a class="code" href="gdbtypes_8h.html#abb11145b63a8563c0dc0a4c26229b188">01033</a> <span class="preprocessor">#define INIT_GNAT_SPECIFIC(type) \</span>
<a name="l01034"></a>01034 <span class="preprocessor">  (TYPE_SPECIFIC_FIELD (type) = TYPE_SPECIFIC_GNAT_STUFF, \</span>
<a name="l01035"></a>01035 <span class="preprocessor">   TYPE_GNAT_SPECIFIC (type) = (struct gnat_aux_type *) &amp;gnat_aux_default)</span>
<a name="l01036"></a><a class="code" href="gdbtypes_8h.html#a79d8159b14f17291ce9b150d9ce4f7c4">01036</a> <span class="preprocessor"></span><span class="preprocessor">#define ALLOCATE_GNAT_AUX_TYPE(type) allocate_gnat_aux_type (type)</span>
<a name="l01037"></a>01037 <span class="preprocessor"></span><span class="comment">/* A macro that returns non-zero if the type-specific data should be</span>
<a name="l01038"></a>01038 <span class="comment">   read as &quot;gnat-stuff&quot;.  */</span>
<a name="l01039"></a><a class="code" href="gdbtypes_8h.html#ae599879d692c6b43f60ff21df29a89c2">01039</a> <span class="preprocessor">#define HAVE_GNAT_AUX_INFO(type) \</span>
<a name="l01040"></a>01040 <span class="preprocessor">  (TYPE_SPECIFIC_FIELD (type) == TYPE_SPECIFIC_GNAT_STUFF)</span>
<a name="l01041"></a>01041 <span class="preprocessor"></span>
<a name="l01042"></a><a class="code" href="gdbtypes_8h.html#a76a09a0ebf377c3209b4463651d53ec9">01042</a> <span class="preprocessor">#define INIT_FUNC_SPECIFIC(type)                                               \</span>
<a name="l01043"></a>01043 <span class="preprocessor">  (TYPE_SPECIFIC_FIELD (type) = TYPE_SPECIFIC_FUNC,                            \</span>
<a name="l01044"></a>01044 <span class="preprocessor">   TYPE_MAIN_TYPE (type)-&gt;type_specific.func_stuff                             \</span>
<a name="l01045"></a>01045 <span class="preprocessor">     = TYPE_ZALLOC (type,                                                      \</span>
<a name="l01046"></a>01046 <span class="preprocessor">                    sizeof (*TYPE_MAIN_TYPE (type)-&gt;type_specific.func_stuff)))</span>
<a name="l01047"></a>01047 <span class="preprocessor"></span>
<a name="l01048"></a><a class="code" href="gdbtypes_8h.html#ad0ad42ffb661b51ebff620a309a26dd1">01048</a> <span class="preprocessor">#define TYPE_INSTANCE_FLAGS(thistype) (thistype)-&gt;instance_flags</span>
<a name="l01049"></a><a class="code" href="gdbtypes_8h.html#a55dcae50baf1c424ac0ceb071bcaa68c">01049</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_MAIN_TYPE(thistype) (thistype)-&gt;main_type</span>
<a name="l01050"></a><a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">01050</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_NAME(thistype) TYPE_MAIN_TYPE(thistype)-&gt;name</span>
<a name="l01051"></a><a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">01051</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_TAG_NAME(type) TYPE_MAIN_TYPE(type)-&gt;tag_name</span>
<a name="l01052"></a><a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">01052</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_TARGET_TYPE(thistype) TYPE_MAIN_TYPE(thistype)-&gt;target_type</span>
<a name="l01053"></a><a class="code" href="gdbtypes_8h.html#a8ae8aa0084f45dbfbe06cfb6c1dc5be6">01053</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_POINTER_TYPE(thistype) (thistype)-&gt;pointer_type</span>
<a name="l01054"></a><a class="code" href="gdbtypes_8h.html#ad05e8f5ce247a8887a8a415c8a35f6e1">01054</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_REFERENCE_TYPE(thistype) (thistype)-&gt;reference_type</span>
<a name="l01055"></a><a class="code" href="gdbtypes_8h.html#a3147de748da03903b4895637850a2dca">01055</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_CHAIN(thistype) (thistype)-&gt;chain</span>
<a name="l01056"></a>01056 <span class="preprocessor"></span><span class="comment">/* Note that if thistype is a TYPEDEF type, you have to call check_typedef.</span>
<a name="l01057"></a>01057 <span class="comment">   But check_typedef does set the TYPE_LENGTH of the TYPEDEF type,</span>
<a name="l01058"></a>01058 <span class="comment">   so you only have to call check_typedef once.  Since allocate_value</span>
<a name="l01059"></a>01059 <span class="comment">   calls check_typedef, TYPE_LENGTH (VALUE_TYPE (X)) is safe.  */</span>
<a name="l01060"></a><a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">01060</a> <span class="preprocessor">#define TYPE_LENGTH(thistype) (thistype)-&gt;length</span>
<a name="l01061"></a>01061 <span class="preprocessor"></span><span class="comment">/* Note that TYPE_CODE can be TYPE_CODE_TYPEDEF, so if you want the real</span>
<a name="l01062"></a>01062 <span class="comment">   type, you need to do TYPE_CODE (check_type (this_type)).  */</span>
<a name="l01063"></a><a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">01063</a> <span class="preprocessor">#define TYPE_CODE(thistype) TYPE_MAIN_TYPE(thistype)-&gt;code</span>
<a name="l01064"></a><a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">01064</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_NFIELDS(thistype) TYPE_MAIN_TYPE(thistype)-&gt;nfields</span>
<a name="l01065"></a><a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">01065</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELDS(thistype) TYPE_MAIN_TYPE(thistype)-&gt;flds_bnds.fields</span>
<a name="l01066"></a>01066 <span class="preprocessor"></span>
<a name="l01067"></a><a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">01067</a> <span class="preprocessor">#define TYPE_INDEX_TYPE(type) TYPE_FIELD_TYPE (type, 0)</span>
<a name="l01068"></a><a class="code" href="gdbtypes_8h.html#ae9113b911f1961005dd2e52bd6dc5d6e">01068</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_RANGE_DATA(thistype) TYPE_MAIN_TYPE(thistype)-&gt;flds_bnds.bounds</span>
<a name="l01069"></a><a class="code" href="gdbtypes_8h.html#a8a35064d1a955f191b0a63b03755689b">01069</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_LOW_BOUND(range_type) TYPE_RANGE_DATA(range_type)-&gt;low</span>
<a name="l01070"></a><a class="code" href="gdbtypes_8h.html#a77cdc334123abc6858b3ea8b3361cd5d">01070</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_HIGH_BOUND(range_type) TYPE_RANGE_DATA(range_type)-&gt;high</span>
<a name="l01071"></a><a class="code" href="gdbtypes_8h.html#ac623dd04baf71d8f307fbb8b69e6e5b6">01071</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_LOW_BOUND_UNDEFINED(range_type) \</span>
<a name="l01072"></a>01072 <span class="preprocessor">   TYPE_RANGE_DATA(range_type)-&gt;low_undefined</span>
<a name="l01073"></a><a class="code" href="gdbtypes_8h.html#a0edde51aec176e3e7cb65849d4d78329">01073</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_HIGH_BOUND_UNDEFINED(range_type) \</span>
<a name="l01074"></a>01074 <span class="preprocessor">   TYPE_RANGE_DATA(range_type)-&gt;high_undefined</span>
<a name="l01075"></a>01075 <span class="preprocessor"></span>
<a name="l01076"></a>01076 <span class="comment">/* Moto-specific stuff for FORTRAN arrays.  */</span>
<a name="l01077"></a>01077 
<a name="l01078"></a><a class="code" href="gdbtypes_8h.html#a54487ac042b1fcfca60cf43c158af526">01078</a> <span class="preprocessor">#define TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED(arraytype) \</span>
<a name="l01079"></a>01079 <span class="preprocessor">   TYPE_HIGH_BOUND_UNDEFINED(TYPE_INDEX_TYPE(arraytype))</span>
<a name="l01080"></a><a class="code" href="gdbtypes_8h.html#a820b860a86cb2c4e6d9af73b293ee130">01080</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED(arraytype) \</span>
<a name="l01081"></a>01081 <span class="preprocessor">   TYPE_LOW_BOUND_UNDEFINED(TYPE_INDEX_TYPE(arraytype))</span>
<a name="l01082"></a>01082 <span class="preprocessor"></span>
<a name="l01083"></a><a class="code" href="gdbtypes_8h.html#aad805c525df82e820c813f77892a7b1b">01083</a> <span class="preprocessor">#define TYPE_ARRAY_UPPER_BOUND_VALUE(arraytype) \</span>
<a name="l01084"></a>01084 <span class="preprocessor">   (TYPE_HIGH_BOUND(TYPE_INDEX_TYPE((arraytype))))</span>
<a name="l01085"></a>01085 <span class="preprocessor"></span>
<a name="l01086"></a><a class="code" href="gdbtypes_8h.html#a50a43ece387ccd8f44d6c463315a95e4">01086</a> <span class="preprocessor">#define TYPE_ARRAY_LOWER_BOUND_VALUE(arraytype) \</span>
<a name="l01087"></a>01087 <span class="preprocessor">   (TYPE_LOW_BOUND(TYPE_INDEX_TYPE((arraytype))))</span>
<a name="l01088"></a>01088 <span class="preprocessor"></span>
<a name="l01089"></a>01089 <span class="comment">/* C++ */</span>
<a name="l01090"></a>01090 
<a name="l01091"></a><a class="code" href="gdbtypes_8h.html#a128fd92e71469aa5f55704a1f0814fb3">01091</a> <span class="preprocessor">#define TYPE_VPTR_BASETYPE(thistype) TYPE_MAIN_TYPE(thistype)-&gt;vptr_basetype</span>
<a name="l01092"></a><a class="code" href="gdbtypes_8h.html#a9c3fa31c69cb13e091817b41616af6f1">01092</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_DOMAIN_TYPE(thistype) TYPE_MAIN_TYPE(thistype)-&gt;vptr_basetype</span>
<a name="l01093"></a><a class="code" href="gdbtypes_8h.html#aa20a30a8f11029649bea0e356e9dc140">01093</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_VPTR_FIELDNO(thistype) TYPE_MAIN_TYPE(thistype)-&gt;vptr_fieldno</span>
<a name="l01094"></a><a class="code" href="gdbtypes_8h.html#a2f7d533df4cabb4ded543f07f9153445">01094</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELDS(thistype) TYPE_CPLUS_SPECIFIC(thistype)-&gt;fn_fields</span>
<a name="l01095"></a><a class="code" href="gdbtypes_8h.html#a04c1a1616329be52b9a9706ddc102bd1">01095</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_NFN_FIELDS(thistype) TYPE_CPLUS_SPECIFIC(thistype)-&gt;nfn_fields</span>
<a name="l01096"></a><a class="code" href="gdbtypes_8h.html#aa9db4650ac83b316119cd495328e186a">01096</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_SPECIFIC_FIELD(thistype) \</span>
<a name="l01097"></a>01097 <span class="preprocessor">  TYPE_MAIN_TYPE(thistype)-&gt;type_specific_field</span>
<a name="l01098"></a><a class="code" href="gdbtypes_8h.html#aedc4f2d9fc9242d5d4ec51ab05c76f3f">01098</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_TYPE_SPECIFIC(thistype) TYPE_MAIN_TYPE(thistype)-&gt;type_specific</span>
<a name="l01099"></a>01099 <span class="preprocessor"></span><span class="comment">/* We need this tap-dance with the TYPE_RAW_SPECIFIC because of the case</span>
<a name="l01100"></a>01100 <span class="comment">   where we&#39;re trying to print an Ada array using the C language.</span>
<a name="l01101"></a>01101 <span class="comment">   In that case, there is no &quot;cplus_stuff&quot;, but the C language assumes</span>
<a name="l01102"></a>01102 <span class="comment">   that there is.  What we do, in that case, is pretend that there is</span>
<a name="l01103"></a>01103 <span class="comment">   an implicit one which is the default cplus stuff.  */</span>
<a name="l01104"></a><a class="code" href="gdbtypes_8h.html#a231e984ee0a4aec0266bf519250924f2">01104</a> <span class="preprocessor">#define TYPE_CPLUS_SPECIFIC(thistype) \</span>
<a name="l01105"></a>01105 <span class="preprocessor">   (!HAVE_CPLUS_STRUCT(thistype) \</span>
<a name="l01106"></a>01106 <span class="preprocessor">    ? (struct cplus_struct_type*)&amp;cplus_struct_default \</span>
<a name="l01107"></a>01107 <span class="preprocessor">    : TYPE_RAW_CPLUS_SPECIFIC(thistype))</span>
<a name="l01108"></a><a class="code" href="gdbtypes_8h.html#a2a02de3fe416dbf1f4353c3c76fc9df1">01108</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_RAW_CPLUS_SPECIFIC(thistype) TYPE_MAIN_TYPE(thistype)-&gt;type_specific.cplus_stuff</span>
<a name="l01109"></a><a class="code" href="gdbtypes_8h.html#a78df82e6fe646479917a312101f22df5">01109</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FLOATFORMAT(thistype) TYPE_MAIN_TYPE(thistype)-&gt;type_specific.floatformat</span>
<a name="l01110"></a><a class="code" href="gdbtypes_8h.html#a305a38a4dc04c98ea4f49d15a5bf72a2">01110</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_GNAT_SPECIFIC(thistype) TYPE_MAIN_TYPE(thistype)-&gt;type_specific.gnat_stuff</span>
<a name="l01111"></a><a class="code" href="gdbtypes_8h.html#a13051c2080a5b87f05b73a931f0eee3a">01111</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_DESCRIPTIVE_TYPE(thistype) TYPE_GNAT_SPECIFIC(thistype)-&gt;descriptive_type</span>
<a name="l01112"></a><a class="code" href="gdbtypes_8h.html#a80f847a96456b925bec1116fe39f69dc">01112</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_CALLING_CONVENTION(thistype) TYPE_MAIN_TYPE(thistype)-&gt;type_specific.func_stuff-&gt;calling_convention</span>
<a name="l01113"></a><a class="code" href="gdbtypes_8h.html#aa506d232b2c4c0710d012b6844b73662">01113</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_TAIL_CALL_LIST(thistype) TYPE_MAIN_TYPE(thistype)-&gt;type_specific.func_stuff-&gt;tail_call_list</span>
<a name="l01114"></a><a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">01114</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_BASECLASS(thistype,index) TYPE_FIELD_TYPE(thistype, index)</span>
<a name="l01115"></a><a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">01115</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_N_BASECLASSES(thistype) TYPE_CPLUS_SPECIFIC(thistype)-&gt;n_baseclasses</span>
<a name="l01116"></a><a class="code" href="gdbtypes_8h.html#a01a3292b0c953727fb57e7b81f5dbd02">01116</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_BASECLASS_NAME(thistype,index) TYPE_FIELD_NAME(thistype, index)</span>
<a name="l01117"></a><a class="code" href="gdbtypes_8h.html#a8131e3735fa0c8a76d2876c349854b7a">01117</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_BASECLASS_BITPOS(thistype,index) TYPE_FIELD_BITPOS(thistype,index)</span>
<a name="l01118"></a><a class="code" href="gdbtypes_8h.html#adb19c8aef61bc4ce36cf98f6d40afa55">01118</a> <span class="preprocessor"></span><span class="preprocessor">#define BASETYPE_VIA_PUBLIC(thistype, index) \</span>
<a name="l01119"></a>01119 <span class="preprocessor">  ((!TYPE_FIELD_PRIVATE(thistype, index)) &amp;&amp; (!TYPE_FIELD_PROTECTED(thistype, index)))</span>
<a name="l01120"></a><a class="code" href="gdbtypes_8h.html#a074995818010740f86e96d95a93e2cb1">01120</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_CPLUS_DYNAMIC(thistype) TYPE_CPLUS_SPECIFIC (thistype)-&gt;is_dynamic</span>
<a name="l01121"></a><a class="code" href="gdbtypes_8h.html#a7fb5e879fed7a38eaa1756aa5d0e658b">01121</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_CPLUS_REALLY_JAVA(thistype) TYPE_CPLUS_SPECIFIC (thistype)-&gt;is_java</span>
<a name="l01122"></a>01122 <span class="preprocessor"></span>
<a name="l01123"></a><a class="code" href="gdbtypes_8h.html#acc2f1c0fb434ce574171ed5ae0d841cb">01123</a> <span class="preprocessor">#define BASETYPE_VIA_VIRTUAL(thistype, index) \</span>
<a name="l01124"></a>01124 <span class="preprocessor">  (TYPE_CPLUS_SPECIFIC(thistype)-&gt;virtual_field_bits == NULL ? 0 \</span>
<a name="l01125"></a>01125 <span class="preprocessor">    : B_TST(TYPE_CPLUS_SPECIFIC(thistype)-&gt;virtual_field_bits, (index)))</span>
<a name="l01126"></a>01126 <span class="preprocessor"></span>
<a name="l01127"></a><a class="code" href="gdbtypes_8h.html#ae88bb60de05efe94bc1cbafee6fa3985">01127</a> <span class="preprocessor">#define FIELD_TYPE(thisfld) ((thisfld).type)</span>
<a name="l01128"></a><a class="code" href="gdbtypes_8h.html#aeaff087d79e6871070384c25cf886da7">01128</a> <span class="preprocessor"></span><span class="preprocessor">#define FIELD_NAME(thisfld) ((thisfld).name)</span>
<a name="l01129"></a><a class="code" href="gdbtypes_8h.html#a4cdaf77fe6873a7a2372d378ffb60d1f">01129</a> <span class="preprocessor"></span><span class="preprocessor">#define FIELD_LOC_KIND(thisfld) ((thisfld).loc_kind)</span>
<a name="l01130"></a><a class="code" href="gdbtypes_8h.html#a322feab08d827fe1ab35a55344fcf275">01130</a> <span class="preprocessor"></span><span class="preprocessor">#define FIELD_BITPOS_LVAL(thisfld) ((thisfld).loc.bitpos)</span>
<a name="l01131"></a><a class="code" href="gdbtypes_8h.html#acd937b9429ab865041b5a88eb54e183c">01131</a> <span class="preprocessor"></span><span class="preprocessor">#define FIELD_BITPOS(thisfld) (FIELD_BITPOS_LVAL (thisfld) + 0)</span>
<a name="l01132"></a><a class="code" href="gdbtypes_8h.html#a4cc997e0c6e9d3255a6674f558b4cfa7">01132</a> <span class="preprocessor"></span><span class="preprocessor">#define FIELD_ENUMVAL_LVAL(thisfld) ((thisfld).loc.enumval)</span>
<a name="l01133"></a><a class="code" href="gdbtypes_8h.html#ad0d4ed644e19876534ff91875175931d">01133</a> <span class="preprocessor"></span><span class="preprocessor">#define FIELD_ENUMVAL(thisfld) (FIELD_ENUMVAL_LVAL (thisfld) + 0)</span>
<a name="l01134"></a><a class="code" href="gdbtypes_8h.html#a14d27a113be3d69ebfad98c91da876fb">01134</a> <span class="preprocessor"></span><span class="preprocessor">#define FIELD_STATIC_PHYSNAME(thisfld) ((thisfld).loc.physname)</span>
<a name="l01135"></a><a class="code" href="gdbtypes_8h.html#a923011565252b5f3310df99b83744c68">01135</a> <span class="preprocessor"></span><span class="preprocessor">#define FIELD_STATIC_PHYSADDR(thisfld) ((thisfld).loc.physaddr)</span>
<a name="l01136"></a><a class="code" href="gdbtypes_8h.html#aceb5969b4ef73dbd54375dfc6ebd852a">01136</a> <span class="preprocessor"></span><span class="preprocessor">#define FIELD_DWARF_BLOCK(thisfld) ((thisfld).loc.dwarf_block)</span>
<a name="l01137"></a><a class="code" href="gdbtypes_8h.html#a3b785c6047f2bce21ac78987ab5a4b48">01137</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_FIELD_BITPOS(thisfld, bitpos)                       \</span>
<a name="l01138"></a>01138 <span class="preprocessor">  (FIELD_LOC_KIND (thisfld) = FIELD_LOC_KIND_BITPOS,            \</span>
<a name="l01139"></a>01139 <span class="preprocessor">   FIELD_BITPOS_LVAL (thisfld) = (bitpos))</span>
<a name="l01140"></a><a class="code" href="gdbtypes_8h.html#a7c5d158b14cf4880b850a7dcd791582f">01140</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_FIELD_ENUMVAL(thisfld, enumval)                     \</span>
<a name="l01141"></a>01141 <span class="preprocessor">  (FIELD_LOC_KIND (thisfld) = FIELD_LOC_KIND_ENUMVAL,           \</span>
<a name="l01142"></a>01142 <span class="preprocessor">   FIELD_ENUMVAL_LVAL (thisfld) = (enumval))</span>
<a name="l01143"></a><a class="code" href="gdbtypes_8h.html#a07a65b002f15d09d0b4ddec1f778e8b3">01143</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_FIELD_PHYSNAME(thisfld, name)                       \</span>
<a name="l01144"></a>01144 <span class="preprocessor">  (FIELD_LOC_KIND (thisfld) = FIELD_LOC_KIND_PHYSNAME,          \</span>
<a name="l01145"></a>01145 <span class="preprocessor">   FIELD_STATIC_PHYSNAME (thisfld) = (name))</span>
<a name="l01146"></a><a class="code" href="gdbtypes_8h.html#a7832aca28f8cb43c7e307c6a67e472ba">01146</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_FIELD_PHYSADDR(thisfld, addr)                       \</span>
<a name="l01147"></a>01147 <span class="preprocessor">  (FIELD_LOC_KIND (thisfld) = FIELD_LOC_KIND_PHYSADDR,          \</span>
<a name="l01148"></a>01148 <span class="preprocessor">   FIELD_STATIC_PHYSADDR (thisfld) = (addr))</span>
<a name="l01149"></a><a class="code" href="gdbtypes_8h.html#aaceadec4e6dcef3346f0156294873b6d">01149</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_FIELD_DWARF_BLOCK(thisfld, addr)                    \</span>
<a name="l01150"></a>01150 <span class="preprocessor">  (FIELD_LOC_KIND (thisfld) = FIELD_LOC_KIND_DWARF_BLOCK,       \</span>
<a name="l01151"></a>01151 <span class="preprocessor">   FIELD_DWARF_BLOCK (thisfld) = (addr))</span>
<a name="l01152"></a><a class="code" href="gdbtypes_8h.html#a5632e7a6760a5aa372c2393ea18c4975">01152</a> <span class="preprocessor"></span><span class="preprocessor">#define FIELD_ARTIFICIAL(thisfld) ((thisfld).artificial)</span>
<a name="l01153"></a><a class="code" href="gdbtypes_8h.html#af6b82d1dbebd01aa271ea0273efb0958">01153</a> <span class="preprocessor"></span><span class="preprocessor">#define FIELD_BITSIZE(thisfld) ((thisfld).bitsize)</span>
<a name="l01154"></a>01154 <span class="preprocessor"></span>
<a name="l01155"></a><a class="code" href="gdbtypes_8h.html#a8beaef20f443a0d98c7b445bbcfcf031">01155</a> <span class="preprocessor">#define TYPE_FIELD(thistype, n) TYPE_MAIN_TYPE(thistype)-&gt;flds_bnds.fields[n]</span>
<a name="l01156"></a><a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">01156</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_TYPE(thistype, n) FIELD_TYPE(TYPE_FIELD(thistype, n))</span>
<a name="l01157"></a><a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">01157</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_NAME(thistype, n) FIELD_NAME(TYPE_FIELD(thistype, n))</span>
<a name="l01158"></a><a class="code" href="gdbtypes_8h.html#ad08e8d2561e0b336d275ac16c10c5961">01158</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_LOC_KIND(thistype, n) FIELD_LOC_KIND (TYPE_FIELD (thistype, n))</span>
<a name="l01159"></a><a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">01159</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_BITPOS(thistype, n) FIELD_BITPOS (TYPE_FIELD (thistype, n))</span>
<a name="l01160"></a><a class="code" href="gdbtypes_8h.html#a2ab26ef1ee13615e128e3cb3cd058a5c">01160</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_ENUMVAL(thistype, n) FIELD_ENUMVAL (TYPE_FIELD (thistype, n))</span>
<a name="l01161"></a><a class="code" href="gdbtypes_8h.html#adb1ba2986c669807801c855372cff84d">01161</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_STATIC_PHYSNAME(thistype, n) FIELD_STATIC_PHYSNAME (TYPE_FIELD (thistype, n))</span>
<a name="l01162"></a><a class="code" href="gdbtypes_8h.html#ac08f659b4b7d4c61f6c74d5c53a0d5c7">01162</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_STATIC_PHYSADDR(thistype, n) FIELD_STATIC_PHYSADDR (TYPE_FIELD (thistype, n))</span>
<a name="l01163"></a><a class="code" href="gdbtypes_8h.html#a491e3bfcbd091d3256653f5ffbf07ecb">01163</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_DWARF_BLOCK(thistype, n) FIELD_DWARF_BLOCK (TYPE_FIELD (thistype, n))</span>
<a name="l01164"></a><a class="code" href="gdbtypes_8h.html#aa2bb2f58f95f604830c665368481946d">01164</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_ARTIFICIAL(thistype, n) FIELD_ARTIFICIAL(TYPE_FIELD(thistype,n))</span>
<a name="l01165"></a><a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">01165</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_BITSIZE(thistype, n) FIELD_BITSIZE(TYPE_FIELD(thistype,n))</span>
<a name="l01166"></a><a class="code" href="gdbtypes_8h.html#ac5d0007ccfe3d37905b3b428e7fee770">01166</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_PACKED(thistype, n) (FIELD_BITSIZE(TYPE_FIELD(thistype,n))!=0)</span>
<a name="l01167"></a>01167 <span class="preprocessor"></span>
<a name="l01168"></a><a class="code" href="gdbtypes_8h.html#a3ddf1eec48821311d6e1284d2a399dd7">01168</a> <span class="preprocessor">#define TYPE_FIELD_PRIVATE_BITS(thistype) \</span>
<a name="l01169"></a>01169 <span class="preprocessor">  TYPE_CPLUS_SPECIFIC(thistype)-&gt;private_field_bits</span>
<a name="l01170"></a><a class="code" href="gdbtypes_8h.html#ad4b9af0bc40d948a0c89eccb1f10094d">01170</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_PROTECTED_BITS(thistype) \</span>
<a name="l01171"></a>01171 <span class="preprocessor">  TYPE_CPLUS_SPECIFIC(thistype)-&gt;protected_field_bits</span>
<a name="l01172"></a><a class="code" href="gdbtypes_8h.html#aecf17b6fd9577f479e5d9e9aad7b0006">01172</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_IGNORE_BITS(thistype) \</span>
<a name="l01173"></a>01173 <span class="preprocessor">  TYPE_CPLUS_SPECIFIC(thistype)-&gt;ignore_field_bits</span>
<a name="l01174"></a><a class="code" href="gdbtypes_8h.html#a37857baeb6b538bd7591df423cfa2f66">01174</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_VIRTUAL_BITS(thistype) \</span>
<a name="l01175"></a>01175 <span class="preprocessor">  TYPE_CPLUS_SPECIFIC(thistype)-&gt;virtual_field_bits</span>
<a name="l01176"></a><a class="code" href="gdbtypes_8h.html#ae049a27d3991cb2c41905234fa551b3e">01176</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_TYPE_FIELD_PRIVATE(thistype, n) \</span>
<a name="l01177"></a>01177 <span class="preprocessor">  B_SET (TYPE_CPLUS_SPECIFIC(thistype)-&gt;private_field_bits, (n))</span>
<a name="l01178"></a><a class="code" href="gdbtypes_8h.html#a46c997f1679b1e86240a034ab3e56f0a">01178</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_TYPE_FIELD_PROTECTED(thistype, n) \</span>
<a name="l01179"></a>01179 <span class="preprocessor">  B_SET (TYPE_CPLUS_SPECIFIC(thistype)-&gt;protected_field_bits, (n))</span>
<a name="l01180"></a><a class="code" href="gdbtypes_8h.html#a4c2c3599bfb89a11b4852912913bc9ac">01180</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_TYPE_FIELD_IGNORE(thistype, n) \</span>
<a name="l01181"></a>01181 <span class="preprocessor">  B_SET (TYPE_CPLUS_SPECIFIC(thistype)-&gt;ignore_field_bits, (n))</span>
<a name="l01182"></a><a class="code" href="gdbtypes_8h.html#aec7868fff6efc6c214eb2b4e2443d167">01182</a> <span class="preprocessor"></span><span class="preprocessor">#define SET_TYPE_FIELD_VIRTUAL(thistype, n) \</span>
<a name="l01183"></a>01183 <span class="preprocessor">  B_SET (TYPE_CPLUS_SPECIFIC(thistype)-&gt;virtual_field_bits, (n))</span>
<a name="l01184"></a><a class="code" href="gdbtypes_8h.html#ae0f6510d214ef484caa50da98e4de773">01184</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_PRIVATE(thistype, n) \</span>
<a name="l01185"></a>01185 <span class="preprocessor">  (TYPE_CPLUS_SPECIFIC(thistype)-&gt;private_field_bits == NULL ? 0 \</span>
<a name="l01186"></a>01186 <span class="preprocessor">    : B_TST(TYPE_CPLUS_SPECIFIC(thistype)-&gt;private_field_bits, (n)))</span>
<a name="l01187"></a><a class="code" href="gdbtypes_8h.html#aaecb2d14e5db468b2a0d30d80453fe76">01187</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_PROTECTED(thistype, n) \</span>
<a name="l01188"></a>01188 <span class="preprocessor">  (TYPE_CPLUS_SPECIFIC(thistype)-&gt;protected_field_bits == NULL ? 0 \</span>
<a name="l01189"></a>01189 <span class="preprocessor">    : B_TST(TYPE_CPLUS_SPECIFIC(thistype)-&gt;protected_field_bits, (n)))</span>
<a name="l01190"></a><a class="code" href="gdbtypes_8h.html#a8630010b5f6381df06cf0421014edf67">01190</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_IGNORE(thistype, n) \</span>
<a name="l01191"></a>01191 <span class="preprocessor">  (TYPE_CPLUS_SPECIFIC(thistype)-&gt;ignore_field_bits == NULL ? 0 \</span>
<a name="l01192"></a>01192 <span class="preprocessor">    : B_TST(TYPE_CPLUS_SPECIFIC(thistype)-&gt;ignore_field_bits, (n)))</span>
<a name="l01193"></a><a class="code" href="gdbtypes_8h.html#ae644eef9715d7b419ebdf12b82a276c1">01193</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FIELD_VIRTUAL(thistype, n) \</span>
<a name="l01194"></a>01194 <span class="preprocessor">  (TYPE_CPLUS_SPECIFIC(thistype)-&gt;virtual_field_bits == NULL ? 0 \</span>
<a name="l01195"></a>01195 <span class="preprocessor">    : B_TST(TYPE_CPLUS_SPECIFIC(thistype)-&gt;virtual_field_bits, (n)))</span>
<a name="l01196"></a>01196 <span class="preprocessor"></span>
<a name="l01197"></a><a class="code" href="gdbtypes_8h.html#a62d757a5b33e46ec18d2f92b66a948f0">01197</a> <span class="preprocessor">#define TYPE_FN_FIELDLISTS(thistype) TYPE_CPLUS_SPECIFIC(thistype)-&gt;fn_fieldlists</span>
<a name="l01198"></a><a class="code" href="gdbtypes_8h.html#a1b38036dfbb2c6f7550104b7cde4b1b1">01198</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELDLIST(thistype, n) TYPE_CPLUS_SPECIFIC(thistype)-&gt;fn_fieldlists[n]</span>
<a name="l01199"></a><a class="code" href="gdbtypes_8h.html#a475365c72b8bba6494569379cec012df">01199</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELDLIST1(thistype, n) TYPE_CPLUS_SPECIFIC(thistype)-&gt;fn_fieldlists[n].fn_fields</span>
<a name="l01200"></a><a class="code" href="gdbtypes_8h.html#ad06fe1d1555d89ce87344fa6825e5642">01200</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELDLIST_NAME(thistype, n) TYPE_CPLUS_SPECIFIC(thistype)-&gt;fn_fieldlists[n].name</span>
<a name="l01201"></a><a class="code" href="gdbtypes_8h.html#a93f192829a3feec903de135b4d53981e">01201</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELDLIST_LENGTH(thistype, n) TYPE_CPLUS_SPECIFIC(thistype)-&gt;fn_fieldlists[n].length</span>
<a name="l01202"></a>01202 <span class="preprocessor"></span>
<a name="l01203"></a><a class="code" href="gdbtypes_8h.html#a9bac56587d93fbab70301eed2bd4a0bd">01203</a> <span class="preprocessor">#define TYPE_N_TEMPLATE_ARGUMENTS(thistype) \</span>
<a name="l01204"></a>01204 <span class="preprocessor">  TYPE_CPLUS_SPECIFIC (thistype)-&gt;n_template_arguments</span>
<a name="l01205"></a><a class="code" href="gdbtypes_8h.html#a29de819362b24f0269c86b8975d25c2e">01205</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_TEMPLATE_ARGUMENTS(thistype) \</span>
<a name="l01206"></a>01206 <span class="preprocessor">  TYPE_CPLUS_SPECIFIC (thistype)-&gt;template_arguments</span>
<a name="l01207"></a><a class="code" href="gdbtypes_8h.html#ab3ad8861abfe798cf6517cb6a889f640">01207</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_TEMPLATE_ARGUMENT(thistype, n) \</span>
<a name="l01208"></a>01208 <span class="preprocessor">  TYPE_CPLUS_SPECIFIC (thistype)-&gt;template_arguments[n]</span>
<a name="l01209"></a>01209 <span class="preprocessor"></span>
<a name="l01210"></a><a class="code" href="gdbtypes_8h.html#a833457ea1f8c008f18c496c9643101d0">01210</a> <span class="preprocessor">#define TYPE_FN_FIELD(thisfn, n) (thisfn)[n]</span>
<a name="l01211"></a><a class="code" href="gdbtypes_8h.html#a027f2138f114a97b7ee81a535d4714b1">01211</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_PHYSNAME(thisfn, n) (thisfn)[n].physname</span>
<a name="l01212"></a><a class="code" href="gdbtypes_8h.html#a76c6074ace855100086c485428668372">01212</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_TYPE(thisfn, n) (thisfn)[n].type</span>
<a name="l01213"></a><a class="code" href="gdbtypes_8h.html#a1b27df66ed198a941d2467943749c166">01213</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_ARGS(thisfn, n) TYPE_FIELDS ((thisfn)[n].type)</span>
<a name="l01214"></a><a class="code" href="gdbtypes_8h.html#aeaa03f601ef5734c239321915b0c989c">01214</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_CONST(thisfn, n) ((thisfn)[n].is_const)</span>
<a name="l01215"></a><a class="code" href="gdbtypes_8h.html#a795e139e0374a3c6040d7c71ce81ffc2">01215</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_VOLATILE(thisfn, n) ((thisfn)[n].is_volatile)</span>
<a name="l01216"></a><a class="code" href="gdbtypes_8h.html#a9b743873bbadb6b97d6084648fa84d77">01216</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_PRIVATE(thisfn, n) ((thisfn)[n].is_private)</span>
<a name="l01217"></a><a class="code" href="gdbtypes_8h.html#a98fce472782fa55b305b09c6f9666016">01217</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_PROTECTED(thisfn, n) ((thisfn)[n].is_protected)</span>
<a name="l01218"></a><a class="code" href="gdbtypes_8h.html#af0dd7a45ba4a5a9b1547faf2f1cfd39d">01218</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_PUBLIC(thisfn, n) ((thisfn)[n].is_public)</span>
<a name="l01219"></a><a class="code" href="gdbtypes_8h.html#aeff0a755d9dbe313abc4ffc2ddebce0d">01219</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_STATIC(thisfn, n) ((thisfn)[n].is_static)</span>
<a name="l01220"></a><a class="code" href="gdbtypes_8h.html#a2970e15742bded27f1b4f48fc19a109a">01220</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_FINAL(thisfn, n) ((thisfn)[n].is_final)</span>
<a name="l01221"></a><a class="code" href="gdbtypes_8h.html#ade7a29a5fe8934ca3a402471a30a5d58">01221</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_SYNCHRONIZED(thisfn, n) ((thisfn)[n].is_synchronized)</span>
<a name="l01222"></a><a class="code" href="gdbtypes_8h.html#a74c315ca8986b6d4db653cd64377d230">01222</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_NATIVE(thisfn, n) ((thisfn)[n].is_native)</span>
<a name="l01223"></a><a class="code" href="gdbtypes_8h.html#ad89202614e1e5f2567ff387575f08e9a">01223</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_ARTIFICIAL(thisfn, n) ((thisfn)[n].is_artificial)</span>
<a name="l01224"></a><a class="code" href="gdbtypes_8h.html#a3dca6a26ae6d76a614df8a2159fb2c7c">01224</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_ABSTRACT(thisfn, n) ((thisfn)[n].is_abstract)</span>
<a name="l01225"></a><a class="code" href="gdbtypes_8h.html#a72f4bcaebfce8d11113344c05af99dd4">01225</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_STUB(thisfn, n) ((thisfn)[n].is_stub)</span>
<a name="l01226"></a><a class="code" href="gdbtypes_8h.html#a7d7abb5bc2729feae3184fc0c9924077">01226</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_CONSTRUCTOR(thisfn, n) ((thisfn)[n].is_constructor)</span>
<a name="l01227"></a><a class="code" href="gdbtypes_8h.html#af97d10dc7bc8151174db9d8c02d8452a">01227</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_FCONTEXT(thisfn, n) ((thisfn)[n].fcontext)</span>
<a name="l01228"></a><a class="code" href="gdbtypes_8h.html#a39952d3e6dd94ab2067e02ea7be9bbdf">01228</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_VOFFSET(thisfn, n) ((thisfn)[n].voffset-2)</span>
<a name="l01229"></a><a class="code" href="gdbtypes_8h.html#a7d4951372b6efd1f52238a17cef7c509">01229</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_VIRTUAL_P(thisfn, n) ((thisfn)[n].voffset &gt; 1)</span>
<a name="l01230"></a><a class="code" href="gdbtypes_8h.html#ab772f7a2fa3ac127cfd52c64d129ac18">01230</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_FN_FIELD_STATIC_P(thisfn, n) ((thisfn)[n].voffset == VOFFSET_STATIC)</span>
<a name="l01231"></a>01231 <span class="preprocessor"></span>
<a name="l01232"></a><a class="code" href="gdbtypes_8h.html#adcb871b5d18a459cac4d7e4c6cf76320">01232</a> <span class="preprocessor">#define TYPE_TYPEDEF_FIELD_ARRAY(thistype) \</span>
<a name="l01233"></a>01233 <span class="preprocessor">  TYPE_CPLUS_SPECIFIC (thistype)-&gt;typedef_field</span>
<a name="l01234"></a><a class="code" href="gdbtypes_8h.html#ab7e7ca6cf80f9833f648e4bae4e2b6ad">01234</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_TYPEDEF_FIELD(thistype, n) \</span>
<a name="l01235"></a>01235 <span class="preprocessor">  TYPE_CPLUS_SPECIFIC (thistype)-&gt;typedef_field[n]</span>
<a name="l01236"></a><a class="code" href="gdbtypes_8h.html#af112d1553e909bba062fb1bdb23f3a7c">01236</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_TYPEDEF_FIELD_NAME(thistype, n) \</span>
<a name="l01237"></a>01237 <span class="preprocessor">  TYPE_TYPEDEF_FIELD (thistype, n).name</span>
<a name="l01238"></a><a class="code" href="gdbtypes_8h.html#a4991155e3eae0dada84aea7f0b87c501">01238</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_TYPEDEF_FIELD_TYPE(thistype, n) \</span>
<a name="l01239"></a>01239 <span class="preprocessor">  TYPE_TYPEDEF_FIELD (thistype, n).type</span>
<a name="l01240"></a><a class="code" href="gdbtypes_8h.html#ac34451cdc1f0b073c3866b901aa8a460">01240</a> <span class="preprocessor"></span><span class="preprocessor">#define TYPE_TYPEDEF_FIELD_COUNT(thistype) \</span>
<a name="l01241"></a>01241 <span class="preprocessor">  TYPE_CPLUS_SPECIFIC (thistype)-&gt;typedef_field_count</span>
<a name="l01242"></a>01242 <span class="preprocessor"></span>
<a name="l01243"></a><a class="code" href="gdbtypes_8h.html#a69344b27f7781ba403f1843600ed386e">01243</a> <span class="preprocessor">#define TYPE_IS_OPAQUE(thistype) \</span>
<a name="l01244"></a>01244 <span class="preprocessor">  (((TYPE_CODE (thistype) == TYPE_CODE_STRUCT) \</span>
<a name="l01245"></a>01245 <span class="preprocessor">    || (TYPE_CODE (thistype) == TYPE_CODE_UNION)) \</span>
<a name="l01246"></a>01246 <span class="preprocessor">   &amp;&amp; (TYPE_NFIELDS (thistype) == 0) \</span>
<a name="l01247"></a>01247 <span class="preprocessor">   &amp;&amp; (!HAVE_CPLUS_STRUCT (thistype) \</span>
<a name="l01248"></a>01248 <span class="preprocessor">       || TYPE_NFN_FIELDS (thistype) == 0) \</span>
<a name="l01249"></a>01249 <span class="preprocessor">   &amp;&amp; (TYPE_STUB (thistype) || !TYPE_STUB_SUPPORTED (thistype)))</span>
<a name="l01250"></a>01250 <span class="preprocessor"></span>
<a name="l01251"></a>01251 <span class="comment">/* A helper macro that returns the name of a type or &quot;unnamed type&quot; if the type</span>
<a name="l01252"></a>01252 <span class="comment">   has no name.  */</span>
<a name="l01253"></a><a class="code" href="gdbtypes_8h.html#a69e35a3916d7d899ac6aa5f0bd187694">01253</a> <span class="preprocessor">#define TYPE_SAFE_NAME(type) \</span>
<a name="l01254"></a>01254 <span class="preprocessor">  (TYPE_NAME (type) ? TYPE_NAME (type) : _(&quot;&lt;unnamed type&gt;&quot;))</span>
<a name="l01255"></a>01255 <span class="preprocessor"></span>
<a name="l01256"></a>01256 <span class="comment">/* A helper macro that returns the name of an error type.  If the type</span>
<a name="l01257"></a>01257 <span class="comment">   has a name, it is used; otherwise, a default is used.  */</span>
<a name="l01258"></a><a class="code" href="gdbtypes_8h.html#ac178d55c38dfc4738b1781eba74a309f">01258</a> <span class="preprocessor">#define TYPE_ERROR_NAME(type) \</span>
<a name="l01259"></a>01259 <span class="preprocessor">  (TYPE_NAME (type) ? TYPE_NAME (type) : _(&quot;&lt;error type&gt;&quot;))</span>
<a name="l01260"></a>01260 <span class="preprocessor"></span>
<a name="l01261"></a><a class="code" href="structbuiltin__type.html">01261</a> <span class="keyword">struct </span><a class="code" href="structbuiltin__type.html">builtin_type</a>
<a name="l01262"></a>01262 {
<a name="l01263"></a>01263   <span class="comment">/* Integral types.  */</span>
<a name="l01264"></a>01264 
<a name="l01265"></a>01265   <span class="comment">/* Implicit size/sign (based on the architecture&#39;s ABI).  */</span>
<a name="l01266"></a><a class="code" href="structbuiltin__type.html#ae1b424251656c129a027977d3c0ea066">01266</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#ae1b424251656c129a027977d3c0ea066">builtin_void</a>;
<a name="l01267"></a><a class="code" href="structbuiltin__type.html#aaf6738aff8469bfe0b9d5d3793a3b59b">01267</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#aaf6738aff8469bfe0b9d5d3793a3b59b">builtin_char</a>;
<a name="l01268"></a><a class="code" href="structbuiltin__type.html#a91725ac9c05f84b6816aafe80e50e898">01268</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a91725ac9c05f84b6816aafe80e50e898">builtin_short</a>;
<a name="l01269"></a><a class="code" href="structbuiltin__type.html#ab12f96a04e89e8c951f0eacb379f7ffc">01269</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#ab12f96a04e89e8c951f0eacb379f7ffc">builtin_int</a>;
<a name="l01270"></a><a class="code" href="structbuiltin__type.html#a52238d85813719573b7876379b145307">01270</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a52238d85813719573b7876379b145307">builtin_long</a>;
<a name="l01271"></a><a class="code" href="structbuiltin__type.html#a044a35581cb432c2cf47f3209c420164">01271</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a044a35581cb432c2cf47f3209c420164">builtin_signed_char</a>;
<a name="l01272"></a><a class="code" href="structbuiltin__type.html#a65b31f3aec59f348cc1916c176a54c8e">01272</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a65b31f3aec59f348cc1916c176a54c8e">builtin_unsigned_char</a>;
<a name="l01273"></a><a class="code" href="structbuiltin__type.html#ac0b67ca3b05727955e899eddb53e6bef">01273</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#ac0b67ca3b05727955e899eddb53e6bef">builtin_unsigned_short</a>;
<a name="l01274"></a><a class="code" href="structbuiltin__type.html#ac67e7a7e456c7b32a0700f2a3aab59d4">01274</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#ac67e7a7e456c7b32a0700f2a3aab59d4">builtin_unsigned_int</a>;
<a name="l01275"></a><a class="code" href="structbuiltin__type.html#adb875d7866f4cf67914872b93854c1b4">01275</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#adb875d7866f4cf67914872b93854c1b4">builtin_unsigned_long</a>;
<a name="l01276"></a><a class="code" href="structbuiltin__type.html#af44abaec1868fa0a34efaab02a436d6a">01276</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#af44abaec1868fa0a34efaab02a436d6a">builtin_float</a>;
<a name="l01277"></a><a class="code" href="structbuiltin__type.html#a29f1e28c1aa70321c4c7d4094f672b57">01277</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a29f1e28c1aa70321c4c7d4094f672b57">builtin_double</a>;
<a name="l01278"></a><a class="code" href="structbuiltin__type.html#a715dea24631a6825a39dbb26d85c87f5">01278</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a715dea24631a6825a39dbb26d85c87f5">builtin_long_double</a>;
<a name="l01279"></a><a class="code" href="structbuiltin__type.html#a7030db9f50d5d41574b34156ceb5ea38">01279</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a7030db9f50d5d41574b34156ceb5ea38">builtin_complex</a>;
<a name="l01280"></a><a class="code" href="structbuiltin__type.html#a9455eba48a3302f250cc4642e9d37f7d">01280</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a9455eba48a3302f250cc4642e9d37f7d">builtin_double_complex</a>;
<a name="l01281"></a><a class="code" href="structbuiltin__type.html#a2fbf31d83bfd21ca4a459d5012f8dd82">01281</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a2fbf31d83bfd21ca4a459d5012f8dd82">builtin_string</a>;
<a name="l01282"></a><a class="code" href="structbuiltin__type.html#a57a89bd1fdc8856566719d1dd9ccb4b1">01282</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a57a89bd1fdc8856566719d1dd9ccb4b1">builtin_bool</a>;
<a name="l01283"></a><a class="code" href="structbuiltin__type.html#a128563393645356d1b16420e6e8d48a2">01283</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a128563393645356d1b16420e6e8d48a2">builtin_long_long</a>;
<a name="l01284"></a><a class="code" href="structbuiltin__type.html#a762acf1511c503d73556da1b9487cf47">01284</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a762acf1511c503d73556da1b9487cf47">builtin_unsigned_long_long</a>;
<a name="l01285"></a><a class="code" href="structbuiltin__type.html#ab35ff0933e3e85c60028781395c69e0b">01285</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#ab35ff0933e3e85c60028781395c69e0b">builtin_decfloat</a>;
<a name="l01286"></a><a class="code" href="structbuiltin__type.html#ac69a34335b9be0fe0603e8979e101f0d">01286</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#ac69a34335b9be0fe0603e8979e101f0d">builtin_decdouble</a>;
<a name="l01287"></a><a class="code" href="structbuiltin__type.html#a08ba137b3f76b011d6213a2480776f86">01287</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a08ba137b3f76b011d6213a2480776f86">builtin_declong</a>;
<a name="l01288"></a>01288 
<a name="l01289"></a>01289   <span class="comment">/* &quot;True&quot; character types.</span>
<a name="l01290"></a>01290 <span class="comment">      We use these for the &#39;/c&#39; print format, because c_char is just a</span>
<a name="l01291"></a>01291 <span class="comment">      one-byte integral type, which languages less laid back than C</span>
<a name="l01292"></a>01292 <span class="comment">      will print as ... well, a one-byte integral type.  */</span>
<a name="l01293"></a><a class="code" href="structbuiltin__type.html#afe4574015ae6bc9b3ee2c1a8c5440e87">01293</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#afe4574015ae6bc9b3ee2c1a8c5440e87">builtin_true_char</a>;
<a name="l01294"></a><a class="code" href="structbuiltin__type.html#a62b7c7c269c00894245a60e10403a41e">01294</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a62b7c7c269c00894245a60e10403a41e">builtin_true_unsigned_char</a>;
<a name="l01295"></a>01295 
<a name="l01296"></a>01296   <span class="comment">/* Explicit sizes - see C9X &lt;intypes.h&gt; for naming scheme.  The &quot;int0&quot;</span>
<a name="l01297"></a>01297 <span class="comment">     is for when an architecture needs to describe a register that has</span>
<a name="l01298"></a>01298 <span class="comment">     no size.  */</span>
<a name="l01299"></a><a class="code" href="structbuiltin__type.html#a166be012cbf9b1f92709d0422305f883">01299</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a166be012cbf9b1f92709d0422305f883">builtin_int0</a>;
<a name="l01300"></a><a class="code" href="structbuiltin__type.html#a3bda6904e80e6a0de09549a1b51fb088">01300</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a3bda6904e80e6a0de09549a1b51fb088">builtin_int8</a>;
<a name="l01301"></a><a class="code" href="structbuiltin__type.html#ad57a1250e3b718be55d3810f484bdc3a">01301</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#ad57a1250e3b718be55d3810f484bdc3a">builtin_uint8</a>;
<a name="l01302"></a><a class="code" href="structbuiltin__type.html#adfd7e6377d8b18a3a019bdc9a7eff0b8">01302</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#adfd7e6377d8b18a3a019bdc9a7eff0b8">builtin_int16</a>;
<a name="l01303"></a><a class="code" href="structbuiltin__type.html#a2278f4cd3362bed6087abfb78d6fb1bd">01303</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a2278f4cd3362bed6087abfb78d6fb1bd">builtin_uint16</a>;
<a name="l01304"></a><a class="code" href="structbuiltin__type.html#ab514809bc3e50d6db51f7b1b0729f2cb">01304</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#ab514809bc3e50d6db51f7b1b0729f2cb">builtin_int32</a>;
<a name="l01305"></a><a class="code" href="structbuiltin__type.html#a7d0cf7d4e93c3cd2f1b744a18fa23b80">01305</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a7d0cf7d4e93c3cd2f1b744a18fa23b80">builtin_uint32</a>;
<a name="l01306"></a><a class="code" href="structbuiltin__type.html#a96f3cd71c9619fa5a5ae644402e841ec">01306</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a96f3cd71c9619fa5a5ae644402e841ec">builtin_int64</a>;
<a name="l01307"></a><a class="code" href="structbuiltin__type.html#a82b181ebbb2bdb20e94beafeb3497674">01307</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a82b181ebbb2bdb20e94beafeb3497674">builtin_uint64</a>;
<a name="l01308"></a><a class="code" href="structbuiltin__type.html#adab156fb5ac8e061ea16e8d6d0873a8f">01308</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#adab156fb5ac8e061ea16e8d6d0873a8f">builtin_int128</a>;
<a name="l01309"></a><a class="code" href="structbuiltin__type.html#a462e5c89d490be8effbd7f3efd50e330">01309</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a462e5c89d490be8effbd7f3efd50e330">builtin_uint128</a>;
<a name="l01310"></a>01310 
<a name="l01311"></a>01311   <span class="comment">/* Wide character types.  */</span>
<a name="l01312"></a><a class="code" href="structbuiltin__type.html#a8415d7432f815241fb3e7380fe3a9523">01312</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a8415d7432f815241fb3e7380fe3a9523">builtin_char16</a>;
<a name="l01313"></a><a class="code" href="structbuiltin__type.html#aca5c68334d371caf96361fd7be81d675">01313</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#aca5c68334d371caf96361fd7be81d675">builtin_char32</a>;
<a name="l01314"></a>01314 
<a name="l01315"></a>01315   <span class="comment">/* Pointer types.  */</span>
<a name="l01316"></a>01316 
<a name="l01317"></a>01317   <span class="comment">/* `pointer to data&#39; type.  Some target platforms use an implicitly</span>
<a name="l01318"></a>01318 <span class="comment">     {sign,zero} -extended 32-bit ABI pointer on a 64-bit ISA.  */</span>
<a name="l01319"></a><a class="code" href="structbuiltin__type.html#a55f6f9ff7436431777683d8ba62f662a">01319</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a55f6f9ff7436431777683d8ba62f662a">builtin_data_ptr</a>;
<a name="l01320"></a>01320 
<a name="l01321"></a>01321   <span class="comment">/* `pointer to function (returning void)&#39; type.  Harvard</span>
<a name="l01322"></a>01322 <span class="comment">     architectures mean that ABI function and code pointers are not</span>
<a name="l01323"></a>01323 <span class="comment">     interconvertible.  Similarly, since ANSI, C standards have</span>
<a name="l01324"></a>01324 <span class="comment">     explicitly said that pointers to functions and pointers to data</span>
<a name="l01325"></a>01325 <span class="comment">     are not interconvertible --- that is, you can&#39;t cast a function</span>
<a name="l01326"></a>01326 <span class="comment">     pointer to void * and back, and expect to get the same value.</span>
<a name="l01327"></a>01327 <span class="comment">     However, all function pointer types are interconvertible, so void</span>
<a name="l01328"></a>01328 <span class="comment">     (*) () can server as a generic function pointer.  */</span>
<a name="l01329"></a><a class="code" href="structbuiltin__type.html#a3db2ea73bd0003f6e6103bd031ba7cb1">01329</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a3db2ea73bd0003f6e6103bd031ba7cb1">builtin_func_ptr</a>;
<a name="l01330"></a>01330 
<a name="l01331"></a>01331   <span class="comment">/* `function returning pointer to function (returning void)&#39; type.</span>
<a name="l01332"></a>01332 <span class="comment">     The final void return type is not significant for it.  */</span>
<a name="l01333"></a><a class="code" href="structbuiltin__type.html#afda477090a6b336b49512fbc7b719633">01333</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#afda477090a6b336b49512fbc7b719633">builtin_func_func</a>;
<a name="l01334"></a>01334 
<a name="l01335"></a>01335 
<a name="l01336"></a>01336   <span class="comment">/* Special-purpose types.  */</span>
<a name="l01337"></a>01337 
<a name="l01338"></a>01338   <span class="comment">/* This type is used to represent a GDB internal function.  */</span>
<a name="l01339"></a><a class="code" href="structbuiltin__type.html#a19fc4b0e8524ffa2eb680f625164a161">01339</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structbuiltin__type.html#a19fc4b0e8524ffa2eb680f625164a161">internal_fn</a>;
<a name="l01340"></a>01340 };
<a name="l01341"></a>01341 
<a name="l01342"></a>01342 <span class="comment">/* Return the type table for the specified architecture.  */</span>
<a name="l01343"></a>01343 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structbuiltin__type.html">builtin_type</a> *<a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (<span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a>);
<a name="l01344"></a>01344 
<a name="l01345"></a>01345 
<a name="l01346"></a>01346 <span class="comment">/* Per-objfile types used by symbol readers.  */</span>
<a name="l01347"></a>01347 
<a name="l01348"></a><a class="code" href="structobjfile__type.html">01348</a> <span class="keyword">struct </span><a class="code" href="structobjfile__type.html">objfile_type</a>
<a name="l01349"></a>01349 {
<a name="l01350"></a>01350   <span class="comment">/* Basic types based on the objfile architecture.  */</span>
<a name="l01351"></a><a class="code" href="structobjfile__type.html#a4143df3933c553aa6f862ea7d3140151">01351</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#a4143df3933c553aa6f862ea7d3140151">builtin_void</a>;
<a name="l01352"></a><a class="code" href="structobjfile__type.html#a695e84fb9969e5a0ae671609f4af9a47">01352</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#a695e84fb9969e5a0ae671609f4af9a47">builtin_char</a>;
<a name="l01353"></a><a class="code" href="structobjfile__type.html#a981fdcee74e5081af2fd39a2559e3109">01353</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#a981fdcee74e5081af2fd39a2559e3109">builtin_short</a>;
<a name="l01354"></a><a class="code" href="structobjfile__type.html#a2c06bc9a1e779eb8f0936d386382da9a">01354</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#a2c06bc9a1e779eb8f0936d386382da9a">builtin_int</a>;
<a name="l01355"></a><a class="code" href="structobjfile__type.html#a31625148de3baf58086a0fb73c365d80">01355</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#a31625148de3baf58086a0fb73c365d80">builtin_long</a>;
<a name="l01356"></a><a class="code" href="structobjfile__type.html#a6dc46bf069ce3bf8c351ee4ff89d2793">01356</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#a6dc46bf069ce3bf8c351ee4ff89d2793">builtin_long_long</a>;
<a name="l01357"></a><a class="code" href="structobjfile__type.html#ab92852dd87743800bc29c4d4aee3426a">01357</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#ab92852dd87743800bc29c4d4aee3426a">builtin_signed_char</a>;
<a name="l01358"></a><a class="code" href="structobjfile__type.html#aaffa5153f6021da3a0ecb3bc4d73866f">01358</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#aaffa5153f6021da3a0ecb3bc4d73866f">builtin_unsigned_char</a>;
<a name="l01359"></a><a class="code" href="structobjfile__type.html#add288b2b113d0265f41b7fa98e93a95e">01359</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#add288b2b113d0265f41b7fa98e93a95e">builtin_unsigned_short</a>;
<a name="l01360"></a><a class="code" href="structobjfile__type.html#a2209786fd5d2ab9002b0b1e8c3a3e8a6">01360</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#a2209786fd5d2ab9002b0b1e8c3a3e8a6">builtin_unsigned_int</a>;
<a name="l01361"></a><a class="code" href="structobjfile__type.html#a3b7e9cc9ecc601dd74e3ebe2bbc9e406">01361</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#a3b7e9cc9ecc601dd74e3ebe2bbc9e406">builtin_unsigned_long</a>;
<a name="l01362"></a><a class="code" href="structobjfile__type.html#af8c91baa18000f7c19e4f24f30eaa357">01362</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#af8c91baa18000f7c19e4f24f30eaa357">builtin_unsigned_long_long</a>;
<a name="l01363"></a><a class="code" href="structobjfile__type.html#a7380f347f0e72ae3de6c1dee76445ca5">01363</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#a7380f347f0e72ae3de6c1dee76445ca5">builtin_float</a>;
<a name="l01364"></a><a class="code" href="structobjfile__type.html#af181bc724afe829bae50e9f0ae0486e7">01364</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#af181bc724afe829bae50e9f0ae0486e7">builtin_double</a>;
<a name="l01365"></a><a class="code" href="structobjfile__type.html#a71e36bcbbe145df00eaa99daf644bb8d">01365</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#a71e36bcbbe145df00eaa99daf644bb8d">builtin_long_double</a>;
<a name="l01366"></a>01366 
<a name="l01367"></a>01367   <span class="comment">/* This type is used to represent symbol addresses.  */</span>
<a name="l01368"></a><a class="code" href="structobjfile__type.html#ad83f60998b933fb4fec11e38ba67dee5">01368</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#ad83f60998b933fb4fec11e38ba67dee5">builtin_core_addr</a>;
<a name="l01369"></a>01369 
<a name="l01370"></a>01370   <span class="comment">/* This type represents a type that was unrecognized in symbol read-in.  */</span>
<a name="l01371"></a><a class="code" href="structobjfile__type.html#a154dcfbae48033268966abbf7854b0f5">01371</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#a154dcfbae48033268966abbf7854b0f5">builtin_error</a>;
<a name="l01372"></a>01372 
<a name="l01373"></a>01373   <span class="comment">/* Types used for symbols with no debug information.  */</span>
<a name="l01374"></a><a class="code" href="structobjfile__type.html#ae6687105f6162048a82c16720de5590e">01374</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#ae6687105f6162048a82c16720de5590e">nodebug_text_symbol</a>;
<a name="l01375"></a><a class="code" href="structobjfile__type.html#ad35a37848eb39d1838c771f615419c35">01375</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#ad35a37848eb39d1838c771f615419c35">nodebug_text_gnu_ifunc_symbol</a>;
<a name="l01376"></a><a class="code" href="structobjfile__type.html#a154acf9be73190565bf1b35e094f5701">01376</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#a154acf9be73190565bf1b35e094f5701">nodebug_got_plt_symbol</a>;
<a name="l01377"></a><a class="code" href="structobjfile__type.html#af2516f8f1d7556b0bc245154c635fa79">01377</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#af2516f8f1d7556b0bc245154c635fa79">nodebug_data_symbol</a>;
<a name="l01378"></a><a class="code" href="structobjfile__type.html#a06fdf65e3aeb2d03bb57f57e5ff2ea70">01378</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#a06fdf65e3aeb2d03bb57f57e5ff2ea70">nodebug_unknown_symbol</a>;
<a name="l01379"></a><a class="code" href="structobjfile__type.html#a07d3ff97f6062fe9d46a45503105477c">01379</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structobjfile__type.html#a07d3ff97f6062fe9d46a45503105477c">nodebug_tls_symbol</a>;
<a name="l01380"></a>01380 };
<a name="l01381"></a>01381 
<a name="l01382"></a>01382 <span class="comment">/* Return the type table for the specified objfile.  */</span>
<a name="l01383"></a>01383 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structobjfile__type.html">objfile_type</a> *<a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>);
<a name="l01384"></a>01384 
<a name="l01385"></a>01385  
<a name="l01386"></a>01386 <span class="comment">/* Explicit floating-point formats.  See &quot;floatformat.h&quot;.  */</span>
<a name="l01387"></a>01387 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span>floatformat *<a class="code" href="gdbtypes_8c.html#aff241a14077f903a7e4dc728ca497ac3">floatformats_ieee_half</a>[BFD_ENDIAN_UNKNOWN];
<a name="l01388"></a>01388 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span>floatformat *<a class="code" href="gdbtypes_8c.html#a2fcc5f34f85af43cce0eb78225fd2a11">floatformats_ieee_single</a>[BFD_ENDIAN_UNKNOWN];
<a name="l01389"></a>01389 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span>floatformat *<a class="code" href="gdbtypes_8c.html#ab5eaf32f7eeeb57f880c28ff0d7544ae">floatformats_ieee_double</a>[BFD_ENDIAN_UNKNOWN];
<a name="l01390"></a>01390 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span>floatformat *<a class="code" href="gdbtypes_8c.html#a956f16db2cd5f9acd4169d60ccae1456">floatformats_ieee_double_littlebyte_bigword</a>[BFD_ENDIAN_UNKNOWN];
<a name="l01391"></a>01391 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span>floatformat *<a class="code" href="gdbtypes_8c.html#a680c463379f95d0f85b87bc564b52f34">floatformats_i387_ext</a>[BFD_ENDIAN_UNKNOWN];
<a name="l01392"></a>01392 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span>floatformat *<a class="code" href="gdbtypes_8c.html#a32c82eaca99047649e4c57acf8652763">floatformats_m68881_ext</a>[BFD_ENDIAN_UNKNOWN];
<a name="l01393"></a>01393 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span>floatformat *<a class="code" href="gdbtypes_8c.html#afda5ec50efe91294b790b39d029e2b7f">floatformats_arm_ext</a>[BFD_ENDIAN_UNKNOWN];
<a name="l01394"></a>01394 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span>floatformat *<a class="code" href="gdbtypes_8c.html#a71aed52cadaa49d14f1d7fefdae8375e">floatformats_ia64_spill</a>[BFD_ENDIAN_UNKNOWN];
<a name="l01395"></a>01395 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span>floatformat *<a class="code" href="gdbtypes_8c.html#a1ea1201b05023ea2babf75d55406e9c4">floatformats_ia64_quad</a>[BFD_ENDIAN_UNKNOWN];
<a name="l01396"></a>01396 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span>floatformat *<a class="code" href="gdbtypes_8c.html#a5a0964925864ccab1969c17b7722b901">floatformats_vax_f</a>[BFD_ENDIAN_UNKNOWN];
<a name="l01397"></a>01397 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span>floatformat *<a class="code" href="gdbtypes_8c.html#a1070ea9fe234cc496c4f497452e2005a">floatformats_vax_d</a>[BFD_ENDIAN_UNKNOWN];
<a name="l01398"></a>01398 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span>floatformat *<a class="code" href="gdbtypes_8c.html#a00ce2ca5b07ae8ff5159988c71396aba">floatformats_ibm_long_double</a>[BFD_ENDIAN_UNKNOWN];
<a name="l01399"></a>01399 
<a name="l01400"></a>01400 
<a name="l01401"></a>01401 <span class="comment">/* Allocate space for storing data associated with a particular type.</span>
<a name="l01402"></a>01402 <span class="comment">   We ensure that the space is allocated using the same mechanism that</span>
<a name="l01403"></a>01403 <span class="comment">   was used to allocate the space for the type structure itself.  I.e.</span>
<a name="l01404"></a>01404 <span class="comment">   if the type is on an objfile&#39;s objfile_obstack, then the space for data</span>
<a name="l01405"></a>01405 <span class="comment">   associated with that type will also be allocated on the objfile_obstack.</span>
<a name="l01406"></a>01406 <span class="comment">   If the type is not associated with any particular objfile (such as</span>
<a name="l01407"></a>01407 <span class="comment">   builtin types), then the data space will be allocated with xmalloc,</span>
<a name="l01408"></a>01408 <span class="comment">   the same as for the type structure.  */</span>
<a name="l01409"></a>01409 
<a name="l01410"></a><a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">01410</a> <span class="preprocessor">#define TYPE_ALLOC(t,size)  \</span>
<a name="l01411"></a>01411 <span class="preprocessor">   (TYPE_OBJFILE_OWNED (t) \</span>
<a name="l01412"></a>01412 <span class="preprocessor">    ? obstack_alloc (&amp;TYPE_OBJFILE (t) -&gt; objfile_obstack, size) \</span>
<a name="l01413"></a>01413 <span class="preprocessor">    : xmalloc (size))</span>
<a name="l01414"></a>01414 <span class="preprocessor"></span>
<a name="l01415"></a><a class="code" href="gdbtypes_8h.html#a01507b6808623c0c49a222acac6f841c">01415</a> <span class="preprocessor">#define TYPE_ZALLOC(t,size)  \</span>
<a name="l01416"></a>01416 <span class="preprocessor">   (TYPE_OBJFILE_OWNED (t) \</span>
<a name="l01417"></a>01417 <span class="preprocessor">    ? memset (obstack_alloc (&amp;TYPE_OBJFILE (t)-&gt;objfile_obstack, size),  \</span>
<a name="l01418"></a>01418 <span class="preprocessor">              0, size)  \</span>
<a name="l01419"></a>01419 <span class="preprocessor">    : xzalloc (size))</span>
<a name="l01420"></a>01420 <span class="preprocessor"></span>
<a name="l01421"></a>01421 <span class="comment">/* Use alloc_type to allocate a type owned by an objfile.</span>
<a name="l01422"></a>01422 <span class="comment">   Use alloc_type_arch to allocate a type owned by an architecture.</span>
<a name="l01423"></a>01423 <span class="comment">   Use alloc_type_copy to allocate a type with the same owner as a</span>
<a name="l01424"></a>01424 <span class="comment">   pre-existing template type, no matter whether objfile or gdbarch.  */</span>
<a name="l01425"></a>01425 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a0929c0c96b083ea88998926b06d62d01">alloc_type</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l01426"></a>01426 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a3cd07ce1f93e53ab4bea0b48ce3c4554">alloc_type_arch</a> (<span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *);
<a name="l01427"></a>01427 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a2e8f72ee412f83ecd89f47068fda9634">alloc_type_copy</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01428"></a>01428 
<a name="l01429"></a>01429 <span class="comment">/* Return the type&#39;s architecture.  For types owned by an architecture,</span>
<a name="l01430"></a>01430 <span class="comment">   that architecture is returned.  For types owned by an objfile, that</span>
<a name="l01431"></a>01431 <span class="comment">   objfile&#39;s architecture is returned.  */</span>
<a name="l01432"></a>01432 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="gdbtypes_8c.html#a84ca61a6d58c2bd2c7dcedf19d56a39d">get_type_arch</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01433"></a>01433 
<a name="l01434"></a>01434 <span class="comment">/* Helper function to construct objfile-owned types.  */</span>
<a name="l01435"></a>01435 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#ac74c6d3def8258efc09a3deb8f395d64">init_type</a> (<span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *,
<a name="l01436"></a>01436                                <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l01437"></a>01437 
<a name="l01438"></a>01438 <span class="comment">/* Helper functions to construct architecture-owned types.  */</span>
<a name="l01439"></a>01439 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a4b444f0f6cfacb3f35d68fd7866402e2">arch_type</a> (<span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *, <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a>, <span class="keywordtype">int</span>, <span class="keywordtype">char</span> *);
<a name="l01440"></a>01440 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (<span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">char</span> *);
<a name="l01441"></a>01441 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#abf097ab6cef555918409ef2c4ed8335d">arch_character_type</a> (<span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">char</span> *);
<a name="l01442"></a>01442 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a96583a5ee2a894c239ad5018ca977f45">arch_boolean_type</a> (<span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">char</span> *);
<a name="l01443"></a>01443 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a793ccf335a07069a67a654084cd4a513">arch_float_type</a> (<span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *, <span class="keywordtype">int</span>, <span class="keywordtype">char</span> *,
<a name="l01444"></a>01444                                      <span class="keyword">const</span> <span class="keyword">struct</span> floatformat **);
<a name="l01445"></a>01445 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a0cd16e70a93da3e835cb945e56ea8ba7">arch_complex_type</a> (<span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *, <span class="keywordtype">char</span> *,
<a name="l01446"></a>01446                                        <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01447"></a>01447 
<a name="l01448"></a>01448 <span class="comment">/* Helper functions to construct a struct or record type.  An</span>
<a name="l01449"></a>01449 <span class="comment">   initially empty type is created using arch_composite_type().</span>
<a name="l01450"></a>01450 <span class="comment">   Fields are then added using append_composite_type_field*().  A union</span>
<a name="l01451"></a>01451 <span class="comment">   type has its size set to the largest field.  A struct type has each</span>
<a name="l01452"></a>01452 <span class="comment">   field packed against the previous.  */</span>
<a name="l01453"></a>01453 
<a name="l01454"></a>01454 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a3e82e9d618c11c61cbae9b89d00efc1b">arch_composite_type</a> (<span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a>,
<a name="l01455"></a>01455                                          <span class="keywordtype">char</span> *<a class="code" href="structmain__type.html#ac6545878d5e92b3dfdc799e3980e5b6e">name</a>, <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> <a class="code" href="ser-unix_8c.html#a45a5b7c00a796a23f01673cef1dbe0a9">code</a>);
<a name="l01456"></a>01456 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="gdbtypes_8c.html#a8e501de48b50f6deb1568b5ade567f2a">append_composite_type_field</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *t, <span class="keywordtype">char</span> *<a class="code" href="structmain__type.html#ac6545878d5e92b3dfdc799e3980e5b6e">name</a>,
<a name="l01457"></a>01457                                          <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *field);
<a name="l01458"></a>01458 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="gdbtypes_8c.html#a811622e1494545af9574c85d5b33ae5b">append_composite_type_field_aligned</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *t,
<a name="l01459"></a>01459                                                  <span class="keywordtype">char</span> *<a class="code" href="structmain__type.html#ac6545878d5e92b3dfdc799e3980e5b6e">name</a>,
<a name="l01460"></a>01460                                                  <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *field,
<a name="l01461"></a>01461                                                  <span class="keywordtype">int</span> alignment);
<a name="l01462"></a>01462 <span class="keyword">struct </span>field *<a class="code" href="gdbtypes_8c.html#a9da6e7332f9a13845fc8bd095abbe927">append_composite_type_field_raw</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *t, <span class="keywordtype">char</span> *<a class="code" href="structmain__type.html#ac6545878d5e92b3dfdc799e3980e5b6e">name</a>,
<a name="l01463"></a>01463                                                <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *field);
<a name="l01464"></a>01464 
<a name="l01465"></a>01465 <span class="comment">/* Helper functions to construct a bit flags type.  An initially empty</span>
<a name="l01466"></a>01466 <span class="comment">   type is created using arch_flag_type().  Flags are then added using</span>
<a name="l01467"></a>01467 <span class="comment">   append_flag_type_flag().  */</span>
<a name="l01468"></a>01468 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a9a9557729e74c821a1e1b1c39fb0cafc">arch_flags_type</a> (<span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a>,
<a name="l01469"></a>01469                                      <span class="keywordtype">char</span> *<a class="code" href="structmain__type.html#ac6545878d5e92b3dfdc799e3980e5b6e">name</a>, <span class="keywordtype">int</span> <a class="code" href="structtype.html#a73598608f0395a10828a7f69cb843d70">length</a>);
<a name="l01470"></a>01470 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="gdbtypes_8c.html#aba7bd1312b7850d68c5a8e9e934e3512">append_flags_type_flag</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keywordtype">int</span> <a class="code" href="structmain__type.html#a12a99669f6e1e5b4360fb6423658d497">bitpos</a>, <span class="keywordtype">char</span> *<a class="code" href="structmain__type.html#ac6545878d5e92b3dfdc799e3980e5b6e">name</a>);
<a name="l01471"></a>01471 
<a name="l01472"></a>01472 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="gdbtypes_8c.html#af80dd4539475753c833d2a7df64e3060">make_vector_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *array_type);
<a name="l01473"></a>01473 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a93eefcbb5ac6aec0f3f1c96e186bfdef">init_vector_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *elt_type, <span class="keywordtype">int</span> n);
<a name="l01474"></a>01474 
<a name="l01475"></a>01475 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#afa9bb6a94856e413a9932abea7356e22">lookup_reference_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01476"></a>01476 
<a name="l01477"></a>01477 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a952201ee0995dfa6e045d289b9d01167">make_reference_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **);
<a name="l01478"></a>01478 
<a name="l01479"></a>01479 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#ab5e31dbb249efdac4f48d4871290bf46">make_cv_type</a> (<span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **);
<a name="l01480"></a>01480 
<a name="l01481"></a>01481 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#ae14549e9e4d111171b30b21aa35fa048">make_restrict_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01482"></a>01482 
<a name="l01483"></a>01483 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="gdbtypes_8c.html#ab72db02ed9868fbaa967bb96dd4662e6">replace_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01484"></a>01484 
<a name="l01485"></a>01485 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#a9baa80b36263389d369e1624c12f4f62">address_space_name_to_int</a> (<span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *, <span class="keywordtype">char</span> *);
<a name="l01486"></a>01486 
<a name="l01487"></a>01487 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="gdbtypes_8c.html#a4c46adabb03421efde93b51817a08e45">address_space_int_to_name</a> (<span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *, <span class="keywordtype">int</span>);
<a name="l01488"></a>01488 
<a name="l01489"></a>01489 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#aad73132bd29e0c9552b8ecf04473241d">make_type_with_address_space</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, 
<a name="l01490"></a>01490                                                   <span class="keywordtype">int</span> space_identifier);
<a name="l01491"></a>01491 
<a name="l01492"></a>01492 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a133dbb915fedac068ac437460da3d13b">lookup_memberptr_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01493"></a>01493 
<a name="l01494"></a>01494 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#abe0e31f80a8f4e227727ea42ce596dd9">lookup_methodptr_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01495"></a>01495 
<a name="l01496"></a>01496 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="gdbtypes_8c.html#afae62bb1c2fdb5c6e6dafdbf7d5f935f">smash_to_method_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> type *domain,
<a name="l01497"></a>01497                                   <span class="keyword">struct</span> type *to_type, <span class="keyword">struct</span> field *args,
<a name="l01498"></a>01498                                   <span class="keywordtype">int</span> nargs, <span class="keywordtype">int</span> varargs);
<a name="l01499"></a>01499 
<a name="l01500"></a>01500 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="gdbtypes_8c.html#a7e82840e04d39176d3c087cc42fe6761">smash_to_memberptr_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l01501"></a>01501                                      <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01502"></a>01502 
<a name="l01503"></a>01503 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="gdbtypes_8c.html#a9ab5ed967338b8c238f568f75097ad53">smash_to_methodptr_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01504"></a>01504 
<a name="l01505"></a>01505 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#aab9d1b477911f6b7e68e5b0dad6aff77">allocate_stub_method</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01506"></a>01506 
<a name="l01507"></a>01507 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="gdbtypes_8c.html#a1bce8398d8a46f3d37bfc7e618ab9e9d">type_name_no_tag</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01508"></a>01508 
<a name="l01509"></a>01509 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="gdbtypes_8c.html#abcdee541a871ec6c4a8066113cd5f2fb">type_name_no_tag_or_error</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>);
<a name="l01510"></a>01510 
<a name="l01511"></a>01511 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#af148a4aea0393ca08a9da997b8cda7d6">lookup_struct_elt_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>);
<a name="l01512"></a>01512 
<a name="l01513"></a>01513 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a6013d2e7f97ec899887d0bd1c4f9817e">make_pointer_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **);
<a name="l01514"></a>01514 
<a name="l01515"></a>01515 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01516"></a>01516 
<a name="l01517"></a>01517 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a0faf05fe325d2ad028dcc2630056fb88">make_function_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **);
<a name="l01518"></a>01518 
<a name="l01519"></a>01519 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#ab21dd6531306fba2a7078534017df6fb">lookup_function_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01520"></a>01520 
<a name="l01521"></a>01521 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a8691b190da815f4a90d21dd0c0ae921e">lookup_function_type_with_arguments</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l01522"></a>01522                                                          <span class="keywordtype">int</span>,
<a name="l01523"></a>01523                                                          <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **);
<a name="l01524"></a>01524 
<a name="l01525"></a>01525 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#ab0885fdae181c47ff3f958bcba70b82d">create_range_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>,
<a name="l01526"></a>01526                                        <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>);
<a name="l01527"></a>01527 
<a name="l01528"></a>01528 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a779bbebb8202264a73344b49b22d774e">create_array_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l01529"></a>01529                                        <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01530"></a>01530 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a91c24db4658fe0833c46b6fe5d677159">lookup_array_range_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>);
<a name="l01531"></a>01531 
<a name="l01532"></a>01532 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a02305c2213c2302683719ce68acf0f7e">create_string_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l01533"></a>01533                                         <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01534"></a>01534 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a07dfeb10d05931ffd294e444eafcacd5">lookup_string_range_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>);
<a name="l01535"></a>01535 
<a name="l01536"></a>01536 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a9b379f0366f139b0c80be4898b1f0f7b">create_set_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01537"></a>01537 
<a name="l01538"></a>01538 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a5b22148a3b260ef0ee2611c0f1572a88">lookup_unsigned_typename</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlanguage__defn.html">language_defn</a> *,
<a name="l01539"></a>01539                                               <span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l01540"></a>01540 
<a name="l01541"></a>01541 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#ac51f12ce9aa28f47ba3bcc26b39a02b4">lookup_signed_typename</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlanguage__defn.html">language_defn</a> *,
<a name="l01542"></a>01542                                             <span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l01543"></a>01543 
<a name="l01544"></a>01544 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01545"></a>01545 
<a name="l01546"></a><a class="code" href="gdbtypes_8h.html#ae2f9348c644babaa9038b4dc18bffaac">01546</a> <span class="preprocessor">#define CHECK_TYPEDEF(TYPE)                     \</span>
<a name="l01547"></a>01547 <span class="preprocessor">  do {                                          \</span>
<a name="l01548"></a>01548 <span class="preprocessor">    (TYPE) = check_typedef (TYPE);              \</span>
<a name="l01549"></a>01549 <span class="preprocessor">  } while (0)</span>
<a name="l01550"></a>01550 <span class="preprocessor"></span>
<a name="l01551"></a>01551 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="gdbtypes_8c.html#a104ee91f58366ea5451ad5e9ea42b327">check_stub_method_group</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keywordtype">int</span>);
<a name="l01552"></a>01552 
<a name="l01553"></a>01553 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="gdbtypes_8h.html#a6e342e8232f052b96220ed8f5ee8c034">gdb_mangle_name</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);
<a name="l01554"></a>01554 
<a name="l01555"></a>01555 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#adadb1dc66dab92ad081c55f355a1582c">lookup_typename</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlanguage__defn.html">language_defn</a> *,
<a name="l01556"></a>01556                                      <span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *,
<a name="l01557"></a>01557                                      <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *, <span class="keywordtype">int</span>);
<a name="l01558"></a>01558 
<a name="l01559"></a>01559 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a079fa3f95bf00e597b8837b95770b48c">lookup_template_type</a> (<span class="keywordtype">char</span> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l01560"></a>01560                                           <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *);
<a name="l01561"></a>01561 
<a name="l01562"></a>01562 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#ac29bc4d1a96b9275c1f4522d734fb14b">get_vptr_fieldno</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **);
<a name="l01563"></a>01563 
<a name="l01564"></a>01564 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#a6b7f508cb2cdaf4d8f53494d9239b163">get_discrete_bounds</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *);
<a name="l01565"></a>01565 
<a name="l01566"></a>01566 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#a499d94cb3d0212c4f898aa51f264da65">get_array_bounds</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *low_bound,
<a name="l01567"></a>01567                              <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *high_bound);
<a name="l01568"></a>01568 
<a name="l01569"></a>01569 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#ad4e64ffdca6d0e40e350c4b5a72d0712">class_types_same_p</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01570"></a>01570 
<a name="l01571"></a>01571 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#aa76bf4be3e0efb00a674a991d5ef95f2">is_ancestor</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01572"></a>01572 
<a name="l01573"></a>01573 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#aabe098d2282927629df79faa6acd8b5f">is_public_ancestor</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01574"></a>01574 
<a name="l01575"></a>01575 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#a970bab06a136d8205e71ee88629b639e">is_unique_ancestor</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *);
<a name="l01576"></a>01576 
<a name="l01577"></a>01577 <span class="comment">/* Overload resolution */</span>
<a name="l01578"></a>01578 
<a name="l01579"></a><a class="code" href="gdbtypes_8h.html#af6997379fee43d7e0e42475222fa38a8">01579</a> <span class="preprocessor">#define LENGTH_MATCH(bv) ((bv)-&gt;rank[0])</span>
<a name="l01580"></a>01580 <span class="preprocessor"></span>
<a name="l01581"></a>01581 <span class="comment">/* Badness if parameter list length doesn&#39;t match arg list length.  */</span>
<a name="l01582"></a>01582 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#afad4c215a3ed4cea2306d3350d6711e7">LENGTH_MISMATCH_BADNESS</a>;
<a name="l01583"></a>01583 
<a name="l01584"></a>01584 <span class="comment">/* Dummy badness value for nonexistent parameter positions.  */</span>
<a name="l01585"></a>01585 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#ac9c6d6c022e76c5cbde443299ca3a24d">TOO_FEW_PARAMS_BADNESS</a>;
<a name="l01586"></a>01586 <span class="comment">/* Badness if no conversion among types.  */</span>
<a name="l01587"></a>01587 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#a0859fdf4de5e553a6540635295d11b99">INCOMPATIBLE_TYPE_BADNESS</a>;
<a name="l01588"></a>01588 
<a name="l01589"></a>01589 <span class="comment">/* Badness of an exact match.  */</span>
<a name="l01590"></a>01590 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#a97e7af63cf2a070514079194c4e21ad9">EXACT_MATCH_BADNESS</a>;
<a name="l01591"></a>01591 
<a name="l01592"></a>01592 <span class="comment">/* Badness of integral promotion.  */</span>
<a name="l01593"></a>01593 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#a0878a39da425524d446952164996130d">INTEGER_PROMOTION_BADNESS</a>;
<a name="l01594"></a>01594 <span class="comment">/* Badness of floating promotion.  */</span>
<a name="l01595"></a>01595 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#ac9b23dd6619b3ffb5a89f1ff41c805a0">FLOAT_PROMOTION_BADNESS</a>;
<a name="l01596"></a>01596 <span class="comment">/* Badness of converting a derived class pointer</span>
<a name="l01597"></a>01597 <span class="comment">   to a base class pointer.  */</span>
<a name="l01598"></a>01598 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#a681f940e46164147b0dc6ef8779f285b">BASE_PTR_CONVERSION_BADNESS</a>;
<a name="l01599"></a>01599 <span class="comment">/* Badness of integral conversion.  */</span>
<a name="l01600"></a>01600 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#afdc13d6d2756ce7c41a8b8cde7d0ad85">INTEGER_CONVERSION_BADNESS</a>;
<a name="l01601"></a>01601 <span class="comment">/* Badness of floating conversion.  */</span>
<a name="l01602"></a>01602 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#a995085702fe2e7803c9233a3db4a4180">FLOAT_CONVERSION_BADNESS</a>;
<a name="l01603"></a>01603 <span class="comment">/* Badness of integer&lt;-&gt;floating conversions.  */</span>
<a name="l01604"></a>01604 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#a8b66750379ca672664782a0bbbc8ea76">INT_FLOAT_CONVERSION_BADNESS</a>;
<a name="l01605"></a>01605 <span class="comment">/* Badness of conversion of pointer to void pointer.  */</span>
<a name="l01606"></a>01606 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#abf033a7327e6a108b697c2146d444cfc">VOID_PTR_CONVERSION_BADNESS</a>;
<a name="l01607"></a>01607 <span class="comment">/* Badness of conversion to boolean.  */</span>
<a name="l01608"></a>01608 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#af977d9b9c5f13ec8e153d84306a00550">BOOL_CONVERSION_BADNESS</a>;
<a name="l01609"></a>01609 <span class="comment">/* Badness of converting derived to base class.  */</span>
<a name="l01610"></a>01610 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#a4ee14cbfa882b1e67ba83003447850fc">BASE_CONVERSION_BADNESS</a>;
<a name="l01611"></a>01611 <span class="comment">/* Badness of converting from non-reference to reference.  */</span>
<a name="l01612"></a>01612 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#a6dff35e00ca6a767fa43e309821ac594">REFERENCE_CONVERSION_BADNESS</a>;
<a name="l01613"></a>01613 <span class="comment">/* Badness of converting integer 0 to NULL pointer.  */</span>
<a name="l01614"></a>01614 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8h.html#ab35ed3a8c62ef1b33dcf7bfd7b6ddaaa">NULL_POINTER_CONVERSION</a>;
<a name="l01615"></a>01615 
<a name="l01616"></a>01616 <span class="comment">/* Non-standard conversions allowed by the debugger */</span>
<a name="l01617"></a>01617 <span class="comment">/* Converting a pointer to an int is usually OK.  */</span>
<a name="l01618"></a>01618 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#ae40be37fa4c5597f7cc6e6d062a820f7">NS_POINTER_CONVERSION_BADNESS</a>;
<a name="l01619"></a>01619 
<a name="l01620"></a>01620 <span class="comment">/* Badness of converting a (non-zero) integer constant</span>
<a name="l01621"></a>01621 <span class="comment">   to a pointer.  */</span>
<a name="l01622"></a>01622 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#a7838383c697ddf3c54208bd25ac8a31b">NS_INTEGER_POINTER_CONVERSION_BADNESS</a>;
<a name="l01623"></a>01623 
<a name="l01624"></a>01624 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#af8dc428960e15574a3c62d6661e55993">sum_ranks</a> (struct <a class="code" href="structrank.html">rank</a> a, struct <a class="code" href="structrank.html">rank</a> b);
<a name="l01625"></a>01625 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#a84e2bb70a3bb63b01315ad128ca294d1">compare_ranks</a> (<span class="keyword">struct</span> <a class="code" href="structrank.html">rank</a> a, <span class="keyword">struct</span> <a class="code" href="structrank.html">rank</a> b);
<a name="l01626"></a>01626 
<a name="l01627"></a>01627 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#a00978bb926d19570635f0aa9a8b2a9f4">compare_badness</a> (<span class="keyword">struct</span> <a class="code" href="structbadness__vector.html">badness_vector</a> *, <span class="keyword">struct</span> <a class="code" href="structbadness__vector.html">badness_vector</a> *);
<a name="l01628"></a>01628 
<a name="l01629"></a>01629 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structbadness__vector.html">badness_vector</a> *<a class="code" href="gdbtypes_8c.html#a4fef7bb1d2ff1a5eac00003a62eb4ae1">rank_function</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **, <span class="keywordtype">int</span>,
<a name="l01630"></a>01630                                              <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **, <span class="keywordtype">int</span>);
<a name="l01631"></a>01631 
<a name="l01632"></a>01632 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structrank.html">rank</a> <a class="code" href="gdbtypes_8c.html#a46e5531c7311495575754d2722b654d0">rank_one_type</a> (struct <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *,
<a name="l01633"></a>01633                                   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *);
<a name="l01634"></a>01634 
<a name="l01635"></a>01635 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="gdbtypes_8c.html#adcf3983e09aa79711d7a9711296f0768">recursive_dump_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keywordtype">int</span>);
<a name="l01636"></a>01636 
<a name="l01637"></a>01637 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#a38a5ce3cc244d3f0618908f9a7ceca62">field_is_static</a> (<span class="keyword">struct</span> field *);
<a name="l01638"></a>01638 
<a name="l01639"></a>01639 <span class="comment">/* printcmd.c */</span>
<a name="l01640"></a>01640 
<a name="l01641"></a>01641 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="gdbtypes_8h.html#a7b01a75e18ea7083fc6abaebc996f70e">print_scalar_formatted</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l01642"></a>01642                                     <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structvalue__print__options.html">value_print_options</a> *,
<a name="l01643"></a>01643                                     <span class="keywordtype">int</span>, <span class="keyword">struct</span> <a class="code" href="structui__file.html">ui_file</a> *);
<a name="l01644"></a>01644 
<a name="l01645"></a>01645 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#aff78936933f772fdf4f8ca83258f8a82">can_dereference</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01646"></a>01646 
<a name="l01647"></a>01647 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#a292da1df1ddf044d92c8958d304aac2d">is_integral_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01648"></a>01648 
<a name="l01649"></a>01649 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#a0f2f17623338e84ad1bff7fba7f32daa">is_scalar_type_recursive</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01650"></a>01650 
<a name="l01651"></a>01651 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="gdbtypes_8h.html#a037424e36c971d25458a0631e8a25c7f">maintenance_print_type</a> (<span class="keywordtype">char</span> *, <span class="keywordtype">int</span>);
<a name="l01652"></a>01652 
<a name="l01653"></a>01653 <span class="keyword">extern</span> htab_t <a class="code" href="gdbtypes_8c.html#ae5ea276bc197accde0f748fc6df2ae6b">create_copied_types_hash</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>);
<a name="l01654"></a>01654 
<a name="l01655"></a>01655 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#ac557106711cd3c47cd660fff9d773edd">copy_type_recursive</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l01656"></a>01656                                          <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>,
<a name="l01657"></a>01657                                          htab_t copied_types);
<a name="l01658"></a>01658 
<a name="l01659"></a>01659 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="gdbtypes_8c.html#a73be1910eae6da9c7ec226a3d38beeac">copy_type</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>);
<a name="l01660"></a>01660 
<a name="l01661"></a>01661 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#a795feab717db4babc1d7db5dcb512736">types_equal</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l01662"></a>01662 
<a name="l01663"></a>01663 <span class="preprocessor">#endif </span><span class="comment">/* GDBTYPES_H */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:13:27 for GDB (xrefs) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
