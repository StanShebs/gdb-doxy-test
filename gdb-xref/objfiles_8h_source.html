<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (xrefs): /home/stan/gdb/src/gdb/objfiles.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (xrefs)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/objfiles.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="objfiles_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Definitions for symbol file management in GDB.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 1992-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   This file is part of GDB.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00010"></a>00010 <span class="comment">   (at your option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00018"></a>00018 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#if !defined (OBJFILES_H)</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">#define OBJFILES_H</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="gdb__obstack_8h.html">gdb_obstack.h</a>&quot;</span>        <span class="comment">/* For obstack internals.  */</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="symfile_8h.html">symfile.h</a>&quot;</span>            <span class="comment">/* For struct psymbol_allocation_list.  */</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="progspace_8h.html">progspace.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="registry_8h.html">registry.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="gdb__bfd_8h.html">gdb_bfd.h</a>&quot;</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="keyword">struct </span><a class="code" href="structbcache.html">bcache</a>;
<a name="l00030"></a>00030 <span class="keyword">struct </span>htab;
<a name="l00031"></a>00031 <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a>;
<a name="l00032"></a>00032 <span class="keyword">struct </span>objfile_data;
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="comment">/* This structure maintains information on a per-objfile basis about the</span>
<a name="l00035"></a>00035 <span class="comment">   &quot;entry point&quot; of the objfile, and the scope within which the entry point</span>
<a name="l00036"></a>00036 <span class="comment">   exists.  It is possible that gdb will see more than one objfile that is</span>
<a name="l00037"></a>00037 <span class="comment">   executable, each with its own entry point.</span>
<a name="l00038"></a>00038 <span class="comment"></span>
<a name="l00039"></a>00039 <span class="comment">   For example, for dynamically linked executables in SVR4, the dynamic linker</span>
<a name="l00040"></a>00040 <span class="comment">   code is contained within the shared C library, which is actually executable</span>
<a name="l00041"></a>00041 <span class="comment">   and is run by the kernel first when an exec is done of a user executable</span>
<a name="l00042"></a>00042 <span class="comment">   that is dynamically linked.  The dynamic linker within the shared C library</span>
<a name="l00043"></a>00043 <span class="comment">   then maps in the various program segments in the user executable and jumps</span>
<a name="l00044"></a>00044 <span class="comment">   to the user executable&#39;s recorded entry point, as if the call had been made</span>
<a name="l00045"></a>00045 <span class="comment">   directly by the kernel.</span>
<a name="l00046"></a>00046 <span class="comment"></span>
<a name="l00047"></a>00047 <span class="comment">   The traditional gdb method of using this info was to use the</span>
<a name="l00048"></a>00048 <span class="comment">   recorded entry point to set the entry-file&#39;s lowpc and highpc from</span>
<a name="l00049"></a>00049 <span class="comment">   the debugging information, where these values are the starting</span>
<a name="l00050"></a>00050 <span class="comment">   address (inclusive) and ending address (exclusive) of the</span>
<a name="l00051"></a>00051 <span class="comment">   instruction space in the executable which correspond to the</span>
<a name="l00052"></a>00052 <span class="comment">   &quot;startup file&quot;, i.e. crt0.o in most cases.  This file is assumed to</span>
<a name="l00053"></a>00053 <span class="comment">   be a startup file and frames with pc&#39;s inside it are treated as</span>
<a name="l00054"></a>00054 <span class="comment">   nonexistent.  Setting these variables is necessary so that</span>
<a name="l00055"></a>00055 <span class="comment">   backtraces do not fly off the bottom of the stack.</span>
<a name="l00056"></a>00056 <span class="comment"></span>
<a name="l00057"></a>00057 <span class="comment">   NOTE: cagney/2003-09-09: It turns out that this &quot;traditional&quot;</span>
<a name="l00058"></a>00058 <span class="comment">   method doesn&#39;t work.  Corinna writes: ``It turns out that the call</span>
<a name="l00059"></a>00059 <span class="comment">   to test for &quot;inside entry file&quot; destroys a meaningful backtrace</span>
<a name="l00060"></a>00060 <span class="comment">   under some conditions.  E.g. the backtrace tests in the asm-source</span>
<a name="l00061"></a>00061 <span class="comment">   testcase are broken for some targets.  In this test the functions</span>
<a name="l00062"></a>00062 <span class="comment">   are all implemented as part of one file and the testcase is not</span>
<a name="l00063"></a>00063 <span class="comment">   necessarily linked with a start file (depending on the target).</span>
<a name="l00064"></a>00064 <span class="comment">   What happens is, that the first frame is printed normaly and</span>
<a name="l00065"></a>00065 <span class="comment">   following frames are treated as being inside the enttry file then.</span>
<a name="l00066"></a>00066 <span class="comment">   This way, only the #0 frame is printed in the backtrace output.&#39;&#39;</span>
<a name="l00067"></a>00067 <span class="comment">   Ref &quot;frame.c&quot; &quot;NOTE: vinschen/2003-04-01&quot;.</span>
<a name="l00068"></a>00068 <span class="comment"></span>
<a name="l00069"></a>00069 <span class="comment">   Gdb also supports an alternate method to avoid running off the bottom</span>
<a name="l00070"></a>00070 <span class="comment">   of the stack.</span>
<a name="l00071"></a>00071 <span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">   There are two frames that are &quot;special&quot;, the frame for the function</span>
<a name="l00073"></a>00073 <span class="comment">   containing the process entry point, since it has no predecessor frame,</span>
<a name="l00074"></a>00074 <span class="comment">   and the frame for the function containing the user code entry point</span>
<a name="l00075"></a>00075 <span class="comment">   (the main() function), since all the predecessor frames are for the</span>
<a name="l00076"></a>00076 <span class="comment">   process startup code.  Since we have no guarantee that the linked</span>
<a name="l00077"></a>00077 <span class="comment">   in startup modules have any debugging information that gdb can use,</span>
<a name="l00078"></a>00078 <span class="comment">   we need to avoid following frame pointers back into frames that might</span>
<a name="l00079"></a>00079 <span class="comment">   have been built in the startup code, as we might get hopelessly </span>
<a name="l00080"></a>00080 <span class="comment">   confused.  However, we almost always have debugging information</span>
<a name="l00081"></a>00081 <span class="comment">   available for main().</span>
<a name="l00082"></a>00082 <span class="comment"></span>
<a name="l00083"></a>00083 <span class="comment">   These variables are used to save the range of PC values which are</span>
<a name="l00084"></a>00084 <span class="comment">   valid within the main() function and within the function containing</span>
<a name="l00085"></a>00085 <span class="comment">   the process entry point.  If we always consider the frame for</span>
<a name="l00086"></a>00086 <span class="comment">   main() as the outermost frame when debugging user code, and the</span>
<a name="l00087"></a>00087 <span class="comment">   frame for the process entry point function as the outermost frame</span>
<a name="l00088"></a>00088 <span class="comment">   when debugging startup code, then all we have to do is have</span>
<a name="l00089"></a>00089 <span class="comment">   DEPRECATED_FRAME_CHAIN_VALID return false whenever a frame&#39;s</span>
<a name="l00090"></a>00090 <span class="comment">   current PC is within the range specified by these variables.  In</span>
<a name="l00091"></a>00091 <span class="comment">   essence, we set &quot;ceilings&quot; in the frame chain beyond which we will</span>
<a name="l00092"></a>00092 <span class="comment">   not proceed when following the frame chain back up the stack.</span>
<a name="l00093"></a>00093 <span class="comment"></span>
<a name="l00094"></a>00094 <span class="comment">   A nice side effect is that we can still debug startup code without</span>
<a name="l00095"></a>00095 <span class="comment">   running off the end of the frame chain, assuming that we have usable</span>
<a name="l00096"></a>00096 <span class="comment">   debugging information in the startup modules, and if we choose to not</span>
<a name="l00097"></a>00097 <span class="comment">   use the block at main, or can&#39;t find it for some reason, everything</span>
<a name="l00098"></a>00098 <span class="comment">   still works as before.  And if we have no startup code debugging</span>
<a name="l00099"></a>00099 <span class="comment">   information but we do have usable information for main(), backtraces</span>
<a name="l00100"></a>00100 <span class="comment">   from user code don&#39;t go wandering off into the startup code.  */</span>
<a name="l00101"></a>00101 
<a name="l00102"></a><a class="code" href="structentry__info.html">00102</a> <span class="keyword">struct </span><a class="code" href="structentry__info.html">entry_info</a>
<a name="l00103"></a>00103   {
<a name="l00104"></a>00104     <span class="comment">/* The relocated value we should use for this objfile entry point.  */</span>
<a name="l00105"></a><a class="code" href="structentry__info.html#a832e924ade2c71c6ed3589a30e67e9fc">00105</a>     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structentry__info.html#a832e924ade2c71c6ed3589a30e67e9fc">entry_point</a>;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107     <span class="comment">/* Set to 1 iff ENTRY_POINT contains a valid value.  */</span>
<a name="l00108"></a><a class="code" href="structentry__info.html#aed10c7357010ae66abed3a2f11ff5977">00108</a>     <span class="keywordtype">unsigned</span> <a class="code" href="structentry__info.html#aed10c7357010ae66abed3a2f11ff5977">entry_point_p</a> : 1;
<a name="l00109"></a>00109   };
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment">/* Sections in an objfile.  The section offsets are stored in the</span>
<a name="l00112"></a>00112 <span class="comment">   OBJFILE.  */</span>
<a name="l00113"></a>00113 
<a name="l00114"></a><a class="code" href="structobj__section.html">00114</a> <span class="keyword">struct </span><a class="code" href="structobj__section.html">obj_section</a>
<a name="l00115"></a>00115   {
<a name="l00116"></a><a class="code" href="structobj__section.html#ad233927d4d1037bde66ab9628ae82345">00116</a>     <span class="keyword">struct </span>bfd_section *<a class="code" href="structobj__section.html#ad233927d4d1037bde66ab9628ae82345">the_bfd_section</a>;        <span class="comment">/* BFD section pointer */</span>
<a name="l00117"></a>00117 
<a name="l00118"></a>00118     <span class="comment">/* Objfile this section is part of.  */</span>
<a name="l00119"></a><a class="code" href="structobj__section.html#a3dba4273f49b43a5e8c64bd29ac39ef1">00119</a>     <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobj__section.html#a3dba4273f49b43a5e8c64bd29ac39ef1">objfile</a>;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121     <span class="comment">/* True if this &quot;overlay section&quot; is mapped into an &quot;overlay region&quot;.  */</span>
<a name="l00122"></a><a class="code" href="structobj__section.html#a5304004a0276b0af9f106bb28cea546b">00122</a>     <span class="keywordtype">int</span> <a class="code" href="structobj__section.html#a5304004a0276b0af9f106bb28cea546b">ovly_mapped</a>;
<a name="l00123"></a>00123   };
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="comment">/* Relocation offset applied to S.  */</span>
<a name="l00126"></a><a class="code" href="objfiles_8h.html#a5c649cde3090dfb6687c5aedd5630b56">00126</a> <span class="preprocessor">#define obj_section_offset(s)                                           \</span>
<a name="l00127"></a>00127 <span class="preprocessor">  (((s)-&gt;objfile-&gt;section_offsets)-&gt;offsets[gdb_bfd_section_index ((s)-&gt;objfile-&gt;obfd, (s)-&gt;the_bfd_section)])</span>
<a name="l00128"></a>00128 <span class="preprocessor"></span>
<a name="l00129"></a>00129 <span class="comment">/* The memory address of section S (vma + offset).  */</span>
<a name="l00130"></a><a class="code" href="objfiles_8h.html#add2e3fffc531c5f6789a03324308ccf6">00130</a> <span class="preprocessor">#define obj_section_addr(s)                                             \</span>
<a name="l00131"></a>00131 <span class="preprocessor">  (bfd_get_section_vma ((s)-&gt;objfile-&gt;obfd, s-&gt;the_bfd_section)         \</span>
<a name="l00132"></a>00132 <span class="preprocessor">   + obj_section_offset (s))</span>
<a name="l00133"></a>00133 <span class="preprocessor"></span>
<a name="l00134"></a>00134 <span class="comment">/* The one-passed-the-end memory address of section S</span>
<a name="l00135"></a>00135 <span class="comment">   (vma + size + offset).  */</span>
<a name="l00136"></a><a class="code" href="objfiles_8h.html#aa53c013212e4b756a307fe6d7e6f966a">00136</a> <span class="preprocessor">#define obj_section_endaddr(s)                                          \</span>
<a name="l00137"></a>00137 <span class="preprocessor">  (bfd_get_section_vma ((s)-&gt;objfile-&gt;obfd, s-&gt;the_bfd_section)         \</span>
<a name="l00138"></a>00138 <span class="preprocessor">   + bfd_get_section_size ((s)-&gt;the_bfd_section)                        \</span>
<a name="l00139"></a>00139 <span class="preprocessor">   + obj_section_offset (s))</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span>
<a name="l00141"></a>00141 <span class="comment">/* The &quot;objstats&quot; structure provides a place for gdb to record some</span>
<a name="l00142"></a>00142 <span class="comment">   interesting information about its internal state at runtime, on a</span>
<a name="l00143"></a>00143 <span class="comment">   per objfile basis, such as information about the number of symbols</span>
<a name="l00144"></a>00144 <span class="comment">   read, size of string table (if any), etc.  */</span>
<a name="l00145"></a>00145 
<a name="l00146"></a><a class="code" href="structobjstats.html">00146</a> <span class="keyword">struct </span><a class="code" href="structobjstats.html">objstats</a>
<a name="l00147"></a>00147   {
<a name="l00148"></a><a class="code" href="structobjstats.html#abad1e12e9abefe691c80d37c7c89c248">00148</a>     <span class="keywordtype">int</span> <a class="code" href="structobjstats.html#abad1e12e9abefe691c80d37c7c89c248">n_minsyms</a>;              <span class="comment">/* Number of minimal symbols read */</span>
<a name="l00149"></a><a class="code" href="structobjstats.html#a0b0eb265d74612a9674d2d5f1f09f329">00149</a>     <span class="keywordtype">int</span> <a class="code" href="structobjstats.html#a0b0eb265d74612a9674d2d5f1f09f329">n_psyms</a>;                <span class="comment">/* Number of partial symbols read */</span>
<a name="l00150"></a><a class="code" href="structobjstats.html#a764fc6de4aa1d8acc54570f2ab5756de">00150</a>     <span class="keywordtype">int</span> <a class="code" href="structobjstats.html#a764fc6de4aa1d8acc54570f2ab5756de">n_syms</a>;                 <span class="comment">/* Number of full symbols read */</span>
<a name="l00151"></a><a class="code" href="structobjstats.html#a7a8edd0d044fd39870896dd858f7af58">00151</a>     <span class="keywordtype">int</span> <a class="code" href="structobjstats.html#a7a8edd0d044fd39870896dd858f7af58">n_stabs</a>;                <span class="comment">/* Number of &quot;.stabs&quot; read (if applicable) */</span>
<a name="l00152"></a><a class="code" href="structobjstats.html#a5b3f46644377d8d68b3531f106661c3f">00152</a>     <span class="keywordtype">int</span> <a class="code" href="structobjstats.html#a5b3f46644377d8d68b3531f106661c3f">n_types</a>;                <span class="comment">/* Number of types */</span>
<a name="l00153"></a><a class="code" href="structobjstats.html#aa4fe61ec64623cdfde9d626851666379">00153</a>     <span class="keywordtype">int</span> <a class="code" href="structobjstats.html#aa4fe61ec64623cdfde9d626851666379">sz_strtab</a>;              <span class="comment">/* Size of stringtable, (if applicable) */</span>
<a name="l00154"></a>00154   };
<a name="l00155"></a>00155 
<a name="l00156"></a><a class="code" href="objfiles_8h.html#abdcf99cd4c458e281e591cbce3fa627c">00156</a> <span class="preprocessor">#define OBJSTAT(objfile, expr) (objfile -&gt; stats.expr)</span>
<a name="l00157"></a><a class="code" href="objfiles_8h.html#aa0cdcfc8eb10b8107c5ae6ca4d2ee46f">00157</a> <span class="preprocessor"></span><span class="preprocessor">#define OBJSTATS struct objstats stats</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8h.html#a72d0ce5da9f5a313827c2047691b5e94">print_objfile_statistics</a> (<span class="keywordtype">void</span>);
<a name="l00159"></a>00159 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8h.html#aeb07376682b245f881be6d02fcd65315">print_symbol_bcache_statistics</a> (<span class="keywordtype">void</span>);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="comment">/* Number of entries in the minimal symbol hash table.  */</span>
<a name="l00162"></a><a class="code" href="objfiles_8h.html#a1829e1592cbf4ae4234d0cf8ecd0a91d">00162</a> <span class="preprocessor">#define MINIMAL_SYMBOL_HASH_SIZE 2039</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span>
<a name="l00164"></a>00164 <span class="comment">/* Some objfile data is hung off the BFD.  This enables sharing of the</span>
<a name="l00165"></a>00165 <span class="comment">   data across all objfiles using the BFD.  The data is stored in an</span>
<a name="l00166"></a>00166 <span class="comment">   instance of this structure, and associated with the BFD using the</span>
<a name="l00167"></a>00167 <span class="comment">   registry system.  */</span>
<a name="l00168"></a>00168 
<a name="l00169"></a><a class="code" href="structobjfile__per__bfd__storage.html">00169</a> <span class="keyword">struct </span><a class="code" href="structobjfile__per__bfd__storage.html">objfile_per_bfd_storage</a>
<a name="l00170"></a>00170 {
<a name="l00171"></a>00171   <span class="comment">/* The storage has an obstack of its own.  */</span>
<a name="l00172"></a>00172 
<a name="l00173"></a><a class="code" href="structobjfile__per__bfd__storage.html#a69799b6bf0ec4e1056ad3c417b5f90c6">00173</a>   <span class="keyword">struct </span>obstack <a class="code" href="structobjfile__per__bfd__storage.html#a69799b6bf0ec4e1056ad3c417b5f90c6">storage_obstack</a>;
<a name="l00174"></a>00174   
<a name="l00175"></a>00175   <span class="comment">/* Byte cache for file names.  */</span>
<a name="l00176"></a>00176 
<a name="l00177"></a><a class="code" href="structobjfile__per__bfd__storage.html#a3d8f41aaa7b694d9d3faf26346056208">00177</a>   <span class="keyword">struct </span><a class="code" href="structbcache.html">bcache</a> *<a class="code" href="structobjfile__per__bfd__storage.html#a3d8f41aaa7b694d9d3faf26346056208">filename_cache</a>;
<a name="l00178"></a>00178 
<a name="l00179"></a>00179   <span class="comment">/* Byte cache for macros.  */</span>
<a name="l00180"></a><a class="code" href="structobjfile__per__bfd__storage.html#ab79d9333c551341d74c8fb420d58aff7">00180</a>   <span class="keyword">struct </span><a class="code" href="structbcache.html">bcache</a> *<a class="code" href="structobjfile__per__bfd__storage.html#ab79d9333c551341d74c8fb420d58aff7">macro_cache</a>;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182   <span class="comment">/* The gdbarch associated with the BFD.  Note that this gdbarch is</span>
<a name="l00183"></a>00183 <span class="comment">     determined solely from BFD information, without looking at target</span>
<a name="l00184"></a>00184 <span class="comment">     information.  The gdbarch determined from a running target may</span>
<a name="l00185"></a>00185 <span class="comment">     differ from this e.g. with respect to register types and names.  */</span>
<a name="l00186"></a>00186 
<a name="l00187"></a><a class="code" href="structobjfile__per__bfd__storage.html#aa29ba6b52d98d7dbfbb65e9fdd84813c">00187</a>   <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structobjfile__per__bfd__storage.html#aa29ba6b52d98d7dbfbb65e9fdd84813c">gdbarch</a>;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189   <span class="comment">/* Hash table for mapping symbol names to demangled names.  Each</span>
<a name="l00190"></a>00190 <span class="comment">     entry in the hash table is actually two consecutive strings,</span>
<a name="l00191"></a>00191 <span class="comment">     both null-terminated; the first one is a mangled or linkage</span>
<a name="l00192"></a>00192 <span class="comment">     name, and the second is the demangled name or just a zero byte</span>
<a name="l00193"></a>00193 <span class="comment">     if the name doesn&#39;t demangle.  */</span>
<a name="l00194"></a><a class="code" href="structobjfile__per__bfd__storage.html#a748f3cfef41f4c9dc1f5c1b33d2c4dd4">00194</a>   <span class="keyword">struct </span>htab *<a class="code" href="structobjfile__per__bfd__storage.html#a748f3cfef41f4c9dc1f5c1b33d2c4dd4">demangled_names_hash</a>;
<a name="l00195"></a>00195 };
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="comment">/* Master structure for keeping track of each file from which</span>
<a name="l00198"></a>00198 <span class="comment">   gdb reads symbols.  There are several ways these get allocated: 1.</span>
<a name="l00199"></a>00199 <span class="comment">   The main symbol file, symfile_objfile, set by the symbol-file command,</span>
<a name="l00200"></a>00200 <span class="comment">   2.  Additional symbol files added by the add-symbol-file command,</span>
<a name="l00201"></a>00201 <span class="comment">   3.  Shared library objfiles, added by ADD_SOLIB,  4.  symbol files</span>
<a name="l00202"></a>00202 <span class="comment">   for modules that were loaded when GDB attached to a remote system</span>
<a name="l00203"></a>00203 <span class="comment">   (see remote-vx.c).  */</span>
<a name="l00204"></a>00204 
<a name="l00205"></a><a class="code" href="structobjfile.html">00205</a> <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a>
<a name="l00206"></a>00206   {
<a name="l00207"></a>00207 
<a name="l00208"></a>00208     <span class="comment">/* All struct objfile&#39;s are chained together by their next pointers.</span>
<a name="l00209"></a>00209 <span class="comment">       The program space field &quot;objfiles&quot;  (frequently referenced via</span>
<a name="l00210"></a>00210 <span class="comment">       the macro &quot;object_files&quot;) points to the first link in this</span>
<a name="l00211"></a>00211 <span class="comment">       chain.  */</span>
<a name="l00212"></a>00212 
<a name="l00213"></a><a class="code" href="structobjfile.html#a3b8083e843c67911bfb6ff39029d6259">00213</a>     <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html#a3b8083e843c67911bfb6ff39029d6259">next</a>;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215     <span class="comment">/* The object file&#39;s name, tilde-expanded and absolute.  This</span>
<a name="l00216"></a>00216 <span class="comment">       pointer is never NULL.  This does not have to be freed; it is</span>
<a name="l00217"></a>00217 <span class="comment">       guaranteed to have a lifetime at least as long as the objfile.  */</span>
<a name="l00218"></a>00218 
<a name="l00219"></a><a class="code" href="structobjfile.html#adf7349914310f50116bc5a556d3d958b">00219</a>     <span class="keywordtype">char</span> *<a class="code" href="structobjfile.html#adf7349914310f50116bc5a556d3d958b">original_name</a>;
<a name="l00220"></a>00220 
<a name="l00221"></a><a class="code" href="structobjfile.html#a57fb6afa162329408c276dd5acf41fa5">00221</a>     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structobjfile.html#a57fb6afa162329408c276dd5acf41fa5">addr_low</a>;
<a name="l00222"></a>00222 
<a name="l00223"></a>00223     <span class="comment">/* Some flag bits for this objfile.</span>
<a name="l00224"></a>00224 <span class="comment">       The values are defined by OBJF_*.  */</span>
<a name="l00225"></a>00225 
<a name="l00226"></a><a class="code" href="structobjfile.html#a07578e542db3b2a277e146b24adf007e">00226</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="structobjfile.html#a07578e542db3b2a277e146b24adf007e">flags</a>;
<a name="l00227"></a>00227 
<a name="l00228"></a>00228     <span class="comment">/* The program space associated with this objfile.  */</span>
<a name="l00229"></a>00229 
<a name="l00230"></a><a class="code" href="structobjfile.html#a1f6ab738ce0b1fb1588709351b0c9091">00230</a>     <span class="keyword">struct </span><a class="code" href="structprogram__space.html">program_space</a> *<a class="code" href="structobjfile.html#a1f6ab738ce0b1fb1588709351b0c9091">pspace</a>;
<a name="l00231"></a>00231 
<a name="l00232"></a>00232     <span class="comment">/* Each objfile points to a linked list of symtabs derived from this file,</span>
<a name="l00233"></a>00233 <span class="comment">       one symtab structure for each compilation unit (source file).  Each link</span>
<a name="l00234"></a>00234 <span class="comment">       in the symtab list contains a backpointer to this objfile.  */</span>
<a name="l00235"></a>00235 
<a name="l00236"></a><a class="code" href="structobjfile.html#a7de941af61199f5f18580235feec7e8c">00236</a>     <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structobjfile.html#a7de941af61199f5f18580235feec7e8c">symtabs</a>;
<a name="l00237"></a>00237 
<a name="l00238"></a>00238     <span class="comment">/* Each objfile points to a linked list of partial symtabs derived from</span>
<a name="l00239"></a>00239 <span class="comment">       this file, one partial symtab structure for each compilation unit</span>
<a name="l00240"></a>00240 <span class="comment">       (source file).  */</span>
<a name="l00241"></a>00241 
<a name="l00242"></a><a class="code" href="structobjfile.html#a4dcbf92348a83fa9d6d5d2d08cb59eb5">00242</a>     <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *<a class="code" href="structobjfile.html#a4dcbf92348a83fa9d6d5d2d08cb59eb5">psymtabs</a>;
<a name="l00243"></a>00243 
<a name="l00244"></a>00244     <span class="comment">/* Map addresses to the entries of PSYMTABS.  It would be more efficient to</span>
<a name="l00245"></a>00245 <span class="comment">       have a map per the whole process but ADDRMAP cannot selectively remove</span>
<a name="l00246"></a>00246 <span class="comment">       its items during FREE_OBJFILE.  This mapping is already present even for</span>
<a name="l00247"></a>00247 <span class="comment">       PARTIAL_SYMTABs which still have no corresponding full SYMTABs read.  */</span>
<a name="l00248"></a>00248 
<a name="l00249"></a><a class="code" href="structobjfile.html#ae7c792f2cd4efcff86d84d7bd3e15b26">00249</a>     <span class="keyword">struct </span><a class="code" href="structaddrmap.html">addrmap</a> *<a class="code" href="structobjfile.html#ae7c792f2cd4efcff86d84d7bd3e15b26">psymtabs_addrmap</a>;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251     <span class="comment">/* List of freed partial symtabs, available for re-use.  */</span>
<a name="l00252"></a>00252 
<a name="l00253"></a><a class="code" href="structobjfile.html#a280f61a600a303c151625e90f3762383">00253</a>     <span class="keyword">struct </span><a class="code" href="structpartial__symtab.html">partial_symtab</a> *<a class="code" href="structobjfile.html#a280f61a600a303c151625e90f3762383">free_psymtabs</a>;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     <span class="comment">/* The object file&#39;s BFD.  Can be null if the objfile contains only</span>
<a name="l00256"></a>00256 <span class="comment">       minimal symbols, e.g. the run time common symbols for SunOS4.  */</span>
<a name="l00257"></a>00257 
<a name="l00258"></a><a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">00258</a>     bfd *<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>;
<a name="l00259"></a>00259 
<a name="l00260"></a>00260     <span class="comment">/* The per-BFD data.  Note that this is treated specially if OBFD</span>
<a name="l00261"></a>00261 <span class="comment">       is NULL.  */</span>
<a name="l00262"></a>00262 
<a name="l00263"></a><a class="code" href="structobjfile.html#a4f3bc3943504820dff1f0362b38d2101">00263</a>     <span class="keyword">struct </span><a class="code" href="structobjfile__per__bfd__storage.html">objfile_per_bfd_storage</a> *<a class="code" href="structobjfile.html#a4f3bc3943504820dff1f0362b38d2101">per_bfd</a>;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265     <span class="comment">/* The modification timestamp of the object file, as of the last time</span>
<a name="l00266"></a>00266 <span class="comment">       we read its symbols.  */</span>
<a name="l00267"></a>00267 
<a name="l00268"></a><a class="code" href="structobjfile.html#af985d4c90ce61817676ec27ab23104b7">00268</a>     <span class="keywordtype">long</span> <a class="code" href="structobjfile.html#af985d4c90ce61817676ec27ab23104b7">mtime</a>;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270     <span class="comment">/* Obstack to hold objects that should be freed when we load a new symbol</span>
<a name="l00271"></a>00271 <span class="comment">       table from this object file.  */</span>
<a name="l00272"></a>00272 
<a name="l00273"></a><a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">00273</a>     <span class="keyword">struct </span>obstack <a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>; 
<a name="l00274"></a>00274 
<a name="l00275"></a>00275     <span class="comment">/* A byte cache where we can stash arbitrary &quot;chunks&quot; of bytes that</span>
<a name="l00276"></a>00276 <span class="comment">       will not change.  */</span>
<a name="l00277"></a>00277 
<a name="l00278"></a><a class="code" href="structobjfile.html#a48c765fff8299f429430792b1864ce38">00278</a>     <span class="keyword">struct </span><a class="code" href="structpsymbol__bcache.html">psymbol_bcache</a> *<a class="code" href="structobjfile.html#a48c765fff8299f429430792b1864ce38">psymbol_cache</a>; <span class="comment">/* Byte cache for partial syms.  */</span>
<a name="l00279"></a>00279 
<a name="l00280"></a>00280     <span class="comment">/* Vectors of all partial symbols read in from file.  The actual data</span>
<a name="l00281"></a>00281 <span class="comment">       is stored in the objfile_obstack.  */</span>
<a name="l00282"></a>00282 
<a name="l00283"></a><a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">00283</a>     <span class="keyword">struct </span><a class="code" href="structpsymbol__allocation__list.html">psymbol_allocation_list</a> <a class="code" href="structobjfile.html#a5665fb90f8a5d1481cc59ed5cf6a86fa">global_psymbols</a>;
<a name="l00284"></a><a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">00284</a>     <span class="keyword">struct </span><a class="code" href="structpsymbol__allocation__list.html">psymbol_allocation_list</a> <a class="code" href="structobjfile.html#a365549b70c39eb429e3103991da9b3e6">static_psymbols</a>;
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     <span class="comment">/* Each file contains a pointer to an array of minimal symbols for all</span>
<a name="l00287"></a>00287 <span class="comment">       global symbols that are defined within the file.  The array is</span>
<a name="l00288"></a>00288 <span class="comment">       terminated by a &quot;null symbol&quot;, one that has a NULL pointer for the</span>
<a name="l00289"></a>00289 <span class="comment">       name and a zero value for the address.  This makes it easy to walk</span>
<a name="l00290"></a>00290 <span class="comment">       through the array when passed a pointer to somewhere in the middle</span>
<a name="l00291"></a>00291 <span class="comment">       of it.  There is also a count of the number of symbols, which does</span>
<a name="l00292"></a>00292 <span class="comment">       not include the terminating null symbol.  The array itself, as well</span>
<a name="l00293"></a>00293 <span class="comment">       as all the data that it points to, should be allocated on the</span>
<a name="l00294"></a>00294 <span class="comment">       objfile_obstack for this file.  */</span>
<a name="l00295"></a>00295 
<a name="l00296"></a><a class="code" href="structobjfile.html#a2927f444693262879bc0ca58a4634aa0">00296</a>     <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *<a class="code" href="structobjfile.html#a2927f444693262879bc0ca58a4634aa0">msymbols</a>;
<a name="l00297"></a><a class="code" href="structobjfile.html#a50f039d907b8e65e0468d53c8b27218a">00297</a>     <span class="keywordtype">int</span> <a class="code" href="structobjfile.html#a50f039d907b8e65e0468d53c8b27218a">minimal_symbol_count</a>;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299     <span class="comment">/* This is a hash table used to index the minimal symbols by name.  */</span>
<a name="l00300"></a>00300 
<a name="l00301"></a><a class="code" href="structobjfile.html#ae430c9b684604fb307e0607142e4e965">00301</a>     <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *<a class="code" href="structobjfile.html#ae430c9b684604fb307e0607142e4e965">msymbol_hash</a>[<a class="code" href="objfiles_8h.html#a1829e1592cbf4ae4234d0cf8ecd0a91d">MINIMAL_SYMBOL_HASH_SIZE</a>];
<a name="l00302"></a>00302 
<a name="l00303"></a>00303     <span class="comment">/* This hash table is used to index the minimal symbols by their</span>
<a name="l00304"></a>00304 <span class="comment">       demangled names.  */</span>
<a name="l00305"></a>00305 
<a name="l00306"></a><a class="code" href="structobjfile.html#af6309127ede28d1c30c8ca8686c6bee2">00306</a>     <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *<a class="code" href="structobjfile.html#af6309127ede28d1c30c8ca8686c6bee2">msymbol_demangled_hash</a>[<a class="code" href="objfiles_8h.html#a1829e1592cbf4ae4234d0cf8ecd0a91d">MINIMAL_SYMBOL_HASH_SIZE</a>];
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     <span class="comment">/* Structure which keeps track of functions that manipulate objfile&#39;s</span>
<a name="l00309"></a>00309 <span class="comment">       of the same type as this objfile.  I.e. the function to read partial</span>
<a name="l00310"></a>00310 <span class="comment">       symbols for example.  Note that this structure is in statically</span>
<a name="l00311"></a>00311 <span class="comment">       allocated memory, and is shared by all objfiles that use the</span>
<a name="l00312"></a>00312 <span class="comment">       object module reader of this type.  */</span>
<a name="l00313"></a>00313 
<a name="l00314"></a><a class="code" href="structobjfile.html#af6814df9c2fd1f669fd79d0b0c94262c">00314</a>     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structsym__fns.html">sym_fns</a> *<a class="code" href="structobjfile.html#af6814df9c2fd1f669fd79d0b0c94262c">sf</a>;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316     <span class="comment">/* The per-objfile information about the entry point, the scope (file/func)</span>
<a name="l00317"></a>00317 <span class="comment">       containing the entry point, and the scope of the user&#39;s main() func.  */</span>
<a name="l00318"></a>00318 
<a name="l00319"></a><a class="code" href="structobjfile.html#ab4cb9b71d04674a1af7a6036644b1f1b">00319</a>     <span class="keyword">struct </span><a class="code" href="structentry__info.html">entry_info</a> <a class="code" href="structobjfile.html#ab4cb9b71d04674a1af7a6036644b1f1b">ei</a>;
<a name="l00320"></a>00320 
<a name="l00321"></a>00321     <span class="comment">/* Per objfile data-pointers required by other GDB modules.  */</span>
<a name="l00322"></a>00322 
<a name="l00323"></a><a class="code" href="structobjfile.html#a223739e65b28b110cb1fba9b98d1babc">00323</a>     <a class="code" href="structobjfile.html#a223739e65b28b110cb1fba9b98d1babc">REGISTRY_FIELDS</a>;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325     <span class="comment">/* Set of relocation offsets to apply to each section.</span>
<a name="l00326"></a>00326 <span class="comment">       The table is indexed by the_bfd_section-&gt;index, thus it is generally</span>
<a name="l00327"></a>00327 <span class="comment">       as large as the number of sections in the binary.</span>
<a name="l00328"></a>00328 <span class="comment">       The table is stored on the objfile_obstack.</span>
<a name="l00329"></a>00329 <span class="comment"></span>
<a name="l00330"></a>00330 <span class="comment">       These offsets indicate that all symbols (including partial and</span>
<a name="l00331"></a>00331 <span class="comment">       minimal symbols) which have been read have been relocated by this</span>
<a name="l00332"></a>00332 <span class="comment">       much.  Symbols which are yet to be read need to be relocated by it.  */</span>
<a name="l00333"></a>00333 
<a name="l00334"></a><a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">00334</a>     <span class="keyword">struct </span><a class="code" href="structsection__offsets.html">section_offsets</a> *<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>;
<a name="l00335"></a><a class="code" href="structobjfile.html#a34232a1b946c53c44c4a41409033d533">00335</a>     <span class="keywordtype">int</span> <a class="code" href="structobjfile.html#a34232a1b946c53c44c4a41409033d533">num_sections</a>;
<a name="l00336"></a>00336 
<a name="l00337"></a>00337     <span class="comment">/* Indexes in the section_offsets array.  These are initialized by the</span>
<a name="l00338"></a>00338 <span class="comment">       *_symfile_offsets() family of functions (som_symfile_offsets,</span>
<a name="l00339"></a>00339 <span class="comment">       xcoff_symfile_offsets, default_symfile_offsets).  In theory they</span>
<a name="l00340"></a>00340 <span class="comment">       should correspond to the section indexes used by bfd for the</span>
<a name="l00341"></a>00341 <span class="comment">       current objfile.  The exception to this for the time being is the</span>
<a name="l00342"></a>00342 <span class="comment">       SOM version.  */</span>
<a name="l00343"></a>00343 
<a name="l00344"></a><a class="code" href="structobjfile.html#aa1931d5fc57d674ffdedb8a97d7ca9b5">00344</a>     <span class="keywordtype">int</span> <a class="code" href="structobjfile.html#aa1931d5fc57d674ffdedb8a97d7ca9b5">sect_index_text</a>;
<a name="l00345"></a><a class="code" href="structobjfile.html#a4bf85413b188f632de97609c228b1cad">00345</a>     <span class="keywordtype">int</span> <a class="code" href="structobjfile.html#a4bf85413b188f632de97609c228b1cad">sect_index_data</a>;
<a name="l00346"></a><a class="code" href="structobjfile.html#a37f41e99df323d618852ee56198e5c75">00346</a>     <span class="keywordtype">int</span> <a class="code" href="structobjfile.html#a37f41e99df323d618852ee56198e5c75">sect_index_bss</a>;
<a name="l00347"></a><a class="code" href="structobjfile.html#a0f97611cc017051800462698f613cfd0">00347</a>     <span class="keywordtype">int</span> <a class="code" href="structobjfile.html#a0f97611cc017051800462698f613cfd0">sect_index_rodata</a>;
<a name="l00348"></a>00348 
<a name="l00349"></a>00349     <span class="comment">/* These pointers are used to locate the section table, which</span>
<a name="l00350"></a>00350 <span class="comment">       among other things, is used to map pc addresses into sections.</span>
<a name="l00351"></a>00351 <span class="comment">       SECTIONS points to the first entry in the table, and</span>
<a name="l00352"></a>00352 <span class="comment">       SECTIONS_END points to the first location past the last entry</span>
<a name="l00353"></a>00353 <span class="comment">       in the table.  The table is stored on the objfile_obstack.  The</span>
<a name="l00354"></a>00354 <span class="comment">       sections are indexed by the BFD section index; but the</span>
<a name="l00355"></a>00355 <span class="comment">       structure data is only valid for certain sections</span>
<a name="l00356"></a>00356 <span class="comment">       (e.g. non-empty, SEC_ALLOC).  */</span>
<a name="l00357"></a>00357 
<a name="l00358"></a><a class="code" href="structobjfile.html#a14f54389e81e2ae3efa512a6fa3365ea">00358</a>     <span class="keyword">struct </span><a class="code" href="structobj__section.html">obj_section</a> *<a class="code" href="structobjfile.html#a728f934c27b3d13bb44fbba47edc37f7">sections</a>, *<a class="code" href="structobjfile.html#a14f54389e81e2ae3efa512a6fa3365ea">sections_end</a>;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360     <span class="comment">/* GDB allows to have debug symbols in separate object files.  This is</span>
<a name="l00361"></a>00361 <span class="comment">       used by .gnu_debuglink, ELF build id note and Mach-O OSO.</span>
<a name="l00362"></a>00362 <span class="comment">       Although this is a tree structure, GDB only support one level</span>
<a name="l00363"></a>00363 <span class="comment">       (ie a separate debug for a separate debug is not supported).  Note that</span>
<a name="l00364"></a>00364 <span class="comment">       separate debug object are in the main chain and therefore will be</span>
<a name="l00365"></a>00365 <span class="comment">       visited by ALL_OBJFILES &amp; co iterators.  Separate debug objfile always</span>
<a name="l00366"></a>00366 <span class="comment">       has a non-nul separate_debug_objfile_backlink.  */</span>
<a name="l00367"></a>00367 
<a name="l00368"></a>00368     <span class="comment">/* Link to the first separate debug object, if any.  */</span>
<a name="l00369"></a><a class="code" href="structobjfile.html#a3145c92bec514df002469eb1a2cd43f0">00369</a>     <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html#a3145c92bec514df002469eb1a2cd43f0">separate_debug_objfile</a>;
<a name="l00370"></a>00370 
<a name="l00371"></a>00371     <span class="comment">/* If this is a separate debug object, this is used as a link to the</span>
<a name="l00372"></a>00372 <span class="comment">       actual executable objfile.  */</span>
<a name="l00373"></a><a class="code" href="structobjfile.html#a1ef5fed06f7a9c5864c9a0ce46a87710">00373</a>     <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html#a1ef5fed06f7a9c5864c9a0ce46a87710">separate_debug_objfile_backlink</a>;
<a name="l00374"></a>00374 
<a name="l00375"></a>00375     <span class="comment">/* If this is a separate debug object, this is a link to the next one</span>
<a name="l00376"></a>00376 <span class="comment">       for the same executable objfile.  */</span>
<a name="l00377"></a><a class="code" href="structobjfile.html#a22363f67f514c7a3ecbd114b946436ac">00377</a>     <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html#a22363f67f514c7a3ecbd114b946436ac">separate_debug_objfile_link</a>;
<a name="l00378"></a>00378 
<a name="l00379"></a>00379     <span class="comment">/* Place to stash various statistics about this objfile.  */</span>
<a name="l00380"></a><a class="code" href="structobjfile.html#afb012ea86153293bc6fe27622f31c7d3">00380</a>     <a class="code" href="structobjfile.html#afb012ea86153293bc6fe27622f31c7d3">OBJSTATS</a>;
<a name="l00381"></a>00381 
<a name="l00382"></a>00382     <span class="comment">/* A linked list of symbols created when reading template types or</span>
<a name="l00383"></a>00383 <span class="comment">       function templates.  These symbols are not stored in any symbol</span>
<a name="l00384"></a>00384 <span class="comment">       table, so we have to keep them here to relocate them</span>
<a name="l00385"></a>00385 <span class="comment">       properly.  */</span>
<a name="l00386"></a><a class="code" href="structobjfile.html#ab974a7032279a493812c9399e9df4df2">00386</a>     <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *<a class="code" href="structobjfile.html#ab974a7032279a493812c9399e9df4df2">template_symbols</a>;
<a name="l00387"></a>00387   };
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 <span class="comment">/* Defines for the objfile flag word.  */</span>
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 <span class="comment">/* When an object file has its functions reordered (currently Irix-5.2</span>
<a name="l00392"></a>00392 <span class="comment">   shared libraries exhibit this behaviour), we will need an expensive</span>
<a name="l00393"></a>00393 <span class="comment">   algorithm to locate a partial symtab or symtab via an address.</span>
<a name="l00394"></a>00394 <span class="comment">   To avoid this penalty for normal object files, we use this flag,</span>
<a name="l00395"></a>00395 <span class="comment">   whose setting is determined upon symbol table read in.  */</span>
<a name="l00396"></a>00396 
<a name="l00397"></a><a class="code" href="objfiles_8h.html#aebdb0f14c149fa8267a184b55130c4c6">00397</a> <span class="preprocessor">#define OBJF_REORDERED  (1 &lt;&lt; 0)        </span><span class="comment">/* Functions are reordered */</span>
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 <span class="comment">/* Distinguish between an objfile for a shared library and a &quot;vanilla&quot;</span>
<a name="l00400"></a>00400 <span class="comment">   objfile.  (If not set, the objfile may still actually be a solib.</span>
<a name="l00401"></a>00401 <span class="comment">   This can happen if the user created the objfile by using the</span>
<a name="l00402"></a>00402 <span class="comment">   add-symbol-file command.  GDB doesn&#39;t in that situation actually</span>
<a name="l00403"></a>00403 <span class="comment">   check whether the file is a solib.  Rather, the target&#39;s</span>
<a name="l00404"></a>00404 <span class="comment">   implementation of the solib interface is responsible for setting</span>
<a name="l00405"></a>00405 <span class="comment">   this flag when noticing solibs used by an inferior.)  */</span>
<a name="l00406"></a>00406 
<a name="l00407"></a><a class="code" href="objfiles_8h.html#a02a85dec7472a89888cd3c7575f88009">00407</a> <span class="preprocessor">#define OBJF_SHARED     (1 &lt;&lt; 1)        </span><span class="comment">/* From a shared library */</span>
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 <span class="comment">/* User requested that this objfile be read in it&#39;s entirety.  */</span>
<a name="l00410"></a>00410 
<a name="l00411"></a><a class="code" href="objfiles_8h.html#a13b0b01806a13d8b96e233e07fe70c09">00411</a> <span class="preprocessor">#define OBJF_READNOW    (1 &lt;&lt; 2)        </span><span class="comment">/* Immediate full read */</span>
<a name="l00412"></a>00412 
<a name="l00413"></a>00413 <span class="comment">/* This objfile was created because the user explicitly caused it</span>
<a name="l00414"></a>00414 <span class="comment">   (e.g., used the add-symbol-file command).  This bit offers a way</span>
<a name="l00415"></a>00415 <span class="comment">   for run_command to remove old objfile entries which are no longer</span>
<a name="l00416"></a>00416 <span class="comment">   valid (i.e., are associated with an old inferior), but to preserve</span>
<a name="l00417"></a>00417 <span class="comment">   ones that the user explicitly loaded via the add-symbol-file</span>
<a name="l00418"></a>00418 <span class="comment">   command.  */</span>
<a name="l00419"></a>00419 
<a name="l00420"></a><a class="code" href="objfiles_8h.html#a83dcbdaa349319071b86d581ed72b557">00420</a> <span class="preprocessor">#define OBJF_USERLOADED (1 &lt;&lt; 3)        </span><span class="comment">/* User loaded */</span>
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 <span class="comment">/* Set if we have tried to read partial symtabs for this objfile.</span>
<a name="l00423"></a>00423 <span class="comment">   This is used to allow lazy reading of partial symtabs.  */</span>
<a name="l00424"></a>00424 
<a name="l00425"></a><a class="code" href="objfiles_8h.html#a13235f574bd2cf0e2254a9693c1a597a">00425</a> <span class="preprocessor">#define OBJF_PSYMTABS_READ (1 &lt;&lt; 4)</span>
<a name="l00426"></a>00426 <span class="preprocessor"></span>
<a name="l00427"></a>00427 <span class="comment">/* Set if this is the main symbol file</span>
<a name="l00428"></a>00428 <span class="comment">   (as opposed to symbol file for dynamically loaded code).  */</span>
<a name="l00429"></a>00429 
<a name="l00430"></a><a class="code" href="objfiles_8h.html#a49e1b6e4f55e359a5db774c025464509">00430</a> <span class="preprocessor">#define OBJF_MAINLINE (1 &lt;&lt; 5)</span>
<a name="l00431"></a>00431 <span class="preprocessor"></span>
<a name="l00432"></a>00432 <span class="comment">/* ORIGINAL_NAME and OBFD-&gt;FILENAME correspond to text description unrelated to</span>
<a name="l00433"></a>00433 <span class="comment">   filesystem names.  It can be for example &quot;&lt;image in memory&gt;&quot;.  */</span>
<a name="l00434"></a>00434 
<a name="l00435"></a><a class="code" href="objfiles_8h.html#a5c3a990e32041dbf2726c6dca54721c5">00435</a> <span class="preprocessor">#define OBJF_NOT_FILENAME (1 &lt;&lt; 6)</span>
<a name="l00436"></a>00436 <span class="preprocessor"></span>
<a name="l00437"></a>00437 <span class="comment">/* Declarations for functions defined in objfiles.c */</span>
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="objfiles_8c.html#ac9a615292fe01a31b17319e67b84db2b">allocate_objfile</a> (bfd *, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keywordtype">int</span>);
<a name="l00440"></a>00440 
<a name="l00441"></a>00441 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="objfiles_8c.html#aaaa719db03e8f7bc7bf756fbf91fd82c">entry_point_address_query</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *entry_p);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="objfiles_8c.html#aa0b9e1a6004a1f192bc89cb2c28df8b9">entry_point_address</a> (<span class="keywordtype">void</span>);
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#aface4dac273ae70f374c6630dfc275e8">build_objfile_section_table</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00448"></a>00448 
<a name="l00449"></a>00449 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="minsyms_8c.html#a4a1bcb0ddf7084c407e304e2351b2eb0">terminate_minimal_symbol_table</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>);
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="objfiles_8c.html#aaa4bbe9a49046dfdd7b91abeb00094c5">objfile_separate_debug_iterate</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *,
<a name="l00452"></a>00452                                                        <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#a2f4e23e80d576a9d9611b0c80ba8aef7">put_objfile_before</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *, <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#a6a153e9457e2342693b33b577e3fe0fc">objfile_to_front</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00457"></a>00457 
<a name="l00458"></a>00458 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#a894b2a046ca6f893b2624b03e1c18d39">add_separate_debug_objfile</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *, <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00459"></a>00459 
<a name="l00460"></a>00460 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#a1b0ebbc839f5eb3086c9a38e4413c591">unlink_objfile</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00461"></a>00461 
<a name="l00462"></a>00462 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#abaf0cc9c95a939f0411ab167e17acdca">free_objfile</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#ab3c886b98be86ee2c8e384aede322538">free_objfile_separate_debug</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00465"></a>00465 
<a name="l00466"></a>00466 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="objfiles_8c.html#a28b13d73eedfe1a97a805d4f5de5bb22">make_cleanup_free_objfile</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#a621f2bdd9848a9964b775840459b2196">free_all_objfiles</a> (<span class="keywordtype">void</span>);
<a name="l00469"></a>00469 
<a name="l00470"></a>00470 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#a5b94685cf3f1097c15df6690ee4cf600">objfile_relocate</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structsection__offsets.html">section_offsets</a> *);
<a name="l00471"></a>00471 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#a9cb10d15616f41932adf76774aa54375">objfile_rebase</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>);
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="objfiles_8c.html#a9efbc153865ef5d6e2b555f168188ba9">objfile_has_partial_symbols</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>);
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="objfiles_8c.html#a072513c66f2fdebd6e972c4ef897c83b">objfile_has_full_symbols</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>);
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="objfiles_8c.html#a4ce59bee0b77fe55f4e326c7ecad3f6a">objfile_has_symbols</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>);
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="objfiles_8c.html#aa8d7d1a2b68ac871a50d0fcbca14518d">have_partial_symbols</a> (<span class="keywordtype">void</span>);
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="objfiles_8c.html#aed27a8abad788fa9b74e13a3bb97c8ee">have_full_symbols</a> (<span class="keywordtype">void</span>);
<a name="l00482"></a>00482 
<a name="l00483"></a>00483 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8h.html#a69c1b36fd2cd382b1380911658c0018e">objfile_set_sym_fns</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l00484"></a>00484                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structsym__fns.html">sym_fns</a> *sf);
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#a13b39c76c926794db4d3b8c388401df0">objfiles_changed</a> (<span class="keywordtype">void</span>);
<a name="l00487"></a>00487 
<a name="l00488"></a>00488 <span class="comment">/* This operation deletes all objfile entries that represent solibs that</span>
<a name="l00489"></a>00489 <span class="comment">   weren&#39;t explicitly loaded by the user, via e.g., the add-symbol-file</span>
<a name="l00490"></a>00490 <span class="comment">   command.  */</span>
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#a4ea3ea4604b0a1557e6354e195b7a638">objfile_purge_solibs</a> (<span class="keywordtype">void</span>);
<a name="l00493"></a>00493 
<a name="l00494"></a>00494 <span class="comment">/* Functions for dealing with the minimal symbol table, really a misc</span>
<a name="l00495"></a>00495 <span class="comment">   address&lt;-&gt;symbol mapping for things we don&#39;t have debug symbols for.  */</span>
<a name="l00496"></a>00496 
<a name="l00497"></a>00497 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="objfiles_8c.html#a590d3dc440408316d16718d09a81c907">have_minimal_symbols</a> (<span class="keywordtype">void</span>);
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structobj__section.html">obj_section</a> *<a class="code" href="objfiles_8c.html#a458f94deb438e6e7908997a9b496674d">find_pc_section</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc);
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 <span class="comment">/* Return non-zero if PC is in a section called NAME.  */</span>
<a name="l00502"></a>00502 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="objfiles_8c.html#a57605c5249e5305f9091139965372556">pc_in_section</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <span class="keywordtype">char</span> *);
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="comment">/* Return non-zero if PC is in a SVR4-style procedure linkage table</span>
<a name="l00505"></a>00505 <span class="comment">   section.  */</span>
<a name="l00506"></a>00506 
<a name="l00507"></a>00507 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l00508"></a><a class="code" href="objfiles_8h.html#ae5c371da14d8439fd4022314676d9783">00508</a> <a class="code" href="objfiles_8h.html#ae5c371da14d8439fd4022314676d9783">in_plt_section</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc)
<a name="l00509"></a>00509 {
<a name="l00510"></a>00510   <span class="keywordflow">return</span> <a class="code" href="objfiles_8c.html#a57605c5249e5305f9091139965372556">pc_in_section</a> (pc, <span class="stringliteral">&quot;.plt&quot;</span>);
<a name="l00511"></a>00511 }
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 <span class="comment">/* Keep a registry of per-objfile data-pointers required by other GDB</span>
<a name="l00514"></a>00514 <span class="comment">   modules.  */</span>
<a name="l00515"></a>00515 <a class="code" href="registry_8h.html#a7af3e7498cc41db86c930cb51245f8b8">DECLARE_REGISTRY</a>(<a class="code" href="structobjfile.html">objfile</a>);
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 <span class="comment">/* In normal use, the section map will be rebuilt by find_pc_section</span>
<a name="l00518"></a>00518 <span class="comment">   if objfiles have been added, removed or relocated since it was last</span>
<a name="l00519"></a>00519 <span class="comment">   called.  Calling inhibit_section_map_updates will inhibit this</span>
<a name="l00520"></a>00520 <span class="comment">   behavior until resume_section_map_updates is called.  If you call</span>
<a name="l00521"></a>00521 <span class="comment">   inhibit_section_map_updates you must ensure that every call to</span>
<a name="l00522"></a>00522 <span class="comment">   find_pc_section in the inhibited region relates to a section that</span>
<a name="l00523"></a>00523 <span class="comment">   is already in the section map and has not since been removed or</span>
<a name="l00524"></a>00524 <span class="comment">   relocated.  */</span>
<a name="l00525"></a>00525 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#a3c4b9f5d17c5d293555c8c5cc2edfb7e">inhibit_section_map_updates</a> (<span class="keyword">struct</span> <a class="code" href="structprogram__space.html">program_space</a> *pspace);
<a name="l00526"></a>00526 
<a name="l00527"></a>00527 <span class="comment">/* Resume automatically rebuilding the section map as required.  */</span>
<a name="l00528"></a>00528 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#a6148340cc76a0eb114de20c54957a6d6">resume_section_map_updates</a> (<span class="keyword">struct</span> <a class="code" href="structprogram__space.html">program_space</a> *pspace);
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="comment">/* Version of the above suitable for use as a cleanup.  */</span>
<a name="l00531"></a>00531 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#a29d7091262d7f39214509978b2fe30d2">resume_section_map_updates_cleanup</a> (<span class="keywordtype">void</span> *arg);
<a name="l00532"></a>00532 
<a name="l00533"></a>00533 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#a8844814eba1633399a0bea052118d206">default_iterate_over_objfiles_in_search_order</a>
<a name="l00534"></a>00534   (<span class="keyword">struct</span> <a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a>,
<a name="l00535"></a>00535    <a class="code" href="gdbarch_8h.html#a97af6b4f01b7e999efa9029c24f2395d">iterate_over_objfiles_in_search_order_cb_ftype</a> *cb,
<a name="l00536"></a>00536    <span class="keywordtype">void</span> *cb_data, <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *current_objfile);
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 
<a name="l00539"></a>00539 <span class="comment">/* Traverse all object files in the current program space.</span>
<a name="l00540"></a>00540 <span class="comment">   ALL_OBJFILES_SAFE works even if you delete the objfile during the</span>
<a name="l00541"></a>00541 <span class="comment">   traversal.  */</span>
<a name="l00542"></a>00542 
<a name="l00543"></a>00543 <span class="comment">/* Traverse all object files in program space SS.  */</span>
<a name="l00544"></a>00544 
<a name="l00545"></a><a class="code" href="objfiles_8h.html#a9c2f75ae5c5a8cb4da219f7cb063e262">00545</a> <span class="preprocessor">#define ALL_PSPACE_OBJFILES(ss, obj)                                    \</span>
<a name="l00546"></a>00546 <span class="preprocessor">  for ((obj) = ss-&gt;objfiles; (obj) != NULL; (obj) = (obj)-&gt;next)</span>
<a name="l00547"></a>00547 <span class="preprocessor"></span>
<a name="l00548"></a><a class="code" href="objfiles_8h.html#aecab1403899d86559b50e2f52f7c6052">00548</a> <span class="preprocessor">#define ALL_PSPACE_OBJFILES_SAFE(ss, obj, nxt)          \</span>
<a name="l00549"></a>00549 <span class="preprocessor">  for ((obj) = ss-&gt;objfiles;                    \</span>
<a name="l00550"></a>00550 <span class="preprocessor">       (obj) != NULL? ((nxt)=(obj)-&gt;next,1) :0; \</span>
<a name="l00551"></a>00551 <span class="preprocessor">       (obj) = (nxt))</span>
<a name="l00552"></a>00552 <span class="preprocessor"></span>
<a name="l00553"></a><a class="code" href="objfiles_8h.html#a8efee3b85a322006131a6056d45058b3">00553</a> <span class="preprocessor">#define ALL_OBJFILES(obj)                           \</span>
<a name="l00554"></a>00554 <span class="preprocessor">  for ((obj) = current_program_space-&gt;objfiles; \</span>
<a name="l00555"></a>00555 <span class="preprocessor">       (obj) != NULL;                               \</span>
<a name="l00556"></a>00556 <span class="preprocessor">       (obj) = (obj)-&gt;next)</span>
<a name="l00557"></a>00557 <span class="preprocessor"></span>
<a name="l00558"></a><a class="code" href="objfiles_8h.html#a7ef07f2da2aa29b817caf474369aa585">00558</a> <span class="preprocessor">#define ALL_OBJFILES_SAFE(obj,nxt)                      \</span>
<a name="l00559"></a>00559 <span class="preprocessor">  for ((obj) = current_program_space-&gt;objfiles; \</span>
<a name="l00560"></a>00560 <span class="preprocessor">       (obj) != NULL? ((nxt)=(obj)-&gt;next,1) :0; \</span>
<a name="l00561"></a>00561 <span class="preprocessor">       (obj) = (nxt))</span>
<a name="l00562"></a>00562 <span class="preprocessor"></span>
<a name="l00563"></a>00563 <span class="comment">/* Traverse all symtabs in one objfile.  */</span>
<a name="l00564"></a>00564 
<a name="l00565"></a><a class="code" href="objfiles_8h.html#ad881e45502f8c05088f9c61165fb7d14">00565</a> <span class="preprocessor">#define ALL_OBJFILE_SYMTABS(objfile, s) \</span>
<a name="l00566"></a>00566 <span class="preprocessor">    for ((s) = (objfile) -&gt; symtabs; (s) != NULL; (s) = (s) -&gt; next)</span>
<a name="l00567"></a>00567 <span class="preprocessor"></span>
<a name="l00568"></a>00568 <span class="comment">/* Traverse all primary symtabs in one objfile.  */</span>
<a name="l00569"></a>00569 
<a name="l00570"></a><a class="code" href="objfiles_8h.html#ac5c382b88266264be72ac28e97437c9d">00570</a> <span class="preprocessor">#define ALL_OBJFILE_PRIMARY_SYMTABS(objfile, s) \</span>
<a name="l00571"></a>00571 <span class="preprocessor">  ALL_OBJFILE_SYMTABS ((objfile), (s)) \</span>
<a name="l00572"></a>00572 <span class="preprocessor">    if ((s)-&gt;primary)</span>
<a name="l00573"></a>00573 <span class="preprocessor"></span>
<a name="l00574"></a>00574 <span class="comment">/* Traverse all minimal symbols in one objfile.  */</span>
<a name="l00575"></a>00575 
<a name="l00576"></a><a class="code" href="objfiles_8h.html#aab33f4a89ebfe4c8adb99dbe422081fe">00576</a> <span class="preprocessor">#define ALL_OBJFILE_MSYMBOLS(objfile, m) \</span>
<a name="l00577"></a>00577 <span class="preprocessor">    for ((m) = (objfile) -&gt; msymbols; SYMBOL_LINKAGE_NAME(m) != NULL; (m)++)</span>
<a name="l00578"></a>00578 <span class="preprocessor"></span>
<a name="l00579"></a>00579 <span class="comment">/* Traverse all symtabs in all objfiles in the current symbol</span>
<a name="l00580"></a>00580 <span class="comment">   space.  */</span>
<a name="l00581"></a>00581 
<a name="l00582"></a><a class="code" href="objfiles_8h.html#ac7a49118a426436bba011cabf8b089b9">00582</a> <span class="preprocessor">#define ALL_SYMTABS(objfile, s) \</span>
<a name="l00583"></a>00583 <span class="preprocessor">  ALL_OBJFILES (objfile)         \</span>
<a name="l00584"></a>00584 <span class="preprocessor">    ALL_OBJFILE_SYMTABS (objfile, s)</span>
<a name="l00585"></a>00585 <span class="preprocessor"></span>
<a name="l00586"></a><a class="code" href="objfiles_8h.html#a1b5652b8dc2231291f2a235487ce0b72">00586</a> <span class="preprocessor">#define ALL_PSPACE_SYMTABS(ss, objfile, s)              \</span>
<a name="l00587"></a>00587 <span class="preprocessor">  ALL_PSPACE_OBJFILES (ss, objfile)                     \</span>
<a name="l00588"></a>00588 <span class="preprocessor">    ALL_OBJFILE_SYMTABS (objfile, s)</span>
<a name="l00589"></a>00589 <span class="preprocessor"></span>
<a name="l00590"></a>00590 <span class="comment">/* Traverse all symtabs in all objfiles in the current program space,</span>
<a name="l00591"></a>00591 <span class="comment">   skipping included files (which share a blockvector with their</span>
<a name="l00592"></a>00592 <span class="comment">   primary symtab).  */</span>
<a name="l00593"></a>00593 
<a name="l00594"></a><a class="code" href="objfiles_8h.html#ac80c9acdada8be123653694d316dc247">00594</a> <span class="preprocessor">#define ALL_PRIMARY_SYMTABS(objfile, s) \</span>
<a name="l00595"></a>00595 <span class="preprocessor">  ALL_OBJFILES (objfile)                \</span>
<a name="l00596"></a>00596 <span class="preprocessor">    ALL_OBJFILE_PRIMARY_SYMTABS (objfile, s)</span>
<a name="l00597"></a>00597 <span class="preprocessor"></span>
<a name="l00598"></a><a class="code" href="objfiles_8h.html#a862af6c5f0058b636e9734543bf5ede3">00598</a> <span class="preprocessor">#define ALL_PSPACE_PRIMARY_SYMTABS(pspace, objfile, s)  \</span>
<a name="l00599"></a>00599 <span class="preprocessor">  ALL_PSPACE_OBJFILES (ss, objfile)                     \</span>
<a name="l00600"></a>00600 <span class="preprocessor">    ALL_OBJFILE_PRIMARY_SYMTABS (objfile, s)</span>
<a name="l00601"></a>00601 <span class="preprocessor"></span>
<a name="l00602"></a>00602 <span class="comment">/* Traverse all minimal symbols in all objfiles in the current symbol</span>
<a name="l00603"></a>00603 <span class="comment">   space.  */</span>
<a name="l00604"></a>00604 
<a name="l00605"></a><a class="code" href="objfiles_8h.html#a3d08aae2073557e019d75ab37f8182d8">00605</a> <span class="preprocessor">#define ALL_MSYMBOLS(objfile, m) \</span>
<a name="l00606"></a>00606 <span class="preprocessor">  ALL_OBJFILES (objfile)         \</span>
<a name="l00607"></a>00607 <span class="preprocessor">    ALL_OBJFILE_MSYMBOLS (objfile, m)</span>
<a name="l00608"></a>00608 <span class="preprocessor"></span>
<a name="l00609"></a><a class="code" href="objfiles_8h.html#ad7608d3f6245108438ac6aca20412589">00609</a> <span class="preprocessor">#define ALL_OBJFILE_OSECTIONS(objfile, osect)   \</span>
<a name="l00610"></a>00610 <span class="preprocessor">  for (osect = objfile-&gt;sections; osect &lt; objfile-&gt;sections_end; osect++) \</span>
<a name="l00611"></a>00611 <span class="preprocessor">    if (osect-&gt;the_bfd_section == NULL)                                 \</span>
<a name="l00612"></a>00612 <span class="preprocessor">      {                                                                 \</span>
<a name="l00613"></a>00613 <span class="preprocessor">        </span><span class="comment">/* Nothing.  */</span>                                                 \
<a name="l00614"></a>00614       }                                                                 \
<a name="l00615"></a>00615     else
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 <span class="comment">/* Traverse all obj_sections in all objfiles in the current program</span>
<a name="l00618"></a>00618 <span class="comment">   space.</span>
<a name="l00619"></a>00619 <span class="comment"></span>
<a name="l00620"></a>00620 <span class="comment">   Note that this detects a &quot;break&quot; in the inner loop, and exits</span>
<a name="l00621"></a>00621 <span class="comment">   immediately from the outer loop as well, thus, client code doesn&#39;t</span>
<a name="l00622"></a>00622 <span class="comment">   need to know that this is implemented with a double for.  The extra</span>
<a name="l00623"></a>00623 <span class="comment">   hair is to make sure that a &quot;break;&quot; stops the outer loop iterating</span>
<a name="l00624"></a>00624 <span class="comment">   as well, and both OBJFILE and OSECT are left unmodified:</span>
<a name="l00625"></a>00625 <span class="comment"></span>
<a name="l00626"></a>00626 <span class="comment">    - The outer loop learns about the inner loop&#39;s end condition, and</span>
<a name="l00627"></a>00627 <span class="comment">      stops iterating if it detects the inner loop didn&#39;t reach its</span>
<a name="l00628"></a>00628 <span class="comment">      end.  In other words, the outer loop keeps going only if the</span>
<a name="l00629"></a>00629 <span class="comment">      inner loop reached its end cleanly [(osect) ==</span>
<a name="l00630"></a>00630 <span class="comment">      (objfile)-&gt;sections_end].</span>
<a name="l00631"></a>00631 <span class="comment"></span>
<a name="l00632"></a>00632 <span class="comment">    - OSECT is initialized in the outer loop initialization</span>
<a name="l00633"></a>00633 <span class="comment">      expressions, such as if the inner loop has reached its end, so</span>
<a name="l00634"></a>00634 <span class="comment">      the check mentioned above succeeds the first time.</span>
<a name="l00635"></a>00635 <span class="comment"></span>
<a name="l00636"></a>00636 <span class="comment">    - The trick to not clearing OBJFILE on a &quot;break;&quot; is, in the outer</span>
<a name="l00637"></a>00637 <span class="comment">      loop&#39;s loop expression, advance OBJFILE, but iff the inner loop</span>
<a name="l00638"></a>00638 <span class="comment">      reached its end.  If not, there was a &quot;break;&quot;, so leave OBJFILE</span>
<a name="l00639"></a>00639 <span class="comment">      as is; the outer loop&#39;s conditional will break immediately as</span>
<a name="l00640"></a>00640 <span class="comment">      well (as OSECT will be different from OBJFILE-&gt;sections_end).  */</span>
<a name="l00641"></a>00641 
<a name="l00642"></a><a class="code" href="objfiles_8h.html#ac97332e8e963307538cd23e38ab820b9">00642</a> <span class="preprocessor">#define ALL_OBJSECTIONS(objfile, osect)                                 \</span>
<a name="l00643"></a>00643 <span class="preprocessor">  for ((objfile) = current_program_space-&gt;objfiles,                     \</span>
<a name="l00644"></a>00644 <span class="preprocessor">         (objfile) != NULL ? ((osect) = (objfile)-&gt;sections_end) : 0;   \</span>
<a name="l00645"></a>00645 <span class="preprocessor">       (objfile) != NULL                                                \</span>
<a name="l00646"></a>00646 <span class="preprocessor">         &amp;&amp; (osect) == (objfile)-&gt;sections_end;                         \</span>
<a name="l00647"></a>00647 <span class="preprocessor">       ((osect) == (objfile)-&gt;sections_end                              \</span>
<a name="l00648"></a>00648 <span class="preprocessor">        ? ((objfile) = (objfile)-&gt;next,                                 \</span>
<a name="l00649"></a>00649 <span class="preprocessor">           (objfile) != NULL ? (osect) = (objfile)-&gt;sections_end : 0)   \</span>
<a name="l00650"></a>00650 <span class="preprocessor">        : 0))                                                           \</span>
<a name="l00651"></a>00651 <span class="preprocessor">    ALL_OBJFILE_OSECTIONS (objfile, osect)</span>
<a name="l00652"></a>00652 <span class="preprocessor"></span>
<a name="l00653"></a><a class="code" href="objfiles_8h.html#a42a1ef9c66f0784ea10448a8a1949bf9">00653</a> <span class="preprocessor">#define SECT_OFF_DATA(objfile) \</span>
<a name="l00654"></a>00654 <span class="preprocessor">     ((objfile-&gt;sect_index_data == -1) \</span>
<a name="l00655"></a>00655 <span class="preprocessor">      ? (internal_error (__FILE__, __LINE__, \</span>
<a name="l00656"></a>00656 <span class="preprocessor">                         _(&quot;sect_index_data not initialized&quot;)), -1)     \</span>
<a name="l00657"></a>00657 <span class="preprocessor">      : objfile-&gt;sect_index_data)</span>
<a name="l00658"></a>00658 <span class="preprocessor"></span>
<a name="l00659"></a><a class="code" href="objfiles_8h.html#a607b7c41db74c147a04dd1e52dddf3e5">00659</a> <span class="preprocessor">#define SECT_OFF_RODATA(objfile) \</span>
<a name="l00660"></a>00660 <span class="preprocessor">     ((objfile-&gt;sect_index_rodata == -1) \</span>
<a name="l00661"></a>00661 <span class="preprocessor">      ? (internal_error (__FILE__, __LINE__, \</span>
<a name="l00662"></a>00662 <span class="preprocessor">                         _(&quot;sect_index_rodata not initialized&quot;)), -1)   \</span>
<a name="l00663"></a>00663 <span class="preprocessor">      : objfile-&gt;sect_index_rodata)</span>
<a name="l00664"></a>00664 <span class="preprocessor"></span>
<a name="l00665"></a><a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">00665</a> <span class="preprocessor">#define SECT_OFF_TEXT(objfile) \</span>
<a name="l00666"></a>00666 <span class="preprocessor">     ((objfile-&gt;sect_index_text == -1) \</span>
<a name="l00667"></a>00667 <span class="preprocessor">      ? (internal_error (__FILE__, __LINE__, \</span>
<a name="l00668"></a>00668 <span class="preprocessor">                         _(&quot;sect_index_text not initialized&quot;)), -1)     \</span>
<a name="l00669"></a>00669 <span class="preprocessor">      : objfile-&gt;sect_index_text)</span>
<a name="l00670"></a>00670 <span class="preprocessor"></span>
<a name="l00671"></a>00671 <span class="comment">/* Sometimes the .bss section is missing from the objfile, so we don&#39;t</span>
<a name="l00672"></a>00672 <span class="comment">   want to die here.  Let the users of SECT_OFF_BSS deal with an</span>
<a name="l00673"></a>00673 <span class="comment">   uninitialized section index.  */</span>
<a name="l00674"></a><a class="code" href="objfiles_8h.html#a3f6faa077173baf9e24df56c66043fbb">00674</a> <span class="preprocessor">#define SECT_OFF_BSS(objfile) (objfile)-&gt;sect_index_bss</span>
<a name="l00675"></a>00675 <span class="preprocessor"></span>
<a name="l00676"></a>00676 <span class="comment">/* Answer whether there is more than one object file loaded.  */</span>
<a name="l00677"></a>00677 
<a name="l00678"></a><a class="code" href="objfiles_8h.html#a929d5fdce429389f9b3602378b5eff42">00678</a> <span class="preprocessor">#define MULTI_OBJFILE_P() (object_files &amp;&amp; object_files-&gt;next)</span>
<a name="l00679"></a>00679 <span class="preprocessor"></span>
<a name="l00680"></a>00680 <span class="comment">/* Reset the per-BFD storage area on OBJ.  */</span>
<a name="l00681"></a>00681 
<a name="l00682"></a>00682 <span class="keywordtype">void</span> <a class="code" href="objfiles_8c.html#aff4c8303314e3260ec86c79e19785701">set_objfile_per_bfd</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *obj);
<a name="l00683"></a>00683 
<a name="l00684"></a>00684 <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>);
<a name="l00685"></a>00685 
<a name="l00686"></a>00686 <span class="preprocessor">#endif </span><span class="comment">/* !defined (OBJFILES_H) */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:13:30 for GDB (xrefs) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
