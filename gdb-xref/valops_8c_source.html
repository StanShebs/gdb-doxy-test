<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (xrefs): /home/stan/gdb/src/gdb/valops.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (xrefs)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/valops.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="valops_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Perform non-arithmetic operations on values, for GDB.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 1986-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   This file is part of GDB.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00010"></a>00010 <span class="comment">   (at your option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00018"></a>00018 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="gdbtypes_8h.html">gdbtypes.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="value_8h.html">value.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="frame_8h.html">frame.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="inferior_8h.html">inferior.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="gdbcore_8h.html">gdbcore.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="target_8h.html">target.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;demangle.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="language_8h.html">language.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="gdbcmd_8h.html">gdbcmd.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="regcache_8h.html">regcache.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="cp-abi_8h.html">cp-abi.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="block_8h.html">block.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="infcall_8h.html">infcall.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="dictionary_8h.html">dictionary.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="cp-support_8h.html">cp-support.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="dfp_8h.html">dfp.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="tracepoint_8h.html">tracepoint.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;errno.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="gdb__string_8h.html">gdb_string.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="gdb__assert_8h.html">gdb_assert.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="cp-support_8h.html">cp-support.h</a>&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="observer_8h.html">observer.h</a>&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="objfiles_8h.html">objfiles.h</a>&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;<a class="code" href="exceptions_8h.html">exceptions.h</a>&quot;</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="gdbtypes_8c.html#aa45853f3c19e5cb9cb4d830912e11395">overload_debug</a>;
<a name="l00049"></a>00049 <span class="comment">/* Local functions.  */</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="valops_8c.html#a153df6d2ebd99111f79a91848d0e55ae">typecmp</a> (<span class="keywordtype">int</span> staticp, <span class="keywordtype">int</span> varargs, <span class="keywordtype">int</span> nargs,
<a name="l00052"></a>00052                     <span class="keyword">struct</span> field t1[], <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *t2[]);
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="valops_8c.html#aecb0e8f1755b58d860741f00dd0cadf5">search_struct_field</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *, 
<a name="l00055"></a>00055                                           <span class="keywordtype">int</span>, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keywordtype">int</span>);
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="valops_8c.html#a272c8540923c2bc901412ab4dd8a822e">search_struct_method</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **,
<a name="l00058"></a>00058                                            <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **,
<a name="l00059"></a>00059                                            <span class="keywordtype">int</span>, <span class="keywordtype">int</span> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="valops_8c.html#a8c6a9c2ede1ffc9e104633727db4204e">find_oload_champ_namespace</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **, <span class="keywordtype">int</span>,
<a name="l00062"></a>00062                                        <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *,
<a name="l00063"></a>00063                                        <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> ***,
<a name="l00064"></a>00064                                        <span class="keyword">struct</span> <a class="code" href="structbadness__vector.html">badness_vector</a> **,
<a name="l00065"></a>00065                                        <span class="keyword">const</span> <span class="keywordtype">int</span> no_adl);
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="keyword">static</span>
<a name="l00068"></a>00068 <span class="keywordtype">int</span> <a class="code" href="valops_8c.html#a86c0da3243d4ffcef3dfac1337bae220">find_oload_champ_namespace_loop</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **, <span class="keywordtype">int</span>,
<a name="l00069"></a>00069                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *,
<a name="l00070"></a>00070                                      <span class="keywordtype">int</span>, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> ***,
<a name="l00071"></a>00071                                      <span class="keyword">struct</span> <a class="code" href="structbadness__vector.html">badness_vector</a> **, <span class="keywordtype">int</span> *,
<a name="l00072"></a>00072                                      <span class="keyword">const</span> <span class="keywordtype">int</span> no_adl);
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="valops_8c.html#a7f4c90439e40cce6113426c5b25e53c6">find_oload_champ</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>,
<a name="l00075"></a>00075                              <span class="keyword">struct</span> fn_field *, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> **,
<a name="l00076"></a>00076                              <span class="keyword">struct</span> <a class="code" href="structbadness__vector.html">badness_vector</a> **);
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="valops_8c.html#a53c5ca67792b188788711efbc1ffac76">oload_method_static</a> (<span class="keywordtype">int</span>, <span class="keyword">struct</span> fn_field *, <span class="keywordtype">int</span>);
<a name="l00079"></a>00079 
<a name="l00080"></a><a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7a9de934790934fe831fe946c851e8338e">00080</a> <span class="keyword">enum</span> <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7">oload_classification</a> { <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7a9de934790934fe831fe946c851e8338e">STANDARD</a>, <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7a2e658c001901706a2e2c19f15652a417">NON_STANDARD</a>, <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7a1d5787f0d18fdb7422615b7c08562710">INCOMPATIBLE</a> };
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 <span class="keyword">static</span> <span class="keyword">enum</span>
<a name="l00083"></a>00083 <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7">oload_classification</a> <a class="code" href="valops_8c.html#a60d383f4b94d6281a9be1ddc9035bab4">classify_oload_match</a> (<span class="keyword">struct</span> <a class="code" href="structbadness__vector.html">badness_vector</a> *,
<a name="l00084"></a>00084                                            <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="valops_8c.html#a107fe3950fecf16bb0bf7ce7290b09f0">value_struct_elt_for_reference</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l00087"></a>00087                                                      <span class="keywordtype">int</span>, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l00088"></a>00088                                                      <span class="keywordtype">char</span> *,
<a name="l00089"></a>00089                                                      <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l00090"></a>00090                                                      <span class="keywordtype">int</span>, <span class="keyword">enum</span> <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73">noside</a>);
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="valops_8c.html#af2efc03285e4b19401311e51300bf427">value_namespace_elt</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l00093"></a>00093                                           <span class="keywordtype">char</span> *, <span class="keywordtype">int</span> , <span class="keyword">enum</span> <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73">noside</a>);
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="valops_8c.html#a1d5f3c2626c3a57cee4586968dd9a1c7">value_maybe_namespace_elt</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l00096"></a>00096                                                 <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>,
<a name="l00097"></a>00097                                                 <span class="keyword">enum</span> <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73">noside</a>);
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="valops_8c.html#aa2b54cae947d2ce4891dad670286fb92">allocate_space_in_inferior</a> (<span class="keywordtype">int</span>);
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="valops_8c.html#aa6339bc660215f0da06ebafed0703d20">cast_into_complex</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *);
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="keyword">static</span> <span class="keyword">struct </span>fn_field *<a class="code" href="valops_8c.html#a189e79c34c5e7329d73b5d80dd20384a">find_method_list</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **, <span class="keyword">const</span> <span class="keywordtype">char</span> *,
<a name="l00104"></a>00104                                           <span class="keywordtype">int</span>, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keywordtype">int</span> *,
<a name="l00105"></a>00105                                           <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **, <span class="keywordtype">int</span> *);
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="keywordtype">void</span> <a class="code" href="init_8c.html#a347aadb7eb733d717880347d098fa7a4">_initialize_valops</a> (<span class="keywordtype">void</span>);
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="preprocessor">#if 0</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span><span class="comment">/* Flag for whether we want to abandon failed expression evals by</span>
<a name="l00111"></a>00111 <span class="comment">   default.  */</span>
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 <span class="keyword">static</span> <span class="keywordtype">int</span> auto_abandon = 0;
<a name="l00114"></a>00114 <span class="preprocessor">#endif</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span>
<a name="l00116"></a><a class="code" href="valops_8c.html#a77a4a275864a2a5a429965b0136adbc6">00116</a> <span class="keywordtype">int</span> <a class="code" href="eval_8c.html#a77a4a275864a2a5a429965b0136adbc6">overload_resolution</a> = 0;
<a name="l00117"></a>00117 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00118"></a><a class="code" href="valops_8c.html#a9282b1fefb8a60702d131f7d8865afaf">00118</a> <a class="code" href="valops_8c.html#a9282b1fefb8a60702d131f7d8865afaf">show_overload_resolution</a> (<span class="keyword">struct</span> <a class="code" href="structui__file.html">ui_file</a> *file, <span class="keywordtype">int</span> from_tty,
<a name="l00119"></a>00119                           <span class="keyword">struct</span> <a class="code" href="structcmd__list__element.html">cmd_list_element</a> *c, 
<a name="l00120"></a>00120                           <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structvalue.html">value</a>)
<a name="l00121"></a>00121 {
<a name="l00122"></a>00122   <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (file, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Overload resolution in evaluating &quot;</span>
<a name="l00123"></a>00123                             <span class="stringliteral">&quot;C++ functions is %s.\n&quot;</span>),
<a name="l00124"></a>00124                     value);
<a name="l00125"></a>00125 }
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 <span class="comment">/* Find the address of function name NAME in the inferior.  If OBJF_P</span>
<a name="l00128"></a>00128 <span class="comment">   is non-NULL, *OBJF_P will be set to the OBJFILE where the function</span>
<a name="l00129"></a>00129 <span class="comment">   is defined.  */</span>
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l00132"></a><a class="code" href="value_8h.html#a52fa84294b6e49fa31006f2fdfffd84a">00132</a> <a class="code" href="valops_8c.html#a122c0454d98b26597f4bfa54ba4e587d">find_function_in_inferior</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> **objf_p)
<a name="l00133"></a>00133 {
<a name="l00134"></a>00134   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l00135"></a>00135 
<a name="l00136"></a>00136   sym = <a class="code" href="symtab_8c.html#a8a5c3f803198aed047a55c0e4f61b315">lookup_symbol</a> (name, 0, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, 0);
<a name="l00137"></a>00137   <span class="keywordflow">if</span> (sym != NULL)
<a name="l00138"></a>00138     {
<a name="l00139"></a>00139       <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) != <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>)
<a name="l00140"></a>00140         {
<a name="l00141"></a>00141           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\&quot;%s\&quot; exists in this program but is not a function.&quot;</span>),
<a name="l00142"></a>00142                  name);
<a name="l00143"></a>00143         }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145       <span class="keywordflow">if</span> (objf_p)
<a name="l00146"></a>00146         *objf_p = <a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (sym)-&gt;objfile;
<a name="l00147"></a>00147 
<a name="l00148"></a>00148       <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a353e75e3afb5f274e886d08360d045b8">value_of_variable</a> (sym, NULL);
<a name="l00149"></a>00149     }
<a name="l00150"></a>00150   <span class="keywordflow">else</span>
<a name="l00151"></a>00151     {
<a name="l00152"></a>00152       <span class="keyword">struct </span><a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol</a> msymbol = 
<a name="l00153"></a>00153         <a class="code" href="minsyms_8c.html#a897792988bedbb8b26bdc46838516a90">lookup_bound_minimal_symbol</a> (name);
<a name="l00154"></a>00154 
<a name="l00155"></a>00155       <span class="keywordflow">if</span> (msymbol.<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a> != NULL)
<a name="l00156"></a>00156         {
<a name="l00157"></a>00157           <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a> = msymbol.<a class="code" href="structbound__minimal__symbol.html#a070e0e47d191675f0f4892e0b321d663">objfile</a>;
<a name="l00158"></a>00158           <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l00159"></a>00159 
<a name="l00160"></a>00160           <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l00161"></a>00161           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> maddr;
<a name="l00162"></a>00162           type = <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (<a class="code" href="structbuiltin__type.html">builtin_type</a> (gdbarch)-&gt;builtin_char);
<a name="l00163"></a>00163           type = <a class="code" href="gdbtypes_8c.html#ab21dd6531306fba2a7078534017df6fb">lookup_function_type</a> (type);
<a name="l00164"></a>00164           type = <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (type);
<a name="l00165"></a>00165           maddr = <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (msymbol.<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>);
<a name="l00166"></a>00166 
<a name="l00167"></a>00167           <span class="keywordflow">if</span> (objf_p)
<a name="l00168"></a>00168             *objf_p = objfile;
<a name="l00169"></a>00169 
<a name="l00170"></a>00170           <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a2f2d0d3d3ce482fc844f1fc4dc4c038e">value_from_pointer</a> (type, maddr);
<a name="l00171"></a>00171         }
<a name="l00172"></a>00172       <span class="keywordflow">else</span>
<a name="l00173"></a>00173         {
<a name="l00174"></a>00174           <span class="keywordflow">if</span> (!<a class="code" href="target_8h.html#a85885df22f7c1304269eaba1e1d618b7">target_has_execution</a>)
<a name="l00175"></a>00175             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;evaluation of this expression &quot;</span>
<a name="l00176"></a>00176                      <span class="stringliteral">&quot;requires the target program to be active&quot;</span>));
<a name="l00177"></a>00177           <span class="keywordflow">else</span>
<a name="l00178"></a>00178             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;evaluation of this expression requires the &quot;</span>
<a name="l00179"></a>00179                      <span class="stringliteral">&quot;program to have a function \&quot;%s\&quot;.&quot;</span>),
<a name="l00180"></a>00180                    name);
<a name="l00181"></a>00181         }
<a name="l00182"></a>00182     }
<a name="l00183"></a>00183 }
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 <span class="comment">/* Allocate NBYTES of space in the inferior using the inferior&#39;s</span>
<a name="l00186"></a>00186 <span class="comment">   malloc and return a value that is a pointer to the allocated</span>
<a name="l00187"></a>00187 <span class="comment">   space.  */</span>
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l00190"></a><a class="code" href="value_8h.html#a6dc33d73722ede438e64cbfd77c82d9a">00190</a> <a class="code" href="valops_8c.html#a44cbd3d7cac10c3852c1f23cc47987c8">value_allocate_space_in_inferior</a> (<span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>)
<a name="l00191"></a>00191 {
<a name="l00192"></a>00192   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *objf;
<a name="l00193"></a>00193   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *val = <a class="code" href="valops_8c.html#a122c0454d98b26597f4bfa54ba4e587d">find_function_in_inferior</a> (<span class="stringliteral">&quot;malloc&quot;</span>, &amp;objf);
<a name="l00194"></a>00194   <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objf);
<a name="l00195"></a>00195   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *blocklen;
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   blocklen = <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (<a class="code" href="structbuiltin__type.html">builtin_type</a> (gdbarch)-&gt;builtin_int, len);
<a name="l00198"></a>00198   val = <a class="code" href="infcall_8c.html#a8344d63cd8405f1e9fae104da173283d">call_function_by_hand</a> (val, 1, &amp;blocklen);
<a name="l00199"></a>00199   <span class="keywordflow">if</span> (<a class="code" href="valarith_8c.html#a821fac89ccfe296b4a931fd1123c7fca">value_logical_not</a> (val))
<a name="l00200"></a>00200     {
<a name="l00201"></a>00201       <span class="keywordflow">if</span> (!<a class="code" href="target_8h.html#a85885df22f7c1304269eaba1e1d618b7">target_has_execution</a>)
<a name="l00202"></a>00202         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No memory available to program now: &quot;</span>
<a name="l00203"></a>00203                  <span class="stringliteral">&quot;you need to start the target first&quot;</span>));
<a name="l00204"></a>00204       <span class="keywordflow">else</span>
<a name="l00205"></a>00205         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No memory available to program: call to malloc failed&quot;</span>));
<a name="l00206"></a>00206     }
<a name="l00207"></a>00207   <span class="keywordflow">return</span> val;
<a name="l00208"></a>00208 }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l00211"></a><a class="code" href="valops_8c.html#aa2b54cae947d2ce4891dad670286fb92">00211</a> <a class="code" href="valops_8c.html#aa2b54cae947d2ce4891dad670286fb92">allocate_space_in_inferior</a> (<span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>)
<a name="l00212"></a>00212 {
<a name="l00213"></a>00213   <span class="keywordflow">return</span> <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (<a class="code" href="valops_8c.html#a44cbd3d7cac10c3852c1f23cc47987c8">value_allocate_space_in_inferior</a> (len));
<a name="l00214"></a>00214 }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216 <span class="comment">/* Cast struct value VAL to type TYPE and return as a value.</span>
<a name="l00217"></a>00217 <span class="comment">   Both type and val must be of TYPE_CODE_STRUCT or TYPE_CODE_UNION</span>
<a name="l00218"></a>00218 <span class="comment">   for this to work.  Typedef to one of the codes is permitted.</span>
<a name="l00219"></a>00219 <span class="comment">   Returns NULL if the cast is neither an upcast nor a downcast.  */</span>
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l00222"></a><a class="code" href="valops_8c.html#a59646c9f6e52e7b12cc6ae0fcc828556">00222</a> <a class="code" href="valops_8c.html#a59646c9f6e52e7b12cc6ae0fcc828556">value_cast_structs</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *v2)
<a name="l00223"></a>00223 {
<a name="l00224"></a>00224   <span class="keyword">struct </span>type *t1;
<a name="l00225"></a>00225   <span class="keyword">struct </span>type *t2;
<a name="l00226"></a>00226   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *v;
<a name="l00227"></a>00227 
<a name="l00228"></a>00228   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (type != NULL &amp;&amp; v2 != NULL);
<a name="l00229"></a>00229 
<a name="l00230"></a>00230   t1 = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (type);
<a name="l00231"></a>00231   t2 = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (v2));
<a name="l00232"></a>00232 
<a name="l00233"></a>00233   <span class="comment">/* Check preconditions.  */</span>
<a name="l00234"></a>00234   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> ((<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t1) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l00235"></a>00235                || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t1) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l00236"></a>00236               &amp;&amp; !!<span class="stringliteral">&quot;Precondition is that type is of STRUCT or UNION kind.&quot;</span>);
<a name="l00237"></a>00237   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> ((<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t2) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l00238"></a>00238                || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t2) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l00239"></a>00239               &amp;&amp; !!<span class="stringliteral">&quot;Precondition is that value is of STRUCT or UNION kind&quot;</span>);
<a name="l00240"></a>00240 
<a name="l00241"></a>00241   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (t1) != NULL
<a name="l00242"></a>00242       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (t2) != NULL
<a name="l00243"></a>00243       &amp;&amp; !strcmp (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (t1), <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (t2)))
<a name="l00244"></a>00244     <span class="keywordflow">return</span> NULL;
<a name="l00245"></a>00245 
<a name="l00246"></a>00246   <span class="comment">/* Upcasting: look in the type of the source to see if it contains the</span>
<a name="l00247"></a>00247 <span class="comment">     type of the target as a superclass.  If so, we&#39;ll need to</span>
<a name="l00248"></a>00248 <span class="comment">     offset the pointer rather than just change its type.  */</span>
<a name="l00249"></a>00249   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (t1) != NULL)
<a name="l00250"></a>00250     {
<a name="l00251"></a>00251       v = <a class="code" href="valops_8c.html#aecb0e8f1755b58d860741f00dd0cadf5">search_struct_field</a> (<a class="code" href="gdbtypes_8c.html#a1bce8398d8a46f3d37bfc7e618ab9e9d">type_name_no_tag</a> (t1),
<a name="l00252"></a>00252                                v2, 0, t2, 1);
<a name="l00253"></a>00253       <span class="keywordflow">if</span> (v)
<a name="l00254"></a>00254         <span class="keywordflow">return</span> v;
<a name="l00255"></a>00255     }
<a name="l00256"></a>00256 
<a name="l00257"></a>00257   <span class="comment">/* Downcasting: look in the type of the target to see if it contains the</span>
<a name="l00258"></a>00258 <span class="comment">     type of the source as a superclass.  If so, we&#39;ll need to</span>
<a name="l00259"></a>00259 <span class="comment">     offset the pointer rather than just change its type.  */</span>
<a name="l00260"></a>00260   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (t2) != NULL)
<a name="l00261"></a>00261     {
<a name="l00262"></a>00262       <span class="comment">/* Try downcasting using the run-time type of the value.  */</span>
<a name="l00263"></a>00263       <span class="keywordtype">int</span> full, top, using_enc;
<a name="l00264"></a>00264       <span class="keyword">struct </span>type *real_type;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266       real_type = <a class="code" href="cp-abi_8c.html#a2e4a56716a4c26e96f1ce00c93f83c04">value_rtti_type</a> (v2, &amp;full, &amp;top, &amp;using_enc);
<a name="l00267"></a>00267       <span class="keywordflow">if</span> (real_type)
<a name="l00268"></a>00268         {
<a name="l00269"></a>00269           v = <a class="code" href="valops_8c.html#ad255d8fbb1ae5eb8ea28ad8befb22c92">value_full_object</a> (v2, real_type, full, top, using_enc);
<a name="l00270"></a>00270           v = <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (real_type, <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (v));
<a name="l00271"></a>00271 
<a name="l00272"></a>00272           <span class="comment">/* We might be trying to cast to the outermost enclosing</span>
<a name="l00273"></a>00273 <span class="comment">             type, in which case search_struct_field won&#39;t work.  */</span>
<a name="l00274"></a>00274           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (real_type) != NULL
<a name="l00275"></a>00275               &amp;&amp; !strcmp (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (real_type), <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (t1)))
<a name="l00276"></a>00276             <span class="keywordflow">return</span> v;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278           v = <a class="code" href="valops_8c.html#aecb0e8f1755b58d860741f00dd0cadf5">search_struct_field</a> (<a class="code" href="gdbtypes_8c.html#a1bce8398d8a46f3d37bfc7e618ab9e9d">type_name_no_tag</a> (t2), v, 0, real_type, 1);
<a name="l00279"></a>00279           <span class="keywordflow">if</span> (v)
<a name="l00280"></a>00280             <span class="keywordflow">return</span> v;
<a name="l00281"></a>00281         }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283       <span class="comment">/* Try downcasting using information from the destination type</span>
<a name="l00284"></a>00284 <span class="comment">         T2.  This wouldn&#39;t work properly for classes with virtual</span>
<a name="l00285"></a>00285 <span class="comment">         bases, but those were handled above.  */</span>
<a name="l00286"></a>00286       v = <a class="code" href="valops_8c.html#aecb0e8f1755b58d860741f00dd0cadf5">search_struct_field</a> (<a class="code" href="gdbtypes_8c.html#a1bce8398d8a46f3d37bfc7e618ab9e9d">type_name_no_tag</a> (t2),
<a name="l00287"></a>00287                                <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (t1, <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>), 0, t1, 1);
<a name="l00288"></a>00288       <span class="keywordflow">if</span> (v)
<a name="l00289"></a>00289         {
<a name="l00290"></a>00290           <span class="comment">/* Downcasting is possible (t1 is superclass of v2).  */</span>
<a name="l00291"></a>00291           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr2 = <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (v2);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293           addr2 -= <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (v) + <a class="code" href="value_8c.html#acbd6146ab9bd4c54f994a895a66f3f3d">value_embedded_offset</a> (v);
<a name="l00294"></a>00294           <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#aed5411e37c248ed2abd959ddae4e9d34">value_at</a> (type, addr2);
<a name="l00295"></a>00295         }
<a name="l00296"></a>00296     }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298   <span class="keywordflow">return</span> NULL;
<a name="l00299"></a>00299 }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 <span class="comment">/* Cast one pointer or reference type to another.  Both TYPE and</span>
<a name="l00302"></a>00302 <span class="comment">   the type of ARG2 should be pointer types, or else both should be</span>
<a name="l00303"></a>00303 <span class="comment">   reference types.  If SUBCLASS_CHECK is non-zero, this will force a</span>
<a name="l00304"></a>00304 <span class="comment">   check to see whether TYPE is a superclass of ARG2&#39;s type.  If</span>
<a name="l00305"></a>00305 <span class="comment">   SUBCLASS_CHECK is zero, then the subclass check is done only when</span>
<a name="l00306"></a>00306 <span class="comment">   ARG2 is itself non-zero.  Returns the new pointer or reference.  */</span>
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l00309"></a><a class="code" href="value_8h.html#af665b8488c0ca268a38ab4c75e302017">00309</a> <a class="code" href="valops_8c.html#a05b825cece89f641f79b46a16afb9425">value_cast_pointers</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *arg2,
<a name="l00310"></a>00310                      <span class="keywordtype">int</span> subclass_check)
<a name="l00311"></a>00311 {
<a name="l00312"></a>00312   <span class="keyword">struct </span>type *type1 = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (type);
<a name="l00313"></a>00313   <span class="keyword">struct </span>type *type2 = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2));
<a name="l00314"></a>00314   <span class="keyword">struct </span>type *t1 = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type1));
<a name="l00315"></a>00315   <span class="keyword">struct </span>type *t2 = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type2));
<a name="l00316"></a>00316 
<a name="l00317"></a>00317   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t1) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l00318"></a>00318       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t2) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l00319"></a>00319       &amp;&amp; (subclass_check || !<a class="code" href="valarith_8c.html#a821fac89ccfe296b4a931fd1123c7fca">value_logical_not</a> (arg2)))
<a name="l00320"></a>00320     {
<a name="l00321"></a>00321       <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *v2;
<a name="l00322"></a>00322 
<a name="l00323"></a>00323       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type2) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l00324"></a>00324         v2 = <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (arg2);
<a name="l00325"></a>00325       <span class="keywordflow">else</span>
<a name="l00326"></a>00326         v2 = <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (arg2);
<a name="l00327"></a>00327       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (v2)))
<a name="l00328"></a>00328                   == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a> &amp;&amp; !!<span class="stringliteral">&quot;Why did coercion fail?&quot;</span>);
<a name="l00329"></a>00329       v2 = <a class="code" href="valops_8c.html#a59646c9f6e52e7b12cc6ae0fcc828556">value_cast_structs</a> (t1, v2);
<a name="l00330"></a>00330       <span class="comment">/* At this point we have what we can have, un-dereference if needed.  */</span>
<a name="l00331"></a>00331       <span class="keywordflow">if</span> (v2)
<a name="l00332"></a>00332         {
<a name="l00333"></a>00333           <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *v = <a class="code" href="valops_8c.html#a29bc320305726a3cbf324189df2ca772">value_addr</a> (v2);
<a name="l00334"></a>00334 
<a name="l00335"></a>00335           <a class="code" href="value_8c.html#adac1b2d5054e2d7b44ea25ac1f8002f1">deprecated_set_value_type</a> (v, type);
<a name="l00336"></a>00336           <span class="keywordflow">return</span> v;
<a name="l00337"></a>00337         }
<a name="l00338"></a>00338    }
<a name="l00339"></a>00339 
<a name="l00340"></a>00340   <span class="comment">/* No superclass found, just change the pointer type.  */</span>
<a name="l00341"></a>00341   arg2 = <a class="code" href="value_8c.html#abe2b4f6342cfefdbb63666b6bcba636b">value_copy</a> (arg2);
<a name="l00342"></a>00342   <a class="code" href="value_8c.html#adac1b2d5054e2d7b44ea25ac1f8002f1">deprecated_set_value_type</a> (arg2, type);
<a name="l00343"></a>00343   <a class="code" href="value_8c.html#ac90fd2d225f145f10b5f4d515027d7d2">set_value_enclosing_type</a> (arg2, type);
<a name="l00344"></a>00344   <a class="code" href="value_8c.html#ae68cafe981874da3e148c261f24bbb04">set_value_pointed_to_offset</a> (arg2, 0);        <span class="comment">/* pai: chk_val */</span>
<a name="l00345"></a>00345   <span class="keywordflow">return</span> arg2;
<a name="l00346"></a>00346 }
<a name="l00347"></a>00347 
<a name="l00348"></a>00348 <span class="comment">/* Cast value ARG2 to type TYPE and return as a value.</span>
<a name="l00349"></a>00349 <span class="comment">   More general than a C cast: accepts any two types of the same length,</span>
<a name="l00350"></a>00350 <span class="comment">   and if ARG2 is an lvalue it can be cast into anything at all.  */</span>
<a name="l00351"></a>00351 <span class="comment">/* In C++, casts may change pointer or object representations.  */</span>
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l00354"></a><a class="code" href="value_8h.html#a458c471119ca0e007cecaa24fe6b1333">00354</a> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *arg2)
<a name="l00355"></a>00355 {
<a name="l00356"></a>00356   <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> code1;
<a name="l00357"></a>00357   <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> code2;
<a name="l00358"></a>00358   <span class="keywordtype">int</span> scalar;
<a name="l00359"></a>00359   <span class="keyword">struct </span>type *type2;
<a name="l00360"></a>00360 
<a name="l00361"></a>00361   <span class="keywordtype">int</span> convert_to_boolean = 0;
<a name="l00362"></a>00362 
<a name="l00363"></a>00363   <span class="keywordflow">if</span> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2) == type)
<a name="l00364"></a>00364     <span class="keywordflow">return</span> arg2;
<a name="l00365"></a>00365 
<a name="l00366"></a>00366   code1 = <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (type));
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <span class="comment">/* Check if we are casting struct reference to struct reference.  */</span>
<a name="l00369"></a>00369   <span class="keywordflow">if</span> (code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l00370"></a>00370     {
<a name="l00371"></a>00371       <span class="comment">/* We dereference type; then we recurse and finally</span>
<a name="l00372"></a>00372 <span class="comment">         we generate value of the given reference.  Nothing wrong with </span>
<a name="l00373"></a>00373 <span class="comment">         that.  */</span>
<a name="l00374"></a>00374       <span class="keyword">struct </span>type *t1 = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (type);
<a name="l00375"></a>00375       <span class="keyword">struct </span>type *dereftype = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (t1));
<a name="l00376"></a>00376       <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *val =  <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (dereftype, arg2);
<a name="l00377"></a>00377 
<a name="l00378"></a>00378       <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#ab73ccebbfb87a9332020dcf03976b053">value_ref</a> (val); 
<a name="l00379"></a>00379     }
<a name="l00380"></a>00380 
<a name="l00381"></a>00381   code2 = <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2)));
<a name="l00382"></a>00382 
<a name="l00383"></a>00383   <span class="keywordflow">if</span> (code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l00384"></a>00384     <span class="comment">/* We deref the value and then do the cast.  */</span>
<a name="l00385"></a>00385     <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (type, <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (arg2)); 
<a name="l00386"></a>00386 
<a name="l00387"></a>00387   <a class="code" href="gdbtypes_8h.html#ae2f9348c644babaa9038b4dc18bffaac">CHECK_TYPEDEF</a> (type);
<a name="l00388"></a>00388   code1 = <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type);
<a name="l00389"></a>00389   arg2 = <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (arg2);
<a name="l00390"></a>00390   type2 = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2));
<a name="l00391"></a>00391 
<a name="l00392"></a>00392   <span class="comment">/* You can&#39;t cast to a reference type.  See value_cast_pointers</span>
<a name="l00393"></a>00393 <span class="comment">     instead.  */</span>
<a name="l00394"></a>00394   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (code1 != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>);
<a name="l00395"></a>00395 
<a name="l00396"></a>00396   <span class="comment">/* A cast to an undetermined-length array_type, such as </span>
<a name="l00397"></a>00397 <span class="comment">     (TYPE [])OBJECT, is treated like a cast to (TYPE [N])OBJECT,</span>
<a name="l00398"></a>00398 <span class="comment">     where N is sizeof(OBJECT)/sizeof(TYPE).  */</span>
<a name="l00399"></a>00399   <span class="keywordflow">if</span> (code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l00400"></a>00400     {
<a name="l00401"></a>00401       <span class="keyword">struct </span>type *element_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l00402"></a>00402       <span class="keywordtype">unsigned</span> element_length = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (element_type));
<a name="l00403"></a>00403 
<a name="l00404"></a>00404       <span class="keywordflow">if</span> (element_length &gt; 0 &amp;&amp; <a class="code" href="gdbtypes_8h.html#a54487ac042b1fcfca60cf43c158af526">TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED</a> (type))
<a name="l00405"></a>00405         {
<a name="l00406"></a>00406           <span class="keyword">struct </span>type *range_type = <a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (type);
<a name="l00407"></a>00407           <span class="keywordtype">int</span> val_length = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type2);
<a name="l00408"></a>00408           <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> low_bound, high_bound, new_length;
<a name="l00409"></a>00409 
<a name="l00410"></a>00410           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#a6b7f508cb2cdaf4d8f53494d9239b163">get_discrete_bounds</a> (range_type, &amp;low_bound, &amp;high_bound) &lt; 0)
<a name="l00411"></a>00411             low_bound = 0, high_bound = 0;
<a name="l00412"></a>00412           new_length = val_length / element_length;
<a name="l00413"></a>00413           <span class="keywordflow">if</span> (val_length % element_length != 0)
<a name="l00414"></a>00414             <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;array element type size does not &quot;</span>
<a name="l00415"></a>00415                        <span class="stringliteral">&quot;divide object size in cast&quot;</span>));
<a name="l00416"></a>00416           <span class="comment">/* FIXME-type-allocation: need a way to free this type when</span>
<a name="l00417"></a>00417 <span class="comment">             we are done with it.  */</span>
<a name="l00418"></a>00418           range_type = <a class="code" href="gdbtypes_8c.html#ab0885fdae181c47ff3f958bcba70b82d">create_range_type</a> ((<span class="keyword">struct</span> type *) NULL,
<a name="l00419"></a>00419                                           <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (range_type),
<a name="l00420"></a>00420                                           low_bound,
<a name="l00421"></a>00421                                           new_length + low_bound - 1);
<a name="l00422"></a>00422           <a class="code" href="value_8c.html#adac1b2d5054e2d7b44ea25ac1f8002f1">deprecated_set_value_type</a> (arg2, 
<a name="l00423"></a>00423                                      <a class="code" href="gdbtypes_8c.html#a779bbebb8202264a73344b49b22d774e">create_array_type</a> ((<span class="keyword">struct</span> type *) NULL,
<a name="l00424"></a>00424                                                         element_type, 
<a name="l00425"></a>00425                                                         range_type));
<a name="l00426"></a>00426           <span class="keywordflow">return</span> arg2;
<a name="l00427"></a>00427         }
<a name="l00428"></a>00428     }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430   <span class="keywordflow">if</span> (<a class="code" href="language_8c.html#acd2505a014a95629da9c836f8914fc79">current_language</a>-&gt;<a class="code" href="structlanguage__defn.html#a14aa24c8c78b4aa2bb9ac7f64b10229e">c_style_arrays</a>
<a name="l00431"></a>00431       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type2) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l00432"></a>00432       &amp;&amp; !<a class="code" href="gdbtypes_8h.html#a68a23253bcb233221400208f4c21c406">TYPE_VECTOR</a> (type2))
<a name="l00433"></a>00433     arg2 = <a class="code" href="valops_8c.html#aaa184aecfd7121e9660f6385d03b8324">value_coerce_array</a> (arg2);
<a name="l00434"></a>00434 
<a name="l00435"></a>00435   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type2) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>)
<a name="l00436"></a>00436     arg2 = <a class="code" href="valops_8c.html#a5327ca7c1db660a4b64383dbc1e01791">value_coerce_function</a> (arg2);
<a name="l00437"></a>00437 
<a name="l00438"></a>00438   type2 = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2));
<a name="l00439"></a>00439   code2 = <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type2);
<a name="l00440"></a>00440 
<a name="l00441"></a>00441   <span class="keywordflow">if</span> (code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad8de4d143b624cd2bcab740a51a04658">TYPE_CODE_COMPLEX</a>)
<a name="l00442"></a>00442     <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#aa6339bc660215f0da06ebafed0703d20">cast_into_complex</a> (type, arg2);
<a name="l00443"></a>00443   <span class="keywordflow">if</span> (code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462afbf0aa0241df408e1017ae7ff8e6798c">TYPE_CODE_BOOL</a>)
<a name="l00444"></a>00444     {
<a name="l00445"></a>00445       code1 = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>;
<a name="l00446"></a>00446       convert_to_boolean = 1;
<a name="l00447"></a>00447     }
<a name="l00448"></a>00448   <span class="keywordflow">if</span> (code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae991dd7ea70631f3e1b67a1a75020b5f">TYPE_CODE_CHAR</a>)
<a name="l00449"></a>00449     code1 = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>;
<a name="l00450"></a>00450   <span class="keywordflow">if</span> (code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462afbf0aa0241df408e1017ae7ff8e6798c">TYPE_CODE_BOOL</a> || code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae991dd7ea70631f3e1b67a1a75020b5f">TYPE_CODE_CHAR</a>)
<a name="l00451"></a>00451     code2 = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>;
<a name="l00452"></a>00452 
<a name="l00453"></a>00453   scalar = (code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a> || code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>
<a name="l00454"></a>00454             || code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ace4e1a5aff0ea601f04c6f25eb8ed47b">TYPE_CODE_DECFLOAT</a> || code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>
<a name="l00455"></a>00455             || code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>);
<a name="l00456"></a>00456 
<a name="l00457"></a>00457   <span class="keywordflow">if</span> ((code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a> || code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l00458"></a>00458       &amp;&amp; (code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a> || code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l00459"></a>00459       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) != 0)
<a name="l00460"></a>00460     {
<a name="l00461"></a>00461       <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *v = <a class="code" href="valops_8c.html#a59646c9f6e52e7b12cc6ae0fcc828556">value_cast_structs</a> (type, arg2);
<a name="l00462"></a>00462 
<a name="l00463"></a>00463       <span class="keywordflow">if</span> (v)
<a name="l00464"></a>00464         <span class="keywordflow">return</span> v;
<a name="l00465"></a>00465     }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467   <span class="keywordflow">if</span> (code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a> &amp;&amp; scalar)
<a name="l00468"></a>00468     <span class="keywordflow">return</span> <a class="code" href="value_8c.html#ac2cf5b8fa401dbfc4c1fb505b002c0bf">value_from_double</a> (type, <a class="code" href="value_8c.html#a70cb29f1d53150216cc7816d93b8b115">value_as_double</a> (arg2));
<a name="l00469"></a>00469   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ace4e1a5aff0ea601f04c6f25eb8ed47b">TYPE_CODE_DECFLOAT</a> &amp;&amp; scalar)
<a name="l00470"></a>00470     {
<a name="l00471"></a>00471       <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (<a class="code" href="gdbtypes_8c.html#a84ca61a6d58c2bd2c7dcedf19d56a39d">get_type_arch</a> (type));
<a name="l00472"></a>00472       <span class="keywordtype">int</span> dec_len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type);
<a name="l00473"></a>00473       <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> dec[16];
<a name="l00474"></a>00474 
<a name="l00475"></a>00475       <span class="keywordflow">if</span> (code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>)
<a name="l00476"></a>00476         <a class="code" href="dfp_8c.html#aa4c0235281cfa294d14920eebd18a01f">decimal_from_floating</a> (arg2, dec, dec_len, byte_order);
<a name="l00477"></a>00477       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ace4e1a5aff0ea601f04c6f25eb8ed47b">TYPE_CODE_DECFLOAT</a>)
<a name="l00478"></a>00478         <a class="code" href="dfp_8c.html#a1b75ef24878b3cba6f681d969b7a641a">decimal_convert</a> (<a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (arg2), <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type2),
<a name="l00479"></a>00479                          byte_order, dec, dec_len, byte_order);
<a name="l00480"></a>00480       <span class="keywordflow">else</span>
<a name="l00481"></a>00481         <span class="comment">/* The only option left is an integral type.  */</span>
<a name="l00482"></a>00482         <a class="code" href="dfp_8c.html#ab99188e056fa18f7e3719b9a75f9eaca">decimal_from_integral</a> (arg2, dec, dec_len, byte_order);
<a name="l00483"></a>00483 
<a name="l00484"></a>00484       <span class="keywordflow">return</span> <a class="code" href="value_8c.html#ab8645cba250bddc4b62ee9aa9629d755">value_from_decfloat</a> (type, dec);
<a name="l00485"></a>00485     }
<a name="l00486"></a>00486   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a> || code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>
<a name="l00487"></a>00487             || code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>)
<a name="l00488"></a>00488            &amp;&amp; (scalar || code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l00489"></a>00489                || code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a0311d6e6980a50c23e68350f1b8fb5ae">TYPE_CODE_MEMBERPTR</a>))
<a name="l00490"></a>00490     {
<a name="l00491"></a>00491       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> longest;
<a name="l00492"></a>00492 
<a name="l00493"></a>00493       <span class="comment">/* When we cast pointers to integers, we mustn&#39;t use</span>
<a name="l00494"></a>00494 <span class="comment">         gdbarch_pointer_to_address to find the address the pointer</span>
<a name="l00495"></a>00495 <span class="comment">         represents, as value_as_long would.  GDB should evaluate</span>
<a name="l00496"></a>00496 <span class="comment">         expressions just as the compiler would --- and the compiler</span>
<a name="l00497"></a>00497 <span class="comment">         sees a cast as a simple reinterpretation of the pointer&#39;s</span>
<a name="l00498"></a>00498 <span class="comment">         bits.  */</span>
<a name="l00499"></a>00499       <span class="keywordflow">if</span> (code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l00500"></a>00500         longest = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a>
<a name="l00501"></a>00501                     (<a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (arg2), <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type2),
<a name="l00502"></a>00502                      <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (<a class="code" href="gdbtypes_8c.html#a84ca61a6d58c2bd2c7dcedf19d56a39d">get_type_arch</a> (type2)));
<a name="l00503"></a>00503       <span class="keywordflow">else</span>
<a name="l00504"></a>00504         longest = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg2);
<a name="l00505"></a>00505       <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, convert_to_boolean ?
<a name="l00506"></a>00506                                  (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) (longest ? 1 : 0) : longest);
<a name="l00507"></a>00507     }
<a name="l00508"></a>00508   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a> &amp;&amp; (code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>  
<a name="l00509"></a>00509                                       || code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a> 
<a name="l00510"></a>00510                                       || code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>))
<a name="l00511"></a>00511     {
<a name="l00512"></a>00512       <span class="comment">/* TYPE_LENGTH (type) is the length of a pointer, but we really</span>
<a name="l00513"></a>00513 <span class="comment">         want the length of an address! -- we are really dealing with</span>
<a name="l00514"></a>00514 <span class="comment">         addresses (i.e., gdb representations) not pointers (i.e.,</span>
<a name="l00515"></a>00515 <span class="comment">         target representations) here.</span>
<a name="l00516"></a>00516 <span class="comment"></span>
<a name="l00517"></a>00517 <span class="comment">         This allows things like &quot;print *(int *)0x01000234&quot; to work</span>
<a name="l00518"></a>00518 <span class="comment">         without printing a misleading message -- which would</span>
<a name="l00519"></a>00519 <span class="comment">         otherwise occur when dealing with a target having two byte</span>
<a name="l00520"></a>00520 <span class="comment">         pointers and four byte addresses.  */</span>
<a name="l00521"></a>00521 
<a name="l00522"></a>00522       <span class="keywordtype">int</span> addr_bit = <a class="code" href="gdbarch_8c.html#a3ee335ac98782b6633ab7fc235182cc9">gdbarch_addr_bit</a> (<a class="code" href="gdbtypes_8c.html#a84ca61a6d58c2bd2c7dcedf19d56a39d">get_type_arch</a> (type2));
<a name="l00523"></a>00523       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> longest = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg2);
<a name="l00524"></a>00524 
<a name="l00525"></a>00525       <span class="keywordflow">if</span> (addr_bit &lt; <span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) * <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>)
<a name="l00526"></a>00526         {
<a name="l00527"></a>00527           <span class="keywordflow">if</span> (longest &gt;= ((<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) 1 &lt;&lt; addr_bit)
<a name="l00528"></a>00528               || longest &lt;= -((<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) 1 &lt;&lt; addr_bit))
<a name="l00529"></a>00529             <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;value truncated&quot;</span>));
<a name="l00530"></a>00530         }
<a name="l00531"></a>00531       <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, longest);
<a name="l00532"></a>00532     }
<a name="l00533"></a>00533   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462adec2c2388675220f922bae85d149f170">TYPE_CODE_METHODPTR</a> &amp;&amp; code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>
<a name="l00534"></a>00534            &amp;&amp; <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg2) == 0)
<a name="l00535"></a>00535     {
<a name="l00536"></a>00536       <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *result = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (type);
<a name="l00537"></a>00537 
<a name="l00538"></a>00538       <a class="code" href="cp-abi_8c.html#aa998e448123c366dc7731a862fc94786">cplus_make_method_ptr</a> (type, <a class="code" href="value_8c.html#a13d7c6c06f661cae284e575c50647344">value_contents_writeable</a> (result), 0, 0);
<a name="l00539"></a>00539       <span class="keywordflow">return</span> result;
<a name="l00540"></a>00540     }
<a name="l00541"></a>00541   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a0311d6e6980a50c23e68350f1b8fb5ae">TYPE_CODE_MEMBERPTR</a> &amp;&amp; code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>
<a name="l00542"></a>00542            &amp;&amp; <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg2) == 0)
<a name="l00543"></a>00543     {
<a name="l00544"></a>00544       <span class="comment">/* The Itanium C++ ABI represents NULL pointers to members as</span>
<a name="l00545"></a>00545 <span class="comment">         minus one, instead of biasing the normal case.  */</span>
<a name="l00546"></a>00546       <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, -1);
<a name="l00547"></a>00547     }
<a name="l00548"></a>00548   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a> &amp;&amp; <a class="code" href="gdbtypes_8h.html#a68a23253bcb233221400208f4c21c406">TYPE_VECTOR</a> (type)
<a name="l00549"></a>00549            &amp;&amp; code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a> &amp;&amp; <a class="code" href="gdbtypes_8h.html#a68a23253bcb233221400208f4c21c406">TYPE_VECTOR</a> (type2)
<a name="l00550"></a>00550            &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) != <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type2))
<a name="l00551"></a>00551     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot convert between vector values of different sizes&quot;</span>));
<a name="l00552"></a>00552   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a> &amp;&amp; <a class="code" href="gdbtypes_8h.html#a68a23253bcb233221400208f4c21c406">TYPE_VECTOR</a> (type) &amp;&amp; scalar
<a name="l00553"></a>00553            &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) != <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type2))
<a name="l00554"></a>00554     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;can only cast scalar to vector of same size&quot;</span>));
<a name="l00555"></a>00555   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>)
<a name="l00556"></a>00556     {
<a name="l00557"></a>00557       <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (type, <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l00558"></a>00558     }
<a name="l00559"></a>00559   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) == <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type2))
<a name="l00560"></a>00560     {
<a name="l00561"></a>00561       <span class="keywordflow">if</span> (code1 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a> &amp;&amp; code2 == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l00562"></a>00562         <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a05b825cece89f641f79b46a16afb9425">value_cast_pointers</a> (type, arg2, 0);
<a name="l00563"></a>00563 
<a name="l00564"></a>00564       arg2 = <a class="code" href="value_8c.html#abe2b4f6342cfefdbb63666b6bcba636b">value_copy</a> (arg2);
<a name="l00565"></a>00565       <a class="code" href="value_8c.html#adac1b2d5054e2d7b44ea25ac1f8002f1">deprecated_set_value_type</a> (arg2, type);
<a name="l00566"></a>00566       <a class="code" href="value_8c.html#ac90fd2d225f145f10b5f4d515027d7d2">set_value_enclosing_type</a> (arg2, type);
<a name="l00567"></a>00567       <a class="code" href="value_8c.html#ae68cafe981874da3e148c261f24bbb04">set_value_pointed_to_offset</a> (arg2, 0);    <span class="comment">/* pai: chk_val */</span>
<a name="l00568"></a>00568       <span class="keywordflow">return</span> arg2;
<a name="l00569"></a>00569     }
<a name="l00570"></a>00570   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (arg2) == <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>)
<a name="l00571"></a>00571     <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (type, <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (arg2));
<a name="l00572"></a>00572   <span class="keywordflow">else</span>
<a name="l00573"></a>00573     {
<a name="l00574"></a>00574       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Invalid cast.&quot;</span>));
<a name="l00575"></a>00575       <span class="keywordflow">return</span> 0;
<a name="l00576"></a>00576     }
<a name="l00577"></a>00577 }
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 <span class="comment">/* The C++ reinterpret_cast operator.  */</span>
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l00582"></a><a class="code" href="value_8h.html#aaaa87ee1b22a8ae39a083fb4d03d34ea">00582</a> <a class="code" href="valops_8c.html#aaaa87ee1b22a8ae39a083fb4d03d34ea">value_reinterpret_cast</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *arg)
<a name="l00583"></a>00583 {
<a name="l00584"></a>00584   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *result;
<a name="l00585"></a>00585   <span class="keyword">struct </span>type *real_type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (type);
<a name="l00586"></a>00586   <span class="keyword">struct </span>type *arg_type, *dest_type;
<a name="l00587"></a>00587   <span class="keywordtype">int</span> is_ref = 0;
<a name="l00588"></a>00588   <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> dest_code, arg_code;
<a name="l00589"></a>00589 
<a name="l00590"></a>00590   <span class="comment">/* Do reference, function, and array conversion.  */</span>
<a name="l00591"></a>00591   arg = <a class="code" href="value_8c.html#a773e1b64380b836763411d405aa758f1">coerce_array</a> (arg);
<a name="l00592"></a>00592 
<a name="l00593"></a>00593   <span class="comment">/* Attempt to preserve the type the user asked for.  */</span>
<a name="l00594"></a>00594   dest_type = <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l00595"></a>00595 
<a name="l00596"></a>00596   <span class="comment">/* If we are casting to a reference type, transform</span>
<a name="l00597"></a>00597 <span class="comment">     reinterpret_cast&lt;T&amp;&gt;(V) to *reinterpret_cast&lt;T*&gt;(&amp;V).  */</span>
<a name="l00598"></a>00598   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (real_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l00599"></a>00599     {
<a name="l00600"></a>00600       is_ref = 1;
<a name="l00601"></a>00601       arg = <a class="code" href="valops_8c.html#a29bc320305726a3cbf324189df2ca772">value_addr</a> (arg);
<a name="l00602"></a>00602       dest_type = <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (dest_type));
<a name="l00603"></a>00603       real_type = <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (real_type);
<a name="l00604"></a>00604     }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606   arg_type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg);
<a name="l00607"></a>00607 
<a name="l00608"></a>00608   dest_code = <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (real_type);
<a name="l00609"></a>00609   arg_code = <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (arg_type);
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   <span class="comment">/* We can convert pointer types, or any pointer type to int, or int</span>
<a name="l00612"></a>00612 <span class="comment">     type to pointer.  */</span>
<a name="l00613"></a>00613   <span class="keywordflow">if</span> ((dest_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a> &amp;&amp; arg_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>)
<a name="l00614"></a>00614       || (dest_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a> &amp;&amp; arg_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l00615"></a>00615       || (dest_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462adec2c2388675220f922bae85d149f170">TYPE_CODE_METHODPTR</a> &amp;&amp; arg_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>)
<a name="l00616"></a>00616       || (dest_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a> &amp;&amp; arg_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462adec2c2388675220f922bae85d149f170">TYPE_CODE_METHODPTR</a>)
<a name="l00617"></a>00617       || (dest_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a0311d6e6980a50c23e68350f1b8fb5ae">TYPE_CODE_MEMBERPTR</a> &amp;&amp; arg_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>)
<a name="l00618"></a>00618       || (dest_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a> &amp;&amp; arg_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a0311d6e6980a50c23e68350f1b8fb5ae">TYPE_CODE_MEMBERPTR</a>)
<a name="l00619"></a>00619       || (dest_code == arg_code
<a name="l00620"></a>00620           &amp;&amp; (dest_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l00621"></a>00621               || dest_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462adec2c2388675220f922bae85d149f170">TYPE_CODE_METHODPTR</a>
<a name="l00622"></a>00622               || dest_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a0311d6e6980a50c23e68350f1b8fb5ae">TYPE_CODE_MEMBERPTR</a>)))
<a name="l00623"></a>00623     result = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (dest_type, arg);
<a name="l00624"></a>00624   <span class="keywordflow">else</span>
<a name="l00625"></a>00625     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Invalid reinterpret_cast&quot;</span>));
<a name="l00626"></a>00626 
<a name="l00627"></a>00627   <span class="keywordflow">if</span> (is_ref)
<a name="l00628"></a>00628     result = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (type, <a class="code" href="valops_8c.html#ab73ccebbfb87a9332020dcf03976b053">value_ref</a> (<a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (result)));
<a name="l00629"></a>00629 
<a name="l00630"></a>00630   <span class="keywordflow">return</span> result;
<a name="l00631"></a>00631 }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633 <span class="comment">/* A helper for value_dynamic_cast.  This implements the first of two</span>
<a name="l00634"></a>00634 <span class="comment">   runtime checks: we iterate over all the base classes of the value&#39;s</span>
<a name="l00635"></a>00635 <span class="comment">   class which are equal to the desired class; if only one of these</span>
<a name="l00636"></a>00636 <span class="comment">   holds the value, then it is the answer.  */</span>
<a name="l00637"></a>00637 
<a name="l00638"></a>00638 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00639"></a><a class="code" href="valops_8c.html#a1cb680825638fbe4b1b71a60a5024ab4">00639</a> <a class="code" href="valops_8c.html#a1cb680825638fbe4b1b71a60a5024ab4">dynamic_cast_check_1</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *desired_type,
<a name="l00640"></a>00640                       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valaddr,
<a name="l00641"></a>00641                       <span class="keywordtype">int</span> embedded_offset,
<a name="l00642"></a>00642                       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address,
<a name="l00643"></a>00643                       <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *val,
<a name="l00644"></a>00644                       <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *search_type,
<a name="l00645"></a>00645                       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> arg_addr,
<a name="l00646"></a>00646                       <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *arg_type,
<a name="l00647"></a>00647                       <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **result)
<a name="l00648"></a>00648 {
<a name="l00649"></a>00649   <span class="keywordtype">int</span> i, result_count = 0;
<a name="l00650"></a>00650 
<a name="l00651"></a>00651   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (search_type) &amp;&amp; result_count &lt; 2; ++i)
<a name="l00652"></a>00652     {
<a name="l00653"></a>00653       <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a> = <a class="code" href="cp-abi_8c.html#a7da6ba80818bbcc6461cdb87197ddfad">baseclass_offset</a> (search_type, i, valaddr, embedded_offset,
<a name="l00654"></a>00654                                      address, val);
<a name="l00655"></a>00655 
<a name="l00656"></a>00656       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#ad4e64ffdca6d0e40e350c4b5a72d0712">class_types_same_p</a> (desired_type, <a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">TYPE_BASECLASS</a> (search_type, i)))
<a name="l00657"></a>00657         {
<a name="l00658"></a>00658           <span class="keywordflow">if</span> (address + embedded_offset + offset &gt;= arg_addr
<a name="l00659"></a>00659               &amp;&amp; address + embedded_offset + offset &lt; arg_addr + <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (arg_type))
<a name="l00660"></a>00660             {
<a name="l00661"></a>00661               ++result_count;
<a name="l00662"></a>00662               <span class="keywordflow">if</span> (!*result)
<a name="l00663"></a>00663                 *result = <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (<a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">TYPE_BASECLASS</a> (search_type, i),
<a name="l00664"></a>00664                                          address + embedded_offset + offset);
<a name="l00665"></a>00665             }
<a name="l00666"></a>00666         }
<a name="l00667"></a>00667       <span class="keywordflow">else</span>
<a name="l00668"></a>00668         result_count += <a class="code" href="valops_8c.html#a1cb680825638fbe4b1b71a60a5024ab4">dynamic_cast_check_1</a> (desired_type,
<a name="l00669"></a>00669                                               valaddr,
<a name="l00670"></a>00670                                               embedded_offset + offset,
<a name="l00671"></a>00671                                               address, val,
<a name="l00672"></a>00672                                               <a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">TYPE_BASECLASS</a> (search_type, i),
<a name="l00673"></a>00673                                               arg_addr,
<a name="l00674"></a>00674                                               arg_type,
<a name="l00675"></a>00675                                               result);
<a name="l00676"></a>00676     }
<a name="l00677"></a>00677 
<a name="l00678"></a>00678   <span class="keywordflow">return</span> result_count;
<a name="l00679"></a>00679 }
<a name="l00680"></a>00680 
<a name="l00681"></a>00681 <span class="comment">/* A helper for value_dynamic_cast.  This implements the second of two</span>
<a name="l00682"></a>00682 <span class="comment">   runtime checks: we look for a unique public sibling class of the</span>
<a name="l00683"></a>00683 <span class="comment">   argument&#39;s declared class.  */</span>
<a name="l00684"></a>00684 
<a name="l00685"></a>00685 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00686"></a><a class="code" href="valops_8c.html#a04d987dfe17294087b985a49fabfb681">00686</a> <a class="code" href="valops_8c.html#a04d987dfe17294087b985a49fabfb681">dynamic_cast_check_2</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *desired_type,
<a name="l00687"></a>00687                       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valaddr,
<a name="l00688"></a>00688                       <span class="keywordtype">int</span> embedded_offset,
<a name="l00689"></a>00689                       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address,
<a name="l00690"></a>00690                       <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *val,
<a name="l00691"></a>00691                       <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *search_type,
<a name="l00692"></a>00692                       <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **result)
<a name="l00693"></a>00693 {
<a name="l00694"></a>00694   <span class="keywordtype">int</span> i, result_count = 0;
<a name="l00695"></a>00695 
<a name="l00696"></a>00696   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (search_type) &amp;&amp; result_count &lt; 2; ++i)
<a name="l00697"></a>00697     {
<a name="l00698"></a>00698       <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l00699"></a>00699 
<a name="l00700"></a>00700       <span class="keywordflow">if</span> (! <a class="code" href="gdbtypes_8h.html#adb19c8aef61bc4ce36cf98f6d40afa55">BASETYPE_VIA_PUBLIC</a> (search_type, i))
<a name="l00701"></a>00701         <span class="keywordflow">continue</span>;
<a name="l00702"></a>00702 
<a name="l00703"></a>00703       offset = <a class="code" href="cp-abi_8c.html#a7da6ba80818bbcc6461cdb87197ddfad">baseclass_offset</a> (search_type, i, valaddr, embedded_offset,
<a name="l00704"></a>00704                                  address, val);
<a name="l00705"></a>00705       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#ad4e64ffdca6d0e40e350c4b5a72d0712">class_types_same_p</a> (desired_type, <a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">TYPE_BASECLASS</a> (search_type, i)))
<a name="l00706"></a>00706         {
<a name="l00707"></a>00707           ++result_count;
<a name="l00708"></a>00708           <span class="keywordflow">if</span> (*result == NULL)
<a name="l00709"></a>00709             *result = <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (<a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">TYPE_BASECLASS</a> (search_type, i),
<a name="l00710"></a>00710                                      address + embedded_offset + offset);
<a name="l00711"></a>00711         }
<a name="l00712"></a>00712       <span class="keywordflow">else</span>
<a name="l00713"></a>00713         result_count += <a class="code" href="valops_8c.html#a04d987dfe17294087b985a49fabfb681">dynamic_cast_check_2</a> (desired_type,
<a name="l00714"></a>00714                                               valaddr,
<a name="l00715"></a>00715                                               embedded_offset + offset,
<a name="l00716"></a>00716                                               address, val,
<a name="l00717"></a>00717                                               <a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">TYPE_BASECLASS</a> (search_type, i),
<a name="l00718"></a>00718                                               result);
<a name="l00719"></a>00719     }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721   <span class="keywordflow">return</span> result_count;
<a name="l00722"></a>00722 }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 <span class="comment">/* The C++ dynamic_cast operator.  */</span>
<a name="l00725"></a>00725 
<a name="l00726"></a>00726 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l00727"></a><a class="code" href="value_8h.html#a324c6f21198643bdde2c9cda3a319e85">00727</a> <a class="code" href="valops_8c.html#a324c6f21198643bdde2c9cda3a319e85">value_dynamic_cast</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *arg)
<a name="l00728"></a>00728 {
<a name="l00729"></a>00729   <span class="keywordtype">int</span> full, top, using_enc;
<a name="l00730"></a>00730   <span class="keyword">struct </span>type *resolved_type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (type);
<a name="l00731"></a>00731   <span class="keyword">struct </span>type *arg_type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg));
<a name="l00732"></a>00732   <span class="keyword">struct </span>type *class_type, *rtti_type;
<a name="l00733"></a>00733   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *result, *tem, *original_arg = arg;
<a name="l00734"></a>00734   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr;
<a name="l00735"></a>00735   <span class="keywordtype">int</span> is_ref = <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (resolved_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>;
<a name="l00736"></a>00736 
<a name="l00737"></a>00737   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (resolved_type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l00738"></a>00738       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (resolved_type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l00739"></a>00739     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Argument to dynamic_cast must be a pointer or reference type&quot;</span>));
<a name="l00740"></a>00740   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (resolved_type)) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>
<a name="l00741"></a>00741       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (resolved_type)) != <a class="code" href="gdbtypes_8h.html#a9f70b67b4d14548a879667f544eab4ef">TYPE_CODE_CLASS</a>)
<a name="l00742"></a>00742     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Argument to dynamic_cast must be pointer to class or `void *&#39;&quot;</span>));
<a name="l00743"></a>00743 
<a name="l00744"></a>00744   class_type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (resolved_type));
<a name="l00745"></a>00745   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (resolved_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l00746"></a>00746     {
<a name="l00747"></a>00747       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (arg_type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l00748"></a>00748           &amp;&amp; ! (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (arg_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>
<a name="l00749"></a>00749                 &amp;&amp; <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg) == 0))
<a name="l00750"></a>00750         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Argument to dynamic_cast does not have pointer type&quot;</span>));
<a name="l00751"></a>00751       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (arg_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l00752"></a>00752         {
<a name="l00753"></a>00753           arg_type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (arg_type));
<a name="l00754"></a>00754           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (arg_type) != <a class="code" href="gdbtypes_8h.html#a9f70b67b4d14548a879667f544eab4ef">TYPE_CODE_CLASS</a>)
<a name="l00755"></a>00755             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Argument to dynamic_cast does &quot;</span>
<a name="l00756"></a>00756                      <span class="stringliteral">&quot;not have pointer to class type&quot;</span>));
<a name="l00757"></a>00757         }
<a name="l00758"></a>00758 
<a name="l00759"></a>00759       <span class="comment">/* Handle NULL pointers.  */</span>
<a name="l00760"></a>00760       <span class="keywordflow">if</span> (<a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg) == 0)
<a name="l00761"></a>00761         <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (type, <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l00762"></a>00762 
<a name="l00763"></a>00763       arg = <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (arg);
<a name="l00764"></a>00764     }
<a name="l00765"></a>00765   <span class="keywordflow">else</span>
<a name="l00766"></a>00766     {
<a name="l00767"></a>00767       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (arg_type) != <a class="code" href="gdbtypes_8h.html#a9f70b67b4d14548a879667f544eab4ef">TYPE_CODE_CLASS</a>)
<a name="l00768"></a>00768         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Argument to dynamic_cast does not have class type&quot;</span>));
<a name="l00769"></a>00769     }
<a name="l00770"></a>00770 
<a name="l00771"></a>00771   <span class="comment">/* If the classes are the same, just return the argument.  */</span>
<a name="l00772"></a>00772   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#ad4e64ffdca6d0e40e350c4b5a72d0712">class_types_same_p</a> (class_type, arg_type))
<a name="l00773"></a>00773     <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (type, arg);
<a name="l00774"></a>00774 
<a name="l00775"></a>00775   <span class="comment">/* If the target type is a unique base class of the argument&#39;s</span>
<a name="l00776"></a>00776 <span class="comment">     declared type, just cast it.  */</span>
<a name="l00777"></a>00777   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#aa76bf4be3e0efb00a674a991d5ef95f2">is_ancestor</a> (class_type, arg_type))
<a name="l00778"></a>00778     {
<a name="l00779"></a>00779       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#a970bab06a136d8205e71ee88629b639e">is_unique_ancestor</a> (class_type, arg))
<a name="l00780"></a>00780         <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (type, original_arg);
<a name="l00781"></a>00781       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Ambiguous dynamic_cast&quot;</span>));
<a name="l00782"></a>00782     }
<a name="l00783"></a>00783 
<a name="l00784"></a>00784   rtti_type = <a class="code" href="cp-abi_8c.html#a2e4a56716a4c26e96f1ce00c93f83c04">value_rtti_type</a> (arg, &amp;full, &amp;top, &amp;using_enc);
<a name="l00785"></a>00785   <span class="keywordflow">if</span> (! rtti_type)
<a name="l00786"></a>00786     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Couldn&#39;t determine value&#39;s most derived type for dynamic_cast&quot;</span>));
<a name="l00787"></a>00787 
<a name="l00788"></a>00788   <span class="comment">/* Compute the most derived object&#39;s address.  */</span>
<a name="l00789"></a>00789   addr = <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (arg);
<a name="l00790"></a>00790   <span class="keywordflow">if</span> (full)
<a name="l00791"></a>00791     {
<a name="l00792"></a>00792       <span class="comment">/* Done.  */</span>
<a name="l00793"></a>00793     }
<a name="l00794"></a>00794   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (using_enc)
<a name="l00795"></a>00795     addr += top;
<a name="l00796"></a>00796   <span class="keywordflow">else</span>
<a name="l00797"></a>00797     addr += top + <a class="code" href="value_8c.html#acbd6146ab9bd4c54f994a895a66f3f3d">value_embedded_offset</a> (arg);
<a name="l00798"></a>00798 
<a name="l00799"></a>00799   <span class="comment">/* dynamic_cast&lt;void *&gt; means to return a pointer to the</span>
<a name="l00800"></a>00800 <span class="comment">     most-derived object.  */</span>
<a name="l00801"></a>00801   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (resolved_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l00802"></a>00802       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (resolved_type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>)
<a name="l00803"></a>00803     <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (type, addr);
<a name="l00804"></a>00804 
<a name="l00805"></a>00805   tem = <a class="code" href="valops_8c.html#aed5411e37c248ed2abd959ddae4e9d34">value_at</a> (type, addr);
<a name="l00806"></a>00806 
<a name="l00807"></a>00807   <span class="comment">/* The first dynamic check specified in 5.2.7.  */</span>
<a name="l00808"></a>00808   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#aabe098d2282927629df79faa6acd8b5f">is_public_ancestor</a> (arg_type, <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (resolved_type)))
<a name="l00809"></a>00809     {
<a name="l00810"></a>00810       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#ad4e64ffdca6d0e40e350c4b5a72d0712">class_types_same_p</a> (rtti_type, <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (resolved_type)))
<a name="l00811"></a>00811         <span class="keywordflow">return</span> tem;
<a name="l00812"></a>00812       result = NULL;
<a name="l00813"></a>00813       <span class="keywordflow">if</span> (<a class="code" href="valops_8c.html#a1cb680825638fbe4b1b71a60a5024ab4">dynamic_cast_check_1</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (resolved_type),
<a name="l00814"></a>00814                                 <a class="code" href="value_8c.html#a77fb759fae03d1a1c2a4e1500aa13adb">value_contents_for_printing</a> (tem),
<a name="l00815"></a>00815                                 value_embedded_offset (tem),
<a name="l00816"></a>00816                                 <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (tem), tem,
<a name="l00817"></a>00817                                 rtti_type, addr,
<a name="l00818"></a>00818                                 arg_type,
<a name="l00819"></a>00819                                 &amp;result) == 1)
<a name="l00820"></a>00820         <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (type,
<a name="l00821"></a>00821                            is_ref ? <a class="code" href="valops_8c.html#ab73ccebbfb87a9332020dcf03976b053">value_ref</a> (result) : <a class="code" href="valops_8c.html#a29bc320305726a3cbf324189df2ca772">value_addr</a> (result));
<a name="l00822"></a>00822     }
<a name="l00823"></a>00823 
<a name="l00824"></a>00824   <span class="comment">/* The second dynamic check specified in 5.2.7.  */</span>
<a name="l00825"></a>00825   result = NULL;
<a name="l00826"></a>00826   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#aabe098d2282927629df79faa6acd8b5f">is_public_ancestor</a> (arg_type, rtti_type)
<a name="l00827"></a>00827       &amp;&amp; <a class="code" href="valops_8c.html#a04d987dfe17294087b985a49fabfb681">dynamic_cast_check_2</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (resolved_type),
<a name="l00828"></a>00828                                <a class="code" href="value_8c.html#a77fb759fae03d1a1c2a4e1500aa13adb">value_contents_for_printing</a> (tem),
<a name="l00829"></a>00829                                value_embedded_offset (tem),
<a name="l00830"></a>00830                                <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (tem), tem,
<a name="l00831"></a>00831                                rtti_type, &amp;result) == 1)
<a name="l00832"></a>00832     <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (type,
<a name="l00833"></a>00833                        is_ref ? <a class="code" href="valops_8c.html#ab73ccebbfb87a9332020dcf03976b053">value_ref</a> (result) : <a class="code" href="valops_8c.html#a29bc320305726a3cbf324189df2ca772">value_addr</a> (result));
<a name="l00834"></a>00834 
<a name="l00835"></a>00835   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (resolved_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l00836"></a>00836     <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (type, <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l00837"></a>00837 
<a name="l00838"></a>00838   <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;dynamic_cast failed&quot;</span>));
<a name="l00839"></a>00839 }
<a name="l00840"></a>00840 
<a name="l00841"></a>00841 <span class="comment">/* Create a value of type TYPE that is zero, and return it.  */</span>
<a name="l00842"></a>00842 
<a name="l00843"></a>00843 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l00844"></a><a class="code" href="value_8h.html#a97f02862d1fe8dc4cac71d0585f40870">00844</a> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098ab">lval_type</a> lv)
<a name="l00845"></a>00845 {
<a name="l00846"></a>00846   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *val = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (type);
<a name="l00847"></a>00847 
<a name="l00848"></a>00848   <a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (val) = (lv == <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba61712ce609a0e4f03514da2c992b6fc5">lval_computed</a> ? <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a> : lv);
<a name="l00849"></a>00849   <span class="keywordflow">return</span> val;
<a name="l00850"></a>00850 }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852 <span class="comment">/* Create a not_lval value of numeric type TYPE that is one, and return it.  */</span>
<a name="l00853"></a>00853 
<a name="l00854"></a>00854 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l00855"></a><a class="code" href="value_8h.html#ae66d8992f82bcbe654da36a52d78fd5e">00855</a> <a class="code" href="valops_8c.html#ae66d8992f82bcbe654da36a52d78fd5e">value_one</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>)
<a name="l00856"></a>00856 {
<a name="l00857"></a>00857   <span class="keyword">struct </span>type *type1 = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (type);
<a name="l00858"></a>00858   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *val;
<a name="l00859"></a>00859 
<a name="l00860"></a>00860   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type1) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ace4e1a5aff0ea601f04c6f25eb8ed47b">TYPE_CODE_DECFLOAT</a>)
<a name="l00861"></a>00861     {
<a name="l00862"></a>00862       <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (<a class="code" href="gdbtypes_8c.html#a84ca61a6d58c2bd2c7dcedf19d56a39d">get_type_arch</a> (type));
<a name="l00863"></a>00863       <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> v[16];
<a name="l00864"></a>00864 
<a name="l00865"></a>00865       <a class="code" href="dfp_8c.html#a6b7196395d7d3386e8e98c707bfcfebf">decimal_from_string</a> (v, <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type), byte_order, <span class="stringliteral">&quot;1&quot;</span>);
<a name="l00866"></a>00866       val = <a class="code" href="value_8c.html#ab8645cba250bddc4b62ee9aa9629d755">value_from_decfloat</a> (type, v);
<a name="l00867"></a>00867     }
<a name="l00868"></a>00868   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type1) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>)
<a name="l00869"></a>00869     {
<a name="l00870"></a>00870       val = <a class="code" href="value_8c.html#ac2cf5b8fa401dbfc4c1fb505b002c0bf">value_from_double</a> (type, (<a class="code" href="doublest_8h.html#ac1812677a2f11158956252854ec47a77">DOUBLEST</a>) 1);
<a name="l00871"></a>00871     }
<a name="l00872"></a>00872   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#a292da1df1ddf044d92c8958d304aac2d">is_integral_type</a> (type1))
<a name="l00873"></a>00873     {
<a name="l00874"></a>00874       val = <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) 1);
<a name="l00875"></a>00875     }
<a name="l00876"></a>00876   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type1) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a> &amp;&amp; <a class="code" href="gdbtypes_8h.html#a68a23253bcb233221400208f4c21c406">TYPE_VECTOR</a> (type1))
<a name="l00877"></a>00877     {
<a name="l00878"></a>00878       <span class="keyword">struct </span>type *eltype = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type1));
<a name="l00879"></a>00879       <span class="keywordtype">int</span> i;
<a name="l00880"></a>00880       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> low_bound, high_bound;
<a name="l00881"></a>00881       <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *tmp;
<a name="l00882"></a>00882 
<a name="l00883"></a>00883       <span class="keywordflow">if</span> (!<a class="code" href="gdbtypes_8c.html#a499d94cb3d0212c4f898aa51f264da65">get_array_bounds</a> (type1, &amp;low_bound, &amp;high_bound))
<a name="l00884"></a>00884         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Could not determine the vector bounds&quot;</span>));
<a name="l00885"></a>00885 
<a name="l00886"></a>00886       val = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (type);
<a name="l00887"></a>00887       <span class="keywordflow">for</span> (i = 0; i &lt; high_bound - low_bound + 1; i++)
<a name="l00888"></a>00888         {
<a name="l00889"></a>00889           tmp = <a class="code" href="valops_8c.html#ae66d8992f82bcbe654da36a52d78fd5e">value_one</a> (eltype);
<a name="l00890"></a>00890           <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="value_8c.html#a13d7c6c06f661cae284e575c50647344">value_contents_writeable</a> (val) + i * <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (eltype),
<a name="l00891"></a>00891                   <a class="code" href="value_8c.html#a169102027b7f913a4d387d01d62dbeae">value_contents_all</a> (tmp), <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (eltype));
<a name="l00892"></a>00892         }
<a name="l00893"></a>00893     }
<a name="l00894"></a>00894   <span class="keywordflow">else</span>
<a name="l00895"></a>00895     {
<a name="l00896"></a>00896       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Not a numeric type.&quot;</span>));
<a name="l00897"></a>00897     }
<a name="l00898"></a>00898 
<a name="l00899"></a>00899   <span class="comment">/* value_one result is never used for assignments to.  */</span>
<a name="l00900"></a>00900   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (val) == <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l00901"></a>00901 
<a name="l00902"></a>00902   <span class="keywordflow">return</span> val;
<a name="l00903"></a>00903 }
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 <span class="comment">/* Helper function for value_at, value_at_lazy, and value_at_lazy_stack.  */</span>
<a name="l00906"></a>00906 
<a name="l00907"></a>00907 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l00908"></a><a class="code" href="valops_8c.html#aabe00db6ba403e2937c3150052fc42ed">00908</a> <a class="code" href="valops_8c.html#aabe00db6ba403e2937c3150052fc42ed">get_value_at</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr, <span class="keywordtype">int</span> <a class="code" href="structvalue.html#a3993fbd5f722d9f4d9a4c7c2ad9d5530">lazy</a>)
<a name="l00909"></a>00909 {
<a name="l00910"></a>00910   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *val;
<a name="l00911"></a>00911 
<a name="l00912"></a>00912   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>)
<a name="l00913"></a>00913     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attempt to dereference a generic pointer.&quot;</span>));
<a name="l00914"></a>00914 
<a name="l00915"></a>00915   val = <a class="code" href="value_8c.html#ab189fd2d8ea1fe71f000581289a20e17">value_from_contents_and_address</a> (type, NULL, addr);
<a name="l00916"></a>00916 
<a name="l00917"></a>00917   <span class="keywordflow">if</span> (!lazy)
<a name="l00918"></a>00918     <a class="code" href="value_8c.html#a27ee2d69678b458a82ac350e2e2132d8">value_fetch_lazy</a> (val);
<a name="l00919"></a>00919 
<a name="l00920"></a>00920   <span class="keywordflow">return</span> val;
<a name="l00921"></a>00921 }
<a name="l00922"></a>00922 
<a name="l00923"></a>00923 <span class="comment">/* Return a value with type TYPE located at ADDR.</span>
<a name="l00924"></a>00924 <span class="comment"></span>
<a name="l00925"></a>00925 <span class="comment">   Call value_at only if the data needs to be fetched immediately;</span>
<a name="l00926"></a>00926 <span class="comment">   if we can be &#39;lazy&#39; and defer the fetch, perhaps indefinately, call</span>
<a name="l00927"></a>00927 <span class="comment">   value_at_lazy instead.  value_at_lazy simply records the address of</span>
<a name="l00928"></a>00928 <span class="comment">   the data and sets the lazy-evaluation-required flag.  The lazy flag</span>
<a name="l00929"></a>00929 <span class="comment">   is tested in the value_contents macro, which is used if and when</span>
<a name="l00930"></a>00930 <span class="comment">   the contents are actually required.</span>
<a name="l00931"></a>00931 <span class="comment"></span>
<a name="l00932"></a>00932 <span class="comment">   Note: value_at does *NOT* handle embedded offsets; perform such</span>
<a name="l00933"></a>00933 <span class="comment">   adjustments before or after calling it.  */</span>
<a name="l00934"></a>00934 
<a name="l00935"></a>00935 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l00936"></a><a class="code" href="value_8h.html#aed5411e37c248ed2abd959ddae4e9d34">00936</a> <a class="code" href="valops_8c.html#aed5411e37c248ed2abd959ddae4e9d34">value_at</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr)
<a name="l00937"></a>00937 {
<a name="l00938"></a>00938   <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#aabe00db6ba403e2937c3150052fc42ed">get_value_at</a> (type, addr, 0);
<a name="l00939"></a>00939 }
<a name="l00940"></a>00940 
<a name="l00941"></a>00941 <span class="comment">/* Return a lazy value with type TYPE located at ADDR (cf. value_at).  */</span>
<a name="l00942"></a>00942 
<a name="l00943"></a>00943 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l00944"></a><a class="code" href="value_8h.html#ae8cdb6f0257c5b86c719c90621e184d6">00944</a> <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr)
<a name="l00945"></a>00945 {
<a name="l00946"></a>00946   <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#aabe00db6ba403e2937c3150052fc42ed">get_value_at</a> (type, addr, 1);
<a name="l00947"></a>00947 }
<a name="l00948"></a>00948 
<a name="l00949"></a>00949 <span class="keywordtype">void</span>
<a name="l00950"></a><a class="code" href="value_8h.html#a85fc3c2a6982cfbc5025418775d0042c">00950</a> <a class="code" href="valops_8c.html#a85fc3c2a6982cfbc5025418775d0042c">read_value_memory</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *val, <span class="keywordtype">int</span> <a class="code" href="structvalue.html#a7b3baf9115c5f56308b121ce285316c4">embedded_offset</a>,
<a name="l00951"></a>00951                    <span class="keywordtype">int</span> <a class="code" href="structvalue.html#a1d1b2de52c04f606f83de97afd5296c1">stack</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="exec_8h.html#ab268c3184bf49615e16de006a296a542">memaddr</a>,
<a name="l00952"></a>00952                    <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structbuffer.html">buffer</a>, <span class="keywordtype">size_t</span> length)
<a name="l00953"></a>00953 {
<a name="l00954"></a>00954   <span class="keywordflow">if</span> (length)
<a name="l00955"></a>00955     {
<a name="l00956"></a>00956       <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a>(<a class="code" href="structmem__range.html">mem_range_s</a>) *available_memory;
<a name="l00957"></a>00957 
<a name="l00958"></a>00958       <span class="keywordflow">if</span> (!<a class="code" href="tracepoint_8c.html#a7a4773385bc6ad9ca1704981f3186867">traceframe_available_memory</a> (&amp;available_memory, memaddr, length))
<a name="l00959"></a>00959         {
<a name="l00960"></a>00960           <span class="keywordflow">if</span> (stack)
<a name="l00961"></a>00961             <a class="code" href="corefile_8c.html#a16801c29f66e0deab74d6dd6535449e1">read_stack</a> (memaddr, buffer, length);
<a name="l00962"></a>00962           <span class="keywordflow">else</span>
<a name="l00963"></a>00963             <a class="code" href="corefile_8c.html#a5e0189c6f21f1c9321b379877183b819">read_memory</a> (memaddr, buffer, length);
<a name="l00964"></a>00964         }
<a name="l00965"></a>00965       <span class="keywordflow">else</span>
<a name="l00966"></a>00966         {
<a name="l00967"></a>00967           <span class="keyword">struct </span><a class="code" href="structtarget__section__table.html">target_section_table</a> *table;
<a name="l00968"></a>00968           <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_chain;
<a name="l00969"></a>00969           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> unavail;
<a name="l00970"></a>00970           <a class="code" href="structmem__range.html">mem_range_s</a> *r;
<a name="l00971"></a>00971           <span class="keywordtype">int</span> i;
<a name="l00972"></a>00972 
<a name="l00973"></a>00973           <span class="comment">/* Fallback to reading from read-only sections.  */</span>
<a name="l00974"></a>00974           table = <a class="code" href="target_8c.html#a24748d3564c354de182ba340a381e9e7">target_get_section_table</a> (&amp;<a class="code" href="exec_8c.html#ae3d760e0c1f0e91359de3eea7845b12d">exec_ops</a>);
<a name="l00975"></a>00975           available_memory =
<a name="l00976"></a>00976             section_table_available_memory (available_memory,
<a name="l00977"></a>00977                                             memaddr, length,
<a name="l00978"></a>00978                                             table-&gt;<a class="code" href="structtarget__section__table.html#a432fe15b9d6b7650e3a8a9ca9ed58322">sections</a>,
<a name="l00979"></a>00979                                             table-&gt;<a class="code" href="structtarget__section__table.html#a4240d8815c53d6b388b0440f03175043">sections_end</a>);
<a name="l00980"></a>00980 
<a name="l00981"></a>00981           old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="vec_8h.html#a92a6114eb727b9274e1523d0e9dd2e61">VEC_cleanup</a>(<a class="code" href="structmem__range.html">mem_range_s</a>),
<a name="l00982"></a>00982                                     &amp;available_memory);
<a name="l00983"></a>00983 
<a name="l00984"></a>00984           <a class="code" href="memrange_8c.html#aed28e0f23b22120dc9c43e54d7812366">normalize_mem_ranges</a> (available_memory);
<a name="l00985"></a>00985 
<a name="l00986"></a>00986           <span class="comment">/* Mark which bytes are unavailable, and read those which</span>
<a name="l00987"></a>00987 <span class="comment">             are available.  */</span>
<a name="l00988"></a>00988 
<a name="l00989"></a>00989           unavail = <a class="code" href="exec_8h.html#ab268c3184bf49615e16de006a296a542">memaddr</a>;
<a name="l00990"></a>00990 
<a name="l00991"></a>00991           <span class="keywordflow">for</span> (i = 0;
<a name="l00992"></a>00992                <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="structmem__range.html">mem_range_s</a>, available_memory, i, r);
<a name="l00993"></a>00993                i++)
<a name="l00994"></a>00994             {
<a name="l00995"></a>00995               <span class="keywordflow">if</span> (<a class="code" href="memrange_8c.html#a3d1f4c93febac91bd950ea20743947bf">mem_ranges_overlap</a> (r-&gt;<a class="code" href="structmem__range.html#af0c57d66bc3b5fc21cfba6dfb161f618">start</a>, r-&gt;<a class="code" href="structmem__range.html#a7dd2d185dbacbc0a099e55a2cffb0696">length</a>,
<a name="l00996"></a>00996                                       memaddr, length))
<a name="l00997"></a>00997                 {
<a name="l00998"></a>00998                   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> lo1, hi1, lo2, hi2;
<a name="l00999"></a>00999                   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start, end;
<a name="l01000"></a>01000 
<a name="l01001"></a>01001                   <span class="comment">/* Get the intersection window.  */</span>
<a name="l01002"></a>01002                   lo1 = <a class="code" href="exec_8h.html#ab268c3184bf49615e16de006a296a542">memaddr</a>;
<a name="l01003"></a>01003                   hi1 = memaddr + length;
<a name="l01004"></a>01004                   lo2 = r-&gt;<a class="code" href="structmem__range.html#af0c57d66bc3b5fc21cfba6dfb161f618">start</a>;
<a name="l01005"></a>01005                   hi2 = r-&gt;<a class="code" href="structmem__range.html#af0c57d66bc3b5fc21cfba6dfb161f618">start</a> + r-&gt;<a class="code" href="structmem__range.html#a7dd2d185dbacbc0a099e55a2cffb0696">length</a>;
<a name="l01006"></a>01006                   start = <a class="code" href="environ_8c.html#affe776513b24d84b39af8ab0930fef7f">max</a> (lo1, lo2);
<a name="l01007"></a>01007                   end = <a class="code" href="environ_8c.html#ac6afabdc09a49a433ee19d8a9486056d">min</a> (hi1, hi2);
<a name="l01008"></a>01008 
<a name="l01009"></a>01009                   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (end - memaddr &lt;= length);
<a name="l01010"></a>01010 
<a name="l01011"></a>01011                   <span class="keywordflow">if</span> (start &gt; unavail)
<a name="l01012"></a>01012                     <a class="code" href="value_8c.html#a9d526a0fb9ea7e59ebaf800b71adb4b3">mark_value_bytes_unavailable</a> (val,
<a name="l01013"></a>01013                                                   (embedded_offset
<a name="l01014"></a>01014                                                    + unavail - memaddr),
<a name="l01015"></a>01015                                                   start - unavail);
<a name="l01016"></a>01016                   unavail = end;
<a name="l01017"></a>01017 
<a name="l01018"></a>01018                   <a class="code" href="corefile_8c.html#a5e0189c6f21f1c9321b379877183b819">read_memory</a> (start, buffer + start - memaddr, end - start);
<a name="l01019"></a>01019                 }
<a name="l01020"></a>01020             }
<a name="l01021"></a>01021 
<a name="l01022"></a>01022           <span class="keywordflow">if</span> (unavail != memaddr + length)
<a name="l01023"></a>01023             <a class="code" href="value_8c.html#a9d526a0fb9ea7e59ebaf800b71adb4b3">mark_value_bytes_unavailable</a> (val,
<a name="l01024"></a>01024                                           embedded_offset + unavail - memaddr,
<a name="l01025"></a>01025                                           (memaddr + length) - unavail);
<a name="l01026"></a>01026 
<a name="l01027"></a>01027           <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l01028"></a>01028         }
<a name="l01029"></a>01029     }
<a name="l01030"></a>01030 }
<a name="l01031"></a>01031 
<a name="l01032"></a>01032 <span class="comment">/* Store the contents of FROMVAL into the location of TOVAL.</span>
<a name="l01033"></a>01033 <span class="comment">   Return a new value with the location of TOVAL and contents of FROMVAL.  */</span>
<a name="l01034"></a>01034 
<a name="l01035"></a>01035 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l01036"></a><a class="code" href="value_8h.html#a1357019ae48dabe7c46916ab0cf04ba2">01036</a> <a class="code" href="valops_8c.html#a1357019ae48dabe7c46916ab0cf04ba2">value_assign</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *toval, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *fromval)
<a name="l01037"></a>01037 {
<a name="l01038"></a>01038   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l01039"></a>01039   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *val;
<a name="l01040"></a>01040   <span class="keyword">struct </span><a class="code" href="structframe__id.html">frame_id</a> old_frame;
<a name="l01041"></a>01041 
<a name="l01042"></a>01042   <span class="keywordflow">if</span> (!<a class="code" href="value_8c.html#af38ad07ecbd1d8ae5a31ad793399d0ba">deprecated_value_modifiable</a> (toval))
<a name="l01043"></a>01043     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Left operand of assignment is not a modifiable lvalue.&quot;</span>));
<a name="l01044"></a>01044 
<a name="l01045"></a>01045   toval = <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (toval);
<a name="l01046"></a>01046 
<a name="l01047"></a>01047   type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (toval);
<a name="l01048"></a>01048   <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (toval) != <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba8dfa3647df3362b7c410ac31f6cde323">lval_internalvar</a>)
<a name="l01049"></a>01049     fromval = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (type, fromval);
<a name="l01050"></a>01050   <span class="keywordflow">else</span>
<a name="l01051"></a>01051     {
<a name="l01052"></a>01052       <span class="comment">/* Coerce arrays and functions to pointers, except for arrays</span>
<a name="l01053"></a>01053 <span class="comment">         which only live in GDB&#39;s storage.  */</span>
<a name="l01054"></a>01054       <span class="keywordflow">if</span> (!<a class="code" href="valops_8c.html#ae6aadea6423ef8af2a01193c0d2b0fa0">value_must_coerce_to_target</a> (fromval))
<a name="l01055"></a>01055         fromval = <a class="code" href="value_8c.html#a773e1b64380b836763411d405aa758f1">coerce_array</a> (fromval);
<a name="l01056"></a>01056     }
<a name="l01057"></a>01057 
<a name="l01058"></a>01058   <a class="code" href="gdbtypes_8h.html#ae2f9348c644babaa9038b4dc18bffaac">CHECK_TYPEDEF</a> (type);
<a name="l01059"></a>01059 
<a name="l01060"></a>01060   <span class="comment">/* Since modifying a register can trash the frame chain, and</span>
<a name="l01061"></a>01061 <span class="comment">     modifying memory can trash the frame cache, we save the old frame</span>
<a name="l01062"></a>01062 <span class="comment">     and then restore the new frame afterwards.  */</span>
<a name="l01063"></a>01063   old_frame = <a class="code" href="frame_8c.html#a4d69effe10c03fa7c702d490081012bf">get_frame_id</a> (<a class="code" href="frame_8c.html#aff8ce563cf529a6695bd2afc8b3d9833">deprecated_safe_get_selected_frame</a> ());
<a name="l01064"></a>01064 
<a name="l01065"></a>01065   <span class="keywordflow">switch</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (toval))
<a name="l01066"></a>01066     {
<a name="l01067"></a>01067     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba8dfa3647df3362b7c410ac31f6cde323">lval_internalvar</a>:
<a name="l01068"></a>01068       <a class="code" href="value_8c.html#a8e5fd3bd77e20876ececbe85d2c8b568">set_internalvar</a> (<a class="code" href="value_8h.html#aa0976bbc250fff8bdc40dfa0d245eb86">VALUE_INTERNALVAR</a> (toval), fromval);
<a name="l01069"></a>01069       <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a2cb406b1dc504c17f1d33bf6464fd716">value_of_internalvar</a> (<a class="code" href="gdbtypes_8c.html#a84ca61a6d58c2bd2c7dcedf19d56a39d">get_type_arch</a> (type),
<a name="l01070"></a>01070                                    <a class="code" href="value_8h.html#aa0976bbc250fff8bdc40dfa0d245eb86">VALUE_INTERNALVAR</a> (toval));
<a name="l01071"></a>01071 
<a name="l01072"></a>01072     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba1a4bc6eb90ebb401ddec38c7e605f2f8">lval_internalvar_component</a>:
<a name="l01073"></a>01073       {
<a name="l01074"></a>01074         <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a> = <a class="code" href="value_8c.html#aff69bf52c3773e7afc5f95b6ef302b1c">value_offset</a> (toval);
<a name="l01075"></a>01075 
<a name="l01076"></a>01076         <span class="comment">/* Are we dealing with a bitfield?</span>
<a name="l01077"></a>01077 <span class="comment"></span>
<a name="l01078"></a>01078 <span class="comment">           It is important to mention that `value_parent (toval)&#39; is</span>
<a name="l01079"></a>01079 <span class="comment">           non-NULL iff `value_bitsize (toval)&#39; is non-zero.  */</span>
<a name="l01080"></a>01080         <span class="keywordflow">if</span> (<a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (toval))
<a name="l01081"></a>01081           {
<a name="l01082"></a>01082             <span class="comment">/* VALUE_INTERNALVAR below refers to the parent value, while</span>
<a name="l01083"></a>01083 <span class="comment">               the offset is relative to this parent value.  */</span>
<a name="l01084"></a>01084             <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="value_8c.html#a04cf6e987c05f26c59686cedf529cf3e">value_parent</a> (<a class="code" href="value_8c.html#a04cf6e987c05f26c59686cedf529cf3e">value_parent</a> (toval)) == NULL);
<a name="l01085"></a>01085             offset += <a class="code" href="value_8c.html#aff69bf52c3773e7afc5f95b6ef302b1c">value_offset</a> (<a class="code" href="value_8c.html#a04cf6e987c05f26c59686cedf529cf3e">value_parent</a> (toval));
<a name="l01086"></a>01086           }
<a name="l01087"></a>01087 
<a name="l01088"></a>01088         <a class="code" href="value_8c.html#a0bdd5c6cf1f43376fcc5d73f300f258a">set_internalvar_component</a> (<a class="code" href="value_8h.html#aa0976bbc250fff8bdc40dfa0d245eb86">VALUE_INTERNALVAR</a> (toval),
<a name="l01089"></a>01089                                    offset,
<a name="l01090"></a>01090                                    <a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (toval),
<a name="l01091"></a>01091                                    <a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (toval),
<a name="l01092"></a>01092                                    fromval);
<a name="l01093"></a>01093       }
<a name="l01094"></a>01094       <span class="keywordflow">break</span>;
<a name="l01095"></a>01095 
<a name="l01096"></a>01096     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>:
<a name="l01097"></a>01097       {
<a name="l01098"></a>01098         <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *dest_buffer;
<a name="l01099"></a>01099         <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> changed_addr;
<a name="l01100"></a>01100         <span class="keywordtype">int</span> changed_len;
<a name="l01101"></a>01101         <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> <a class="code" href="structbuffer.html">buffer</a>[<span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>)];
<a name="l01102"></a>01102 
<a name="l01103"></a>01103         <span class="keywordflow">if</span> (<a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (toval))
<a name="l01104"></a>01104           {
<a name="l01105"></a>01105             <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html#ac5784dc092188f21d4d2a0e041a8eeb8">parent</a> = <a class="code" href="value_8c.html#a04cf6e987c05f26c59686cedf529cf3e">value_parent</a> (toval);
<a name="l01106"></a>01106 
<a name="l01107"></a>01107             changed_addr = <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (parent) + <a class="code" href="value_8c.html#aff69bf52c3773e7afc5f95b6ef302b1c">value_offset</a> (toval);
<a name="l01108"></a>01108             changed_len = (<a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (toval)
<a name="l01109"></a>01109                            + <a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (toval)
<a name="l01110"></a>01110                            + <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - 1)
<a name="l01111"></a>01111               / <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l01112"></a>01112 
<a name="l01113"></a>01113             <span class="comment">/* If we can read-modify-write exactly the size of the</span>
<a name="l01114"></a>01114 <span class="comment">               containing type (e.g. short or int) then do so.  This</span>
<a name="l01115"></a>01115 <span class="comment">               is safer for volatile bitfields mapped to hardware</span>
<a name="l01116"></a>01116 <span class="comment">               registers.  */</span>
<a name="l01117"></a>01117             <span class="keywordflow">if</span> (changed_len &lt; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type)
<a name="l01118"></a>01118                 &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) &lt;= (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>) <span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>)
<a name="l01119"></a>01119                 &amp;&amp; ((<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) changed_addr % <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type)) == 0)
<a name="l01120"></a>01120               changed_len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type);
<a name="l01121"></a>01121 
<a name="l01122"></a>01122             <span class="keywordflow">if</span> (changed_len &gt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>))
<a name="l01123"></a>01123               <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Can&#39;t handle bitfields which &quot;</span>
<a name="l01124"></a>01124                        <span class="stringliteral">&quot;don&#39;t fit in a %d bit word.&quot;</span>),
<a name="l01125"></a>01125                      (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) * <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>);
<a name="l01126"></a>01126 
<a name="l01127"></a>01127             <a class="code" href="corefile_8c.html#a5e0189c6f21f1c9321b379877183b819">read_memory</a> (changed_addr, <a class="code" href="structbuffer.html">buffer</a>, changed_len);
<a name="l01128"></a>01128             <a class="code" href="value_8c.html#a52aaf72536254f2f365df4d9e8f69a5e">modify_field</a> (type, <a class="code" href="structbuffer.html">buffer</a>, <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (fromval),
<a name="l01129"></a>01129                           <a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (toval), <a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (toval));
<a name="l01130"></a>01130             dest_buffer = <a class="code" href="structbuffer.html">buffer</a>;
<a name="l01131"></a>01131           }
<a name="l01132"></a>01132         <span class="keywordflow">else</span>
<a name="l01133"></a>01133           {
<a name="l01134"></a>01134             changed_addr = <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (toval);
<a name="l01135"></a>01135             changed_len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type);
<a name="l01136"></a>01136             dest_buffer = <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (fromval);
<a name="l01137"></a>01137           }
<a name="l01138"></a>01138 
<a name="l01139"></a>01139         <a class="code" href="corefile_8c.html#a79bfa0e1eb4062f8c9e8448b47e7b3ea">write_memory_with_notification</a> (changed_addr, dest_buffer, changed_len);
<a name="l01140"></a>01140       }
<a name="l01141"></a>01141       <span class="keywordflow">break</span>;
<a name="l01142"></a>01142 
<a name="l01143"></a>01143     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098abad63b16226e0a89af48f2750b1259377c">lval_register</a>:
<a name="l01144"></a>01144       {
<a name="l01145"></a>01145         <span class="keyword">struct </span><a class="code" href="structframe__info.html">frame_info</a> *frame;
<a name="l01146"></a>01146         <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a>;
<a name="l01147"></a>01147         <span class="keywordtype">int</span> value_reg;
<a name="l01148"></a>01148 
<a name="l01149"></a>01149         <span class="comment">/* Figure out which frame this is in currently.  */</span>
<a name="l01150"></a>01150         frame = <a class="code" href="frame_8c.html#a09616280d1811c8f06c46e26a8e07960">frame_find_by_id</a> (<a class="code" href="value_8h.html#aced704dd83f00b026dbbc39446616338">VALUE_FRAME_ID</a> (toval));
<a name="l01151"></a>01151         value_reg = <a class="code" href="value_8h.html#a8ce5c2cdfd9120ea68e7dd358299931c">VALUE_REGNUM</a> (toval);
<a name="l01152"></a>01152 
<a name="l01153"></a>01153         <span class="keywordflow">if</span> (!frame)
<a name="l01154"></a>01154           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Value being assigned to is no longer active.&quot;</span>));
<a name="l01155"></a>01155 
<a name="l01156"></a>01156         gdbarch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (frame);
<a name="l01157"></a>01157         <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#aba0dc4450e8811bbbe23046e7cdc7b05">gdbarch_convert_register_p</a> (gdbarch, <a class="code" href="value_8h.html#a8ce5c2cdfd9120ea68e7dd358299931c">VALUE_REGNUM</a> (toval), type))
<a name="l01158"></a>01158           {
<a name="l01159"></a>01159             <span class="comment">/* If TOVAL is a special machine register requiring</span>
<a name="l01160"></a>01160 <span class="comment">               conversion of program values to a special raw</span>
<a name="l01161"></a>01161 <span class="comment">               format.  */</span>
<a name="l01162"></a>01162             <a class="code" href="gdbarch_8c.html#af2602e5de7c86ea46b52587961f27754">gdbarch_value_to_register</a> (gdbarch, frame,
<a name="l01163"></a>01163                                        <a class="code" href="value_8h.html#a8ce5c2cdfd9120ea68e7dd358299931c">VALUE_REGNUM</a> (toval), type,
<a name="l01164"></a>01164                                        <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (fromval));
<a name="l01165"></a>01165           }
<a name="l01166"></a>01166         <span class="keywordflow">else</span>
<a name="l01167"></a>01167           {
<a name="l01168"></a>01168             <span class="keywordflow">if</span> (<a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (toval))
<a name="l01169"></a>01169               {
<a name="l01170"></a>01170                 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html#ac5784dc092188f21d4d2a0e041a8eeb8">parent</a> = <a class="code" href="value_8c.html#a04cf6e987c05f26c59686cedf529cf3e">value_parent</a> (toval);
<a name="l01171"></a>01171                 <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a> = <a class="code" href="value_8c.html#aff69bf52c3773e7afc5f95b6ef302b1c">value_offset</a> (parent) + <a class="code" href="value_8c.html#aff69bf52c3773e7afc5f95b6ef302b1c">value_offset</a> (toval);
<a name="l01172"></a>01172                 <span class="keywordtype">int</span> changed_len;
<a name="l01173"></a>01173                 <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> <a class="code" href="structbuffer.html">buffer</a>[<span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>)];
<a name="l01174"></a>01174                 <span class="keywordtype">int</span> optim, unavail;
<a name="l01175"></a>01175 
<a name="l01176"></a>01176                 changed_len = (<a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (toval)
<a name="l01177"></a>01177                                + <a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (toval)
<a name="l01178"></a>01178                                + <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - 1)
<a name="l01179"></a>01179                   / <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l01180"></a>01180 
<a name="l01181"></a>01181                 <span class="keywordflow">if</span> (changed_len &gt; (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>))
<a name="l01182"></a>01182                   <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Can&#39;t handle bitfields which &quot;</span>
<a name="l01183"></a>01183                            <span class="stringliteral">&quot;don&#39;t fit in a %d bit word.&quot;</span>),
<a name="l01184"></a>01184                          (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) * <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>);
<a name="l01185"></a>01185 
<a name="l01186"></a>01186                 <span class="keywordflow">if</span> (!<a class="code" href="frame_8c.html#a2a2fcb8f8afb97611547f3b62026dfed">get_frame_register_bytes</a> (frame, value_reg, offset,
<a name="l01187"></a>01187                                                changed_len, <a class="code" href="structbuffer.html">buffer</a>,
<a name="l01188"></a>01188                                                &amp;optim, &amp;unavail))
<a name="l01189"></a>01189                   {
<a name="l01190"></a>01190                     <span class="keywordflow">if</span> (optim)
<a name="l01191"></a>01191                       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;value has been optimized out&quot;</span>));
<a name="l01192"></a>01192                     <span class="keywordflow">if</span> (unavail)
<a name="l01193"></a>01193                       <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971ad5f524b407f1cb2d36cb365112de18c9">NOT_AVAILABLE_ERROR</a>,
<a name="l01194"></a>01194                                    <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;value is not available&quot;</span>));
<a name="l01195"></a>01195                   }
<a name="l01196"></a>01196 
<a name="l01197"></a>01197                 <a class="code" href="value_8c.html#a52aaf72536254f2f365df4d9e8f69a5e">modify_field</a> (type, <a class="code" href="structbuffer.html">buffer</a>, <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (fromval),
<a name="l01198"></a>01198                               <a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (toval), <a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (toval));
<a name="l01199"></a>01199 
<a name="l01200"></a>01200                 <a class="code" href="frame_8c.html#a0f13a8b2febdcd5944bd4ef66812fb26">put_frame_register_bytes</a> (frame, value_reg, offset,
<a name="l01201"></a>01201                                           changed_len, <a class="code" href="structbuffer.html">buffer</a>);
<a name="l01202"></a>01202               }
<a name="l01203"></a>01203             <span class="keywordflow">else</span>
<a name="l01204"></a>01204               {
<a name="l01205"></a>01205                 <a class="code" href="frame_8c.html#a0f13a8b2febdcd5944bd4ef66812fb26">put_frame_register_bytes</a> (frame, value_reg,
<a name="l01206"></a>01206                                           <a class="code" href="value_8c.html#aff69bf52c3773e7afc5f95b6ef302b1c">value_offset</a> (toval),
<a name="l01207"></a>01207                                           <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type),
<a name="l01208"></a>01208                                           <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (fromval));
<a name="l01209"></a>01209               }
<a name="l01210"></a>01210           }
<a name="l01211"></a>01211 
<a name="l01212"></a>01212         <span class="keywordflow">if</span> (<a class="code" href="defs_8h.html#a3f2d9ce8bb47675e307ca85299bbbacc">deprecated_register_changed_hook</a>)
<a name="l01213"></a>01213           <a class="code" href="defs_8h.html#a3f2d9ce8bb47675e307ca85299bbbacc">deprecated_register_changed_hook</a> (-1);
<a name="l01214"></a>01214         <span class="keywordflow">break</span>;
<a name="l01215"></a>01215       }
<a name="l01216"></a>01216 
<a name="l01217"></a>01217     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba61712ce609a0e4f03514da2c992b6fc5">lval_computed</a>:
<a name="l01218"></a>01218       {
<a name="l01219"></a>01219         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlval__funcs.html">lval_funcs</a> *funcs = <a class="code" href="value_8c.html#a66a66a9d832ec824b091bf52b97e6097">value_computed_funcs</a> (toval);
<a name="l01220"></a>01220 
<a name="l01221"></a>01221         <span class="keywordflow">if</span> (funcs-&gt;<a class="code" href="structlval__funcs.html#a0ce721c246fa432d7481b8e892856418">write</a> != NULL)
<a name="l01222"></a>01222           {
<a name="l01223"></a>01223             funcs-&gt;<a class="code" href="structlval__funcs.html#a0ce721c246fa432d7481b8e892856418">write</a> (toval, fromval);
<a name="l01224"></a>01224             <span class="keywordflow">break</span>;
<a name="l01225"></a>01225           }
<a name="l01226"></a>01226       }
<a name="l01227"></a>01227       <span class="comment">/* Fall through.  */</span>
<a name="l01228"></a>01228 
<a name="l01229"></a>01229     <span class="keywordflow">default</span>:
<a name="l01230"></a>01230       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Left operand of assignment is not an lvalue.&quot;</span>));
<a name="l01231"></a>01231     }
<a name="l01232"></a>01232 
<a name="l01233"></a>01233   <span class="comment">/* Assigning to the stack pointer, frame pointer, and other</span>
<a name="l01234"></a>01234 <span class="comment">     (architecture and calling convention specific) registers may</span>
<a name="l01235"></a>01235 <span class="comment">     cause the frame cache and regcache to be out of date.  Assigning to memory</span>
<a name="l01236"></a>01236 <span class="comment">     also can.  We just do this on all assignments to registers or</span>
<a name="l01237"></a>01237 <span class="comment">     memory, for simplicity&#39;s sake; I doubt the slowdown matters.  */</span>
<a name="l01238"></a>01238   <span class="keywordflow">switch</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (toval))
<a name="l01239"></a>01239     {
<a name="l01240"></a>01240     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>:
<a name="l01241"></a>01241     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098abad63b16226e0a89af48f2750b1259377c">lval_register</a>:
<a name="l01242"></a>01242     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba61712ce609a0e4f03514da2c992b6fc5">lval_computed</a>:
<a name="l01243"></a>01243 
<a name="l01244"></a>01244       <a class="code" href="observer_8h.html#a7f5c5ada747f945ce8f3832514dbcb97">observer_notify_target_changed</a> (&amp;<a class="code" href="target_8h.html#a2d8640b030266b58d3821eb5cfd112b9">current_target</a>);
<a name="l01245"></a>01245 
<a name="l01246"></a>01246       <span class="comment">/* Having destroyed the frame cache, restore the selected</span>
<a name="l01247"></a>01247 <span class="comment">         frame.  */</span>
<a name="l01248"></a>01248 
<a name="l01249"></a>01249       <span class="comment">/* FIXME: cagney/2002-11-02: There has to be a better way of</span>
<a name="l01250"></a>01250 <span class="comment">         doing this.  Instead of constantly saving/restoring the</span>
<a name="l01251"></a>01251 <span class="comment">         frame.  Why not create a get_selected_frame() function that,</span>
<a name="l01252"></a>01252 <span class="comment">         having saved the selected frame&#39;s ID can automatically</span>
<a name="l01253"></a>01253 <span class="comment">         re-find the previously selected frame automatically.  */</span>
<a name="l01254"></a>01254 
<a name="l01255"></a>01255       {
<a name="l01256"></a>01256         <span class="keyword">struct </span><a class="code" href="structframe__info.html">frame_info</a> *fi = <a class="code" href="frame_8c.html#a09616280d1811c8f06c46e26a8e07960">frame_find_by_id</a> (old_frame);
<a name="l01257"></a>01257 
<a name="l01258"></a>01258         <span class="keywordflow">if</span> (fi != NULL)
<a name="l01259"></a>01259           <a class="code" href="frame_8c.html#a400fa273ac86863322cdc65683ef2356">select_frame</a> (fi);
<a name="l01260"></a>01260       }
<a name="l01261"></a>01261 
<a name="l01262"></a>01262       <span class="keywordflow">break</span>;
<a name="l01263"></a>01263     <span class="keywordflow">default</span>:
<a name="l01264"></a>01264       <span class="keywordflow">break</span>;
<a name="l01265"></a>01265     }
<a name="l01266"></a>01266   
<a name="l01267"></a>01267   <span class="comment">/* If the field does not entirely fill a LONGEST, then zero the sign</span>
<a name="l01268"></a>01268 <span class="comment">     bits.  If the field is signed, and is negative, then sign</span>
<a name="l01269"></a>01269 <span class="comment">     extend.  */</span>
<a name="l01270"></a>01270   <span class="keywordflow">if</span> ((<a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (toval) &gt; 0)
<a name="l01271"></a>01271       &amp;&amp; (<a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (toval) &lt; 8 * (<span class="keywordtype">int</span>) <span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>)))
<a name="l01272"></a>01272     {
<a name="l01273"></a>01273       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> fieldval = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (fromval);
<a name="l01274"></a>01274       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> valmask = (((<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a>) 1) &lt;&lt; <a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (toval)) - 1;
<a name="l01275"></a>01275 
<a name="l01276"></a>01276       fieldval &amp;= valmask;
<a name="l01277"></a>01277       <span class="keywordflow">if</span> (!<a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">TYPE_UNSIGNED</a> (type) 
<a name="l01278"></a>01278           &amp;&amp; (fieldval &amp; (valmask ^ (valmask &gt;&gt; 1))))
<a name="l01279"></a>01279         fieldval |= ~valmask;
<a name="l01280"></a>01280 
<a name="l01281"></a>01281       fromval = <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, fieldval);
<a name="l01282"></a>01282     }
<a name="l01283"></a>01283 
<a name="l01284"></a>01284   <span class="comment">/* The return value is a copy of TOVAL so it shares its location</span>
<a name="l01285"></a>01285 <span class="comment">     information, but its contents are updated from FROMVAL.  This</span>
<a name="l01286"></a>01286 <span class="comment">     implies the returned value is not lazy, even if TOVAL was.  */</span>
<a name="l01287"></a>01287   val = <a class="code" href="value_8c.html#abe2b4f6342cfefdbb63666b6bcba636b">value_copy</a> (toval);
<a name="l01288"></a>01288   <a class="code" href="value_8c.html#aeaf79c8a3eb809c51a0bc907b20c0a0d">set_value_lazy</a> (val, 0);
<a name="l01289"></a>01289   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="value_8c.html#a9f59e572fabef6e1905632fb81cc00e1">value_contents_raw</a> (val), <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (fromval),
<a name="l01290"></a>01290           <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type));
<a name="l01291"></a>01291 
<a name="l01292"></a>01292   <span class="comment">/* We copy over the enclosing type and pointed-to offset from FROMVAL</span>
<a name="l01293"></a>01293 <span class="comment">     in the case of pointer types.  For object types, the enclosing type</span>
<a name="l01294"></a>01294 <span class="comment">     and embedded offset must *not* be copied: the target object refered</span>
<a name="l01295"></a>01295 <span class="comment">     to by TOVAL retains its original dynamic type after assignment.  */</span>
<a name="l01296"></a>01296   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l01297"></a>01297     {
<a name="l01298"></a>01298       <a class="code" href="value_8c.html#ac90fd2d225f145f10b5f4d515027d7d2">set_value_enclosing_type</a> (val, <a class="code" href="value_8c.html#a23e0abd15939236dcae8b0c5c0674b1b">value_enclosing_type</a> (fromval));
<a name="l01299"></a>01299       <a class="code" href="value_8c.html#ae68cafe981874da3e148c261f24bbb04">set_value_pointed_to_offset</a> (val, <a class="code" href="value_8c.html#a0bd4dcd4316771060462fd971403833b">value_pointed_to_offset</a> (fromval));
<a name="l01300"></a>01300     }
<a name="l01301"></a>01301 
<a name="l01302"></a>01302   <span class="keywordflow">return</span> val;
<a name="l01303"></a>01303 }
<a name="l01304"></a>01304 
<a name="l01305"></a>01305 <span class="comment">/* Extend a value VAL to COUNT repetitions of its type.  */</span>
<a name="l01306"></a>01306 
<a name="l01307"></a>01307 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l01308"></a><a class="code" href="value_8h.html#a50c303b00bda3e7321eb56a94c665bcf">01308</a> <a class="code" href="valops_8c.html#a50c303b00bda3e7321eb56a94c665bcf">value_repeat</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *arg1, <span class="keywordtype">int</span> count)
<a name="l01309"></a>01309 {
<a name="l01310"></a>01310   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *val;
<a name="l01311"></a>01311 
<a name="l01312"></a>01312   <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (arg1) != <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>)
<a name="l01313"></a>01313     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Only values in memory can be extended with &#39;@&#39;.&quot;</span>));
<a name="l01314"></a>01314   <span class="keywordflow">if</span> (count &lt; 1)
<a name="l01315"></a>01315     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Invalid number %d of repetitions.&quot;</span>), count);
<a name="l01316"></a>01316 
<a name="l01317"></a>01317   val = <a class="code" href="value_8c.html#a4a2db8ee19bf9caacbf716d9f8035be9">allocate_repeat_value</a> (<a class="code" href="value_8c.html#a23e0abd15939236dcae8b0c5c0674b1b">value_enclosing_type</a> (arg1), count);
<a name="l01318"></a>01318 
<a name="l01319"></a>01319   <a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (val) = <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>;
<a name="l01320"></a>01320   <a class="code" href="value_8c.html#a33ecd4bc76c6629df42dafee1158307d">set_value_address</a> (val, <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (arg1));
<a name="l01321"></a>01321 
<a name="l01322"></a>01322   <a class="code" href="valops_8c.html#a85fc3c2a6982cfbc5025418775d0042c">read_value_memory</a> (val, 0, <a class="code" href="value_8c.html#ae3fa0e95cc1ccca1747d631ebd662bd1">value_stack</a> (val), <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (val),
<a name="l01323"></a>01323                      <a class="code" href="value_8c.html#afe16b8b2839f978d4cee40c96a054274">value_contents_all_raw</a> (val),
<a name="l01324"></a>01324                      <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a23e0abd15939236dcae8b0c5c0674b1b">value_enclosing_type</a> (val)));
<a name="l01325"></a>01325 
<a name="l01326"></a>01326   <span class="keywordflow">return</span> val;
<a name="l01327"></a>01327 }
<a name="l01328"></a>01328 
<a name="l01329"></a>01329 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l01330"></a><a class="code" href="value_8h.html#a353e75e3afb5f274e886d08360d045b8">01330</a> <a class="code" href="valops_8c.html#a353e75e3afb5f274e886d08360d045b8">value_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *var, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *b)
<a name="l01331"></a>01331 {
<a name="l01332"></a>01332   <span class="keyword">struct </span><a class="code" href="structframe__info.html">frame_info</a> *frame;
<a name="l01333"></a>01333 
<a name="l01334"></a>01334   <span class="keywordflow">if</span> (!<a class="code" href="findvar_8c.html#a4b5301bcfe22c158402854b932557637">symbol_read_needs_frame</a> (var))
<a name="l01335"></a>01335     frame = NULL;
<a name="l01336"></a>01336   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!b)
<a name="l01337"></a>01337     frame = <a class="code" href="frame_8c.html#a8b714a78478670e14a297eba8d1a9915">get_selected_frame</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No frame selected.&quot;</span>));
<a name="l01338"></a>01338   <span class="keywordflow">else</span>
<a name="l01339"></a>01339     {
<a name="l01340"></a>01340       frame = <a class="code" href="blockframe_8c.html#acef754b55368c6be1928b137738b927a">block_innermost_frame</a> (b);
<a name="l01341"></a>01341       <span class="keywordflow">if</span> (!frame)
<a name="l01342"></a>01342         {
<a name="l01343"></a>01343           <span class="keywordflow">if</span> (<a class="code" href="block_8h.html#aeea4a00e65c2be0c8674106f38d8ab65">BLOCK_FUNCTION</a> (b) &amp;&amp; !<a class="code" href="block_8c.html#a4f68882a103ca948ccea9a5fff7aa764">block_inlined_p</a> (b)
<a name="l01344"></a>01344               &amp;&amp; <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (<a class="code" href="block_8h.html#aeea4a00e65c2be0c8674106f38d8ab65">BLOCK_FUNCTION</a> (b)))
<a name="l01345"></a>01345             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No frame is currently executing in block %s.&quot;</span>),
<a name="l01346"></a>01346                    <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (<a class="code" href="block_8h.html#aeea4a00e65c2be0c8674106f38d8ab65">BLOCK_FUNCTION</a> (b)));
<a name="l01347"></a>01347           <span class="keywordflow">else</span>
<a name="l01348"></a>01348             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No frame is currently executing in specified block&quot;</span>));
<a name="l01349"></a>01349         }
<a name="l01350"></a>01350     }
<a name="l01351"></a>01351 
<a name="l01352"></a>01352   <span class="keywordflow">return</span> <a class="code" href="findvar_8c.html#afeb191a780ccc9cc2d95378bc1413751">read_var_value</a> (var, frame);
<a name="l01353"></a>01353 }
<a name="l01354"></a>01354 
<a name="l01355"></a>01355 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l01356"></a><a class="code" href="value_8h.html#ab8f383cc8436483bf6524f3df0cbf188">01356</a> <a class="code" href="valops_8c.html#ab8f383cc8436483bf6524f3df0cbf188">address_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *var, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *b)
<a name="l01357"></a>01357 {
<a name="l01358"></a>01358   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (var);
<a name="l01359"></a>01359   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *val;
<a name="l01360"></a>01360 
<a name="l01361"></a>01361   <span class="comment">/* Evaluate it first; if the result is a memory address, we&#39;re fine.</span>
<a name="l01362"></a>01362 <span class="comment">     Lazy evaluation pays off here.  */</span>
<a name="l01363"></a>01363 
<a name="l01364"></a>01364   val = <a class="code" href="valops_8c.html#a353e75e3afb5f274e886d08360d045b8">value_of_variable</a> (var, b);
<a name="l01365"></a>01365 
<a name="l01366"></a>01366   <span class="keywordflow">if</span> ((<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (val) == <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a> &amp;&amp; <a class="code" href="value_8c.html#aa60bc8ecf77867a2d16bec57a4ccf983">value_lazy</a> (val))
<a name="l01367"></a>01367       || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>)
<a name="l01368"></a>01368     {
<a name="l01369"></a>01369       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr = <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (val);
<a name="l01370"></a>01370 
<a name="l01371"></a>01371       <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a2f2d0d3d3ce482fc844f1fc4dc4c038e">value_from_pointer</a> (<a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (type), addr);
<a name="l01372"></a>01372     }
<a name="l01373"></a>01373 
<a name="l01374"></a>01374   <span class="comment">/* Not a memory address; check what the problem was.  */</span>
<a name="l01375"></a>01375   <span class="keywordflow">switch</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (val))
<a name="l01376"></a>01376     {
<a name="l01377"></a>01377     <span class="keywordflow">case</span> <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098abad63b16226e0a89af48f2750b1259377c">lval_register</a>:
<a name="l01378"></a>01378       {
<a name="l01379"></a>01379         <span class="keyword">struct </span><a class="code" href="structframe__info.html">frame_info</a> *frame;
<a name="l01380"></a>01380         <span class="keyword">const</span> <span class="keywordtype">char</span> *regname;
<a name="l01381"></a>01381 
<a name="l01382"></a>01382         frame = <a class="code" href="frame_8c.html#a09616280d1811c8f06c46e26a8e07960">frame_find_by_id</a> (<a class="code" href="value_8h.html#aced704dd83f00b026dbbc39446616338">VALUE_FRAME_ID</a> (val));
<a name="l01383"></a>01383         <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (frame);
<a name="l01384"></a>01384 
<a name="l01385"></a>01385         regname = <a class="code" href="gdbarch_8c.html#a86c0cf41eb88c54e943cd80e79af36e5">gdbarch_register_name</a> (<a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (frame),
<a name="l01386"></a>01386                                          <a class="code" href="value_8h.html#a8ce5c2cdfd9120ea68e7dd358299931c">VALUE_REGNUM</a> (val));
<a name="l01387"></a>01387         <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (regname &amp;&amp; *regname);
<a name="l01388"></a>01388 
<a name="l01389"></a>01389         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Address requested for identifier &quot;</span>
<a name="l01390"></a>01390                  <span class="stringliteral">&quot;\&quot;%s\&quot; which is in register $%s&quot;</span>),
<a name="l01391"></a>01391                <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (var), regname);
<a name="l01392"></a>01392         <span class="keywordflow">break</span>;
<a name="l01393"></a>01393       }
<a name="l01394"></a>01394 
<a name="l01395"></a>01395     <span class="keywordflow">default</span>:
<a name="l01396"></a>01396       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Can&#39;t take address of \&quot;%s\&quot; which isn&#39;t an lvalue.&quot;</span>),
<a name="l01397"></a>01397              <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (var));
<a name="l01398"></a>01398       <span class="keywordflow">break</span>;
<a name="l01399"></a>01399     }
<a name="l01400"></a>01400 
<a name="l01401"></a>01401   <span class="keywordflow">return</span> val;
<a name="l01402"></a>01402 }
<a name="l01403"></a>01403 
<a name="l01404"></a>01404 <span class="comment">/* Return one if VAL does not live in target memory, but should in order</span>
<a name="l01405"></a>01405 <span class="comment">   to operate on it.  Otherwise return zero.  */</span>
<a name="l01406"></a>01406 
<a name="l01407"></a>01407 <span class="keywordtype">int</span>
<a name="l01408"></a><a class="code" href="value_8h.html#acb1348e95ee814b075b3742c60073805">01408</a> <a class="code" href="valops_8c.html#ae6aadea6423ef8af2a01193c0d2b0fa0">value_must_coerce_to_target</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *val)
<a name="l01409"></a>01409 {
<a name="l01410"></a>01410   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *valtype;
<a name="l01411"></a>01411 
<a name="l01412"></a>01412   <span class="comment">/* The only lval kinds which do not live in target memory.  */</span>
<a name="l01413"></a>01413   <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (val) != <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>
<a name="l01414"></a>01414       &amp;&amp; <a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (val) != <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba8dfa3647df3362b7c410ac31f6cde323">lval_internalvar</a>)
<a name="l01415"></a>01415     <span class="keywordflow">return</span> 0;
<a name="l01416"></a>01416 
<a name="l01417"></a>01417   valtype = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val));
<a name="l01418"></a>01418 
<a name="l01419"></a>01419   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (valtype))
<a name="l01420"></a>01420     {
<a name="l01421"></a>01421     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>:
<a name="l01422"></a>01422       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a68a23253bcb233221400208f4c21c406">TYPE_VECTOR</a> (valtype) ? 0 : 1;
<a name="l01423"></a>01423     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a956ce01e5c83060e05208c9404fedca2">TYPE_CODE_STRING</a>:
<a name="l01424"></a>01424       <span class="keywordflow">return</span> 1;
<a name="l01425"></a>01425     <span class="keywordflow">default</span>:
<a name="l01426"></a>01426       <span class="keywordflow">return</span> 0;
<a name="l01427"></a>01427     }
<a name="l01428"></a>01428 }
<a name="l01429"></a>01429 
<a name="l01430"></a>01430 <span class="comment">/* Make sure that VAL lives in target memory if it&#39;s supposed to.  For</span>
<a name="l01431"></a>01431 <span class="comment">   instance, strings are constructed as character arrays in GDB&#39;s</span>
<a name="l01432"></a>01432 <span class="comment">   storage, and this function copies them to the target.  */</span>
<a name="l01433"></a>01433 
<a name="l01434"></a>01434 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l01435"></a><a class="code" href="value_8h.html#ad3d90e242997ece9d51efd806d01157a">01435</a> <a class="code" href="valops_8c.html#a0aed7747241f1f608acc6e1f199cba16">value_coerce_to_target</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *val)
<a name="l01436"></a>01436 {
<a name="l01437"></a>01437   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> length;
<a name="l01438"></a>01438   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr;
<a name="l01439"></a>01439 
<a name="l01440"></a>01440   <span class="keywordflow">if</span> (!<a class="code" href="valops_8c.html#ae6aadea6423ef8af2a01193c0d2b0fa0">value_must_coerce_to_target</a> (val))
<a name="l01441"></a>01441     <span class="keywordflow">return</span> val;
<a name="l01442"></a>01442 
<a name="l01443"></a>01443   length = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val)));
<a name="l01444"></a>01444   addr = <a class="code" href="valops_8c.html#aa2b54cae947d2ce4891dad670286fb92">allocate_space_in_inferior</a> (length);
<a name="l01445"></a>01445   <a class="code" href="corefile_8c.html#a05c568c157071d9349667fab589228e5">write_memory</a> (addr, <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (val), length);
<a name="l01446"></a>01446   <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val), addr);
<a name="l01447"></a>01447 }
<a name="l01448"></a>01448 
<a name="l01449"></a>01449 <span class="comment">/* Given a value which is an array, return a value which is a pointer</span>
<a name="l01450"></a>01450 <span class="comment">   to its first element, regardless of whether or not the array has a</span>
<a name="l01451"></a>01451 <span class="comment">   nonzero lower bound.</span>
<a name="l01452"></a>01452 <span class="comment"></span>
<a name="l01453"></a>01453 <span class="comment">   FIXME: A previous comment here indicated that this routine should</span>
<a name="l01454"></a>01454 <span class="comment">   be substracting the array&#39;s lower bound.  It&#39;s not clear to me that</span>
<a name="l01455"></a>01455 <span class="comment">   this is correct.  Given an array subscripting operation, it would</span>
<a name="l01456"></a>01456 <span class="comment">   certainly work to do the adjustment here, essentially computing:</span>
<a name="l01457"></a>01457 <span class="comment"></span>
<a name="l01458"></a>01458 <span class="comment">   (&amp;array[0] - (lowerbound * sizeof array[0])) + (index * sizeof array[0])</span>
<a name="l01459"></a>01459 <span class="comment"></span>
<a name="l01460"></a>01460 <span class="comment">   However I believe a more appropriate and logical place to account</span>
<a name="l01461"></a>01461 <span class="comment">   for the lower bound is to do so in value_subscript, essentially</span>
<a name="l01462"></a>01462 <span class="comment">   computing:</span>
<a name="l01463"></a>01463 <span class="comment"></span>
<a name="l01464"></a>01464 <span class="comment">   (&amp;array[0] + ((index - lowerbound) * sizeof array[0]))</span>
<a name="l01465"></a>01465 <span class="comment"></span>
<a name="l01466"></a>01466 <span class="comment">   As further evidence consider what would happen with operations</span>
<a name="l01467"></a>01467 <span class="comment">   other than array subscripting, where the caller would get back a</span>
<a name="l01468"></a>01468 <span class="comment">   value that had an address somewhere before the actual first element</span>
<a name="l01469"></a>01469 <span class="comment">   of the array, and the information about the lower bound would be</span>
<a name="l01470"></a>01470 <span class="comment">   lost because of the coercion to pointer type.  */</span>
<a name="l01471"></a>01471 
<a name="l01472"></a>01472 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l01473"></a><a class="code" href="value_8h.html#aaa184aecfd7121e9660f6385d03b8324">01473</a> <a class="code" href="valops_8c.html#aaa184aecfd7121e9660f6385d03b8324">value_coerce_array</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *arg1)
<a name="l01474"></a>01474 {
<a name="l01475"></a>01475   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1));
<a name="l01476"></a>01476 
<a name="l01477"></a>01477   <span class="comment">/* If the user tries to do something requiring a pointer with an</span>
<a name="l01478"></a>01478 <span class="comment">     array that has not yet been pushed to the target, then this would</span>
<a name="l01479"></a>01479 <span class="comment">     be a good time to do so.  */</span>
<a name="l01480"></a>01480   arg1 = <a class="code" href="valops_8c.html#a0aed7747241f1f608acc6e1f199cba16">value_coerce_to_target</a> (arg1);
<a name="l01481"></a>01481 
<a name="l01482"></a>01482   <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (arg1) != <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>)
<a name="l01483"></a>01483     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attempt to take address of value not located in memory.&quot;</span>));
<a name="l01484"></a>01484 
<a name="l01485"></a>01485   <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a2f2d0d3d3ce482fc844f1fc4dc4c038e">value_from_pointer</a> (<a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)),
<a name="l01486"></a>01486                              <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (arg1));
<a name="l01487"></a>01487 }
<a name="l01488"></a>01488 
<a name="l01489"></a>01489 <span class="comment">/* Given a value which is a function, return a value which is a pointer</span>
<a name="l01490"></a>01490 <span class="comment">   to it.  */</span>
<a name="l01491"></a>01491 
<a name="l01492"></a>01492 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l01493"></a><a class="code" href="value_8h.html#a5327ca7c1db660a4b64383dbc1e01791">01493</a> <a class="code" href="valops_8c.html#a5327ca7c1db660a4b64383dbc1e01791">value_coerce_function</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *arg1)
<a name="l01494"></a>01494 {
<a name="l01495"></a>01495   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *retval;
<a name="l01496"></a>01496 
<a name="l01497"></a>01497   <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (arg1) != <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>)
<a name="l01498"></a>01498     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attempt to take address of value not located in memory.&quot;</span>));
<a name="l01499"></a>01499 
<a name="l01500"></a>01500   retval = <a class="code" href="value_8c.html#a2f2d0d3d3ce482fc844f1fc4dc4c038e">value_from_pointer</a> (<a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1)),
<a name="l01501"></a>01501                                <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (arg1));
<a name="l01502"></a>01502   <span class="keywordflow">return</span> retval;
<a name="l01503"></a>01503 }
<a name="l01504"></a>01504 
<a name="l01505"></a>01505 <span class="comment">/* Return a pointer value for the object for which ARG1 is the</span>
<a name="l01506"></a>01506 <span class="comment">   contents.  */</span>
<a name="l01507"></a>01507 
<a name="l01508"></a>01508 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l01509"></a><a class="code" href="value_8h.html#a29bc320305726a3cbf324189df2ca772">01509</a> <a class="code" href="valops_8c.html#a29bc320305726a3cbf324189df2ca772">value_addr</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *arg1)
<a name="l01510"></a>01510 {
<a name="l01511"></a>01511   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *arg2;
<a name="l01512"></a>01512   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1));
<a name="l01513"></a>01513 
<a name="l01514"></a>01514   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l01515"></a>01515     {
<a name="l01516"></a>01516       <span class="comment">/* Copy the value, but change the type from (T&amp;) to (T*).  We</span>
<a name="l01517"></a>01517 <span class="comment">         keep the same location information, which is efficient, and</span>
<a name="l01518"></a>01518 <span class="comment">         allows &amp;(&amp;X) to get the location containing the reference.  */</span>
<a name="l01519"></a>01519       arg2 = <a class="code" href="value_8c.html#abe2b4f6342cfefdbb63666b6bcba636b">value_copy</a> (arg1);
<a name="l01520"></a>01520       <a class="code" href="value_8c.html#adac1b2d5054e2d7b44ea25ac1f8002f1">deprecated_set_value_type</a> (arg2, 
<a name="l01521"></a>01521                                  <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)));
<a name="l01522"></a>01522       <span class="keywordflow">return</span> arg2;
<a name="l01523"></a>01523     }
<a name="l01524"></a>01524   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>)
<a name="l01525"></a>01525     <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a5327ca7c1db660a4b64383dbc1e01791">value_coerce_function</a> (arg1);
<a name="l01526"></a>01526 
<a name="l01527"></a>01527   <span class="comment">/* If this is an array that has not yet been pushed to the target,</span>
<a name="l01528"></a>01528 <span class="comment">     then this would be a good time to force it to memory.  */</span>
<a name="l01529"></a>01529   arg1 = <a class="code" href="valops_8c.html#a0aed7747241f1f608acc6e1f199cba16">value_coerce_to_target</a> (arg1);
<a name="l01530"></a>01530 
<a name="l01531"></a>01531   <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (arg1) != <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>)
<a name="l01532"></a>01532     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attempt to take address of value not located in memory.&quot;</span>));
<a name="l01533"></a>01533 
<a name="l01534"></a>01534   <span class="comment">/* Get target memory address.  */</span>
<a name="l01535"></a>01535   arg2 = <a class="code" href="value_8c.html#a2f2d0d3d3ce482fc844f1fc4dc4c038e">value_from_pointer</a> (<a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1)),
<a name="l01536"></a>01536                              (<a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (arg1)
<a name="l01537"></a>01537                               + <a class="code" href="value_8c.html#acbd6146ab9bd4c54f994a895a66f3f3d">value_embedded_offset</a> (arg1)));
<a name="l01538"></a>01538 
<a name="l01539"></a>01539   <span class="comment">/* This may be a pointer to a base subobject; so remember the</span>
<a name="l01540"></a>01540 <span class="comment">     full derived object&#39;s type ...  */</span>
<a name="l01541"></a>01541   <a class="code" href="value_8c.html#ac90fd2d225f145f10b5f4d515027d7d2">set_value_enclosing_type</a> (arg2,
<a name="l01542"></a>01542                             <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (<a class="code" href="value_8c.html#a23e0abd15939236dcae8b0c5c0674b1b">value_enclosing_type</a> (arg1)));
<a name="l01543"></a>01543   <span class="comment">/* ... and also the relative position of the subobject in the full</span>
<a name="l01544"></a>01544 <span class="comment">     object.  */</span>
<a name="l01545"></a>01545   <a class="code" href="value_8c.html#ae68cafe981874da3e148c261f24bbb04">set_value_pointed_to_offset</a> (arg2, <a class="code" href="value_8c.html#acbd6146ab9bd4c54f994a895a66f3f3d">value_embedded_offset</a> (arg1));
<a name="l01546"></a>01546   <span class="keywordflow">return</span> arg2;
<a name="l01547"></a>01547 }
<a name="l01548"></a>01548 
<a name="l01549"></a>01549 <span class="comment">/* Return a reference value for the object for which ARG1 is the</span>
<a name="l01550"></a>01550 <span class="comment">   contents.  */</span>
<a name="l01551"></a>01551 
<a name="l01552"></a>01552 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l01553"></a><a class="code" href="value_8h.html#ab73ccebbfb87a9332020dcf03976b053">01553</a> <a class="code" href="valops_8c.html#ab73ccebbfb87a9332020dcf03976b053">value_ref</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *arg1)
<a name="l01554"></a>01554 {
<a name="l01555"></a>01555   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *arg2;
<a name="l01556"></a>01556   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1));
<a name="l01557"></a>01557 
<a name="l01558"></a>01558   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l01559"></a>01559     <span class="keywordflow">return</span> arg1;
<a name="l01560"></a>01560 
<a name="l01561"></a>01561   arg2 = <a class="code" href="valops_8c.html#a29bc320305726a3cbf324189df2ca772">value_addr</a> (arg1);
<a name="l01562"></a>01562   <a class="code" href="value_8c.html#adac1b2d5054e2d7b44ea25ac1f8002f1">deprecated_set_value_type</a> (arg2, <a class="code" href="gdbtypes_8c.html#afa9bb6a94856e413a9932abea7356e22">lookup_reference_type</a> (type));
<a name="l01563"></a>01563   <span class="keywordflow">return</span> arg2;
<a name="l01564"></a>01564 }
<a name="l01565"></a>01565 
<a name="l01566"></a>01566 <span class="comment">/* Given a value of a pointer type, apply the C unary * operator to</span>
<a name="l01567"></a>01567 <span class="comment">   it.  */</span>
<a name="l01568"></a>01568 
<a name="l01569"></a>01569 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l01570"></a><a class="code" href="value_8h.html#af1f1e44875d884ca57ccedf048016cc7">01570</a> <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *arg1)
<a name="l01571"></a>01571 {
<a name="l01572"></a>01572   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *base_type;
<a name="l01573"></a>01573   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *arg2;
<a name="l01574"></a>01574 
<a name="l01575"></a>01575   arg1 = <a class="code" href="value_8c.html#a773e1b64380b836763411d405aa758f1">coerce_array</a> (arg1);
<a name="l01576"></a>01576 
<a name="l01577"></a>01577   base_type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1));
<a name="l01578"></a>01578 
<a name="l01579"></a>01579   <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (arg1) == <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba61712ce609a0e4f03514da2c992b6fc5">lval_computed</a>)
<a name="l01580"></a>01580     {
<a name="l01581"></a>01581       <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlval__funcs.html">lval_funcs</a> *funcs = <a class="code" href="value_8c.html#a66a66a9d832ec824b091bf52b97e6097">value_computed_funcs</a> (arg1);
<a name="l01582"></a>01582 
<a name="l01583"></a>01583       <span class="keywordflow">if</span> (funcs-&gt;<a class="code" href="structlval__funcs.html#af45e41bf65beeb3af167aaf03786fa47">indirect</a>)
<a name="l01584"></a>01584         {
<a name="l01585"></a>01585           <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *result = funcs-&gt;<a class="code" href="structlval__funcs.html#af45e41bf65beeb3af167aaf03786fa47">indirect</a> (arg1);
<a name="l01586"></a>01586 
<a name="l01587"></a>01587           <span class="keywordflow">if</span> (result)
<a name="l01588"></a>01588             <span class="keywordflow">return</span> result;
<a name="l01589"></a>01589         }
<a name="l01590"></a>01590     }
<a name="l01591"></a>01591 
<a name="l01592"></a>01592   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (base_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l01593"></a>01593     {
<a name="l01594"></a>01594       <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *enc_type;
<a name="l01595"></a>01595 
<a name="l01596"></a>01596       <span class="comment">/* We may be pointing to something embedded in a larger object.</span>
<a name="l01597"></a>01597 <span class="comment">         Get the real type of the enclosing object.  */</span>
<a name="l01598"></a>01598       enc_type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a23e0abd15939236dcae8b0c5c0674b1b">value_enclosing_type</a> (arg1));
<a name="l01599"></a>01599       enc_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (enc_type);
<a name="l01600"></a>01600 
<a name="l01601"></a>01601       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (enc_type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>
<a name="l01602"></a>01602           || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (enc_type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a581771a1410949e8b505dd51426949e9">TYPE_CODE_METHOD</a>)
<a name="l01603"></a>01603         <span class="comment">/* For functions, go through find_function_addr, which knows</span>
<a name="l01604"></a>01604 <span class="comment">           how to handle function descriptors.  */</span>
<a name="l01605"></a>01605         arg2 = <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (enc_type, 
<a name="l01606"></a>01606                               <a class="code" href="infcall_8c.html#a68f258349aa77867901ff0b0ba2815a9">find_function_addr</a> (arg1, NULL));
<a name="l01607"></a>01607       <span class="keywordflow">else</span>
<a name="l01608"></a>01608         <span class="comment">/* Retrieve the enclosing object pointed to.  */</span>
<a name="l01609"></a>01609         arg2 = <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (enc_type, 
<a name="l01610"></a>01610                               (<a class="code" href="value_8c.html#a2e64d8ca2ab5480e05097c6b2df1aa02">value_as_address</a> (arg1)
<a name="l01611"></a>01611                                - <a class="code" href="value_8c.html#a0bd4dcd4316771060462fd971403833b">value_pointed_to_offset</a> (arg1)));
<a name="l01612"></a>01612 
<a name="l01613"></a>01613       <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a87e9b01eae6f64fabeb342636fb38cf5">readjust_indirect_value_type</a> (arg2, enc_type, base_type, arg1);
<a name="l01614"></a>01614     }
<a name="l01615"></a>01615 
<a name="l01616"></a>01616   <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attempt to take contents of a non-pointer value.&quot;</span>));
<a name="l01617"></a>01617   <span class="keywordflow">return</span> 0;                     <span class="comment">/* For lint -- never reached.  */</span>
<a name="l01618"></a>01618 }
<a name="l01619"></a>01619 
<a name="l01620"></a>01620 <span class="comment">/* Create a value for an array by allocating space in GDB, copying the</span>
<a name="l01621"></a>01621 <span class="comment">   data into that space, and then setting up an array value.</span>
<a name="l01622"></a>01622 <span class="comment"></span>
<a name="l01623"></a>01623 <span class="comment">   The array bounds are set from LOWBOUND and HIGHBOUND, and the array</span>
<a name="l01624"></a>01624 <span class="comment">   is populated from the values passed in ELEMVEC.</span>
<a name="l01625"></a>01625 <span class="comment"></span>
<a name="l01626"></a>01626 <span class="comment">   The element type of the array is inherited from the type of the</span>
<a name="l01627"></a>01627 <span class="comment">   first element, and all elements must have the same size (though we</span>
<a name="l01628"></a>01628 <span class="comment">   don&#39;t currently enforce any restriction on their types).  */</span>
<a name="l01629"></a>01629 
<a name="l01630"></a>01630 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l01631"></a><a class="code" href="value_8h.html#aad4cdd8b2ec59e85f4984641787395d8">01631</a> <a class="code" href="valops_8c.html#aad4cdd8b2ec59e85f4984641787395d8">value_array</a> (<span class="keywordtype">int</span> lowbound, <span class="keywordtype">int</span> highbound, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **elemvec)
<a name="l01632"></a>01632 {
<a name="l01633"></a>01633   <span class="keywordtype">int</span> nelem;
<a name="l01634"></a>01634   <span class="keywordtype">int</span> idx;
<a name="l01635"></a>01635   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> typelength;
<a name="l01636"></a>01636   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *val;
<a name="l01637"></a>01637   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *arraytype;
<a name="l01638"></a>01638 
<a name="l01639"></a>01639   <span class="comment">/* Validate that the bounds are reasonable and that each of the</span>
<a name="l01640"></a>01640 <span class="comment">     elements have the same size.  */</span>
<a name="l01641"></a>01641 
<a name="l01642"></a>01642   nelem = highbound - lowbound + 1;
<a name="l01643"></a>01643   <span class="keywordflow">if</span> (nelem &lt;= 0)
<a name="l01644"></a>01644     {
<a name="l01645"></a>01645       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;bad array bounds (%d, %d)&quot;</span>), lowbound, highbound);
<a name="l01646"></a>01646     }
<a name="l01647"></a>01647   typelength = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a23e0abd15939236dcae8b0c5c0674b1b">value_enclosing_type</a> (elemvec[0]));
<a name="l01648"></a>01648   <span class="keywordflow">for</span> (idx = 1; idx &lt; nelem; idx++)
<a name="l01649"></a>01649     {
<a name="l01650"></a>01650       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a23e0abd15939236dcae8b0c5c0674b1b">value_enclosing_type</a> (elemvec[idx])) != typelength)
<a name="l01651"></a>01651         {
<a name="l01652"></a>01652           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;array elements must all be the same size&quot;</span>));
<a name="l01653"></a>01653         }
<a name="l01654"></a>01654     }
<a name="l01655"></a>01655 
<a name="l01656"></a>01656   arraytype = <a class="code" href="gdbtypes_8c.html#a91c24db4658fe0833c46b6fe5d677159">lookup_array_range_type</a> (<a class="code" href="value_8c.html#a23e0abd15939236dcae8b0c5c0674b1b">value_enclosing_type</a> (elemvec[0]),
<a name="l01657"></a>01657                                        lowbound, highbound);
<a name="l01658"></a>01658 
<a name="l01659"></a>01659   <span class="keywordflow">if</span> (!<a class="code" href="language_8c.html#acd2505a014a95629da9c836f8914fc79">current_language</a>-&gt;<a class="code" href="structlanguage__defn.html#a14aa24c8c78b4aa2bb9ac7f64b10229e">c_style_arrays</a>)
<a name="l01660"></a>01660     {
<a name="l01661"></a>01661       val = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (arraytype);
<a name="l01662"></a>01662       <span class="keywordflow">for</span> (idx = 0; idx &lt; nelem; idx++)
<a name="l01663"></a>01663         <a class="code" href="value_8c.html#a05f447d7418303febbc0a5f7e570834e">value_contents_copy</a> (val, idx * typelength, elemvec[idx], 0,
<a name="l01664"></a>01664                              typelength);
<a name="l01665"></a>01665       <span class="keywordflow">return</span> val;
<a name="l01666"></a>01666     }
<a name="l01667"></a>01667 
<a name="l01668"></a>01668   <span class="comment">/* Allocate space to store the array, and then initialize it by</span>
<a name="l01669"></a>01669 <span class="comment">     copying in each element.  */</span>
<a name="l01670"></a>01670 
<a name="l01671"></a>01671   val = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (arraytype);
<a name="l01672"></a>01672   <span class="keywordflow">for</span> (idx = 0; idx &lt; nelem; idx++)
<a name="l01673"></a>01673     <a class="code" href="value_8c.html#a05f447d7418303febbc0a5f7e570834e">value_contents_copy</a> (val, idx * typelength, elemvec[idx], 0, typelength);
<a name="l01674"></a>01674   <span class="keywordflow">return</span> val;
<a name="l01675"></a>01675 }
<a name="l01676"></a>01676 
<a name="l01677"></a>01677 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l01678"></a><a class="code" href="value_8h.html#a48ad28d9482ace03259985e3b1858d54">01678</a> <a class="code" href="valops_8c.html#a48ad28d9482ace03259985e3b1858d54">value_cstring</a> (<span class="keywordtype">char</span> *ptr, ssize_t <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *char_type)
<a name="l01679"></a>01679 {
<a name="l01680"></a>01680   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *val;
<a name="l01681"></a>01681   <span class="keywordtype">int</span> lowbound = <a class="code" href="language_8c.html#acd2505a014a95629da9c836f8914fc79">current_language</a>-&gt;<a class="code" href="structlanguage__defn.html#a7926f434a3d6a5d8bbe9334a160d2526">string_lower_bound</a>;
<a name="l01682"></a>01682   ssize_t highbound = len / <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (char_type);
<a name="l01683"></a>01683   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *stringtype
<a name="l01684"></a>01684     = <a class="code" href="gdbtypes_8c.html#a91c24db4658fe0833c46b6fe5d677159">lookup_array_range_type</a> (char_type, lowbound, highbound + lowbound - 1);
<a name="l01685"></a>01685 
<a name="l01686"></a>01686   val = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (stringtype);
<a name="l01687"></a>01687   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="value_8c.html#a9f59e572fabef6e1905632fb81cc00e1">value_contents_raw</a> (val), ptr, len);
<a name="l01688"></a>01688   <span class="keywordflow">return</span> val;
<a name="l01689"></a>01689 }
<a name="l01690"></a>01690 
<a name="l01691"></a>01691 <span class="comment">/* Create a value for a string constant by allocating space in the</span>
<a name="l01692"></a>01692 <span class="comment">   inferior, copying the data into that space, and returning the</span>
<a name="l01693"></a>01693 <span class="comment">   address with type TYPE_CODE_STRING.  PTR points to the string</span>
<a name="l01694"></a>01694 <span class="comment">   constant data; LEN is number of characters.</span>
<a name="l01695"></a>01695 <span class="comment"></span>
<a name="l01696"></a>01696 <span class="comment">   Note that string types are like array of char types with a lower</span>
<a name="l01697"></a>01697 <span class="comment">   bound of zero and an upper bound of LEN - 1.  Also note that the</span>
<a name="l01698"></a>01698 <span class="comment">   string may contain embedded null bytes.  */</span>
<a name="l01699"></a>01699 
<a name="l01700"></a>01700 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l01701"></a><a class="code" href="value_8h.html#abbbf41471a8d43ae4bd659e37c8ed578">01701</a> <a class="code" href="valops_8c.html#abbbf41471a8d43ae4bd659e37c8ed578">value_string</a> (<span class="keywordtype">char</span> *ptr, ssize_t <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *char_type)
<a name="l01702"></a>01702 {
<a name="l01703"></a>01703   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *val;
<a name="l01704"></a>01704   <span class="keywordtype">int</span> lowbound = <a class="code" href="language_8c.html#acd2505a014a95629da9c836f8914fc79">current_language</a>-&gt;<a class="code" href="structlanguage__defn.html#a7926f434a3d6a5d8bbe9334a160d2526">string_lower_bound</a>;
<a name="l01705"></a>01705   ssize_t highbound = len / <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (char_type);
<a name="l01706"></a>01706   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *stringtype
<a name="l01707"></a>01707     = <a class="code" href="gdbtypes_8c.html#a07dfeb10d05931ffd294e444eafcacd5">lookup_string_range_type</a> (char_type, lowbound, highbound + lowbound - 1);
<a name="l01708"></a>01708 
<a name="l01709"></a>01709   val = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (stringtype);
<a name="l01710"></a>01710   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="value_8c.html#a9f59e572fabef6e1905632fb81cc00e1">value_contents_raw</a> (val), ptr, len);
<a name="l01711"></a>01711   <span class="keywordflow">return</span> val;
<a name="l01712"></a>01712 }
<a name="l01713"></a>01713 
<a name="l01714"></a>01714 
<a name="l01715"></a>01715 <span class="comment">/* See if we can pass arguments in T2 to a function which takes</span>
<a name="l01716"></a>01716 <span class="comment">   arguments of types T1.  T1 is a list of NARGS arguments, and T2 is</span>
<a name="l01717"></a>01717 <span class="comment">   a NULL-terminated vector.  If some arguments need coercion of some</span>
<a name="l01718"></a>01718 <span class="comment">   sort, then the coerced values are written into T2.  Return value is</span>
<a name="l01719"></a>01719 <span class="comment">   0 if the arguments could be matched, or the position at which they</span>
<a name="l01720"></a>01720 <span class="comment">   differ if not.</span>
<a name="l01721"></a>01721 <span class="comment"></span>
<a name="l01722"></a>01722 <span class="comment">   STATICP is nonzero if the T1 argument list came from a static</span>
<a name="l01723"></a>01723 <span class="comment">   member function.  T2 will still include the ``this&#39;&#39; pointer, but</span>
<a name="l01724"></a>01724 <span class="comment">   it will be skipped.</span>
<a name="l01725"></a>01725 <span class="comment"></span>
<a name="l01726"></a>01726 <span class="comment">   For non-static member functions, we ignore the first argument,</span>
<a name="l01727"></a>01727 <span class="comment">   which is the type of the instance variable.  This is because we</span>
<a name="l01728"></a>01728 <span class="comment">   want to handle calls with objects from derived classes.  This is</span>
<a name="l01729"></a>01729 <span class="comment">   not entirely correct: we should actually check to make sure that a</span>
<a name="l01730"></a>01730 <span class="comment">   requested operation is type secure, shouldn&#39;t we?  FIXME.  */</span>
<a name="l01731"></a>01731 
<a name="l01732"></a>01732 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01733"></a><a class="code" href="valops_8c.html#a153df6d2ebd99111f79a91848d0e55ae">01733</a> <a class="code" href="valops_8c.html#a153df6d2ebd99111f79a91848d0e55ae">typecmp</a> (<span class="keywordtype">int</span> staticp, <span class="keywordtype">int</span> varargs, <span class="keywordtype">int</span> nargs,
<a name="l01734"></a>01734          <span class="keyword">struct</span> field t1[], <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *t2[])
<a name="l01735"></a>01735 {
<a name="l01736"></a>01736   <span class="keywordtype">int</span> i;
<a name="l01737"></a>01737 
<a name="l01738"></a>01738   <span class="keywordflow">if</span> (t2 == 0)
<a name="l01739"></a>01739     <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__, 
<a name="l01740"></a>01740                     <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;typecmp: no argument list&quot;</span>));
<a name="l01741"></a>01741 
<a name="l01742"></a>01742   <span class="comment">/* Skip ``this&#39;&#39; argument if applicable.  T2 will always include</span>
<a name="l01743"></a>01743 <span class="comment">     THIS.  */</span>
<a name="l01744"></a>01744   <span class="keywordflow">if</span> (staticp)
<a name="l01745"></a>01745     t2 ++;
<a name="l01746"></a>01746 
<a name="l01747"></a>01747   <span class="keywordflow">for</span> (i = 0;
<a name="l01748"></a>01748        (i &lt; nargs) &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t1[i].<a class="code" href="structtype.html">type</a>) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>;
<a name="l01749"></a>01749        i++)
<a name="l01750"></a>01750     {
<a name="l01751"></a>01751       <span class="keyword">struct </span>type *tt1, *tt2;
<a name="l01752"></a>01752 
<a name="l01753"></a>01753       <span class="keywordflow">if</span> (!t2[i])
<a name="l01754"></a>01754         <span class="keywordflow">return</span> i + 1;
<a name="l01755"></a>01755 
<a name="l01756"></a>01756       tt1 = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (t1[i].type);
<a name="l01757"></a>01757       tt2 = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (t2[i]));
<a name="l01758"></a>01758 
<a name="l01759"></a>01759       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (tt1) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>
<a name="l01760"></a>01760       <span class="comment">/* We should be doing hairy argument matching, as below.  */</span>
<a name="l01761"></a>01761           &amp;&amp; (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (tt1)))
<a name="l01762"></a>01762               == <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (tt2)))
<a name="l01763"></a>01763         {
<a name="l01764"></a>01764           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (tt2) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l01765"></a>01765             t2[i] = <a class="code" href="valops_8c.html#aaa184aecfd7121e9660f6385d03b8324">value_coerce_array</a> (t2[i]);
<a name="l01766"></a>01766           <span class="keywordflow">else</span>
<a name="l01767"></a>01767             t2[i] = <a class="code" href="valops_8c.html#ab73ccebbfb87a9332020dcf03976b053">value_ref</a> (t2[i]);
<a name="l01768"></a>01768           <span class="keywordflow">continue</span>;
<a name="l01769"></a>01769         }
<a name="l01770"></a>01770 
<a name="l01771"></a>01771       <span class="comment">/* djb - 20000715 - Until the new type structure is in the</span>
<a name="l01772"></a>01772 <span class="comment">         place, and we can attempt things like implicit conversions,</span>
<a name="l01773"></a>01773 <span class="comment">         we need to do this so you can take something like a map&lt;const</span>
<a name="l01774"></a>01774 <span class="comment">         char *&gt;, and properly access map[&quot;hello&quot;], because the</span>
<a name="l01775"></a>01775 <span class="comment">         argument to [] will be a reference to a pointer to a char,</span>
<a name="l01776"></a>01776 <span class="comment">         and the argument will be a pointer to a char.  */</span>
<a name="l01777"></a>01777       <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a>(tt1) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>
<a name="l01778"></a>01778              || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (tt1) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l01779"></a>01779         {
<a name="l01780"></a>01780           tt1 = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a>( <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a>(tt1) );
<a name="l01781"></a>01781         }
<a name="l01782"></a>01782       <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a>(tt2) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l01783"></a>01783              || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a>(tt2) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l01784"></a>01784              || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a>(tt2) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l01785"></a>01785         {
<a name="l01786"></a>01786           tt2 = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a>(tt2));
<a name="l01787"></a>01787         }
<a name="l01788"></a>01788       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (tt1) == <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (tt2))
<a name="l01789"></a>01789         <span class="keywordflow">continue</span>;
<a name="l01790"></a>01790       <span class="comment">/* Array to pointer is a `trivial conversion&#39; according to the</span>
<a name="l01791"></a>01791 <span class="comment">         ARM.  */</span>
<a name="l01792"></a>01792 
<a name="l01793"></a>01793       <span class="comment">/* We should be doing much hairier argument matching (see</span>
<a name="l01794"></a>01794 <span class="comment">         section 13.2 of the ARM), but as a quick kludge, just check</span>
<a name="l01795"></a>01795 <span class="comment">         for the same type code.  */</span>
<a name="l01796"></a>01796       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t1[i].type) != <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (t2[i])))
<a name="l01797"></a>01797         <span class="keywordflow">return</span> i + 1;
<a name="l01798"></a>01798     }
<a name="l01799"></a>01799   <span class="keywordflow">if</span> (varargs || t2[i] == NULL)
<a name="l01800"></a>01800     <span class="keywordflow">return</span> 0;
<a name="l01801"></a>01801   <span class="keywordflow">return</span> i + 1;
<a name="l01802"></a>01802 }
<a name="l01803"></a>01803 
<a name="l01804"></a>01804 <span class="comment">/* Helper class for do_search_struct_field that updates *RESULT_PTR</span>
<a name="l01805"></a>01805 <span class="comment">   and *LAST_BOFFSET, and possibly throws an exception if the field</span>
<a name="l01806"></a>01806 <span class="comment">   search has yielded ambiguous results.  */</span>
<a name="l01807"></a>01807 
<a name="l01808"></a>01808 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01809"></a><a class="code" href="valops_8c.html#abb7fbf7c6f78ffe5c03ca0d99d744ab2">01809</a> <a class="code" href="valops_8c.html#abb7fbf7c6f78ffe5c03ca0d99d744ab2">update_search_result</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **<a class="code" href="gdbtk-hooks_8c.html#a04dc8d0cf64b0bcd3ab28f06fb266bfc">result_ptr</a>, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *v,
<a name="l01810"></a>01810                       <span class="keywordtype">int</span> *last_boffset, <span class="keywordtype">int</span> boffset,
<a name="l01811"></a>01811                       <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>)
<a name="l01812"></a>01812 {
<a name="l01813"></a>01813   <span class="keywordflow">if</span> (v != NULL)
<a name="l01814"></a>01814     {
<a name="l01815"></a>01815       <span class="keywordflow">if</span> (*result_ptr != NULL
<a name="l01816"></a>01816           <span class="comment">/* The result is not ambiguous if all the classes that are</span>
<a name="l01817"></a>01817 <span class="comment">             found occupy the same space.  */</span>
<a name="l01818"></a>01818           &amp;&amp; *last_boffset != boffset)
<a name="l01819"></a>01819         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;base class &#39;%s&#39; is ambiguous in type &#39;%s&#39;&quot;</span>),
<a name="l01820"></a>01820                name, <a class="code" href="gdbtypes_8h.html#a69e35a3916d7d899ac6aa5f0bd187694">TYPE_SAFE_NAME</a> (type));
<a name="l01821"></a>01821       *result_ptr = v;
<a name="l01822"></a>01822       *last_boffset = boffset;
<a name="l01823"></a>01823     }
<a name="l01824"></a>01824 }
<a name="l01825"></a>01825 
<a name="l01826"></a>01826 <span class="comment">/* A helper for search_struct_field.  This does all the work; most</span>
<a name="l01827"></a>01827 <span class="comment">   arguments are as passed to search_struct_field.  The result is</span>
<a name="l01828"></a>01828 <span class="comment">   stored in *RESULT_PTR, which must be initialized to NULL.</span>
<a name="l01829"></a>01829 <span class="comment">   OUTERMOST_TYPE is the type of the initial type passed to</span>
<a name="l01830"></a>01830 <span class="comment">   search_struct_field; this is used for error reporting when the</span>
<a name="l01831"></a>01831 <span class="comment">   lookup is ambiguous.  */</span>
<a name="l01832"></a>01832 
<a name="l01833"></a>01833 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01834"></a><a class="code" href="valops_8c.html#a0ee6d5370dfbf977ea4f397cff1ce6d0">01834</a> <a class="code" href="valops_8c.html#a0ee6d5370dfbf977ea4f397cff1ce6d0">do_search_struct_field</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *arg1, <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>,
<a name="l01835"></a>01835                         <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keywordtype">int</span> looking_for_baseclass,
<a name="l01836"></a>01836                         <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **<a class="code" href="gdbtk-hooks_8c.html#a04dc8d0cf64b0bcd3ab28f06fb266bfc">result_ptr</a>,
<a name="l01837"></a>01837                         <span class="keywordtype">int</span> *last_boffset,
<a name="l01838"></a>01838                         <span class="keyword">struct</span> type *outermost_type)
<a name="l01839"></a>01839 {
<a name="l01840"></a>01840   <span class="keywordtype">int</span> i;
<a name="l01841"></a>01841   <span class="keywordtype">int</span> nbases;
<a name="l01842"></a>01842 
<a name="l01843"></a>01843   <a class="code" href="gdbtypes_8h.html#ae2f9348c644babaa9038b4dc18bffaac">CHECK_TYPEDEF</a> (type);
<a name="l01844"></a>01844   nbases = <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (type);
<a name="l01845"></a>01845 
<a name="l01846"></a>01846   <span class="keywordflow">if</span> (!looking_for_baseclass)
<a name="l01847"></a>01847     <span class="keywordflow">for</span> (i = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) - 1; i &gt;= nbases; i--)
<a name="l01848"></a>01848       {
<a name="l01849"></a>01849         <span class="keyword">const</span> <span class="keywordtype">char</span> *t_field_name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, i);
<a name="l01850"></a>01850 
<a name="l01851"></a>01851         <span class="keywordflow">if</span> (t_field_name &amp;&amp; (<a class="code" href="utils_8c.html#afe92387dbf8135978e7845a7dcf18003">strcmp_iw</a> (t_field_name, name) == 0))
<a name="l01852"></a>01852           {
<a name="l01853"></a>01853             <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *v;
<a name="l01854"></a>01854 
<a name="l01855"></a>01855             <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#a38a5ce3cc244d3f0618908f9a7ceca62">field_is_static</a> (&amp;<a class="code" href="gdbtypes_8h.html#a8beaef20f443a0d98c7b445bbcfcf031">TYPE_FIELD</a> (type, i)))
<a name="l01856"></a>01856               {
<a name="l01857"></a>01857                 v = <a class="code" href="value_8c.html#ad227db366076082564a611a5da413d8a">value_static_field</a> (type, i);
<a name="l01858"></a>01858                 <span class="keywordflow">if</span> (v == 0)
<a name="l01859"></a>01859                   <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;field %s is nonexistent or &quot;</span>
<a name="l01860"></a>01860                            <span class="stringliteral">&quot;has been optimized out&quot;</span>),
<a name="l01861"></a>01861                          name);
<a name="l01862"></a>01862               }
<a name="l01863"></a>01863             <span class="keywordflow">else</span>
<a name="l01864"></a>01864               v = <a class="code" href="value_8c.html#ac6e677d5cd8f7c40c20448fd7418b01c">value_primitive_field</a> (arg1, offset, i, type);
<a name="l01865"></a>01865             *result_ptr = v;
<a name="l01866"></a>01866             <span class="keywordflow">return</span>;
<a name="l01867"></a>01867           }
<a name="l01868"></a>01868 
<a name="l01869"></a>01869         <span class="keywordflow">if</span> (t_field_name
<a name="l01870"></a>01870             &amp;&amp; (t_field_name[0] == <span class="charliteral">&#39;\0&#39;</span>
<a name="l01871"></a>01871                 || (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>
<a name="l01872"></a>01872                     &amp;&amp; (<a class="code" href="utils_8c.html#afe92387dbf8135978e7845a7dcf18003">strcmp_iw</a> (t_field_name, <span class="stringliteral">&quot;else&quot;</span>) == 0))))
<a name="l01873"></a>01873           {
<a name="l01874"></a>01874             <span class="keyword">struct </span>type *field_type = <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, i);
<a name="l01875"></a>01875 
<a name="l01876"></a>01876             <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (field_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>
<a name="l01877"></a>01877                 || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (field_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>)
<a name="l01878"></a>01878               {
<a name="l01879"></a>01879                 <span class="comment">/* Look for a match through the fields of an anonymous</span>
<a name="l01880"></a>01880 <span class="comment">                   union, or anonymous struct.  C++ provides anonymous</span>
<a name="l01881"></a>01881 <span class="comment">                   unions.</span>
<a name="l01882"></a>01882 <span class="comment"></span>
<a name="l01883"></a>01883 <span class="comment">                   In the GNU Chill (now deleted from GDB)</span>
<a name="l01884"></a>01884 <span class="comment">                   implementation of variant record types, each</span>
<a name="l01885"></a>01885 <span class="comment">                   &lt;alternative field&gt; has an (anonymous) union type,</span>
<a name="l01886"></a>01886 <span class="comment">                   each member of the union represents a &lt;variant</span>
<a name="l01887"></a>01887 <span class="comment">                   alternative&gt;.  Each &lt;variant alternative&gt; is</span>
<a name="l01888"></a>01888 <span class="comment">                   represented as a struct, with a member for each</span>
<a name="l01889"></a>01889 <span class="comment">                   &lt;variant field&gt;.  */</span>
<a name="l01890"></a>01890 
<a name="l01891"></a>01891                 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *v = NULL;
<a name="l01892"></a>01892                 <span class="keywordtype">int</span> new_offset = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l01893"></a>01893 
<a name="l01894"></a>01894                 <span class="comment">/* This is pretty gross.  In G++, the offset in an</span>
<a name="l01895"></a>01895 <span class="comment">                   anonymous union is relative to the beginning of the</span>
<a name="l01896"></a>01896 <span class="comment">                   enclosing struct.  In the GNU Chill (now deleted</span>
<a name="l01897"></a>01897 <span class="comment">                   from GDB) implementation of variant records, the</span>
<a name="l01898"></a>01898 <span class="comment">                   bitpos is zero in an anonymous union field, so we</span>
<a name="l01899"></a>01899 <span class="comment">                   have to add the offset of the union here.  */</span>
<a name="l01900"></a>01900                 <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (field_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l01901"></a>01901                     || (<a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (field_type) &gt; 0
<a name="l01902"></a>01902                         &amp;&amp; <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (field_type, 0) == 0))
<a name="l01903"></a>01903                   new_offset += <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (type, i) / 8;
<a name="l01904"></a>01904 
<a name="l01905"></a>01905                 <a class="code" href="valops_8c.html#a0ee6d5370dfbf977ea4f397cff1ce6d0">do_search_struct_field</a> (name, arg1, new_offset, 
<a name="l01906"></a>01906                                         field_type,
<a name="l01907"></a>01907                                         looking_for_baseclass, &amp;v,
<a name="l01908"></a>01908                                         last_boffset,
<a name="l01909"></a>01909                                         outermost_type);
<a name="l01910"></a>01910                 <span class="keywordflow">if</span> (v)
<a name="l01911"></a>01911                   {
<a name="l01912"></a>01912                     *result_ptr = v;
<a name="l01913"></a>01913                     <span class="keywordflow">return</span>;
<a name="l01914"></a>01914                   }
<a name="l01915"></a>01915               }
<a name="l01916"></a>01916           }
<a name="l01917"></a>01917       }
<a name="l01918"></a>01918 
<a name="l01919"></a>01919   <span class="keywordflow">for</span> (i = 0; i &lt; nbases; i++)
<a name="l01920"></a>01920     {
<a name="l01921"></a>01921       <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *v = NULL;
<a name="l01922"></a>01922       <span class="keyword">struct </span>type *basetype = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">TYPE_BASECLASS</a> (type, i));
<a name="l01923"></a>01923       <span class="comment">/* If we are looking for baseclasses, this is what we get when</span>
<a name="l01924"></a>01924 <span class="comment">         we hit them.  But it could happen that the base part&#39;s member</span>
<a name="l01925"></a>01925 <span class="comment">         name is not yet filled in.  */</span>
<a name="l01926"></a>01926       <span class="keywordtype">int</span> found_baseclass = (looking_for_baseclass
<a name="l01927"></a>01927                              &amp;&amp; <a class="code" href="gdbtypes_8h.html#a01a3292b0c953727fb57e7b81f5dbd02">TYPE_BASECLASS_NAME</a> (type, i) != NULL
<a name="l01928"></a>01928                              &amp;&amp; (<a class="code" href="utils_8c.html#afe92387dbf8135978e7845a7dcf18003">strcmp_iw</a> (name, 
<a name="l01929"></a>01929                                             <a class="code" href="gdbtypes_8h.html#a01a3292b0c953727fb57e7b81f5dbd02">TYPE_BASECLASS_NAME</a> (type, 
<a name="l01930"></a>01930                                                                  i)) == 0));
<a name="l01931"></a>01931       <span class="keywordtype">int</span> boffset = <a class="code" href="value_8c.html#acbd6146ab9bd4c54f994a895a66f3f3d">value_embedded_offset</a> (arg1) + <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l01932"></a>01932 
<a name="l01933"></a>01933       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#acc2f1c0fb434ce574171ed5ae0d841cb">BASETYPE_VIA_VIRTUAL</a> (type, i))
<a name="l01934"></a>01934         {
<a name="l01935"></a>01935           <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *v2;
<a name="l01936"></a>01936 
<a name="l01937"></a>01937           boffset = <a class="code" href="cp-abi_8c.html#a7da6ba80818bbcc6461cdb87197ddfad">baseclass_offset</a> (type, i,
<a name="l01938"></a>01938                                       <a class="code" href="value_8c.html#a77fb759fae03d1a1c2a4e1500aa13adb">value_contents_for_printing</a> (arg1),
<a name="l01939"></a>01939                                       <a class="code" href="value_8c.html#acbd6146ab9bd4c54f994a895a66f3f3d">value_embedded_offset</a> (arg1) + offset,
<a name="l01940"></a>01940                                       <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (arg1),
<a name="l01941"></a>01941                                       arg1);
<a name="l01942"></a>01942 
<a name="l01943"></a>01943           <span class="comment">/* The virtual base class pointer might have been clobbered</span>
<a name="l01944"></a>01944 <span class="comment">             by the user program.  Make sure that it still points to a</span>
<a name="l01945"></a>01945 <span class="comment">             valid memory location.  */</span>
<a name="l01946"></a>01946 
<a name="l01947"></a>01947           boffset += <a class="code" href="value_8c.html#acbd6146ab9bd4c54f994a895a66f3f3d">value_embedded_offset</a> (arg1) + <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l01948"></a>01948           <span class="keywordflow">if</span> (boffset &lt; 0
<a name="l01949"></a>01949               || boffset &gt;= <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a23e0abd15939236dcae8b0c5c0674b1b">value_enclosing_type</a> (arg1)))
<a name="l01950"></a>01950             {
<a name="l01951"></a>01951               <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> base_addr;
<a name="l01952"></a>01952 
<a name="l01953"></a>01953               base_addr = <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (arg1) + boffset;
<a name="l01954"></a>01954               v2 = <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (basetype, base_addr);
<a name="l01955"></a>01955               <span class="keywordflow">if</span> (<a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (base_addr, 
<a name="l01956"></a>01956                                       <a class="code" href="value_8c.html#a9f59e572fabef6e1905632fb81cc00e1">value_contents_raw</a> (v2),
<a name="l01957"></a>01957                                       <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (v2))) != 0)
<a name="l01958"></a>01958                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;virtual baseclass botch&quot;</span>));
<a name="l01959"></a>01959             }
<a name="l01960"></a>01960           <span class="keywordflow">else</span>
<a name="l01961"></a>01961             {
<a name="l01962"></a>01962               v2 = <a class="code" href="value_8c.html#abe2b4f6342cfefdbb63666b6bcba636b">value_copy</a> (arg1);
<a name="l01963"></a>01963               <a class="code" href="value_8c.html#adac1b2d5054e2d7b44ea25ac1f8002f1">deprecated_set_value_type</a> (v2, basetype);
<a name="l01964"></a>01964               <a class="code" href="value_8c.html#a24d431e297ffee09519c654c96438ecc">set_value_embedded_offset</a> (v2, boffset);
<a name="l01965"></a>01965             }
<a name="l01966"></a>01966 
<a name="l01967"></a>01967           <span class="keywordflow">if</span> (found_baseclass)
<a name="l01968"></a>01968             v = v2;
<a name="l01969"></a>01969           <span class="keywordflow">else</span>
<a name="l01970"></a>01970             {
<a name="l01971"></a>01971               <a class="code" href="valops_8c.html#a0ee6d5370dfbf977ea4f397cff1ce6d0">do_search_struct_field</a> (name, v2, 0,
<a name="l01972"></a>01972                                       <a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">TYPE_BASECLASS</a> (type, i),
<a name="l01973"></a>01973                                       looking_for_baseclass,
<a name="l01974"></a>01974                                       result_ptr, last_boffset,
<a name="l01975"></a>01975                                       outermost_type);
<a name="l01976"></a>01976             }
<a name="l01977"></a>01977         }
<a name="l01978"></a>01978       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (found_baseclass)
<a name="l01979"></a>01979         v = <a class="code" href="value_8c.html#ac6e677d5cd8f7c40c20448fd7418b01c">value_primitive_field</a> (arg1, offset, i, type);
<a name="l01980"></a>01980       <span class="keywordflow">else</span>
<a name="l01981"></a>01981         {
<a name="l01982"></a>01982           <a class="code" href="valops_8c.html#a0ee6d5370dfbf977ea4f397cff1ce6d0">do_search_struct_field</a> (name, arg1,
<a name="l01983"></a>01983                                   offset + <a class="code" href="gdbtypes_8h.html#a8131e3735fa0c8a76d2876c349854b7a">TYPE_BASECLASS_BITPOS</a> (type, 
<a name="l01984"></a>01984                                                                   i) / 8,
<a name="l01985"></a>01985                                   basetype, looking_for_baseclass,
<a name="l01986"></a>01986                                   result_ptr, last_boffset,
<a name="l01987"></a>01987                                   outermost_type);
<a name="l01988"></a>01988         }
<a name="l01989"></a>01989 
<a name="l01990"></a>01990       <a class="code" href="valops_8c.html#abb7fbf7c6f78ffe5c03ca0d99d744ab2">update_search_result</a> (result_ptr, v, last_boffset,
<a name="l01991"></a>01991                             boffset, name, outermost_type);
<a name="l01992"></a>01992     }
<a name="l01993"></a>01993 }
<a name="l01994"></a>01994 
<a name="l01995"></a>01995 <span class="comment">/* Helper function used by value_struct_elt to recurse through</span>
<a name="l01996"></a>01996 <span class="comment">   baseclasses.  Look for a field NAME in ARG1.  Adjust the address of</span>
<a name="l01997"></a>01997 <span class="comment">   ARG1 by OFFSET bytes, and search in it assuming it has (class) type</span>
<a name="l01998"></a>01998 <span class="comment">   TYPE.  If found, return value, else return NULL.</span>
<a name="l01999"></a>01999 <span class="comment"></span>
<a name="l02000"></a>02000 <span class="comment">   If LOOKING_FOR_BASECLASS, then instead of looking for struct</span>
<a name="l02001"></a>02001 <span class="comment">   fields, look for a baseclass named NAME.  */</span>
<a name="l02002"></a>02002 
<a name="l02003"></a>02003 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l02004"></a><a class="code" href="valops_8c.html#aecb0e8f1755b58d860741f00dd0cadf5">02004</a> <a class="code" href="valops_8c.html#aecb0e8f1755b58d860741f00dd0cadf5">search_struct_field</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *arg1, <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>,
<a name="l02005"></a>02005                      <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keywordtype">int</span> looking_for_baseclass)
<a name="l02006"></a>02006 {
<a name="l02007"></a>02007   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *result = NULL;
<a name="l02008"></a>02008   <span class="keywordtype">int</span> boffset = 0;
<a name="l02009"></a>02009 
<a name="l02010"></a>02010   <a class="code" href="valops_8c.html#a0ee6d5370dfbf977ea4f397cff1ce6d0">do_search_struct_field</a> (name, arg1, offset, type, looking_for_baseclass,
<a name="l02011"></a>02011                           &amp;result, &amp;boffset, type);
<a name="l02012"></a>02012   <span class="keywordflow">return</span> result;
<a name="l02013"></a>02013 }
<a name="l02014"></a>02014 
<a name="l02015"></a>02015 <span class="comment">/* Helper function used by value_struct_elt to recurse through</span>
<a name="l02016"></a>02016 <span class="comment">   baseclasses.  Look for a field NAME in ARG1.  Adjust the address of</span>
<a name="l02017"></a>02017 <span class="comment">   ARG1 by OFFSET bytes, and search in it assuming it has (class) type</span>
<a name="l02018"></a>02018 <span class="comment">   TYPE.</span>
<a name="l02019"></a>02019 <span class="comment"></span>
<a name="l02020"></a>02020 <span class="comment">   If found, return value, else if name matched and args not return</span>
<a name="l02021"></a>02021 <span class="comment">   (value) -1, else return NULL.  */</span>
<a name="l02022"></a>02022 
<a name="l02023"></a>02023 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l02024"></a><a class="code" href="valops_8c.html#a272c8540923c2bc901412ab4dd8a822e">02024</a> <a class="code" href="valops_8c.html#a272c8540923c2bc901412ab4dd8a822e">search_struct_method</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **arg1p,
<a name="l02025"></a>02025                       <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **args, <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>,
<a name="l02026"></a>02026                       <span class="keywordtype">int</span> *static_memfuncp, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>)
<a name="l02027"></a>02027 {
<a name="l02028"></a>02028   <span class="keywordtype">int</span> i;
<a name="l02029"></a>02029   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *v;
<a name="l02030"></a>02030   <span class="keywordtype">int</span> name_matched = 0;
<a name="l02031"></a>02031   <span class="keywordtype">char</span> dem_opname[64];
<a name="l02032"></a>02032 
<a name="l02033"></a>02033   <a class="code" href="gdbtypes_8h.html#ae2f9348c644babaa9038b4dc18bffaac">CHECK_TYPEDEF</a> (type);
<a name="l02034"></a>02034   <span class="keywordflow">for</span> (i = <a class="code" href="gdbtypes_8h.html#a04c1a1616329be52b9a9706ddc102bd1">TYPE_NFN_FIELDS</a> (type) - 1; i &gt;= 0; i--)
<a name="l02035"></a>02035     {
<a name="l02036"></a>02036       <span class="keyword">const</span> <span class="keywordtype">char</span> *t_field_name = <a class="code" href="gdbtypes_8h.html#ad06fe1d1555d89ce87344fa6825e5642">TYPE_FN_FIELDLIST_NAME</a> (type, i);
<a name="l02037"></a>02037 
<a name="l02038"></a>02038       <span class="comment">/* FIXME!  May need to check for ARM demangling here.  */</span>
<a name="l02039"></a>02039       <span class="keywordflow">if</span> (strncmp (t_field_name, <span class="stringliteral">&quot;__&quot;</span>, 2) == 0 ||
<a name="l02040"></a>02040           strncmp (t_field_name, <span class="stringliteral">&quot;op&quot;</span>, 2) == 0 ||
<a name="l02041"></a>02041           strncmp (t_field_name, <span class="stringliteral">&quot;type&quot;</span>, 4) == 0)
<a name="l02042"></a>02042         {
<a name="l02043"></a>02043           <span class="keywordflow">if</span> (cplus_demangle_opname (t_field_name, dem_opname, DMGL_ANSI))
<a name="l02044"></a>02044             t_field_name = dem_opname;
<a name="l02045"></a>02045           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cplus_demangle_opname (t_field_name, dem_opname, 0))
<a name="l02046"></a>02046             t_field_name = dem_opname;
<a name="l02047"></a>02047         }
<a name="l02048"></a>02048       <span class="keywordflow">if</span> (t_field_name &amp;&amp; (<a class="code" href="utils_8c.html#afe92387dbf8135978e7845a7dcf18003">strcmp_iw</a> (t_field_name, name) == 0))
<a name="l02049"></a>02049         {
<a name="l02050"></a>02050           <span class="keywordtype">int</span> j = <a class="code" href="gdbtypes_8h.html#a93f192829a3feec903de135b4d53981e">TYPE_FN_FIELDLIST_LENGTH</a> (type, i) - 1;
<a name="l02051"></a>02051           <span class="keyword">struct </span>fn_field *f = <a class="code" href="gdbtypes_8h.html#a475365c72b8bba6494569379cec012df">TYPE_FN_FIELDLIST1</a> (type, i);
<a name="l02052"></a>02052 
<a name="l02053"></a>02053           name_matched = 1;
<a name="l02054"></a>02054           <a class="code" href="gdbtypes_8c.html#a104ee91f58366ea5451ad5e9ea42b327">check_stub_method_group</a> (type, i);
<a name="l02055"></a>02055           <span class="keywordflow">if</span> (j &gt; 0 &amp;&amp; args == 0)
<a name="l02056"></a>02056             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot resolve overloaded method &quot;</span>
<a name="l02057"></a>02057                      <span class="stringliteral">&quot;`%s&#39;: no arguments supplied&quot;</span>), name);
<a name="l02058"></a>02058           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j == 0 &amp;&amp; args == 0)
<a name="l02059"></a>02059             {
<a name="l02060"></a>02060               v = <a class="code" href="value_8c.html#a5d8010a9145812bfec9f7edb2483394f">value_fn_field</a> (arg1p, f, j, type, offset);
<a name="l02061"></a>02061               <span class="keywordflow">if</span> (v != NULL)
<a name="l02062"></a>02062                 <span class="keywordflow">return</span> v;
<a name="l02063"></a>02063             }
<a name="l02064"></a>02064           <span class="keywordflow">else</span>
<a name="l02065"></a>02065             <span class="keywordflow">while</span> (j &gt;= 0)
<a name="l02066"></a>02066               {
<a name="l02067"></a>02067                 <span class="keywordflow">if</span> (!<a class="code" href="valops_8c.html#a153df6d2ebd99111f79a91848d0e55ae">typecmp</a> (<a class="code" href="gdbtypes_8h.html#ab772f7a2fa3ac127cfd52c64d129ac18">TYPE_FN_FIELD_STATIC_P</a> (f, j),
<a name="l02068"></a>02068                               <a class="code" href="gdbtypes_8h.html#ac64534be7706a7ed40f5b2de42df4371">TYPE_VARARGS</a> (<a class="code" href="gdbtypes_8h.html#a76c6074ace855100086c485428668372">TYPE_FN_FIELD_TYPE</a> (f, j)),
<a name="l02069"></a>02069                               <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (<a class="code" href="gdbtypes_8h.html#a76c6074ace855100086c485428668372">TYPE_FN_FIELD_TYPE</a> (f, j)),
<a name="l02070"></a>02070                               <a class="code" href="gdbtypes_8h.html#a1b27df66ed198a941d2467943749c166">TYPE_FN_FIELD_ARGS</a> (f, j), args))
<a name="l02071"></a>02071                   {
<a name="l02072"></a>02072                     <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a7d4951372b6efd1f52238a17cef7c509">TYPE_FN_FIELD_VIRTUAL_P</a> (f, j))
<a name="l02073"></a>02073                       <span class="keywordflow">return</span> <a class="code" href="cp-abi_8c.html#a8baeee049cd8f1cccb39a0289d8085f3">value_virtual_fn_field</a> (arg1p, f, j, 
<a name="l02074"></a>02074                                                      type, offset);
<a name="l02075"></a>02075                     <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#ab772f7a2fa3ac127cfd52c64d129ac18">TYPE_FN_FIELD_STATIC_P</a> (f, j) 
<a name="l02076"></a>02076                         &amp;&amp; static_memfuncp)
<a name="l02077"></a>02077                       *static_memfuncp = 1;
<a name="l02078"></a>02078                     v = <a class="code" href="value_8c.html#a5d8010a9145812bfec9f7edb2483394f">value_fn_field</a> (arg1p, f, j, type, offset);
<a name="l02079"></a>02079                     <span class="keywordflow">if</span> (v != NULL)
<a name="l02080"></a>02080                       <span class="keywordflow">return</span> v;       
<a name="l02081"></a>02081                   }
<a name="l02082"></a>02082                 j--;
<a name="l02083"></a>02083               }
<a name="l02084"></a>02084         }
<a name="l02085"></a>02085     }
<a name="l02086"></a>02086 
<a name="l02087"></a>02087   <span class="keywordflow">for</span> (i = <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (type) - 1; i &gt;= 0; i--)
<a name="l02088"></a>02088     {
<a name="l02089"></a>02089       <span class="keywordtype">int</span> base_offset;
<a name="l02090"></a>02090       <span class="keywordtype">int</span> this_offset;
<a name="l02091"></a>02091 
<a name="l02092"></a>02092       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#acc2f1c0fb434ce574171ed5ae0d841cb">BASETYPE_VIA_VIRTUAL</a> (type, i))
<a name="l02093"></a>02093         {
<a name="l02094"></a>02094           <span class="keyword">struct </span>type *baseclass = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">TYPE_BASECLASS</a> (type, i));
<a name="l02095"></a>02095           <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *base_val;
<a name="l02096"></a>02096           <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *base_valaddr;
<a name="l02097"></a>02097 
<a name="l02098"></a>02098           <span class="comment">/* The virtual base class pointer might have been</span>
<a name="l02099"></a>02099 <span class="comment">             clobbered by the user program.  Make sure that it</span>
<a name="l02100"></a>02100 <span class="comment">            still points to a valid memory location.  */</span>
<a name="l02101"></a>02101 
<a name="l02102"></a>02102           <span class="keywordflow">if</span> (offset &lt; 0 || offset &gt;= <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type))
<a name="l02103"></a>02103             {
<a name="l02104"></a>02104               <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *tmp;
<a name="l02105"></a>02105               <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *back_to;
<a name="l02106"></a>02106               <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address;
<a name="l02107"></a>02107 
<a name="l02108"></a>02108               tmp = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (baseclass));
<a name="l02109"></a>02109               back_to = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, tmp);
<a name="l02110"></a>02110               address = <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (*arg1p);
<a name="l02111"></a>02111 
<a name="l02112"></a>02112               <span class="keywordflow">if</span> (<a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (address + offset,
<a name="l02113"></a>02113                                       tmp, <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (baseclass)) != 0)
<a name="l02114"></a>02114                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;virtual baseclass botch&quot;</span>));
<a name="l02115"></a>02115 
<a name="l02116"></a>02116               base_val = <a class="code" href="value_8c.html#ab189fd2d8ea1fe71f000581289a20e17">value_from_contents_and_address</a> (baseclass,
<a name="l02117"></a>02117                                                           tmp,
<a name="l02118"></a>02118                                                           address + offset);
<a name="l02119"></a>02119               base_valaddr = <a class="code" href="value_8c.html#a77fb759fae03d1a1c2a4e1500aa13adb">value_contents_for_printing</a> (base_val);
<a name="l02120"></a>02120               this_offset = 0;
<a name="l02121"></a>02121               <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l02122"></a>02122             }
<a name="l02123"></a>02123           <span class="keywordflow">else</span>
<a name="l02124"></a>02124             {
<a name="l02125"></a>02125               base_val = *arg1p;
<a name="l02126"></a>02126               base_valaddr = <a class="code" href="value_8c.html#a77fb759fae03d1a1c2a4e1500aa13adb">value_contents_for_printing</a> (*arg1p);
<a name="l02127"></a>02127               this_offset = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l02128"></a>02128             }
<a name="l02129"></a>02129 
<a name="l02130"></a>02130           base_offset = <a class="code" href="cp-abi_8c.html#a7da6ba80818bbcc6461cdb87197ddfad">baseclass_offset</a> (type, i, base_valaddr,
<a name="l02131"></a>02131                                           this_offset, <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (base_val),
<a name="l02132"></a>02132                                           base_val);
<a name="l02133"></a>02133         }
<a name="l02134"></a>02134       <span class="keywordflow">else</span>
<a name="l02135"></a>02135         {
<a name="l02136"></a>02136           base_offset = <a class="code" href="gdbtypes_8h.html#a8131e3735fa0c8a76d2876c349854b7a">TYPE_BASECLASS_BITPOS</a> (type, i) / 8;
<a name="l02137"></a>02137         }
<a name="l02138"></a>02138       v = <a class="code" href="valops_8c.html#a272c8540923c2bc901412ab4dd8a822e">search_struct_method</a> (name, arg1p, args, base_offset + offset,
<a name="l02139"></a>02139                                 static_memfuncp, <a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">TYPE_BASECLASS</a> (type, i));
<a name="l02140"></a>02140       <span class="keywordflow">if</span> (v == (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *) - 1)
<a name="l02141"></a>02141         {
<a name="l02142"></a>02142           name_matched = 1;
<a name="l02143"></a>02143         }
<a name="l02144"></a>02144       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (v)
<a name="l02145"></a>02145         {
<a name="l02146"></a>02146           <span class="comment">/* FIXME-bothner:  Why is this commented out?  Why is it here?  */</span>
<a name="l02147"></a>02147           <span class="comment">/* *arg1p = arg1_tmp; */</span>
<a name="l02148"></a>02148           <span class="keywordflow">return</span> v;
<a name="l02149"></a>02149         }
<a name="l02150"></a>02150     }
<a name="l02151"></a>02151   <span class="keywordflow">if</span> (name_matched)
<a name="l02152"></a>02152     <span class="keywordflow">return</span> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *) - 1;
<a name="l02153"></a>02153   <span class="keywordflow">else</span>
<a name="l02154"></a>02154     <span class="keywordflow">return</span> NULL;
<a name="l02155"></a>02155 }
<a name="l02156"></a>02156 
<a name="l02157"></a>02157 <span class="comment">/* Given *ARGP, a value of type (pointer to a)* structure/union,</span>
<a name="l02158"></a>02158 <span class="comment">   extract the component named NAME from the ultimate target</span>
<a name="l02159"></a>02159 <span class="comment">   structure/union and return it as a value with its appropriate type.</span>
<a name="l02160"></a>02160 <span class="comment">   ERR is used in the error message if *ARGP&#39;s type is wrong.</span>
<a name="l02161"></a>02161 <span class="comment"></span>
<a name="l02162"></a>02162 <span class="comment">   C++: ARGS is a list of argument types to aid in the selection of</span>
<a name="l02163"></a>02163 <span class="comment">   an appropriate method.  Also, handle derived types.</span>
<a name="l02164"></a>02164 <span class="comment"></span>
<a name="l02165"></a>02165 <span class="comment">   STATIC_MEMFUNCP, if non-NULL, points to a caller-supplied location</span>
<a name="l02166"></a>02166 <span class="comment">   where the truthvalue of whether the function that was resolved was</span>
<a name="l02167"></a>02167 <span class="comment">   a static member function or not is stored.</span>
<a name="l02168"></a>02168 <span class="comment"></span>
<a name="l02169"></a>02169 <span class="comment">   ERR is an error message to be printed in case the field is not</span>
<a name="l02170"></a>02170 <span class="comment">   found.  */</span>
<a name="l02171"></a>02171 
<a name="l02172"></a>02172 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l02173"></a><a class="code" href="value_8h.html#a6abb19142201b9964d661edfd4d8a058">02173</a> <a class="code" href="valops_8c.html#a6abb19142201b9964d661edfd4d8a058">value_struct_elt</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **argp, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **args,
<a name="l02174"></a>02174                   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keywordtype">int</span> *static_memfuncp, <span class="keyword">const</span> <span class="keywordtype">char</span> *err)
<a name="l02175"></a>02175 {
<a name="l02176"></a>02176   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *t;
<a name="l02177"></a>02177   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *v;
<a name="l02178"></a>02178 
<a name="l02179"></a>02179   *argp = <a class="code" href="value_8c.html#a773e1b64380b836763411d405aa758f1">coerce_array</a> (*argp);
<a name="l02180"></a>02180 
<a name="l02181"></a>02181   t = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (*argp));
<a name="l02182"></a>02182 
<a name="l02183"></a>02183   <span class="comment">/* Follow pointers until we get to a non-pointer.  */</span>
<a name="l02184"></a>02184 
<a name="l02185"></a>02185   <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a> || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l02186"></a>02186     {
<a name="l02187"></a>02187       *argp = <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (*argp);
<a name="l02188"></a>02188       <span class="comment">/* Don&#39;t coerce fn pointer to fn and then back again!  */</span>
<a name="l02189"></a>02189       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (*argp))) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>)
<a name="l02190"></a>02190         *argp = <a class="code" href="value_8c.html#a773e1b64380b836763411d405aa758f1">coerce_array</a> (*argp);
<a name="l02191"></a>02191       t = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (*argp));
<a name="l02192"></a>02192     }
<a name="l02193"></a>02193 
<a name="l02194"></a>02194   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l02195"></a>02195       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l02196"></a>02196     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attempt to extract a component of a value that is not a %s.&quot;</span>),
<a name="l02197"></a>02197            err);
<a name="l02198"></a>02198 
<a name="l02199"></a>02199   <span class="comment">/* Assume it&#39;s not, unless we see that it is.  */</span>
<a name="l02200"></a>02200   <span class="keywordflow">if</span> (static_memfuncp)
<a name="l02201"></a>02201     *static_memfuncp = 0;
<a name="l02202"></a>02202 
<a name="l02203"></a>02203   <span class="keywordflow">if</span> (!args)
<a name="l02204"></a>02204     {
<a name="l02205"></a>02205       <span class="comment">/* if there are no arguments ...do this...  */</span>
<a name="l02206"></a>02206 
<a name="l02207"></a>02207       <span class="comment">/* Try as a field first, because if we succeed, there is less</span>
<a name="l02208"></a>02208 <span class="comment">         work to be done.  */</span>
<a name="l02209"></a>02209       v = <a class="code" href="valops_8c.html#aecb0e8f1755b58d860741f00dd0cadf5">search_struct_field</a> (name, *argp, 0, t, 0);
<a name="l02210"></a>02210       <span class="keywordflow">if</span> (v)
<a name="l02211"></a>02211         <span class="keywordflow">return</span> v;
<a name="l02212"></a>02212 
<a name="l02213"></a>02213       <span class="comment">/* C++: If it was not found as a data field, then try to</span>
<a name="l02214"></a>02214 <span class="comment">         return it as a pointer to a method.  */</span>
<a name="l02215"></a>02215       v = <a class="code" href="valops_8c.html#a272c8540923c2bc901412ab4dd8a822e">search_struct_method</a> (name, argp, args, 0, 
<a name="l02216"></a>02216                                 static_memfuncp, t);
<a name="l02217"></a>02217 
<a name="l02218"></a>02218       <span class="keywordflow">if</span> (v == (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *) - 1)
<a name="l02219"></a>02219         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot take address of method %s.&quot;</span>), name);
<a name="l02220"></a>02220       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (v == 0)
<a name="l02221"></a>02221         {
<a name="l02222"></a>02222           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a04c1a1616329be52b9a9706ddc102bd1">TYPE_NFN_FIELDS</a> (t))
<a name="l02223"></a>02223             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;There is no member or method named %s.&quot;</span>), name);
<a name="l02224"></a>02224           <span class="keywordflow">else</span>
<a name="l02225"></a>02225             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;There is no member named %s.&quot;</span>), name);
<a name="l02226"></a>02226         }
<a name="l02227"></a>02227       <span class="keywordflow">return</span> v;
<a name="l02228"></a>02228     }
<a name="l02229"></a>02229 
<a name="l02230"></a>02230     v = <a class="code" href="valops_8c.html#a272c8540923c2bc901412ab4dd8a822e">search_struct_method</a> (name, argp, args, 0, 
<a name="l02231"></a>02231                               static_memfuncp, t);
<a name="l02232"></a>02232   
<a name="l02233"></a>02233   <span class="keywordflow">if</span> (v == (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *) - 1)
<a name="l02234"></a>02234     {
<a name="l02235"></a>02235       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;One of the arguments you tried to pass to %s could not &quot;</span>
<a name="l02236"></a>02236                <span class="stringliteral">&quot;be converted to what the function wants.&quot;</span>), name);
<a name="l02237"></a>02237     }
<a name="l02238"></a>02238   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (v == 0)
<a name="l02239"></a>02239     {
<a name="l02240"></a>02240       <span class="comment">/* See if user tried to invoke data as function.  If so, hand it</span>
<a name="l02241"></a>02241 <span class="comment">         back.  If it&#39;s not callable (i.e., a pointer to function),</span>
<a name="l02242"></a>02242 <span class="comment">         gdb should give an error.  */</span>
<a name="l02243"></a>02243       v = <a class="code" href="valops_8c.html#aecb0e8f1755b58d860741f00dd0cadf5">search_struct_field</a> (name, *argp, 0, t, 0);
<a name="l02244"></a>02244       <span class="comment">/* If we found an ordinary field, then it is not a method call.</span>
<a name="l02245"></a>02245 <span class="comment">         So, treat it as if it were a static member function.  */</span>
<a name="l02246"></a>02246       <span class="keywordflow">if</span> (v &amp;&amp; static_memfuncp)
<a name="l02247"></a>02247         *static_memfuncp = 1;
<a name="l02248"></a>02248     }
<a name="l02249"></a>02249 
<a name="l02250"></a>02250   <span class="keywordflow">if</span> (!v)
<a name="l02251"></a>02251     <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>,
<a name="l02252"></a>02252                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Structure has no component named %s.&quot;</span>), name);
<a name="l02253"></a>02253   <span class="keywordflow">return</span> v;
<a name="l02254"></a>02254 }
<a name="l02255"></a>02255 
<a name="l02256"></a>02256 <span class="comment">/* Search through the methods of an object (and its bases) to find a</span>
<a name="l02257"></a>02257 <span class="comment">   specified method.  Return the pointer to the fn_field list of</span>
<a name="l02258"></a>02258 <span class="comment">   overloaded instances.</span>
<a name="l02259"></a>02259 <span class="comment"></span>
<a name="l02260"></a>02260 <span class="comment">   Helper function for value_find_oload_list.</span>
<a name="l02261"></a>02261 <span class="comment">   ARGP is a pointer to a pointer to a value (the object).</span>
<a name="l02262"></a>02262 <span class="comment">   METHOD is a string containing the method name.</span>
<a name="l02263"></a>02263 <span class="comment">   OFFSET is the offset within the value.</span>
<a name="l02264"></a>02264 <span class="comment">   TYPE is the assumed type of the object.</span>
<a name="l02265"></a>02265 <span class="comment">   NUM_FNS is the number of overloaded instances.</span>
<a name="l02266"></a>02266 <span class="comment">   BASETYPE is set to the actual type of the subobject where the</span>
<a name="l02267"></a>02267 <span class="comment">      method is found.</span>
<a name="l02268"></a>02268 <span class="comment">   BOFFSET is the offset of the base subobject where the method is found.  */</span>
<a name="l02269"></a>02269 
<a name="l02270"></a>02270 <span class="keyword">static</span> <span class="keyword">struct </span>fn_field *
<a name="l02271"></a><a class="code" href="valops_8c.html#a189e79c34c5e7329d73b5d80dd20384a">02271</a> <a class="code" href="valops_8c.html#a189e79c34c5e7329d73b5d80dd20384a">find_method_list</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **argp, <span class="keyword">const</span> <span class="keywordtype">char</span> *method,
<a name="l02272"></a>02272                   <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keywordtype">int</span> *num_fns,
<a name="l02273"></a>02273                   <span class="keyword">struct</span> type **basetype, <span class="keywordtype">int</span> *boffset)
<a name="l02274"></a>02274 {
<a name="l02275"></a>02275   <span class="keywordtype">int</span> i;
<a name="l02276"></a>02276   <span class="keyword">struct </span>fn_field *f;
<a name="l02277"></a>02277   <a class="code" href="gdbtypes_8h.html#ae2f9348c644babaa9038b4dc18bffaac">CHECK_TYPEDEF</a> (type);
<a name="l02278"></a>02278 
<a name="l02279"></a>02279   *num_fns = 0;
<a name="l02280"></a>02280 
<a name="l02281"></a>02281   <span class="comment">/* First check in object itself.  */</span>
<a name="l02282"></a>02282   <span class="keywordflow">for</span> (i = <a class="code" href="gdbtypes_8h.html#a04c1a1616329be52b9a9706ddc102bd1">TYPE_NFN_FIELDS</a> (type) - 1; i &gt;= 0; i--)
<a name="l02283"></a>02283     {
<a name="l02284"></a>02284       <span class="comment">/* pai: FIXME What about operators and type conversions?  */</span>
<a name="l02285"></a>02285       <span class="keyword">const</span> <span class="keywordtype">char</span> *fn_field_name = <a class="code" href="gdbtypes_8h.html#ad06fe1d1555d89ce87344fa6825e5642">TYPE_FN_FIELDLIST_NAME</a> (type, i);
<a name="l02286"></a>02286 
<a name="l02287"></a>02287       <span class="keywordflow">if</span> (fn_field_name &amp;&amp; (<a class="code" href="utils_8c.html#afe92387dbf8135978e7845a7dcf18003">strcmp_iw</a> (fn_field_name, method) == 0))
<a name="l02288"></a>02288         {
<a name="l02289"></a>02289           <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a> = <a class="code" href="gdbtypes_8h.html#a93f192829a3feec903de135b4d53981e">TYPE_FN_FIELDLIST_LENGTH</a> (type, i);
<a name="l02290"></a>02290           <span class="keyword">struct </span>fn_field *f = <a class="code" href="gdbtypes_8h.html#a475365c72b8bba6494569379cec012df">TYPE_FN_FIELDLIST1</a> (type, i);
<a name="l02291"></a>02291 
<a name="l02292"></a>02292           *num_fns = <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l02293"></a>02293           *basetype = <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l02294"></a>02294           *boffset = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l02295"></a>02295 
<a name="l02296"></a>02296           <span class="comment">/* Resolve any stub methods.  */</span>
<a name="l02297"></a>02297           <a class="code" href="gdbtypes_8c.html#a104ee91f58366ea5451ad5e9ea42b327">check_stub_method_group</a> (type, i);
<a name="l02298"></a>02298 
<a name="l02299"></a>02299           <span class="keywordflow">return</span> f;
<a name="l02300"></a>02300         }
<a name="l02301"></a>02301     }
<a name="l02302"></a>02302 
<a name="l02303"></a>02303   <span class="comment">/* Not found in object, check in base subobjects.  */</span>
<a name="l02304"></a>02304   <span class="keywordflow">for</span> (i = <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (type) - 1; i &gt;= 0; i--)
<a name="l02305"></a>02305     {
<a name="l02306"></a>02306       <span class="keywordtype">int</span> base_offset;
<a name="l02307"></a>02307 
<a name="l02308"></a>02308       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#acc2f1c0fb434ce574171ed5ae0d841cb">BASETYPE_VIA_VIRTUAL</a> (type, i))
<a name="l02309"></a>02309         {
<a name="l02310"></a>02310           base_offset = <a class="code" href="cp-abi_8c.html#a7da6ba80818bbcc6461cdb87197ddfad">baseclass_offset</a> (type, i,
<a name="l02311"></a>02311                                           <a class="code" href="value_8c.html#a77fb759fae03d1a1c2a4e1500aa13adb">value_contents_for_printing</a> (*argp),
<a name="l02312"></a>02312                                           <a class="code" href="value_8c.html#aff69bf52c3773e7afc5f95b6ef302b1c">value_offset</a> (*argp) + offset,
<a name="l02313"></a>02313                                           <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (*argp), *argp);
<a name="l02314"></a>02314         }
<a name="l02315"></a>02315       <span class="keywordflow">else</span> <span class="comment">/* Non-virtual base, simply use bit position from debug</span>
<a name="l02316"></a>02316 <span class="comment">              info.  */</span>
<a name="l02317"></a>02317         {
<a name="l02318"></a>02318           base_offset = <a class="code" href="gdbtypes_8h.html#a8131e3735fa0c8a76d2876c349854b7a">TYPE_BASECLASS_BITPOS</a> (type, i) / 8;
<a name="l02319"></a>02319         }
<a name="l02320"></a>02320       f = <a class="code" href="valops_8c.html#a189e79c34c5e7329d73b5d80dd20384a">find_method_list</a> (argp, method, base_offset + offset,
<a name="l02321"></a>02321                             <a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">TYPE_BASECLASS</a> (type, i), num_fns, 
<a name="l02322"></a>02322                             basetype, boffset);
<a name="l02323"></a>02323       <span class="keywordflow">if</span> (f)
<a name="l02324"></a>02324         <span class="keywordflow">return</span> f;
<a name="l02325"></a>02325     }
<a name="l02326"></a>02326   <span class="keywordflow">return</span> NULL;
<a name="l02327"></a>02327 }
<a name="l02328"></a>02328 
<a name="l02329"></a>02329 <span class="comment">/* Return the list of overloaded methods of a specified name.</span>
<a name="l02330"></a>02330 <span class="comment"></span>
<a name="l02331"></a>02331 <span class="comment">   ARGP is a pointer to a pointer to a value (the object).</span>
<a name="l02332"></a>02332 <span class="comment">   METHOD is the method name.</span>
<a name="l02333"></a>02333 <span class="comment">   OFFSET is the offset within the value contents.</span>
<a name="l02334"></a>02334 <span class="comment">   NUM_FNS is the number of overloaded instances.</span>
<a name="l02335"></a>02335 <span class="comment">   BASETYPE is set to the type of the base subobject that defines the</span>
<a name="l02336"></a>02336 <span class="comment">      method.</span>
<a name="l02337"></a>02337 <span class="comment">   BOFFSET is the offset of the base subobject which defines the method.  */</span>
<a name="l02338"></a>02338 
<a name="l02339"></a>02339 <span class="keyword">static</span> <span class="keyword">struct </span>fn_field *
<a name="l02340"></a><a class="code" href="valops_8c.html#ac1c4512e3957cfb8e1225a9116f8d453">02340</a> <a class="code" href="valops_8c.html#ac1c4512e3957cfb8e1225a9116f8d453">value_find_oload_method_list</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **argp, <span class="keyword">const</span> <span class="keywordtype">char</span> *method,
<a name="l02341"></a>02341                               <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <span class="keywordtype">int</span> *num_fns, 
<a name="l02342"></a>02342                               <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **basetype, <span class="keywordtype">int</span> *boffset)
<a name="l02343"></a>02343 {
<a name="l02344"></a>02344   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *t;
<a name="l02345"></a>02345 
<a name="l02346"></a>02346   t = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (*argp));
<a name="l02347"></a>02347 
<a name="l02348"></a>02348   <span class="comment">/* Code snarfed from value_struct_elt.  */</span>
<a name="l02349"></a>02349   <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a> || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l02350"></a>02350     {
<a name="l02351"></a>02351       *argp = <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (*argp);
<a name="l02352"></a>02352       <span class="comment">/* Don&#39;t coerce fn pointer to fn and then back again!  */</span>
<a name="l02353"></a>02353       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (*argp))) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>)
<a name="l02354"></a>02354         *argp = <a class="code" href="value_8c.html#a773e1b64380b836763411d405aa758f1">coerce_array</a> (*argp);
<a name="l02355"></a>02355       t = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (*argp));
<a name="l02356"></a>02356     }
<a name="l02357"></a>02357 
<a name="l02358"></a>02358   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l02359"></a>02359       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l02360"></a>02360     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attempt to extract a component of a &quot;</span>
<a name="l02361"></a>02361              <span class="stringliteral">&quot;value that is not a struct or union&quot;</span>));
<a name="l02362"></a>02362 
<a name="l02363"></a>02363   <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a189e79c34c5e7329d73b5d80dd20384a">find_method_list</a> (argp, method, 0, t, num_fns, 
<a name="l02364"></a>02364                            basetype, boffset);
<a name="l02365"></a>02365 }
<a name="l02366"></a>02366 
<a name="l02367"></a>02367 <span class="comment">/* Given an array of arguments (ARGS) (which includes an</span>
<a name="l02368"></a>02368 <span class="comment">   entry for &quot;this&quot; in the case of C++ methods), the number of</span>
<a name="l02369"></a>02369 <span class="comment">   arguments NARGS, the NAME of a function, and whether it&#39;s a method or</span>
<a name="l02370"></a>02370 <span class="comment">   not (METHOD), find the best function that matches on the argument types</span>
<a name="l02371"></a>02371 <span class="comment">   according to the overload resolution rules.</span>
<a name="l02372"></a>02372 <span class="comment"></span>
<a name="l02373"></a>02373 <span class="comment">   METHOD can be one of three values:</span>
<a name="l02374"></a>02374 <span class="comment">     NON_METHOD for non-member functions.</span>
<a name="l02375"></a>02375 <span class="comment">     METHOD: for member functions.</span>
<a name="l02376"></a>02376 <span class="comment">     BOTH: used for overload resolution of operators where the</span>
<a name="l02377"></a>02377 <span class="comment">       candidates are expected to be either member or non member</span>
<a name="l02378"></a>02378 <span class="comment">       functions.  In this case the first argument ARGTYPES</span>
<a name="l02379"></a>02379 <span class="comment">       (representing &#39;this&#39;) is expected to be a reference to the</span>
<a name="l02380"></a>02380 <span class="comment">       target object, and will be dereferenced when attempting the</span>
<a name="l02381"></a>02381 <span class="comment">       non-member search.</span>
<a name="l02382"></a>02382 <span class="comment"></span>
<a name="l02383"></a>02383 <span class="comment">   In the case of class methods, the parameter OBJ is an object value</span>
<a name="l02384"></a>02384 <span class="comment">   in which to search for overloaded methods.</span>
<a name="l02385"></a>02385 <span class="comment"></span>
<a name="l02386"></a>02386 <span class="comment">   In the case of non-method functions, the parameter FSYM is a symbol</span>
<a name="l02387"></a>02387 <span class="comment">   corresponding to one of the overloaded functions.</span>
<a name="l02388"></a>02388 <span class="comment"></span>
<a name="l02389"></a>02389 <span class="comment">   Return value is an integer: 0 -&gt; good match, 10 -&gt; debugger applied</span>
<a name="l02390"></a>02390 <span class="comment">   non-standard coercions, 100 -&gt; incompatible.</span>
<a name="l02391"></a>02391 <span class="comment"></span>
<a name="l02392"></a>02392 <span class="comment">   If a method is being searched for, VALP will hold the value.</span>
<a name="l02393"></a>02393 <span class="comment">   If a non-method is being searched for, SYMP will hold the symbol </span>
<a name="l02394"></a>02394 <span class="comment">   for it.</span>
<a name="l02395"></a>02395 <span class="comment"></span>
<a name="l02396"></a>02396 <span class="comment">   If a method is being searched for, and it is a static method,</span>
<a name="l02397"></a>02397 <span class="comment">   then STATICP will point to a non-zero value.</span>
<a name="l02398"></a>02398 <span class="comment"></span>
<a name="l02399"></a>02399 <span class="comment">   If NO_ADL argument dependent lookup is disabled.  This is used to prevent</span>
<a name="l02400"></a>02400 <span class="comment">   ADL overload candidates when performing overload resolution for a fully</span>
<a name="l02401"></a>02401 <span class="comment">   qualified name.</span>
<a name="l02402"></a>02402 <span class="comment"></span>
<a name="l02403"></a>02403 <span class="comment">   Note: This function does *not* check the value of</span>
<a name="l02404"></a>02404 <span class="comment">   overload_resolution.  Caller must check it to see whether overload</span>
<a name="l02405"></a>02405 <span class="comment">   resolution is permitted.  */</span>
<a name="l02406"></a>02406 
<a name="l02407"></a>02407 <span class="keywordtype">int</span>
<a name="l02408"></a><a class="code" href="value_8h.html#a0feb38fe4da3ac644db23302ea40301c">02408</a> <a class="code" href="valops_8c.html#a0feb38fe4da3ac644db23302ea40301c">find_overload_match</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **args, <span class="keywordtype">int</span> nargs,
<a name="l02409"></a>02409                      <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keyword">enum</span> <a class="code" href="value_8h.html#ae494996768698ec566510613d30fd99c">oload_search_type</a> method,
<a name="l02410"></a>02410                      <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **objp, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *fsym,
<a name="l02411"></a>02411                      <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **valp, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> **symp, 
<a name="l02412"></a>02412                      <span class="keywordtype">int</span> *staticp, <span class="keyword">const</span> <span class="keywordtype">int</span> no_adl)
<a name="l02413"></a>02413 {
<a name="l02414"></a>02414   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *obj = (objp ? *objp : NULL);
<a name="l02415"></a>02415   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *obj_type = obj ? <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (obj) : NULL;
<a name="l02416"></a>02416   <span class="comment">/* Index of best overloaded function.  */</span>
<a name="l02417"></a>02417   <span class="keywordtype">int</span> func_oload_champ = -1;
<a name="l02418"></a>02418   <span class="keywordtype">int</span> method_oload_champ = -1;
<a name="l02419"></a>02419 
<a name="l02420"></a>02420   <span class="comment">/* The measure for the current best match.  */</span>
<a name="l02421"></a>02421   <span class="keyword">struct </span><a class="code" href="structbadness__vector.html">badness_vector</a> *method_badness = NULL;
<a name="l02422"></a>02422   <span class="keyword">struct </span><a class="code" href="structbadness__vector.html">badness_vector</a> *func_badness = NULL;
<a name="l02423"></a>02423 
<a name="l02424"></a>02424   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *temp = obj;
<a name="l02425"></a>02425   <span class="comment">/* For methods, the list of overloaded methods.  */</span>
<a name="l02426"></a>02426   <span class="keyword">struct </span>fn_field *fns_ptr = NULL;
<a name="l02427"></a>02427   <span class="comment">/* For non-methods, the list of overloaded function symbols.  */</span>
<a name="l02428"></a>02428   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> **oload_syms = NULL;
<a name="l02429"></a>02429   <span class="comment">/* Number of overloaded instances being considered.  */</span>
<a name="l02430"></a>02430   <span class="keywordtype">int</span> num_fns = 0;
<a name="l02431"></a>02431   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *basetype = NULL;
<a name="l02432"></a>02432   <span class="keywordtype">int</span> boffset;
<a name="l02433"></a>02433 
<a name="l02434"></a>02434   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="cleanups_8c.html#a125d335ea866e3abcc1a7fb305e2f965">all_cleanups</a> = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, NULL);
<a name="l02435"></a>02435 
<a name="l02436"></a>02436   <span class="keyword">const</span> <span class="keywordtype">char</span> *obj_type_name = NULL;
<a name="l02437"></a>02437   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name = NULL;
<a name="l02438"></a>02438   <span class="keyword">enum</span> <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7">oload_classification</a> match_quality;
<a name="l02439"></a>02439   <span class="keyword">enum</span> <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7">oload_classification</a> method_match_quality = <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7a1d5787f0d18fdb7422615b7c08562710">INCOMPATIBLE</a>;
<a name="l02440"></a>02440   <span class="keyword">enum</span> <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7">oload_classification</a> func_match_quality = <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7a1d5787f0d18fdb7422615b7c08562710">INCOMPATIBLE</a>;
<a name="l02441"></a>02441 
<a name="l02442"></a>02442   <span class="comment">/* Get the list of overloaded methods or functions.  */</span>
<a name="l02443"></a>02443   <span class="keywordflow">if</span> (method == <a class="code" href="value_8h.html#ae494996768698ec566510613d30fd99caab8ec12ae9fe16e1151412938f611a19">METHOD</a> || method == <a class="code" href="value_8h.html#ae494996768698ec566510613d30fd99ca627abe5a430420baf29ebe1940a7f2fb">BOTH</a>)
<a name="l02444"></a>02444     {
<a name="l02445"></a>02445       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (obj);
<a name="l02446"></a>02446 
<a name="l02447"></a>02447       <span class="comment">/* OBJ may be a pointer value rather than the object itself.  */</span>
<a name="l02448"></a>02448       obj = <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (obj);
<a name="l02449"></a>02449       <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (value_type (obj))) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l02450"></a>02450         obj = <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (<a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (obj));
<a name="l02451"></a>02451       obj_type_name = <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (value_type (obj));
<a name="l02452"></a>02452 
<a name="l02453"></a>02453       <span class="comment">/* First check whether this is a data member, e.g. a pointer to</span>
<a name="l02454"></a>02454 <span class="comment">         a function.  */</span>
<a name="l02455"></a>02455       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (value_type (obj))) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>)
<a name="l02456"></a>02456         {
<a name="l02457"></a>02457           *valp = <a class="code" href="valops_8c.html#aecb0e8f1755b58d860741f00dd0cadf5">search_struct_field</a> (name, obj, 0,
<a name="l02458"></a>02458                                        <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (value_type (obj)), 0);
<a name="l02459"></a>02459           <span class="keywordflow">if</span> (*valp)
<a name="l02460"></a>02460             {
<a name="l02461"></a>02461               *staticp = 1;
<a name="l02462"></a>02462               <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (all_cleanups);
<a name="l02463"></a>02463               <span class="keywordflow">return</span> 0;
<a name="l02464"></a>02464             }
<a name="l02465"></a>02465         }
<a name="l02466"></a>02466 
<a name="l02467"></a>02467       <span class="comment">/* Retrieve the list of methods with the name NAME.  */</span>
<a name="l02468"></a>02468       fns_ptr = <a class="code" href="valops_8c.html#ac1c4512e3957cfb8e1225a9116f8d453">value_find_oload_method_list</a> (&amp;temp, name, 
<a name="l02469"></a>02469                                               0, &amp;num_fns, 
<a name="l02470"></a>02470                                               &amp;basetype, &amp;boffset);
<a name="l02471"></a>02471       <span class="comment">/* If this is a method only search, and no methods were found</span>
<a name="l02472"></a>02472 <span class="comment">         the search has faild.  */</span>
<a name="l02473"></a>02473       <span class="keywordflow">if</span> (method == <a class="code" href="value_8h.html#ae494996768698ec566510613d30fd99caab8ec12ae9fe16e1151412938f611a19">METHOD</a> &amp;&amp; (!fns_ptr || !num_fns))
<a name="l02474"></a>02474         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Couldn&#39;t find method %s%s%s&quot;</span>),
<a name="l02475"></a>02475                obj_type_name,
<a name="l02476"></a>02476                (obj_type_name &amp;&amp; *obj_type_name) ? <span class="stringliteral">&quot;::&quot;</span> : <span class="stringliteral">&quot;&quot;</span>,
<a name="l02477"></a>02477                name);
<a name="l02478"></a>02478       <span class="comment">/* If we are dealing with stub method types, they should have</span>
<a name="l02479"></a>02479 <span class="comment">         been resolved by find_method_list via</span>
<a name="l02480"></a>02480 <span class="comment">         value_find_oload_method_list above.  */</span>
<a name="l02481"></a>02481       <span class="keywordflow">if</span> (fns_ptr)
<a name="l02482"></a>02482         {
<a name="l02483"></a>02483           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a9c3fa31c69cb13e091817b41616af6f1">TYPE_DOMAIN_TYPE</a> (fns_ptr[0].<a class="code" href="structtype.html">type</a>) != NULL);
<a name="l02484"></a>02484           method_oload_champ = <a class="code" href="valops_8c.html#a7f4c90439e40cce6113426c5b25e53c6">find_oload_champ</a> (args, nargs, method,
<a name="l02485"></a>02485                                                  num_fns, fns_ptr,
<a name="l02486"></a>02486                                                  oload_syms, &amp;method_badness);
<a name="l02487"></a>02487 
<a name="l02488"></a>02488           method_match_quality =
<a name="l02489"></a>02489               <a class="code" href="valops_8c.html#a60d383f4b94d6281a9be1ddc9035bab4">classify_oload_match</a> (method_badness, nargs,
<a name="l02490"></a>02490                                     <a class="code" href="valops_8c.html#a53c5ca67792b188788711efbc1ffac76">oload_method_static</a> (method, fns_ptr,
<a name="l02491"></a>02491                                                          method_oload_champ));
<a name="l02492"></a>02492 
<a name="l02493"></a>02493           <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, method_badness);
<a name="l02494"></a>02494         }
<a name="l02495"></a>02495 
<a name="l02496"></a>02496     }
<a name="l02497"></a>02497 
<a name="l02498"></a>02498   <span class="keywordflow">if</span> (method == <a class="code" href="value_8h.html#ae494996768698ec566510613d30fd99caee5dc0c7c2b254b48edb6f4a5f46f2ae">NON_METHOD</a> || method == <a class="code" href="value_8h.html#ae494996768698ec566510613d30fd99ca627abe5a430420baf29ebe1940a7f2fb">BOTH</a>)
<a name="l02499"></a>02499     {
<a name="l02500"></a>02500       <span class="keyword">const</span> <span class="keywordtype">char</span> *qualified_name = NULL;
<a name="l02501"></a>02501 
<a name="l02502"></a>02502       <span class="comment">/* If the overload match is being search for both as a method</span>
<a name="l02503"></a>02503 <span class="comment">         and non member function, the first argument must now be</span>
<a name="l02504"></a>02504 <span class="comment">         dereferenced.  */</span>
<a name="l02505"></a>02505       <span class="keywordflow">if</span> (method == <a class="code" href="value_8h.html#ae494996768698ec566510613d30fd99ca627abe5a430420baf29ebe1940a7f2fb">BOTH</a>)
<a name="l02506"></a>02506         args[0] = <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (args[0]);
<a name="l02507"></a>02507 
<a name="l02508"></a>02508       <span class="keywordflow">if</span> (fsym)
<a name="l02509"></a>02509         {
<a name="l02510"></a>02510           qualified_name = <a class="code" href="symtab_8h.html#a243e66afa96ff58a851b38f428bb3394">SYMBOL_NATURAL_NAME</a> (fsym);
<a name="l02511"></a>02511 
<a name="l02512"></a>02512           <span class="comment">/* If we have a function with a C++ name, try to extract just</span>
<a name="l02513"></a>02513 <span class="comment">             the function part.  Do not try this for non-functions (e.g.</span>
<a name="l02514"></a>02514 <span class="comment">             function pointers).  */</span>
<a name="l02515"></a>02515           <span class="keywordflow">if</span> (qualified_name
<a name="l02516"></a>02516               &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (fsym)))
<a name="l02517"></a>02517               == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>)
<a name="l02518"></a>02518             {
<a name="l02519"></a>02519               <span class="keywordtype">char</span> *temp;
<a name="l02520"></a>02520 
<a name="l02521"></a>02521               temp = <a class="code" href="cp-support_8c.html#a275dd20b2397da19cfb1eada20b61686">cp_func_name</a> (qualified_name);
<a name="l02522"></a>02522 
<a name="l02523"></a>02523               <span class="comment">/* If cp_func_name did not remove anything, the name of the</span>
<a name="l02524"></a>02524 <span class="comment">                 symbol did not include scope or argument types - it was</span>
<a name="l02525"></a>02525 <span class="comment">                 probably a C-style function.  */</span>
<a name="l02526"></a>02526               <span class="keywordflow">if</span> (temp)
<a name="l02527"></a>02527                 {
<a name="l02528"></a>02528                   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, temp);
<a name="l02529"></a>02529                   <span class="keywordflow">if</span> (strcmp (temp, qualified_name) == 0)
<a name="l02530"></a>02530                     func_name = NULL;
<a name="l02531"></a>02531                   <span class="keywordflow">else</span>
<a name="l02532"></a>02532                     func_name = temp;
<a name="l02533"></a>02533                 }
<a name="l02534"></a>02534             }
<a name="l02535"></a>02535         }
<a name="l02536"></a>02536       <span class="keywordflow">else</span>
<a name="l02537"></a>02537         {
<a name="l02538"></a>02538           func_name = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l02539"></a>02539           qualified_name = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l02540"></a>02540         }
<a name="l02541"></a>02541 
<a name="l02542"></a>02542       <span class="comment">/* If there was no C++ name, this must be a C-style function or</span>
<a name="l02543"></a>02543 <span class="comment">         not a function at all.  Just return the same symbol.  Do the</span>
<a name="l02544"></a>02544 <span class="comment">         same if cp_func_name fails for some reason.  */</span>
<a name="l02545"></a>02545       <span class="keywordflow">if</span> (func_name == NULL)
<a name="l02546"></a>02546         {
<a name="l02547"></a>02547           *symp = fsym;
<a name="l02548"></a>02548           <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (all_cleanups);
<a name="l02549"></a>02549           <span class="keywordflow">return</span> 0;
<a name="l02550"></a>02550         }
<a name="l02551"></a>02551 
<a name="l02552"></a>02552       func_oload_champ = <a class="code" href="valops_8c.html#a8c6a9c2ede1ffc9e104633727db4204e">find_oload_champ_namespace</a> (args, nargs,
<a name="l02553"></a>02553                                                      func_name,
<a name="l02554"></a>02554                                                      qualified_name,
<a name="l02555"></a>02555                                                      &amp;oload_syms,
<a name="l02556"></a>02556                                                      &amp;func_badness,
<a name="l02557"></a>02557                                                      no_adl);
<a name="l02558"></a>02558 
<a name="l02559"></a>02559       <span class="keywordflow">if</span> (func_oload_champ &gt;= 0)
<a name="l02560"></a>02560         func_match_quality = <a class="code" href="valops_8c.html#a60d383f4b94d6281a9be1ddc9035bab4">classify_oload_match</a> (func_badness, nargs, 0);
<a name="l02561"></a>02561 
<a name="l02562"></a>02562       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, oload_syms);
<a name="l02563"></a>02563       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, func_badness);
<a name="l02564"></a>02564     }
<a name="l02565"></a>02565 
<a name="l02566"></a>02566   <span class="comment">/* Did we find a match ?  */</span>
<a name="l02567"></a>02567   <span class="keywordflow">if</span> (method_oload_champ == -1 &amp;&amp; func_oload_champ == -1)
<a name="l02568"></a>02568     <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>,
<a name="l02569"></a>02569                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No symbol \&quot;%s\&quot; in current context.&quot;</span>),
<a name="l02570"></a>02570                  name);
<a name="l02571"></a>02571 
<a name="l02572"></a>02572   <span class="comment">/* If we have found both a method match and a function</span>
<a name="l02573"></a>02573 <span class="comment">     match, find out which one is better, and calculate match</span>
<a name="l02574"></a>02574 <span class="comment">     quality.  */</span>
<a name="l02575"></a>02575   <span class="keywordflow">if</span> (method_oload_champ &gt;= 0 &amp;&amp; func_oload_champ &gt;= 0)
<a name="l02576"></a>02576     {
<a name="l02577"></a>02577       <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8c.html#a00978bb926d19570635f0aa9a8b2a9f4">compare_badness</a> (func_badness, method_badness))
<a name="l02578"></a>02578         {
<a name="l02579"></a>02579           <span class="keywordflow">case</span> 0: <span class="comment">/* Top two contenders are equally good.  */</span>
<a name="l02580"></a>02580             <span class="comment">/* FIXME: GDB does not support the general ambiguous case.</span>
<a name="l02581"></a>02581 <span class="comment">             All candidates should be collected and presented the</span>
<a name="l02582"></a>02582 <span class="comment">             user.  */</span>
<a name="l02583"></a>02583             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Ambiguous overload resolution&quot;</span>));
<a name="l02584"></a>02584             <span class="keywordflow">break</span>;
<a name="l02585"></a>02585           <span class="keywordflow">case</span> 1: <span class="comment">/* Incomparable top contenders.  */</span>
<a name="l02586"></a>02586             <span class="comment">/* This is an error incompatible candidates</span>
<a name="l02587"></a>02587 <span class="comment">               should not have been proposed.  */</span>
<a name="l02588"></a>02588             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Internal error: incompatible &quot;</span>
<a name="l02589"></a>02589                      <span class="stringliteral">&quot;overload candidates proposed&quot;</span>));
<a name="l02590"></a>02590             <span class="keywordflow">break</span>;
<a name="l02591"></a>02591           <span class="keywordflow">case</span> 2: <span class="comment">/* Function champion.  */</span>
<a name="l02592"></a>02592             method_oload_champ = -1;
<a name="l02593"></a>02593             match_quality = func_match_quality;
<a name="l02594"></a>02594             <span class="keywordflow">break</span>;
<a name="l02595"></a>02595           <span class="keywordflow">case</span> 3: <span class="comment">/* Method champion.  */</span>
<a name="l02596"></a>02596             func_oload_champ = -1;
<a name="l02597"></a>02597             match_quality = method_match_quality;
<a name="l02598"></a>02598             <span class="keywordflow">break</span>;
<a name="l02599"></a>02599           <span class="keywordflow">default</span>:
<a name="l02600"></a>02600             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Internal error: unexpected overload comparison result&quot;</span>));
<a name="l02601"></a>02601             <span class="keywordflow">break</span>;
<a name="l02602"></a>02602         }
<a name="l02603"></a>02603     }
<a name="l02604"></a>02604   <span class="keywordflow">else</span>
<a name="l02605"></a>02605     {
<a name="l02606"></a>02606       <span class="comment">/* We have either a method match or a function match.  */</span>
<a name="l02607"></a>02607       <span class="keywordflow">if</span> (method_oload_champ &gt;= 0)
<a name="l02608"></a>02608         match_quality = method_match_quality;
<a name="l02609"></a>02609       <span class="keywordflow">else</span>
<a name="l02610"></a>02610         match_quality = func_match_quality;
<a name="l02611"></a>02611     }
<a name="l02612"></a>02612 
<a name="l02613"></a>02613   <span class="keywordflow">if</span> (match_quality == <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7a1d5787f0d18fdb7422615b7c08562710">INCOMPATIBLE</a>)
<a name="l02614"></a>02614     {
<a name="l02615"></a>02615       <span class="keywordflow">if</span> (method == <a class="code" href="value_8h.html#ae494996768698ec566510613d30fd99caab8ec12ae9fe16e1151412938f611a19">METHOD</a>)
<a name="l02616"></a>02616         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot resolve method %s%s%s to any overloaded instance&quot;</span>),
<a name="l02617"></a>02617                obj_type_name,
<a name="l02618"></a>02618                (obj_type_name &amp;&amp; *obj_type_name) ? <span class="stringliteral">&quot;::&quot;</span> : <span class="stringliteral">&quot;&quot;</span>,
<a name="l02619"></a>02619                name);
<a name="l02620"></a>02620       <span class="keywordflow">else</span>
<a name="l02621"></a>02621         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot resolve function %s to any overloaded instance&quot;</span>),
<a name="l02622"></a>02622                func_name);
<a name="l02623"></a>02623     }
<a name="l02624"></a>02624   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (match_quality == <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7a2e658c001901706a2e2c19f15652a417">NON_STANDARD</a>)
<a name="l02625"></a>02625     {
<a name="l02626"></a>02626       <span class="keywordflow">if</span> (method == <a class="code" href="value_8h.html#ae494996768698ec566510613d30fd99caab8ec12ae9fe16e1151412938f611a19">METHOD</a>)
<a name="l02627"></a>02627         <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Using non-standard conversion to match &quot;</span>
<a name="l02628"></a>02628                    <span class="stringliteral">&quot;method %s%s%s to supplied arguments&quot;</span>),
<a name="l02629"></a>02629                  obj_type_name,
<a name="l02630"></a>02630                  (obj_type_name &amp;&amp; *obj_type_name) ? <span class="stringliteral">&quot;::&quot;</span> : <span class="stringliteral">&quot;&quot;</span>,
<a name="l02631"></a>02631                  name);
<a name="l02632"></a>02632       <span class="keywordflow">else</span>
<a name="l02633"></a>02633         <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Using non-standard conversion to match &quot;</span>
<a name="l02634"></a>02634                    <span class="stringliteral">&quot;function %s to supplied arguments&quot;</span>),
<a name="l02635"></a>02635                  func_name);
<a name="l02636"></a>02636     }
<a name="l02637"></a>02637 
<a name="l02638"></a>02638   <span class="keywordflow">if</span> (staticp != NULL)
<a name="l02639"></a>02639     *staticp = <a class="code" href="valops_8c.html#a53c5ca67792b188788711efbc1ffac76">oload_method_static</a> (method, fns_ptr, method_oload_champ);
<a name="l02640"></a>02640 
<a name="l02641"></a>02641   <span class="keywordflow">if</span> (method_oload_champ &gt;= 0)
<a name="l02642"></a>02642     {
<a name="l02643"></a>02643       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a7d4951372b6efd1f52238a17cef7c509">TYPE_FN_FIELD_VIRTUAL_P</a> (fns_ptr, method_oload_champ))
<a name="l02644"></a>02644         *valp = <a class="code" href="cp-abi_8c.html#a8baeee049cd8f1cccb39a0289d8085f3">value_virtual_fn_field</a> (&amp;temp, fns_ptr, method_oload_champ,
<a name="l02645"></a>02645                                         basetype, boffset);
<a name="l02646"></a>02646       <span class="keywordflow">else</span>
<a name="l02647"></a>02647         *valp = <a class="code" href="value_8c.html#a5d8010a9145812bfec9f7edb2483394f">value_fn_field</a> (&amp;temp, fns_ptr, method_oload_champ,
<a name="l02648"></a>02648                                 basetype, boffset);
<a name="l02649"></a>02649     }
<a name="l02650"></a>02650   <span class="keywordflow">else</span>
<a name="l02651"></a>02651     *symp = oload_syms[func_oload_champ];
<a name="l02652"></a>02652 
<a name="l02653"></a>02653   <span class="keywordflow">if</span> (objp)
<a name="l02654"></a>02654     {
<a name="l02655"></a>02655       <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *temp_type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (value_type (temp));
<a name="l02656"></a>02656       <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *objtype = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (obj_type);
<a name="l02657"></a>02657 
<a name="l02658"></a>02658       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (temp_type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l02659"></a>02659           &amp;&amp; (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (objtype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l02660"></a>02660               || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (objtype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>))
<a name="l02661"></a>02661         {
<a name="l02662"></a>02662           temp = <a class="code" href="valops_8c.html#a29bc320305726a3cbf324189df2ca772">value_addr</a> (temp);
<a name="l02663"></a>02663         }
<a name="l02664"></a>02664       *objp = temp;
<a name="l02665"></a>02665     }
<a name="l02666"></a>02666 
<a name="l02667"></a>02667   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (all_cleanups);
<a name="l02668"></a>02668 
<a name="l02669"></a>02669   <span class="keywordflow">switch</span> (match_quality)
<a name="l02670"></a>02670     {
<a name="l02671"></a>02671     <span class="keywordflow">case</span> <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7a1d5787f0d18fdb7422615b7c08562710">INCOMPATIBLE</a>:
<a name="l02672"></a>02672       <span class="keywordflow">return</span> 100;
<a name="l02673"></a>02673     <span class="keywordflow">case</span> <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7a2e658c001901706a2e2c19f15652a417">NON_STANDARD</a>:
<a name="l02674"></a>02674       <span class="keywordflow">return</span> 10;
<a name="l02675"></a>02675     <span class="keywordflow">default</span>:                            <span class="comment">/* STANDARD */</span>
<a name="l02676"></a>02676       <span class="keywordflow">return</span> 0;
<a name="l02677"></a>02677     }
<a name="l02678"></a>02678 }
<a name="l02679"></a>02679 
<a name="l02680"></a>02680 <span class="comment">/* Find the best overload match, searching for FUNC_NAME in namespaces</span>
<a name="l02681"></a>02681 <span class="comment">   contained in QUALIFIED_NAME until it either finds a good match or</span>
<a name="l02682"></a>02682 <span class="comment">   runs out of namespaces.  It stores the overloaded functions in</span>
<a name="l02683"></a>02683 <span class="comment">   *OLOAD_SYMS, and the badness vector in *OLOAD_CHAMP_BV.  The</span>
<a name="l02684"></a>02684 <span class="comment">   calling function is responsible for freeing *OLOAD_SYMS and</span>
<a name="l02685"></a>02685 <span class="comment">   *OLOAD_CHAMP_BV.  If NO_ADL, argument dependent lookup is not </span>
<a name="l02686"></a>02686 <span class="comment">   performned.  */</span>
<a name="l02687"></a>02687 
<a name="l02688"></a>02688 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02689"></a><a class="code" href="valops_8c.html#a8c6a9c2ede1ffc9e104633727db4204e">02689</a> <a class="code" href="valops_8c.html#a8c6a9c2ede1ffc9e104633727db4204e">find_oload_champ_namespace</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **args, <span class="keywordtype">int</span> nargs,
<a name="l02690"></a>02690                             <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name,
<a name="l02691"></a>02691                             <span class="keyword">const</span> <span class="keywordtype">char</span> *qualified_name,
<a name="l02692"></a>02692                             <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> ***oload_syms,
<a name="l02693"></a>02693                             <span class="keyword">struct</span> <a class="code" href="structbadness__vector.html">badness_vector</a> **oload_champ_bv,
<a name="l02694"></a>02694                             <span class="keyword">const</span> <span class="keywordtype">int</span> no_adl)
<a name="l02695"></a>02695 {
<a name="l02696"></a>02696   <span class="keywordtype">int</span> oload_champ;
<a name="l02697"></a>02697 
<a name="l02698"></a>02698   <a class="code" href="valops_8c.html#a86c0da3243d4ffcef3dfac1337bae220">find_oload_champ_namespace_loop</a> (args, nargs,
<a name="l02699"></a>02699                                    func_name,
<a name="l02700"></a>02700                                    qualified_name, 0,
<a name="l02701"></a>02701                                    oload_syms, oload_champ_bv,
<a name="l02702"></a>02702                                    &amp;oload_champ,
<a name="l02703"></a>02703                                    no_adl);
<a name="l02704"></a>02704 
<a name="l02705"></a>02705   <span class="keywordflow">return</span> oload_champ;
<a name="l02706"></a>02706 }
<a name="l02707"></a>02707 
<a name="l02708"></a>02708 <span class="comment">/* Helper function for find_oload_champ_namespace; NAMESPACE_LEN is</span>
<a name="l02709"></a>02709 <span class="comment">   how deep we&#39;ve looked for namespaces, and the champ is stored in</span>
<a name="l02710"></a>02710 <span class="comment">   OLOAD_CHAMP.  The return value is 1 if the champ is a good one, 0</span>
<a name="l02711"></a>02711 <span class="comment">   if it isn&#39;t.  Other arguments are the same as in</span>
<a name="l02712"></a>02712 <span class="comment">   find_oload_champ_namespace</span>
<a name="l02713"></a>02713 <span class="comment"></span>
<a name="l02714"></a>02714 <span class="comment">   It is the caller&#39;s responsibility to free *OLOAD_SYMS and</span>
<a name="l02715"></a>02715 <span class="comment">   *OLOAD_CHAMP_BV.  */</span>
<a name="l02716"></a>02716 
<a name="l02717"></a>02717 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02718"></a><a class="code" href="valops_8c.html#a86c0da3243d4ffcef3dfac1337bae220">02718</a> <a class="code" href="valops_8c.html#a86c0da3243d4ffcef3dfac1337bae220">find_oload_champ_namespace_loop</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **args, <span class="keywordtype">int</span> nargs,
<a name="l02719"></a>02719                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name,
<a name="l02720"></a>02720                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *qualified_name,
<a name="l02721"></a>02721                                  <span class="keywordtype">int</span> namespace_len,
<a name="l02722"></a>02722                                  <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> ***oload_syms,
<a name="l02723"></a>02723                                  <span class="keyword">struct</span> <a class="code" href="structbadness__vector.html">badness_vector</a> **oload_champ_bv,
<a name="l02724"></a>02724                                  <span class="keywordtype">int</span> *oload_champ,
<a name="l02725"></a>02725                                  <span class="keyword">const</span> <span class="keywordtype">int</span> no_adl)
<a name="l02726"></a>02726 {
<a name="l02727"></a>02727   <span class="keywordtype">int</span> next_namespace_len = namespace_len;
<a name="l02728"></a>02728   <span class="keywordtype">int</span> searched_deeper = 0;
<a name="l02729"></a>02729   <span class="keywordtype">int</span> num_fns = 0;
<a name="l02730"></a>02730   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_cleanups;
<a name="l02731"></a>02731   <span class="keywordtype">int</span> new_oload_champ;
<a name="l02732"></a>02732   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> **new_oload_syms;
<a name="l02733"></a>02733   <span class="keyword">struct </span><a class="code" href="structbadness__vector.html">badness_vector</a> *new_oload_champ_bv;
<a name="l02734"></a>02734   <span class="keywordtype">char</span> *new_namespace;
<a name="l02735"></a>02735 
<a name="l02736"></a>02736   <span class="keywordflow">if</span> (next_namespace_len != 0)
<a name="l02737"></a>02737     {
<a name="l02738"></a>02738       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (qualified_name[next_namespace_len] == <span class="charliteral">&#39;:&#39;</span>);
<a name="l02739"></a>02739       next_namespace_len +=  2;
<a name="l02740"></a>02740     }
<a name="l02741"></a>02741   next_namespace_len +=
<a name="l02742"></a>02742     <a class="code" href="cp-support_8c.html#a9220248a41cd63dc5f0a64d5222cd623">cp_find_first_component</a> (qualified_name + next_namespace_len);
<a name="l02743"></a>02743 
<a name="l02744"></a>02744   <span class="comment">/* Initialize these to values that can safely be xfree&#39;d.  */</span>
<a name="l02745"></a>02745   *oload_syms = NULL;
<a name="l02746"></a>02746   *oload_champ_bv = NULL;
<a name="l02747"></a>02747 
<a name="l02748"></a>02748   <span class="comment">/* First, see if we have a deeper namespace we can search in.</span>
<a name="l02749"></a>02749 <span class="comment">     If we get a good match there, use it.  */</span>
<a name="l02750"></a>02750 
<a name="l02751"></a>02751   <span class="keywordflow">if</span> (qualified_name[next_namespace_len] == <span class="charliteral">&#39;:&#39;</span>)
<a name="l02752"></a>02752     {
<a name="l02753"></a>02753       searched_deeper = 1;
<a name="l02754"></a>02754 
<a name="l02755"></a>02755       <span class="keywordflow">if</span> (<a class="code" href="valops_8c.html#a86c0da3243d4ffcef3dfac1337bae220">find_oload_champ_namespace_loop</a> (args, nargs,
<a name="l02756"></a>02756                                            func_name, qualified_name,
<a name="l02757"></a>02757                                            next_namespace_len,
<a name="l02758"></a>02758                                            oload_syms, oload_champ_bv,
<a name="l02759"></a>02759                                            oload_champ, no_adl))
<a name="l02760"></a>02760         {
<a name="l02761"></a>02761           <span class="keywordflow">return</span> 1;
<a name="l02762"></a>02762         }
<a name="l02763"></a>02763     };
<a name="l02764"></a>02764 
<a name="l02765"></a>02765   <span class="comment">/* If we reach here, either we&#39;re in the deepest namespace or we</span>
<a name="l02766"></a>02766 <span class="comment">     didn&#39;t find a good match in a deeper namespace.  But, in the</span>
<a name="l02767"></a>02767 <span class="comment">     latter case, we still have a bad match in a deeper namespace;</span>
<a name="l02768"></a>02768 <span class="comment">     note that we might not find any match at all in the current</span>
<a name="l02769"></a>02769 <span class="comment">     namespace.  (There&#39;s always a match in the deepest namespace,</span>
<a name="l02770"></a>02770 <span class="comment">     because this overload mechanism only gets called if there&#39;s a</span>
<a name="l02771"></a>02771 <span class="comment">     function symbol to start off with.)  */</span>
<a name="l02772"></a>02772 
<a name="l02773"></a>02773   old_cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, *oload_syms);
<a name="l02774"></a>02774   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, *oload_champ_bv);
<a name="l02775"></a>02775   new_namespace = alloca (namespace_len + 1);
<a name="l02776"></a>02776   strncpy (new_namespace, qualified_name, namespace_len);
<a name="l02777"></a>02777   new_namespace[namespace_len] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l02778"></a>02778   new_oload_syms = <a class="code" href="cp-support_8c.html#acc44ea3d596fbf6b94b891b29194bcb7">make_symbol_overload_list</a> (func_name,
<a name="l02779"></a>02779                                               new_namespace);
<a name="l02780"></a>02780 
<a name="l02781"></a>02781   <span class="comment">/* If we have reached the deepest level perform argument</span>
<a name="l02782"></a>02782 <span class="comment">     determined lookup.  */</span>
<a name="l02783"></a>02783   <span class="keywordflow">if</span> (!searched_deeper &amp;&amp; !no_adl)
<a name="l02784"></a>02784     {
<a name="l02785"></a>02785       <span class="keywordtype">int</span> ix;
<a name="l02786"></a>02786       <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> **arg_types;
<a name="l02787"></a>02787 
<a name="l02788"></a>02788       <span class="comment">/* Prepare list of argument types for overload resolution.  */</span>
<a name="l02789"></a>02789       arg_types = (<span class="keyword">struct </span><a class="code" href="structtype.html">type</a> **)
<a name="l02790"></a>02790         alloca (nargs * (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *)));
<a name="l02791"></a>02791       <span class="keywordflow">for</span> (ix = 0; ix &lt; nargs; ix++)
<a name="l02792"></a>02792         arg_types[ix] = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (args[ix]);
<a name="l02793"></a>02793       <a class="code" href="cp-support_8c.html#a2065e45f2d40dd1f677702315dd962c8">make_symbol_overload_list_adl</a> (arg_types, nargs, func_name);
<a name="l02794"></a>02794     }
<a name="l02795"></a>02795 
<a name="l02796"></a>02796   <span class="keywordflow">while</span> (new_oload_syms[num_fns])
<a name="l02797"></a>02797     ++num_fns;
<a name="l02798"></a>02798 
<a name="l02799"></a>02799   new_oload_champ = <a class="code" href="valops_8c.html#a7f4c90439e40cce6113426c5b25e53c6">find_oload_champ</a> (args, nargs, 0, num_fns,
<a name="l02800"></a>02800                                       NULL, new_oload_syms,
<a name="l02801"></a>02801                                       &amp;new_oload_champ_bv);
<a name="l02802"></a>02802 
<a name="l02803"></a>02803   <span class="comment">/* Case 1: We found a good match.  Free earlier matches (if any),</span>
<a name="l02804"></a>02804 <span class="comment">     and return it.  Case 2: We didn&#39;t find a good match, but we&#39;re</span>
<a name="l02805"></a>02805 <span class="comment">     not the deepest function.  Then go with the bad match that the</span>
<a name="l02806"></a>02806 <span class="comment">     deeper function found.  Case 3: We found a bad match, and we&#39;re</span>
<a name="l02807"></a>02807 <span class="comment">     the deepest function.  Then return what we found, even though</span>
<a name="l02808"></a>02808 <span class="comment">     it&#39;s a bad match.  */</span>
<a name="l02809"></a>02809 
<a name="l02810"></a>02810   <span class="keywordflow">if</span> (new_oload_champ != -1
<a name="l02811"></a>02811       &amp;&amp; <a class="code" href="valops_8c.html#a60d383f4b94d6281a9be1ddc9035bab4">classify_oload_match</a> (new_oload_champ_bv, nargs, 0) == <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7a9de934790934fe831fe946c851e8338e">STANDARD</a>)
<a name="l02812"></a>02812     {
<a name="l02813"></a>02813       *oload_syms = new_oload_syms;
<a name="l02814"></a>02814       *oload_champ = new_oload_champ;
<a name="l02815"></a>02815       *oload_champ_bv = new_oload_champ_bv;
<a name="l02816"></a>02816       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_cleanups);
<a name="l02817"></a>02817       <span class="keywordflow">return</span> 1;
<a name="l02818"></a>02818     }
<a name="l02819"></a>02819   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (searched_deeper)
<a name="l02820"></a>02820     {
<a name="l02821"></a>02821       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (new_oload_syms);
<a name="l02822"></a>02822       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (new_oload_champ_bv);
<a name="l02823"></a>02823       <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (old_cleanups);
<a name="l02824"></a>02824       <span class="keywordflow">return</span> 0;
<a name="l02825"></a>02825     }
<a name="l02826"></a>02826   <span class="keywordflow">else</span>
<a name="l02827"></a>02827     {
<a name="l02828"></a>02828       *oload_syms = new_oload_syms;
<a name="l02829"></a>02829       *oload_champ = new_oload_champ;
<a name="l02830"></a>02830       *oload_champ_bv = new_oload_champ_bv;
<a name="l02831"></a>02831       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_cleanups);
<a name="l02832"></a>02832       <span class="keywordflow">return</span> 0;
<a name="l02833"></a>02833     }
<a name="l02834"></a>02834 }
<a name="l02835"></a>02835 
<a name="l02836"></a>02836 <span class="comment">/* Look for a function to take NARGS args of ARGS.  Find</span>
<a name="l02837"></a>02837 <span class="comment">   the best match from among the overloaded methods or functions</span>
<a name="l02838"></a>02838 <span class="comment">   (depending on METHOD) given by FNS_PTR or OLOAD_SYMS, respectively.</span>
<a name="l02839"></a>02839 <span class="comment">   The number of methods/functions in the list is given by NUM_FNS.</span>
<a name="l02840"></a>02840 <span class="comment">   Return the index of the best match; store an indication of the</span>
<a name="l02841"></a>02841 <span class="comment">   quality of the match in OLOAD_CHAMP_BV.</span>
<a name="l02842"></a>02842 <span class="comment"></span>
<a name="l02843"></a>02843 <span class="comment">   It is the caller&#39;s responsibility to free *OLOAD_CHAMP_BV.  */</span>
<a name="l02844"></a>02844 
<a name="l02845"></a>02845 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02846"></a><a class="code" href="valops_8c.html#a7f4c90439e40cce6113426c5b25e53c6">02846</a> <a class="code" href="valops_8c.html#a7f4c90439e40cce6113426c5b25e53c6">find_oload_champ</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **args, <span class="keywordtype">int</span> nargs, <span class="keywordtype">int</span> method,
<a name="l02847"></a>02847                   <span class="keywordtype">int</span> num_fns, <span class="keyword">struct</span> fn_field *fns_ptr,
<a name="l02848"></a>02848                   <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> **oload_syms,
<a name="l02849"></a>02849                   <span class="keyword">struct</span> <a class="code" href="structbadness__vector.html">badness_vector</a> **oload_champ_bv)
<a name="l02850"></a>02850 {
<a name="l02851"></a>02851   <span class="keywordtype">int</span> ix;
<a name="l02852"></a>02852   <span class="comment">/* A measure of how good an overloaded instance is.  */</span>
<a name="l02853"></a>02853   <span class="keyword">struct </span><a class="code" href="structbadness__vector.html">badness_vector</a> *bv;
<a name="l02854"></a>02854   <span class="comment">/* Index of best overloaded function.  */</span>
<a name="l02855"></a>02855   <span class="keywordtype">int</span> oload_champ = -1;
<a name="l02856"></a>02856   <span class="comment">/* Current ambiguity state for overload resolution.  */</span>
<a name="l02857"></a>02857   <span class="keywordtype">int</span> oload_ambiguous = 0;
<a name="l02858"></a>02858   <span class="comment">/* 0 =&gt; no ambiguity, 1 =&gt; two good funcs, 2 =&gt; incomparable funcs.  */</span>
<a name="l02859"></a>02859 
<a name="l02860"></a>02860   *oload_champ_bv = NULL;
<a name="l02861"></a>02861 
<a name="l02862"></a>02862   <span class="comment">/* Consider each candidate in turn.  */</span>
<a name="l02863"></a>02863   <span class="keywordflow">for</span> (ix = 0; ix &lt; num_fns; ix++)
<a name="l02864"></a>02864     {
<a name="l02865"></a>02865       <span class="keywordtype">int</span> jj;
<a name="l02866"></a>02866       <span class="keywordtype">int</span> static_offset = <a class="code" href="valops_8c.html#a53c5ca67792b188788711efbc1ffac76">oload_method_static</a> (method, fns_ptr, ix);
<a name="l02867"></a>02867       <span class="keywordtype">int</span> nparms;
<a name="l02868"></a>02868       <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> **parm_types;
<a name="l02869"></a>02869 
<a name="l02870"></a>02870       <span class="keywordflow">if</span> (method)
<a name="l02871"></a>02871         {
<a name="l02872"></a>02872           nparms = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (<a class="code" href="gdbtypes_8h.html#a76c6074ace855100086c485428668372">TYPE_FN_FIELD_TYPE</a> (fns_ptr, ix));
<a name="l02873"></a>02873         }
<a name="l02874"></a>02874       <span class="keywordflow">else</span>
<a name="l02875"></a>02875         {
<a name="l02876"></a>02876           <span class="comment">/* If it&#39;s not a method, this is the proper place.  */</span>
<a name="l02877"></a>02877           nparms = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (oload_syms[ix]));
<a name="l02878"></a>02878         }
<a name="l02879"></a>02879 
<a name="l02880"></a>02880       <span class="comment">/* Prepare array of parameter types.  */</span>
<a name="l02881"></a>02881       parm_types = (<span class="keyword">struct </span><a class="code" href="structtype.html">type</a> **) 
<a name="l02882"></a>02882         <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (nparms * (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *)));
<a name="l02883"></a>02883       <span class="keywordflow">for</span> (jj = 0; jj &lt; nparms; jj++)
<a name="l02884"></a>02884         parm_types[jj] = (method
<a name="l02885"></a>02885                           ? (<a class="code" href="gdbtypes_8h.html#a1b27df66ed198a941d2467943749c166">TYPE_FN_FIELD_ARGS</a> (fns_ptr, ix)[jj].<a class="code" href="structtype.html">type</a>)
<a name="l02886"></a>02886                           : <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (oload_syms[ix]), 
<a name="l02887"></a>02887                                              jj));
<a name="l02888"></a>02888 
<a name="l02889"></a>02889       <span class="comment">/* Compare parameter types to supplied argument types.  Skip</span>
<a name="l02890"></a>02890 <span class="comment">         THIS for static methods.  */</span>
<a name="l02891"></a>02891       bv = <a class="code" href="gdbtypes_8c.html#a4fef7bb1d2ff1a5eac00003a62eb4ae1">rank_function</a> (parm_types, nparms, 
<a name="l02892"></a>02892                           args + static_offset,
<a name="l02893"></a>02893                           nargs - static_offset);
<a name="l02894"></a>02894 
<a name="l02895"></a>02895       <span class="keywordflow">if</span> (!*oload_champ_bv)
<a name="l02896"></a>02896         {
<a name="l02897"></a>02897           *oload_champ_bv = bv;
<a name="l02898"></a>02898           oload_champ = 0;
<a name="l02899"></a>02899         }
<a name="l02900"></a>02900       <span class="keywordflow">else</span> <span class="comment">/* See whether current candidate is better or worse than</span>
<a name="l02901"></a>02901 <span class="comment">              previous best.  */</span>
<a name="l02902"></a>02902         <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8c.html#a00978bb926d19570635f0aa9a8b2a9f4">compare_badness</a> (bv, *oload_champ_bv))
<a name="l02903"></a>02903           {
<a name="l02904"></a>02904           <span class="keywordflow">case</span> 0:               <span class="comment">/* Top two contenders are equally good.  */</span>
<a name="l02905"></a>02905             oload_ambiguous = 1;
<a name="l02906"></a>02906             <span class="keywordflow">break</span>;
<a name="l02907"></a>02907           <span class="keywordflow">case</span> 1:               <span class="comment">/* Incomparable top contenders.  */</span>
<a name="l02908"></a>02908             oload_ambiguous = 2;
<a name="l02909"></a>02909             <span class="keywordflow">break</span>;
<a name="l02910"></a>02910           <span class="keywordflow">case</span> 2:               <span class="comment">/* New champion, record details.  */</span>
<a name="l02911"></a>02911             *oload_champ_bv = bv;
<a name="l02912"></a>02912             oload_ambiguous = 0;
<a name="l02913"></a>02913             oload_champ = ix;
<a name="l02914"></a>02914             <span class="keywordflow">break</span>;
<a name="l02915"></a>02915           <span class="keywordflow">case</span> 3:
<a name="l02916"></a>02916           <span class="keywordflow">default</span>:
<a name="l02917"></a>02917             <span class="keywordflow">break</span>;
<a name="l02918"></a>02918           }
<a name="l02919"></a>02919       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (parm_types);
<a name="l02920"></a>02920       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#aa45853f3c19e5cb9cb4d830912e11395">overload_debug</a>)
<a name="l02921"></a>02921         {
<a name="l02922"></a>02922           <span class="keywordflow">if</span> (method)
<a name="l02923"></a>02923             <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>,
<a name="l02924"></a>02924                               <span class="stringliteral">&quot;Overloaded method instance %s, # of parms %d\n&quot;</span>,
<a name="l02925"></a>02925                               fns_ptr[ix].physname, nparms);
<a name="l02926"></a>02926           <span class="keywordflow">else</span>
<a name="l02927"></a>02927             <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>,
<a name="l02928"></a>02928                               <span class="stringliteral">&quot;Overloaded function instance &quot;</span>
<a name="l02929"></a>02929                               <span class="stringliteral">&quot;%s # of parms %d\n&quot;</span>,
<a name="l02930"></a>02930                               <a class="code" href="symtab_8h.html#a9be4a0902a8e084998541d5968d36a8c">SYMBOL_DEMANGLED_NAME</a> (oload_syms[ix]), 
<a name="l02931"></a>02931                               nparms);
<a name="l02932"></a>02932           <span class="keywordflow">for</span> (jj = 0; jj &lt; nargs - static_offset; jj++)
<a name="l02933"></a>02933             <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>,
<a name="l02934"></a>02934                               <span class="stringliteral">&quot;...Badness @ %d : %d\n&quot;</span>, 
<a name="l02935"></a>02935                               jj, bv-&gt;<a class="code" href="structbadness__vector.html#ac94061a09806133279a0696ad36c8bd2">rank</a>[jj].<a class="code" href="structrank.html#adcce1bc7082298591f12271d5d62b199">rank</a>);
<a name="l02936"></a>02936           <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, <span class="stringliteral">&quot;Overload resolution &quot;</span>
<a name="l02937"></a>02937                             <span class="stringliteral">&quot;champion is %d, ambiguous? %d\n&quot;</span>, 
<a name="l02938"></a>02938                             oload_champ, oload_ambiguous);
<a name="l02939"></a>02939         }
<a name="l02940"></a>02940     }
<a name="l02941"></a>02941 
<a name="l02942"></a>02942   <span class="keywordflow">return</span> oload_champ;
<a name="l02943"></a>02943 }
<a name="l02944"></a>02944 
<a name="l02945"></a>02945 <span class="comment">/* Return 1 if we&#39;re looking at a static method, 0 if we&#39;re looking at</span>
<a name="l02946"></a>02946 <span class="comment">   a non-static method or a function that isn&#39;t a method.  */</span>
<a name="l02947"></a>02947 
<a name="l02948"></a>02948 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02949"></a><a class="code" href="valops_8c.html#a53c5ca67792b188788711efbc1ffac76">02949</a> <a class="code" href="valops_8c.html#a53c5ca67792b188788711efbc1ffac76">oload_method_static</a> (<span class="keywordtype">int</span> method, <span class="keyword">struct</span> fn_field *fns_ptr, <span class="keywordtype">int</span> index)
<a name="l02950"></a>02950 {
<a name="l02951"></a>02951   <span class="keywordflow">if</span> (method &amp;&amp; fns_ptr &amp;&amp; index &gt;= 0
<a name="l02952"></a>02952       &amp;&amp; <a class="code" href="gdbtypes_8h.html#ab772f7a2fa3ac127cfd52c64d129ac18">TYPE_FN_FIELD_STATIC_P</a> (fns_ptr, index))
<a name="l02953"></a>02953     <span class="keywordflow">return</span> 1;
<a name="l02954"></a>02954   <span class="keywordflow">else</span>
<a name="l02955"></a>02955     <span class="keywordflow">return</span> 0;
<a name="l02956"></a>02956 }
<a name="l02957"></a>02957 
<a name="l02958"></a>02958 <span class="comment">/* Check how good an overload match OLOAD_CHAMP_BV represents.  */</span>
<a name="l02959"></a>02959 
<a name="l02960"></a>02960 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7">oload_classification</a>
<a name="l02961"></a><a class="code" href="valops_8c.html#a60d383f4b94d6281a9be1ddc9035bab4">02961</a> <a class="code" href="valops_8c.html#a60d383f4b94d6281a9be1ddc9035bab4">classify_oload_match</a> (<span class="keyword">struct</span> <a class="code" href="structbadness__vector.html">badness_vector</a> *oload_champ_bv,
<a name="l02962"></a>02962                       <span class="keywordtype">int</span> nargs,
<a name="l02963"></a>02963                       <span class="keywordtype">int</span> static_offset)
<a name="l02964"></a>02964 {
<a name="l02965"></a>02965   <span class="keywordtype">int</span> ix;
<a name="l02966"></a>02966   <span class="keyword">enum</span> <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7">oload_classification</a> worst = <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7a9de934790934fe831fe946c851e8338e">STANDARD</a>;
<a name="l02967"></a>02967 
<a name="l02968"></a>02968   <span class="keywordflow">for</span> (ix = 1; ix &lt;= nargs - static_offset; ix++)
<a name="l02969"></a>02969     {
<a name="l02970"></a>02970       <span class="comment">/* If this conversion is as bad as INCOMPATIBLE_TYPE_BADNESS</span>
<a name="l02971"></a>02971 <span class="comment">         or worse return INCOMPATIBLE.  */</span>
<a name="l02972"></a>02972       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#a84e2bb70a3bb63b01315ad128ca294d1">compare_ranks</a> (oload_champ_bv-&gt;<a class="code" href="structbadness__vector.html#ac94061a09806133279a0696ad36c8bd2">rank</a>[ix],
<a name="l02973"></a>02973                          <a class="code" href="gdbtypes_8c.html#a0859fdf4de5e553a6540635295d11b99">INCOMPATIBLE_TYPE_BADNESS</a>) &lt;= 0)
<a name="l02974"></a>02974         <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7a1d5787f0d18fdb7422615b7c08562710">INCOMPATIBLE</a>;    <span class="comment">/* Truly mismatched types.  */</span>
<a name="l02975"></a>02975       <span class="comment">/* Otherwise If this conversion is as bad as</span>
<a name="l02976"></a>02976 <span class="comment">         NS_POINTER_CONVERSION_BADNESS or worse return NON_STANDARD.  */</span>
<a name="l02977"></a>02977       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#a84e2bb70a3bb63b01315ad128ca294d1">compare_ranks</a> (oload_champ_bv-&gt;<a class="code" href="structbadness__vector.html#ac94061a09806133279a0696ad36c8bd2">rank</a>[ix],
<a name="l02978"></a>02978                               <a class="code" href="gdbtypes_8c.html#ae40be37fa4c5597f7cc6e6d062a820f7">NS_POINTER_CONVERSION_BADNESS</a>) &lt;= 0)
<a name="l02979"></a>02979         worst = <a class="code" href="valops_8c.html#a6fdf1aaae89ab3bd9fe3fd4f027091b7a2e658c001901706a2e2c19f15652a417">NON_STANDARD</a>;   <span class="comment">/* Non-standard type conversions</span>
<a name="l02980"></a>02980 <span class="comment">                                   needed.  */</span>
<a name="l02981"></a>02981     }
<a name="l02982"></a>02982 
<a name="l02983"></a>02983   <span class="comment">/* If no INCOMPATIBLE classification was found, return the worst one</span>
<a name="l02984"></a>02984 <span class="comment">     that was found (if any).  */</span>
<a name="l02985"></a>02985   <span class="keywordflow">return</span> worst;
<a name="l02986"></a>02986 }
<a name="l02987"></a>02987 
<a name="l02988"></a>02988 <span class="comment">/* C++: return 1 is NAME is a legitimate name for the destructor of</span>
<a name="l02989"></a>02989 <span class="comment">   type TYPE.  If TYPE does not have a destructor, or if NAME is</span>
<a name="l02990"></a>02990 <span class="comment">   inappropriate for TYPE, an error is signaled.  Parameter TYPE should not yet</span>
<a name="l02991"></a>02991 <span class="comment">   have CHECK_TYPEDEF applied, this function will apply it itself.  */</span>
<a name="l02992"></a>02992 
<a name="l02993"></a>02993 <span class="keywordtype">int</span>
<a name="l02994"></a><a class="code" href="value_8h.html#af20e1939d3ec06831824f7f064204094">02994</a> <a class="code" href="valops_8c.html#af20e1939d3ec06831824f7f064204094">destructor_name_p</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>)
<a name="l02995"></a>02995 {
<a name="l02996"></a>02996   <span class="keywordflow">if</span> (name[0] == <span class="charliteral">&#39;~&#39;</span>)
<a name="l02997"></a>02997     {
<a name="l02998"></a>02998       <span class="keyword">const</span> <span class="keywordtype">char</span> *dname = <a class="code" href="gdbtypes_8c.html#abcdee541a871ec6c4a8066113cd5f2fb">type_name_no_tag_or_error</a> (type);
<a name="l02999"></a>02999       <span class="keyword">const</span> <span class="keywordtype">char</span> *cp = <a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (dname, <span class="charliteral">&#39;&lt;&#39;</span>);
<a name="l03000"></a>03000       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l03001"></a>03001 
<a name="l03002"></a>03002       <span class="comment">/* Do not compare the template part for template classes.  */</span>
<a name="l03003"></a>03003       <span class="keywordflow">if</span> (cp == NULL)
<a name="l03004"></a>03004         len = strlen (dname);
<a name="l03005"></a>03005       <span class="keywordflow">else</span>
<a name="l03006"></a>03006         len = cp - dname;
<a name="l03007"></a>03007       <span class="keywordflow">if</span> (strlen (name + 1) != len || strncmp (dname, name + 1, len) != 0)
<a name="l03008"></a>03008         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;name of destructor must equal name of class&quot;</span>));
<a name="l03009"></a>03009       <span class="keywordflow">else</span>
<a name="l03010"></a>03010         <span class="keywordflow">return</span> 1;
<a name="l03011"></a>03011     }
<a name="l03012"></a>03012   <span class="keywordflow">return</span> 0;
<a name="l03013"></a>03013 }
<a name="l03014"></a>03014 
<a name="l03015"></a>03015 <span class="comment">/* C++: Given an aggregate type CURTYPE, and a member name NAME,</span>
<a name="l03016"></a>03016 <span class="comment">   return the appropriate member (or the address of the member, if</span>
<a name="l03017"></a>03017 <span class="comment">   WANT_ADDRESS).  This function is used to resolve user expressions</span>
<a name="l03018"></a>03018 <span class="comment">   of the form &quot;DOMAIN::NAME&quot;.  For more details on what happens, see</span>
<a name="l03019"></a>03019 <span class="comment">   the comment before value_struct_elt_for_reference.  */</span>
<a name="l03020"></a>03020 
<a name="l03021"></a>03021 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l03022"></a><a class="code" href="value_8h.html#acffe875dbf11c4799bdaa6342e012077">03022</a> <a class="code" href="valops_8c.html#acffe875dbf11c4799bdaa6342e012077">value_aggregate_elt</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *curtype, <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>,
<a name="l03023"></a>03023                      <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *expect_type, <span class="keywordtype">int</span> want_address,
<a name="l03024"></a>03024                      <span class="keyword">enum</span> <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73">noside</a> <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73">noside</a>)
<a name="l03025"></a>03025 {
<a name="l03026"></a>03026   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (curtype))
<a name="l03027"></a>03027     {
<a name="l03028"></a>03028     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l03029"></a>03029     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>:
<a name="l03030"></a>03030       <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a107fe3950fecf16bb0bf7ce7290b09f0">value_struct_elt_for_reference</a> (curtype, 0, curtype, 
<a name="l03031"></a>03031                                              name, expect_type,
<a name="l03032"></a>03032                                              want_address, noside);
<a name="l03033"></a>03033     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae5cdf73186d3029211503380f64949b6">TYPE_CODE_NAMESPACE</a>:
<a name="l03034"></a>03034       <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#af2efc03285e4b19401311e51300bf427">value_namespace_elt</a> (curtype, name, 
<a name="l03035"></a>03035                                   want_address, noside);
<a name="l03036"></a>03036     <span class="keywordflow">default</span>:
<a name="l03037"></a>03037       <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l03038"></a>03038                       <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;non-aggregate type in value_aggregate_elt&quot;</span>));
<a name="l03039"></a>03039     }
<a name="l03040"></a>03040 }
<a name="l03041"></a>03041 
<a name="l03042"></a>03042 <span class="comment">/* Compares the two method/function types T1 and T2 for &quot;equality&quot; </span>
<a name="l03043"></a>03043 <span class="comment">   with respect to the methods&#39; parameters.  If the types of the</span>
<a name="l03044"></a>03044 <span class="comment">   two parameter lists are the same, returns 1; 0 otherwise.  This</span>
<a name="l03045"></a>03045 <span class="comment">   comparison may ignore any artificial parameters in T1 if</span>
<a name="l03046"></a>03046 <span class="comment">   SKIP_ARTIFICIAL is non-zero.  This function will ALWAYS skip</span>
<a name="l03047"></a>03047 <span class="comment">   the first artificial parameter in T1, assumed to be a &#39;this&#39; pointer.</span>
<a name="l03048"></a>03048 <span class="comment"></span>
<a name="l03049"></a>03049 <span class="comment">   The type T2 is expected to have come from make_params (in eval.c).  */</span>
<a name="l03050"></a>03050 
<a name="l03051"></a>03051 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03052"></a><a class="code" href="valops_8c.html#a16839b2e02bc9a74587362c912a75fed">03052</a> <a class="code" href="valops_8c.html#a16839b2e02bc9a74587362c912a75fed">compare_parameters</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *t1, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *t2, <span class="keywordtype">int</span> skip_artificial)
<a name="l03053"></a>03053 {
<a name="l03054"></a>03054   <span class="keywordtype">int</span> start = 0;
<a name="l03055"></a>03055 
<a name="l03056"></a>03056   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (t1) &gt; 0 &amp;&amp; <a class="code" href="gdbtypes_8h.html#aa2bb2f58f95f604830c665368481946d">TYPE_FIELD_ARTIFICIAL</a> (t1, 0))
<a name="l03057"></a>03057     ++start;
<a name="l03058"></a>03058 
<a name="l03059"></a>03059   <span class="comment">/* If skipping artificial fields, find the first real field</span>
<a name="l03060"></a>03060 <span class="comment">     in T1.  */</span>
<a name="l03061"></a>03061   <span class="keywordflow">if</span> (skip_artificial)
<a name="l03062"></a>03062     {
<a name="l03063"></a>03063       <span class="keywordflow">while</span> (start &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (t1)
<a name="l03064"></a>03064              &amp;&amp; <a class="code" href="gdbtypes_8h.html#aa2bb2f58f95f604830c665368481946d">TYPE_FIELD_ARTIFICIAL</a> (t1, start))
<a name="l03065"></a>03065         ++start;
<a name="l03066"></a>03066     }
<a name="l03067"></a>03067 
<a name="l03068"></a>03068   <span class="comment">/* Now compare parameters.  */</span>
<a name="l03069"></a>03069 
<a name="l03070"></a>03070   <span class="comment">/* Special case: a method taking void.  T1 will contain no</span>
<a name="l03071"></a>03071 <span class="comment">     non-artificial fields, and T2 will contain TYPE_CODE_VOID.  */</span>
<a name="l03072"></a>03072   <span class="keywordflow">if</span> ((<a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (t1) - start) == 0 &amp;&amp; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (t2) == 1
<a name="l03073"></a>03073       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (t2, 0)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>)
<a name="l03074"></a>03074     <span class="keywordflow">return</span> 1;
<a name="l03075"></a>03075 
<a name="l03076"></a>03076   <span class="keywordflow">if</span> ((<a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (t1) - start) == <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (t2))
<a name="l03077"></a>03077     {
<a name="l03078"></a>03078       <span class="keywordtype">int</span> i;
<a name="l03079"></a>03079 
<a name="l03080"></a>03080       <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (t2); ++i)
<a name="l03081"></a>03081         {
<a name="l03082"></a>03082           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#a84e2bb70a3bb63b01315ad128ca294d1">compare_ranks</a> (<a class="code" href="gdbtypes_8c.html#a46e5531c7311495575754d2722b654d0">rank_one_type</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (t1, start + i),
<a name="l03083"></a>03083                                             <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (t2, i), NULL),
<a name="l03084"></a>03084                              <a class="code" href="gdbtypes_8c.html#a97e7af63cf2a070514079194c4e21ad9">EXACT_MATCH_BADNESS</a>) != 0)
<a name="l03085"></a>03085             <span class="keywordflow">return</span> 0;
<a name="l03086"></a>03086         }
<a name="l03087"></a>03087 
<a name="l03088"></a>03088       <span class="keywordflow">return</span> 1;
<a name="l03089"></a>03089     }
<a name="l03090"></a>03090 
<a name="l03091"></a>03091   <span class="keywordflow">return</span> 0;
<a name="l03092"></a>03092 }
<a name="l03093"></a>03093 
<a name="l03094"></a>03094 <span class="comment">/* C++: Given an aggregate type CURTYPE, and a member name NAME,</span>
<a name="l03095"></a>03095 <span class="comment">   return the address of this member as a &quot;pointer to member&quot; type.</span>
<a name="l03096"></a>03096 <span class="comment">   If INTYPE is non-null, then it will be the type of the member we</span>
<a name="l03097"></a>03097 <span class="comment">   are looking for.  This will help us resolve &quot;pointers to member</span>
<a name="l03098"></a>03098 <span class="comment">   functions&quot;.  This function is used to resolve user expressions of</span>
<a name="l03099"></a>03099 <span class="comment">   the form &quot;DOMAIN::NAME&quot;.  */</span>
<a name="l03100"></a>03100 
<a name="l03101"></a>03101 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l03102"></a>03102 <a class="code" href="valops_8c.html#a107fe3950fecf16bb0bf7ce7290b09f0">value_struct_elt_for_reference</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *domain, <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>,
<a name="l03103"></a>03103                                 <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *curtype, <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>,
<a name="l03104"></a>03104                                 <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *intype, 
<a name="l03105"></a>03105                                 <span class="keywordtype">int</span> want_address,
<a name="l03106"></a>03106                                 <span class="keyword">enum</span> <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73">noside</a> <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73">noside</a>)
<a name="l03107"></a>03107 {
<a name="l03108"></a>03108   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *t = curtype;
<a name="l03109"></a>03109   <span class="keywordtype">int</span> i;
<a name="l03110"></a>03110   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *v, *result;
<a name="l03111"></a>03111 
<a name="l03112"></a>03112   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l03113"></a>03113       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l03114"></a>03114     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Internal error: non-aggregate type &quot;</span>
<a name="l03115"></a>03115              <span class="stringliteral">&quot;to value_struct_elt_for_reference&quot;</span>));
<a name="l03116"></a>03116 
<a name="l03117"></a>03117   <span class="keywordflow">for</span> (i = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (t) - 1; i &gt;= <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (t); i--)
<a name="l03118"></a>03118     {
<a name="l03119"></a>03119       <span class="keyword">const</span> <span class="keywordtype">char</span> *t_field_name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (t, i);
<a name="l03120"></a>03120 
<a name="l03121"></a>03121       <span class="keywordflow">if</span> (t_field_name &amp;&amp; strcmp (t_field_name, name) == 0)
<a name="l03122"></a>03122         {
<a name="l03123"></a>03123           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#a38a5ce3cc244d3f0618908f9a7ceca62">field_is_static</a> (&amp;<a class="code" href="gdbtypes_8h.html#a8beaef20f443a0d98c7b445bbcfcf031">TYPE_FIELD</a> (t, i)))
<a name="l03124"></a>03124             {
<a name="l03125"></a>03125               v = <a class="code" href="value_8c.html#ad227db366076082564a611a5da413d8a">value_static_field</a> (t, i);
<a name="l03126"></a>03126               <span class="keywordflow">if</span> (v == NULL)
<a name="l03127"></a>03127                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;static field %s has been optimized out&quot;</span>),
<a name="l03128"></a>03128                        name);
<a name="l03129"></a>03129               <span class="keywordflow">if</span> (want_address)
<a name="l03130"></a>03130                 v = <a class="code" href="valops_8c.html#a29bc320305726a3cbf324189df2ca772">value_addr</a> (v);
<a name="l03131"></a>03131               <span class="keywordflow">return</span> v;
<a name="l03132"></a>03132             }
<a name="l03133"></a>03133           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#ac5d0007ccfe3d37905b3b428e7fee770">TYPE_FIELD_PACKED</a> (t, i))
<a name="l03134"></a>03134             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;pointers to bitfield members not allowed&quot;</span>));
<a name="l03135"></a>03135 
<a name="l03136"></a>03136           <span class="keywordflow">if</span> (want_address)
<a name="l03137"></a>03137             <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a>
<a name="l03138"></a>03138               (<a class="code" href="gdbtypes_8c.html#a133dbb915fedac068ac437460da3d13b">lookup_memberptr_type</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (t, i), domain),
<a name="l03139"></a>03139                offset + (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) (<a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (t, i) &gt;&gt; 3));
<a name="l03140"></a>03140           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l03141"></a>03141             <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (t, i));
<a name="l03142"></a>03142           <span class="keywordflow">else</span>
<a name="l03143"></a>03143             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot reference non-static field \&quot;%s\&quot;&quot;</span>), name);
<a name="l03144"></a>03144         }
<a name="l03145"></a>03145     }
<a name="l03146"></a>03146 
<a name="l03147"></a>03147   <span class="comment">/* C++: If it was not found as a data field, then try to return it</span>
<a name="l03148"></a>03148 <span class="comment">     as a pointer to a method.  */</span>
<a name="l03149"></a>03149 
<a name="l03150"></a>03150   <span class="comment">/* Perform all necessary dereferencing.  */</span>
<a name="l03151"></a>03151   <span class="keywordflow">while</span> (intype &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (intype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l03152"></a>03152     intype = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (intype);
<a name="l03153"></a>03153 
<a name="l03154"></a>03154   <span class="keywordflow">for</span> (i = <a class="code" href="gdbtypes_8h.html#a04c1a1616329be52b9a9706ddc102bd1">TYPE_NFN_FIELDS</a> (t) - 1; i &gt;= 0; --i)
<a name="l03155"></a>03155     {
<a name="l03156"></a>03156       <span class="keyword">const</span> <span class="keywordtype">char</span> *t_field_name = <a class="code" href="gdbtypes_8h.html#ad06fe1d1555d89ce87344fa6825e5642">TYPE_FN_FIELDLIST_NAME</a> (t, i);
<a name="l03157"></a>03157       <span class="keywordtype">char</span> dem_opname[64];
<a name="l03158"></a>03158 
<a name="l03159"></a>03159       <span class="keywordflow">if</span> (strncmp (t_field_name, <span class="stringliteral">&quot;__&quot;</span>, 2) == 0 
<a name="l03160"></a>03160           || strncmp (t_field_name, <span class="stringliteral">&quot;op&quot;</span>, 2) == 0 
<a name="l03161"></a>03161           || strncmp (t_field_name, <span class="stringliteral">&quot;type&quot;</span>, 4) == 0)
<a name="l03162"></a>03162         {
<a name="l03163"></a>03163           <span class="keywordflow">if</span> (cplus_demangle_opname (t_field_name, 
<a name="l03164"></a>03164                                      dem_opname, DMGL_ANSI))
<a name="l03165"></a>03165             t_field_name = dem_opname;
<a name="l03166"></a>03166           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cplus_demangle_opname (t_field_name, 
<a name="l03167"></a>03167                                           dem_opname, 0))
<a name="l03168"></a>03168             t_field_name = dem_opname;
<a name="l03169"></a>03169         }
<a name="l03170"></a>03170       <span class="keywordflow">if</span> (t_field_name &amp;&amp; strcmp (t_field_name, name) == 0)
<a name="l03171"></a>03171         {
<a name="l03172"></a>03172           <span class="keywordtype">int</span> j;
<a name="l03173"></a>03173           <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a> = <a class="code" href="gdbtypes_8h.html#a93f192829a3feec903de135b4d53981e">TYPE_FN_FIELDLIST_LENGTH</a> (t, i);
<a name="l03174"></a>03174           <span class="keyword">struct </span>fn_field *f = <a class="code" href="gdbtypes_8h.html#a475365c72b8bba6494569379cec012df">TYPE_FN_FIELDLIST1</a> (t, i);
<a name="l03175"></a>03175 
<a name="l03176"></a>03176           <a class="code" href="gdbtypes_8c.html#a104ee91f58366ea5451ad5e9ea42b327">check_stub_method_group</a> (t, i);
<a name="l03177"></a>03177 
<a name="l03178"></a>03178           <span class="keywordflow">if</span> (intype)
<a name="l03179"></a>03179             {
<a name="l03180"></a>03180               <span class="keywordflow">for</span> (j = 0; j &lt; <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>; ++j)
<a name="l03181"></a>03181                 {
<a name="l03182"></a>03182                   <span class="keywordflow">if</span> (<a class="code" href="valops_8c.html#a16839b2e02bc9a74587362c912a75fed">compare_parameters</a> (<a class="code" href="gdbtypes_8h.html#a76c6074ace855100086c485428668372">TYPE_FN_FIELD_TYPE</a> (f, j), intype, 0)
<a name="l03183"></a>03183                       || <a class="code" href="valops_8c.html#a16839b2e02bc9a74587362c912a75fed">compare_parameters</a> (<a class="code" href="gdbtypes_8h.html#a76c6074ace855100086c485428668372">TYPE_FN_FIELD_TYPE</a> (f, j),
<a name="l03184"></a>03184                                              intype, 1))
<a name="l03185"></a>03185                     <span class="keywordflow">break</span>;
<a name="l03186"></a>03186                 }
<a name="l03187"></a>03187 
<a name="l03188"></a>03188               <span class="keywordflow">if</span> (j == len)
<a name="l03189"></a>03189                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;no member function matches &quot;</span>
<a name="l03190"></a>03190                          <span class="stringliteral">&quot;that type instantiation&quot;</span>));
<a name="l03191"></a>03191             }
<a name="l03192"></a>03192           <span class="keywordflow">else</span>
<a name="l03193"></a>03193             {
<a name="l03194"></a>03194               <span class="keywordtype">int</span> ii;
<a name="l03195"></a>03195 
<a name="l03196"></a>03196               j = -1;
<a name="l03197"></a>03197               <span class="keywordflow">for</span> (ii = 0; ii &lt; <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>; ++ii)
<a name="l03198"></a>03198                 {
<a name="l03199"></a>03199                   <span class="comment">/* Skip artificial methods.  This is necessary if,</span>
<a name="l03200"></a>03200 <span class="comment">                     for example, the user wants to &quot;print</span>
<a name="l03201"></a>03201 <span class="comment">                     subclass::subclass&quot; with only one user-defined</span>
<a name="l03202"></a>03202 <span class="comment">                     constructor.  There is no ambiguity in this case.</span>
<a name="l03203"></a>03203 <span class="comment">                     We are careful here to allow artificial methods</span>
<a name="l03204"></a>03204 <span class="comment">                     if they are the unique result.  */</span>
<a name="l03205"></a>03205                   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#ad89202614e1e5f2567ff387575f08e9a">TYPE_FN_FIELD_ARTIFICIAL</a> (f, ii))
<a name="l03206"></a>03206                     {
<a name="l03207"></a>03207                       <span class="keywordflow">if</span> (j == -1)
<a name="l03208"></a>03208                         j = ii;
<a name="l03209"></a>03209                       <span class="keywordflow">continue</span>;
<a name="l03210"></a>03210                     }
<a name="l03211"></a>03211 
<a name="l03212"></a>03212                   <span class="comment">/* Desired method is ambiguous if more than one</span>
<a name="l03213"></a>03213 <span class="comment">                     method is defined.  */</span>
<a name="l03214"></a>03214                   <span class="keywordflow">if</span> (j != -1 &amp;&amp; !<a class="code" href="gdbtypes_8h.html#ad89202614e1e5f2567ff387575f08e9a">TYPE_FN_FIELD_ARTIFICIAL</a> (f, j))
<a name="l03215"></a>03215                     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;non-unique member `%s&#39; requires &quot;</span>
<a name="l03216"></a>03216                              <span class="stringliteral">&quot;type instantiation&quot;</span>), name);
<a name="l03217"></a>03217 
<a name="l03218"></a>03218                   j = ii;
<a name="l03219"></a>03219                 }
<a name="l03220"></a>03220 
<a name="l03221"></a>03221               <span class="keywordflow">if</span> (j == -1)
<a name="l03222"></a>03222                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;no matching member function&quot;</span>));
<a name="l03223"></a>03223             }
<a name="l03224"></a>03224 
<a name="l03225"></a>03225           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#ab772f7a2fa3ac127cfd52c64d129ac18">TYPE_FN_FIELD_STATIC_P</a> (f, j))
<a name="l03226"></a>03226             {
<a name="l03227"></a>03227               <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *s = 
<a name="l03228"></a>03228                 <a class="code" href="symtab_8c.html#a8a5c3f803198aed047a55c0e4f61b315">lookup_symbol</a> (<a class="code" href="gdbtypes_8h.html#a027f2138f114a97b7ee81a535d4714b1">TYPE_FN_FIELD_PHYSNAME</a> (f, j),
<a name="l03229"></a>03229                                0, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, 0);
<a name="l03230"></a>03230 
<a name="l03231"></a>03231               <span class="keywordflow">if</span> (s == NULL)
<a name="l03232"></a>03232                 <span class="keywordflow">return</span> NULL;
<a name="l03233"></a>03233 
<a name="l03234"></a>03234               <span class="keywordflow">if</span> (want_address)
<a name="l03235"></a>03235                 <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a29bc320305726a3cbf324189df2ca772">value_addr</a> (<a class="code" href="findvar_8c.html#afeb191a780ccc9cc2d95378bc1413751">read_var_value</a> (s, 0));
<a name="l03236"></a>03236               <span class="keywordflow">else</span>
<a name="l03237"></a>03237                 <span class="keywordflow">return</span> <a class="code" href="findvar_8c.html#afeb191a780ccc9cc2d95378bc1413751">read_var_value</a> (s, 0);
<a name="l03238"></a>03238             }
<a name="l03239"></a>03239 
<a name="l03240"></a>03240           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a7d4951372b6efd1f52238a17cef7c509">TYPE_FN_FIELD_VIRTUAL_P</a> (f, j))
<a name="l03241"></a>03241             {
<a name="l03242"></a>03242               <span class="keywordflow">if</span> (want_address)
<a name="l03243"></a>03243                 {
<a name="l03244"></a>03244                   result = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a>
<a name="l03245"></a>03245                     (<a class="code" href="gdbtypes_8c.html#abe0e31f80a8f4e227727ea42ce596dd9">lookup_methodptr_type</a> (<a class="code" href="gdbtypes_8h.html#a76c6074ace855100086c485428668372">TYPE_FN_FIELD_TYPE</a> (f, j)));
<a name="l03246"></a>03246                   <a class="code" href="cp-abi_8c.html#aa998e448123c366dc7731a862fc94786">cplus_make_method_ptr</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (result),
<a name="l03247"></a>03247                                          <a class="code" href="value_8c.html#a13d7c6c06f661cae284e575c50647344">value_contents_writeable</a> (result),
<a name="l03248"></a>03248                                          <a class="code" href="gdbtypes_8h.html#a39952d3e6dd94ab2067e02ea7be9bbdf">TYPE_FN_FIELD_VOFFSET</a> (f, j), 1);
<a name="l03249"></a>03249                 }
<a name="l03250"></a>03250               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l03251"></a>03251                 <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (<a class="code" href="gdbtypes_8h.html#a76c6074ace855100086c485428668372">TYPE_FN_FIELD_TYPE</a> (f, j));
<a name="l03252"></a>03252               <span class="keywordflow">else</span>
<a name="l03253"></a>03253                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot reference virtual member function \&quot;%s\&quot;&quot;</span>),
<a name="l03254"></a>03254                        name);
<a name="l03255"></a>03255             }
<a name="l03256"></a>03256           <span class="keywordflow">else</span>
<a name="l03257"></a>03257             {
<a name="l03258"></a>03258               <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *s = 
<a name="l03259"></a>03259                 <a class="code" href="symtab_8c.html#a8a5c3f803198aed047a55c0e4f61b315">lookup_symbol</a> (<a class="code" href="gdbtypes_8h.html#a027f2138f114a97b7ee81a535d4714b1">TYPE_FN_FIELD_PHYSNAME</a> (f, j),
<a name="l03260"></a>03260                                0, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, 0);
<a name="l03261"></a>03261 
<a name="l03262"></a>03262               <span class="keywordflow">if</span> (s == NULL)
<a name="l03263"></a>03263                 <span class="keywordflow">return</span> NULL;
<a name="l03264"></a>03264 
<a name="l03265"></a>03265               v = <a class="code" href="findvar_8c.html#afeb191a780ccc9cc2d95378bc1413751">read_var_value</a> (s, 0);
<a name="l03266"></a>03266               <span class="keywordflow">if</span> (!want_address)
<a name="l03267"></a>03267                 result = v;
<a name="l03268"></a>03268               <span class="keywordflow">else</span>
<a name="l03269"></a>03269                 {
<a name="l03270"></a>03270                   result = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (<a class="code" href="gdbtypes_8c.html#abe0e31f80a8f4e227727ea42ce596dd9">lookup_methodptr_type</a> (<a class="code" href="gdbtypes_8h.html#a76c6074ace855100086c485428668372">TYPE_FN_FIELD_TYPE</a> (f, j)));
<a name="l03271"></a>03271                   <a class="code" href="cp-abi_8c.html#aa998e448123c366dc7731a862fc94786">cplus_make_method_ptr</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (result),
<a name="l03272"></a>03272                                          <a class="code" href="value_8c.html#a13d7c6c06f661cae284e575c50647344">value_contents_writeable</a> (result),
<a name="l03273"></a>03273                                          <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (v), 0);
<a name="l03274"></a>03274                 }
<a name="l03275"></a>03275             }
<a name="l03276"></a>03276           <span class="keywordflow">return</span> result;
<a name="l03277"></a>03277         }
<a name="l03278"></a>03278     }
<a name="l03279"></a>03279   <span class="keywordflow">for</span> (i = <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (t) - 1; i &gt;= 0; i--)
<a name="l03280"></a>03280     {
<a name="l03281"></a>03281       <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *v;
<a name="l03282"></a>03282       <span class="keywordtype">int</span> base_offset;
<a name="l03283"></a>03283 
<a name="l03284"></a>03284       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#acc2f1c0fb434ce574171ed5ae0d841cb">BASETYPE_VIA_VIRTUAL</a> (t, i))
<a name="l03285"></a>03285         base_offset = 0;
<a name="l03286"></a>03286       <span class="keywordflow">else</span>
<a name="l03287"></a>03287         base_offset = <a class="code" href="gdbtypes_8h.html#a8131e3735fa0c8a76d2876c349854b7a">TYPE_BASECLASS_BITPOS</a> (t, i) / 8;
<a name="l03288"></a>03288       v = <a class="code" href="valops_8c.html#a107fe3950fecf16bb0bf7ce7290b09f0">value_struct_elt_for_reference</a> (domain,
<a name="l03289"></a>03289                                           offset + base_offset,
<a name="l03290"></a>03290                                           <a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">TYPE_BASECLASS</a> (t, i),
<a name="l03291"></a>03291                                           name, intype, 
<a name="l03292"></a>03292                                           want_address, noside);
<a name="l03293"></a>03293       <span class="keywordflow">if</span> (v)
<a name="l03294"></a>03294         <span class="keywordflow">return</span> v;
<a name="l03295"></a>03295     }
<a name="l03296"></a>03296 
<a name="l03297"></a>03297   <span class="comment">/* As a last chance, pretend that CURTYPE is a namespace, and look</span>
<a name="l03298"></a>03298 <span class="comment">     it up that way; this (frequently) works for types nested inside</span>
<a name="l03299"></a>03299 <span class="comment">     classes.  */</span>
<a name="l03300"></a>03300 
<a name="l03301"></a>03301   <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a1d5f3c2626c3a57cee4586968dd9a1c7">value_maybe_namespace_elt</a> (curtype, name, 
<a name="l03302"></a>03302                                     want_address, noside);
<a name="l03303"></a>03303 }
<a name="l03304"></a>03304 
<a name="l03305"></a>03305 <span class="comment">/* C++: Return the member NAME of the namespace given by the type</span>
<a name="l03306"></a>03306 <span class="comment">   CURTYPE.  */</span>
<a name="l03307"></a>03307 
<a name="l03308"></a>03308 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l03309"></a>03309 <a class="code" href="valops_8c.html#af2efc03285e4b19401311e51300bf427">value_namespace_elt</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *curtype,
<a name="l03310"></a>03310                      <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> want_address,
<a name="l03311"></a>03311                      <span class="keyword">enum</span> noside noside)
<a name="l03312"></a>03312 {
<a name="l03313"></a>03313   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *retval = <a class="code" href="valops_8c.html#a1d5f3c2626c3a57cee4586968dd9a1c7">value_maybe_namespace_elt</a> (curtype, name,
<a name="l03314"></a>03314                                                     want_address, 
<a name="l03315"></a>03315                                                     noside);
<a name="l03316"></a>03316 
<a name="l03317"></a>03317   <span class="keywordflow">if</span> (retval == NULL)
<a name="l03318"></a>03318     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No symbol \&quot;%s\&quot; in namespace \&quot;%s\&quot;.&quot;</span>), 
<a name="l03319"></a>03319            name, <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (curtype));
<a name="l03320"></a>03320 
<a name="l03321"></a>03321   <span class="keywordflow">return</span> retval;
<a name="l03322"></a>03322 }
<a name="l03323"></a>03323 
<a name="l03324"></a>03324 <span class="comment">/* A helper function used by value_namespace_elt and</span>
<a name="l03325"></a>03325 <span class="comment">   value_struct_elt_for_reference.  It looks up NAME inside the</span>
<a name="l03326"></a>03326 <span class="comment">   context CURTYPE; this works if CURTYPE is a namespace or if CURTYPE</span>
<a name="l03327"></a>03327 <span class="comment">   is a class and NAME refers to a type in CURTYPE itself (as opposed</span>
<a name="l03328"></a>03328 <span class="comment">   to, say, some base class of CURTYPE).  */</span>
<a name="l03329"></a>03329 
<a name="l03330"></a>03330 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l03331"></a>03331 <a class="code" href="valops_8c.html#a1d5f3c2626c3a57cee4586968dd9a1c7">value_maybe_namespace_elt</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *curtype,
<a name="l03332"></a>03332                            <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> want_address,
<a name="l03333"></a>03333                            <span class="keyword">enum</span> noside noside)
<a name="l03334"></a>03334 {
<a name="l03335"></a>03335   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dwarf2read_8c.html#aa36ad06e3757cedacef0e32245045b4b">namespace_name</a> = <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (curtype);
<a name="l03336"></a>03336   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l03337"></a>03337   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *result;
<a name="l03338"></a>03338 
<a name="l03339"></a>03339   sym = <a class="code" href="cp-namespace_8c.html#a7890ae77ebe0e55985a5cf7f50353785">cp_lookup_symbol_namespace</a> (namespace_name, name,
<a name="l03340"></a>03340                                     <a class="code" href="frame_8h.html#a91efbdcf182d840c28d378def97cfc23">get_selected_block</a> (0), <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>);
<a name="l03341"></a>03341 
<a name="l03342"></a>03342   <span class="keywordflow">if</span> (sym == NULL)
<a name="l03343"></a>03343     {
<a name="l03344"></a>03344       <span class="keywordtype">char</span> *concatenated_name = alloca (strlen (namespace_name) + 2
<a name="l03345"></a>03345                                         + strlen (name) + 1);
<a name="l03346"></a>03346 
<a name="l03347"></a>03347       sprintf (concatenated_name, <span class="stringliteral">&quot;%s::%s&quot;</span>, namespace_name, name);
<a name="l03348"></a>03348       sym = <a class="code" href="symtab_8c.html#a58d5919fc29444fc279a03b196d87b42">lookup_static_symbol_aux</a> (concatenated_name, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>);
<a name="l03349"></a>03349     }
<a name="l03350"></a>03350 
<a name="l03351"></a>03351   <span class="keywordflow">if</span> (sym == NULL)
<a name="l03352"></a>03352     <span class="keywordflow">return</span> NULL;
<a name="l03353"></a>03353   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l03354"></a>03354            &amp;&amp; (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>))
<a name="l03355"></a>03355     result = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym));
<a name="l03356"></a>03356   <span class="keywordflow">else</span>
<a name="l03357"></a>03357     result = <a class="code" href="valops_8c.html#a353e75e3afb5f274e886d08360d045b8">value_of_variable</a> (sym, <a class="code" href="frame_8h.html#a91efbdcf182d840c28d378def97cfc23">get_selected_block</a> (0));
<a name="l03358"></a>03358 
<a name="l03359"></a>03359   <span class="keywordflow">if</span> (result &amp;&amp; want_address)
<a name="l03360"></a>03360     result = <a class="code" href="valops_8c.html#a29bc320305726a3cbf324189df2ca772">value_addr</a> (result);
<a name="l03361"></a>03361 
<a name="l03362"></a>03362   <span class="keywordflow">return</span> result;
<a name="l03363"></a>03363 }
<a name="l03364"></a>03364 
<a name="l03365"></a>03365 <span class="comment">/* Given a pointer or a reference value V, find its real (RTTI) type.</span>
<a name="l03366"></a>03366 <span class="comment"></span>
<a name="l03367"></a>03367 <span class="comment">   Other parameters FULL, TOP, USING_ENC as with value_rtti_type()</span>
<a name="l03368"></a>03368 <span class="comment">   and refer to the values computed for the object pointed to.  */</span>
<a name="l03369"></a>03369 
<a name="l03370"></a>03370 <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l03371"></a><a class="code" href="value_8h.html#a8a7d7ae1f5466a1a60b145bc09eb8397">03371</a> <a class="code" href="valops_8c.html#a01607a79d24e6fecde68f8119097118f">value_rtti_indirect_type</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *v, <span class="keywordtype">int</span> *full, 
<a name="l03372"></a>03372                           <span class="keywordtype">int</span> *top, <span class="keywordtype">int</span> *using_enc)
<a name="l03373"></a>03373 {
<a name="l03374"></a>03374   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *target;
<a name="l03375"></a>03375   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>, *real_type, *target_type;
<a name="l03376"></a>03376 
<a name="l03377"></a>03377   type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (v);
<a name="l03378"></a>03378   type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (type);
<a name="l03379"></a>03379   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l03380"></a>03380     target = <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (v);
<a name="l03381"></a>03381   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l03382"></a>03382     target = <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (v);
<a name="l03383"></a>03383   <span class="keywordflow">else</span>
<a name="l03384"></a>03384     <span class="keywordflow">return</span> NULL;
<a name="l03385"></a>03385 
<a name="l03386"></a>03386   real_type = <a class="code" href="cp-abi_8c.html#a2e4a56716a4c26e96f1ce00c93f83c04">value_rtti_type</a> (target, full, top, using_enc);
<a name="l03387"></a>03387 
<a name="l03388"></a>03388   <span class="keywordflow">if</span> (real_type)
<a name="l03389"></a>03389     {
<a name="l03390"></a>03390       <span class="comment">/* Copy qualifiers to the referenced object.  */</span>
<a name="l03391"></a>03391       target_type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (target);
<a name="l03392"></a>03392       real_type = <a class="code" href="gdbtypes_8c.html#ab5e31dbb249efdac4f48d4871290bf46">make_cv_type</a> (<a class="code" href="gdbtypes_8h.html#a82b926a1727ba5c6b856145197495a34">TYPE_CONST</a> (target_type),
<a name="l03393"></a>03393                                 <a class="code" href="gdbtypes_8h.html#a85371642c55e599b0d13fc95d0108ad1">TYPE_VOLATILE</a> (target_type), real_type, NULL);
<a name="l03394"></a>03394       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l03395"></a>03395         real_type = <a class="code" href="gdbtypes_8c.html#afa9bb6a94856e413a9932abea7356e22">lookup_reference_type</a> (real_type);
<a name="l03396"></a>03396       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l03397"></a>03397         real_type = <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (real_type);
<a name="l03398"></a>03398       <span class="keywordflow">else</span>
<a name="l03399"></a>03399         <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unexpected value type.&quot;</span>));
<a name="l03400"></a>03400 
<a name="l03401"></a>03401       <span class="comment">/* Copy qualifiers to the pointer/reference.  */</span>
<a name="l03402"></a>03402       real_type = <a class="code" href="gdbtypes_8c.html#ab5e31dbb249efdac4f48d4871290bf46">make_cv_type</a> (<a class="code" href="gdbtypes_8h.html#a82b926a1727ba5c6b856145197495a34">TYPE_CONST</a> (type), <a class="code" href="gdbtypes_8h.html#a85371642c55e599b0d13fc95d0108ad1">TYPE_VOLATILE</a> (type),
<a name="l03403"></a>03403                                 real_type, NULL);
<a name="l03404"></a>03404     }
<a name="l03405"></a>03405 
<a name="l03406"></a>03406   <span class="keywordflow">return</span> real_type;
<a name="l03407"></a>03407 }
<a name="l03408"></a>03408 
<a name="l03409"></a>03409 <span class="comment">/* Given a value pointed to by ARGP, check its real run-time type, and</span>
<a name="l03410"></a>03410 <span class="comment">   if that is different from the enclosing type, create a new value</span>
<a name="l03411"></a>03411 <span class="comment">   using the real run-time type as the enclosing type (and of the same</span>
<a name="l03412"></a>03412 <span class="comment">   type as ARGP) and return it, with the embedded offset adjusted to</span>
<a name="l03413"></a>03413 <span class="comment">   be the correct offset to the enclosed object.  RTYPE is the type,</span>
<a name="l03414"></a>03414 <span class="comment">   and XFULL, XTOP, and XUSING_ENC are the other parameters, computed</span>
<a name="l03415"></a>03415 <span class="comment">   by value_rtti_type().  If these are available, they can be supplied</span>
<a name="l03416"></a>03416 <span class="comment">   and a second call to value_rtti_type() is avoided.  (Pass RTYPE ==</span>
<a name="l03417"></a>03417 <span class="comment">   NULL if they&#39;re not available.  */</span>
<a name="l03418"></a>03418 
<a name="l03419"></a>03419 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l03420"></a><a class="code" href="value_8h.html#af98214416883b8de98bee35e6966e462">03420</a> <a class="code" href="valops_8c.html#ad255d8fbb1ae5eb8ea28ad8befb22c92">value_full_object</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *argp, 
<a name="l03421"></a>03421                    <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *rtype, 
<a name="l03422"></a>03422                    <span class="keywordtype">int</span> xfull, <span class="keywordtype">int</span> xtop,
<a name="l03423"></a>03423                    <span class="keywordtype">int</span> xusing_enc)
<a name="l03424"></a>03424 {
<a name="l03425"></a>03425   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *real_type;
<a name="l03426"></a>03426   <span class="keywordtype">int</span> full = 0;
<a name="l03427"></a>03427   <span class="keywordtype">int</span> top = -1;
<a name="l03428"></a>03428   <span class="keywordtype">int</span> using_enc = 0;
<a name="l03429"></a>03429   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *new_val;
<a name="l03430"></a>03430 
<a name="l03431"></a>03431   <span class="keywordflow">if</span> (rtype)
<a name="l03432"></a>03432     {
<a name="l03433"></a>03433       real_type = rtype;
<a name="l03434"></a>03434       full = xfull;
<a name="l03435"></a>03435       top = xtop;
<a name="l03436"></a>03436       using_enc = xusing_enc;
<a name="l03437"></a>03437     }
<a name="l03438"></a>03438   <span class="keywordflow">else</span>
<a name="l03439"></a>03439     real_type = <a class="code" href="cp-abi_8c.html#a2e4a56716a4c26e96f1ce00c93f83c04">value_rtti_type</a> (argp, &amp;full, &amp;top, &amp;using_enc);
<a name="l03440"></a>03440 
<a name="l03441"></a>03441   <span class="comment">/* If no RTTI data, or if object is already complete, do nothing.  */</span>
<a name="l03442"></a>03442   <span class="keywordflow">if</span> (!real_type || real_type == <a class="code" href="value_8c.html#a23e0abd15939236dcae8b0c5c0674b1b">value_enclosing_type</a> (argp))
<a name="l03443"></a>03443     <span class="keywordflow">return</span> argp;
<a name="l03444"></a>03444 
<a name="l03445"></a>03445   <span class="comment">/* In a destructor we might see a real type that is a superclass of</span>
<a name="l03446"></a>03446 <span class="comment">     the object&#39;s type.  In this case it is better to leave the object</span>
<a name="l03447"></a>03447 <span class="comment">     as-is.  */</span>
<a name="l03448"></a>03448   <span class="keywordflow">if</span> (full
<a name="l03449"></a>03449       &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (real_type) &lt; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a23e0abd15939236dcae8b0c5c0674b1b">value_enclosing_type</a> (argp)))
<a name="l03450"></a>03450     <span class="keywordflow">return</span> argp;
<a name="l03451"></a>03451 
<a name="l03452"></a>03452   <span class="comment">/* If we have the full object, but for some reason the enclosing</span>
<a name="l03453"></a>03453 <span class="comment">     type is wrong, set it.  */</span>
<a name="l03454"></a>03454   <span class="comment">/* pai: FIXME -- sounds iffy */</span>
<a name="l03455"></a>03455   <span class="keywordflow">if</span> (full)
<a name="l03456"></a>03456     {
<a name="l03457"></a>03457       argp = <a class="code" href="value_8c.html#abe2b4f6342cfefdbb63666b6bcba636b">value_copy</a> (argp);
<a name="l03458"></a>03458       <a class="code" href="value_8c.html#ac90fd2d225f145f10b5f4d515027d7d2">set_value_enclosing_type</a> (argp, real_type);
<a name="l03459"></a>03459       <span class="keywordflow">return</span> argp;
<a name="l03460"></a>03460     }
<a name="l03461"></a>03461 
<a name="l03462"></a>03462   <span class="comment">/* Check if object is in memory.  */</span>
<a name="l03463"></a>03463   <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (argp) != <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>)
<a name="l03464"></a>03464     {
<a name="l03465"></a>03465       <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Couldn&#39;t retrieve complete object of RTTI &quot;</span>
<a name="l03466"></a>03466                  <span class="stringliteral">&quot;type %s; object may be in register(s).&quot;</span>), 
<a name="l03467"></a>03467                <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (real_type));
<a name="l03468"></a>03468 
<a name="l03469"></a>03469       <span class="keywordflow">return</span> argp;
<a name="l03470"></a>03470     }
<a name="l03471"></a>03471 
<a name="l03472"></a>03472   <span class="comment">/* All other cases -- retrieve the complete object.  */</span>
<a name="l03473"></a>03473   <span class="comment">/* Go back by the computed top_offset from the beginning of the</span>
<a name="l03474"></a>03474 <span class="comment">     object, adjusting for the embedded offset of argp if that&#39;s what</span>
<a name="l03475"></a>03475 <span class="comment">     value_rtti_type used for its computation.  */</span>
<a name="l03476"></a>03476   new_val = <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (real_type, <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (argp) - top +
<a name="l03477"></a>03477                            (using_enc ? 0 : <a class="code" href="value_8c.html#acbd6146ab9bd4c54f994a895a66f3f3d">value_embedded_offset</a> (argp)));
<a name="l03478"></a>03478   <a class="code" href="value_8c.html#adac1b2d5054e2d7b44ea25ac1f8002f1">deprecated_set_value_type</a> (new_val, <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (argp));
<a name="l03479"></a>03479   <a class="code" href="value_8c.html#a24d431e297ffee09519c654c96438ecc">set_value_embedded_offset</a> (new_val, (using_enc
<a name="l03480"></a>03480                                        ? top + <a class="code" href="value_8c.html#acbd6146ab9bd4c54f994a895a66f3f3d">value_embedded_offset</a> (argp)
<a name="l03481"></a>03481                                        : top));
<a name="l03482"></a>03482   <span class="keywordflow">return</span> new_val;
<a name="l03483"></a>03483 }
<a name="l03484"></a>03484 
<a name="l03485"></a>03485 
<a name="l03486"></a>03486 <span class="comment">/* Return the value of the local variable, if one exists.  Throw error</span>
<a name="l03487"></a>03487 <span class="comment">   otherwise, such as if the request is made in an inappropriate context.  */</span>
<a name="l03488"></a>03488 
<a name="l03489"></a>03489 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l03490"></a><a class="code" href="value_8h.html#acbe62500a5d4216eba3777d4fa0018d9">03490</a> <a class="code" href="valops_8c.html#acbe62500a5d4216eba3777d4fa0018d9">value_of_this</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlanguage__defn.html">language_defn</a> *lang)
<a name="l03491"></a>03491 {
<a name="l03492"></a>03492   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l03493"></a>03493   <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *b;
<a name="l03494"></a>03494   <span class="keyword">struct </span><a class="code" href="structframe__info.html">frame_info</a> *frame;
<a name="l03495"></a>03495 
<a name="l03496"></a>03496   <span class="keywordflow">if</span> (!lang-&gt;<a class="code" href="structlanguage__defn.html#a00a28645478628abeb2ddaef74c055e4">la_name_of_this</a>)
<a name="l03497"></a>03497     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;no `this&#39; in current language&quot;</span>));
<a name="l03498"></a>03498 
<a name="l03499"></a>03499   frame = <a class="code" href="frame_8c.html#a8b714a78478670e14a297eba8d1a9915">get_selected_frame</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;no frame selected&quot;</span>));
<a name="l03500"></a>03500 
<a name="l03501"></a>03501   b = <a class="code" href="blockframe_8c.html#a48cd98610b3a7f167334b616336cadfb">get_frame_block</a> (frame, NULL);
<a name="l03502"></a>03502 
<a name="l03503"></a>03503   sym = <a class="code" href="symtab_8c.html#ad8a7da9f944bb2884adeb755378e9b9d">lookup_language_this</a> (lang, b);
<a name="l03504"></a>03504   <span class="keywordflow">if</span> (sym == NULL)
<a name="l03505"></a>03505     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;current stack frame does not contain a variable named `%s&#39;&quot;</span>),
<a name="l03506"></a>03506            lang-&gt;<a class="code" href="structlanguage__defn.html#a00a28645478628abeb2ddaef74c055e4">la_name_of_this</a>);
<a name="l03507"></a>03507 
<a name="l03508"></a>03508   <span class="keywordflow">return</span> <a class="code" href="findvar_8c.html#afeb191a780ccc9cc2d95378bc1413751">read_var_value</a> (sym, frame);
<a name="l03509"></a>03509 }
<a name="l03510"></a>03510 
<a name="l03511"></a>03511 <span class="comment">/* Return the value of the local variable, if one exists.  Return NULL</span>
<a name="l03512"></a>03512 <span class="comment">   otherwise.  Never throw error.  */</span>
<a name="l03513"></a>03513 
<a name="l03514"></a>03514 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l03515"></a><a class="code" href="value_8h.html#a4e215f9a92255a91139406ca66cfe147">03515</a> <a class="code" href="valops_8c.html#a4e215f9a92255a91139406ca66cfe147">value_of_this_silent</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlanguage__defn.html">language_defn</a> *lang)
<a name="l03516"></a>03516 {
<a name="l03517"></a>03517   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *ret = NULL;
<a name="l03518"></a>03518   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> except;
<a name="l03519"></a>03519 
<a name="l03520"></a>03520   <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l03521"></a>03521     {
<a name="l03522"></a>03522       ret = <a class="code" href="valops_8c.html#acbe62500a5d4216eba3777d4fa0018d9">value_of_this</a> (lang);
<a name="l03523"></a>03523     }
<a name="l03524"></a>03524 
<a name="l03525"></a>03525   <span class="keywordflow">return</span> ret;
<a name="l03526"></a>03526 }
<a name="l03527"></a>03527 
<a name="l03528"></a>03528 <span class="comment">/* Create a slice (sub-string, sub-array) of ARRAY, that is LENGTH</span>
<a name="l03529"></a>03529 <span class="comment">   elements long, starting at LOWBOUND.  The result has the same lower</span>
<a name="l03530"></a>03530 <span class="comment">   bound as the original ARRAY.  */</span>
<a name="l03531"></a>03531 
<a name="l03532"></a>03532 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l03533"></a><a class="code" href="value_8h.html#a4d9958135073ad3dbd9ead52c8d363be">03533</a> <a class="code" href="valops_8c.html#adb4d883c475f4c92b1afc51dbd6b638c">value_slice</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *array, <span class="keywordtype">int</span> lowbound, <span class="keywordtype">int</span> length)
<a name="l03534"></a>03534 {
<a name="l03535"></a>03535   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *slice_range_type, *slice_type, *range_type;
<a name="l03536"></a>03536   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> lowerbound, upperbound;
<a name="l03537"></a>03537   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *slice;
<a name="l03538"></a>03538   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *array_type;
<a name="l03539"></a>03539 
<a name="l03540"></a>03540   array_type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array));
<a name="l03541"></a>03541   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (array_type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l03542"></a>03542       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (array_type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a956ce01e5c83060e05208c9404fedca2">TYPE_CODE_STRING</a>)
<a name="l03543"></a>03543     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot take slice of non-array&quot;</span>));
<a name="l03544"></a>03544 
<a name="l03545"></a>03545   range_type = <a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (array_type);
<a name="l03546"></a>03546   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#a6b7f508cb2cdaf4d8f53494d9239b163">get_discrete_bounds</a> (range_type, &amp;lowerbound, &amp;upperbound) &lt; 0)
<a name="l03547"></a>03547     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;slice from bad array or bitstring&quot;</span>));
<a name="l03548"></a>03548 
<a name="l03549"></a>03549   <span class="keywordflow">if</span> (lowbound &lt; lowerbound || length &lt; 0
<a name="l03550"></a>03550       || lowbound + length - 1 &gt; upperbound)
<a name="l03551"></a>03551     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;slice out of range&quot;</span>));
<a name="l03552"></a>03552 
<a name="l03553"></a>03553   <span class="comment">/* FIXME-type-allocation: need a way to free this type when we are</span>
<a name="l03554"></a>03554 <span class="comment">     done with it.  */</span>
<a name="l03555"></a>03555   slice_range_type = <a class="code" href="gdbtypes_8c.html#ab0885fdae181c47ff3f958bcba70b82d">create_range_type</a> ((<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *) NULL,
<a name="l03556"></a>03556                                         <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (range_type),
<a name="l03557"></a>03557                                         lowbound, 
<a name="l03558"></a>03558                                         lowbound + length - 1);
<a name="l03559"></a>03559 
<a name="l03560"></a>03560     {
<a name="l03561"></a>03561       <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *element_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (array_type);
<a name="l03562"></a>03562       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> offset =
<a name="l03563"></a>03563         (lowbound - lowerbound) * <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (element_type));
<a name="l03564"></a>03564 
<a name="l03565"></a>03565       slice_type = <a class="code" href="gdbtypes_8c.html#a779bbebb8202264a73344b49b22d774e">create_array_type</a> ((<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *) NULL, 
<a name="l03566"></a>03566                                       element_type,
<a name="l03567"></a>03567                                       slice_range_type);
<a name="l03568"></a>03568       <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (slice_type) = <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (array_type);
<a name="l03569"></a>03569 
<a name="l03570"></a>03570       <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (array) == <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a> &amp;&amp; <a class="code" href="value_8c.html#aa60bc8ecf77867a2d16bec57a4ccf983">value_lazy</a> (array))
<a name="l03571"></a>03571         slice = <a class="code" href="value_8c.html#a8421b27c5fb4ce6e2c972ecce4265d1b">allocate_value_lazy</a> (slice_type);
<a name="l03572"></a>03572       <span class="keywordflow">else</span>
<a name="l03573"></a>03573         {
<a name="l03574"></a>03574           slice = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (slice_type);
<a name="l03575"></a>03575           <a class="code" href="value_8c.html#a05f447d7418303febbc0a5f7e570834e">value_contents_copy</a> (slice, 0, array, offset,
<a name="l03576"></a>03576                                <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (slice_type));
<a name="l03577"></a>03577         }
<a name="l03578"></a>03578 
<a name="l03579"></a>03579       <a class="code" href="value_8c.html#a3b68f85fbdfad03a038292fef7520e53">set_value_component_location</a> (slice, array);
<a name="l03580"></a>03580       <a class="code" href="value_8h.html#aced704dd83f00b026dbbc39446616338">VALUE_FRAME_ID</a> (slice) = <a class="code" href="value_8h.html#aced704dd83f00b026dbbc39446616338">VALUE_FRAME_ID</a> (array);
<a name="l03581"></a>03581       <a class="code" href="value_8c.html#a3d475a6b1e01fde10fa68ed0d666067e">set_value_offset</a> (slice, <a class="code" href="value_8c.html#aff69bf52c3773e7afc5f95b6ef302b1c">value_offset</a> (array) + offset);
<a name="l03582"></a>03582     }
<a name="l03583"></a>03583   <span class="keywordflow">return</span> slice;
<a name="l03584"></a>03584 }
<a name="l03585"></a>03585 
<a name="l03586"></a>03586 <span class="comment">/* Create a value for a FORTRAN complex number.  Currently most of the</span>
<a name="l03587"></a>03587 <span class="comment">   time values are coerced to COMPLEX*16 (i.e. a complex number</span>
<a name="l03588"></a>03588 <span class="comment">   composed of 2 doubles.  This really should be a smarter routine</span>
<a name="l03589"></a>03589 <span class="comment">   that figures out precision inteligently as opposed to assuming</span>
<a name="l03590"></a>03590 <span class="comment">   doubles.  FIXME: fmb  */</span>
<a name="l03591"></a>03591 
<a name="l03592"></a>03592 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l03593"></a><a class="code" href="value_8h.html#ac81847d53f91454b012be169ffeeeb53">03593</a> <a class="code" href="valops_8c.html#a37d6ba97e0604e014e908e48b5d0ee2c">value_literal_complex</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *arg1, 
<a name="l03594"></a>03594                        <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *arg2,
<a name="l03595"></a>03595                        <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>)
<a name="l03596"></a>03596 {
<a name="l03597"></a>03597   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *val;
<a name="l03598"></a>03598   <span class="keyword">struct </span>type *real_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l03599"></a>03599 
<a name="l03600"></a>03600   val = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (type);
<a name="l03601"></a>03601   arg1 = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (real_type, arg1);
<a name="l03602"></a>03602   arg2 = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (real_type, arg2);
<a name="l03603"></a>03603 
<a name="l03604"></a>03604   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="value_8c.html#a9f59e572fabef6e1905632fb81cc00e1">value_contents_raw</a> (val),
<a name="l03605"></a>03605           <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (arg1), <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (real_type));
<a name="l03606"></a>03606   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="value_8c.html#a9f59e572fabef6e1905632fb81cc00e1">value_contents_raw</a> (val) + <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (real_type),
<a name="l03607"></a>03607           <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (arg2), <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (real_type));
<a name="l03608"></a>03608   <span class="keywordflow">return</span> val;
<a name="l03609"></a>03609 }
<a name="l03610"></a>03610 
<a name="l03611"></a>03611 <span class="comment">/* Cast a value into the appropriate complex data type.  */</span>
<a name="l03612"></a>03612 
<a name="l03613"></a>03613 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l03614"></a><a class="code" href="valops_8c.html#aa6339bc660215f0da06ebafed0703d20">03614</a> <a class="code" href="valops_8c.html#aa6339bc660215f0da06ebafed0703d20">cast_into_complex</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *val)
<a name="l03615"></a>03615 {
<a name="l03616"></a>03616   <span class="keyword">struct </span>type *real_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l03617"></a>03617 
<a name="l03618"></a>03618   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad8de4d143b624cd2bcab740a51a04658">TYPE_CODE_COMPLEX</a>)
<a name="l03619"></a>03619     {
<a name="l03620"></a>03620       <span class="keyword">struct </span>type *val_real_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val));
<a name="l03621"></a>03621       <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *re_val = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (val_real_type);
<a name="l03622"></a>03622       <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *im_val = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (val_real_type);
<a name="l03623"></a>03623 
<a name="l03624"></a>03624       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="value_8c.html#a9f59e572fabef6e1905632fb81cc00e1">value_contents_raw</a> (re_val),
<a name="l03625"></a>03625               <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (val), <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (val_real_type));
<a name="l03626"></a>03626       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="value_8c.html#a9f59e572fabef6e1905632fb81cc00e1">value_contents_raw</a> (im_val),
<a name="l03627"></a>03627               <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (val) + <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (val_real_type),
<a name="l03628"></a>03628               <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (val_real_type));
<a name="l03629"></a>03629 
<a name="l03630"></a>03630       <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a37d6ba97e0604e014e908e48b5d0ee2c">value_literal_complex</a> (re_val, im_val, type);
<a name="l03631"></a>03631     }
<a name="l03632"></a>03632   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>
<a name="l03633"></a>03633            || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>)
<a name="l03634"></a>03634     <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a37d6ba97e0604e014e908e48b5d0ee2c">value_literal_complex</a> (val, 
<a name="l03635"></a>03635                                   <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (real_type, <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>), 
<a name="l03636"></a>03636                                   type);
<a name="l03637"></a>03637   <span class="keywordflow">else</span>
<a name="l03638"></a>03638     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot cast non-number to complex&quot;</span>));
<a name="l03639"></a>03639 }
<a name="l03640"></a>03640 
<a name="l03641"></a>03641 <span class="keywordtype">void</span>
<a name="l03642"></a><a class="code" href="init_8c.html#a347aadb7eb733d717880347d098fa7a4">03642</a> <a class="code" href="init_8c.html#a347aadb7eb733d717880347d098fa7a4">_initialize_valops</a> (<span class="keywordtype">void</span>)
<a name="l03643"></a>03643 {
<a name="l03644"></a>03644   <a class="code" href="cli-decode_8c.html#ad86a0f135b6c546ae7ffbb41fd72e14f">add_setshow_boolean_cmd</a> (<span class="stringliteral">&quot;overload-resolution&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a92be6efbab6bd9647a6f7a2862712d9b">class_support</a>,
<a name="l03645"></a>03645                            &amp;<a class="code" href="eval_8c.html#a77a4a275864a2a5a429965b0136adbc6">overload_resolution</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l03646"></a>03646 <span class="stringliteral">Set overload resolution in evaluating C++ functions.&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l03647"></a>03647 <span class="stringliteral">Show overload resolution in evaluating C++ functions.&quot;</span>), 
<a name="l03648"></a>03648                            NULL, NULL,
<a name="l03649"></a>03649                            <a class="code" href="valops_8c.html#a9282b1fefb8a60702d131f7d8865afaf">show_overload_resolution</a>,
<a name="l03650"></a>03650                            &amp;<a class="code" href="cli-cmds_8c.html#a723e0174d833cba0aa82fb936a56c8fa">setlist</a>, &amp;<a class="code" href="cli-cmds_8c.html#a003932aa76fd3f41763ecc6bee5e2ca8">showlist</a>);
<a name="l03651"></a>03651   <a class="code" href="eval_8c.html#a77a4a275864a2a5a429965b0136adbc6">overload_resolution</a> = 1;
<a name="l03652"></a>03652 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:13:35 for GDB (xrefs) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
