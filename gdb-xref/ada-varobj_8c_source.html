<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (xrefs): /home/stan/gdb/src/gdb/ada-varobj.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (xrefs)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/ada-varobj.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="ada-varobj_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* varobj support for Ada.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 2012-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   This file is part of GDB.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00010"></a>00010 <span class="comment">   (at your option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00018"></a>00018 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="ada-varobj_8h.html">ada-varobj.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="ada-lang_8h.html">ada-lang.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="language_8h.html">language.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="valprint_8h.html">valprint.h</a>&quot;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="comment">/* Implementation principle used in this unit:</span>
<a name="l00027"></a>00027 <span class="comment"></span>
<a name="l00028"></a>00028 <span class="comment">   For our purposes, the meat of the varobj object is made of two</span>
<a name="l00029"></a>00029 <span class="comment">   elements: The varobj&#39;s (struct) value, and the varobj&#39;s (struct)</span>
<a name="l00030"></a>00030 <span class="comment">   type.  In most situations, the varobj has a non-NULL value, and</span>
<a name="l00031"></a>00031 <span class="comment">   the type becomes redundant, as it can be directly derived from</span>
<a name="l00032"></a>00032 <span class="comment">   the value.  In the initial implementation of this unit, most</span>
<a name="l00033"></a>00033 <span class="comment">   routines would only take a value, and return a value.</span>
<a name="l00034"></a>00034 <span class="comment"></span>
<a name="l00035"></a>00035 <span class="comment">   But there are many situations where it is possible for a varobj</span>
<a name="l00036"></a>00036 <span class="comment">   to have a NULL value.  For instance, if the varobj becomes out of</span>
<a name="l00037"></a>00037 <span class="comment">   scope.  Or better yet, when the varobj is the child of another</span>
<a name="l00038"></a>00038 <span class="comment">   NULL pointer varobj.  In that situation, we must rely on the type</span>
<a name="l00039"></a>00039 <span class="comment">   instead of the value to create the child varobj.</span>
<a name="l00040"></a>00040 <span class="comment"></span>
<a name="l00041"></a>00041 <span class="comment">   That&#39;s why most functions below work with a (value, type) pair.</span>
<a name="l00042"></a>00042 <span class="comment">   The value may or may not be NULL.  But the type is always expected</span>
<a name="l00043"></a>00043 <span class="comment">   to be set.  When the value is NULL, then we work with the type</span>
<a name="l00044"></a>00044 <span class="comment">   alone, and keep the value NULL.  But when the value is not NULL,</span>
<a name="l00045"></a>00045 <span class="comment">   then we work using the value, because it provides more information.</span>
<a name="l00046"></a>00046 <span class="comment">   But we still always set the type as well, even if that type could</span>
<a name="l00047"></a>00047 <span class="comment">   easily be derived from the value.  The reason behind this is that</span>
<a name="l00048"></a>00048 <span class="comment">   it allows the code to use the type without having to worry about</span>
<a name="l00049"></a>00049 <span class="comment">   it being set or not.  It makes the code clearer.  */</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="comment">/* A convenience function that decodes the VALUE_PTR/TYPE_PTR couple:</span>
<a name="l00052"></a>00052 <span class="comment">   If there is a value (*VALUE_PTR not NULL), then perform the decoding</span>
<a name="l00053"></a>00053 <span class="comment">   using it, and compute the associated type from the resulting value.</span>
<a name="l00054"></a>00054 <span class="comment">   Otherwise, compute a static approximation of *TYPE_PTR, leaving</span>
<a name="l00055"></a>00055 <span class="comment">   *VALUE_PTR unchanged.</span>
<a name="l00056"></a>00056 <span class="comment"></span>
<a name="l00057"></a>00057 <span class="comment">   The results are written in place.  */</span>
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00060"></a><a class="code" href="ada-varobj_8c.html#a47aee56dfaa82ff3882493fff8c69216">00060</a> <a class="code" href="ada-varobj_8c.html#a47aee56dfaa82ff3882493fff8c69216">ada_varobj_decode_var</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **<a class="code" href="structvalue.html">value_ptr</a>, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **<a class="code" href="structtype.html">type_ptr</a>)
<a name="l00061"></a>00061 {
<a name="l00062"></a>00062   <span class="keywordflow">if</span> (*value_ptr)
<a name="l00063"></a>00063     {
<a name="l00064"></a>00064       *value_ptr = <a class="code" href="ada-lang_8c.html#a418ac2f77a5357313be0b37efc61ebfb">ada_get_decoded_value</a> (*value_ptr);
<a name="l00065"></a>00065       *type_ptr = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (*value_ptr));
<a name="l00066"></a>00066     }
<a name="l00067"></a>00067   <span class="keywordflow">else</span>
<a name="l00068"></a>00068     *type_ptr = <a class="code" href="ada-lang_8c.html#ae79f64d3d7ea8e5dd3ac506cb9ba7a44">ada_get_decoded_type</a> (*type_ptr);
<a name="l00069"></a>00069 }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="comment">/* Return a string containing an image of the given scalar value.</span>
<a name="l00072"></a>00072 <span class="comment">   VAL is the numeric value, while TYPE is the value&#39;s type.</span>
<a name="l00073"></a>00073 <span class="comment">   This is useful for plain integers, of course, but even more</span>
<a name="l00074"></a>00074 <span class="comment">   so for enumerated types.</span>
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">   The result should be deallocated by xfree after use.  */</span>
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00079"></a><a class="code" href="ada-varobj_8c.html#a82e9758dd21d4c88f0d2a3ff788f373b">00079</a> <a class="code" href="ada-varobj_8c.html#a82e9758dd21d4c88f0d2a3ff788f373b">ada_varobj_scalar_image</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> val)
<a name="l00080"></a>00080 {
<a name="l00081"></a>00081   <span class="keyword">struct </span><a class="code" href="structui__file.html">ui_file</a> *buf = <a class="code" href="ui-file_8c.html#a340771735f105582d314e191a399a45c">mem_fileopen</a> ();
<a name="l00082"></a>00082   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups = <a class="code" href="utils_8c.html#a94dc56baeb57791e114136764f7763aa">make_cleanup_ui_file_delete</a> (buf);
<a name="l00083"></a>00083   <span class="keywordtype">char</span> *result;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085   <a class="code" href="ada-lang_8h.html#a26642426c02d598a1bc9caae498c7a35">ada_print_scalar</a> (type, val, buf);
<a name="l00086"></a>00086   result = <a class="code" href="ui-file_8c.html#a995485039ce5a1d994a1863cd76a5356">ui_file_xstrdup</a> (buf, NULL);
<a name="l00087"></a>00087   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l00088"></a>00088 
<a name="l00089"></a>00089   <span class="keywordflow">return</span> result;
<a name="l00090"></a>00090 }
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="comment">/* Assuming that the (PARENT_VALUE, PARENT_TYPE) pair designates</span>
<a name="l00093"></a>00093 <span class="comment">   a struct or union, compute the (CHILD_VALUE, CHILD_TYPE) couple</span>
<a name="l00094"></a>00094 <span class="comment">   corresponding to the field number FIELDNO.  */</span>
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00097"></a><a class="code" href="ada-varobj_8c.html#aa4415d3abf1846d642662bc90780893f">00097</a> <a class="code" href="ada-varobj_8c.html#aa4415d3abf1846d642662bc90780893f">ada_varobj_struct_elt</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00098"></a>00098                        <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type,
<a name="l00099"></a>00099                        <span class="keywordtype">int</span> fieldno,
<a name="l00100"></a>00100                        <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **child_value,
<a name="l00101"></a>00101                        <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **child_type)
<a name="l00102"></a>00102 {
<a name="l00103"></a>00103   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html">value</a> = NULL;
<a name="l00104"></a>00104   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = NULL;
<a name="l00105"></a>00105 
<a name="l00106"></a>00106   <span class="keywordflow">if</span> (parent_value)
<a name="l00107"></a>00107     {
<a name="l00108"></a>00108       value = <a class="code" href="value_8c.html#a05553e1fa45b56bcd8bd362ce3a4ef10">value_field</a> (parent_value, fieldno);
<a name="l00109"></a>00109       type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (value);
<a name="l00110"></a>00110     }
<a name="l00111"></a>00111   <span class="keywordflow">else</span>
<a name="l00112"></a>00112     type = <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (parent_type, fieldno);
<a name="l00113"></a>00113 
<a name="l00114"></a>00114   <span class="keywordflow">if</span> (child_value)
<a name="l00115"></a>00115     *child_value = value;
<a name="l00116"></a>00116   <span class="keywordflow">if</span> (child_type)
<a name="l00117"></a>00117     *child_type = <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l00118"></a>00118 }
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="comment">/* Assuming that the (PARENT_VALUE, PARENT_TYPE) pair is a pointer or</span>
<a name="l00121"></a>00121 <span class="comment">   reference, return a (CHILD_VALUE, CHILD_TYPE) couple corresponding</span>
<a name="l00122"></a>00122 <span class="comment">   to the dereferenced value.  */</span>
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00125"></a><a class="code" href="ada-varobj_8c.html#a2c8ee7f3649315b98e51314b5bcf575c">00125</a> <a class="code" href="ada-varobj_8c.html#a2c8ee7f3649315b98e51314b5bcf575c">ada_varobj_ind</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00126"></a>00126                 <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type,
<a name="l00127"></a>00127                 <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **child_value,
<a name="l00128"></a>00128                 <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **child_type)
<a name="l00129"></a>00129 {
<a name="l00130"></a>00130   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html">value</a> = NULL;
<a name="l00131"></a>00131   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = NULL;
<a name="l00132"></a>00132 
<a name="l00133"></a>00133   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (parent_type))
<a name="l00134"></a>00134     {
<a name="l00135"></a>00135       <span class="comment">/* This can only happen when PARENT_VALUE is NULL.  Otherwise,</span>
<a name="l00136"></a>00136 <span class="comment">         ada_get_decoded_value would have transformed our parent_type</span>
<a name="l00137"></a>00137 <span class="comment">         into a simple array pointer type.  */</span>
<a name="l00138"></a>00138       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (parent_value == NULL);
<a name="l00139"></a>00139       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141       <span class="comment">/* Decode parent_type by the equivalent pointer to (decoded)</span>
<a name="l00142"></a>00142 <span class="comment">         array.  */</span>
<a name="l00143"></a>00143       <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>)
<a name="l00144"></a>00144         parent_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (parent_type);
<a name="l00145"></a>00145       parent_type = <a class="code" href="ada-lang_8c.html#a08af5f804b36a05cc3a11fe364b5b57a">ada_coerce_to_simple_array_type</a> (parent_type);
<a name="l00146"></a>00146       parent_type = <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (parent_type);
<a name="l00147"></a>00147     }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149   <span class="comment">/* If parent_value is a null pointer, then only perform static</span>
<a name="l00150"></a>00150 <span class="comment">     dereferencing.  We cannot dereference null pointers.  */</span>
<a name="l00151"></a>00151   <span class="keywordflow">if</span> (parent_value &amp;&amp; <a class="code" href="value_8c.html#a2e64d8ca2ab5480e05097c6b2df1aa02">value_as_address</a> (parent_value) == 0)
<a name="l00152"></a>00152     parent_value = NULL;
<a name="l00153"></a>00153 
<a name="l00154"></a>00154   <span class="keywordflow">if</span> (parent_value)
<a name="l00155"></a>00155     {
<a name="l00156"></a>00156       value = <a class="code" href="ada-lang_8c.html#a917a1ba2a6b58d43803a1f999164295b">ada_value_ind</a> (parent_value);
<a name="l00157"></a>00157       type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (value);
<a name="l00158"></a>00158     }
<a name="l00159"></a>00159   <span class="keywordflow">else</span>
<a name="l00160"></a>00160     type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (parent_type);
<a name="l00161"></a>00161 
<a name="l00162"></a>00162   <span class="keywordflow">if</span> (child_value)
<a name="l00163"></a>00163     *child_value = value;
<a name="l00164"></a>00164   <span class="keywordflow">if</span> (child_type)
<a name="l00165"></a>00165     *child_type = <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l00166"></a>00166 }
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 <span class="comment">/* Assuming that the (PARENT_VALUE, PARENT_TYPE) pair is a simple</span>
<a name="l00169"></a>00169 <span class="comment">   array (TYPE_CODE_ARRAY), return the (CHILD_VALUE, CHILD_TYPE)</span>
<a name="l00170"></a>00170 <span class="comment">   pair corresponding to the element at ELT_INDEX.  */</span>
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00173"></a><a class="code" href="ada-varobj_8c.html#a8df8d72677af20a63996948fcf9907c2">00173</a> <a class="code" href="ada-varobj_8c.html#a8df8d72677af20a63996948fcf9907c2">ada_varobj_simple_array_elt</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00174"></a>00174                              <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type,
<a name="l00175"></a>00175                              <span class="keywordtype">int</span> elt_index,
<a name="l00176"></a>00176                              <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **child_value,
<a name="l00177"></a>00177                              <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **child_type)
<a name="l00178"></a>00178 {
<a name="l00179"></a>00179   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html">value</a> = NULL;
<a name="l00180"></a>00180   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = NULL;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182   <span class="keywordflow">if</span> (parent_value)
<a name="l00183"></a>00183     {
<a name="l00184"></a>00184       <span class="keyword">struct </span>value *index_value =
<a name="l00185"></a>00185         <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (<a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (parent_type), elt_index);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187       value = <a class="code" href="ada-lang_8c.html#a40dcd8728888b5b445fa2a917076c1a9">ada_value_subscript</a> (parent_value, 1, &amp;index_value);
<a name="l00188"></a>00188       type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (value);
<a name="l00189"></a>00189     }
<a name="l00190"></a>00190   <span class="keywordflow">else</span>
<a name="l00191"></a>00191     type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (parent_type);
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   <span class="keywordflow">if</span> (child_value)
<a name="l00194"></a>00194     *child_value = value;
<a name="l00195"></a>00195   <span class="keywordflow">if</span> (child_type)
<a name="l00196"></a>00196     *child_type = <a class="code" href="language_8c.html#a763fd8db6bba8fbbbc113ca0d61c47c2">type</a>;
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="comment">/* Given the decoded value and decoded type of a variable object,</span>
<a name="l00200"></a>00200 <span class="comment">   adjust the value and type to those necessary for getting children</span>
<a name="l00201"></a>00201 <span class="comment">   of the variable object.</span>
<a name="l00202"></a>00202 <span class="comment"></span>
<a name="l00203"></a>00203 <span class="comment">   The replacement is performed in place.  */</span>
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00206"></a><a class="code" href="ada-varobj_8c.html#a4106d49eee24ef107982b91b4273b155">00206</a> <a class="code" href="ada-varobj_8c.html#a4106d49eee24ef107982b91b4273b155">ada_varobj_adjust_for_child_access</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **<a class="code" href="structvalue.html">value</a>,
<a name="l00207"></a>00207                                     <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **<a class="code" href="structtype.html">type</a>)
<a name="l00208"></a>00208 {
<a name="l00209"></a>00209    <span class="comment">/* Pointers to struct/union types are special: Instead of having</span>
<a name="l00210"></a>00210 <span class="comment">      one child (the struct), their children are the components of</span>
<a name="l00211"></a>00211 <span class="comment">      the struct/union type.  We handle this situation by dereferencing</span>
<a name="l00212"></a>00212 <span class="comment">      the (value, type) couple.  */</span>
<a name="l00213"></a>00213   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (*type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l00214"></a>00214       &amp;&amp; (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (*type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l00215"></a>00215           || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (*type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l00216"></a>00216       &amp;&amp; !<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (*type))
<a name="l00217"></a>00217       &amp;&amp; !<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (*type)))
<a name="l00218"></a>00218     <a class="code" href="ada-varobj_8c.html#a2c8ee7f3649315b98e51314b5bcf575c">ada_varobj_ind</a> (*value, *type, value, type);
<a name="l00219"></a>00219 }
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 <span class="comment">/* Assuming that the (PARENT_VALUE, PARENT_TYPE) pair is an array</span>
<a name="l00222"></a>00222 <span class="comment">   (any type of array, &quot;simple&quot; or not), return the number of children</span>
<a name="l00223"></a>00223 <span class="comment">   that this array contains.  */</span>
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00226"></a><a class="code" href="ada-varobj_8c.html#a33ff2569ad2c277204deff50a6bf1970">00226</a> <a class="code" href="ada-varobj_8c.html#a33ff2569ad2c277204deff50a6bf1970">ada_varobj_get_array_number_of_children</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00227"></a>00227                                          <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type)
<a name="l00228"></a>00228 {
<a name="l00229"></a>00229   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> lo, hi;
<a name="l00230"></a>00230 
<a name="l00231"></a>00231   <span class="keywordflow">if</span> (!<a class="code" href="gdbtypes_8c.html#a499d94cb3d0212c4f898aa51f264da65">get_array_bounds</a> (parent_type, &amp;lo, &amp;hi))
<a name="l00232"></a>00232     {
<a name="l00233"></a>00233       <span class="comment">/* Could not get the array bounds.  Pretend this is an empty array.  */</span>
<a name="l00234"></a>00234       <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unable to get bounds of array, assuming null array&quot;</span>));
<a name="l00235"></a>00235       <span class="keywordflow">return</span> 0;
<a name="l00236"></a>00236     }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238   <span class="comment">/* Ada allows the upper bound to be less than the lower bound,</span>
<a name="l00239"></a>00239 <span class="comment">     in order to specify empty arrays...  */</span>
<a name="l00240"></a>00240   <span class="keywordflow">if</span> (hi &lt; lo)
<a name="l00241"></a>00241     <span class="keywordflow">return</span> 0;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243   <span class="keywordflow">return</span> hi - lo + 1;
<a name="l00244"></a>00244 }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246 <span class="comment">/* Assuming that the (PARENT_VALUE, PARENT_TYPE) pair is a struct or</span>
<a name="l00247"></a>00247 <span class="comment">   union, return the number of children this struct contains.  */</span>
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00250"></a><a class="code" href="ada-varobj_8c.html#a9d99a42ac976cdfcd74facd0f0e8b241">00250</a> <a class="code" href="ada-varobj_8c.html#a9d99a42ac976cdfcd74facd0f0e8b241">ada_varobj_get_struct_number_of_children</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00251"></a>00251                                           <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type)
<a name="l00252"></a>00252 {
<a name="l00253"></a>00253   <span class="keywordtype">int</span> n_children = 0;
<a name="l00254"></a>00254   <span class="keywordtype">int</span> i;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l00257"></a>00257               || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>);
<a name="l00258"></a>00258 
<a name="l00259"></a>00259   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (parent_type); i++)
<a name="l00260"></a>00260     {
<a name="l00261"></a>00261       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ad9a44edc68931dbf99d0f64e7ec778d7">ada_is_ignored_field</a> (parent_type, i))
<a name="l00262"></a>00262         <span class="keywordflow">continue</span>;
<a name="l00263"></a>00263 
<a name="l00264"></a>00264       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ab6ed5a863da98f196c38498f7512d30b">ada_is_wrapper_field</a> (parent_type, i))
<a name="l00265"></a>00265         {
<a name="l00266"></a>00266           <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *elt_value;
<a name="l00267"></a>00267           <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *elt_type;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269           <a class="code" href="ada-varobj_8c.html#aa4415d3abf1846d642662bc90780893f">ada_varobj_struct_elt</a> (parent_value, parent_type, i,
<a name="l00270"></a>00270                                  &amp;elt_value, &amp;elt_type);
<a name="l00271"></a>00271           <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#abbecc644387ffb0a43e57ed0462c2c8b">ada_is_tagged_type</a> (elt_type, 0))
<a name="l00272"></a>00272             {
<a name="l00273"></a>00273               <span class="comment">/* We must not use ada_varobj_get_number_of_children</span>
<a name="l00274"></a>00274 <span class="comment">                 to determine is element&#39;s number of children, because</span>
<a name="l00275"></a>00275 <span class="comment">                 this function first calls ada_varobj_decode_var,</span>
<a name="l00276"></a>00276 <span class="comment">                 which &quot;fixes&quot; the element.  For tagged types, this</span>
<a name="l00277"></a>00277 <span class="comment">                 includes reading the object&#39;s tag to determine its</span>
<a name="l00278"></a>00278 <span class="comment">                 real type, which happens to be the parent_type, and</span>
<a name="l00279"></a>00279 <span class="comment">                 leads to an infinite loop (because the element gets</span>
<a name="l00280"></a>00280 <span class="comment">                 fixed back into the parent).  */</span>
<a name="l00281"></a>00281               n_children += <a class="code" href="ada-varobj_8c.html#a9d99a42ac976cdfcd74facd0f0e8b241">ada_varobj_get_struct_number_of_children</a>
<a name="l00282"></a>00282                 (elt_value, elt_type);
<a name="l00283"></a>00283             }
<a name="l00284"></a>00284           <span class="keywordflow">else</span>
<a name="l00285"></a>00285             n_children += <a class="code" href="ada-varobj_8c.html#a8c77dcd297321f684638fc12196e3f25">ada_varobj_get_number_of_children</a> (elt_value, elt_type);
<a name="l00286"></a>00286         }
<a name="l00287"></a>00287       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a370ccbe192d73c5795afa034113a4ffb">ada_is_variant_part</a> (parent_type, i))
<a name="l00288"></a>00288         {
<a name="l00289"></a>00289           <span class="comment">/* In normal situations, the variant part of the record should</span>
<a name="l00290"></a>00290 <span class="comment">             have been &quot;fixed&quot;. Or, in other words, it should have been</span>
<a name="l00291"></a>00291 <span class="comment">             replaced by the branch of the variant part that is relevant</span>
<a name="l00292"></a>00292 <span class="comment">             for our value.  But there are still situations where this</span>
<a name="l00293"></a>00293 <span class="comment">             can happen, however (Eg. when our parent is a NULL pointer).</span>
<a name="l00294"></a>00294 <span class="comment">             We do not support showing this part of the record for now,</span>
<a name="l00295"></a>00295 <span class="comment">             so just pretend this field does not exist.  */</span>
<a name="l00296"></a>00296         }
<a name="l00297"></a>00297       <span class="keywordflow">else</span>
<a name="l00298"></a>00298         n_children++;
<a name="l00299"></a>00299     }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301   <span class="keywordflow">return</span> n_children;
<a name="l00302"></a>00302 }
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="comment">/* Assuming that the (PARENT_VALUE, PARENT_TYPE) pair designates</span>
<a name="l00305"></a>00305 <span class="comment">   a pointer, return the number of children this pointer has.  */</span>
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00308"></a><a class="code" href="ada-varobj_8c.html#a53ff6478d3b89401d03f5b1ffc6991db">00308</a> <a class="code" href="ada-varobj_8c.html#a53ff6478d3b89401d03f5b1ffc6991db">ada_varobj_get_ptr_number_of_children</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00309"></a>00309                                        <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type)
<a name="l00310"></a>00310 {
<a name="l00311"></a>00311   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *child_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (parent_type);
<a name="l00312"></a>00312 
<a name="l00313"></a>00313   <span class="comment">/* Pointer to functions and to void do not have a child, since</span>
<a name="l00314"></a>00314 <span class="comment">     you cannot print what they point to.  */</span>
<a name="l00315"></a>00315   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (child_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>
<a name="l00316"></a>00316       || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (child_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>)
<a name="l00317"></a>00317     <span class="keywordflow">return</span> 0;
<a name="l00318"></a>00318 
<a name="l00319"></a>00319   <span class="comment">/* All other types have 1 child.  */</span>
<a name="l00320"></a>00320   <span class="keywordflow">return</span> 1;
<a name="l00321"></a>00321 }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="comment">/* Return the number of children for the (PARENT_VALUE, PARENT_TYPE)</span>
<a name="l00324"></a>00324 <span class="comment">   pair.  */</span>
<a name="l00325"></a>00325 
<a name="l00326"></a>00326 <span class="keywordtype">int</span>
<a name="l00327"></a><a class="code" href="ada-varobj_8h.html#a8c77dcd297321f684638fc12196e3f25">00327</a> <a class="code" href="ada-varobj_8c.html#a8c77dcd297321f684638fc12196e3f25">ada_varobj_get_number_of_children</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00328"></a>00328                                    <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type)
<a name="l00329"></a>00329 {
<a name="l00330"></a>00330   <a class="code" href="ada-varobj_8c.html#a47aee56dfaa82ff3882493fff8c69216">ada_varobj_decode_var</a> (&amp;parent_value, &amp;parent_type);
<a name="l00331"></a>00331   <a class="code" href="ada-varobj_8c.html#a4106d49eee24ef107982b91b4273b155">ada_varobj_adjust_for_child_access</a> (&amp;parent_value, &amp;parent_type);
<a name="l00332"></a>00332 
<a name="l00333"></a>00333   <span class="comment">/* A typedef to an array descriptor in fact represents a pointer</span>
<a name="l00334"></a>00334 <span class="comment">     to an unconstrained array.  These types always have one child</span>
<a name="l00335"></a>00335 <span class="comment">     (the unconstrained array).  */</span>
<a name="l00336"></a>00336   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (parent_type)
<a name="l00337"></a>00337       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>)
<a name="l00338"></a>00338     <span class="keywordflow">return</span> 1;
<a name="l00339"></a>00339 
<a name="l00340"></a>00340   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l00341"></a>00341     <span class="keywordflow">return</span> <a class="code" href="ada-varobj_8c.html#a33ff2569ad2c277204deff50a6bf1970">ada_varobj_get_array_number_of_children</a> (parent_value,
<a name="l00342"></a>00342                                                     parent_type);
<a name="l00343"></a>00343 
<a name="l00344"></a>00344   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l00345"></a>00345       || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l00346"></a>00346     <span class="keywordflow">return</span> <a class="code" href="ada-varobj_8c.html#a9d99a42ac976cdfcd74facd0f0e8b241">ada_varobj_get_struct_number_of_children</a> (parent_value,
<a name="l00347"></a>00347                                                      parent_type);
<a name="l00348"></a>00348 
<a name="l00349"></a>00349   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l00350"></a>00350     <span class="keywordflow">return</span> <a class="code" href="ada-varobj_8c.html#a53ff6478d3b89401d03f5b1ffc6991db">ada_varobj_get_ptr_number_of_children</a> (parent_value,
<a name="l00351"></a>00351                                                   parent_type);
<a name="l00352"></a>00352 
<a name="l00353"></a>00353   <span class="comment">/* All other types have no child.  */</span>
<a name="l00354"></a>00354   <span class="keywordflow">return</span> 0;
<a name="l00355"></a>00355 }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 <span class="comment">/* Describe the child of the (PARENT_VALUE, PARENT_TYPE) pair</span>
<a name="l00358"></a>00358 <span class="comment">   whose index is CHILD_INDEX:</span>
<a name="l00359"></a>00359 <span class="comment"></span>
<a name="l00360"></a>00360 <span class="comment">     - If CHILD_NAME is not NULL, then a copy of the child&#39;s name</span>
<a name="l00361"></a>00361 <span class="comment">       is saved in *CHILD_NAME.  This copy must be deallocated</span>
<a name="l00362"></a>00362 <span class="comment">       with xfree after use.</span>
<a name="l00363"></a>00363 <span class="comment"></span>
<a name="l00364"></a>00364 <span class="comment">     - If CHILD_VALUE is not NULL, then save the child&#39;s value</span>
<a name="l00365"></a>00365 <span class="comment">       in *CHILD_VALUE. Same thing for the child&#39;s type with</span>
<a name="l00366"></a>00366 <span class="comment">       CHILD_TYPE if not NULL.</span>
<a name="l00367"></a>00367 <span class="comment"></span>
<a name="l00368"></a>00368 <span class="comment">     - If CHILD_PATH_EXPR is not NULL, then compute the child&#39;s</span>
<a name="l00369"></a>00369 <span class="comment">       path expression.  The resulting string must be deallocated</span>
<a name="l00370"></a>00370 <span class="comment">       after use with xfree.</span>
<a name="l00371"></a>00371 <span class="comment"></span>
<a name="l00372"></a>00372 <span class="comment">       Computing the child&#39;s path expression requires the PARENT_PATH_EXPR</span>
<a name="l00373"></a>00373 <span class="comment">       to be non-NULL.  Otherwise, PARENT_PATH_EXPR may be null if</span>
<a name="l00374"></a>00374 <span class="comment">       CHILD_PATH_EXPR is NULL.</span>
<a name="l00375"></a>00375 <span class="comment"></span>
<a name="l00376"></a>00376 <span class="comment">  PARENT_NAME is the name of the parent, and should never be NULL.  */</span>
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="ada-varobj_8c.html#a0195eb858553982713df60b29225202c">ada_varobj_describe_child</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00379"></a>00379                                        <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type,
<a name="l00380"></a>00380                                        <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_name,
<a name="l00381"></a>00381                                        <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_path_expr,
<a name="l00382"></a>00382                                        <span class="keywordtype">int</span> child_index,
<a name="l00383"></a>00383                                        <span class="keywordtype">char</span> **child_name,
<a name="l00384"></a>00384                                        <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **child_value,
<a name="l00385"></a>00385                                        <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **child_type,
<a name="l00386"></a>00386                                        <span class="keywordtype">char</span> **child_path_expr);
<a name="l00387"></a>00387 
<a name="l00388"></a>00388 <span class="comment">/* Same as ada_varobj_describe_child, but limited to struct/union</span>
<a name="l00389"></a>00389 <span class="comment">   objects.  */</span>
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00392"></a><a class="code" href="ada-varobj_8c.html#a2b6488e95181301cc91495d328af3c80">00392</a> <a class="code" href="ada-varobj_8c.html#a2b6488e95181301cc91495d328af3c80">ada_varobj_describe_struct_child</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00393"></a>00393                                   <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type,
<a name="l00394"></a>00394                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_name,
<a name="l00395"></a>00395                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_path_expr,
<a name="l00396"></a>00396                                   <span class="keywordtype">int</span> child_index,
<a name="l00397"></a>00397                                   <span class="keywordtype">char</span> **child_name,
<a name="l00398"></a>00398                                   <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **child_value,
<a name="l00399"></a>00399                                   <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **child_type,
<a name="l00400"></a>00400                                   <span class="keywordtype">char</span> **child_path_expr)
<a name="l00401"></a>00401 {
<a name="l00402"></a>00402   <span class="keywordtype">int</span> fieldno;
<a name="l00403"></a>00403   <span class="keywordtype">int</span> childno = 0;
<a name="l00404"></a>00404 
<a name="l00405"></a>00405   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>);
<a name="l00406"></a>00406 
<a name="l00407"></a>00407   <span class="keywordflow">for</span> (fieldno = 0; fieldno &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (parent_type); fieldno++)
<a name="l00408"></a>00408     {
<a name="l00409"></a>00409       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ad9a44edc68931dbf99d0f64e7ec778d7">ada_is_ignored_field</a> (parent_type, fieldno))
<a name="l00410"></a>00410         <span class="keywordflow">continue</span>;
<a name="l00411"></a>00411 
<a name="l00412"></a>00412       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ab6ed5a863da98f196c38498f7512d30b">ada_is_wrapper_field</a> (parent_type, fieldno))
<a name="l00413"></a>00413         {
<a name="l00414"></a>00414           <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *elt_value;
<a name="l00415"></a>00415           <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *elt_type;
<a name="l00416"></a>00416           <span class="keywordtype">int</span> elt_n_children;
<a name="l00417"></a>00417 
<a name="l00418"></a>00418           <a class="code" href="ada-varobj_8c.html#aa4415d3abf1846d642662bc90780893f">ada_varobj_struct_elt</a> (parent_value, parent_type, fieldno,
<a name="l00419"></a>00419                                  &amp;elt_value, &amp;elt_type);
<a name="l00420"></a>00420           <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#abbecc644387ffb0a43e57ed0462c2c8b">ada_is_tagged_type</a> (elt_type, 0))
<a name="l00421"></a>00421             {
<a name="l00422"></a>00422               <span class="comment">/* Same as in ada_varobj_get_struct_number_of_children:</span>
<a name="l00423"></a>00423 <span class="comment">                 For tagged types, we must be careful to not call</span>
<a name="l00424"></a>00424 <span class="comment">                 ada_varobj_get_number_of_children, to prevent our</span>
<a name="l00425"></a>00425 <span class="comment">                 element from being fixed back into the parent.  */</span>
<a name="l00426"></a>00426               elt_n_children = <a class="code" href="ada-varobj_8c.html#a9d99a42ac976cdfcd74facd0f0e8b241">ada_varobj_get_struct_number_of_children</a>
<a name="l00427"></a>00427                 (elt_value, elt_type);
<a name="l00428"></a>00428             }
<a name="l00429"></a>00429           <span class="keywordflow">else</span>
<a name="l00430"></a>00430             elt_n_children =
<a name="l00431"></a>00431               <a class="code" href="ada-varobj_8c.html#a8c77dcd297321f684638fc12196e3f25">ada_varobj_get_number_of_children</a> (elt_value, elt_type);
<a name="l00432"></a>00432 
<a name="l00433"></a>00433           <span class="comment">/* Is the child we&#39;re looking for one of the children</span>
<a name="l00434"></a>00434 <span class="comment">             of this wrapper field?  */</span>
<a name="l00435"></a>00435           <span class="keywordflow">if</span> (child_index - childno &lt; elt_n_children)
<a name="l00436"></a>00436             {
<a name="l00437"></a>00437               <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#abbecc644387ffb0a43e57ed0462c2c8b">ada_is_tagged_type</a> (elt_type, 0))
<a name="l00438"></a>00438                 {
<a name="l00439"></a>00439                   <span class="comment">/* Same as in ada_varobj_get_struct_number_of_children:</span>
<a name="l00440"></a>00440 <span class="comment">                     For tagged types, we must be careful to not call</span>
<a name="l00441"></a>00441 <span class="comment">                     ada_varobj_describe_child, to prevent our element</span>
<a name="l00442"></a>00442 <span class="comment">                     from being fixed back into the parent.  */</span>
<a name="l00443"></a>00443                   <a class="code" href="ada-varobj_8c.html#a2b6488e95181301cc91495d328af3c80">ada_varobj_describe_struct_child</a>
<a name="l00444"></a>00444                     (elt_value, elt_type, parent_name, parent_path_expr,
<a name="l00445"></a>00445                      child_index - childno, child_name, child_value,
<a name="l00446"></a>00446                      child_type, child_path_expr);
<a name="l00447"></a>00447                 }
<a name="l00448"></a>00448               <span class="keywordflow">else</span>
<a name="l00449"></a>00449                 <a class="code" href="ada-varobj_8c.html#a0195eb858553982713df60b29225202c">ada_varobj_describe_child</a> (elt_value, elt_type,
<a name="l00450"></a>00450                                            parent_name, parent_path_expr,
<a name="l00451"></a>00451                                            child_index - childno,
<a name="l00452"></a>00452                                            child_name, child_value,
<a name="l00453"></a>00453                                            child_type, child_path_expr);
<a name="l00454"></a>00454               <span class="keywordflow">return</span>;
<a name="l00455"></a>00455             }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457           <span class="comment">/* The child we&#39;re looking for is beyond this wrapper</span>
<a name="l00458"></a>00458 <span class="comment">             field, so skip all its children.  */</span>
<a name="l00459"></a>00459           childno += elt_n_children;
<a name="l00460"></a>00460           <span class="keywordflow">continue</span>;
<a name="l00461"></a>00461         }
<a name="l00462"></a>00462       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a370ccbe192d73c5795afa034113a4ffb">ada_is_variant_part</a> (parent_type, fieldno))
<a name="l00463"></a>00463         {
<a name="l00464"></a>00464           <span class="comment">/* In normal situations, the variant part of the record should</span>
<a name="l00465"></a>00465 <span class="comment">             have been &quot;fixed&quot;. Or, in other words, it should have been</span>
<a name="l00466"></a>00466 <span class="comment">             replaced by the branch of the variant part that is relevant</span>
<a name="l00467"></a>00467 <span class="comment">             for our value.  But there are still situations where this</span>
<a name="l00468"></a>00468 <span class="comment">             can happen, however (Eg. when our parent is a NULL pointer).</span>
<a name="l00469"></a>00469 <span class="comment">             We do not support showing this part of the record for now,</span>
<a name="l00470"></a>00470 <span class="comment">             so just pretend this field does not exist.  */</span>
<a name="l00471"></a>00471           <span class="keywordflow">continue</span>;
<a name="l00472"></a>00472         }
<a name="l00473"></a>00473 
<a name="l00474"></a>00474       <span class="keywordflow">if</span> (childno == child_index)
<a name="l00475"></a>00475         {
<a name="l00476"></a>00476           <span class="keywordflow">if</span> (child_name)
<a name="l00477"></a>00477             {
<a name="l00478"></a>00478               <span class="comment">/* The name of the child is none other than the field&#39;s</span>
<a name="l00479"></a>00479 <span class="comment">                 name, except that we need to strip suffixes from it.</span>
<a name="l00480"></a>00480 <span class="comment">                 For instance, fields with alignment constraints will</span>
<a name="l00481"></a>00481 <span class="comment">                 have an __XVA suffix added to them.  */</span>
<a name="l00482"></a>00482               <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="py-type_8c.html#a1042b6e635f9f4eeca3f79047e2cf2c1">field_name</a> = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (parent_type, fieldno);
<a name="l00483"></a>00483               <span class="keywordtype">int</span> child_name_len = <a class="code" href="ada-lang_8c.html#aa5624d1411eb736cbb8426496fadcf45">ada_name_prefix_len</a> (field_name);
<a name="l00484"></a>00484 
<a name="l00485"></a>00485               *child_name = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;%.*s&quot;</span>, child_name_len, field_name);
<a name="l00486"></a>00486             }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488           <span class="keywordflow">if</span> (child_value &amp;&amp; parent_value)
<a name="l00489"></a>00489             <a class="code" href="ada-varobj_8c.html#aa4415d3abf1846d642662bc90780893f">ada_varobj_struct_elt</a> (parent_value, parent_type, fieldno,
<a name="l00490"></a>00490                                    child_value, NULL);
<a name="l00491"></a>00491 
<a name="l00492"></a>00492           <span class="keywordflow">if</span> (child_type)
<a name="l00493"></a>00493             <a class="code" href="ada-varobj_8c.html#aa4415d3abf1846d642662bc90780893f">ada_varobj_struct_elt</a> (parent_value, parent_type, fieldno,
<a name="l00494"></a>00494                                    NULL, child_type);
<a name="l00495"></a>00495 
<a name="l00496"></a>00496           <span class="keywordflow">if</span> (child_path_expr)
<a name="l00497"></a>00497             {
<a name="l00498"></a>00498               <span class="comment">/* The name of the child is none other than the field&#39;s</span>
<a name="l00499"></a>00499 <span class="comment">                 name, except that we need to strip suffixes from it.</span>
<a name="l00500"></a>00500 <span class="comment">                 For instance, fields with alignment constraints will</span>
<a name="l00501"></a>00501 <span class="comment">                 have an __XVA suffix added to them.  */</span>
<a name="l00502"></a>00502               <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="py-type_8c.html#a1042b6e635f9f4eeca3f79047e2cf2c1">field_name</a> = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (parent_type, fieldno);
<a name="l00503"></a>00503               <span class="keywordtype">int</span> child_name_len = <a class="code" href="ada-lang_8c.html#aa5624d1411eb736cbb8426496fadcf45">ada_name_prefix_len</a> (field_name);
<a name="l00504"></a>00504 
<a name="l00505"></a>00505               *child_path_expr =
<a name="l00506"></a>00506                 <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;(%s).%.*s&quot;</span>, parent_path_expr,
<a name="l00507"></a>00507                             child_name_len, field_name);
<a name="l00508"></a>00508             }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510           <span class="keywordflow">return</span>;
<a name="l00511"></a>00511         }
<a name="l00512"></a>00512 
<a name="l00513"></a>00513       childno++;
<a name="l00514"></a>00514     }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516   <span class="comment">/* Something went wrong.  Either we miscounted the number of</span>
<a name="l00517"></a>00517 <span class="comment">     children, or CHILD_INDEX was too high.  But we should never</span>
<a name="l00518"></a>00518 <span class="comment">     reach here.  We don&#39;t have enough information to recover</span>
<a name="l00519"></a>00519 <span class="comment">     nicely, so just raise an assertion failure.  */</span>
<a name="l00520"></a>00520   <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;unexpected code path&quot;</span>);
<a name="l00521"></a>00521 }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523 <span class="comment">/* Same as ada_varobj_describe_child, but limited to pointer objects.</span>
<a name="l00524"></a>00524 <span class="comment"></span>
<a name="l00525"></a>00525 <span class="comment">   Note that CHILD_INDEX is unused in this situation, but still provided</span>
<a name="l00526"></a>00526 <span class="comment">   for consistency of interface with other routines describing an object&#39;s</span>
<a name="l00527"></a>00527 <span class="comment">   child.  */</span>
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00530"></a><a class="code" href="ada-varobj_8c.html#a42752039732c0240465fa02b3ddc0a71">00530</a> <a class="code" href="ada-varobj_8c.html#a42752039732c0240465fa02b3ddc0a71">ada_varobj_describe_ptr_child</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00531"></a>00531                                <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type,
<a name="l00532"></a>00532                                <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_name,
<a name="l00533"></a>00533                                <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_path_expr,
<a name="l00534"></a>00534                                <span class="keywordtype">int</span> child_index,
<a name="l00535"></a>00535                                <span class="keywordtype">char</span> **child_name,
<a name="l00536"></a>00536                                <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **child_value,
<a name="l00537"></a>00537                                <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **child_type,
<a name="l00538"></a>00538                                <span class="keywordtype">char</span> **child_path_expr)
<a name="l00539"></a>00539 {
<a name="l00540"></a>00540   <span class="keywordflow">if</span> (child_name)
<a name="l00541"></a>00541     *child_name = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;%s.all&quot;</span>, parent_name);
<a name="l00542"></a>00542 
<a name="l00543"></a>00543   <span class="keywordflow">if</span> (child_value &amp;&amp; parent_value)
<a name="l00544"></a>00544     <a class="code" href="ada-varobj_8c.html#a2c8ee7f3649315b98e51314b5bcf575c">ada_varobj_ind</a> (parent_value, parent_type, child_value, NULL);
<a name="l00545"></a>00545 
<a name="l00546"></a>00546   <span class="keywordflow">if</span> (child_type)
<a name="l00547"></a>00547     <a class="code" href="ada-varobj_8c.html#a2c8ee7f3649315b98e51314b5bcf575c">ada_varobj_ind</a> (parent_value, parent_type, NULL, child_type);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549   <span class="keywordflow">if</span> (child_path_expr)
<a name="l00550"></a>00550     *child_path_expr = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;(%s).all&quot;</span>, parent_path_expr);
<a name="l00551"></a>00551 }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553 <span class="comment">/* Same as ada_varobj_describe_child, limited to simple array objects</span>
<a name="l00554"></a>00554 <span class="comment">   (TYPE_CODE_ARRAY only).</span>
<a name="l00555"></a>00555 <span class="comment"></span>
<a name="l00556"></a>00556 <span class="comment">   Assumes that the (PARENT_VALUE, PARENT_TYPE) pair is properly decoded.</span>
<a name="l00557"></a>00557 <span class="comment">   This is done by ada_varobj_describe_child before calling us.  */</span>
<a name="l00558"></a>00558 
<a name="l00559"></a>00559 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00560"></a><a class="code" href="ada-varobj_8c.html#a26e429cc2d443caa113eef79832f225d">00560</a> <a class="code" href="ada-varobj_8c.html#a26e429cc2d443caa113eef79832f225d">ada_varobj_describe_simple_array_child</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00561"></a>00561                                         <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type,
<a name="l00562"></a>00562                                         <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_name,
<a name="l00563"></a>00563                                         <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_path_expr,
<a name="l00564"></a>00564                                         <span class="keywordtype">int</span> child_index,
<a name="l00565"></a>00565                                         <span class="keywordtype">char</span> **child_name,
<a name="l00566"></a>00566                                         <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **child_value,
<a name="l00567"></a>00567                                         <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **child_type,
<a name="l00568"></a>00568                                         <span class="keywordtype">char</span> **child_path_expr)
<a name="l00569"></a>00569 {
<a name="l00570"></a>00570   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *index_desc_type;
<a name="l00571"></a>00571   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *index_type;
<a name="l00572"></a>00572   <span class="keywordtype">int</span> real_index;
<a name="l00573"></a>00573 
<a name="l00574"></a>00574   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>);
<a name="l00575"></a>00575 
<a name="l00576"></a>00576   index_desc_type = <a class="code" href="ada-lang_8c.html#ade263e735047904b7eabe725cd6cc2f9">ada_find_parallel_type</a> (parent_type, <span class="stringliteral">&quot;___XA&quot;</span>);
<a name="l00577"></a>00577   <a class="code" href="ada-lang_8c.html#ad725b7268112515bd22d705724724044">ada_fixup_array_indexes_type</a> (index_desc_type);
<a name="l00578"></a>00578   <span class="keywordflow">if</span> (index_desc_type)
<a name="l00579"></a>00579     index_type = <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (index_desc_type, 0);
<a name="l00580"></a>00580   <span class="keywordflow">else</span>
<a name="l00581"></a>00581     index_type = <a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (parent_type);
<a name="l00582"></a>00582   real_index = child_index + <a class="code" href="ada-lang_8c.html#ad4891bc1ffa6690999afab17e367bc57">ada_discrete_type_low_bound</a> (index_type);
<a name="l00583"></a>00583 
<a name="l00584"></a>00584   <span class="keywordflow">if</span> (child_name)
<a name="l00585"></a>00585     *child_name = <a class="code" href="ada-varobj_8c.html#a82e9758dd21d4c88f0d2a3ff788f373b">ada_varobj_scalar_image</a> (index_type, real_index);
<a name="l00586"></a>00586 
<a name="l00587"></a>00587   <span class="keywordflow">if</span> (child_value &amp;&amp; parent_value)
<a name="l00588"></a>00588     <a class="code" href="ada-varobj_8c.html#a8df8d72677af20a63996948fcf9907c2">ada_varobj_simple_array_elt</a> (parent_value, parent_type, real_index,
<a name="l00589"></a>00589                                  child_value, NULL);
<a name="l00590"></a>00590 
<a name="l00591"></a>00591   <span class="keywordflow">if</span> (child_type)
<a name="l00592"></a>00592     <a class="code" href="ada-varobj_8c.html#a8df8d72677af20a63996948fcf9907c2">ada_varobj_simple_array_elt</a> (parent_value, parent_type, real_index,
<a name="l00593"></a>00593                                  NULL, child_type);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595   <span class="keywordflow">if</span> (child_path_expr)
<a name="l00596"></a>00596     {
<a name="l00597"></a>00597       <span class="keywordtype">char</span> *index_img = <a class="code" href="ada-varobj_8c.html#a82e9758dd21d4c88f0d2a3ff788f373b">ada_varobj_scalar_image</a> (index_type, real_index);
<a name="l00598"></a>00598       <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, index_img);
<a name="l00599"></a>00599 
<a name="l00600"></a>00600       <span class="comment">/* Enumeration litterals by themselves are potentially ambiguous.</span>
<a name="l00601"></a>00601 <span class="comment">         For instance, consider the following package spec:</span>
<a name="l00602"></a>00602 <span class="comment"></span>
<a name="l00603"></a>00603 <span class="comment">            package Pck is</span>
<a name="l00604"></a>00604 <span class="comment">               type Color is (Red, Green, Blue, White);</span>
<a name="l00605"></a>00605 <span class="comment">               type Blood_Cells is (White, Red);</span>
<a name="l00606"></a>00606 <span class="comment">            end Pck;</span>
<a name="l00607"></a>00607 <span class="comment"></span>
<a name="l00608"></a>00608 <span class="comment">         In this case, the litteral &quot;red&quot; for instance, or even</span>
<a name="l00609"></a>00609 <span class="comment">         the fully-qualified litteral &quot;pck.red&quot; cannot be resolved</span>
<a name="l00610"></a>00610 <span class="comment">         by itself.  Type qualification is needed to determine which</span>
<a name="l00611"></a>00611 <span class="comment">         enumeration litterals should be used.</span>
<a name="l00612"></a>00612 <span class="comment"></span>
<a name="l00613"></a>00613 <span class="comment">         The following variable will be used to contain the name</span>
<a name="l00614"></a>00614 <span class="comment">         of the array index type when such type qualification is</span>
<a name="l00615"></a>00615 <span class="comment">         needed.  */</span>
<a name="l00616"></a>00616       <span class="keyword">const</span> <span class="keywordtype">char</span> *index_type_name = NULL;
<a name="l00617"></a>00617 
<a name="l00618"></a>00618       <span class="comment">/* If the index type is a range type, find the base type.  */</span>
<a name="l00619"></a>00619       <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (index_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>)
<a name="l00620"></a>00620         index_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (index_type);
<a name="l00621"></a>00621 
<a name="l00622"></a>00622       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (index_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>
<a name="l00623"></a>00623           || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (index_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462afbf0aa0241df408e1017ae7ff8e6798c">TYPE_CODE_BOOL</a>)
<a name="l00624"></a>00624         {
<a name="l00625"></a>00625           index_type_name = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (index_type);
<a name="l00626"></a>00626           <span class="keywordflow">if</span> (index_type_name)
<a name="l00627"></a>00627             index_type_name = <a class="code" href="ada-lang_8c.html#a09b16b65c7ccf6ce05e91a51321903a1">ada_decode</a> (index_type_name);
<a name="l00628"></a>00628         }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630       <span class="keywordflow">if</span> (index_type_name != NULL)
<a name="l00631"></a>00631         *child_path_expr =
<a name="l00632"></a>00632           <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;(%s)(%.*s&#39;(%s))&quot;</span>, parent_path_expr,
<a name="l00633"></a>00633                       <a class="code" href="ada-lang_8c.html#aa5624d1411eb736cbb8426496fadcf45">ada_name_prefix_len</a> (index_type_name),
<a name="l00634"></a>00634                       index_type_name, index_img);
<a name="l00635"></a>00635       <span class="keywordflow">else</span>
<a name="l00636"></a>00636         *child_path_expr =
<a name="l00637"></a>00637           <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;(%s)(%s)&quot;</span>, parent_path_expr, index_img);
<a name="l00638"></a>00638       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l00639"></a>00639     }
<a name="l00640"></a>00640 }
<a name="l00641"></a>00641 
<a name="l00642"></a>00642 <span class="comment">/* See description at declaration above.  */</span>
<a name="l00643"></a>00643 
<a name="l00644"></a>00644 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00645"></a><a class="code" href="ada-varobj_8c.html#a0195eb858553982713df60b29225202c">00645</a> <a class="code" href="ada-varobj_8c.html#a0195eb858553982713df60b29225202c">ada_varobj_describe_child</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00646"></a>00646                            <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type,
<a name="l00647"></a>00647                            <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_name,
<a name="l00648"></a>00648                            <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_path_expr,
<a name="l00649"></a>00649                            <span class="keywordtype">int</span> child_index,
<a name="l00650"></a>00650                            <span class="keywordtype">char</span> **child_name,
<a name="l00651"></a>00651                            <span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> **child_value,
<a name="l00652"></a>00652                            <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **child_type,
<a name="l00653"></a>00653                            <span class="keywordtype">char</span> **child_path_expr)
<a name="l00654"></a>00654 {
<a name="l00655"></a>00655   <span class="comment">/* We cannot compute the child&#39;s path expression without</span>
<a name="l00656"></a>00656 <span class="comment">     the parent&#39;s path expression.  This is a pre-condition</span>
<a name="l00657"></a>00657 <span class="comment">     for calling this function.  */</span>
<a name="l00658"></a>00658   <span class="keywordflow">if</span> (child_path_expr)
<a name="l00659"></a>00659     <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (parent_path_expr != NULL);
<a name="l00660"></a>00660 
<a name="l00661"></a>00661   <a class="code" href="ada-varobj_8c.html#a47aee56dfaa82ff3882493fff8c69216">ada_varobj_decode_var</a> (&amp;parent_value, &amp;parent_type);
<a name="l00662"></a>00662   <a class="code" href="ada-varobj_8c.html#a4106d49eee24ef107982b91b4273b155">ada_varobj_adjust_for_child_access</a> (&amp;parent_value, &amp;parent_type);
<a name="l00663"></a>00663 
<a name="l00664"></a>00664   <span class="keywordflow">if</span> (child_name)
<a name="l00665"></a>00665     *child_name = NULL;
<a name="l00666"></a>00666   <span class="keywordflow">if</span> (child_value)
<a name="l00667"></a>00667     *child_value = NULL;
<a name="l00668"></a>00668   <span class="keywordflow">if</span> (child_type)
<a name="l00669"></a>00669     *child_type = NULL;
<a name="l00670"></a>00670   <span class="keywordflow">if</span> (child_path_expr)
<a name="l00671"></a>00671     *child_path_expr = NULL;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (parent_type)
<a name="l00674"></a>00674       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>)
<a name="l00675"></a>00675     {
<a name="l00676"></a>00676       <a class="code" href="ada-varobj_8c.html#a42752039732c0240465fa02b3ddc0a71">ada_varobj_describe_ptr_child</a> (parent_value, parent_type,
<a name="l00677"></a>00677                                      parent_name, parent_path_expr,
<a name="l00678"></a>00678                                      child_index, child_name,
<a name="l00679"></a>00679                                      child_value, child_type,
<a name="l00680"></a>00680                                      child_path_expr);
<a name="l00681"></a>00681       <span class="keywordflow">return</span>;
<a name="l00682"></a>00682     }
<a name="l00683"></a>00683 
<a name="l00684"></a>00684   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l00685"></a>00685     {
<a name="l00686"></a>00686       <a class="code" href="ada-varobj_8c.html#a26e429cc2d443caa113eef79832f225d">ada_varobj_describe_simple_array_child</a>
<a name="l00687"></a>00687         (parent_value, parent_type, parent_name, parent_path_expr,
<a name="l00688"></a>00688          child_index, child_name, child_value, child_type,
<a name="l00689"></a>00689          child_path_expr);
<a name="l00690"></a>00690       <span class="keywordflow">return</span>;
<a name="l00691"></a>00691     }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>)
<a name="l00694"></a>00694     {
<a name="l00695"></a>00695       <a class="code" href="ada-varobj_8c.html#a2b6488e95181301cc91495d328af3c80">ada_varobj_describe_struct_child</a> (parent_value, parent_type,
<a name="l00696"></a>00696                                         parent_name, parent_path_expr,
<a name="l00697"></a>00697                                         child_index, child_name,
<a name="l00698"></a>00698                                         child_value, child_type,
<a name="l00699"></a>00699                                         child_path_expr);
<a name="l00700"></a>00700       <span class="keywordflow">return</span>;
<a name="l00701"></a>00701     }
<a name="l00702"></a>00702 
<a name="l00703"></a>00703   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l00704"></a>00704     {
<a name="l00705"></a>00705       <a class="code" href="ada-varobj_8c.html#a42752039732c0240465fa02b3ddc0a71">ada_varobj_describe_ptr_child</a> (parent_value, parent_type,
<a name="l00706"></a>00706                                      parent_name, parent_path_expr,
<a name="l00707"></a>00707                                      child_index, child_name,
<a name="l00708"></a>00708                                      child_value, child_type,
<a name="l00709"></a>00709                                      child_path_expr);
<a name="l00710"></a>00710       <span class="keywordflow">return</span>;
<a name="l00711"></a>00711     }
<a name="l00712"></a>00712 
<a name="l00713"></a>00713   <span class="comment">/* It should never happen.  But rather than crash, report dummy names</span>
<a name="l00714"></a>00714 <span class="comment">     and return a NULL child_value.  */</span>
<a name="l00715"></a>00715   <span class="keywordflow">if</span> (child_name)
<a name="l00716"></a>00716     *child_name = xstrdup (<span class="stringliteral">&quot;???&quot;</span>);
<a name="l00717"></a>00717 }
<a name="l00718"></a>00718 
<a name="l00719"></a>00719 <span class="comment">/* Return the name of the child number CHILD_INDEX of the (PARENT_VALUE,</span>
<a name="l00720"></a>00720 <span class="comment">   PARENT_TYPE) pair.  PARENT_NAME is the name of the PARENT.</span>
<a name="l00721"></a>00721 <span class="comment"></span>
<a name="l00722"></a>00722 <span class="comment">   The result should be deallocated after use with xfree.  */</span>
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 <span class="keywordtype">char</span> *
<a name="l00725"></a><a class="code" href="ada-varobj_8h.html#abb148477cda76581ccc494bb000624d8">00725</a> <a class="code" href="ada-varobj_8c.html#abb148477cda76581ccc494bb000624d8">ada_varobj_get_name_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00726"></a>00726                               <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type,
<a name="l00727"></a>00727                               <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_name, <span class="keywordtype">int</span> child_index)
<a name="l00728"></a>00728 {
<a name="l00729"></a>00729   <span class="keywordtype">char</span> *child_name;
<a name="l00730"></a>00730 
<a name="l00731"></a>00731   <a class="code" href="ada-varobj_8c.html#a0195eb858553982713df60b29225202c">ada_varobj_describe_child</a> (parent_value, parent_type, parent_name,
<a name="l00732"></a>00732                              NULL, child_index, &amp;child_name, NULL,
<a name="l00733"></a>00733                              NULL, NULL);
<a name="l00734"></a>00734   <span class="keywordflow">return</span> child_name;
<a name="l00735"></a>00735 }
<a name="l00736"></a>00736 
<a name="l00737"></a>00737 <span class="comment">/* Return the path expression of the child number CHILD_INDEX of</span>
<a name="l00738"></a>00738 <span class="comment">   the (PARENT_VALUE, PARENT_TYPE) pair.  PARENT_NAME is the name</span>
<a name="l00739"></a>00739 <span class="comment">   of the parent, and PARENT_PATH_EXPR is the parent&#39;s path expression.</span>
<a name="l00740"></a>00740 <span class="comment">   Both must be non-NULL.</span>
<a name="l00741"></a>00741 <span class="comment"></span>
<a name="l00742"></a>00742 <span class="comment">   The result must be deallocated after use with xfree.  */</span>
<a name="l00743"></a>00743 
<a name="l00744"></a>00744 <span class="keywordtype">char</span> *
<a name="l00745"></a><a class="code" href="ada-varobj_8h.html#a8124f346b33174f15fd041712bc2be57">00745</a> <a class="code" href="ada-varobj_8c.html#a8124f346b33174f15fd041712bc2be57">ada_varobj_get_path_expr_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00746"></a>00746                                    <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type,
<a name="l00747"></a>00747                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_name,
<a name="l00748"></a>00748                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_path_expr,
<a name="l00749"></a>00749                                    <span class="keywordtype">int</span> child_index)
<a name="l00750"></a>00750 {
<a name="l00751"></a>00751   <span class="keywordtype">char</span> *child_path_expr;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753   <a class="code" href="ada-varobj_8c.html#a0195eb858553982713df60b29225202c">ada_varobj_describe_child</a> (parent_value, parent_type, parent_name,
<a name="l00754"></a>00754                              parent_path_expr, child_index, NULL,
<a name="l00755"></a>00755                              NULL, NULL, &amp;child_path_expr);
<a name="l00756"></a>00756 
<a name="l00757"></a>00757   <span class="keywordflow">return</span> child_path_expr;
<a name="l00758"></a>00758 }
<a name="l00759"></a>00759 
<a name="l00760"></a>00760 <span class="comment">/* Return the value of child number CHILD_INDEX of the (PARENT_VALUE,</span>
<a name="l00761"></a>00761 <span class="comment">   PARENT_TYPE) pair.  PARENT_NAME is the name of the parent.  */</span>
<a name="l00762"></a>00762 
<a name="l00763"></a>00763 <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *
<a name="l00764"></a><a class="code" href="ada-varobj_8h.html#a8ee908fde7b8689fe09edc3b714f1211">00764</a> <a class="code" href="ada-varobj_8c.html#a8ee908fde7b8689fe09edc3b714f1211">ada_varobj_get_value_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00765"></a>00765                                <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type,
<a name="l00766"></a>00766                                <span class="keyword">const</span> <span class="keywordtype">char</span> *parent_name, <span class="keywordtype">int</span> child_index)
<a name="l00767"></a>00767 {
<a name="l00768"></a>00768   <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *child_value;
<a name="l00769"></a>00769 
<a name="l00770"></a>00770   <a class="code" href="ada-varobj_8c.html#a0195eb858553982713df60b29225202c">ada_varobj_describe_child</a> (parent_value, parent_type, parent_name,
<a name="l00771"></a>00771                              NULL, child_index, NULL, &amp;child_value,
<a name="l00772"></a>00772                              NULL, NULL);
<a name="l00773"></a>00773 
<a name="l00774"></a>00774   <span class="keywordflow">return</span> child_value;
<a name="l00775"></a>00775 }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 <span class="comment">/* Return the type of child number CHILD_INDEX of the (PARENT_VALUE,</span>
<a name="l00778"></a>00778 <span class="comment">   PARENT_TYPE) pair.  */</span>
<a name="l00779"></a>00779 
<a name="l00780"></a>00780 <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l00781"></a><a class="code" href="ada-varobj_8h.html#aa7831b9c200ae8b7acc6cc76aaa15845">00781</a> <a class="code" href="ada-varobj_8c.html#aa7831b9c200ae8b7acc6cc76aaa15845">ada_varobj_get_type_of_child</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *parent_value,
<a name="l00782"></a>00782                               <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *parent_type,
<a name="l00783"></a>00783                               <span class="keywordtype">int</span> child_index)
<a name="l00784"></a>00784 {
<a name="l00785"></a>00785   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *child_type;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787   <a class="code" href="ada-varobj_8c.html#a0195eb858553982713df60b29225202c">ada_varobj_describe_child</a> (parent_value, parent_type, NULL, NULL,
<a name="l00788"></a>00788                              child_index, NULL, NULL, &amp;child_type, NULL);
<a name="l00789"></a>00789 
<a name="l00790"></a>00790   <span class="keywordflow">return</span> child_type;
<a name="l00791"></a>00791 }
<a name="l00792"></a>00792 
<a name="l00793"></a>00793 <span class="comment">/* Return a string that contains the image of the given VALUE, using</span>
<a name="l00794"></a>00794 <span class="comment">   the print options OPTS as the options for formatting the result.</span>
<a name="l00795"></a>00795 <span class="comment"></span>
<a name="l00796"></a>00796 <span class="comment">   The resulting string must be deallocated after use with xfree.  */</span>
<a name="l00797"></a>00797 
<a name="l00798"></a>00798 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00799"></a><a class="code" href="ada-varobj_8c.html#a57c74fe6fe7fe542f885c4ddf6b1ee4e">00799</a> <a class="code" href="ada-varobj_8c.html#a57c74fe6fe7fe542f885c4ddf6b1ee4e">ada_varobj_get_value_image</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html">value</a>,
<a name="l00800"></a>00800                             <span class="keyword">struct</span> <a class="code" href="structvalue__print__options.html">value_print_options</a> *opts)
<a name="l00801"></a>00801 {
<a name="l00802"></a>00802   <span class="keywordtype">char</span> *result;
<a name="l00803"></a>00803   <span class="keyword">struct </span><a class="code" href="structui__file.html">ui_file</a> *<a class="code" href="structbuffer.html">buffer</a>;
<a name="l00804"></a>00804   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_chain;
<a name="l00805"></a>00805 
<a name="l00806"></a>00806   buffer = <a class="code" href="ui-file_8c.html#a340771735f105582d314e191a399a45c">mem_fileopen</a> ();
<a name="l00807"></a>00807   old_chain = <a class="code" href="utils_8c.html#a94dc56baeb57791e114136764f7763aa">make_cleanup_ui_file_delete</a> (buffer);
<a name="l00808"></a>00808 
<a name="l00809"></a>00809   <a class="code" href="valprint_8c.html#a3b8220f1b9270a2f8b8f4e197f2be9db">common_val_print</a> (value, buffer, 0, opts, <a class="code" href="language_8c.html#acd2505a014a95629da9c836f8914fc79">current_language</a>);
<a name="l00810"></a>00810   result = <a class="code" href="ui-file_8c.html#a995485039ce5a1d994a1863cd76a5356">ui_file_xstrdup</a> (buffer, NULL);
<a name="l00811"></a>00811 
<a name="l00812"></a>00812   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l00813"></a>00813   <span class="keywordflow">return</span> result;
<a name="l00814"></a>00814 }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816 <span class="comment">/* Assuming that the (VALUE, TYPE) pair designates an array varobj,</span>
<a name="l00817"></a>00817 <span class="comment">   return a string that is suitable for use in the &quot;value&quot; field of</span>
<a name="l00818"></a>00818 <span class="comment">   the varobj output.  Most of the time, this is the number of elements</span>
<a name="l00819"></a>00819 <span class="comment">   in the array inside square brackets, but there are situations where</span>
<a name="l00820"></a>00820 <span class="comment">   it&#39;s useful to add more info.</span>
<a name="l00821"></a>00821 <span class="comment"></span>
<a name="l00822"></a>00822 <span class="comment">   OPTS are the print options used when formatting the result.</span>
<a name="l00823"></a>00823 <span class="comment"></span>
<a name="l00824"></a>00824 <span class="comment">   The result should be deallocated after use using xfree.  */</span>
<a name="l00825"></a>00825 
<a name="l00826"></a>00826 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00827"></a><a class="code" href="ada-varobj_8c.html#ae6ce7ad35d51a9378dd531c00695bf53">00827</a> <a class="code" href="ada-varobj_8c.html#ae6ce7ad35d51a9378dd531c00695bf53">ada_varobj_get_value_of_array_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html">value</a>,
<a name="l00828"></a>00828                                         <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>,
<a name="l00829"></a>00829                                         <span class="keyword">struct</span> <a class="code" href="structvalue__print__options.html">value_print_options</a> *opts)
<a name="l00830"></a>00830 {
<a name="l00831"></a>00831   <span class="keywordtype">char</span> *result;
<a name="l00832"></a>00832   <span class="keyword">const</span> <span class="keywordtype">int</span> numchild = <a class="code" href="ada-varobj_8c.html#a33ff2569ad2c277204deff50a6bf1970">ada_varobj_get_array_number_of_children</a> (value, type);
<a name="l00833"></a>00833 
<a name="l00834"></a>00834   <span class="comment">/* If we have a string, provide its contents in the &quot;value&quot; field.</span>
<a name="l00835"></a>00835 <span class="comment">     Otherwise, the only other way to inspect the contents of the string</span>
<a name="l00836"></a>00836 <span class="comment">     is by looking at the value of each element, as in any other array,</span>
<a name="l00837"></a>00837 <span class="comment">     which is not very convenient...  */</span>
<a name="l00838"></a>00838   <span class="keywordflow">if</span> (value
<a name="l00839"></a>00839       &amp;&amp; <a class="code" href="ada-lang_8c.html#a18f24b5d515fb07617cf7905f26d9067">ada_is_string_type</a> (type)
<a name="l00840"></a>00840       &amp;&amp; (opts-&gt;<a class="code" href="structvalue__print__options.html#ad4c1267f3716389d2b1ce09fc2191e7b">format</a> == 0 || opts-&gt;<a class="code" href="structvalue__print__options.html#ad4c1267f3716389d2b1ce09fc2191e7b">format</a> == <span class="charliteral">&#39;s&#39;</span>))
<a name="l00841"></a>00841     {
<a name="l00842"></a>00842       <span class="keywordtype">char</span> *str;
<a name="l00843"></a>00843       <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_chain;
<a name="l00844"></a>00844 
<a name="l00845"></a>00845       str = <a class="code" href="ada-varobj_8c.html#a57c74fe6fe7fe542f885c4ddf6b1ee4e">ada_varobj_get_value_image</a> (value, opts);
<a name="l00846"></a>00846       old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, str);
<a name="l00847"></a>00847       result = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;[%d] %s&quot;</span>, numchild, str);
<a name="l00848"></a>00848       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l00849"></a>00849     }
<a name="l00850"></a>00850   <span class="keywordflow">else</span>
<a name="l00851"></a>00851     result = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;[%d]&quot;</span>, numchild);
<a name="l00852"></a>00852 
<a name="l00853"></a>00853   <span class="keywordflow">return</span> result;
<a name="l00854"></a>00854 }
<a name="l00855"></a>00855 
<a name="l00856"></a>00856 <span class="comment">/* Return a string representation of the (VALUE, TYPE) pair, using</span>
<a name="l00857"></a>00857 <span class="comment">   the given print options OPTS as our formatting options.  */</span>
<a name="l00858"></a>00858 
<a name="l00859"></a>00859 <span class="keywordtype">char</span> *
<a name="l00860"></a><a class="code" href="ada-varobj_8h.html#a877e7c58702364a66a5f4a71b14e88f9">00860</a> <a class="code" href="ada-varobj_8c.html#a877e7c58702364a66a5f4a71b14e88f9">ada_varobj_get_value_of_variable</a> (<span class="keyword">struct</span> <a class="code" href="structvalue.html">value</a> *<a class="code" href="structvalue.html">value</a>,
<a name="l00861"></a>00861                                   <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>,
<a name="l00862"></a>00862                                   <span class="keyword">struct</span> <a class="code" href="structvalue__print__options.html">value_print_options</a> *opts)
<a name="l00863"></a>00863 {
<a name="l00864"></a>00864   <span class="keywordtype">char</span> *result = NULL;
<a name="l00865"></a>00865 
<a name="l00866"></a>00866   <a class="code" href="ada-varobj_8c.html#a47aee56dfaa82ff3882493fff8c69216">ada_varobj_decode_var</a> (&amp;value, &amp;type);
<a name="l00867"></a>00867 
<a name="l00868"></a>00868   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l00869"></a>00869     {
<a name="l00870"></a>00870     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l00871"></a>00871     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>:
<a name="l00872"></a>00872       result = xstrdup (<span class="stringliteral">&quot;{...}&quot;</span>);
<a name="l00873"></a>00873       <span class="keywordflow">break</span>;
<a name="l00874"></a>00874     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>:
<a name="l00875"></a>00875       result = <a class="code" href="ada-varobj_8c.html#ae6ce7ad35d51a9378dd531c00695bf53">ada_varobj_get_value_of_array_variable</a> (value, type, opts);
<a name="l00876"></a>00876       <span class="keywordflow">break</span>;
<a name="l00877"></a>00877     <span class="keywordflow">default</span>:
<a name="l00878"></a>00878       <span class="keywordflow">if</span> (!value)
<a name="l00879"></a>00879         result = xstrdup (<span class="stringliteral">&quot;&quot;</span>);
<a name="l00880"></a>00880       <span class="keywordflow">else</span>
<a name="l00881"></a>00881         result = <a class="code" href="ada-varobj_8c.html#a57c74fe6fe7fe542f885c4ddf6b1ee4e">ada_varobj_get_value_image</a> (value, opts);
<a name="l00882"></a>00882       <span class="keywordflow">break</span>;
<a name="l00883"></a>00883     }
<a name="l00884"></a>00884 
<a name="l00885"></a>00885   <span class="keywordflow">return</span> result;
<a name="l00886"></a>00886 }
<a name="l00887"></a>00887 
<a name="l00888"></a>00888 
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:13:22 for GDB (xrefs) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
