<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (xrefs): /home/stan/gdb/src/gdb/linespec.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (xrefs)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/linespec.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="linespec_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Parser for linespec for the GNU debugger, GDB.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 1986-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   This file is part of GDB.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00010"></a>00010 <span class="comment">   (at your option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00018"></a>00018 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="frame_8h.html">frame.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="command_8h.html">command.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="symfile_8h.html">symfile.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="objfiles_8h.html">objfiles.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="source_8h.html">source.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;demangle.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="value_8h.html">value.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="completer_8h.html">completer.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="cp-abi_8h.html">cp-abi.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="cp-support_8h.html">cp-support.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="parser-defs_8h.html">parser-defs.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="block_8h.html">block.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="objc-lang_8h.html">objc-lang.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="linespec_8h.html">linespec.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="exceptions_8h.html">exceptions.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="language_8h.html">language.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="interps_8h.html">interps.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="mi-cmds_8h.html">mi/mi-cmds.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="target_8h.html">target.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="arch-utils_8h.html">arch-utils.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="cli-utils_8h.html">cli/cli-utils.h</a>&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;filenames.h&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="ada-lang_8h.html">ada-lang.h</a>&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;<a class="code" href="stack_8h.html">stack.h</a>&quot;</span>
<a name="l00047"></a>00047 
<a name="l00048"></a><a class="code" href="linespec_8c.html#af4cfb57f8a20c4f02a52ca8959d1f718">00048</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *<a class="code" href="dwarf2read_8c.html#af4cfb57f8a20c4f02a52ca8959d1f718">symbolp</a>;
<a name="l00049"></a>00049 <a class="code" href="vec_8h.html#af9d77557e51db07808428f28a3559803">DEF_VEC_P</a> (symbolp);
<a name="l00050"></a>00050 
<a name="l00051"></a><a class="code" href="linespec_8c.html#ab7f8c61060c5d5b2dc20d2aa601b9b69">00051</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="linespec_8c.html#ab7f8c61060c5d5b2dc20d2aa601b9b69">typep</a>;
<a name="l00052"></a>00052 <a class="code" href="vec_8h.html#af9d77557e51db07808428f28a3559803">DEF_VEC_P</a> (typep);
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">/* An address entry is used to ensure that any given location is only</span>
<a name="l00055"></a>00055 <span class="comment">   added to the result a single time.  It holds an address and the</span>
<a name="l00056"></a>00056 <span class="comment">   program space from which the address came.  */</span>
<a name="l00057"></a>00057 
<a name="l00058"></a><a class="code" href="structaddress__entry.html">00058</a> <span class="keyword">struct </span><a class="code" href="structaddress__entry.html">address_entry</a>
<a name="l00059"></a>00059 {
<a name="l00060"></a><a class="code" href="structaddress__entry.html#a2575cdc9a11fba3e23b6f8a5f10a9ff2">00060</a>   <span class="keyword">struct </span><a class="code" href="structprogram__space.html">program_space</a> *<a class="code" href="structaddress__entry.html#a2575cdc9a11fba3e23b6f8a5f10a9ff2">pspace</a>;
<a name="l00061"></a><a class="code" href="structaddress__entry.html#a02f9238c23361589fdd018083f36f62f">00061</a>   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structaddress__entry.html#a02f9238c23361589fdd018083f36f62f">addr</a>;
<a name="l00062"></a>00062 };
<a name="l00063"></a>00063 
<a name="l00064"></a><a class="code" href="linespec_8c.html#a77d4285dda21b9ce1c426e1c7c341203">00064</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol</a> <a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <a class="code" href="vec_8h.html#abc2d38563a8b5bed340654cf06060f11">DEF_VEC_O</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>);
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="comment">/* An enumeration of possible signs for a line offset.  */</span>
<a name="l00069"></a><a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376">00069</a> <span class="keyword">enum</span> <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376">offset_relative_sign</a>
<a name="l00070"></a>00070 {
<a name="l00071"></a>00071   <span class="comment">/* No sign  */</span>
<a name="l00072"></a><a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a6476a4ac46c8b156670deb1f9094a206">00072</a>   <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a6476a4ac46c8b156670deb1f9094a206">LINE_OFFSET_NONE</a>,
<a name="l00073"></a>00073 
<a name="l00074"></a>00074   <span class="comment">/* A plus sign (&quot;+&quot;)  */</span>
<a name="l00075"></a><a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a372071bffc263af1039dc02745e0af39">00075</a>   <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a372071bffc263af1039dc02745e0af39">LINE_OFFSET_PLUS</a>,
<a name="l00076"></a>00076 
<a name="l00077"></a>00077   <span class="comment">/* A minus sign (&quot;-&quot;)  */</span>
<a name="l00078"></a><a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a0785984972ad861764f36548801c2152">00078</a>   <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a0785984972ad861764f36548801c2152">LINE_OFFSET_MINUS</a>,
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   <span class="comment">/* A special &quot;sign&quot; for unspecified offset.  */</span>
<a name="l00081"></a><a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376abf2fff5ff94b498a10942f7e2b22f251">00081</a>   <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376abf2fff5ff94b498a10942f7e2b22f251">LINE_OFFSET_UNKNOWN</a>
<a name="l00082"></a>00082 };
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="comment">/* A line offset in a linespec.  */</span>
<a name="l00085"></a>00085 
<a name="l00086"></a><a class="code" href="structline__offset.html">00086</a> <span class="keyword">struct </span><a class="code" href="structline__offset.html">line_offset</a>
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088   <span class="comment">/* Line offset and any specified sign.  */</span>
<a name="l00089"></a><a class="code" href="structline__offset.html#a67b3ef5291f38b482121139dc421a84f">00089</a>   <span class="keywordtype">int</span> <a class="code" href="structline__offset.html#a67b3ef5291f38b482121139dc421a84f">offset</a>;
<a name="l00090"></a><a class="code" href="structline__offset.html#a472435e8559e52f51621869a9dc9f927">00090</a>   <span class="keyword">enum</span> <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376">offset_relative_sign</a> <a class="code" href="structline__offset.html#a472435e8559e52f51621869a9dc9f927">sign</a>;
<a name="l00091"></a>00091 };
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="comment">/* A linespec.  Elements of this structure are filled in by a parser</span>
<a name="l00094"></a>00094 <span class="comment">   (either parse_linespec or some other function).  The structure is</span>
<a name="l00095"></a>00095 <span class="comment">   then converted into SALs by convert_linespec_to_sals.  */</span>
<a name="l00096"></a>00096 
<a name="l00097"></a><a class="code" href="structlinespec.html">00097</a> <span class="keyword">struct </span><a class="code" href="structlinespec.html">linespec</a>
<a name="l00098"></a>00098 {
<a name="l00099"></a>00099   <span class="comment">/* An expression and the resulting PC.  Specifying an expression</span>
<a name="l00100"></a>00100 <span class="comment">     currently precludes the use of other members.  */</span>
<a name="l00101"></a>00101 
<a name="l00102"></a>00102   <span class="comment">/* The expression entered by the user.  */</span>
<a name="l00103"></a><a class="code" href="structlinespec.html#a6b0c3421dfbb7f24b02cf8f19e52a2a7">00103</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structlinespec.html#a6b0c3421dfbb7f24b02cf8f19e52a2a7">expression</a>;
<a name="l00104"></a>00104 
<a name="l00105"></a>00105   <span class="comment">/* The resulting PC expression derived from evaluating EXPRESSION.  */</span>
<a name="l00106"></a><a class="code" href="structlinespec.html#aa5de48a1573de9d8112e539a6f0b8308">00106</a>   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structlinespec.html#aa5de48a1573de9d8112e539a6f0b8308">expr_pc</a>;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <span class="comment">/* Any specified file symtabs.  */</span>
<a name="l00109"></a>00109 
<a name="l00110"></a>00110   <span class="comment">/* The user-supplied source filename or NULL if none was specified.  */</span>
<a name="l00111"></a><a class="code" href="structlinespec.html#a2c8cb5e40245987dbe66268f32c1fcb9">00111</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structlinespec.html#a2c8cb5e40245987dbe66268f32c1fcb9">source_filename</a>;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113   <span class="comment">/* The list of symtabs to search to which to limit the search.  May not</span>
<a name="l00114"></a>00114 <span class="comment">     be NULL.  If SOURCE_FILENAME is NULL (no user-specified filename),</span>
<a name="l00115"></a>00115 <span class="comment">     FILE_SYMTABS should contain one single NULL member.  This will</span>
<a name="l00116"></a>00116 <span class="comment">     cause the code to use the default symtab.  */</span>
<a name="l00117"></a><a class="code" href="structlinespec.html#aefcafd8b6c4968554f7935d3e20446e2">00117</a>   <a class="code" href="structlinespec.html#aefcafd8b6c4968554f7935d3e20446e2">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) *file_symtabs;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119   <span class="comment">/* The name of a function or method and any matching symbols.  */</span>
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   <span class="comment">/* The user-specified function name.  If no function name was</span>
<a name="l00122"></a>00122 <span class="comment">     supplied, this may be NULL.  */</span>
<a name="l00123"></a>00123   <span class="keyword">const</span> <span class="keywordtype">char</span> *function_name;
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   <span class="comment">/* A list of matching function symbols and minimal symbols.  Both lists</span>
<a name="l00126"></a>00126 <span class="comment">     may be NULL if no matching symbols were found.  */</span>
<a name="l00127"></a>00127   <a class="code" href="structlinespec.html#aefcafd8b6c4968554f7935d3e20446e2">VEC</a> (symbolp) *function_symbols;
<a name="l00128"></a>00128   <a class="code" href="structlinespec.html#aefcafd8b6c4968554f7935d3e20446e2">VEC</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>) *minimal_symbols;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   <span class="comment">/* The name of a label and matching symbols.  */</span>
<a name="l00131"></a>00131 
<a name="l00132"></a>00132   <span class="comment">/* The user-specified label name.  */</span>
<a name="l00133"></a>00133   <span class="keyword">const</span> <span class="keywordtype">char</span> *label_name;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135   <span class="comment">/* A structure of matching label symbols and the corresponding</span>
<a name="l00136"></a>00136 <span class="comment">     function symbol in which the label was found.  Both may be NULL</span>
<a name="l00137"></a>00137 <span class="comment">     or both must be non-NULL.  */</span>
<a name="l00138"></a>00138   <span class="keyword">struct</span>
<a name="l00139"></a>00139   {
<a name="l00140"></a>00140     <a class="code" href="structlinespec.html#aefcafd8b6c4968554f7935d3e20446e2">VEC</a> (symbolp) *label_symbols;
<a name="l00141"></a>00141     <a class="code" href="structlinespec.html#aefcafd8b6c4968554f7935d3e20446e2">VEC</a> (symbolp) *function_symbols;
<a name="l00142"></a><a class="code" href="structlinespec.html#af7e09f841ce15d942352005109a5c4d1">00142</a>   } <a class="code" href="structlinespec.html#af7e09f841ce15d942352005109a5c4d1">labels</a>;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144   <span class="comment">/* Line offset.  It may be LINE_OFFSET_UNKNOWN, meaning that no</span>
<a name="l00145"></a>00145 <span class="comment">   offset was specified.  */</span>
<a name="l00146"></a><a class="code" href="structlinespec.html#a2c94bd09386e673f272cdeabdf4dabe4">00146</a>   <span class="keyword">struct </span><a class="code" href="structline__offset.html">line_offset</a> <a class="code" href="structline__offset.html">line_offset</a>;
<a name="l00147"></a>00147 };
<a name="l00148"></a><a class="code" href="linespec_8c.html#a21e98dfe47859cd1e7877cc817f21ab3">00148</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structlinespec.html">linespec</a> *<a class="code" href="linespec_8c.html#a21e98dfe47859cd1e7877cc817f21ab3">linespec_p</a>;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="comment">/* A canonical linespec represented as a symtab-related string.</span>
<a name="l00151"></a>00151 <span class="comment"></span>
<a name="l00152"></a>00152 <span class="comment">   Each entry represents the &quot;SYMTAB:SUFFIX&quot; linespec string.</span>
<a name="l00153"></a>00153 <span class="comment">   SYMTAB can be converted for example by symtab_to_fullname or</span>
<a name="l00154"></a>00154 <span class="comment">   symtab_to_filename_for_display as needed.  */</span>
<a name="l00155"></a>00155 
<a name="l00156"></a><a class="code" href="structlinespec__canonical__name.html">00156</a> <span class="keyword">struct </span><a class="code" href="structlinespec__canonical__name.html">linespec_canonical_name</a>
<a name="l00157"></a>00157 {
<a name="l00158"></a>00158   <span class="comment">/* Remaining text part of the linespec string.  */</span>
<a name="l00159"></a><a class="code" href="structlinespec__canonical__name.html#af887cf4c56a62f9a6f0600a977c83551">00159</a>   <span class="keywordtype">char</span> *<a class="code" href="structlinespec__canonical__name.html#af887cf4c56a62f9a6f0600a977c83551">suffix</a>;
<a name="l00160"></a>00160 
<a name="l00161"></a>00161   <span class="comment">/* If NULL then SUFFIX is the whole linespec string.  */</span>
<a name="l00162"></a><a class="code" href="structlinespec__canonical__name.html#a7c67cdfe1ea5e98d5c6da45107625f05">00162</a>   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structlinespec__canonical__name.html#a7c67cdfe1ea5e98d5c6da45107625f05">symtab</a>;
<a name="l00163"></a>00163 };
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="comment">/* An instance of this is used to keep all state while linespec</span>
<a name="l00166"></a>00166 <span class="comment">   operates.  This instance is passed around as a &#39;this&#39; pointer to</span>
<a name="l00167"></a>00167 <span class="comment">   the various implementation methods.  */</span>
<a name="l00168"></a>00168 
<a name="l00169"></a><a class="code" href="structlinespec__state.html">00169</a> <span class="keyword">struct </span><a class="code" href="structlinespec__state.html">linespec_state</a>
<a name="l00170"></a>00170 {
<a name="l00171"></a>00171   <span class="comment">/* The language in use during linespec processing.  */</span>
<a name="l00172"></a><a class="code" href="structlinespec__state.html#a075a4742ad9d3652c6dd46765f84a0cb">00172</a>   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlanguage__defn.html">language_defn</a> *<a class="code" href="structlinespec__state.html#a075a4742ad9d3652c6dd46765f84a0cb">language</a>;
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <span class="comment">/* The program space as seen when the module was entered.  */</span>
<a name="l00175"></a><a class="code" href="structlinespec__state.html#aaf115e85a4a12355c4ff7694682d80ef">00175</a>   <span class="keyword">struct </span><a class="code" href="structprogram__space.html">program_space</a> *<a class="code" href="structlinespec__state.html#aaf115e85a4a12355c4ff7694682d80ef">program_space</a>;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177   <span class="comment">/* The default symtab to use, if no other symtab is specified.  */</span>
<a name="l00178"></a><a class="code" href="structlinespec__state.html#ad54bf647c2f234e0e2b0f53ee8d0d857">00178</a>   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structlinespec__state.html#ad54bf647c2f234e0e2b0f53ee8d0d857">default_symtab</a>;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180   <span class="comment">/* The default line to use.  */</span>
<a name="l00181"></a><a class="code" href="structlinespec__state.html#a752cf45ea9613bd6760c22156bf41933">00181</a>   <span class="keywordtype">int</span> <a class="code" href="structlinespec__state.html#a752cf45ea9613bd6760c22156bf41933">default_line</a>;
<a name="l00182"></a>00182 
<a name="l00183"></a>00183   <span class="comment">/* The &#39;funfirstline&#39; value that was passed in to decode_line_1 or</span>
<a name="l00184"></a>00184 <span class="comment">     decode_line_full.  */</span>
<a name="l00185"></a><a class="code" href="structlinespec__state.html#a945da3d4b8141bed24fef0d0a1f4a2c0">00185</a>   <span class="keywordtype">int</span> <a class="code" href="structlinespec__state.html#a945da3d4b8141bed24fef0d0a1f4a2c0">funfirstline</a>;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   <span class="comment">/* Nonzero if we are running in &#39;list&#39; mode; see decode_line_list.  */</span>
<a name="l00188"></a><a class="code" href="structlinespec__state.html#a34df2f5baa443f6a4277703e03765f3e">00188</a>   <span class="keywordtype">int</span> <a class="code" href="structlinespec__state.html#a34df2f5baa443f6a4277703e03765f3e">list_mode</a>;
<a name="l00189"></a>00189 
<a name="l00190"></a>00190   <span class="comment">/* The &#39;canonical&#39; value passed to decode_line_full, or NULL.  */</span>
<a name="l00191"></a><a class="code" href="structlinespec__state.html#aa126216e414f7a70c7ac6c9231e3cfa5">00191</a>   <span class="keyword">struct </span><a class="code" href="structlinespec__result.html">linespec_result</a> *<a class="code" href="structlinespec__state.html#aa126216e414f7a70c7ac6c9231e3cfa5">canonical</a>;
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   <span class="comment">/* Canonical strings that mirror the symtabs_and_lines result.  */</span>
<a name="l00194"></a><a class="code" href="structlinespec__state.html#ac6058a4a0366e50629e582135a7b6833">00194</a>   <span class="keyword">struct </span><a class="code" href="structlinespec__canonical__name.html">linespec_canonical_name</a> *<a class="code" href="structlinespec__state.html#ac6058a4a0366e50629e582135a7b6833">canonical_names</a>;
<a name="l00195"></a>00195 
<a name="l00196"></a>00196   <span class="comment">/* This is a set of address_entry objects which is used to prevent</span>
<a name="l00197"></a>00197 <span class="comment">     duplicate symbols from being entered into the result.  */</span>
<a name="l00198"></a><a class="code" href="structlinespec__state.html#a18cc324aa8dee9bc1ec84a12db929fb2">00198</a>   htab_t <a class="code" href="structlinespec__state.html#a18cc324aa8dee9bc1ec84a12db929fb2">addr_set</a>;
<a name="l00199"></a>00199 };
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 <span class="comment">/* This is a helper object that is used when collecting symbols into a</span>
<a name="l00202"></a>00202 <span class="comment">   result.  */</span>
<a name="l00203"></a>00203 
<a name="l00204"></a><a class="code" href="structcollect__info.html">00204</a> <span class="keyword">struct </span><a class="code" href="structcollect__info.html">collect_info</a>
<a name="l00205"></a>00205 {
<a name="l00206"></a>00206   <span class="comment">/* The linespec object in use.  */</span>
<a name="l00207"></a><a class="code" href="structcollect__info.html#ac705a97bd9a86bbe604d50e5b2a1019e">00207</a>   <span class="keyword">struct </span><a class="code" href="structlinespec__state.html">linespec_state</a> *<a class="code" href="structcollect__info.html#ac705a97bd9a86bbe604d50e5b2a1019e">state</a>;
<a name="l00208"></a>00208 
<a name="l00209"></a>00209   <span class="comment">/* A list of symtabs to which to restrict matches.  */</span>
<a name="l00210"></a><a class="code" href="structcollect__info.html#aaaff2f059385cf4d56a6d971c619068d">00210</a>   <a class="code" href="structcollect__info.html#aaaff2f059385cf4d56a6d971c619068d">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) *file_symtabs;
<a name="l00211"></a>00211 
<a name="l00212"></a>00212   <span class="comment">/* The result being accumulated.  */</span>
<a name="l00213"></a>00213   <span class="keyword">struct</span>
<a name="l00214"></a>00214   {
<a name="l00215"></a>00215     <a class="code" href="structcollect__info.html#aaaff2f059385cf4d56a6d971c619068d">VEC</a> (symbolp) *symbols;
<a name="l00216"></a>00216     <a class="code" href="structcollect__info.html#aaaff2f059385cf4d56a6d971c619068d">VEC</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>) *minimal_symbols;
<a name="l00217"></a><a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">00217</a>   } <a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>;
<a name="l00218"></a>00218 };
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 <span class="comment">/* Token types  */</span>
<a name="l00221"></a>00221 
<a name="l00222"></a><a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3">00222</a> <span class="keyword">enum</span> <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3">ls_token_type</a>
<a name="l00223"></a>00223 {
<a name="l00224"></a>00224   <span class="comment">/* A keyword  */</span>
<a name="l00225"></a><a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af8a55ade50678c246a4af428c016dee6">00225</a>   <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af8a55ade50678c246a4af428c016dee6">LSTOKEN_KEYWORD</a> = 0,
<a name="l00226"></a>00226 
<a name="l00227"></a>00227   <span class="comment">/* A colon &quot;separator&quot;  */</span>
<a name="l00228"></a><a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a64e5ca29e811888826b7231415dcb1fa">00228</a>   <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a64e5ca29e811888826b7231415dcb1fa">LSTOKEN_COLON</a>,
<a name="l00229"></a>00229 
<a name="l00230"></a>00230   <span class="comment">/* A string  */</span>
<a name="l00231"></a><a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af51514ff45b95b314eb23812fb75def7">00231</a>   <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af51514ff45b95b314eb23812fb75def7">LSTOKEN_STRING</a>,
<a name="l00232"></a>00232 
<a name="l00233"></a>00233   <span class="comment">/* A number  */</span>
<a name="l00234"></a><a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af5166818bc2e7c7262ab4913a8abd253">00234</a>   <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af5166818bc2e7c7262ab4913a8abd253">LSTOKEN_NUMBER</a>,
<a name="l00235"></a>00235 
<a name="l00236"></a>00236   <span class="comment">/* A comma  */</span>
<a name="l00237"></a><a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3ab831810c44c39dc484a828d6d141bade">00237</a>   <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3ab831810c44c39dc484a828d6d141bade">LSTOKEN_COMMA</a>,
<a name="l00238"></a>00238 
<a name="l00239"></a>00239   <span class="comment">/* EOI (end of input)  */</span>
<a name="l00240"></a><a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a9d5032c178932f2ba5e3c30763b2ef47">00240</a>   <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a9d5032c178932f2ba5e3c30763b2ef47">LSTOKEN_EOI</a>,
<a name="l00241"></a>00241 
<a name="l00242"></a>00242   <span class="comment">/* Consumed token  */</span>
<a name="l00243"></a><a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3aca342f5d4922401449679bbc1f87e700">00243</a>   <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3aca342f5d4922401449679bbc1f87e700">LSTOKEN_CONSUMED</a>
<a name="l00244"></a>00244 };
<a name="l00245"></a><a class="code" href="linespec_8c.html#a3c19f84cdd2fa351e461d88556380068">00245</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3">ls_token_type</a> <a class="code" href="linespec_8c.html#a3c19f84cdd2fa351e461d88556380068">linespec_token_type</a>;
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 <span class="comment">/* List of keywords  */</span>
<a name="l00248"></a>00248 
<a name="l00249"></a><a class="code" href="linespec_8c.html#a8586b6904586db2d682334ab99d0bb75">00249</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> <a class="code" href="linespec_8c.html#a8586b6904586db2d682334ab99d0bb75">linespec_keywords</a>[] = { <span class="stringliteral">&quot;if&quot;</span>, <span class="stringliteral">&quot;thread&quot;</span>, <span class="stringliteral">&quot;task&quot;</span> };
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="comment">/* A token of the linespec lexer  */</span>
<a name="l00252"></a>00252 
<a name="l00253"></a><a class="code" href="structls__token.html">00253</a> <span class="keyword">struct </span><a class="code" href="structls__token.html">ls_token</a>
<a name="l00254"></a>00254 {
<a name="l00255"></a>00255   <span class="comment">/* The type of the token  */</span>
<a name="l00256"></a><a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">00256</a>   <a class="code" href="linespec_8c.html#a3c19f84cdd2fa351e461d88556380068">linespec_token_type</a> <a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a>;
<a name="l00257"></a>00257 
<a name="l00258"></a>00258   <span class="comment">/* Data for the token  */</span>
<a name="l00259"></a>00259   <span class="keyword">union</span>
<a name="l00260"></a>00260   {
<a name="l00261"></a>00261     <span class="comment">/* A string, given as a stoken  */</span>
<a name="l00262"></a><a class="code" href="structls__token.html#aab98d05a326596c2af12a1ff910d256d">00262</a>     <span class="keyword">struct </span><a class="code" href="structstoken.html">stoken</a> <a class="code" href="structls__token.html#aab98d05a326596c2af12a1ff910d256d">string</a>;
<a name="l00263"></a>00263 
<a name="l00264"></a>00264     <span class="comment">/* A keyword  */</span>
<a name="l00265"></a><a class="code" href="structls__token.html#a3102e3b3780127525cee925a2d81dd26">00265</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structls__token.html#a3102e3b3780127525cee925a2d81dd26">keyword</a>;
<a name="l00266"></a>00266   } <a class="code" href="structls__token.html#a9e844fceb1bcd40c66c11854de0a8b99">data</a>;
<a name="l00267"></a>00267 };
<a name="l00268"></a><a class="code" href="linespec_8c.html#a41797d1a38e452b2eba1ada79bffeb39">00268</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structls__token.html">ls_token</a> <a class="code" href="structls__token.html">linespec_token</a>;
<a name="l00269"></a>00269 
<a name="l00270"></a><a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">00270</a> <span class="preprocessor">#define LS_TOKEN_STOKEN(TOK) (TOK).data.string</span>
<a name="l00271"></a><a class="code" href="linespec_8c.html#ae891ef3aaa3e72ad3d4a4754263fb2db">00271</a> <span class="preprocessor"></span><span class="preprocessor">#define LS_TOKEN_KEYWORD(TOK) (TOK).data.keyword</span>
<a name="l00272"></a>00272 <span class="preprocessor"></span>
<a name="l00273"></a>00273 <span class="comment">/* An instance of the linespec parser.  */</span>
<a name="l00274"></a>00274 
<a name="l00275"></a><a class="code" href="structls__parser.html">00275</a> <span class="keyword">struct </span><a class="code" href="structls__parser.html">ls_parser</a>
<a name="l00276"></a>00276 {
<a name="l00277"></a>00277   <span class="comment">/* Lexer internal data  */</span>
<a name="l00278"></a>00278   <span class="keyword">struct</span>
<a name="l00279"></a>00279   {
<a name="l00280"></a>00280     <span class="comment">/* Save head of input stream.  */</span>
<a name="l00281"></a><a class="code" href="structls__parser.html#afe4378668d9de865c3465a3fc25ba646">00281</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structls__parser.html#afe4378668d9de865c3465a3fc25ba646">saved_arg</a>;
<a name="l00282"></a>00282 
<a name="l00283"></a>00283     <span class="comment">/* Head of the input stream.  */</span>
<a name="l00284"></a><a class="code" href="structls__parser.html#a205d232b4158a125d49b0ed7b5b325e6">00284</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> **<a class="code" href="structls__parser.html#a205d232b4158a125d49b0ed7b5b325e6">stream</a>;
<a name="l00285"></a><a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">00285</a> <span class="preprocessor">#define PARSER_STREAM(P) (*(P)-&gt;lexer.stream)</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span>
<a name="l00287"></a>00287     <span class="comment">/* The current token.  */</span>
<a name="l00288"></a><a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">00288</a>     <a class="code" href="structls__token.html">linespec_token</a> <a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>;
<a name="l00289"></a>00289   } <a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>;
<a name="l00290"></a>00290 
<a name="l00291"></a>00291   <span class="comment">/* Is the entire linespec quote-enclosed?  */</span>
<a name="l00292"></a><a class="code" href="structls__parser.html#a5354e619ac44dab79e717d81c2e12331">00292</a>   <span class="keywordtype">int</span> <a class="code" href="structls__parser.html#a5354e619ac44dab79e717d81c2e12331">is_quote_enclosed</a>;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294   <span class="comment">/* Is a keyword syntactically valid at this point?</span>
<a name="l00295"></a>00295 <span class="comment">     In, e.g., &quot;break thread thread 1&quot;, the leading &quot;keyword&quot; must not</span>
<a name="l00296"></a>00296 <span class="comment">     be interpreted as such.  */</span>
<a name="l00297"></a><a class="code" href="structls__parser.html#a22ae887285302dfe09761e391295e7c0">00297</a>   <span class="keywordtype">int</span> <a class="code" href="structls__parser.html#a22ae887285302dfe09761e391295e7c0">keyword_ok</a>;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299   <span class="comment">/* The state of the parse.  */</span>
<a name="l00300"></a><a class="code" href="structls__parser.html#aa8f10ab2838dea40aba8981e4322e54e">00300</a>   <span class="keyword">struct </span><a class="code" href="structlinespec__state.html">linespec_state</a> <a class="code" href="structls__parser.html#aa8f10ab2838dea40aba8981e4322e54e">state</a>;
<a name="l00301"></a><a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">00301</a> <span class="preprocessor">#define PARSER_STATE(PPTR) (&amp;(PPTR)-&gt;state)</span>
<a name="l00302"></a>00302 <span class="preprocessor"></span>
<a name="l00303"></a>00303   <span class="comment">/* The result of the parse.  */</span>
<a name="l00304"></a><a class="code" href="structls__parser.html#a41f15b78d47c95273e9ea45d76733123">00304</a>   <span class="keyword">struct </span><a class="code" href="structlinespec.html">linespec</a> <a class="code" href="structls__parser.html#a41f15b78d47c95273e9ea45d76733123">result</a>;
<a name="l00305"></a><a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">00305</a> <span class="preprocessor">#define PARSER_RESULT(PPTR) (&amp;(PPTR)-&gt;result)</span>
<a name="l00306"></a>00306 <span class="preprocessor"></span>};
<a name="l00307"></a><a class="code" href="linespec_8c.html#a1f0cdf8a598f3f11b7330ec7a0c47d93">00307</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structls__parser.html">ls_parser</a> <a class="code" href="structls__parser.html">linespec_parser</a>;
<a name="l00308"></a>00308 
<a name="l00309"></a>00309 <span class="comment">/* Prototypes for local functions.  */</span>
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="linespec_8c.html#a69960965426eda86edc8cda619e5918e">iterate_over_file_blocks</a> (<span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structsymtab.html">symtab</a>,
<a name="l00312"></a>00312                                       <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> domain,
<a name="l00313"></a>00313                                       <a class="code" href="symtab_8h.html#ad1b2c2531ca06f07126a3f18b5681136">symbol_found_callback_ftype</a> *callback,
<a name="l00314"></a>00314                                       <span class="keywordtype">void</span> *data);
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="linespec_8c.html#a4791ffcdee3b1d956cc1ff1dcdeb2cb4">initialize_defaults</a> (<span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> **default_symtab,
<a name="l00317"></a>00317                                  <span class="keywordtype">int</span> *default_line);
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="linespec_8c.html#aa339d8b806f7f77d62dfa9179713c5d5">linespec_expression_to_pc</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> **exp_ptr);
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> <a class="code" href="linespec_8c.html#a57904262d36d2d6d5c1dfaf9cb181e2e">decode_objc</a> (struct <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l00322"></a>00322                                              linespec_p ls,
<a name="l00323"></a>00323                                              <span class="keyword">const</span> <span class="keywordtype">char</span> **argptr);
<a name="l00324"></a>00324 
<a name="l00325"></a><a class="code" href="linespec_8c.html#ab2e7f8c4796a0a072629b38aa3bc778c">00325</a> <span class="keyword">static</span> <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) *symtabs_from_filename (<span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 <span class="keyword">static</span> <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) *find_label_symbols (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l00328"></a>00328                                           <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) *function_symbols,
<a name="l00329"></a>00329                                           <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) **label_funcs_ret,
<a name="l00330"></a>00330                                           <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>);
<a name="l00331"></a>00331 
<a name="l00332"></a>00332 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="linespec_8c.html#aade11e4b850f57d619e2c4f2a841942f">find_linespec_symbols</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l00333"></a>00333                                    <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) *file_symtabs,
<a name="l00334"></a>00334                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>,
<a name="l00335"></a>00335                                    <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) **symbols,
<a name="l00336"></a>00336                                    <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>) **minsyms);
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structline__offset.html">line_offset</a>
<a name="l00339"></a>00339      <a class="code" href="linespec_8c.html#a4f9761a36dffbb858aa4123c570964fe">linespec_parse_variable</a> (struct <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l00340"></a>00340                               <span class="keyword">const</span> <span class="keywordtype">char</span> *variable);
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="linespec_8c.html#aa85de32bcb33630e5e698928cac16baf">symbol_to_sal</a> (<span class="keyword">struct</span> <a class="code" href="structsymtab__and__line.html">symtab_and_line</a> *result,
<a name="l00343"></a>00343                           <span class="keywordtype">int</span> funfirstline, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym);
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="linespec_8c.html#a9a911b477c6a45e4fd33ada11d1a1db8">add_matching_symbols_to_info</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00346"></a>00346                                           <span class="keyword">struct</span> <a class="code" href="structcollect__info.html">collect_info</a> *info,
<a name="l00347"></a>00347                                           <span class="keyword">struct</span> <a class="code" href="structprogram__space.html">program_space</a> *pspace);
<a name="l00348"></a>00348 
<a name="l00349"></a>00349 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="linespec_8c.html#a13d81637e51dfec2090f555b8c5af46f">add_all_symbol_names_from_pspace</a> (<span class="keyword">struct</span> <a class="code" href="structcollect__info.html">collect_info</a> *info,
<a name="l00350"></a>00350                                               <span class="keyword">struct</span> <a class="code" href="structprogram__space.html">program_space</a> *pspace,
<a name="l00351"></a>00351                                               <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>) *names);
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <span class="keyword">static</span> <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) *collect_symtabs_from_filename (<span class="keyword">const</span> <span class="keywordtype">char</span> *file);
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="linespec_8c.html#a27499bc4b74043e033d15c885f16d809">decode_digits_ordinary</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l00356"></a>00356                                     linespec_p ls,
<a name="l00357"></a>00357                                     <span class="keywordtype">int</span> <a class="code" href="symtab_8h.html#a41ebd28ef1d7c6ade45642cb6acc1039">line</a>,
<a name="l00358"></a>00358                                     <span class="keyword">struct</span> <a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> *sals,
<a name="l00359"></a>00359                                     <span class="keyword">struct</span> <a class="code" href="structlinetable__entry.html">linetable_entry</a> **<a class="code" href="symtab_8h.html#ac5e7b5c1b729fc27d6717b73d9644f85">best_entry</a>);
<a name="l00360"></a>00360 
<a name="l00361"></a>00361 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="linespec_8c.html#a50516c9f4476c1915ea4a16a87e6482a">decode_digits_list_mode</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l00362"></a>00362                                      linespec_p ls,
<a name="l00363"></a>00363                                      <span class="keyword">struct</span> <a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> *values,
<a name="l00364"></a>00364                                      <span class="keyword">struct</span> <a class="code" href="structsymtab__and__line.html">symtab_and_line</a> val);
<a name="l00365"></a>00365 
<a name="l00366"></a>00366 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="linespec_8c.html#a578832c419d6702dc6f0f644224002ed">minsym_found</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>, <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l00367"></a>00367                           <span class="keyword">struct</span> <a class="code" href="structminimal__symbol.html">minimal_symbol</a> *msymbol,
<a name="l00368"></a>00368                           <span class="keyword">struct</span> <a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> *result);
<a name="l00369"></a>00369 
<a name="l00370"></a>00370 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="linespec_8c.html#acb5414cbc70f2fd3932d5448208cfc3c">compare_symbols</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b);
<a name="l00371"></a>00371 
<a name="l00372"></a>00372 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="linespec_8c.html#a70dc083f4402e21d9de69d372c31dc4e">compare_msymbols</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b);
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="linespec_8c.html#a78445a049fc0b73c21b781c917ec68d3">find_toplevel_char</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">char</span> c);
<a name="l00375"></a>00375 
<a name="l00376"></a>00376 <span class="comment">/* Permitted quote characters for the parser.  This is different from the</span>
<a name="l00377"></a>00377 <span class="comment">   completer&#39;s quote characters to allow backward compatibility with the</span>
<a name="l00378"></a>00378 <span class="comment">   previous parser.  */</span>
<a name="l00379"></a>00379 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> linespec_quote_characters = <span class="stringliteral">&quot;\&quot;\&#39;&quot;</span>;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 <span class="comment">/* Lexer functions.  */</span>
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 <span class="comment">/* Lex a number from the input in PARSER.  This only supports</span>
<a name="l00384"></a>00384 <span class="comment">   decimal numbers.</span>
<a name="l00385"></a>00385 <span class="comment"></span>
<a name="l00386"></a>00386 <span class="comment">   Return true if input is decimal numbers.  Return false if not.  */</span>
<a name="l00387"></a>00387 
<a name="l00388"></a>00388 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00389"></a>00389 linespec_lexer_lex_number (<a class="code" href="structls__parser.html">linespec_parser</a> *parser, <a class="code" href="structls__token.html">linespec_token</a> *tokenp)
<a name="l00390"></a>00390 {
<a name="l00391"></a>00391   tokenp-&gt;<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> = <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af5166818bc2e7c7262ab4913a8abd253">LSTOKEN_NUMBER</a>;
<a name="l00392"></a>00392   <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (*tokenp).length = 0;
<a name="l00393"></a>00393   <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (*tokenp).ptr = <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser);
<a name="l00394"></a>00394 
<a name="l00395"></a>00395   <span class="comment">/* Keep any sign at the start of the stream.  */</span>
<a name="l00396"></a>00396   <span class="keywordflow">if</span> (*<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) == <span class="charliteral">&#39;+&#39;</span> || *<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) == <span class="charliteral">&#39;-&#39;</span>)
<a name="l00397"></a>00397     {
<a name="l00398"></a>00398       ++<a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (*tokenp).length;
<a name="l00399"></a>00399       ++(<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser));
<a name="l00400"></a>00400     }
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   <span class="keywordflow">while</span> (isdigit (*<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser)))
<a name="l00403"></a>00403     {
<a name="l00404"></a>00404       ++<a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (*tokenp).length;
<a name="l00405"></a>00405       ++(<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser));
<a name="l00406"></a>00406     }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408   <span class="comment">/* If the next character in the input buffer is not a space, comma,</span>
<a name="l00409"></a>00409 <span class="comment">     quote, or colon, this input does not represent a number.  */</span>
<a name="l00410"></a>00410   <span class="keywordflow">if</span> (*<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) != <span class="charliteral">&#39;\0&#39;</span>
<a name="l00411"></a>00411       &amp;&amp; !isspace (*<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser)) &amp;&amp; *<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) != <span class="charliteral">&#39;,&#39;</span>
<a name="l00412"></a>00412       &amp;&amp; *<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) != <span class="charliteral">&#39;:&#39;</span>
<a name="l00413"></a>00413       &amp;&amp; !<a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (linespec_quote_characters, *<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser)))
<a name="l00414"></a>00414     {
<a name="l00415"></a>00415       <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) = <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (*tokenp).ptr;
<a name="l00416"></a>00416       <span class="keywordflow">return</span> 0;
<a name="l00417"></a>00417     }
<a name="l00418"></a>00418 
<a name="l00419"></a>00419   <span class="keywordflow">return</span> 1;
<a name="l00420"></a>00420 }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 <span class="comment">/* Does P represent one of the keywords?  If so, return</span>
<a name="l00423"></a>00423 <span class="comment">   the keyword.  If not, return NULL.  */</span>
<a name="l00424"></a>00424 
<a name="l00425"></a>00425 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00426"></a><a class="code" href="linespec_8c.html#acb3922e63aced86c3adc52a37612b87a">00426</a> <a class="code" href="linespec_8c.html#acb3922e63aced86c3adc52a37612b87a">linespec_lexer_lex_keyword</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *p)
<a name="l00427"></a>00427 {
<a name="l00428"></a>00428   <span class="keywordtype">int</span> i;
<a name="l00429"></a>00429 
<a name="l00430"></a>00430   <span class="keywordflow">if</span> (p != NULL)
<a name="l00431"></a>00431     {
<a name="l00432"></a>00432       <span class="keywordflow">for</span> (i = 0; i &lt; ARRAY_SIZE (<a class="code" href="linespec_8c.html#a8586b6904586db2d682334ab99d0bb75">linespec_keywords</a>); ++i)
<a name="l00433"></a>00433         {
<a name="l00434"></a>00434           <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a> = strlen (<a class="code" href="linespec_8c.html#a8586b6904586db2d682334ab99d0bb75">linespec_keywords</a>[i]);
<a name="l00435"></a>00435 
<a name="l00436"></a>00436           <span class="comment">/* If P begins with one of the keywords and the next</span>
<a name="l00437"></a>00437 <span class="comment">             character is not a valid identifier character,</span>
<a name="l00438"></a>00438 <span class="comment">             we have found a keyword.  */</span>
<a name="l00439"></a>00439           <span class="keywordflow">if</span> (strncmp (p, <a class="code" href="linespec_8c.html#a8586b6904586db2d682334ab99d0bb75">linespec_keywords</a>[i], len) == 0
<a name="l00440"></a>00440               &amp;&amp; !(isalnum (p[len]) || p[len] == <span class="charliteral">&#39;_&#39;</span>))
<a name="l00441"></a>00441             <span class="keywordflow">return</span> <a class="code" href="linespec_8c.html#a8586b6904586db2d682334ab99d0bb75">linespec_keywords</a>[i];
<a name="l00442"></a>00442         }
<a name="l00443"></a>00443     }
<a name="l00444"></a>00444 
<a name="l00445"></a>00445   <span class="keywordflow">return</span> NULL;
<a name="l00446"></a>00446 }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448 <span class="comment">/* Does STRING represent an Ada operator?  If so, return the length</span>
<a name="l00449"></a>00449 <span class="comment">   of the decoded operator name.  If not, return 0.  */</span>
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00452"></a><a class="code" href="linespec_8c.html#a04bd71d4011fec1f936c61f9b2d254a0">00452</a> <a class="code" href="linespec_8c.html#a04bd71d4011fec1f936c61f9b2d254a0">is_ada_operator</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>)
<a name="l00453"></a>00453 {
<a name="l00454"></a>00454   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structada__opname__map.html">ada_opname_map</a> *mapping;
<a name="l00455"></a>00455 
<a name="l00456"></a>00456   <span class="keywordflow">for</span> (mapping = <a class="code" href="ada-lang_8c.html#a781ba01ff5799c7f5f84df58f20e0129">ada_opname_table</a>;
<a name="l00457"></a>00457        mapping-&gt;<a class="code" href="structada__opname__map.html#af4e7f0cadf2f970fb92488ae523cb706">encoded</a> != NULL
<a name="l00458"></a>00458          &amp;&amp; strncmp (mapping-&gt;<a class="code" href="structada__opname__map.html#a84c52a9db147c775a3ccb707fe99130b">decoded</a>, <span class="keywordtype">string</span>,
<a name="l00459"></a>00459                      strlen (mapping-&gt;<a class="code" href="structada__opname__map.html#a84c52a9db147c775a3ccb707fe99130b">decoded</a>)) != 0; ++mapping)
<a name="l00460"></a>00460     ;
<a name="l00461"></a>00461 
<a name="l00462"></a>00462   <span class="keywordflow">return</span> mapping-&gt;<a class="code" href="structada__opname__map.html#a84c52a9db147c775a3ccb707fe99130b">decoded</a> == NULL ? 0 : strlen (mapping-&gt;<a class="code" href="structada__opname__map.html#a84c52a9db147c775a3ccb707fe99130b">decoded</a>);
<a name="l00463"></a>00463 }
<a name="l00464"></a>00464 
<a name="l00465"></a>00465 <span class="comment">/* Find QUOTE_CHAR in STRING, accounting for the &#39;:&#39; terminal.  Return</span>
<a name="l00466"></a>00466 <span class="comment">   the location of QUOTE_CHAR, or NULL if not found.  */</span>
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00469"></a><a class="code" href="linespec_8c.html#ae2efb74c1247641f689a48b19edb2410">00469</a> <a class="code" href="linespec_8c.html#ae2efb74c1247641f689a48b19edb2410">skip_quote_char</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>, <span class="keywordtype">char</span> quote_char)
<a name="l00470"></a>00470 {
<a name="l00471"></a>00471   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>, *last;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473   p = last = <a class="code" href="linespec_8c.html#a78445a049fc0b73c21b781c917ec68d3">find_toplevel_char</a> (<span class="keywordtype">string</span>, quote_char);
<a name="l00474"></a>00474   <span class="keywordflow">while</span> (p &amp;&amp; *p != <span class="charliteral">&#39;\0&#39;</span> &amp;&amp; *p != <span class="charliteral">&#39;:&#39;</span>)
<a name="l00475"></a>00475     {
<a name="l00476"></a>00476       p = <a class="code" href="linespec_8c.html#a78445a049fc0b73c21b781c917ec68d3">find_toplevel_char</a> (p, quote_char);
<a name="l00477"></a>00477       <span class="keywordflow">if</span> (p != NULL)
<a name="l00478"></a>00478         last = p++;
<a name="l00479"></a>00479     }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481   <span class="keywordflow">return</span> last;
<a name="l00482"></a>00482 }
<a name="l00483"></a>00483 
<a name="l00484"></a>00484 <span class="comment">/* Make a writable copy of the string given in TOKEN, trimming</span>
<a name="l00485"></a>00485 <span class="comment">   any trailing whitespace.  */</span>
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00488"></a><a class="code" href="linespec_8c.html#a554b65b8cc0063ed9adf3e04294253e6">00488</a> <a class="code" href="linespec_8c.html#a554b65b8cc0063ed9adf3e04294253e6">copy_token_string</a> (<a class="code" href="structls__token.html">linespec_token</a> <a class="code" href="structtoken.html">token</a>)
<a name="l00489"></a>00489 {
<a name="l00490"></a>00490   <span class="keywordtype">char</span> *str, *s;
<a name="l00491"></a>00491 
<a name="l00492"></a>00492   <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af8a55ade50678c246a4af428c016dee6">LSTOKEN_KEYWORD</a>)
<a name="l00493"></a>00493     <span class="keywordflow">return</span> xstrdup (<a class="code" href="linespec_8c.html#ae891ef3aaa3e72ad3d4a4754263fb2db">LS_TOKEN_KEYWORD</a> (token));
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   str = <a class="code" href="common-utils_8c.html#a5f388f89054b57d850779d7d71bc4d1c">savestring</a> (<a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).ptr,
<a name="l00496"></a>00496                     <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).length);
<a name="l00497"></a>00497   s = <a class="code" href="cli-utils_8c.html#aca6574c82bc383474273602b4c95c44e">remove_trailing_whitespace</a> (str, str + <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).length);
<a name="l00498"></a>00498   *s = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00499"></a>00499 
<a name="l00500"></a>00500   <span class="keywordflow">return</span> str;
<a name="l00501"></a>00501 }
<a name="l00502"></a>00502 
<a name="l00503"></a>00503 <span class="comment">/* Does P represent the end of a quote-enclosed linespec?  */</span>
<a name="l00504"></a>00504 
<a name="l00505"></a>00505 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00506"></a><a class="code" href="linespec_8c.html#a4bcbc0eca5bb0b55768a5c7c0370e559">00506</a> <a class="code" href="linespec_8c.html#a4bcbc0eca5bb0b55768a5c7c0370e559">is_closing_quote_enclosed</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *p)
<a name="l00507"></a>00507 {
<a name="l00508"></a>00508   <span class="keywordflow">if</span> (<a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (linespec_quote_characters, *p))
<a name="l00509"></a>00509     ++p;
<a name="l00510"></a>00510   p = <a class="code" href="cli-utils_8c.html#afa70bcaee54d487b4412d2a7a5a0c8fa">skip_spaces</a> ((<span class="keywordtype">char</span> *) p);
<a name="l00511"></a>00511   <span class="keywordflow">return</span> (*p == <span class="charliteral">&#39;\0&#39;</span> || <a class="code" href="linespec_8c.html#acb3922e63aced86c3adc52a37612b87a">linespec_lexer_lex_keyword</a> (p));
<a name="l00512"></a>00512 }
<a name="l00513"></a>00513 
<a name="l00514"></a>00514 <span class="comment">/* Find the end of the parameter list that starts with *INPUT.</span>
<a name="l00515"></a>00515 <span class="comment">   This helper function assists with lexing string segments</span>
<a name="l00516"></a>00516 <span class="comment">   which might contain valid (non-terminating) commas.  */</span>
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00519"></a><a class="code" href="linespec_8c.html#a765d078cc14bbd2215c389522affafbe">00519</a> <a class="code" href="linespec_8c.html#a765d078cc14bbd2215c389522affafbe">find_parameter_list_end</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *input)
<a name="l00520"></a>00520 {
<a name="l00521"></a>00521   <span class="keywordtype">char</span> end_char, start_char;
<a name="l00522"></a>00522   <span class="keywordtype">int</span> depth;
<a name="l00523"></a>00523   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>;
<a name="l00524"></a>00524 
<a name="l00525"></a>00525   start_char = *input;
<a name="l00526"></a>00526   <span class="keywordflow">if</span> (start_char == <span class="charliteral">&#39;(&#39;</span>)
<a name="l00527"></a>00527     end_char = <span class="charliteral">&#39;)&#39;</span>;
<a name="l00528"></a>00528   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (start_char == <span class="charliteral">&#39;&lt;&#39;</span>)
<a name="l00529"></a>00529     end_char = <span class="charliteral">&#39;&gt;&#39;</span>;
<a name="l00530"></a>00530   <span class="keywordflow">else</span>
<a name="l00531"></a>00531     <span class="keywordflow">return</span> NULL;
<a name="l00532"></a>00532 
<a name="l00533"></a>00533   p = input;
<a name="l00534"></a>00534   depth = 0;
<a name="l00535"></a>00535   <span class="keywordflow">while</span> (*p)
<a name="l00536"></a>00536     {
<a name="l00537"></a>00537       <span class="keywordflow">if</span> (*p == start_char)
<a name="l00538"></a>00538         ++depth;
<a name="l00539"></a>00539       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*p == end_char)
<a name="l00540"></a>00540         {
<a name="l00541"></a>00541           <span class="keywordflow">if</span> (--depth == 0)
<a name="l00542"></a>00542             {
<a name="l00543"></a>00543               ++p;
<a name="l00544"></a>00544               <span class="keywordflow">break</span>;
<a name="l00545"></a>00545             }
<a name="l00546"></a>00546         }
<a name="l00547"></a>00547       ++p;
<a name="l00548"></a>00548     }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550   <span class="keywordflow">return</span> p;
<a name="l00551"></a>00551 }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="comment">/* Lex a string from the input in PARSER.  */</span>
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 <span class="keyword">static</span> <a class="code" href="structls__token.html">linespec_token</a>
<a name="l00557"></a><a class="code" href="linespec_8c.html#a5c23fa7d6c8a5574e12d5eb90bcd5543">00557</a> <a class="code" href="linespec_8c.html#a5c23fa7d6c8a5574e12d5eb90bcd5543">linespec_lexer_lex_string</a> (<a class="code" href="structls__parser.html">linespec_parser</a> *parser)
<a name="l00558"></a>00558 {
<a name="l00559"></a>00559   <a class="code" href="structls__token.html">linespec_token</a> <a class="code" href="m2-exp_8c.html#a8abb7e972adc09624edab301e021dc5f">token</a>;
<a name="l00560"></a>00560   <span class="keyword">const</span> <span class="keywordtype">char</span> *start = <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser);
<a name="l00561"></a>00561 
<a name="l00562"></a>00562   token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> = <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af51514ff45b95b314eb23812fb75def7">LSTOKEN_STRING</a>;
<a name="l00563"></a>00563 
<a name="l00564"></a>00564   <span class="comment">/* If the input stream starts with a quote character, skip to the next</span>
<a name="l00565"></a>00565 <span class="comment">     quote character, regardless of the content.  */</span>
<a name="l00566"></a>00566   <span class="keywordflow">if</span> (<a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (linespec_quote_characters, *<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser)))
<a name="l00567"></a>00567     {
<a name="l00568"></a>00568       <span class="keyword">const</span> <span class="keywordtype">char</span> *end;
<a name="l00569"></a>00569       <span class="keywordtype">char</span> quote_char = *<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser);
<a name="l00570"></a>00570 
<a name="l00571"></a>00571       <span class="comment">/* Special case: Ada operators.  */</span>
<a name="l00572"></a>00572       <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">PARSER_STATE</a> (parser)-&gt;<a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a>-&gt;la_language == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>
<a name="l00573"></a>00573           &amp;&amp; quote_char == <span class="charliteral">&#39;\&quot;&#39;</span>)
<a name="l00574"></a>00574         {
<a name="l00575"></a>00575           <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a> = <a class="code" href="linespec_8c.html#a04bd71d4011fec1f936c61f9b2d254a0">is_ada_operator</a> (<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser));
<a name="l00576"></a>00576 
<a name="l00577"></a>00577           <span class="keywordflow">if</span> (len != 0)
<a name="l00578"></a>00578             {
<a name="l00579"></a>00579               <span class="comment">/* The input is an Ada operator.  Return the quoted string</span>
<a name="l00580"></a>00580 <span class="comment">                 as-is.  */</span>
<a name="l00581"></a>00581               <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).ptr = <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser);
<a name="l00582"></a>00582               <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).length = <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l00583"></a>00583               <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) += <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l00584"></a>00584               <span class="keywordflow">return</span> <a class="code" href="m2-exp_8c.html#a8abb7e972adc09624edab301e021dc5f">token</a>;
<a name="l00585"></a>00585             }
<a name="l00586"></a>00586 
<a name="l00587"></a>00587           <span class="comment">/* The input does not represent an Ada operator -- fall through</span>
<a name="l00588"></a>00588 <span class="comment">             to normal quoted string handling.  */</span>
<a name="l00589"></a>00589         }
<a name="l00590"></a>00590 
<a name="l00591"></a>00591       <span class="comment">/* Skip past the beginning quote.  */</span>
<a name="l00592"></a>00592       ++(<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser));
<a name="l00593"></a>00593 
<a name="l00594"></a>00594       <span class="comment">/* Mark the start of the string.  */</span>
<a name="l00595"></a>00595       <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).ptr = <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser);
<a name="l00596"></a>00596 
<a name="l00597"></a>00597       <span class="comment">/* Skip to the ending quote.  */</span>
<a name="l00598"></a>00598       end = <a class="code" href="linespec_8c.html#ae2efb74c1247641f689a48b19edb2410">skip_quote_char</a> (<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser), quote_char);
<a name="l00599"></a>00599 
<a name="l00600"></a>00600       <span class="comment">/* Error if the input did not terminate properly.  */</span>
<a name="l00601"></a>00601       <span class="keywordflow">if</span> (end == NULL)
<a name="l00602"></a>00602         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unmatched quote&quot;</span>));
<a name="l00603"></a>00603 
<a name="l00604"></a>00604       <span class="comment">/* Skip over the ending quote and mark the length of the string.  */</span>
<a name="l00605"></a>00605       <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) = (<span class="keywordtype">char</span> *) ++end;
<a name="l00606"></a>00606       <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).length = <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) - 2 - start;
<a name="l00607"></a>00607     }
<a name="l00608"></a>00608   <span class="keywordflow">else</span>
<a name="l00609"></a>00609     {
<a name="l00610"></a>00610       <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>;
<a name="l00611"></a>00611 
<a name="l00612"></a>00612       <span class="comment">/* Otherwise, only identifier characters are permitted.</span>
<a name="l00613"></a>00613 <span class="comment">         Spaces are the exception.  In general, we keep spaces,</span>
<a name="l00614"></a>00614 <span class="comment">         but only if the next characters in the input do not resolve</span>
<a name="l00615"></a>00615 <span class="comment">         to one of the keywords.</span>
<a name="l00616"></a>00616 <span class="comment"></span>
<a name="l00617"></a>00617 <span class="comment">         This allows users to forgo quoting CV-qualifiers, template arguments,</span>
<a name="l00618"></a>00618 <span class="comment">         and similar common language constructs.  */</span>
<a name="l00619"></a>00619 
<a name="l00620"></a>00620       <span class="keywordflow">while</span> (1)
<a name="l00621"></a>00621         {
<a name="l00622"></a>00622           <span class="keywordflow">if</span> (isspace (*<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser)))
<a name="l00623"></a>00623             {
<a name="l00624"></a>00624               p = <a class="code" href="cli-utils_8c.html#aad7df612354d99c740a7ea12eccd3848">skip_spaces_const</a> (<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser));
<a name="l00625"></a>00625               <span class="comment">/* When we get here we know we&#39;ve found something followed by</span>
<a name="l00626"></a>00626 <span class="comment">                 a space (we skip over parens and templates below).</span>
<a name="l00627"></a>00627 <span class="comment">                 So if we find a keyword now, we know it is a keyword and not,</span>
<a name="l00628"></a>00628 <span class="comment">                 say, a function name.  */</span>
<a name="l00629"></a>00629               <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#acb3922e63aced86c3adc52a37612b87a">linespec_lexer_lex_keyword</a> (p) != NULL)
<a name="l00630"></a>00630                 {
<a name="l00631"></a>00631                   <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).ptr = start;
<a name="l00632"></a>00632                   <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).length
<a name="l00633"></a>00633                     = <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) - start;
<a name="l00634"></a>00634                   <span class="keywordflow">return</span> <a class="code" href="m2-exp_8c.html#a8abb7e972adc09624edab301e021dc5f">token</a>;
<a name="l00635"></a>00635                 }
<a name="l00636"></a>00636 
<a name="l00637"></a>00637               <span class="comment">/* Advance past the whitespace.  */</span>
<a name="l00638"></a>00638               <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) = p;
<a name="l00639"></a>00639             }
<a name="l00640"></a>00640 
<a name="l00641"></a>00641           <span class="comment">/* If the next character is EOI or (single) &#39;:&#39;, the</span>
<a name="l00642"></a>00642 <span class="comment">             string is complete;  return the token.  */</span>
<a name="l00643"></a>00643           <span class="keywordflow">if</span> (*<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) == 0)
<a name="l00644"></a>00644             {
<a name="l00645"></a>00645               <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).ptr = start;
<a name="l00646"></a>00646               <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).length = <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) - start;
<a name="l00647"></a>00647               <span class="keywordflow">return</span> <a class="code" href="m2-exp_8c.html#a8abb7e972adc09624edab301e021dc5f">token</a>;
<a name="l00648"></a>00648             }
<a name="l00649"></a>00649           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser)[0] == <span class="charliteral">&#39;:&#39;</span>)
<a name="l00650"></a>00650             {
<a name="l00651"></a>00651               <span class="comment">/* Do not tokenize the C++ scope operator. */</span>
<a name="l00652"></a>00652               <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser)[1] == <span class="charliteral">&#39;:&#39;</span>)
<a name="l00653"></a>00653                 ++(<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser));
<a name="l00654"></a>00654 
<a name="l00655"></a>00655               <span class="comment">/* Do not tokenify if the input length so far is one</span>
<a name="l00656"></a>00656 <span class="comment">                 (i.e, a single-letter drive name) and the next character</span>
<a name="l00657"></a>00657 <span class="comment">                 is a directory separator.  This allows Windows-style</span>
<a name="l00658"></a>00658 <span class="comment">                 paths to be recognized as filenames without quoting it.  */</span>
<a name="l00659"></a>00659               <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) - start) != 1
<a name="l00660"></a>00660                        || !IS_DIR_SEPARATOR (<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser)[1]))
<a name="l00661"></a>00661                 {
<a name="l00662"></a>00662                   <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).ptr = start;
<a name="l00663"></a>00663                   <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).length
<a name="l00664"></a>00664                     = <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) - start;
<a name="l00665"></a>00665                   <span class="keywordflow">return</span> <a class="code" href="m2-exp_8c.html#a8abb7e972adc09624edab301e021dc5f">token</a>;
<a name="l00666"></a>00666                 }
<a name="l00667"></a>00667             }
<a name="l00668"></a>00668           <span class="comment">/* Special case: permit quote-enclosed linespecs.  */</span>
<a name="l00669"></a>00669           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parser-&gt;<a class="code" href="structls__parser.html#a5354e619ac44dab79e717d81c2e12331">is_quote_enclosed</a>
<a name="l00670"></a>00670                    &amp;&amp; <a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (linespec_quote_characters,
<a name="l00671"></a>00671                               *<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser))
<a name="l00672"></a>00672                    &amp;&amp; <a class="code" href="linespec_8c.html#a4bcbc0eca5bb0b55768a5c7c0370e559">is_closing_quote_enclosed</a> (<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser)))
<a name="l00673"></a>00673             {
<a name="l00674"></a>00674               <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).ptr = start;
<a name="l00675"></a>00675               <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).length = <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) - start;
<a name="l00676"></a>00676               <span class="keywordflow">return</span> <a class="code" href="m2-exp_8c.html#a8abb7e972adc09624edab301e021dc5f">token</a>;
<a name="l00677"></a>00677             }
<a name="l00678"></a>00678           <span class="comment">/* Because commas may terminate a linespec and appear in</span>
<a name="l00679"></a>00679 <span class="comment">             the middle of valid string input, special cases for</span>
<a name="l00680"></a>00680 <span class="comment">             &#39;&lt;&#39; and &#39;(&#39; are necessary.  */</span>
<a name="l00681"></a>00681           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) == <span class="charliteral">&#39;&lt;&#39;</span>
<a name="l00682"></a>00682                    || *<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) == <span class="charliteral">&#39;(&#39;</span>)
<a name="l00683"></a>00683             {
<a name="l00684"></a>00684               <span class="keyword">const</span> <span class="keywordtype">char</span> *p;
<a name="l00685"></a>00685 
<a name="l00686"></a>00686               p = <a class="code" href="linespec_8c.html#a765d078cc14bbd2215c389522affafbe">find_parameter_list_end</a> (<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser));
<a name="l00687"></a>00687               <span class="keywordflow">if</span> (p != NULL)
<a name="l00688"></a>00688                 {
<a name="l00689"></a>00689                   <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) = p;
<a name="l00690"></a>00690                   <span class="keywordflow">continue</span>;
<a name="l00691"></a>00691                 }
<a name="l00692"></a>00692             }
<a name="l00693"></a>00693           <span class="comment">/* Commas are terminators, but not if they are part of an</span>
<a name="l00694"></a>00694 <span class="comment">             operator name.  */</span>
<a name="l00695"></a>00695           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) == <span class="charliteral">&#39;,&#39;</span>)
<a name="l00696"></a>00696             {
<a name="l00697"></a>00697               <span class="keywordflow">if</span> ((<a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">PARSER_STATE</a> (parser)-&gt;<a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a>-&gt;la_language
<a name="l00698"></a>00698                    == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a44cdc45a15de5e8e690da9ebf1b91132">language_cplus</a>)
<a name="l00699"></a>00699                   &amp;&amp; (<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) - start) &gt; 8
<a name="l00700"></a>00700                   <span class="comment">/* strlen (&quot;operator&quot;) */</span>)
<a name="l00701"></a>00701                 {
<a name="l00702"></a>00702                   <span class="keywordtype">char</span> *p = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (start, <span class="stringliteral">&quot;operator&quot;</span>);
<a name="l00703"></a>00703 
<a name="l00704"></a>00704                   <span class="keywordflow">if</span> (p != NULL &amp;&amp; <a class="code" href="cp-abi_8c.html#a0df2c3151e3e3809160af3841da5e047">is_operator_name</a> (p))
<a name="l00705"></a>00705                     {
<a name="l00706"></a>00706                       <span class="comment">/* This is an operator name.  Keep going.  */</span>
<a name="l00707"></a>00707                       ++(<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser));
<a name="l00708"></a>00708                       <span class="keywordflow">continue</span>;
<a name="l00709"></a>00709                     }
<a name="l00710"></a>00710                 }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712               <span class="comment">/* Comma terminates the string.  */</span>
<a name="l00713"></a>00713               <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).ptr = start;
<a name="l00714"></a>00714               <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).length = <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) - start;
<a name="l00715"></a>00715               <span class="keywordflow">return</span> <a class="code" href="m2-exp_8c.html#a8abb7e972adc09624edab301e021dc5f">token</a>;
<a name="l00716"></a>00716             }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718           <span class="comment">/* Advance the stream.  */</span>
<a name="l00719"></a>00719           ++(<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser));
<a name="l00720"></a>00720         }
<a name="l00721"></a>00721     }
<a name="l00722"></a>00722 
<a name="l00723"></a>00723   <span class="keywordflow">return</span> <a class="code" href="m2-exp_8c.html#a8abb7e972adc09624edab301e021dc5f">token</a>;
<a name="l00724"></a>00724 }
<a name="l00725"></a>00725 
<a name="l00726"></a>00726 <span class="comment">/* Lex a single linespec token from PARSER.  */</span>
<a name="l00727"></a>00727 
<a name="l00728"></a>00728 <span class="keyword">static</span> <a class="code" href="structls__token.html">linespec_token</a>
<a name="l00729"></a><a class="code" href="linespec_8c.html#ad98a478ce9c21319c2940cc23479d49b">00729</a> <a class="code" href="linespec_8c.html#ad98a478ce9c21319c2940cc23479d49b">linespec_lexer_lex_one</a> (<a class="code" href="structls__parser.html">linespec_parser</a> *parser)
<a name="l00730"></a>00730 {
<a name="l00731"></a>00731   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structkeyword.html">keyword</a>;
<a name="l00732"></a>00732 
<a name="l00733"></a>00733   <span class="keywordflow">if</span> (parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3aca342f5d4922401449679bbc1f87e700">LSTOKEN_CONSUMED</a>)
<a name="l00734"></a>00734     {
<a name="l00735"></a>00735       <span class="comment">/* Skip any whitespace.  */</span>
<a name="l00736"></a>00736       <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) = <a class="code" href="cli-utils_8c.html#aad7df612354d99c740a7ea12eccd3848">skip_spaces_const</a> (<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser));
<a name="l00737"></a>00737 
<a name="l00738"></a>00738       <span class="comment">/* Check for a keyword, they end the linespec.  */</span>
<a name="l00739"></a>00739       keyword = NULL;
<a name="l00740"></a>00740       <span class="keywordflow">if</span> (parser-&gt;<a class="code" href="structls__parser.html#a22ae887285302dfe09761e391295e7c0">keyword_ok</a>)
<a name="l00741"></a>00741         keyword = <a class="code" href="linespec_8c.html#acb3922e63aced86c3adc52a37612b87a">linespec_lexer_lex_keyword</a> (<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser));
<a name="l00742"></a>00742       <span class="keywordflow">if</span> (keyword != NULL)
<a name="l00743"></a>00743         {
<a name="l00744"></a>00744           parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> = <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af8a55ade50678c246a4af428c016dee6">LSTOKEN_KEYWORD</a>;
<a name="l00745"></a>00745           <a class="code" href="linespec_8c.html#ae891ef3aaa3e72ad3d4a4754263fb2db">LS_TOKEN_KEYWORD</a> (parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>) = keyword;
<a name="l00746"></a>00746           <span class="keywordflow">return</span> parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>;
<a name="l00747"></a>00747         }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749       <span class="comment">/* Handle other tokens.  */</span>
<a name="l00750"></a>00750       <span class="keywordflow">switch</span> (*<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser))
<a name="l00751"></a>00751         {
<a name="l00752"></a>00752         <span class="keywordflow">case</span> 0:
<a name="l00753"></a>00753           parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> = <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a9d5032c178932f2ba5e3c30763b2ef47">LSTOKEN_EOI</a>;
<a name="l00754"></a>00754           <span class="keywordflow">break</span>;
<a name="l00755"></a>00755 
<a name="l00756"></a>00756         <span class="keywordflow">case</span> <span class="charliteral">&#39;+&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;-&#39;</span>:
<a name="l00757"></a>00757         <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;1&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;2&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;3&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;4&#39;</span>:
<a name="l00758"></a>00758         <span class="keywordflow">case</span> <span class="charliteral">&#39;5&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;6&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;7&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;8&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;9&#39;</span>:
<a name="l00759"></a>00759            <span class="keywordflow">if</span> (!linespec_lexer_lex_number (parser, &amp;(parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>)))
<a name="l00760"></a>00760              parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a> = <a class="code" href="linespec_8c.html#a5c23fa7d6c8a5574e12d5eb90bcd5543">linespec_lexer_lex_string</a> (parser);
<a name="l00761"></a>00761           <span class="keywordflow">break</span>;
<a name="l00762"></a>00762 
<a name="l00763"></a>00763         <span class="keywordflow">case</span> <span class="charliteral">&#39;:&#39;</span>:
<a name="l00764"></a>00764           <span class="comment">/* If we have a scope operator, lex the input as a string.</span>
<a name="l00765"></a>00765 <span class="comment">             Otherwise, return LSTOKEN_COLON.  */</span>
<a name="l00766"></a>00766           <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser)[1] == <span class="charliteral">&#39;:&#39;</span>)
<a name="l00767"></a>00767             parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a> = <a class="code" href="linespec_8c.html#a5c23fa7d6c8a5574e12d5eb90bcd5543">linespec_lexer_lex_string</a> (parser);
<a name="l00768"></a>00768           <span class="keywordflow">else</span>
<a name="l00769"></a>00769             {
<a name="l00770"></a>00770               parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> = <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a64e5ca29e811888826b7231415dcb1fa">LSTOKEN_COLON</a>;
<a name="l00771"></a>00771               ++(<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser));
<a name="l00772"></a>00772             }
<a name="l00773"></a>00773           <span class="keywordflow">break</span>;
<a name="l00774"></a>00774 
<a name="l00775"></a>00775         <span class="keywordflow">case</span> <span class="charliteral">&#39;\&#39;&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;\&quot;&#39;</span>:
<a name="l00776"></a>00776           <span class="comment">/* Special case: permit quote-enclosed linespecs.  */</span>
<a name="l00777"></a>00777           <span class="keywordflow">if</span> (parser-&gt;<a class="code" href="structls__parser.html#a5354e619ac44dab79e717d81c2e12331">is_quote_enclosed</a>
<a name="l00778"></a>00778               &amp;&amp; <a class="code" href="linespec_8c.html#a4bcbc0eca5bb0b55768a5c7c0370e559">is_closing_quote_enclosed</a> (<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser)))
<a name="l00779"></a>00779             {
<a name="l00780"></a>00780               ++(<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser));
<a name="l00781"></a>00781               parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> = <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a9d5032c178932f2ba5e3c30763b2ef47">LSTOKEN_EOI</a>;
<a name="l00782"></a>00782             }
<a name="l00783"></a>00783           <span class="keywordflow">else</span>
<a name="l00784"></a>00784             parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a> = <a class="code" href="linespec_8c.html#a5c23fa7d6c8a5574e12d5eb90bcd5543">linespec_lexer_lex_string</a> (parser);
<a name="l00785"></a>00785           <span class="keywordflow">break</span>;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787         <span class="keywordflow">case</span> <span class="charliteral">&#39;,&#39;</span>:
<a name="l00788"></a>00788           parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> = <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3ab831810c44c39dc484a828d6d141bade">LSTOKEN_COMMA</a>;
<a name="l00789"></a>00789           <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>).ptr
<a name="l00790"></a>00790             = <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser);
<a name="l00791"></a>00791           <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>).length = 1;
<a name="l00792"></a>00792           ++(<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser));
<a name="l00793"></a>00793           <span class="keywordflow">break</span>;
<a name="l00794"></a>00794 
<a name="l00795"></a>00795         <span class="keywordflow">default</span>:
<a name="l00796"></a>00796           <span class="comment">/* If the input is not a number, it must be a string.</span>
<a name="l00797"></a>00797 <span class="comment">             [Keywords were already considered above.]  */</span>
<a name="l00798"></a>00798           parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a> = <a class="code" href="linespec_8c.html#a5c23fa7d6c8a5574e12d5eb90bcd5543">linespec_lexer_lex_string</a> (parser);
<a name="l00799"></a>00799           <span class="keywordflow">break</span>;
<a name="l00800"></a>00800         }
<a name="l00801"></a>00801     }
<a name="l00802"></a>00802 
<a name="l00803"></a>00803   <span class="keywordflow">return</span> parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>;
<a name="l00804"></a>00804 }
<a name="l00805"></a>00805 
<a name="l00806"></a>00806 <span class="comment">/* Consume the current token and return the next token in PARSER&#39;s</span>
<a name="l00807"></a>00807 <span class="comment">   input stream.  */</span>
<a name="l00808"></a>00808 
<a name="l00809"></a>00809 <span class="keyword">static</span> <a class="code" href="structls__token.html">linespec_token</a>
<a name="l00810"></a><a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">00810</a> <a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">linespec_lexer_consume_token</a> (<a class="code" href="structls__parser.html">linespec_parser</a> *parser)
<a name="l00811"></a>00811 {
<a name="l00812"></a>00812   parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> = <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3aca342f5d4922401449679bbc1f87e700">LSTOKEN_CONSUMED</a>;
<a name="l00813"></a>00813   <span class="keywordflow">return</span> <a class="code" href="linespec_8c.html#ad98a478ce9c21319c2940cc23479d49b">linespec_lexer_lex_one</a> (parser);
<a name="l00814"></a>00814 }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816 <span class="comment">/* Return the next token without consuming the current token.  */</span>
<a name="l00817"></a>00817 
<a name="l00818"></a>00818 <span class="keyword">static</span> <a class="code" href="structls__token.html">linespec_token</a>
<a name="l00819"></a><a class="code" href="linespec_8c.html#a800de2e4bb092a096e3d420798e753b8">00819</a> <a class="code" href="linespec_8c.html#a800de2e4bb092a096e3d420798e753b8">linespec_lexer_peek_token</a> (<a class="code" href="structls__parser.html">linespec_parser</a> *parser)
<a name="l00820"></a>00820 {
<a name="l00821"></a>00821   <a class="code" href="structls__token.html">linespec_token</a> next;
<a name="l00822"></a>00822   <span class="keyword">const</span> <span class="keywordtype">char</span> *saved_stream = <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser);
<a name="l00823"></a>00823   <a class="code" href="structls__token.html">linespec_token</a> saved_token = parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>;
<a name="l00824"></a>00824 
<a name="l00825"></a>00825   next = <a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">linespec_lexer_consume_token</a> (parser);
<a name="l00826"></a>00826   <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) = saved_stream;
<a name="l00827"></a>00827   parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a> = saved_token;
<a name="l00828"></a>00828   <span class="keywordflow">return</span> next;
<a name="l00829"></a>00829 }
<a name="l00830"></a>00830 
<a name="l00831"></a>00831 <span class="comment">/* Helper functions.  */</span>
<a name="l00832"></a>00832 
<a name="l00833"></a>00833 <span class="comment">/* Add SAL to SALS.  */</span>
<a name="l00834"></a>00834 
<a name="l00835"></a>00835 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00836"></a><a class="code" href="linespec_8c.html#adc0b6166d4a7ea4c37ccbd1468790954">00836</a> <a class="code" href="linespec_8c.html#adc0b6166d4a7ea4c37ccbd1468790954">add_sal_to_sals_basic</a> (<span class="keyword">struct</span> <a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> *sals,
<a name="l00837"></a>00837                        <span class="keyword">struct</span> <a class="code" href="structsymtab__and__line.html">symtab_and_line</a> *sal)
<a name="l00838"></a>00838 {
<a name="l00839"></a>00839   ++sals-&gt;<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a>;
<a name="l00840"></a>00840   sals-&gt;<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a> = <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (sals-&gt;<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a>, sals-&gt;<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a> * sizeof (sals-&gt;<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a>[0]));
<a name="l00841"></a>00841   sals-&gt;<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a>[sals-&gt;<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a> - 1] = *sal;
<a name="l00842"></a>00842 }
<a name="l00843"></a>00843 
<a name="l00844"></a>00844 <span class="comment">/* Add SAL to SALS, and also update SELF-&gt;CANONICAL_NAMES to reflect</span>
<a name="l00845"></a>00845 <span class="comment">   the new sal, if needed.  If not NULL, SYMNAME is the name of the</span>
<a name="l00846"></a>00846 <span class="comment">   symbol to use when constructing the new canonical name.</span>
<a name="l00847"></a>00847 <span class="comment"></span>
<a name="l00848"></a>00848 <span class="comment">   If LITERAL_CANONICAL is non-zero, SYMNAME will be used as the</span>
<a name="l00849"></a>00849 <span class="comment">   canonical name for the SAL.  */</span>
<a name="l00850"></a>00850 
<a name="l00851"></a>00851 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00852"></a><a class="code" href="linespec_8c.html#abe07dbe47bca0f2cfca183745cb34f7d">00852</a> <a class="code" href="linespec_8c.html#abe07dbe47bca0f2cfca183745cb34f7d">add_sal_to_sals</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l00853"></a>00853                  <span class="keyword">struct</span> <a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> *sals,
<a name="l00854"></a>00854                  <span class="keyword">struct</span> <a class="code" href="structsymtab__and__line.html">symtab_and_line</a> *sal,
<a name="l00855"></a>00855                  <span class="keyword">const</span> <span class="keywordtype">char</span> *symname, <span class="keywordtype">int</span> literal_canonical)
<a name="l00856"></a>00856 {
<a name="l00857"></a>00857   <a class="code" href="linespec_8c.html#adc0b6166d4a7ea4c37ccbd1468790954">add_sal_to_sals_basic</a> (sals, sal);
<a name="l00858"></a>00858 
<a name="l00859"></a>00859   <span class="keywordflow">if</span> (self-&gt;canonical)
<a name="l00860"></a>00860     {
<a name="l00861"></a>00861       <span class="keyword">struct </span><a class="code" href="structlinespec__canonical__name.html">linespec_canonical_name</a> *canonical;
<a name="l00862"></a>00862 
<a name="l00863"></a>00863       <span class="keyword">self</span>-&gt;canonical_names = <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (self-&gt;canonical_names,
<a name="l00864"></a>00864                                         (sals-&gt;<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a>
<a name="l00865"></a>00865                                          * sizeof (*self-&gt;canonical_names)));
<a name="l00866"></a>00866       canonical = &amp;<span class="keyword">self</span>-&gt;canonical_names[sals-&gt;<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a> - 1];
<a name="l00867"></a>00867       <span class="keywordflow">if</span> (!literal_canonical &amp;&amp; sal-&gt;<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a>)
<a name="l00868"></a>00868         {
<a name="l00869"></a>00869           <span class="keyword">const</span> <span class="keywordtype">char</span> *fullname = <a class="code" href="source_8c.html#aa78177718e9d6c01595600975e8254df">symtab_to_fullname</a> (sal-&gt;<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a>);
<a name="l00870"></a>00870 
<a name="l00871"></a>00871           <span class="comment">/* Note that the filter doesn&#39;t have to be a valid linespec</span>
<a name="l00872"></a>00872 <span class="comment">             input.  We only apply the &quot;:LINE&quot; treatment to Ada for</span>
<a name="l00873"></a>00873 <span class="comment">             the time being.  */</span>
<a name="l00874"></a>00874           <span class="keywordflow">if</span> (symname != NULL &amp;&amp; sal-&gt;<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a> != 0
<a name="l00875"></a>00875               &amp;&amp; self-&gt;language-&gt;la_language == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l00876"></a>00876             canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#af887cf4c56a62f9a6f0600a977c83551">suffix</a> = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;%s:%d&quot;</span>, symname, sal-&gt;<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a>);
<a name="l00877"></a>00877           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (symname != NULL)
<a name="l00878"></a>00878             canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#af887cf4c56a62f9a6f0600a977c83551">suffix</a> = xstrdup (symname);
<a name="l00879"></a>00879           <span class="keywordflow">else</span>
<a name="l00880"></a>00880             canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#af887cf4c56a62f9a6f0600a977c83551">suffix</a> = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;%d&quot;</span>, sal-&gt;<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a>);
<a name="l00881"></a>00881           canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#a7c67cdfe1ea5e98d5c6da45107625f05">symtab</a> = sal-&gt;<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a>;
<a name="l00882"></a>00882         }
<a name="l00883"></a>00883       <span class="keywordflow">else</span>
<a name="l00884"></a>00884         {
<a name="l00885"></a>00885           <span class="keywordflow">if</span> (symname != NULL)
<a name="l00886"></a>00886             canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#af887cf4c56a62f9a6f0600a977c83551">suffix</a> = xstrdup (symname);
<a name="l00887"></a>00887           <span class="keywordflow">else</span>
<a name="l00888"></a>00888             canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#af887cf4c56a62f9a6f0600a977c83551">suffix</a> = NULL;
<a name="l00889"></a>00889           canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#a7c67cdfe1ea5e98d5c6da45107625f05">symtab</a> = NULL;
<a name="l00890"></a>00890         }
<a name="l00891"></a>00891     }
<a name="l00892"></a>00892 }
<a name="l00893"></a>00893 
<a name="l00894"></a>00894 <span class="comment">/* A hash function for address_entry.  */</span>
<a name="l00895"></a>00895 
<a name="l00896"></a>00896 <span class="keyword">static</span> hashval_t
<a name="l00897"></a><a class="code" href="linespec_8c.html#a275c6bfe4494e7d9252def6acfbb6eab">00897</a> <a class="code" href="linespec_8c.html#a275c6bfe4494e7d9252def6acfbb6eab">hash_address_entry</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *p)
<a name="l00898"></a>00898 {
<a name="l00899"></a>00899   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structaddress__entry.html">address_entry</a> *aep = p;
<a name="l00900"></a>00900   hashval_t <a class="code" href="bcache_8c.html#a680b4550cc69a0827af4a7169fe3c372">hash</a>;
<a name="l00901"></a>00901 
<a name="l00902"></a>00902   hash = iterative_hash_object (aep-&gt;<a class="code" href="structaddress__entry.html#a2575cdc9a11fba3e23b6f8a5f10a9ff2">pspace</a>, 0);
<a name="l00903"></a>00903   <span class="keywordflow">return</span> iterative_hash_object (aep-&gt;<a class="code" href="structaddress__entry.html#a02f9238c23361589fdd018083f36f62f">addr</a>, hash);
<a name="l00904"></a>00904 }
<a name="l00905"></a>00905 
<a name="l00906"></a>00906 <span class="comment">/* An equality function for address_entry.  */</span>
<a name="l00907"></a>00907 
<a name="l00908"></a>00908 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00909"></a><a class="code" href="linespec_8c.html#a0a7bf64c264195ffbda31cba368609f7">00909</a> <a class="code" href="linespec_8c.html#a0a7bf64c264195ffbda31cba368609f7">eq_address_entry</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)
<a name="l00910"></a>00910 {
<a name="l00911"></a>00911   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structaddress__entry.html">address_entry</a> *aea = a;
<a name="l00912"></a>00912   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structaddress__entry.html">address_entry</a> *aeb = b;
<a name="l00913"></a>00913 
<a name="l00914"></a>00914   <span class="keywordflow">return</span> aea-&gt;<a class="code" href="structaddress__entry.html#a2575cdc9a11fba3e23b6f8a5f10a9ff2">pspace</a> == aeb-&gt;<a class="code" href="structaddress__entry.html#a2575cdc9a11fba3e23b6f8a5f10a9ff2">pspace</a> &amp;&amp; aea-&gt;<a class="code" href="structaddress__entry.html#a02f9238c23361589fdd018083f36f62f">addr</a> == aeb-&gt;<a class="code" href="structaddress__entry.html#a02f9238c23361589fdd018083f36f62f">addr</a>;
<a name="l00915"></a>00915 }
<a name="l00916"></a>00916 
<a name="l00917"></a>00917 <span class="comment">/* Check whether the address, represented by PSPACE and ADDR, is</span>
<a name="l00918"></a>00918 <span class="comment">   already in the set.  If so, return 0.  Otherwise, add it and return</span>
<a name="l00919"></a>00919 <span class="comment">   1.  */</span>
<a name="l00920"></a>00920 
<a name="l00921"></a>00921 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00922"></a><a class="code" href="linespec_8c.html#adb625ed35c6026ec3265189c615e7e07">00922</a> <a class="code" href="linespec_8c.html#adb625ed35c6026ec3265189c615e7e07">maybe_add_address</a> (htab_t <span class="keyword">set</span>, <span class="keyword">struct</span> <a class="code" href="structprogram__space.html">program_space</a> *pspace, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structaddress__entry.html#a02f9238c23361589fdd018083f36f62f">addr</a>)
<a name="l00923"></a>00923 {
<a name="l00924"></a>00924   <span class="keyword">struct </span><a class="code" href="structaddress__entry.html">address_entry</a> e, *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>;
<a name="l00925"></a>00925   <span class="keywordtype">void</span> **slot;
<a name="l00926"></a>00926 
<a name="l00927"></a>00927   e.<a class="code" href="structaddress__entry.html#a2575cdc9a11fba3e23b6f8a5f10a9ff2">pspace</a> = <a class="code" href="structaddress__entry.html#a2575cdc9a11fba3e23b6f8a5f10a9ff2">pspace</a>;
<a name="l00928"></a>00928   e.<a class="code" href="structaddress__entry.html#a02f9238c23361589fdd018083f36f62f">addr</a> = <a class="code" href="structaddress__entry.html#a02f9238c23361589fdd018083f36f62f">addr</a>;
<a name="l00929"></a>00929   slot = htab_find_slot (<span class="keyword">set</span>, &amp;e, INSERT);
<a name="l00930"></a>00930   <span class="keywordflow">if</span> (*slot)
<a name="l00931"></a>00931     <span class="keywordflow">return</span> 0;
<a name="l00932"></a>00932 
<a name="l00933"></a>00933   p = XNEW (<span class="keyword">struct</span> <a class="code" href="structaddress__entry.html">address_entry</a>);
<a name="l00934"></a>00934   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (p, &amp;e, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structaddress__entry.html">address_entry</a>));
<a name="l00935"></a>00935   *slot = p;
<a name="l00936"></a>00936 
<a name="l00937"></a>00937   <span class="keywordflow">return</span> 1;
<a name="l00938"></a>00938 }
<a name="l00939"></a>00939 
<a name="l00940"></a>00940 <span class="comment">/* A callback function and the additional data to call it with.  */</span>
<a name="l00941"></a>00941 
<a name="l00942"></a><a class="code" href="structsymbol__and__data__callback.html">00942</a> <span class="keyword">struct </span><a class="code" href="structsymbol__and__data__callback.html">symbol_and_data_callback</a>
<a name="l00943"></a>00943 {
<a name="l00944"></a>00944   <span class="comment">/* The callback to use.  */</span>
<a name="l00945"></a><a class="code" href="structsymbol__and__data__callback.html#ac8066d49f1eba1ca3ba181e24b7d69a3">00945</a>   <a class="code" href="symtab_8h.html#ad1b2c2531ca06f07126a3f18b5681136">symbol_found_callback_ftype</a> *<a class="code" href="structsymbol__and__data__callback.html#ac8066d49f1eba1ca3ba181e24b7d69a3">callback</a>;
<a name="l00946"></a>00946 
<a name="l00947"></a>00947   <span class="comment">/* Data to be passed to the callback.  */</span>
<a name="l00948"></a><a class="code" href="structsymbol__and__data__callback.html#a88f631e299673c863a225e970bedefe3">00948</a>   <span class="keywordtype">void</span> *<a class="code" href="structsymbol__and__data__callback.html#a88f631e299673c863a225e970bedefe3">data</a>;
<a name="l00949"></a>00949 };
<a name="l00950"></a>00950 
<a name="l00951"></a>00951 <span class="comment">/* A helper for iterate_over_all_matching_symtabs that is used to</span>
<a name="l00952"></a>00952 <span class="comment">   restrict calls to another callback to symbols representing inline</span>
<a name="l00953"></a>00953 <span class="comment">   symbols only.  */</span>
<a name="l00954"></a>00954 
<a name="l00955"></a>00955 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00956"></a><a class="code" href="linespec_8c.html#a76c184adda15d309fc432c1963618392">00956</a> <a class="code" href="linespec_8c.html#a76c184adda15d309fc432c1963618392">iterate_inline_only</a> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym, <span class="keywordtype">void</span> *d)
<a name="l00957"></a>00957 {
<a name="l00958"></a>00958   <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#ad695f7fd9589586be6188d9cbc0efda6">SYMBOL_INLINED</a> (sym))
<a name="l00959"></a>00959     {
<a name="l00960"></a>00960       <span class="keyword">struct </span><a class="code" href="structsymbol__and__data__callback.html">symbol_and_data_callback</a> *cad = d;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962       <span class="keywordflow">return</span> cad-&gt;<a class="code" href="structsymbol__and__data__callback.html#ac8066d49f1eba1ca3ba181e24b7d69a3">callback</a> (sym, cad-&gt;<a class="code" href="structsymbol__and__data__callback.html#a88f631e299673c863a225e970bedefe3">data</a>);
<a name="l00963"></a>00963     }
<a name="l00964"></a>00964   <span class="keywordflow">return</span> 1; <span class="comment">/* Continue iterating.  */</span>
<a name="l00965"></a>00965 }
<a name="l00966"></a>00966 
<a name="l00967"></a>00967 <span class="comment">/* Some data for the expand_symtabs_matching callback.  */</span>
<a name="l00968"></a>00968 
<a name="l00969"></a><a class="code" href="structsymbol__matcher__data.html">00969</a> <span class="keyword">struct </span><a class="code" href="structsymbol__matcher__data.html">symbol_matcher_data</a>
<a name="l00970"></a>00970 {
<a name="l00971"></a>00971   <span class="comment">/* The lookup name against which symbol name should be compared.  */</span>
<a name="l00972"></a><a class="code" href="structsymbol__matcher__data.html#a30843ec742b14e97a8eb26ef739d996a">00972</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structsymbol__matcher__data.html#a30843ec742b14e97a8eb26ef739d996a">lookup_name</a>;
<a name="l00973"></a>00973 
<a name="l00974"></a>00974   <span class="comment">/* The routine to be used for comparison.  */</span>
<a name="l00975"></a><a class="code" href="structsymbol__matcher__data.html#afa7d564223da681f45111cbe75754eba">00975</a>   <a class="code" href="language_8h.html#a11b69c55d697057ff7350b55851b671b">symbol_name_cmp_ftype</a> <a class="code" href="structsymbol__matcher__data.html#afa7d564223da681f45111cbe75754eba">symbol_name_cmp</a>;
<a name="l00976"></a>00976 };
<a name="l00977"></a>00977 
<a name="l00978"></a>00978 <span class="comment">/* A helper for iterate_over_all_matching_symtabs that is passed as a</span>
<a name="l00979"></a>00979 <span class="comment">   callback to the expand_symtabs_matching method.  */</span>
<a name="l00980"></a>00980 
<a name="l00981"></a>00981 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00982"></a><a class="code" href="linespec_8c.html#aa26f055613e3f477e43809fe23aff6fa">00982</a> <a class="code" href="linespec_8c.html#aa26f055613e3f477e43809fe23aff6fa">iterate_name_matcher</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">void</span> *d)
<a name="l00983"></a>00983 {
<a name="l00984"></a>00984   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structsymbol__matcher__data.html">symbol_matcher_data</a> *data = d;
<a name="l00985"></a>00985 
<a name="l00986"></a>00986   <span class="keywordflow">if</span> (data-&gt;<a class="code" href="structsymbol__matcher__data.html#afa7d564223da681f45111cbe75754eba">symbol_name_cmp</a> (name, data-&gt;<a class="code" href="structsymbol__matcher__data.html#a30843ec742b14e97a8eb26ef739d996a">lookup_name</a>) == 0)
<a name="l00987"></a>00987     <span class="keywordflow">return</span> 1; <span class="comment">/* Expand this symbol&#39;s symbol table.  */</span>
<a name="l00988"></a>00988   <span class="keywordflow">return</span> 0; <span class="comment">/* Skip this symbol.  */</span>
<a name="l00989"></a>00989 }
<a name="l00990"></a>00990 
<a name="l00991"></a>00991 <span class="comment">/* A helper that walks over all matching symtabs in all objfiles and</span>
<a name="l00992"></a>00992 <span class="comment">   calls CALLBACK for each symbol matching NAME.  If SEARCH_PSPACE is</span>
<a name="l00993"></a>00993 <span class="comment">   not NULL, then the search is restricted to just that program</span>
<a name="l00994"></a>00994 <span class="comment">   space.  If INCLUDE_INLINE is nonzero then symbols representing</span>
<a name="l00995"></a>00995 <span class="comment">   inlined instances of functions will be included in the result.  */</span>
<a name="l00996"></a>00996 
<a name="l00997"></a>00997 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00998"></a><a class="code" href="linespec_8c.html#ad601fce792b86d88730bf57a2703cbba">00998</a> <a class="code" href="linespec_8c.html#ad601fce792b86d88730bf57a2703cbba">iterate_over_all_matching_symtabs</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *state,
<a name="l00999"></a>00999                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l01000"></a>01000                                    <span class="keyword">const</span> <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> domain,
<a name="l01001"></a>01001                                    <a class="code" href="symtab_8h.html#ad1b2c2531ca06f07126a3f18b5681136">symbol_found_callback_ftype</a> *callback,
<a name="l01002"></a>01002                                    <span class="keywordtype">void</span> *data,
<a name="l01003"></a>01003                                    <span class="keyword">struct</span> <a class="code" href="structprogram__space.html">program_space</a> *search_pspace,
<a name="l01004"></a>01004                                    <span class="keywordtype">int</span> include_inline)
<a name="l01005"></a>01005 {
<a name="l01006"></a>01006   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>;
<a name="l01007"></a>01007   <span class="keyword">struct </span><a class="code" href="structprogram__space.html">program_space</a> *pspace;
<a name="l01008"></a>01008   <span class="keyword">struct </span><a class="code" href="structsymbol__matcher__data.html">symbol_matcher_data</a> matcher_data;
<a name="l01009"></a>01009 
<a name="l01010"></a>01010   matcher_data.<a class="code" href="structsymbol__matcher__data.html#a30843ec742b14e97a8eb26ef739d996a">lookup_name</a> = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01011"></a>01011   matcher_data.<a class="code" href="structsymbol__matcher__data.html#afa7d564223da681f45111cbe75754eba">symbol_name_cmp</a> =
<a name="l01012"></a>01012     state-&gt;<a class="code" href="structlinespec__state.html#a075a4742ad9d3652c6dd46765f84a0cb">language</a>-&gt;<a class="code" href="structlanguage__defn.html#ac513cbf0a9b4b0e505de117932c7f4ea">la_get_symbol_name_cmp</a> != NULL
<a name="l01013"></a>01013     ? state-&gt;<a class="code" href="structlinespec__state.html#a075a4742ad9d3652c6dd46765f84a0cb">language</a>-&gt;<a class="code" href="structlanguage__defn.html#ac513cbf0a9b4b0e505de117932c7f4ea">la_get_symbol_name_cmp</a> (name)
<a name="l01014"></a>01014     : <a class="code" href="utils_8c.html#afe92387dbf8135978e7845a7dcf18003">strcmp_iw</a>;
<a name="l01015"></a>01015 
<a name="l01016"></a>01016   <a class="code" href="progspace_8h.html#a9e4091a3fcf8c96cb18cf2042cbe21f6">ALL_PSPACES</a> (pspace)
<a name="l01017"></a>01017   {
<a name="l01018"></a>01018     <span class="keywordflow">if</span> (search_pspace != NULL &amp;&amp; search_pspace != pspace)
<a name="l01019"></a>01019       <span class="keywordflow">continue</span>;
<a name="l01020"></a>01020     <span class="keywordflow">if</span> (pspace-&gt;<a class="code" href="structprogram__space.html#a66c8a669a715e0f3c717bf0fd8951724">executing_startup</a>)
<a name="l01021"></a>01021       <span class="keywordflow">continue</span>;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023     <a class="code" href="progspace_8c.html#a394457638b3e584a3ecd019df372209f">set_current_program_space</a> (pspace);
<a name="l01024"></a>01024 
<a name="l01025"></a>01025     <a class="code" href="objfiles_8h.html#a8efee3b85a322006131a6056d45058b3">ALL_OBJFILES</a> (objfile)
<a name="l01026"></a>01026     {
<a name="l01027"></a>01027       <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structsymtab.html">symtab</a>;
<a name="l01028"></a>01028 
<a name="l01029"></a>01029       <span class="keywordflow">if</span> (objfile-&gt;<a class="code" href="structobjfile.html#af6814df9c2fd1f669fd79d0b0c94262c">sf</a>)
<a name="l01030"></a>01030         objfile-&gt;<a class="code" href="structobjfile.html#af6814df9c2fd1f669fd79d0b0c94262c">sf</a>-&gt;<a class="code" href="structsym__fns.html#ae4cb3e689cab6e5ecf8e2fb8770b55b0">qf</a>-&gt;<a class="code" href="structquick__symbol__functions.html#a591769641f8235f275019b6288690a47">expand_symtabs_matching</a> (objfile, NULL,
<a name="l01031"></a>01031                                                   <a class="code" href="linespec_8c.html#aa26f055613e3f477e43809fe23aff6fa">iterate_name_matcher</a>,
<a name="l01032"></a>01032                                                   <a class="code" href="symtab_8h.html#a37678171929b3b399903eec8be25dcd5ac9f9f7eff869eba6d6d85c4046c31f6f">ALL_DOMAIN</a>,
<a name="l01033"></a>01033                                                   &amp;matcher_data);
<a name="l01034"></a>01034 
<a name="l01035"></a>01035       <a class="code" href="objfiles_8h.html#ac5c382b88266264be72ac28e97437c9d">ALL_OBJFILE_PRIMARY_SYMTABS</a> (objfile, symtab)
<a name="l01036"></a>01036         {
<a name="l01037"></a>01037           <a class="code" href="linespec_8c.html#a69960965426eda86edc8cda619e5918e">iterate_over_file_blocks</a> (symtab, name, domain, callback, data);
<a name="l01038"></a>01038 
<a name="l01039"></a>01039           <span class="keywordflow">if</span> (include_inline)
<a name="l01040"></a>01040             {
<a name="l01041"></a>01041               <span class="keyword">struct </span><a class="code" href="structsymbol__and__data__callback.html">symbol_and_data_callback</a> cad = { <a class="code" href="structsymbol__and__data__callback.html#ac8066d49f1eba1ca3ba181e24b7d69a3">callback</a>, data };
<a name="l01042"></a>01042               <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>;
<a name="l01043"></a>01043               <span class="keywordtype">int</span> i;
<a name="l01044"></a>01044 
<a name="l01045"></a>01045               <span class="keywordflow">for</span> (i = <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124aa44bafc9bc0e67afa2e5bb50467d77ae">FIRST_LOCAL_BLOCK</a>;
<a name="l01046"></a>01046                    i &lt; <a class="code" href="block_8h.html#ae5ee617a852fcf6fbff069f0800176a4">BLOCKVECTOR_NBLOCKS</a> (<a class="code" href="symtab_8h.html#a6cd84410d73680ff8006ac44b1b98a9c">BLOCKVECTOR</a> (symtab)); i++)
<a name="l01047"></a>01047                 {
<a name="l01048"></a>01048                   block = <a class="code" href="block_8h.html#a84c4a3aa7b6b4d9a127a1c018dd6a776">BLOCKVECTOR_BLOCK</a> (<a class="code" href="symtab_8h.html#a6cd84410d73680ff8006ac44b1b98a9c">BLOCKVECTOR</a> (symtab), i);
<a name="l01049"></a>01049                   state-&gt;<a class="code" href="structlinespec__state.html#a075a4742ad9d3652c6dd46765f84a0cb">language</a>-&gt;<a class="code" href="structlanguage__defn.html#ae27aa805b10da01c27f943de31835d04">la_iterate_over_symbols</a>
<a name="l01050"></a>01050                     (block, name, domain, <a class="code" href="linespec_8c.html#a76c184adda15d309fc432c1963618392">iterate_inline_only</a>, &amp;cad);
<a name="l01051"></a>01051                 }
<a name="l01052"></a>01052             }
<a name="l01053"></a>01053         }
<a name="l01054"></a>01054     }
<a name="l01055"></a>01055   }
<a name="l01056"></a>01056 }
<a name="l01057"></a>01057 
<a name="l01058"></a>01058 <span class="comment">/* Returns the block to be used for symbol searches from</span>
<a name="l01059"></a>01059 <span class="comment">   the current location.  */</span>
<a name="l01060"></a>01060 
<a name="l01061"></a>01061 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *
<a name="l01062"></a><a class="code" href="linespec_8c.html#a58710768d426155e3738efb013f279f4">01062</a> <a class="code" href="linespec_8c.html#a58710768d426155e3738efb013f279f4">get_current_search_block</a> (<span class="keywordtype">void</span>)
<a name="l01063"></a>01063 {
<a name="l01064"></a>01064   <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>;
<a name="l01065"></a>01065   <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> save_language;
<a name="l01066"></a>01066 
<a name="l01067"></a>01067   <span class="comment">/* get_selected_block can change the current language when there is</span>
<a name="l01068"></a>01068 <span class="comment">     no selected frame yet.  */</span>
<a name="l01069"></a>01069   save_language = <a class="code" href="language_8c.html#acd2505a014a95629da9c836f8914fc79">current_language</a>-&gt;<a class="code" href="structlanguage__defn.html#a1395b7eb05a09e5798dc29257f30810a">la_language</a>;
<a name="l01070"></a>01070   block = <a class="code" href="frame_8h.html#a91efbdcf182d840c28d378def97cfc23">get_selected_block</a> (0);
<a name="l01071"></a>01071   <a class="code" href="language_8c.html#a87176c846a3ec717ada5e5622fe18550">set_language</a> (save_language);
<a name="l01072"></a>01072 
<a name="l01073"></a>01073   <span class="keywordflow">return</span> block;
<a name="l01074"></a>01074 }
<a name="l01075"></a>01075 
<a name="l01076"></a>01076 <span class="comment">/* Iterate over static and global blocks.  */</span>
<a name="l01077"></a>01077 
<a name="l01078"></a>01078 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01079"></a><a class="code" href="linespec_8c.html#a69960965426eda86edc8cda619e5918e">01079</a> <a class="code" href="linespec_8c.html#a69960965426eda86edc8cda619e5918e">iterate_over_file_blocks</a> (<span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structsymtab.html">symtab</a>,
<a name="l01080"></a>01080                           <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> domain,
<a name="l01081"></a>01081                           <a class="code" href="symtab_8h.html#ad1b2c2531ca06f07126a3f18b5681136">symbol_found_callback_ftype</a> *callback, <span class="keywordtype">void</span> *data)
<a name="l01082"></a>01082 {
<a name="l01083"></a>01083   <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>;
<a name="l01084"></a>01084 
<a name="l01085"></a>01085   <span class="keywordflow">for</span> (block = <a class="code" href="block_8h.html#a84c4a3aa7b6b4d9a127a1c018dd6a776">BLOCKVECTOR_BLOCK</a> (<a class="code" href="symtab_8h.html#a6cd84410d73680ff8006ac44b1b98a9c">BLOCKVECTOR</a> (symtab), <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124a4842990ca5391ee943c2069b28443a99">STATIC_BLOCK</a>);
<a name="l01086"></a>01086        block != NULL;
<a name="l01087"></a>01087        block = <a class="code" href="block_8h.html#a8b7633ab6d6feadf9b2ee58e10ad8397">BLOCK_SUPERBLOCK</a> (block))
<a name="l01088"></a>01088     <a class="code" href="language_8h.html#ac1f375f718771da9b2d8de439914a29d">LA_ITERATE_OVER_SYMBOLS</a> (block, name, domain, callback, data);
<a name="l01089"></a>01089 }
<a name="l01090"></a>01090 
<a name="l01091"></a>01091 <span class="comment">/* A helper for find_method.  This finds all methods in type T which</span>
<a name="l01092"></a>01092 <span class="comment">   match NAME.  It adds matching symbol names to RESULT_NAMES, and</span>
<a name="l01093"></a>01093 <span class="comment">   adds T&#39;s direct superclasses to SUPERCLASSES.  */</span>
<a name="l01094"></a>01094 
<a name="l01095"></a>01095 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01096"></a><a class="code" href="linespec_8c.html#aa15d13cd1d9d59f8f67c87aea9f03840">01096</a> <a class="code" href="linespec_8c.html#aa15d13cd1d9d59f8f67c87aea9f03840">find_methods</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *t, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l01097"></a>01097               <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>) **result_names,
<a name="l01098"></a>01098               <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (typep) **superclasses)
<a name="l01099"></a>01099 {
<a name="l01100"></a>01100   <span class="keywordtype">int</span> ibase;
<a name="l01101"></a>01101   <span class="keyword">const</span> <span class="keywordtype">char</span> *class_name = <a class="code" href="gdbtypes_8c.html#a1bce8398d8a46f3d37bfc7e618ab9e9d">type_name_no_tag</a> (t);
<a name="l01102"></a>01102 
<a name="l01103"></a>01103   <span class="comment">/* Ignore this class if it doesn&#39;t have a name.  This is ugly, but</span>
<a name="l01104"></a>01104 <span class="comment">     unless we figure out how to get the physname without the name of</span>
<a name="l01105"></a>01105 <span class="comment">     the class, then the loop can&#39;t do any good.  */</span>
<a name="l01106"></a>01106   <span class="keywordflow">if</span> (class_name)
<a name="l01107"></a>01107     {
<a name="l01108"></a>01108       <span class="keywordtype">int</span> method_counter;
<a name="l01109"></a>01109 
<a name="l01110"></a>01110       <a class="code" href="gdbtypes_8h.html#ae2f9348c644babaa9038b4dc18bffaac">CHECK_TYPEDEF</a> (t);
<a name="l01111"></a>01111 
<a name="l01112"></a>01112       <span class="comment">/* Loop over each method name.  At this level, all overloads of a name</span>
<a name="l01113"></a>01113 <span class="comment">         are counted as a single name.  There is an inner loop which loops over</span>
<a name="l01114"></a>01114 <span class="comment">         each overload.  */</span>
<a name="l01115"></a>01115 
<a name="l01116"></a>01116       <span class="keywordflow">for</span> (method_counter = <a class="code" href="gdbtypes_8h.html#a04c1a1616329be52b9a9706ddc102bd1">TYPE_NFN_FIELDS</a> (t) - 1;
<a name="l01117"></a>01117            method_counter &gt;= 0;
<a name="l01118"></a>01118            --method_counter)
<a name="l01119"></a>01119         {
<a name="l01120"></a>01120           <span class="keyword">const</span> <span class="keywordtype">char</span> *method_name = <a class="code" href="gdbtypes_8h.html#ad06fe1d1555d89ce87344fa6825e5642">TYPE_FN_FIELDLIST_NAME</a> (t, method_counter);
<a name="l01121"></a>01121           <span class="keywordtype">char</span> dem_opname[64];
<a name="l01122"></a>01122 
<a name="l01123"></a>01123           <span class="keywordflow">if</span> (strncmp (method_name, <span class="stringliteral">&quot;__&quot;</span>, 2) == 0 ||
<a name="l01124"></a>01124               strncmp (method_name, <span class="stringliteral">&quot;op&quot;</span>, 2) == 0 ||
<a name="l01125"></a>01125               strncmp (method_name, <span class="stringliteral">&quot;type&quot;</span>, 4) == 0)
<a name="l01126"></a>01126             {
<a name="l01127"></a>01127               <span class="keywordflow">if</span> (cplus_demangle_opname (method_name, dem_opname, DMGL_ANSI))
<a name="l01128"></a>01128                 method_name = dem_opname;
<a name="l01129"></a>01129               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cplus_demangle_opname (method_name, dem_opname, 0))
<a name="l01130"></a>01130                 method_name = dem_opname;
<a name="l01131"></a>01131             }
<a name="l01132"></a>01132 
<a name="l01133"></a>01133           <span class="keywordflow">if</span> (<a class="code" href="utils_8c.html#afe92387dbf8135978e7845a7dcf18003">strcmp_iw</a> (method_name, name) == 0)
<a name="l01134"></a>01134             {
<a name="l01135"></a>01135               <span class="keywordtype">int</span> field_counter;
<a name="l01136"></a>01136 
<a name="l01137"></a>01137               <span class="keywordflow">for</span> (field_counter = (<a class="code" href="gdbtypes_8h.html#a93f192829a3feec903de135b4d53981e">TYPE_FN_FIELDLIST_LENGTH</a> (t, method_counter)
<a name="l01138"></a>01138                                     - 1);
<a name="l01139"></a>01139                    field_counter &gt;= 0;
<a name="l01140"></a>01140                    --field_counter)
<a name="l01141"></a>01141                 {
<a name="l01142"></a>01142                   <span class="keyword">struct </span>fn_field *f;
<a name="l01143"></a>01143                   <span class="keyword">const</span> <span class="keywordtype">char</span> *phys_name;
<a name="l01144"></a>01144 
<a name="l01145"></a>01145                   f = <a class="code" href="gdbtypes_8h.html#a475365c72b8bba6494569379cec012df">TYPE_FN_FIELDLIST1</a> (t, method_counter);
<a name="l01146"></a>01146                   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a72f4bcaebfce8d11113344c05af99dd4">TYPE_FN_FIELD_STUB</a> (f, field_counter))
<a name="l01147"></a>01147                     <span class="keywordflow">continue</span>;
<a name="l01148"></a>01148                   phys_name = <a class="code" href="gdbtypes_8h.html#a027f2138f114a97b7ee81a535d4714b1">TYPE_FN_FIELD_PHYSNAME</a> (f, field_counter);
<a name="l01149"></a>01149                   <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>, *result_names, phys_name);
<a name="l01150"></a>01150                 }
<a name="l01151"></a>01151             }
<a name="l01152"></a>01152         }
<a name="l01153"></a>01153     }
<a name="l01154"></a>01154 
<a name="l01155"></a>01155   <span class="keywordflow">for</span> (ibase = 0; ibase &lt; <a class="code" href="gdbtypes_8h.html#ae19e9d182aaab51bcb695d4828b4fd53">TYPE_N_BASECLASSES</a> (t); ibase++)
<a name="l01156"></a>01156     <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (typep, *superclasses, <a class="code" href="gdbtypes_8h.html#a7d3e65996a8102e558b0ca2b25c1d2a8">TYPE_BASECLASS</a> (t, ibase));
<a name="l01157"></a>01157 }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159 <span class="comment">/* Find an instance of the character C in the string S that is outside</span>
<a name="l01160"></a>01160 <span class="comment">   of all parenthesis pairs, single-quoted strings, and double-quoted</span>
<a name="l01161"></a>01161 <span class="comment">   strings.  Also, ignore the char within a template name, like a &#39;,&#39;</span>
<a name="l01162"></a>01162 <span class="comment">   within foo&lt;int, int&gt;.  */</span>
<a name="l01163"></a>01163 
<a name="l01164"></a>01164 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l01165"></a><a class="code" href="linespec_8c.html#a78445a049fc0b73c21b781c917ec68d3">01165</a> <a class="code" href="linespec_8c.html#a78445a049fc0b73c21b781c917ec68d3">find_toplevel_char</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">char</span> c)
<a name="l01166"></a>01166 {
<a name="l01167"></a>01167   <span class="keywordtype">int</span> quoted = 0;               <span class="comment">/* zero if we&#39;re not in quotes;</span>
<a name="l01168"></a>01168 <span class="comment">                                   &#39;&quot;&#39; if we&#39;re in a double-quoted string;</span>
<a name="l01169"></a>01169 <span class="comment">                                   &#39;\&#39;&#39; if we&#39;re in a single-quoted string.  */</span>
<a name="l01170"></a>01170   <span class="keywordtype">int</span> depth = 0;                <span class="comment">/* Number of unclosed parens we&#39;ve seen.  */</span>
<a name="l01171"></a>01171   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="macroexp_8c.html#a59f4bc0e8b23314727c3ca16f524b309">scan</a>;
<a name="l01172"></a>01172 
<a name="l01173"></a>01173   <span class="keywordflow">for</span> (scan = s; *<a class="code" href="macroexp_8c.html#a59f4bc0e8b23314727c3ca16f524b309">scan</a>; scan++)
<a name="l01174"></a>01174     {
<a name="l01175"></a>01175       <span class="keywordflow">if</span> (quoted)
<a name="l01176"></a>01176         {
<a name="l01177"></a>01177           <span class="keywordflow">if</span> (*scan == quoted)
<a name="l01178"></a>01178             quoted = 0;
<a name="l01179"></a>01179           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*scan == <span class="charliteral">&#39;\\&#39;</span> &amp;&amp; *(scan + 1))
<a name="l01180"></a>01180             scan++;
<a name="l01181"></a>01181         }
<a name="l01182"></a>01182       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*scan == c &amp;&amp; ! quoted &amp;&amp; depth == 0)
<a name="l01183"></a>01183         <span class="keywordflow">return</span> <a class="code" href="macroexp_8c.html#a59f4bc0e8b23314727c3ca16f524b309">scan</a>;
<a name="l01184"></a>01184       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*scan == <span class="charliteral">&#39;&quot;&#39;</span> || *scan == <span class="charliteral">&#39;\&#39;&#39;</span>)
<a name="l01185"></a>01185         quoted = *<a class="code" href="macroexp_8c.html#a59f4bc0e8b23314727c3ca16f524b309">scan</a>;
<a name="l01186"></a>01186       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*scan == <span class="charliteral">&#39;(&#39;</span> || *scan == <span class="charliteral">&#39;&lt;&#39;</span>)
<a name="l01187"></a>01187         depth++;
<a name="l01188"></a>01188       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*scan == <span class="charliteral">&#39;)&#39;</span> || *scan == <span class="charliteral">&#39;&gt;&#39;</span>) &amp;&amp; depth &gt; 0)
<a name="l01189"></a>01189         depth--;
<a name="l01190"></a>01190     }
<a name="l01191"></a>01191 
<a name="l01192"></a>01192   <span class="keywordflow">return</span> 0;
<a name="l01193"></a>01193 }
<a name="l01194"></a>01194 
<a name="l01195"></a>01195 <span class="comment">/* The string equivalent of find_toplevel_char.  Returns a pointer</span>
<a name="l01196"></a>01196 <span class="comment">   to the location of NEEDLE in HAYSTACK, ignoring any occurrences</span>
<a name="l01197"></a>01197 <span class="comment">   inside &quot;()&quot; and &quot;&lt;&gt;&quot;.  Returns NULL if NEEDLE was not found.  */</span>
<a name="l01198"></a>01198 
<a name="l01199"></a>01199 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l01200"></a><a class="code" href="linespec_8c.html#a82b623f622646a274151cec40f12153a">01200</a> <a class="code" href="linespec_8c.html#a82b623f622646a274151cec40f12153a">find_toplevel_string</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *haystack, <span class="keyword">const</span> <span class="keywordtype">char</span> *needle)
<a name="l01201"></a>01201 {
<a name="l01202"></a>01202   <span class="keyword">const</span> <span class="keywordtype">char</span> *s = haystack;
<a name="l01203"></a>01203 
<a name="l01204"></a>01204   <span class="keywordflow">do</span>
<a name="l01205"></a>01205     {
<a name="l01206"></a>01206       s = <a class="code" href="linespec_8c.html#a78445a049fc0b73c21b781c917ec68d3">find_toplevel_char</a> (s, *needle);
<a name="l01207"></a>01207 
<a name="l01208"></a>01208       <span class="keywordflow">if</span> (s != NULL)
<a name="l01209"></a>01209         {
<a name="l01210"></a>01210           <span class="comment">/* Found first char in HAYSTACK;  check rest of string.  */</span>
<a name="l01211"></a>01211           <span class="keywordflow">if</span> (strncmp (s, needle, strlen (needle)) == 0)
<a name="l01212"></a>01212             <span class="keywordflow">return</span> s;
<a name="l01213"></a>01213 
<a name="l01214"></a>01214           <span class="comment">/* Didn&#39;t find it; loop over HAYSTACK, looking for the next</span>
<a name="l01215"></a>01215 <span class="comment">             instance of the first character of NEEDLE.  */</span>
<a name="l01216"></a>01216           ++s;
<a name="l01217"></a>01217         }
<a name="l01218"></a>01218     }
<a name="l01219"></a>01219   <span class="keywordflow">while</span> (s != NULL &amp;&amp; *s != <span class="charliteral">&#39;\0&#39;</span>);
<a name="l01220"></a>01220 
<a name="l01221"></a>01221   <span class="comment">/* NEEDLE was not found in HAYSTACK.  */</span>
<a name="l01222"></a>01222   <span class="keywordflow">return</span> NULL;
<a name="l01223"></a>01223 }
<a name="l01224"></a>01224 
<a name="l01225"></a>01225 <span class="comment">/* Convert CANONICAL to its string representation using</span>
<a name="l01226"></a>01226 <span class="comment">   symtab_to_fullname for SYMTAB.  The caller must xfree the result.  */</span>
<a name="l01227"></a>01227 
<a name="l01228"></a>01228 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l01229"></a><a class="code" href="linespec_8c.html#a50bd140e1fe59992e5764224d3eba108">01229</a> <a class="code" href="linespec_8c.html#a50bd140e1fe59992e5764224d3eba108">canonical_to_fullform</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlinespec__canonical__name.html">linespec_canonical_name</a> *canonical)
<a name="l01230"></a>01230 {
<a name="l01231"></a>01231   <span class="keywordflow">if</span> (canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#a7c67cdfe1ea5e98d5c6da45107625f05">symtab</a> == NULL)
<a name="l01232"></a>01232     <span class="keywordflow">return</span> xstrdup (canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#af887cf4c56a62f9a6f0600a977c83551">suffix</a>);
<a name="l01233"></a>01233   <span class="keywordflow">else</span>
<a name="l01234"></a>01234     <span class="keywordflow">return</span> <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;%s:%s&quot;</span>, <a class="code" href="source_8c.html#aa78177718e9d6c01595600975e8254df">symtab_to_fullname</a> (canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#a7c67cdfe1ea5e98d5c6da45107625f05">symtab</a>),
<a name="l01235"></a>01235                        canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#af887cf4c56a62f9a6f0600a977c83551">suffix</a>);
<a name="l01236"></a>01236 }
<a name="l01237"></a>01237 
<a name="l01238"></a>01238 <span class="comment">/* Given FILTERS, a list of canonical names, filter the sals in RESULT</span>
<a name="l01239"></a>01239 <span class="comment">   and store the result in SELF-&gt;CANONICAL.  */</span>
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01242"></a><a class="code" href="linespec_8c.html#ab7f5c5cf59e14b6816cdd59fedc94ef5">01242</a> <a class="code" href="linespec_8c.html#ab7f5c5cf59e14b6816cdd59fedc94ef5">filter_results</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l01243"></a>01243                 <span class="keyword">struct</span> <a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> *result,
<a name="l01244"></a>01244                 <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>) *filters)
<a name="l01245"></a>01245 {
<a name="l01246"></a>01246   <span class="keywordtype">int</span> i;
<a name="l01247"></a>01247   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01248"></a>01248 
<a name="l01249"></a>01249   <span class="keywordflow">for</span> (i = 0; <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>, filters, i, name); ++i)
<a name="l01250"></a>01250     {
<a name="l01251"></a>01251       <span class="keyword">struct </span><a class="code" href="structlinespec__sals.html">linespec_sals</a> lsal;
<a name="l01252"></a>01252       <span class="keywordtype">int</span> j;
<a name="l01253"></a>01253 
<a name="l01254"></a>01254       <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;lsal, 0, <span class="keyword">sizeof</span> (lsal));
<a name="l01255"></a>01255 
<a name="l01256"></a>01256       <span class="keywordflow">for</span> (j = 0; j &lt; result-&gt;<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a>; ++j)
<a name="l01257"></a>01257         {
<a name="l01258"></a>01258           <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlinespec__canonical__name.html">linespec_canonical_name</a> *canonical;
<a name="l01259"></a>01259           <span class="keywordtype">char</span> *fullform;
<a name="l01260"></a>01260           <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l01261"></a>01261 
<a name="l01262"></a>01262           canonical = &amp;<span class="keyword">self</span>-&gt;canonical_names[j];
<a name="l01263"></a>01263           fullform = <a class="code" href="linespec_8c.html#a50bd140e1fe59992e5764224d3eba108">canonical_to_fullform</a> (canonical);
<a name="l01264"></a>01264           cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, fullform);
<a name="l01265"></a>01265 
<a name="l01266"></a>01266           <span class="keywordflow">if</span> (strcmp (name, fullform) == 0)
<a name="l01267"></a>01267             <a class="code" href="linespec_8c.html#adc0b6166d4a7ea4c37ccbd1468790954">add_sal_to_sals_basic</a> (&amp;lsal.<a class="code" href="structlinespec__sals.html#a34ac2e438b2835722c998f409c85dcee">sals</a>, &amp;result-&gt;<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a>[j]);
<a name="l01268"></a>01268 
<a name="l01269"></a>01269           <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l01270"></a>01270         }
<a name="l01271"></a>01271 
<a name="l01272"></a>01272       <span class="keywordflow">if</span> (lsal.<a class="code" href="structlinespec__sals.html#a34ac2e438b2835722c998f409c85dcee">sals</a>.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a> &gt; 0)
<a name="l01273"></a>01273         {
<a name="l01274"></a>01274           lsal.<a class="code" href="structlinespec__sals.html#a5a6b2c7bb2c9b91d8077fb7186a6c466">canonical</a> = xstrdup (name);
<a name="l01275"></a>01275           <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structlinespec__sals.html">linespec_sals</a>, self-&gt;<a class="code" href="structlinespec__sals.html#a5a6b2c7bb2c9b91d8077fb7186a6c466">canonical</a>-&gt;sals, &amp;lsal);
<a name="l01276"></a>01276         }
<a name="l01277"></a>01277     }
<a name="l01278"></a>01278 
<a name="l01279"></a>01279   <span class="keyword">self</span>-&gt;canonical-&gt;pre_expanded = 0;
<a name="l01280"></a>01280 }
<a name="l01281"></a>01281 
<a name="l01282"></a>01282 <span class="comment">/* Store RESULT into SELF-&gt;CANONICAL.  */</span>
<a name="l01283"></a>01283 
<a name="l01284"></a>01284 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01285"></a><a class="code" href="linespec_8c.html#a2379614f47a369c0c1e4f7d4ba874994">01285</a> <a class="code" href="linespec_8c.html#a2379614f47a369c0c1e4f7d4ba874994">convert_results_to_lsals</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l01286"></a>01286                           <span class="keyword">struct</span> <a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> *result)
<a name="l01287"></a>01287 {
<a name="l01288"></a>01288   <span class="keyword">struct </span><a class="code" href="structlinespec__sals.html">linespec_sals</a> lsal;
<a name="l01289"></a>01289 
<a name="l01290"></a>01290   lsal.<a class="code" href="structlinespec__sals.html#a5a6b2c7bb2c9b91d8077fb7186a6c466">canonical</a> = NULL;
<a name="l01291"></a>01291   lsal.<a class="code" href="structlinespec__sals.html#a34ac2e438b2835722c998f409c85dcee">sals</a> = *result;
<a name="l01292"></a>01292   <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structlinespec__sals.html">linespec_sals</a>, self-&gt;<a class="code" href="structlinespec__sals.html#a5a6b2c7bb2c9b91d8077fb7186a6c466">canonical</a>-&gt;sals, &amp;lsal);
<a name="l01293"></a>01293 }
<a name="l01294"></a>01294 
<a name="l01295"></a>01295 <span class="comment">/* A structure that contains two string representations of a struct</span>
<a name="l01296"></a>01296 <span class="comment">   linespec_canonical_name:</span>
<a name="l01297"></a>01297 <span class="comment">     - one where the the symtab&#39;s fullname is used;</span>
<a name="l01298"></a>01298 <span class="comment">     - one where the filename followed the &quot;set filename-display&quot;</span>
<a name="l01299"></a>01299 <span class="comment">       setting.  */</span>
<a name="l01300"></a>01300 
<a name="l01301"></a><a class="code" href="structdecode__line__2__item.html">01301</a> <span class="keyword">struct </span><a class="code" href="structdecode__line__2__item.html">decode_line_2_item</a>
<a name="l01302"></a>01302 {
<a name="l01303"></a>01303   <span class="comment">/* The form using symtab_to_fullname.</span>
<a name="l01304"></a>01304 <span class="comment">     It must be xfree&#39;ed after use.  */</span>
<a name="l01305"></a><a class="code" href="structdecode__line__2__item.html#a2c87cc360cb4cc2a6be3bc6204e358b5">01305</a>   <span class="keywordtype">char</span> *<a class="code" href="structdecode__line__2__item.html#a2c87cc360cb4cc2a6be3bc6204e358b5">fullform</a>;
<a name="l01306"></a>01306 
<a name="l01307"></a>01307   <span class="comment">/* The form using symtab_to_filename_for_display.</span>
<a name="l01308"></a>01308 <span class="comment">     It must be xfree&#39;ed after use.  */</span>
<a name="l01309"></a><a class="code" href="structdecode__line__2__item.html#a4779821b460fe454b31902deb6288476">01309</a>   <span class="keywordtype">char</span> *<a class="code" href="structdecode__line__2__item.html#a4779821b460fe454b31902deb6288476">displayform</a>;
<a name="l01310"></a>01310 
<a name="l01311"></a>01311   <span class="comment">/* Field is initialized to zero and it is set to one if the user</span>
<a name="l01312"></a>01312 <span class="comment">     requested breakpoint for this entry.  */</span>
<a name="l01313"></a><a class="code" href="structdecode__line__2__item.html#a66d032ece52b090a24f482a036aff4eb">01313</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structdecode__line__2__item.html#a66d032ece52b090a24f482a036aff4eb">selected</a> : 1;
<a name="l01314"></a>01314 };
<a name="l01315"></a>01315 
<a name="l01316"></a>01316 <span class="comment">/* Helper for qsort to sort decode_line_2_item entries by DISPLAYFORM and</span>
<a name="l01317"></a>01317 <span class="comment">   secondarily by FULLFORM.  */</span>
<a name="l01318"></a>01318 
<a name="l01319"></a>01319 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01320"></a><a class="code" href="linespec_8c.html#afb2f265ab21985491efdf0020a3bffa0">01320</a> <a class="code" href="linespec_8c.html#afb2f265ab21985491efdf0020a3bffa0">decode_line_2_compare_items</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *ap, <span class="keyword">const</span> <span class="keywordtype">void</span> *bp)
<a name="l01321"></a>01321 {
<a name="l01322"></a>01322   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdecode__line__2__item.html">decode_line_2_item</a> *a = ap;
<a name="l01323"></a>01323   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdecode__line__2__item.html">decode_line_2_item</a> *b = bp;
<a name="l01324"></a>01324   <span class="keywordtype">int</span> retval;
<a name="l01325"></a>01325 
<a name="l01326"></a>01326   retval = strcmp (a-&gt;<a class="code" href="structdecode__line__2__item.html#a4779821b460fe454b31902deb6288476">displayform</a>, b-&gt;<a class="code" href="structdecode__line__2__item.html#a4779821b460fe454b31902deb6288476">displayform</a>);
<a name="l01327"></a>01327   <span class="keywordflow">if</span> (retval != 0)
<a name="l01328"></a>01328     <span class="keywordflow">return</span> retval;
<a name="l01329"></a>01329 
<a name="l01330"></a>01330   <span class="keywordflow">return</span> strcmp (a-&gt;<a class="code" href="structdecode__line__2__item.html#a2c87cc360cb4cc2a6be3bc6204e358b5">fullform</a>, b-&gt;<a class="code" href="structdecode__line__2__item.html#a2c87cc360cb4cc2a6be3bc6204e358b5">fullform</a>);
<a name="l01331"></a>01331 }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333 <span class="comment">/* Handle multiple results in RESULT depending on SELECT_MODE.  This</span>
<a name="l01334"></a>01334 <span class="comment">   will either return normally, throw an exception on multiple</span>
<a name="l01335"></a>01335 <span class="comment">   results, or present a menu to the user.  On return, the SALS vector</span>
<a name="l01336"></a>01336 <span class="comment">   in SELF-&gt;CANONICAL is set up properly.  */</span>
<a name="l01337"></a>01337 
<a name="l01338"></a>01338 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01339"></a><a class="code" href="linespec_8c.html#a9151e3c41ef3fd972e66cdaaf6bad8ca">01339</a> <a class="code" href="linespec_8c.html#a9151e3c41ef3fd972e66cdaaf6bad8ca">decode_line_2</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l01340"></a>01340                <span class="keyword">struct</span> <a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> *result,
<a name="l01341"></a>01341                <span class="keyword">const</span> <span class="keywordtype">char</span> *select_mode)
<a name="l01342"></a>01342 {
<a name="l01343"></a>01343   <span class="keywordtype">char</span> *args, *prompt;
<a name="l01344"></a>01344   <span class="keywordtype">int</span> i;
<a name="l01345"></a>01345   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *old_chain;
<a name="l01346"></a>01346   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>) *filters = NULL;
<a name="l01347"></a>01347   <span class="keyword">struct </span><a class="code" href="structget__number__or__range__state.html">get_number_or_range_state</a> state;
<a name="l01348"></a>01348   <span class="keyword">struct </span><a class="code" href="structdecode__line__2__item.html">decode_line_2_item</a> *items;
<a name="l01349"></a>01349   <span class="keywordtype">int</span> items_count;
<a name="l01350"></a>01350 
<a name="l01351"></a>01351   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (select_mode != <a class="code" href="symtab_8c.html#a2457c524e394ad239661c86ceedb99a7">multiple_symbols_all</a>);
<a name="l01352"></a>01352   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (self-&gt;canonical != NULL);
<a name="l01353"></a>01353   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (result-&gt;<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a> &gt;= 1);
<a name="l01354"></a>01354 
<a name="l01355"></a>01355   old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="vec_8h.html#a92a6114eb727b9274e1523d0e9dd2e61">VEC_cleanup</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>), &amp;filters);
<a name="l01356"></a>01356 
<a name="l01357"></a>01357   <span class="comment">/* Prepare ITEMS array.  */</span>
<a name="l01358"></a>01358   items_count = result-&gt;<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a>;
<a name="l01359"></a>01359   items = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (*items) * items_count);
<a name="l01360"></a>01360   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, items);
<a name="l01361"></a>01361   <span class="keywordflow">for</span> (i = 0; i &lt; items_count; ++i)
<a name="l01362"></a>01362     {
<a name="l01363"></a>01363       <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlinespec__canonical__name.html">linespec_canonical_name</a> *canonical;
<a name="l01364"></a>01364       <span class="keyword">struct </span><a class="code" href="structdecode__line__2__item.html">decode_line_2_item</a> *item;
<a name="l01365"></a>01365 
<a name="l01366"></a>01366       canonical = &amp;<span class="keyword">self</span>-&gt;canonical_names[i];
<a name="l01367"></a>01367       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#af887cf4c56a62f9a6f0600a977c83551">suffix</a> != NULL);
<a name="l01368"></a>01368       item = &amp;items[i];
<a name="l01369"></a>01369 
<a name="l01370"></a>01370       item-&gt;<a class="code" href="structdecode__line__2__item.html#a2c87cc360cb4cc2a6be3bc6204e358b5">fullform</a> = <a class="code" href="linespec_8c.html#a50bd140e1fe59992e5764224d3eba108">canonical_to_fullform</a> (canonical);
<a name="l01371"></a>01371       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, item-&gt;<a class="code" href="structdecode__line__2__item.html#a2c87cc360cb4cc2a6be3bc6204e358b5">fullform</a>);
<a name="l01372"></a>01372 
<a name="l01373"></a>01373       <span class="keywordflow">if</span> (canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#a7c67cdfe1ea5e98d5c6da45107625f05">symtab</a> == NULL)
<a name="l01374"></a>01374         item-&gt;<a class="code" href="structdecode__line__2__item.html#a4779821b460fe454b31902deb6288476">displayform</a> = canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#af887cf4c56a62f9a6f0600a977c83551">suffix</a>;
<a name="l01375"></a>01375       <span class="keywordflow">else</span>
<a name="l01376"></a>01376         {
<a name="l01377"></a>01377           <span class="keyword">const</span> <span class="keywordtype">char</span> *fn_for_display;
<a name="l01378"></a>01378 
<a name="l01379"></a>01379           fn_for_display = <a class="code" href="source_8c.html#ae251616cab166301d5fed95cbdd31232">symtab_to_filename_for_display</a> (canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#a7c67cdfe1ea5e98d5c6da45107625f05">symtab</a>);
<a name="l01380"></a>01380           item-&gt;<a class="code" href="structdecode__line__2__item.html#a4779821b460fe454b31902deb6288476">displayform</a> = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;%s:%s&quot;</span>, fn_for_display,
<a name="l01381"></a>01381                                           canonical-&gt;<a class="code" href="structlinespec__canonical__name.html#af887cf4c56a62f9a6f0600a977c83551">suffix</a>);
<a name="l01382"></a>01382           <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, item-&gt;<a class="code" href="structdecode__line__2__item.html#a4779821b460fe454b31902deb6288476">displayform</a>);
<a name="l01383"></a>01383         }
<a name="l01384"></a>01384 
<a name="l01385"></a>01385       item-&gt;<a class="code" href="structdecode__line__2__item.html#a66d032ece52b090a24f482a036aff4eb">selected</a> = 0;
<a name="l01386"></a>01386     }
<a name="l01387"></a>01387 
<a name="l01388"></a>01388   <span class="comment">/* Sort the list of method names.  */</span>
<a name="l01389"></a>01389   <a class="code" href="ada-exp_8c.html#a849e2297facde4d3c80dc4f45f8abbdb">qsort</a> (items, items_count, <span class="keyword">sizeof</span> (*items), <a class="code" href="linespec_8c.html#afb2f265ab21985491efdf0020a3bffa0">decode_line_2_compare_items</a>);
<a name="l01390"></a>01390 
<a name="l01391"></a>01391   <span class="comment">/* Remove entries with the same FULLFORM.  */</span>
<a name="l01392"></a>01392   <span class="keywordflow">if</span> (items_count &gt;= 2)
<a name="l01393"></a>01393     {
<a name="l01394"></a>01394       <span class="keyword">struct </span><a class="code" href="structdecode__line__2__item.html">decode_line_2_item</a> *dst, *src;
<a name="l01395"></a>01395 
<a name="l01396"></a>01396       dst = items;
<a name="l01397"></a>01397       <span class="keywordflow">for</span> (src = &amp;items[1]; src &lt; &amp;items[items_count]; src++)
<a name="l01398"></a>01398         <span class="keywordflow">if</span> (strcmp (src-&gt;<a class="code" href="structdecode__line__2__item.html#a2c87cc360cb4cc2a6be3bc6204e358b5">fullform</a>, dst-&gt;<a class="code" href="structdecode__line__2__item.html#a2c87cc360cb4cc2a6be3bc6204e358b5">fullform</a>) != 0)
<a name="l01399"></a>01399           *++dst = *src;
<a name="l01400"></a>01400       items_count = dst + 1 - items;
<a name="l01401"></a>01401     }
<a name="l01402"></a>01402 
<a name="l01403"></a>01403   <span class="keywordflow">if</span> (select_mode == <a class="code" href="symtab_8c.html#a5a9b380bd1851dbd78165e00514e2b64">multiple_symbols_cancel</a> &amp;&amp; items_count &gt; 1)
<a name="l01404"></a>01404     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;canceled because the command is ambiguous\n&quot;</span>
<a name="l01405"></a>01405              <span class="stringliteral">&quot;See set/show multiple-symbol.&quot;</span>));
<a name="l01406"></a>01406   
<a name="l01407"></a>01407   <span class="keywordflow">if</span> (select_mode == <a class="code" href="symtab_8c.html#a2457c524e394ad239661c86ceedb99a7">multiple_symbols_all</a> || items_count == 1)
<a name="l01408"></a>01408     {
<a name="l01409"></a>01409       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l01410"></a>01410       <a class="code" href="linespec_8c.html#a2379614f47a369c0c1e4f7d4ba874994">convert_results_to_lsals</a> (<span class="keyword">self</span>, result);
<a name="l01411"></a>01411       <span class="keywordflow">return</span>;
<a name="l01412"></a>01412     }
<a name="l01413"></a>01413 
<a name="l01414"></a>01414   <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;[0] cancel\n[1] all\n&quot;</span>));
<a name="l01415"></a>01415   <span class="keywordflow">for</span> (i = 0; i &lt; items_count; i++)
<a name="l01416"></a>01416     <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<span class="stringliteral">&quot;[%d] %s\n&quot;</span>, i + 2, items[i].<a class="code" href="structdecode__line__2__item.html#a4779821b460fe454b31902deb6288476">displayform</a>);
<a name="l01417"></a>01417 
<a name="l01418"></a>01418   prompt = getenv (<span class="stringliteral">&quot;PS2&quot;</span>);
<a name="l01419"></a>01419   <span class="keywordflow">if</span> (prompt == NULL)
<a name="l01420"></a>01420     {
<a name="l01421"></a>01421       prompt = <span class="stringliteral">&quot;&gt; &quot;</span>;
<a name="l01422"></a>01422     }
<a name="l01423"></a>01423   args = <a class="code" href="defs_8h.html#a06b7acf2ace3fbf28f5873e57eb39376">command_line_input</a> (prompt, 0, <span class="stringliteral">&quot;overload-choice&quot;</span>);
<a name="l01424"></a>01424 
<a name="l01425"></a>01425   <span class="keywordflow">if</span> (args == 0 || *args == 0)
<a name="l01426"></a>01426     <a class="code" href="cli-cmds_8c.html#a68aef78cdf72abc9df2495a4618842c3">error_no_arg</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;one or more choice numbers&quot;</span>));
<a name="l01427"></a>01427 
<a name="l01428"></a>01428   <a class="code" href="cli-utils_8c.html#a8c5a78ced74fbfc685ab08664c47fa9b">init_number_or_range</a> (&amp;state, args);
<a name="l01429"></a>01429   <span class="keywordflow">while</span> (!state.<a class="code" href="structget__number__or__range__state.html#a24a05f99ac52490b580655f2d97238e6">finished</a>)
<a name="l01430"></a>01430     {
<a name="l01431"></a>01431       <span class="keywordtype">int</span> num;
<a name="l01432"></a>01432 
<a name="l01433"></a>01433       num = <a class="code" href="cli-utils_8c.html#a6d6bbeb272a5fb5ac91e7e2a20e54fef">get_number_or_range</a> (&amp;state);
<a name="l01434"></a>01434 
<a name="l01435"></a>01435       <span class="keywordflow">if</span> (num == 0)
<a name="l01436"></a>01436         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;canceled&quot;</span>));
<a name="l01437"></a>01437       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (num == 1)
<a name="l01438"></a>01438         {
<a name="l01439"></a>01439           <span class="comment">/* We intentionally make this result in a single breakpoint,</span>
<a name="l01440"></a>01440 <span class="comment">             contrary to what older versions of gdb did.  The</span>
<a name="l01441"></a>01441 <span class="comment">             rationale is that this lets a user get the</span>
<a name="l01442"></a>01442 <span class="comment">             multiple_symbols_all behavior even with the &#39;ask&#39;</span>
<a name="l01443"></a>01443 <span class="comment">             setting; and he can get separate breakpoints by entering</span>
<a name="l01444"></a>01444 <span class="comment">             &quot;2-57&quot; at the query.  */</span>
<a name="l01445"></a>01445           <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l01446"></a>01446           <a class="code" href="linespec_8c.html#a2379614f47a369c0c1e4f7d4ba874994">convert_results_to_lsals</a> (<span class="keyword">self</span>, result);
<a name="l01447"></a>01447           <span class="keywordflow">return</span>;
<a name="l01448"></a>01448         }
<a name="l01449"></a>01449 
<a name="l01450"></a>01450       num -= 2;
<a name="l01451"></a>01451       <span class="keywordflow">if</span> (num &gt;= items_count)
<a name="l01452"></a>01452         <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No choice number %d.\n&quot;</span>), num);
<a name="l01453"></a>01453       <span class="keywordflow">else</span>
<a name="l01454"></a>01454         {
<a name="l01455"></a>01455           <span class="keyword">struct </span><a class="code" href="structdecode__line__2__item.html">decode_line_2_item</a> *item = &amp;items[num];
<a name="l01456"></a>01456 
<a name="l01457"></a>01457           <span class="keywordflow">if</span> (!item-&gt;<a class="code" href="structdecode__line__2__item.html#a66d032ece52b090a24f482a036aff4eb">selected</a>)
<a name="l01458"></a>01458             {
<a name="l01459"></a>01459               <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>, filters, item-&gt;<a class="code" href="structdecode__line__2__item.html#a2c87cc360cb4cc2a6be3bc6204e358b5">fullform</a>);
<a name="l01460"></a>01460               item-&gt;<a class="code" href="structdecode__line__2__item.html#a66d032ece52b090a24f482a036aff4eb">selected</a> = 1;
<a name="l01461"></a>01461             }
<a name="l01462"></a>01462           <span class="keywordflow">else</span>
<a name="l01463"></a>01463             {
<a name="l01464"></a>01464               <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;duplicate request for %d ignored.\n&quot;</span>),
<a name="l01465"></a>01465                                  num + 2);
<a name="l01466"></a>01466             }
<a name="l01467"></a>01467         }
<a name="l01468"></a>01468     }
<a name="l01469"></a>01469 
<a name="l01470"></a>01470   <a class="code" href="linespec_8c.html#ab7f5c5cf59e14b6816cdd59fedc94ef5">filter_results</a> (<span class="keyword">self</span>, result, filters);
<a name="l01471"></a>01471   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l01472"></a>01472 }
<a name="l01473"></a>01473 
<a name="l01474"></a>01474 
<a name="l01475"></a>01475 
<a name="l01476"></a>01476 <span class="comment">/* The parser of linespec itself.  */</span>
<a name="l01477"></a>01477 
<a name="l01478"></a>01478 <span class="comment">/* Throw an appropriate error when SYMBOL is not found (optionally in</span>
<a name="l01479"></a>01479 <span class="comment">   FILENAME).  */</span>
<a name="l01480"></a>01480 
<a name="l01481"></a>01481 <span class="keyword">static</span> <span class="keywordtype">void</span> ATTRIBUTE_NORETURN
<a name="l01482"></a><a class="code" href="linespec_8c.html#ac64f473cb06cc9077d8c88eca441d4e6">01482</a> <a class="code" href="linespec_8c.html#ac64f473cb06cc9077d8c88eca441d4e6">symbol_not_found_error</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structsymbol.html">symbol</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *filename)
<a name="l01483"></a>01483 {
<a name="l01484"></a>01484   <span class="keywordflow">if</span> (symbol == NULL)
<a name="l01485"></a>01485     symbol = <span class="stringliteral">&quot;&quot;</span>;
<a name="l01486"></a>01486 
<a name="l01487"></a>01487   <span class="keywordflow">if</span> (!<a class="code" href="objfiles_8c.html#aed27a8abad788fa9b74e13a3bb97c8ee">have_full_symbols</a> ()
<a name="l01488"></a>01488       &amp;&amp; !<a class="code" href="objfiles_8c.html#aa8d7d1a2b68ac871a50d0fcbca14518d">have_partial_symbols</a> ()
<a name="l01489"></a>01489       &amp;&amp; !<a class="code" href="objfiles_8c.html#a590d3dc440408316d16718d09a81c907">have_minimal_symbols</a> ())
<a name="l01490"></a>01490     <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>,
<a name="l01491"></a>01491                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No symbol table is loaded.  Use the \&quot;file\&quot; command.&quot;</span>));
<a name="l01492"></a>01492 
<a name="l01493"></a>01493   <span class="comment">/* If SYMBOL starts with &#39;$&#39;, the user attempted to either lookup</span>
<a name="l01494"></a>01494 <span class="comment">     a function/variable in his code starting with &#39;$&#39; or an internal</span>
<a name="l01495"></a>01495 <span class="comment">     variable of that name.  Since we do not know which, be concise and</span>
<a name="l01496"></a>01496 <span class="comment">     explain both possibilities.  */</span>
<a name="l01497"></a>01497   <span class="keywordflow">if</span> (*symbol == <span class="charliteral">&#39;$&#39;</span>)
<a name="l01498"></a>01498     {
<a name="l01499"></a>01499       <span class="keywordflow">if</span> (filename)
<a name="l01500"></a>01500         <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>,
<a name="l01501"></a>01501                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Undefined convenience variable or function \&quot;%s\&quot; &quot;</span>
<a name="l01502"></a>01502                        <span class="stringliteral">&quot;not defined in \&quot;%s\&quot;.&quot;</span>), symbol, filename);
<a name="l01503"></a>01503       <span class="keywordflow">else</span>
<a name="l01504"></a>01504         <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>,
<a name="l01505"></a>01505                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Undefined convenience variable or function \&quot;%s\&quot; &quot;</span>
<a name="l01506"></a>01506                        <span class="stringliteral">&quot;not defined.&quot;</span>), symbol);
<a name="l01507"></a>01507     }
<a name="l01508"></a>01508   <span class="keywordflow">else</span>
<a name="l01509"></a>01509     {
<a name="l01510"></a>01510       <span class="keywordflow">if</span> (filename)
<a name="l01511"></a>01511         <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>,
<a name="l01512"></a>01512                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Function \&quot;%s\&quot; not defined in \&quot;%s\&quot;.&quot;</span>),
<a name="l01513"></a>01513                      symbol, filename);
<a name="l01514"></a>01514       <span class="keywordflow">else</span>
<a name="l01515"></a>01515         <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>,
<a name="l01516"></a>01516                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Function \&quot;%s\&quot; not defined.&quot;</span>), symbol);
<a name="l01517"></a>01517     }
<a name="l01518"></a>01518 }
<a name="l01519"></a>01519 
<a name="l01520"></a>01520 <span class="comment">/* Throw an appropriate error when an unexpected token is encountered </span>
<a name="l01521"></a>01521 <span class="comment">   in the input.  */</span>
<a name="l01522"></a>01522 
<a name="l01523"></a>01523 <span class="keyword">static</span> <span class="keywordtype">void</span> ATTRIBUTE_NORETURN
<a name="l01524"></a><a class="code" href="linespec_8c.html#a6cad0d21e3b8c050e7e79b0fa97b55e7">01524</a> <a class="code" href="linespec_8c.html#a6cad0d21e3b8c050e7e79b0fa97b55e7">unexpected_linespec_error</a> (<a class="code" href="structls__parser.html">linespec_parser</a> *parser)
<a name="l01525"></a>01525 {
<a name="l01526"></a>01526   <a class="code" href="structls__token.html">linespec_token</a> <a class="code" href="m2-exp_8c.html#a8abb7e972adc09624edab301e021dc5f">token</a>;
<a name="l01527"></a>01527   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * token_type_strings[]
<a name="l01528"></a>01528     = {<span class="stringliteral">&quot;keyword&quot;</span>, <span class="stringliteral">&quot;colon&quot;</span>, <span class="stringliteral">&quot;string&quot;</span>, <span class="stringliteral">&quot;number&quot;</span>, <span class="stringliteral">&quot;comma&quot;</span>, <span class="stringliteral">&quot;end of input&quot;</span>};
<a name="l01529"></a>01529 
<a name="l01530"></a>01530   <span class="comment">/* Get the token that generated the error.  */</span>
<a name="l01531"></a>01531   token = <a class="code" href="linespec_8c.html#ad98a478ce9c21319c2940cc23479d49b">linespec_lexer_lex_one</a> (parser);
<a name="l01532"></a>01532 
<a name="l01533"></a>01533   <span class="comment">/* Finally, throw the error.  */</span>
<a name="l01534"></a>01534   <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af51514ff45b95b314eb23812fb75def7">LSTOKEN_STRING</a> || token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af5166818bc2e7c7262ab4913a8abd253">LSTOKEN_NUMBER</a>
<a name="l01535"></a>01535       || token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af8a55ade50678c246a4af428c016dee6">LSTOKEN_KEYWORD</a>)
<a name="l01536"></a>01536     {
<a name="l01537"></a>01537       <span class="keywordtype">char</span> *<a class="code" href="signals_8c.html#ae1adbce218e7a9d09164012443191d24">string</a>;
<a name="l01538"></a>01538       <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l01539"></a>01539 
<a name="l01540"></a>01540       <span class="keywordtype">string</span> = <a class="code" href="linespec_8c.html#a554b65b8cc0063ed9adf3e04294253e6">copy_token_string</a> (token);
<a name="l01541"></a>01541       cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, <span class="keywordtype">string</span>);
<a name="l01542"></a>01542       <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a9bcb544a32281727d57f35dec7d49e78">GENERIC_ERROR</a>,
<a name="l01543"></a>01543                    <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;malformed linespec error: unexpected %s, \&quot;%s\&quot;&quot;</span>),
<a name="l01544"></a>01544                    token_type_strings[token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a>], <span class="keywordtype">string</span>);
<a name="l01545"></a>01545     }
<a name="l01546"></a>01546   <span class="keywordflow">else</span>
<a name="l01547"></a>01547     <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a9bcb544a32281727d57f35dec7d49e78">GENERIC_ERROR</a>,
<a name="l01548"></a>01548                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;malformed linespec error: unexpected %s&quot;</span>),
<a name="l01549"></a>01549                  token_type_strings[token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a>]);
<a name="l01550"></a>01550 }
<a name="l01551"></a>01551 
<a name="l01552"></a>01552 <span class="comment">/* Parse and return a line offset in STRING.  */</span>
<a name="l01553"></a>01553 
<a name="l01554"></a>01554 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structline__offset.html">line_offset</a>
<a name="l01555"></a><a class="code" href="linespec_8c.html#a3973a3c5bdb3b8717a0624038fa51aaa">01555</a> <a class="code" href="linespec_8c.html#a3973a3c5bdb3b8717a0624038fa51aaa">linespec_parse_line_offset</a> (<a class="code" href="p-lang_8h.html#a21296fc6f36ba2fc4d9780fdd126acb5">const</a> char *<a class="code" href="signals_8c.html#ae1adbce218e7a9d09164012443191d24">string</a>)
<a name="l01556"></a>01556 {
<a name="l01557"></a>01557   <span class="keyword">struct </span><a class="code" href="structline__offset.html">line_offset</a> line_offset = {0, <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a6476a4ac46c8b156670deb1f9094a206">LINE_OFFSET_NONE</a>};
<a name="l01558"></a>01558 
<a name="l01559"></a>01559   <span class="keywordflow">if</span> (*<span class="keywordtype">string</span> == <span class="charliteral">&#39;+&#39;</span>)
<a name="l01560"></a>01560     {
<a name="l01561"></a>01561       line_offset.<a class="code" href="structline__offset.html#a472435e8559e52f51621869a9dc9f927">sign</a> = <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a372071bffc263af1039dc02745e0af39">LINE_OFFSET_PLUS</a>;
<a name="l01562"></a>01562       ++<a class="code" href="signals_8c.html#ae1adbce218e7a9d09164012443191d24">string</a>;
<a name="l01563"></a>01563     }
<a name="l01564"></a>01564   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*<span class="keywordtype">string</span> == <span class="charliteral">&#39;-&#39;</span>)
<a name="l01565"></a>01565     {
<a name="l01566"></a>01566       line_offset.<a class="code" href="structline__offset.html#a472435e8559e52f51621869a9dc9f927">sign</a> = <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a0785984972ad861764f36548801c2152">LINE_OFFSET_MINUS</a>;
<a name="l01567"></a>01567       ++<a class="code" href="signals_8c.html#ae1adbce218e7a9d09164012443191d24">string</a>;
<a name="l01568"></a>01568     }
<a name="l01569"></a>01569 
<a name="l01570"></a>01570   <span class="comment">/* Right now, we only allow base 10 for offsets.  */</span>
<a name="l01571"></a>01571   line_offset.<a class="code" href="structline__offset.html#a67b3ef5291f38b482121139dc421a84f">offset</a> = atoi (<span class="keywordtype">string</span>);
<a name="l01572"></a>01572   <span class="keywordflow">return</span> line_offset;
<a name="l01573"></a>01573 }
<a name="l01574"></a>01574 
<a name="l01575"></a>01575 <span class="comment">/* Parse the basic_spec in PARSER&#39;s input.  */</span>
<a name="l01576"></a>01576 
<a name="l01577"></a>01577 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01578"></a><a class="code" href="linespec_8c.html#a6f7fbf2443a4ca7b0af65db4bbbfcde2">01578</a> <a class="code" href="linespec_8c.html#a6f7fbf2443a4ca7b0af65db4bbbfcde2">linespec_parse_basic</a> (<a class="code" href="structls__parser.html">linespec_parser</a> *parser)
<a name="l01579"></a>01579 {
<a name="l01580"></a>01580   <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01581"></a>01581   <a class="code" href="structls__token.html">linespec_token</a> <a class="code" href="m2-exp_8c.html#a8abb7e972adc09624edab301e021dc5f">token</a>;
<a name="l01582"></a>01582   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) *symbols, *labels;
<a name="l01583"></a>01583   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>) *minimal_symbols;
<a name="l01584"></a>01584   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l01585"></a>01585 
<a name="l01586"></a>01586   <span class="comment">/* Get the next token.  */</span>
<a name="l01587"></a>01587   token = <a class="code" href="linespec_8c.html#ad98a478ce9c21319c2940cc23479d49b">linespec_lexer_lex_one</a> (parser);
<a name="l01588"></a>01588 
<a name="l01589"></a>01589   <span class="comment">/* If it is EOI or KEYWORD, issue an error.  */</span>
<a name="l01590"></a>01590   <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af8a55ade50678c246a4af428c016dee6">LSTOKEN_KEYWORD</a> || token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a9d5032c178932f2ba5e3c30763b2ef47">LSTOKEN_EOI</a>)
<a name="l01591"></a>01591     <a class="code" href="linespec_8c.html#a6cad0d21e3b8c050e7e79b0fa97b55e7">unexpected_linespec_error</a> (parser);
<a name="l01592"></a>01592   <span class="comment">/* If it is a LSTOKEN_NUMBER, we have an offset.  */</span>
<a name="l01593"></a>01593   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af5166818bc2e7c7262ab4913a8abd253">LSTOKEN_NUMBER</a>)
<a name="l01594"></a>01594     {
<a name="l01595"></a>01595       <span class="comment">/* Record the line offset and get the next token.  */</span>
<a name="l01596"></a>01596       name = <a class="code" href="linespec_8c.html#a554b65b8cc0063ed9adf3e04294253e6">copy_token_string</a> (token);
<a name="l01597"></a>01597       cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, name);
<a name="l01598"></a>01598       <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;line_offset = <a class="code" href="linespec_8c.html#a3973a3c5bdb3b8717a0624038fa51aaa">linespec_parse_line_offset</a> (name);
<a name="l01599"></a>01599       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l01600"></a>01600 
<a name="l01601"></a>01601       <span class="comment">/* Get the next token.  */</span>
<a name="l01602"></a>01602       token = <a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">linespec_lexer_consume_token</a> (parser);
<a name="l01603"></a>01603 
<a name="l01604"></a>01604       <span class="comment">/* If the next token is a comma, stop parsing and return.  */</span>
<a name="l01605"></a>01605       <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3ab831810c44c39dc484a828d6d141bade">LSTOKEN_COMMA</a>)
<a name="l01606"></a>01606         <span class="keywordflow">return</span>;
<a name="l01607"></a>01607 
<a name="l01608"></a>01608       <span class="comment">/* If the next token is anything but EOI or KEYWORD, issue</span>
<a name="l01609"></a>01609 <span class="comment">         an error.  */</span>
<a name="l01610"></a>01610       <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> != <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af8a55ade50678c246a4af428c016dee6">LSTOKEN_KEYWORD</a> &amp;&amp; token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> != <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a9d5032c178932f2ba5e3c30763b2ef47">LSTOKEN_EOI</a>)
<a name="l01611"></a>01611         <a class="code" href="linespec_8c.html#a6cad0d21e3b8c050e7e79b0fa97b55e7">unexpected_linespec_error</a> (parser);
<a name="l01612"></a>01612     }
<a name="l01613"></a>01613 
<a name="l01614"></a>01614   <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af8a55ade50678c246a4af428c016dee6">LSTOKEN_KEYWORD</a> || token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a9d5032c178932f2ba5e3c30763b2ef47">LSTOKEN_EOI</a>)
<a name="l01615"></a>01615     <span class="keywordflow">return</span>;
<a name="l01616"></a>01616 
<a name="l01617"></a>01617   <span class="comment">/* Next token must be LSTOKEN_STRING.  */</span>
<a name="l01618"></a>01618   <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> != <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af51514ff45b95b314eb23812fb75def7">LSTOKEN_STRING</a>)
<a name="l01619"></a>01619     <a class="code" href="linespec_8c.html#a6cad0d21e3b8c050e7e79b0fa97b55e7">unexpected_linespec_error</a> (parser);
<a name="l01620"></a>01620 
<a name="l01621"></a>01621   <span class="comment">/* The current token will contain the name of a function, method,</span>
<a name="l01622"></a>01622 <span class="comment">     or label.  */</span>
<a name="l01623"></a>01623   name  = <a class="code" href="linespec_8c.html#a554b65b8cc0063ed9adf3e04294253e6">copy_token_string</a> (token);
<a name="l01624"></a>01624   cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, name);
<a name="l01625"></a>01625 
<a name="l01626"></a>01626   <span class="comment">/* Try looking it up as a function/method.  */</span>
<a name="l01627"></a>01627   <a class="code" href="linespec_8c.html#aade11e4b850f57d619e2c4f2a841942f">find_linespec_symbols</a> (<a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">PARSER_STATE</a> (parser),
<a name="l01628"></a>01628                          <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;file_symtabs, name,
<a name="l01629"></a>01629                          &amp;symbols, &amp;minimal_symbols);
<a name="l01630"></a>01630 
<a name="l01631"></a>01631   <span class="keywordflow">if</span> (symbols != NULL || minimal_symbols != NULL)
<a name="l01632"></a>01632     {
<a name="l01633"></a>01633       <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;function_symbols = symbols;
<a name="l01634"></a>01634       <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;minimal_symbols = minimal_symbols;
<a name="l01635"></a>01635       <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;function_name = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01636"></a>01636       symbols = NULL;
<a name="l01637"></a>01637       <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (cleanup);
<a name="l01638"></a>01638     }
<a name="l01639"></a>01639   <span class="keywordflow">else</span>
<a name="l01640"></a>01640     {
<a name="l01641"></a>01641       <span class="comment">/* NAME was not a function or a method.  So it must be a label</span>
<a name="l01642"></a>01642 <span class="comment">         name or user specified variable like &quot;break foo.c:$zippo&quot;.  */</span>
<a name="l01643"></a>01643       labels = find_label_symbols (<a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">PARSER_STATE</a> (parser), NULL,
<a name="l01644"></a>01644                                    &amp;symbols, name);
<a name="l01645"></a>01645       <span class="keywordflow">if</span> (labels != NULL)
<a name="l01646"></a>01646         {
<a name="l01647"></a>01647           <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;labels.label_symbols = labels;
<a name="l01648"></a>01648           <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;labels.function_symbols = symbols;
<a name="l01649"></a>01649           <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;label_name = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01650"></a>01650           symbols = NULL;
<a name="l01651"></a>01651           <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (cleanup);
<a name="l01652"></a>01652         }
<a name="l01653"></a>01653       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af51514ff45b95b314eb23812fb75def7">LSTOKEN_STRING</a>
<a name="l01654"></a>01654                &amp;&amp; *<a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).ptr == <span class="charliteral">&#39;$&#39;</span>)
<a name="l01655"></a>01655         {
<a name="l01656"></a>01656           <span class="comment">/* User specified a convenience variable or history value.  */</span>
<a name="l01657"></a>01657           <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;line_offset
<a name="l01658"></a>01658             = <a class="code" href="linespec_8c.html#a4f9761a36dffbb858aa4123c570964fe">linespec_parse_variable</a> (<a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">PARSER_STATE</a> (parser), name);
<a name="l01659"></a>01659 
<a name="l01660"></a>01660           <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;<a class="code" href="structline__offset.html">line_offset</a>.<a class="code" href="structline__offset.html#a472435e8559e52f51621869a9dc9f927">sign</a> == <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376abf2fff5ff94b498a10942f7e2b22f251">LINE_OFFSET_UNKNOWN</a>)
<a name="l01661"></a>01661             {
<a name="l01662"></a>01662               <span class="comment">/* The user-specified variable was not valid.  Do not</span>
<a name="l01663"></a>01663 <span class="comment">                 throw an error here.  parse_linespec will do it for us.  */</span>
<a name="l01664"></a>01664               <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;function_name = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01665"></a>01665               <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (cleanup);
<a name="l01666"></a>01666               <span class="keywordflow">return</span>;
<a name="l01667"></a>01667             }
<a name="l01668"></a>01668         }
<a name="l01669"></a>01669       <span class="keywordflow">else</span>
<a name="l01670"></a>01670         {
<a name="l01671"></a>01671           <span class="comment">/* The name is also not a label.  Abort parsing.  Do not throw</span>
<a name="l01672"></a>01672 <span class="comment">             an error here.  parse_linespec will do it for us.  */</span>
<a name="l01673"></a>01673 
<a name="l01674"></a>01674           <span class="comment">/* Save a copy of the name we were trying to lookup.  */</span>
<a name="l01675"></a>01675           <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;function_name = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01676"></a>01676           <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (cleanup);
<a name="l01677"></a>01677           <span class="keywordflow">return</span>;
<a name="l01678"></a>01678         }
<a name="l01679"></a>01679     }
<a name="l01680"></a>01680 
<a name="l01681"></a>01681   <span class="comment">/* Get the next token.  */</span>
<a name="l01682"></a>01682   token = <a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">linespec_lexer_consume_token</a> (parser);
<a name="l01683"></a>01683 
<a name="l01684"></a>01684   <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a64e5ca29e811888826b7231415dcb1fa">LSTOKEN_COLON</a>)
<a name="l01685"></a>01685     {
<a name="l01686"></a>01686       <span class="comment">/* User specified a label or a lineno.  */</span>
<a name="l01687"></a>01687       token = <a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">linespec_lexer_consume_token</a> (parser);
<a name="l01688"></a>01688 
<a name="l01689"></a>01689       <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af5166818bc2e7c7262ab4913a8abd253">LSTOKEN_NUMBER</a>)
<a name="l01690"></a>01690         {
<a name="l01691"></a>01691           <span class="comment">/* User specified an offset.  Record the line offset and</span>
<a name="l01692"></a>01692 <span class="comment">             get the next token.  */</span>
<a name="l01693"></a>01693           name = <a class="code" href="linespec_8c.html#a554b65b8cc0063ed9adf3e04294253e6">copy_token_string</a> (token);
<a name="l01694"></a>01694           cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, name);
<a name="l01695"></a>01695           <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;line_offset
<a name="l01696"></a>01696             = <a class="code" href="linespec_8c.html#a3973a3c5bdb3b8717a0624038fa51aaa">linespec_parse_line_offset</a> (name);
<a name="l01697"></a>01697           <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l01698"></a>01698 
<a name="l01699"></a>01699           <span class="comment">/* Ge the next token.  */</span>
<a name="l01700"></a>01700           token = <a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">linespec_lexer_consume_token</a> (parser);
<a name="l01701"></a>01701         }
<a name="l01702"></a>01702       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af51514ff45b95b314eb23812fb75def7">LSTOKEN_STRING</a>)
<a name="l01703"></a>01703         {
<a name="l01704"></a>01704           <span class="comment">/* Grab a copy of the label&#39;s name and look it up.  */</span>
<a name="l01705"></a>01705           name = <a class="code" href="linespec_8c.html#a554b65b8cc0063ed9adf3e04294253e6">copy_token_string</a> (token);
<a name="l01706"></a>01706           cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, name);
<a name="l01707"></a>01707           labels = find_label_symbols (<a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">PARSER_STATE</a> (parser),
<a name="l01708"></a>01708                                        <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;function_symbols,
<a name="l01709"></a>01709                                        &amp;symbols, name);
<a name="l01710"></a>01710 
<a name="l01711"></a>01711           <span class="keywordflow">if</span> (labels != NULL)
<a name="l01712"></a>01712             {
<a name="l01713"></a>01713               <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;labels.label_symbols = labels;
<a name="l01714"></a>01714               <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;labels.function_symbols = symbols;
<a name="l01715"></a>01715               <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;label_name = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01716"></a>01716               symbols = NULL;
<a name="l01717"></a>01717               <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (cleanup);
<a name="l01718"></a>01718             }
<a name="l01719"></a>01719           <span class="keywordflow">else</span>
<a name="l01720"></a>01720             {
<a name="l01721"></a>01721               <span class="comment">/* We don&#39;t know what it was, but it isn&#39;t a label.  */</span>
<a name="l01722"></a>01722               <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>,
<a name="l01723"></a>01723                            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No label \&quot;%s\&quot; defined in function \&quot;%s\&quot;.&quot;</span>),
<a name="l01724"></a>01724                            name, <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;function_name);
<a name="l01725"></a>01725             }
<a name="l01726"></a>01726 
<a name="l01727"></a>01727           <span class="comment">/* Check for a line offset.  */</span>
<a name="l01728"></a>01728           token = <a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">linespec_lexer_consume_token</a> (parser);
<a name="l01729"></a>01729           <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a64e5ca29e811888826b7231415dcb1fa">LSTOKEN_COLON</a>)
<a name="l01730"></a>01730             {
<a name="l01731"></a>01731               <span class="comment">/* Get the next token.  */</span>
<a name="l01732"></a>01732               token = <a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">linespec_lexer_consume_token</a> (parser);
<a name="l01733"></a>01733 
<a name="l01734"></a>01734               <span class="comment">/* It must be a line offset.  */</span>
<a name="l01735"></a>01735               <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> != <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af5166818bc2e7c7262ab4913a8abd253">LSTOKEN_NUMBER</a>)
<a name="l01736"></a>01736                 <a class="code" href="linespec_8c.html#a6cad0d21e3b8c050e7e79b0fa97b55e7">unexpected_linespec_error</a> (parser);
<a name="l01737"></a>01737 
<a name="l01738"></a>01738               <span class="comment">/* Record the lione offset and get the next token.  */</span>
<a name="l01739"></a>01739               name = <a class="code" href="linespec_8c.html#a554b65b8cc0063ed9adf3e04294253e6">copy_token_string</a> (token);
<a name="l01740"></a>01740               cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, name);
<a name="l01741"></a>01741 
<a name="l01742"></a>01742               <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;line_offset
<a name="l01743"></a>01743                 = <a class="code" href="linespec_8c.html#a3973a3c5bdb3b8717a0624038fa51aaa">linespec_parse_line_offset</a> (name);
<a name="l01744"></a>01744               <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l01745"></a>01745 
<a name="l01746"></a>01746               <span class="comment">/* Get the next token.  */</span>
<a name="l01747"></a>01747               token = <a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">linespec_lexer_consume_token</a> (parser);
<a name="l01748"></a>01748             }
<a name="l01749"></a>01749         }
<a name="l01750"></a>01750       <span class="keywordflow">else</span>
<a name="l01751"></a>01751         {
<a name="l01752"></a>01752           <span class="comment">/* Trailing &#39;:&#39; in the input. Issue an error.  */</span>
<a name="l01753"></a>01753           <a class="code" href="linespec_8c.html#a6cad0d21e3b8c050e7e79b0fa97b55e7">unexpected_linespec_error</a> (parser);
<a name="l01754"></a>01754         }
<a name="l01755"></a>01755     }
<a name="l01756"></a>01756 }
<a name="l01757"></a>01757 
<a name="l01758"></a>01758 <span class="comment">/* Canonicalize the linespec contained in LS.  The result is saved into</span>
<a name="l01759"></a>01759 <span class="comment">   STATE-&gt;canonical.  */</span>
<a name="l01760"></a>01760 
<a name="l01761"></a>01761 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01762"></a><a class="code" href="linespec_8c.html#ac1a2266cc235a37e8a47a7169e16fc33">01762</a> <a class="code" href="linespec_8c.html#ac1a2266cc235a37e8a47a7169e16fc33">canonicalize_linespec</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *state, linespec_p ls)
<a name="l01763"></a>01763 {
<a name="l01764"></a>01764   <span class="comment">/* If canonicalization was not requested, no need to do anything.  */</span>
<a name="l01765"></a>01765   <span class="keywordflow">if</span> (!state-&gt;<a class="code" href="structlinespec__state.html#aa126216e414f7a70c7ac6c9231e3cfa5">canonical</a>)
<a name="l01766"></a>01766     <span class="keywordflow">return</span>;
<a name="l01767"></a>01767 
<a name="l01768"></a>01768   <span class="comment">/* Shortcut expressions, which can only appear by themselves.  */</span>
<a name="l01769"></a>01769   <span class="keywordflow">if</span> (ls-&gt;<a class="code" href="structlinespec.html#a6b0c3421dfbb7f24b02cf8f19e52a2a7">expression</a> != NULL)
<a name="l01770"></a>01770     state-&gt;<a class="code" href="structlinespec__state.html#aa126216e414f7a70c7ac6c9231e3cfa5">canonical</a>-&gt;<a class="code" href="structlinespec__result.html#abfccf5d367c072077ac366af4d3f23f9">addr_string</a> = xstrdup (ls-&gt;<a class="code" href="structlinespec.html#a6b0c3421dfbb7f24b02cf8f19e52a2a7">expression</a>);
<a name="l01771"></a>01771   <span class="keywordflow">else</span>
<a name="l01772"></a>01772     {
<a name="l01773"></a>01773       <span class="keyword">struct </span><a class="code" href="structui__file.html">ui_file</a> *buf;
<a name="l01774"></a>01774       <span class="keywordtype">int</span> need_colon = 0;
<a name="l01775"></a>01775 
<a name="l01776"></a>01776       buf = <a class="code" href="ui-file_8c.html#a340771735f105582d314e191a399a45c">mem_fileopen</a> ();
<a name="l01777"></a>01777       <span class="keywordflow">if</span> (ls-&gt;<a class="code" href="structlinespec.html#a2c8cb5e40245987dbe66268f32c1fcb9">source_filename</a>)
<a name="l01778"></a>01778         {
<a name="l01779"></a>01779           <a class="code" href="ui-file_8c.html#aae3b905f888b1dcdce586f77b9554153">fputs_unfiltered</a> (ls-&gt;<a class="code" href="structlinespec.html#a2c8cb5e40245987dbe66268f32c1fcb9">source_filename</a>, buf);
<a name="l01780"></a>01780           need_colon = 1;
<a name="l01781"></a>01781         }
<a name="l01782"></a>01782 
<a name="l01783"></a>01783       <span class="keywordflow">if</span> (ls-&gt;function_name)
<a name="l01784"></a>01784         {
<a name="l01785"></a>01785           <span class="keywordflow">if</span> (need_colon)
<a name="l01786"></a>01786             <a class="code" href="utils_8c.html#ad68fe4a88bf7dc2738de79643ce8f927">fputc_unfiltered</a> (<span class="charliteral">&#39;:&#39;</span>, buf);
<a name="l01787"></a>01787           <a class="code" href="ui-file_8c.html#aae3b905f888b1dcdce586f77b9554153">fputs_unfiltered</a> (ls-&gt;function_name, buf);
<a name="l01788"></a>01788           need_colon = 1;
<a name="l01789"></a>01789         }
<a name="l01790"></a>01790 
<a name="l01791"></a>01791       <span class="keywordflow">if</span> (ls-&gt;label_name)
<a name="l01792"></a>01792         {
<a name="l01793"></a>01793           <span class="keywordflow">if</span> (need_colon)
<a name="l01794"></a>01794             <a class="code" href="utils_8c.html#ad68fe4a88bf7dc2738de79643ce8f927">fputc_unfiltered</a> (<span class="charliteral">&#39;:&#39;</span>, buf);
<a name="l01795"></a>01795 
<a name="l01796"></a>01796           <span class="keywordflow">if</span> (ls-&gt;function_name == NULL)
<a name="l01797"></a>01797             {
<a name="l01798"></a>01798               <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *s;
<a name="l01799"></a>01799 
<a name="l01800"></a>01800               <span class="comment">/* No function was specified, so add the symbol name.  */</span>
<a name="l01801"></a>01801               <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (ls-&gt;<a class="code" href="structlinespec.html#af7e09f841ce15d942352005109a5c4d1">labels</a>.function_symbols != NULL
<a name="l01802"></a>01802                           &amp;&amp; (<a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (symbolp, ls-&gt;<a class="code" href="structlinespec.html#af7e09f841ce15d942352005109a5c4d1">labels</a>.function_symbols)
<a name="l01803"></a>01803                               == 1));
<a name="l01804"></a>01804               s = <a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (symbolp, ls-&gt;<a class="code" href="structlinespec.html#af7e09f841ce15d942352005109a5c4d1">labels</a>.function_symbols, 0);
<a name="l01805"></a>01805               <a class="code" href="ui-file_8c.html#aae3b905f888b1dcdce586f77b9554153">fputs_unfiltered</a> (<a class="code" href="symtab_8h.html#a243e66afa96ff58a851b38f428bb3394">SYMBOL_NATURAL_NAME</a> (s), buf);
<a name="l01806"></a>01806               <a class="code" href="utils_8c.html#ad68fe4a88bf7dc2738de79643ce8f927">fputc_unfiltered</a> (<span class="charliteral">&#39;:&#39;</span>, buf);
<a name="l01807"></a>01807             }
<a name="l01808"></a>01808 
<a name="l01809"></a>01809           <a class="code" href="ui-file_8c.html#aae3b905f888b1dcdce586f77b9554153">fputs_unfiltered</a> (ls-&gt;label_name, buf);
<a name="l01810"></a>01810           need_colon = 1;
<a name="l01811"></a>01811           state-&gt;<a class="code" href="structlinespec__state.html#aa126216e414f7a70c7ac6c9231e3cfa5">canonical</a>-&gt;<a class="code" href="structlinespec__result.html#ae890c0bedee5c8dec0bf977bb4c3b1bc">special_display</a> = 1;
<a name="l01812"></a>01812         }
<a name="l01813"></a>01813 
<a name="l01814"></a>01814       <span class="keywordflow">if</span> (ls-&gt;<a class="code" href="structlinespec.html#a2c94bd09386e673f272cdeabdf4dabe4">line_offset</a>.<a class="code" href="structline__offset.html#a472435e8559e52f51621869a9dc9f927">sign</a> != <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376abf2fff5ff94b498a10942f7e2b22f251">LINE_OFFSET_UNKNOWN</a>)
<a name="l01815"></a>01815         {
<a name="l01816"></a>01816           <span class="keywordflow">if</span> (need_colon)
<a name="l01817"></a>01817             <a class="code" href="utils_8c.html#ad68fe4a88bf7dc2738de79643ce8f927">fputc_unfiltered</a> (<span class="charliteral">&#39;:&#39;</span>, buf);
<a name="l01818"></a>01818           <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (buf, <span class="stringliteral">&quot;%s%d&quot;</span>,
<a name="l01819"></a>01819                             (ls-&gt;<a class="code" href="structlinespec.html#a2c94bd09386e673f272cdeabdf4dabe4">line_offset</a>.<a class="code" href="structline__offset.html#a472435e8559e52f51621869a9dc9f927">sign</a> == <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a6476a4ac46c8b156670deb1f9094a206">LINE_OFFSET_NONE</a> ? <span class="stringliteral">&quot;&quot;</span>
<a name="l01820"></a>01820                              : (ls-&gt;<a class="code" href="structlinespec.html#a2c94bd09386e673f272cdeabdf4dabe4">line_offset</a>.<a class="code" href="structline__offset.html#a472435e8559e52f51621869a9dc9f927">sign</a>
<a name="l01821"></a>01821                                 == <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a372071bffc263af1039dc02745e0af39">LINE_OFFSET_PLUS</a> ? <span class="stringliteral">&quot;+&quot;</span> : <span class="stringliteral">&quot;-&quot;</span>)),
<a name="l01822"></a>01822                             ls-&gt;<a class="code" href="structlinespec.html#a2c94bd09386e673f272cdeabdf4dabe4">line_offset</a>.<a class="code" href="structline__offset.html#a67b3ef5291f38b482121139dc421a84f">offset</a>);
<a name="l01823"></a>01823         }
<a name="l01824"></a>01824 
<a name="l01825"></a>01825       state-&gt;<a class="code" href="structlinespec__state.html#aa126216e414f7a70c7ac6c9231e3cfa5">canonical</a>-&gt;<a class="code" href="structlinespec__result.html#abfccf5d367c072077ac366af4d3f23f9">addr_string</a> = <a class="code" href="ui-file_8c.html#a995485039ce5a1d994a1863cd76a5356">ui_file_xstrdup</a> (buf, NULL);
<a name="l01826"></a>01826       <a class="code" href="ui-file_8c.html#a17fda20af14c0187cbda770d4eb2777b">ui_file_delete</a> (buf);
<a name="l01827"></a>01827     }
<a name="l01828"></a>01828 }
<a name="l01829"></a>01829 
<a name="l01830"></a>01830 <span class="comment">/* Given a line offset in LS, construct the relevant SALs.  */</span>
<a name="l01831"></a>01831 
<a name="l01832"></a>01832 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a>
<a name="l01833"></a><a class="code" href="linespec_8c.html#a6f1574b8b0095c5be71223320bc1045c">01833</a> <a class="code" href="linespec_8c.html#a6f1574b8b0095c5be71223320bc1045c">create_sals_line_offset</a> (struct <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l01834"></a>01834                          linespec_p ls)
<a name="l01835"></a>01835 {
<a name="l01836"></a>01836   <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> values;
<a name="l01837"></a>01837   <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a> val;
<a name="l01838"></a>01838   <span class="keywordtype">int</span> use_default = 0;
<a name="l01839"></a>01839 
<a name="l01840"></a>01840   <a class="code" href="symtab_8c.html#aca3a01a4f0e1a09f99e8308faecc9028">init_sal</a> (&amp;val);
<a name="l01841"></a>01841   values.<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a> = NULL;
<a name="l01842"></a>01842   values.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a> = 0;
<a name="l01843"></a>01843 
<a name="l01844"></a>01844   <span class="comment">/* This is where we need to make sure we have good defaults.</span>
<a name="l01845"></a>01845 <span class="comment">     We must guarantee that this section of code is never executed</span>
<a name="l01846"></a>01846 <span class="comment">     when we are called with just a function name, since</span>
<a name="l01847"></a>01847 <span class="comment">     set_default_source_symtab_and_line uses</span>
<a name="l01848"></a>01848 <span class="comment">     select_source_symtab that calls us with such an argument.  */</span>
<a name="l01849"></a>01849 
<a name="l01850"></a>01850   <span class="keywordflow">if</span> (<a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, ls-&gt;file_symtabs) == 1
<a name="l01851"></a>01851       &amp;&amp; <a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, ls-&gt;file_symtabs, 0) == NULL)
<a name="l01852"></a>01852     {
<a name="l01853"></a>01853       <span class="keyword">const</span> <span class="keywordtype">char</span> *fullname;
<a name="l01854"></a>01854 
<a name="l01855"></a>01855       <a class="code" href="progspace_8c.html#a394457638b3e584a3ecd019df372209f">set_current_program_space</a> (self-&gt;program_space);
<a name="l01856"></a>01856 
<a name="l01857"></a>01857       <span class="comment">/* Make sure we have at least a default source line.  */</span>
<a name="l01858"></a>01858       <a class="code" href="source_8c.html#aa627308b6e6c5de7233b0d4c7017f091">set_default_source_symtab_and_line</a> ();
<a name="l01859"></a>01859       <a class="code" href="linespec_8c.html#a4791ffcdee3b1d956cc1ff1dcdeb2cb4">initialize_defaults</a> (&amp;self-&gt;default_symtab, &amp;self-&gt;default_line);
<a name="l01860"></a>01860       fullname = <a class="code" href="source_8c.html#aa78177718e9d6c01595600975e8254df">symtab_to_fullname</a> (self-&gt;default_symtab);
<a name="l01861"></a>01861       <a class="code" href="vec_8h.html#a0a57ad58141d88d36b1f3229dba6f0e7">VEC_pop</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, ls-&gt;file_symtabs);
<a name="l01862"></a>01862       <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, ls-&gt;file_symtabs);
<a name="l01863"></a>01863       ls-&gt;file_symtabs = collect_symtabs_from_filename (fullname);
<a name="l01864"></a>01864       use_default = 1;
<a name="l01865"></a>01865     }
<a name="l01866"></a>01866 
<a name="l01867"></a>01867   val.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a> = ls-&gt;line_offset.offset;
<a name="l01868"></a>01868   <span class="keywordflow">switch</span> (ls-&gt;line_offset.sign)
<a name="l01869"></a>01869     {
<a name="l01870"></a>01870     <span class="keywordflow">case</span> <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a372071bffc263af1039dc02745e0af39">LINE_OFFSET_PLUS</a>:
<a name="l01871"></a>01871       <span class="keywordflow">if</span> (ls-&gt;line_offset.offset == 0)
<a name="l01872"></a>01872         val.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a> = 5;
<a name="l01873"></a>01873       <span class="keywordflow">if</span> (use_default)
<a name="l01874"></a>01874         val.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a> = <span class="keyword">self</span>-&gt;default_line + val.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a>;
<a name="l01875"></a>01875       <span class="keywordflow">break</span>;
<a name="l01876"></a>01876 
<a name="l01877"></a>01877     <span class="keywordflow">case</span> <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a0785984972ad861764f36548801c2152">LINE_OFFSET_MINUS</a>:
<a name="l01878"></a>01878       <span class="keywordflow">if</span> (ls-&gt;line_offset.offset == 0)
<a name="l01879"></a>01879         val.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a> = 15;
<a name="l01880"></a>01880       <span class="keywordflow">if</span> (use_default)
<a name="l01881"></a>01881         val.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a> = <span class="keyword">self</span>-&gt;default_line - val.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a>;
<a name="l01882"></a>01882       <span class="keywordflow">else</span>
<a name="l01883"></a>01883         val.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a> = -val.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a>;
<a name="l01884"></a>01884       <span class="keywordflow">break</span>;
<a name="l01885"></a>01885 
<a name="l01886"></a>01886     <span class="keywordflow">case</span> <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a6476a4ac46c8b156670deb1f9094a206">LINE_OFFSET_NONE</a>:
<a name="l01887"></a>01887       <span class="keywordflow">break</span>;                    <span class="comment">/* No need to adjust val.line.  */</span>
<a name="l01888"></a>01888     }
<a name="l01889"></a>01889 
<a name="l01890"></a>01890   <span class="keywordflow">if</span> (self-&gt;list_mode)
<a name="l01891"></a>01891     <a class="code" href="linespec_8c.html#a50516c9f4476c1915ea4a16a87e6482a">decode_digits_list_mode</a> (<span class="keyword">self</span>, ls, &amp;values, val);
<a name="l01892"></a>01892   <span class="keywordflow">else</span>
<a name="l01893"></a>01893     {
<a name="l01894"></a>01894       <span class="keyword">struct </span><a class="code" href="structlinetable__entry.html">linetable_entry</a> *<a class="code" href="symtab_8h.html#ac5e7b5c1b729fc27d6717b73d9644f85">best_entry</a> = NULL;
<a name="l01895"></a>01895       <span class="keywordtype">int</span> *filter;
<a name="l01896"></a>01896       <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> **blocks;
<a name="l01897"></a>01897       <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l01898"></a>01898       <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> intermediate_results;
<a name="l01899"></a>01899       <span class="keywordtype">int</span> i, j;
<a name="l01900"></a>01900 
<a name="l01901"></a>01901       intermediate_results.<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a> = NULL;
<a name="l01902"></a>01902       intermediate_results.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a> = 0;
<a name="l01903"></a>01903 
<a name="l01904"></a>01904       <a class="code" href="linespec_8c.html#a27499bc4b74043e033d15c885f16d809">decode_digits_ordinary</a> (<span class="keyword">self</span>, ls, val.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a>, &amp;intermediate_results,
<a name="l01905"></a>01905                               &amp;best_entry);
<a name="l01906"></a>01906       <span class="keywordflow">if</span> (intermediate_results.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a> == 0 &amp;&amp; best_entry != NULL)
<a name="l01907"></a>01907         <a class="code" href="linespec_8c.html#a27499bc4b74043e033d15c885f16d809">decode_digits_ordinary</a> (<span class="keyword">self</span>, ls, best_entry-&gt;<a class="code" href="structlinetable__entry.html#a2419e47c8d007c587b479fc0fea35d4b">line</a>,
<a name="l01908"></a>01908                                 &amp;intermediate_results, &amp;best_entry);
<a name="l01909"></a>01909 
<a name="l01910"></a>01910       cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, intermediate_results.<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a>);
<a name="l01911"></a>01911 
<a name="l01912"></a>01912       <span class="comment">/* For optimized code, the compiler can scatter one source line</span>
<a name="l01913"></a>01913 <span class="comment">         across disjoint ranges of PC values, even when no duplicate</span>
<a name="l01914"></a>01914 <span class="comment">         functions or inline functions are involved.  For example,</span>
<a name="l01915"></a>01915 <span class="comment">         &#39;for (;;)&#39; inside a non-template, non-inline, and non-ctor-or-dtor</span>
<a name="l01916"></a>01916 <span class="comment">         function can result in two PC ranges.  In this case, we don&#39;t</span>
<a name="l01917"></a>01917 <span class="comment">         want to set a breakpoint on the first PC of each range.  To filter</span>
<a name="l01918"></a>01918 <span class="comment">         such cases, we use containing blocks -- for each PC found</span>
<a name="l01919"></a>01919 <span class="comment">         above, we see if there are other PCs that are in the same</span>
<a name="l01920"></a>01920 <span class="comment">         block.  If yes, the other PCs are filtered out.  */</span>
<a name="l01921"></a>01921 
<a name="l01922"></a>01922       filter = XNEWVEC (<span class="keywordtype">int</span>, intermediate_results.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a>);
<a name="l01923"></a>01923       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, filter);
<a name="l01924"></a>01924       blocks = XNEWVEC (<span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *, intermediate_results.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a>);
<a name="l01925"></a>01925       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, blocks);
<a name="l01926"></a>01926 
<a name="l01927"></a>01927       <span class="keywordflow">for</span> (i = 0; i &lt; intermediate_results.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a>; ++i)
<a name="l01928"></a>01928         {
<a name="l01929"></a>01929           <a class="code" href="progspace_8c.html#a394457638b3e584a3ecd019df372209f">set_current_program_space</a> (intermediate_results.<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a>[i].<a class="code" href="structsymtab__and__line.html#acc91f0276f4648cb5a970f17ddcbaf09">pspace</a>);
<a name="l01930"></a>01930 
<a name="l01931"></a>01931           filter[i] = 1;
<a name="l01932"></a>01932           blocks[i] = <a class="code" href="block_8c.html#a56d92bed7642525e5ae552935bd55cec">block_for_pc_sect</a> (intermediate_results.<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a>[i].<a class="code" href="structsymtab__and__line.html#a77665fa461ad187cb755efa256ba44d7">pc</a>,
<a name="l01933"></a>01933                                          intermediate_results.<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a>[i].<a class="code" href="structsymtab__and__line.html#a2e86134f04ab0e4d0834da476b7d020e">section</a>);
<a name="l01934"></a>01934         }
<a name="l01935"></a>01935 
<a name="l01936"></a>01936       <span class="keywordflow">for</span> (i = 0; i &lt; intermediate_results.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a>; ++i)
<a name="l01937"></a>01937         {
<a name="l01938"></a>01938           <span class="keywordflow">if</span> (blocks[i] != NULL)
<a name="l01939"></a>01939             <span class="keywordflow">for</span> (j = i + 1; j &lt; intermediate_results.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a>; ++j)
<a name="l01940"></a>01940               {
<a name="l01941"></a>01941                 <span class="keywordflow">if</span> (blocks[j] == blocks[i])
<a name="l01942"></a>01942                   {
<a name="l01943"></a>01943                     filter[j] = 0;
<a name="l01944"></a>01944                     <span class="keywordflow">break</span>;
<a name="l01945"></a>01945                   }
<a name="l01946"></a>01946               }
<a name="l01947"></a>01947         }
<a name="l01948"></a>01948 
<a name="l01949"></a>01949       <span class="keywordflow">for</span> (i = 0; i &lt; intermediate_results.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a>; ++i)
<a name="l01950"></a>01950         <span class="keywordflow">if</span> (filter[i])
<a name="l01951"></a>01951           {
<a name="l01952"></a>01952             <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym = (blocks[i]
<a name="l01953"></a>01953                                   ? <a class="code" href="block_8c.html#af69d835d36471a8f893a1aeaf5fd1d97">block_containing_function</a> (blocks[i])
<a name="l01954"></a>01954                                   : NULL);
<a name="l01955"></a>01955 
<a name="l01956"></a>01956             <span class="keywordflow">if</span> (self-&gt;funfirstline)
<a name="l01957"></a>01957               <a class="code" href="symtab_8c.html#a735ed7fdbb5870bad2b89eb8908f79b2">skip_prologue_sal</a> (&amp;intermediate_results.<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a>[i]);
<a name="l01958"></a>01958             <span class="comment">/* Make sure the line matches the request, not what was</span>
<a name="l01959"></a>01959 <span class="comment">               found.  */</span>
<a name="l01960"></a>01960             intermediate_results.<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a>[i].<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a> = val.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a>;
<a name="l01961"></a>01961             <a class="code" href="linespec_8c.html#abe07dbe47bca0f2cfca183745cb34f7d">add_sal_to_sals</a> (<span class="keyword">self</span>, &amp;values, &amp;intermediate_results.<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a>[i],
<a name="l01962"></a>01962                              sym ? <a class="code" href="symtab_8h.html#a243e66afa96ff58a851b38f428bb3394">SYMBOL_NATURAL_NAME</a> (sym) : NULL, 0);
<a name="l01963"></a>01963           }
<a name="l01964"></a>01964 
<a name="l01965"></a>01965       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l01966"></a>01966     }
<a name="l01967"></a>01967 
<a name="l01968"></a>01968   <span class="keywordflow">if</span> (values.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a> == 0)
<a name="l01969"></a>01969     {
<a name="l01970"></a>01970       <span class="keywordflow">if</span> (ls-&gt;source_filename)
<a name="l01971"></a>01971         <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No line %d in file \&quot;%s\&quot;.&quot;</span>),
<a name="l01972"></a>01972                      val.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a>, ls-&gt;source_filename);
<a name="l01973"></a>01973       <span class="keywordflow">else</span>
<a name="l01974"></a>01974         <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No line %d in the current file.&quot;</span>),
<a name="l01975"></a>01975                      val.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a>);
<a name="l01976"></a>01976     }
<a name="l01977"></a>01977 
<a name="l01978"></a>01978   <span class="keywordflow">return</span> values;
<a name="l01979"></a>01979 }
<a name="l01980"></a>01980 
<a name="l01981"></a>01981 <span class="comment">/* Create and return SALs from the linespec LS.  */</span>
<a name="l01982"></a>01982 
<a name="l01983"></a>01983 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a>
<a name="l01984"></a><a class="code" href="linespec_8c.html#a75da5dad27012741422eaf456b0b1595">01984</a> <a class="code" href="linespec_8c.html#a75da5dad27012741422eaf456b0b1595">convert_linespec_to_sals</a> (struct <a class="code" href="structlinespec__state.html">linespec_state</a> *state, linespec_p ls)
<a name="l01985"></a>01985 {
<a name="l01986"></a>01986   <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> sals = {NULL, 0};
<a name="l01987"></a>01987 
<a name="l01988"></a>01988   <span class="keywordflow">if</span> (ls-&gt;expression != NULL)
<a name="l01989"></a>01989     {
<a name="l01990"></a>01990       <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a> sal;
<a name="l01991"></a>01991 
<a name="l01992"></a>01992       <span class="comment">/* We have an expression.  No other attribute is allowed.  */</span>
<a name="l01993"></a>01993       sal = <a class="code" href="symtab_8c.html#ad9bbd85700e3d7fa50e7ba0e32f37846">find_pc_line</a> (ls-&gt;expr_pc, 0);
<a name="l01994"></a>01994       sal.pc = ls-&gt;expr_pc;
<a name="l01995"></a>01995       sal.section = <a class="code" href="symfile_8c.html#ae3387e3fa4dfcec140196f91111883c1">find_pc_overlay</a> (ls-&gt;expr_pc);
<a name="l01996"></a>01996       sal.explicit_pc = 1;
<a name="l01997"></a>01997       <a class="code" href="linespec_8c.html#abe07dbe47bca0f2cfca183745cb34f7d">add_sal_to_sals</a> (state, &amp;sals, &amp;sal, ls-&gt;expression, 1);
<a name="l01998"></a>01998     }
<a name="l01999"></a>01999   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ls-&gt;labels.label_symbols != NULL)
<a name="l02000"></a>02000     {
<a name="l02001"></a>02001       <span class="comment">/* We have just a bunch of functions/methods or labels.  */</span>
<a name="l02002"></a>02002       <span class="keywordtype">int</span> i;
<a name="l02003"></a>02003       <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a> sal;
<a name="l02004"></a>02004       <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l02005"></a>02005 
<a name="l02006"></a>02006       <span class="keywordflow">for</span> (i = 0; <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (symbolp, ls-&gt;labels.label_symbols, i, sym); ++i)
<a name="l02007"></a>02007         {
<a name="l02008"></a>02008           <span class="keyword">struct </span><a class="code" href="structprogram__space.html">program_space</a> *pspace = <a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (<a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (sym));
<a name="l02009"></a>02009 
<a name="l02010"></a>02010           <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#aa85de32bcb33630e5e698928cac16baf">symbol_to_sal</a> (&amp;sal, state-&gt;funfirstline, sym)
<a name="l02011"></a>02011               &amp;&amp; <a class="code" href="linespec_8c.html#adb625ed35c6026ec3265189c615e7e07">maybe_add_address</a> (state-&gt;addr_set, pspace, sal.<a class="code" href="structsymtab__and__line.html#a77665fa461ad187cb755efa256ba44d7">pc</a>))
<a name="l02012"></a>02012             <a class="code" href="linespec_8c.html#abe07dbe47bca0f2cfca183745cb34f7d">add_sal_to_sals</a> (state, &amp;sals, &amp;sal,
<a name="l02013"></a>02013                              <a class="code" href="symtab_8h.html#a243e66afa96ff58a851b38f428bb3394">SYMBOL_NATURAL_NAME</a> (sym), 0);
<a name="l02014"></a>02014         }
<a name="l02015"></a>02015     }
<a name="l02016"></a>02016   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ls-&gt;function_symbols != NULL || ls-&gt;minimal_symbols != NULL)
<a name="l02017"></a>02017     {
<a name="l02018"></a>02018       <span class="comment">/* We have just a bunch of functions and/or methods.  */</span>
<a name="l02019"></a>02019       <span class="keywordtype">int</span> i;
<a name="l02020"></a>02020       <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a> sal;
<a name="l02021"></a>02021       <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l02022"></a>02022       <a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a> *elem;
<a name="l02023"></a>02023       <span class="keyword">struct </span><a class="code" href="structprogram__space.html">program_space</a> *pspace;
<a name="l02024"></a>02024 
<a name="l02025"></a>02025       <span class="keywordflow">if</span> (ls-&gt;function_symbols != NULL)
<a name="l02026"></a>02026         {
<a name="l02027"></a>02027           <span class="comment">/* Sort symbols so that symbols with the same program space are next</span>
<a name="l02028"></a>02028 <span class="comment">             to each other.  */</span>
<a name="l02029"></a>02029           <a class="code" href="ada-exp_8c.html#a849e2297facde4d3c80dc4f45f8abbdb">qsort</a> (<a class="code" href="vec_8h.html#a99adc2006a668acc675e3758d9375ad5">VEC_address</a> (symbolp, ls-&gt;function_symbols),
<a name="l02030"></a>02030                  <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (symbolp, ls-&gt;function_symbols),
<a name="l02031"></a>02031                  sizeof (symbolp), <a class="code" href="linespec_8c.html#acb5414cbc70f2fd3932d5448208cfc3c">compare_symbols</a>);
<a name="l02032"></a>02032 
<a name="l02033"></a>02033           <span class="keywordflow">for</span> (i = 0; <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (symbolp, ls-&gt;function_symbols, i, sym); ++i)
<a name="l02034"></a>02034             {
<a name="l02035"></a>02035               pspace = <a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (<a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (sym));
<a name="l02036"></a>02036               <a class="code" href="progspace_8c.html#a394457638b3e584a3ecd019df372209f">set_current_program_space</a> (pspace);
<a name="l02037"></a>02037               <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#aa85de32bcb33630e5e698928cac16baf">symbol_to_sal</a> (&amp;sal, state-&gt;funfirstline, sym)
<a name="l02038"></a>02038                   &amp;&amp; <a class="code" href="linespec_8c.html#adb625ed35c6026ec3265189c615e7e07">maybe_add_address</a> (state-&gt;addr_set, pspace, sal.<a class="code" href="structsymtab__and__line.html#a77665fa461ad187cb755efa256ba44d7">pc</a>))
<a name="l02039"></a>02039                 <a class="code" href="linespec_8c.html#abe07dbe47bca0f2cfca183745cb34f7d">add_sal_to_sals</a> (state, &amp;sals, &amp;sal,
<a name="l02040"></a>02040                                  <a class="code" href="symtab_8h.html#a243e66afa96ff58a851b38f428bb3394">SYMBOL_NATURAL_NAME</a> (sym), 0);
<a name="l02041"></a>02041             }
<a name="l02042"></a>02042         }
<a name="l02043"></a>02043 
<a name="l02044"></a>02044       <span class="keywordflow">if</span> (ls-&gt;minimal_symbols != NULL)
<a name="l02045"></a>02045         {
<a name="l02046"></a>02046           <span class="comment">/* Sort minimal symbols by program space, too.  */</span>
<a name="l02047"></a>02047           <a class="code" href="ada-exp_8c.html#a849e2297facde4d3c80dc4f45f8abbdb">qsort</a> (<a class="code" href="vec_8h.html#a99adc2006a668acc675e3758d9375ad5">VEC_address</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, ls-&gt;minimal_symbols),
<a name="l02048"></a>02048                  <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, ls-&gt;minimal_symbols),
<a name="l02049"></a>02049                  sizeof (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>), <a class="code" href="linespec_8c.html#a70dc083f4402e21d9de69d372c31dc4e">compare_msymbols</a>);
<a name="l02050"></a>02050 
<a name="l02051"></a>02051           <span class="keywordflow">for</span> (i = 0;
<a name="l02052"></a>02052                <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, ls-&gt;minimal_symbols,
<a name="l02053"></a>02053                             i, elem);
<a name="l02054"></a>02054                ++i)
<a name="l02055"></a>02055             {
<a name="l02056"></a>02056               pspace = elem-&gt;<a class="code" href="structbound__minimal__symbol.html#a070e0e47d191675f0f4892e0b321d663">objfile</a>-&gt;<a class="code" href="structobjfile.html#a1f6ab738ce0b1fb1588709351b0c9091">pspace</a>;
<a name="l02057"></a>02057               <a class="code" href="progspace_8c.html#a394457638b3e584a3ecd019df372209f">set_current_program_space</a> (pspace);
<a name="l02058"></a>02058               <a class="code" href="linespec_8c.html#a578832c419d6702dc6f0f644224002ed">minsym_found</a> (state, elem-&gt;<a class="code" href="structbound__minimal__symbol.html#a070e0e47d191675f0f4892e0b321d663">objfile</a>, elem-&gt;<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>, &amp;sals);
<a name="l02059"></a>02059             }
<a name="l02060"></a>02060         }
<a name="l02061"></a>02061     }
<a name="l02062"></a>02062   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ls-&gt;line_offset.sign != <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376abf2fff5ff94b498a10942f7e2b22f251">LINE_OFFSET_UNKNOWN</a>)
<a name="l02063"></a>02063     {
<a name="l02064"></a>02064       <span class="comment">/* Only an offset was specified.  */</span>
<a name="l02065"></a>02065         sals = <a class="code" href="linespec_8c.html#a6f1574b8b0095c5be71223320bc1045c">create_sals_line_offset</a> (state, ls);
<a name="l02066"></a>02066 
<a name="l02067"></a>02067         <span class="comment">/* Make sure we have a filename for canonicalization.  */</span>
<a name="l02068"></a>02068         <span class="keywordflow">if</span> (ls-&gt;source_filename == NULL)
<a name="l02069"></a>02069           {
<a name="l02070"></a>02070             <span class="keyword">const</span> <span class="keywordtype">char</span> *fullname = <a class="code" href="source_8c.html#aa78177718e9d6c01595600975e8254df">symtab_to_fullname</a> (state-&gt;default_symtab);
<a name="l02071"></a>02071 
<a name="l02072"></a>02072             <span class="comment">/* It may be more appropriate to keep DEFAULT_SYMTAB in its symtab</span>
<a name="l02073"></a>02073 <span class="comment">               form so that displaying SOURCE_FILENAME can follow the current</span>
<a name="l02074"></a>02074 <span class="comment">               FILENAME_DISPLAY_STRING setting.  But as it is used only rarely</span>
<a name="l02075"></a>02075 <span class="comment">               it has been kept for code simplicity only in absolute form.  */</span>
<a name="l02076"></a>02076             ls-&gt;source_filename = xstrdup (fullname);
<a name="l02077"></a>02077           }
<a name="l02078"></a>02078     }
<a name="l02079"></a>02079   <span class="keywordflow">else</span>
<a name="l02080"></a>02080     {
<a name="l02081"></a>02081       <span class="comment">/* We haven&#39;t found any results...  */</span>
<a name="l02082"></a>02082       <span class="keywordflow">return</span> sals;
<a name="l02083"></a>02083     }
<a name="l02084"></a>02084 
<a name="l02085"></a>02085   <a class="code" href="linespec_8c.html#ac1a2266cc235a37e8a47a7169e16fc33">canonicalize_linespec</a> (state, ls);
<a name="l02086"></a>02086 
<a name="l02087"></a>02087   <span class="keywordflow">if</span> (sals.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a> &gt; 0 &amp;&amp; state-&gt;canonical != NULL)
<a name="l02088"></a>02088     state-&gt;canonical-&gt;pre_expanded = 1;
<a name="l02089"></a>02089 
<a name="l02090"></a>02090   <span class="keywordflow">return</span> sals;
<a name="l02091"></a>02091 }
<a name="l02092"></a>02092 
<a name="l02093"></a>02093 <span class="comment">/* Parse a string that specifies a linespec.</span>
<a name="l02094"></a>02094 <span class="comment">   Pass the address of a char * variable; that variable will be</span>
<a name="l02095"></a>02095 <span class="comment">   advanced over the characters actually parsed.</span>
<a name="l02096"></a>02096 <span class="comment"></span>
<a name="l02097"></a>02097 <span class="comment">   The basic grammar of linespecs:</span>
<a name="l02098"></a>02098 <span class="comment"></span>
<a name="l02099"></a>02099 <span class="comment">   linespec -&gt; expr_spec | var_spec | basic_spec</span>
<a name="l02100"></a>02100 <span class="comment">   expr_spec -&gt; &#39;*&#39; STRING</span>
<a name="l02101"></a>02101 <span class="comment">   var_spec -&gt; &#39;$&#39; (STRING | NUMBER)</span>
<a name="l02102"></a>02102 <span class="comment"></span>
<a name="l02103"></a>02103 <span class="comment">   basic_spec -&gt; file_offset_spec | function_spec | label_spec</span>
<a name="l02104"></a>02104 <span class="comment">   file_offset_spec -&gt; opt_file_spec offset_spec</span>
<a name="l02105"></a>02105 <span class="comment">   function_spec -&gt; opt_file_spec function_name_spec opt_label_spec</span>
<a name="l02106"></a>02106 <span class="comment">   label_spec -&gt; label_name_spec</span>
<a name="l02107"></a>02107 <span class="comment"></span>
<a name="l02108"></a>02108 <span class="comment">   opt_file_spec -&gt; &quot;&quot; | file_name_spec &#39;:&#39;</span>
<a name="l02109"></a>02109 <span class="comment">   opt_label_spec -&gt; &quot;&quot; | &#39;:&#39; label_name_spec</span>
<a name="l02110"></a>02110 <span class="comment"></span>
<a name="l02111"></a>02111 <span class="comment">   file_name_spec -&gt; STRING</span>
<a name="l02112"></a>02112 <span class="comment">   function_name_spec -&gt; STRING</span>
<a name="l02113"></a>02113 <span class="comment">   label_name_spec -&gt; STRING</span>
<a name="l02114"></a>02114 <span class="comment">   function_name_spec -&gt; STRING</span>
<a name="l02115"></a>02115 <span class="comment">   offset_spec -&gt; NUMBER</span>
<a name="l02116"></a>02116 <span class="comment">               -&gt; &#39;+&#39; NUMBER</span>
<a name="l02117"></a>02117 <span class="comment">               -&gt; &#39;-&#39; NUMBER</span>
<a name="l02118"></a>02118 <span class="comment"></span>
<a name="l02119"></a>02119 <span class="comment">   This may all be followed by several keywords such as &quot;if EXPR&quot;,</span>
<a name="l02120"></a>02120 <span class="comment">   which we ignore.</span>
<a name="l02121"></a>02121 <span class="comment"></span>
<a name="l02122"></a>02122 <span class="comment">   A comma will terminate parsing.</span>
<a name="l02123"></a>02123 <span class="comment"></span>
<a name="l02124"></a>02124 <span class="comment">   The function may be an undebuggable function found in minimal symbol table.</span>
<a name="l02125"></a>02125 <span class="comment"></span>
<a name="l02126"></a>02126 <span class="comment">   If the argument FUNFIRSTLINE is nonzero, we want the first line</span>
<a name="l02127"></a>02127 <span class="comment">   of real code inside a function when a function is specified, and it is</span>
<a name="l02128"></a>02128 <span class="comment">   not OK to specify a variable or type to get its line number.</span>
<a name="l02129"></a>02129 <span class="comment"></span>
<a name="l02130"></a>02130 <span class="comment">   DEFAULT_SYMTAB specifies the file to use if none is specified.</span>
<a name="l02131"></a>02131 <span class="comment">   It defaults to current_source_symtab.</span>
<a name="l02132"></a>02132 <span class="comment">   DEFAULT_LINE specifies the line number to use for relative</span>
<a name="l02133"></a>02133 <span class="comment">   line numbers (that start with signs).  Defaults to current_source_line.</span>
<a name="l02134"></a>02134 <span class="comment">   If CANONICAL is non-NULL, store an array of strings containing the canonical</span>
<a name="l02135"></a>02135 <span class="comment">   line specs there if necessary.  Currently overloaded member functions and</span>
<a name="l02136"></a>02136 <span class="comment">   line numbers or static functions without a filename yield a canonical</span>
<a name="l02137"></a>02137 <span class="comment">   line spec.  The array and the line spec strings are allocated on the heap,</span>
<a name="l02138"></a>02138 <span class="comment">   it is the callers responsibility to free them.</span>
<a name="l02139"></a>02139 <span class="comment"></span>
<a name="l02140"></a>02140 <span class="comment">   Note that it is possible to return zero for the symtab</span>
<a name="l02141"></a>02141 <span class="comment">   if no file is validly specified.  Callers must check that.</span>
<a name="l02142"></a>02142 <span class="comment">   Also, the line number returned may be invalid.  */</span>
<a name="l02143"></a>02143 
<a name="l02144"></a>02144 <span class="comment">/* Parse the linespec in ARGPTR.  */</span>
<a name="l02145"></a>02145 
<a name="l02146"></a>02146 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a>
<a name="l02147"></a><a class="code" href="linespec_8c.html#a70a574a83ed507d3a93daad05816e832">02147</a> <a class="code" href="linespec_8c.html#a70a574a83ed507d3a93daad05816e832">parse_linespec</a> (<a class="code" href="structls__parser.html">linespec_parser</a> *parser, <span class="keyword">const</span> <span class="keywordtype">char</span> **argptr)
<a name="l02148"></a>02148 {
<a name="l02149"></a>02149   <a class="code" href="structls__token.html">linespec_token</a> <a class="code" href="m2-exp_8c.html#a8abb7e972adc09624edab301e021dc5f">token</a>;
<a name="l02150"></a>02150   <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> values;
<a name="l02151"></a>02151   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> file_exception;
<a name="l02152"></a>02152   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l02153"></a>02153 
<a name="l02154"></a>02154   <span class="comment">/* A special case to start.  It has become quite popular for</span>
<a name="l02155"></a>02155 <span class="comment">     IDEs to work around bugs in the previous parser by quoting</span>
<a name="l02156"></a>02156 <span class="comment">     the entire linespec, so we attempt to deal with this nicely.  */</span>
<a name="l02157"></a>02157   parser-&gt;is_quote_enclosed = 0;
<a name="l02158"></a>02158   <span class="keywordflow">if</span> (!<a class="code" href="linespec_8c.html#a04bd71d4011fec1f936c61f9b2d254a0">is_ada_operator</a> (*argptr)
<a name="l02159"></a>02159       &amp;&amp; <a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (linespec_quote_characters, **argptr) != NULL)
<a name="l02160"></a>02160     {
<a name="l02161"></a>02161       <span class="keyword">const</span> <span class="keywordtype">char</span> *end;
<a name="l02162"></a>02162 
<a name="l02163"></a>02163       end = <a class="code" href="linespec_8c.html#ae2efb74c1247641f689a48b19edb2410">skip_quote_char</a> (*argptr + 1, **argptr);
<a name="l02164"></a>02164       <span class="keywordflow">if</span> (end != NULL &amp;&amp; <a class="code" href="linespec_8c.html#a4bcbc0eca5bb0b55768a5c7c0370e559">is_closing_quote_enclosed</a> (end))
<a name="l02165"></a>02165         {
<a name="l02166"></a>02166           <span class="comment">/* Here&#39;s the special case.  Skip ARGPTR past the initial</span>
<a name="l02167"></a>02167 <span class="comment">             quote.  */</span>
<a name="l02168"></a>02168           ++(*argptr);
<a name="l02169"></a>02169           parser-&gt;is_quote_enclosed = 1;
<a name="l02170"></a>02170         }
<a name="l02171"></a>02171     }
<a name="l02172"></a>02172 
<a name="l02173"></a>02173   <span class="comment">/* A keyword at the start cannot be interpreted as such.</span>
<a name="l02174"></a>02174 <span class="comment">     Consider &quot;b thread thread 42&quot;.  */</span>
<a name="l02175"></a>02175   parser-&gt;keyword_ok = 0;
<a name="l02176"></a>02176 
<a name="l02177"></a>02177   parser-&gt;lexer.saved_arg = *argptr;
<a name="l02178"></a>02178   parser-&gt;lexer.stream = argptr;
<a name="l02179"></a>02179   file_exception.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> = 0;
<a name="l02180"></a>02180 
<a name="l02181"></a>02181   <span class="comment">/* Initialize the default symtab and line offset.  */</span>
<a name="l02182"></a>02182   <a class="code" href="linespec_8c.html#a4791ffcdee3b1d956cc1ff1dcdeb2cb4">initialize_defaults</a> (&amp;<a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">PARSER_STATE</a> (parser)-&gt;default_symtab,
<a name="l02183"></a>02183                        &amp;<a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">PARSER_STATE</a> (parser)-&gt;default_line);
<a name="l02184"></a>02184 
<a name="l02185"></a>02185   <span class="comment">/* Objective-C shortcut.  */</span>
<a name="l02186"></a>02186   values = <a class="code" href="linespec_8c.html#a57904262d36d2d6d5c1dfaf9cb181e2e">decode_objc</a> (<a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">PARSER_STATE</a> (parser), <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser), argptr);
<a name="l02187"></a>02187   <span class="keywordflow">if</span> (values.<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a> != NULL)
<a name="l02188"></a>02188     <span class="keywordflow">return</span> values;
<a name="l02189"></a>02189 
<a name="l02190"></a>02190   <span class="comment">/* Start parsing.  */</span>
<a name="l02191"></a>02191 
<a name="l02192"></a>02192   <span class="comment">/* Get the first token.  */</span>
<a name="l02193"></a>02193   token = <a class="code" href="linespec_8c.html#ad98a478ce9c21319c2940cc23479d49b">linespec_lexer_lex_one</a> (parser);
<a name="l02194"></a>02194 
<a name="l02195"></a>02195   <span class="comment">/* It must be either LSTOKEN_STRING or LSTOKEN_NUMBER.  */</span>
<a name="l02196"></a>02196   <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af51514ff45b95b314eb23812fb75def7">LSTOKEN_STRING</a> &amp;&amp; *<a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).ptr == <span class="charliteral">&#39;*&#39;</span>)
<a name="l02197"></a>02197     {
<a name="l02198"></a>02198       <span class="keywordtype">char</span> *expr;
<a name="l02199"></a>02199       <span class="keyword">const</span> <span class="keywordtype">char</span> *copy;
<a name="l02200"></a>02200 
<a name="l02201"></a>02201       <span class="comment">/* User specified an expression, *EXPR.  */</span>
<a name="l02202"></a>02202       copy = expr = <a class="code" href="linespec_8c.html#a554b65b8cc0063ed9adf3e04294253e6">copy_token_string</a> (token);
<a name="l02203"></a>02203       cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, expr);
<a name="l02204"></a>02204       <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;expr_pc = <a class="code" href="linespec_8c.html#aa339d8b806f7f77d62dfa9179713c5d5">linespec_expression_to_pc</a> (&amp;copy);
<a name="l02205"></a>02205       <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (cleanup);
<a name="l02206"></a>02206       <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;expression = expr;
<a name="l02207"></a>02207 
<a name="l02208"></a>02208       <span class="comment">/* This is a little hacky/tricky.  If linespec_expression_to_pc</span>
<a name="l02209"></a>02209 <span class="comment">         did not evaluate the entire token, then we must find the</span>
<a name="l02210"></a>02210 <span class="comment">         string COPY inside the original token buffer.  */</span>
<a name="l02211"></a>02211       <span class="keywordflow">if</span> (*copy != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l02212"></a>02212         {
<a name="l02213"></a>02213           <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (parser-&gt;lexer.saved_arg, copy);
<a name="l02214"></a>02214           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) != NULL);
<a name="l02215"></a>02215         }
<a name="l02216"></a>02216 
<a name="l02217"></a>02217       <span class="comment">/* Consume the token.  */</span>
<a name="l02218"></a>02218       <a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">linespec_lexer_consume_token</a> (parser);
<a name="l02219"></a>02219 
<a name="l02220"></a>02220       <span class="keywordflow">goto</span> convert_to_sals;
<a name="l02221"></a>02221     }
<a name="l02222"></a>02222   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af51514ff45b95b314eb23812fb75def7">LSTOKEN_STRING</a> &amp;&amp; *<a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).ptr == <span class="charliteral">&#39;$&#39;</span>)
<a name="l02223"></a>02223     {
<a name="l02224"></a>02224       <span class="keywordtype">char</span> *var;
<a name="l02225"></a>02225 
<a name="l02226"></a>02226       <span class="comment">/* A NULL entry means to use GLOBAL_DEFAULT_SYMTAB.  */</span>
<a name="l02227"></a>02227       <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;file_symtabs, NULL);
<a name="l02228"></a>02228 
<a name="l02229"></a>02229       <span class="comment">/* User specified a convenience variable or history value.  */</span>
<a name="l02230"></a>02230       var = <a class="code" href="linespec_8c.html#a554b65b8cc0063ed9adf3e04294253e6">copy_token_string</a> (token);
<a name="l02231"></a>02231       cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, var);
<a name="l02232"></a>02232       <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;line_offset
<a name="l02233"></a>02233         = <a class="code" href="linespec_8c.html#a4f9761a36dffbb858aa4123c570964fe">linespec_parse_variable</a> (<a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">PARSER_STATE</a> (parser), var);
<a name="l02234"></a>02234       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l02235"></a>02235 
<a name="l02236"></a>02236       <span class="comment">/* If a line_offset wasn&#39;t found (VAR is the name of a user</span>
<a name="l02237"></a>02237 <span class="comment">         variable/function), then skip to normal symbol processing.  */</span>
<a name="l02238"></a>02238       <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;<a class="code" href="structline__offset.html">line_offset</a>.<a class="code" href="structline__offset.html#a472435e8559e52f51621869a9dc9f927">sign</a> != <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376abf2fff5ff94b498a10942f7e2b22f251">LINE_OFFSET_UNKNOWN</a>)
<a name="l02239"></a>02239         {
<a name="l02240"></a>02240           <span class="comment">/* Consume this token.  */</span>
<a name="l02241"></a>02241           <a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">linespec_lexer_consume_token</a> (parser);
<a name="l02242"></a>02242 
<a name="l02243"></a>02243           <span class="keywordflow">goto</span> convert_to_sals;
<a name="l02244"></a>02244         }
<a name="l02245"></a>02245     }
<a name="l02246"></a>02246   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> != <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af51514ff45b95b314eb23812fb75def7">LSTOKEN_STRING</a> &amp;&amp; token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> != <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af5166818bc2e7c7262ab4913a8abd253">LSTOKEN_NUMBER</a>)
<a name="l02247"></a>02247     <a class="code" href="linespec_8c.html#a6cad0d21e3b8c050e7e79b0fa97b55e7">unexpected_linespec_error</a> (parser);
<a name="l02248"></a>02248 
<a name="l02249"></a>02249   <span class="comment">/* Now we can recognize keywords.  */</span>
<a name="l02250"></a>02250   parser-&gt;keyword_ok = 1;
<a name="l02251"></a>02251 
<a name="l02252"></a>02252   <span class="comment">/* Shortcut: If the next token is not LSTOKEN_COLON, we know that</span>
<a name="l02253"></a>02253 <span class="comment">     this token cannot represent a filename.  */</span>
<a name="l02254"></a>02254   token = <a class="code" href="linespec_8c.html#a800de2e4bb092a096e3d420798e753b8">linespec_lexer_peek_token</a> (parser);
<a name="l02255"></a>02255 
<a name="l02256"></a>02256   <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> == <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a64e5ca29e811888826b7231415dcb1fa">LSTOKEN_COLON</a>)
<a name="l02257"></a>02257     {
<a name="l02258"></a>02258       <span class="keywordtype">char</span> *user_filename;
<a name="l02259"></a>02259 
<a name="l02260"></a>02260       <span class="comment">/* Get the current token again and extract the filename.  */</span>
<a name="l02261"></a>02261       token = <a class="code" href="linespec_8c.html#ad98a478ce9c21319c2940cc23479d49b">linespec_lexer_lex_one</a> (parser);
<a name="l02262"></a>02262       user_filename = <a class="code" href="linespec_8c.html#a554b65b8cc0063ed9adf3e04294253e6">copy_token_string</a> (token);
<a name="l02263"></a>02263 
<a name="l02264"></a>02264       <span class="comment">/* Check if the input is a filename.  */</span>
<a name="l02265"></a>02265       <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (file_exception, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l02266"></a>02266         {
<a name="l02267"></a>02267           <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;file_symtabs
<a name="l02268"></a>02268             = symtabs_from_filename (user_filename);
<a name="l02269"></a>02269         }
<a name="l02270"></a>02270 
<a name="l02271"></a>02271       <span class="keywordflow">if</span> (file_exception.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &gt;= 0)
<a name="l02272"></a>02272         {
<a name="l02273"></a>02273           <span class="comment">/* Symtabs were found for the file.  Record the filename.  */</span>
<a name="l02274"></a>02274           <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;source_filename = user_filename;
<a name="l02275"></a>02275 
<a name="l02276"></a>02276           <span class="comment">/* Get the next token.  */</span>
<a name="l02277"></a>02277           token = <a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">linespec_lexer_consume_token</a> (parser);
<a name="l02278"></a>02278 
<a name="l02279"></a>02279           <span class="comment">/* This is LSTOKEN_COLON; consume it.  */</span>
<a name="l02280"></a>02280           <a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">linespec_lexer_consume_token</a> (parser);
<a name="l02281"></a>02281         }
<a name="l02282"></a>02282       <span class="keywordflow">else</span>
<a name="l02283"></a>02283         {
<a name="l02284"></a>02284           <span class="comment">/* No symtabs found -- discard user_filename.  */</span>
<a name="l02285"></a>02285           <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (user_filename);
<a name="l02286"></a>02286 
<a name="l02287"></a>02287           <span class="comment">/* A NULL entry means to use GLOBAL_DEFAULT_SYMTAB.  */</span>
<a name="l02288"></a>02288           <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;file_symtabs, NULL);
<a name="l02289"></a>02289         }
<a name="l02290"></a>02290     }
<a name="l02291"></a>02291   <span class="comment">/* If the next token is not EOI, KEYWORD, or COMMA, issue an error.  */</span>
<a name="l02292"></a>02292   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> != <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a9d5032c178932f2ba5e3c30763b2ef47">LSTOKEN_EOI</a> &amp;&amp; token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> != <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af8a55ade50678c246a4af428c016dee6">LSTOKEN_KEYWORD</a>
<a name="l02293"></a>02293            &amp;&amp; token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> != <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3ab831810c44c39dc484a828d6d141bade">LSTOKEN_COMMA</a>)
<a name="l02294"></a>02294     {
<a name="l02295"></a>02295       <span class="comment">/* TOKEN is the _next_ token, not the one currently in the parser.</span>
<a name="l02296"></a>02296 <span class="comment">         Consuming the token will give the correct error message.  */</span>
<a name="l02297"></a>02297       <a class="code" href="linespec_8c.html#af87e6f7d5e135e0131b91ca96b270d9e">linespec_lexer_consume_token</a> (parser);
<a name="l02298"></a>02298       <a class="code" href="linespec_8c.html#a6cad0d21e3b8c050e7e79b0fa97b55e7">unexpected_linespec_error</a> (parser);
<a name="l02299"></a>02299     }
<a name="l02300"></a>02300   <span class="keywordflow">else</span>
<a name="l02301"></a>02301     {
<a name="l02302"></a>02302       <span class="comment">/* A NULL entry means to use GLOBAL_DEFAULT_SYMTAB.  */</span>
<a name="l02303"></a>02303       <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;file_symtabs, NULL);
<a name="l02304"></a>02304     }
<a name="l02305"></a>02305 
<a name="l02306"></a>02306   <span class="comment">/* Parse the rest of the linespec.  */</span>
<a name="l02307"></a>02307   <a class="code" href="linespec_8c.html#a6f7fbf2443a4ca7b0af65db4bbbfcde2">linespec_parse_basic</a> (parser);
<a name="l02308"></a>02308 
<a name="l02309"></a>02309   <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;function_symbols == NULL
<a name="l02310"></a>02310       &amp;&amp; <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;labels.label_symbols == NULL
<a name="l02311"></a>02311       &amp;&amp; <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;<a class="code" href="structline__offset.html">line_offset</a>.<a class="code" href="structline__offset.html#a472435e8559e52f51621869a9dc9f927">sign</a> == <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376abf2fff5ff94b498a10942f7e2b22f251">LINE_OFFSET_UNKNOWN</a>
<a name="l02312"></a>02312       &amp;&amp; <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;minimal_symbols == NULL)
<a name="l02313"></a>02313     {
<a name="l02314"></a>02314       <span class="comment">/* The linespec didn&#39;t parse.  Re-throw the file exception if</span>
<a name="l02315"></a>02315 <span class="comment">         there was one.  */</span>
<a name="l02316"></a>02316       <span class="keywordflow">if</span> (file_exception.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0)
<a name="l02317"></a>02317         <a class="code" href="exceptions_8c.html#a541d1b545da68efe4f8b729a945f83e7">throw_exception</a> (file_exception);
<a name="l02318"></a>02318 
<a name="l02319"></a>02319       <span class="comment">/* Otherwise, the symbol is not found.  */</span>
<a name="l02320"></a>02320       <a class="code" href="linespec_8c.html#ac64f473cb06cc9077d8c88eca441d4e6">symbol_not_found_error</a> (<a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;function_name,
<a name="l02321"></a>02321                               <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;source_filename);
<a name="l02322"></a>02322     }
<a name="l02323"></a>02323 
<a name="l02324"></a>02324  convert_to_sals:
<a name="l02325"></a>02325 
<a name="l02326"></a>02326   <span class="comment">/* Get the last token and record how much of the input was parsed,</span>
<a name="l02327"></a>02327 <span class="comment">     if necessary.  */</span>
<a name="l02328"></a>02328   token = <a class="code" href="linespec_8c.html#ad98a478ce9c21319c2940cc23479d49b">linespec_lexer_lex_one</a> (parser);
<a name="l02329"></a>02329   <span class="keywordflow">if</span> (token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> != <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3a9d5032c178932f2ba5e3c30763b2ef47">LSTOKEN_EOI</a> &amp;&amp; token.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> != <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3af8a55ade50678c246a4af428c016dee6">LSTOKEN_KEYWORD</a>)
<a name="l02330"></a>02330     <a class="code" href="linespec_8c.html#a03f14c8b7a5de56ee710acc509965cb1">PARSER_STREAM</a> (parser) = <a class="code" href="linespec_8c.html#aee4f3aa36e65bf989a1cf9bf31fc2564">LS_TOKEN_STOKEN</a> (token).ptr;
<a name="l02331"></a>02331 
<a name="l02332"></a>02332   <span class="comment">/* Convert the data in PARSER_RESULT to SALs.  */</span>
<a name="l02333"></a>02333   values = <a class="code" href="linespec_8c.html#a75da5dad27012741422eaf456b0b1595">convert_linespec_to_sals</a> (<a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">PARSER_STATE</a> (parser),
<a name="l02334"></a>02334                                      <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser));
<a name="l02335"></a>02335 
<a name="l02336"></a>02336   <span class="keywordflow">return</span> values;
<a name="l02337"></a>02337 }
<a name="l02338"></a>02338 
<a name="l02339"></a>02339 
<a name="l02340"></a>02340 <span class="comment">/* A constructor for linespec_state.  */</span>
<a name="l02341"></a>02341 
<a name="l02342"></a>02342 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02343"></a><a class="code" href="linespec_8c.html#aae23771fdbfc2e3ed198b6bfa7a129aa">02343</a> <a class="code" href="linespec_8c.html#aae23771fdbfc2e3ed198b6bfa7a129aa">linespec_state_constructor</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l02344"></a>02344                             <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlanguage__defn.html">language_defn</a> *<a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a>,
<a name="l02345"></a>02345                             <span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *default_symtab,
<a name="l02346"></a>02346                             <span class="keywordtype">int</span> default_line,
<a name="l02347"></a>02347                             <span class="keyword">struct</span> <a class="code" href="structlinespec__result.html">linespec_result</a> *canonical)
<a name="l02348"></a>02348 {
<a name="l02349"></a>02349   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (<span class="keyword">self</span>, 0, <span class="keyword">sizeof</span> (*<span class="keyword">self</span>));
<a name="l02350"></a>02350   <span class="keyword">self</span>-&gt;language = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a>;
<a name="l02351"></a>02351   <span class="keyword">self</span>-&gt;funfirstline = (flags &amp; <a class="code" href="linespec_8h.html#a66db0c56cdf6b7d07a996c374a0572caadb5b3965c89f02bfa79f8871fde72588">DECODE_LINE_FUNFIRSTLINE</a>) ? 1 : 0;
<a name="l02352"></a>02352   <span class="keyword">self</span>-&gt;list_mode = (flags &amp; <a class="code" href="linespec_8h.html#a66db0c56cdf6b7d07a996c374a0572caae008953599e1c9328463cbbdad314799">DECODE_LINE_LIST_MODE</a>) ? 1 : 0;
<a name="l02353"></a>02353   <span class="keyword">self</span>-&gt;default_symtab = default_symtab;
<a name="l02354"></a>02354   <span class="keyword">self</span>-&gt;default_line = default_line;
<a name="l02355"></a>02355   <span class="keyword">self</span>-&gt;canonical = canonical;
<a name="l02356"></a>02356   <span class="keyword">self</span>-&gt;program_space = <a class="code" href="progspace_8c.html#a07722ff15a98814c086dda44f93380c9">current_program_space</a>;
<a name="l02357"></a>02357   <span class="keyword">self</span>-&gt;addr_set = htab_create_alloc (10, <a class="code" href="linespec_8c.html#a275c6bfe4494e7d9252def6acfbb6eab">hash_address_entry</a>, <a class="code" href="linespec_8c.html#a0a7bf64c264195ffbda31cba368609f7">eq_address_entry</a>,
<a name="l02358"></a>02358                                       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a>, <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>);
<a name="l02359"></a>02359 }
<a name="l02360"></a>02360 
<a name="l02361"></a>02361 <span class="comment">/* Initialize a new linespec parser.  */</span>
<a name="l02362"></a>02362 
<a name="l02363"></a>02363 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02364"></a><a class="code" href="linespec_8c.html#a756262c5c9810de7ba334f10ca07518c">02364</a> <a class="code" href="linespec_8c.html#a756262c5c9810de7ba334f10ca07518c">linespec_parser_new</a> (<a class="code" href="structls__parser.html">linespec_parser</a> *parser,
<a name="l02365"></a>02365                      <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlanguage__defn.html">language_defn</a> *<a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a>,
<a name="l02366"></a>02366                      <span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *default_symtab,
<a name="l02367"></a>02367                      <span class="keywordtype">int</span> default_line,
<a name="l02368"></a>02368                      <span class="keyword">struct</span> <a class="code" href="structlinespec__result.html">linespec_result</a> *canonical)
<a name="l02369"></a>02369 {
<a name="l02370"></a>02370   parser-&gt;<a class="code" href="structls__parser.html#a3d06f65135ed473f52f73d16bb3a70e3">lexer</a>.<a class="code" href="structls__parser.html#a11a8d7f24c9df4d5fd3c240b4bda25fa">current</a>.<a class="code" href="structls__token.html#a84f37b3ecc805c04e3209f3b62fcecf0">type</a> = <a class="code" href="linespec_8c.html#a2b289c87a52d80a5ff259ed36fff21e3aca342f5d4922401449679bbc1f87e700">LSTOKEN_CONSUMED</a>;
<a name="l02371"></a>02371   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (<a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser), 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structlinespec.html">linespec</a>));
<a name="l02372"></a>02372   <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;line_offset.sign = <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376abf2fff5ff94b498a10942f7e2b22f251">LINE_OFFSET_UNKNOWN</a>;
<a name="l02373"></a>02373   <a class="code" href="linespec_8c.html#aae23771fdbfc2e3ed198b6bfa7a129aa">linespec_state_constructor</a> (<a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">PARSER_STATE</a> (parser), flags, language,
<a name="l02374"></a>02374                               default_symtab, default_line, canonical);
<a name="l02375"></a>02375 }
<a name="l02376"></a>02376 
<a name="l02377"></a>02377 <span class="comment">/* A destructor for linespec_state.  */</span>
<a name="l02378"></a>02378 
<a name="l02379"></a>02379 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02380"></a><a class="code" href="linespec_8c.html#a70f77a33d40267ee1fbcb4132b5ea6b0">02380</a> <a class="code" href="linespec_8c.html#a70f77a33d40267ee1fbcb4132b5ea6b0">linespec_state_destructor</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>)
<a name="l02381"></a>02381 {
<a name="l02382"></a>02382   htab_delete (self-&gt;addr_set);
<a name="l02383"></a>02383 }
<a name="l02384"></a>02384 
<a name="l02385"></a>02385 <span class="comment">/* Delete a linespec parser.  */</span>
<a name="l02386"></a>02386 
<a name="l02387"></a>02387 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02388"></a><a class="code" href="linespec_8c.html#aa5f2a5926de184a3b6782ebf67447047">02388</a> <a class="code" href="linespec_8c.html#aa5f2a5926de184a3b6782ebf67447047">linespec_parser_delete</a> (<span class="keywordtype">void</span> *<a class="code" href="structcleanup.html#a10b494058e88a8972633026b5fa3873f">arg</a>)
<a name="l02389"></a>02389 {
<a name="l02390"></a>02390   <a class="code" href="structls__parser.html">linespec_parser</a> *parser = (<a class="code" href="structls__parser.html">linespec_parser</a> *) arg;
<a name="l02391"></a>02391 
<a name="l02392"></a>02392   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> ((<span class="keywordtype">char</span> *) <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;<a class="code" href="structexpression.html">expression</a>);
<a name="l02393"></a>02393   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> ((<span class="keywordtype">char</span> *) <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;source_filename);
<a name="l02394"></a>02394   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> ((<span class="keywordtype">char</span> *) <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;label_name);
<a name="l02395"></a>02395   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> ((<span class="keywordtype">char</span> *) <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;function_name);
<a name="l02396"></a>02396 
<a name="l02397"></a>02397   <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;file_symtabs != NULL)
<a name="l02398"></a>02398     <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;file_symtabs);
<a name="l02399"></a>02399 
<a name="l02400"></a>02400   <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;function_symbols != NULL)
<a name="l02401"></a>02401     <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (symbolp, <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;function_symbols);
<a name="l02402"></a>02402 
<a name="l02403"></a>02403   <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;minimal_symbols != NULL)
<a name="l02404"></a>02404     <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;minimal_symbols);
<a name="l02405"></a>02405 
<a name="l02406"></a>02406   <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;labels.label_symbols != NULL)
<a name="l02407"></a>02407     <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (symbolp, <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;labels.label_symbols);
<a name="l02408"></a>02408 
<a name="l02409"></a>02409   <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;labels.function_symbols != NULL)
<a name="l02410"></a>02410     <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (symbolp, <a class="code" href="linespec_8c.html#af3cfa25e3d9d0d40036ebee909d361a0">PARSER_RESULT</a> (parser)-&gt;labels.function_symbols);
<a name="l02411"></a>02411 
<a name="l02412"></a>02412   <a class="code" href="linespec_8c.html#a70f77a33d40267ee1fbcb4132b5ea6b0">linespec_state_destructor</a> (<a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">PARSER_STATE</a> (parser));
<a name="l02413"></a>02413 }
<a name="l02414"></a>02414 
<a name="l02415"></a>02415 <span class="comment">/* See linespec.h.  */</span>
<a name="l02416"></a>02416 
<a name="l02417"></a>02417 <span class="keywordtype">void</span>
<a name="l02418"></a><a class="code" href="linespec_8h.html#af57ff2f3f7a08d8b7f1d8c1fb3f24e12">02418</a> <a class="code" href="linespec_8c.html#af57ff2f3f7a08d8b7f1d8c1fb3f24e12">decode_line_full</a> (<span class="keywordtype">char</span> **argptr, <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>,
<a name="l02419"></a>02419                   <span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *default_symtab,
<a name="l02420"></a>02420                   <span class="keywordtype">int</span> default_line, <span class="keyword">struct</span> <a class="code" href="structlinespec__result.html">linespec_result</a> *canonical,
<a name="l02421"></a>02421                   <span class="keyword">const</span> <span class="keywordtype">char</span> *select_mode,
<a name="l02422"></a>02422                   <span class="keyword">const</span> <span class="keywordtype">char</span> *filter)
<a name="l02423"></a>02423 {
<a name="l02424"></a>02424   <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> result;
<a name="l02425"></a>02425   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups;
<a name="l02426"></a>02426   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>) *filters = NULL;
<a name="l02427"></a>02427   <a class="code" href="structls__parser.html">linespec_parser</a> parser;
<a name="l02428"></a>02428   <span class="keyword">struct </span><a class="code" href="structlinespec__state.html">linespec_state</a> *state;
<a name="l02429"></a>02429   <span class="keyword">const</span> <span class="keywordtype">char</span> *copy, *orig;
<a name="l02430"></a>02430 
<a name="l02431"></a>02431   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (canonical != NULL);
<a name="l02432"></a>02432   <span class="comment">/* The filter only makes sense for &#39;all&#39;.  */</span>
<a name="l02433"></a>02433   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (filter == NULL || select_mode == <a class="code" href="symtab_8c.html#a2457c524e394ad239661c86ceedb99a7">multiple_symbols_all</a>);
<a name="l02434"></a>02434   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (select_mode == NULL
<a name="l02435"></a>02435               || select_mode == <a class="code" href="symtab_8c.html#a2457c524e394ad239661c86ceedb99a7">multiple_symbols_all</a>
<a name="l02436"></a>02436               || select_mode == <a class="code" href="symtab_8c.html#a2c09113e044998e561df5d1409351dbe">multiple_symbols_ask</a>
<a name="l02437"></a>02437               || select_mode == <a class="code" href="symtab_8c.html#a5a9b380bd1851dbd78165e00514e2b64">multiple_symbols_cancel</a>);
<a name="l02438"></a>02438   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> ((flags &amp; <a class="code" href="linespec_8h.html#a66db0c56cdf6b7d07a996c374a0572caae008953599e1c9328463cbbdad314799">DECODE_LINE_LIST_MODE</a>) == 0);
<a name="l02439"></a>02439 
<a name="l02440"></a>02440   <a class="code" href="linespec_8c.html#a756262c5c9810de7ba334f10ca07518c">linespec_parser_new</a> (&amp;parser, flags, <a class="code" href="language_8c.html#acd2505a014a95629da9c836f8914fc79">current_language</a>, default_symtab,
<a name="l02441"></a>02441                        default_line, canonical);
<a name="l02442"></a>02442   cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="linespec_8c.html#aa5f2a5926de184a3b6782ebf67447047">linespec_parser_delete</a>, &amp;parser);
<a name="l02443"></a>02443   <a class="code" href="progspace_8c.html#a702df4a5aa34e81fc0bb38dd8c2d68df">save_current_program_space</a> ();
<a name="l02444"></a>02444 
<a name="l02445"></a>02445   orig = copy = *argptr;
<a name="l02446"></a>02446   result = <a class="code" href="linespec_8c.html#a70a574a83ed507d3a93daad05816e832">parse_linespec</a> (&amp;parser, &amp;copy);
<a name="l02447"></a>02447   *argptr += copy - orig;
<a name="l02448"></a>02448   state = <a class="code" href="linespec_8c.html#aa35141dea1f89a1701936013a03e90ae">PARSER_STATE</a> (&amp;parser);
<a name="l02449"></a>02449 
<a name="l02450"></a>02450   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (result.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a> == 1 || canonical-&gt;<a class="code" href="structlinespec__result.html#aba3bd9d4d9bc5d3b63ad16e64169b765">pre_expanded</a>);
<a name="l02451"></a>02451   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (canonical-&gt;<a class="code" href="structlinespec__result.html#abfccf5d367c072077ac366af4d3f23f9">addr_string</a> != NULL);
<a name="l02452"></a>02452   canonical-&gt;<a class="code" href="structlinespec__result.html#aba3bd9d4d9bc5d3b63ad16e64169b765">pre_expanded</a> = 1;
<a name="l02453"></a>02453 
<a name="l02454"></a>02454   <span class="comment">/* Arrange for allocated canonical names to be freed.  */</span>
<a name="l02455"></a>02455   <span class="keywordflow">if</span> (result.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a> &gt; 0)
<a name="l02456"></a>02456     {
<a name="l02457"></a>02457       <span class="keywordtype">int</span> i;
<a name="l02458"></a>02458 
<a name="l02459"></a>02459       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, state-&gt;<a class="code" href="structlinespec__state.html#ac6058a4a0366e50629e582135a7b6833">canonical_names</a>);
<a name="l02460"></a>02460       <span class="keywordflow">for</span> (i = 0; i &lt; result.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a>; ++i)
<a name="l02461"></a>02461         {
<a name="l02462"></a>02462           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (state-&gt;<a class="code" href="structlinespec__state.html#ac6058a4a0366e50629e582135a7b6833">canonical_names</a>[i].<a class="code" href="structlinespec__canonical__name.html#af887cf4c56a62f9a6f0600a977c83551">suffix</a> != NULL);
<a name="l02463"></a>02463           <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, state-&gt;<a class="code" href="structlinespec__state.html#ac6058a4a0366e50629e582135a7b6833">canonical_names</a>[i].<a class="code" href="structlinespec__canonical__name.html#af887cf4c56a62f9a6f0600a977c83551">suffix</a>);
<a name="l02464"></a>02464         }
<a name="l02465"></a>02465     }
<a name="l02466"></a>02466 
<a name="l02467"></a>02467   <span class="keywordflow">if</span> (select_mode == NULL)
<a name="l02468"></a>02468     {
<a name="l02469"></a>02469       <span class="keywordflow">if</span> (<a class="code" href="ui-out_8c.html#a473db54efcfbc60feeb5a4f54f27af46">ui_out_is_mi_like_p</a> (<a class="code" href="interps_8c.html#a8e9dd8dc026ec4b76ae0c0a27a97383d">interp_ui_out</a> (<a class="code" href="interps_8c.html#a55d2f9afbe93d6b241b23fdffb5f17a4">top_level_interpreter</a> ())))
<a name="l02470"></a>02470         select_mode = <a class="code" href="symtab_8c.html#a2457c524e394ad239661c86ceedb99a7">multiple_symbols_all</a>;
<a name="l02471"></a>02471       <span class="keywordflow">else</span>
<a name="l02472"></a>02472         select_mode = <a class="code" href="symtab_8c.html#ac1196047fdb70a2214cfcaecda5478d9">multiple_symbols_select_mode</a> ();
<a name="l02473"></a>02473     }
<a name="l02474"></a>02474 
<a name="l02475"></a>02475   <span class="keywordflow">if</span> (select_mode == <a class="code" href="symtab_8c.html#a2457c524e394ad239661c86ceedb99a7">multiple_symbols_all</a>)
<a name="l02476"></a>02476     {
<a name="l02477"></a>02477       <span class="keywordflow">if</span> (filter != NULL)
<a name="l02478"></a>02478         {
<a name="l02479"></a>02479           <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="vec_8h.html#a92a6114eb727b9274e1523d0e9dd2e61">VEC_cleanup</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>), &amp;filters);
<a name="l02480"></a>02480           <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>, filters, filter);
<a name="l02481"></a>02481           <a class="code" href="linespec_8c.html#ab7f5c5cf59e14b6816cdd59fedc94ef5">filter_results</a> (state, &amp;result, filters);
<a name="l02482"></a>02482         }
<a name="l02483"></a>02483       <span class="keywordflow">else</span>
<a name="l02484"></a>02484         <a class="code" href="linespec_8c.html#a2379614f47a369c0c1e4f7d4ba874994">convert_results_to_lsals</a> (state, &amp;result);
<a name="l02485"></a>02485     }
<a name="l02486"></a>02486   <span class="keywordflow">else</span>
<a name="l02487"></a>02487     <a class="code" href="linespec_8c.html#a9151e3c41ef3fd972e66cdaaf6bad8ca">decode_line_2</a> (state, &amp;result, select_mode);
<a name="l02488"></a>02488 
<a name="l02489"></a>02489   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l02490"></a>02490 }
<a name="l02491"></a>02491 
<a name="l02492"></a>02492 <span class="comment">/* See linespec.h.  */</span>
<a name="l02493"></a>02493 
<a name="l02494"></a>02494 <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a>
<a name="l02495"></a><a class="code" href="linespec_8h.html#ad8b0e76089f41873cf0fb2c14cd2d569">02495</a> <a class="code" href="linespec_8c.html#ad8b0e76089f41873cf0fb2c14cd2d569">decode_line_1</a> (char **argptr, <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>,
<a name="l02496"></a>02496                <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *default_symtab,
<a name="l02497"></a>02497                <span class="keywordtype">int</span> default_line)
<a name="l02498"></a>02498 {
<a name="l02499"></a>02499   <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> result;
<a name="l02500"></a>02500   <a class="code" href="structls__parser.html">linespec_parser</a> parser;
<a name="l02501"></a>02501   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups;
<a name="l02502"></a>02502   <span class="keyword">const</span> <span class="keywordtype">char</span> *copy, *orig;
<a name="l02503"></a>02503 
<a name="l02504"></a>02504   <a class="code" href="linespec_8c.html#a756262c5c9810de7ba334f10ca07518c">linespec_parser_new</a> (&amp;parser, flags, <a class="code" href="language_8c.html#acd2505a014a95629da9c836f8914fc79">current_language</a>, default_symtab,
<a name="l02505"></a>02505                        default_line, NULL);
<a name="l02506"></a>02506   cleanups = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="linespec_8c.html#aa5f2a5926de184a3b6782ebf67447047">linespec_parser_delete</a>, &amp;parser);
<a name="l02507"></a>02507   <a class="code" href="progspace_8c.html#a702df4a5aa34e81fc0bb38dd8c2d68df">save_current_program_space</a> ();
<a name="l02508"></a>02508 
<a name="l02509"></a>02509   orig = copy = *argptr;
<a name="l02510"></a>02510   result = <a class="code" href="linespec_8c.html#a70a574a83ed507d3a93daad05816e832">parse_linespec</a> (&amp;parser, &amp;copy);
<a name="l02511"></a>02511   *argptr += copy - orig;
<a name="l02512"></a>02512 
<a name="l02513"></a>02513   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l02514"></a>02514   <span class="keywordflow">return</span> result;
<a name="l02515"></a>02515 }
<a name="l02516"></a>02516 
<a name="l02517"></a>02517 <span class="comment">/* See linespec.h.  */</span>
<a name="l02518"></a>02518 
<a name="l02519"></a>02519 <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a>
<a name="l02520"></a><a class="code" href="linespec_8h.html#a3851d68ff1dad53dda6ae37f901e0286">02520</a> <a class="code" href="linespec_8c.html#a99c1ec5e07db5d8ffc64de454d190650">decode_line_with_current_source</a> (char *<a class="code" href="signals_8c.html#ae1adbce218e7a9d09164012443191d24">string</a>, <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>)
<a name="l02521"></a>02521 {
<a name="l02522"></a>02522   <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> sals;
<a name="l02523"></a>02523   <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a> cursal;
<a name="l02524"></a>02524 
<a name="l02525"></a>02525   <span class="keywordflow">if</span> (<span class="keywordtype">string</span> == 0)
<a name="l02526"></a>02526     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Empty line specification.&quot;</span>));
<a name="l02527"></a>02527 
<a name="l02528"></a>02528   <span class="comment">/* We use whatever is set as the current source line.  We do not try</span>
<a name="l02529"></a>02529 <span class="comment">     and get a default source symtab+line or it will recursively call us!  */</span>
<a name="l02530"></a>02530   cursal = <a class="code" href="source_8c.html#a387b0906b103c4b3dec9d7cfdd41a9ad">get_current_source_symtab_and_line</a> ();
<a name="l02531"></a>02531 
<a name="l02532"></a>02532   sals = <a class="code" href="linespec_8c.html#ad8b0e76089f41873cf0fb2c14cd2d569">decode_line_1</a> (&amp;<span class="keywordtype">string</span>, flags,
<a name="l02533"></a>02533                         cursal.<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a>, cursal.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a>);
<a name="l02534"></a>02534 
<a name="l02535"></a>02535   <span class="keywordflow">if</span> (*<span class="keywordtype">string</span>)
<a name="l02536"></a>02536     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Junk at end of line specification: %s&quot;</span>), <span class="keywordtype">string</span>);
<a name="l02537"></a>02537   <span class="keywordflow">return</span> sals;
<a name="l02538"></a>02538 }
<a name="l02539"></a>02539 
<a name="l02540"></a>02540 <span class="comment">/* See linespec.h.  */</span>
<a name="l02541"></a>02541 
<a name="l02542"></a>02542 <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a>
<a name="l02543"></a><a class="code" href="linespec_8h.html#a286bcd84d4c9ae1317ee0c6ba184ce00">02543</a> <a class="code" href="linespec_8c.html#a6cf53366605fcbdc9b950091efe437e4">decode_line_with_last_displayed</a> (char *<a class="code" href="signals_8c.html#ae1adbce218e7a9d09164012443191d24">string</a>, <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>)
<a name="l02544"></a>02544 {
<a name="l02545"></a>02545   <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> sals;
<a name="l02546"></a>02546 
<a name="l02547"></a>02547   <span class="keywordflow">if</span> (<span class="keywordtype">string</span> == 0)
<a name="l02548"></a>02548     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Empty line specification.&quot;</span>));
<a name="l02549"></a>02549 
<a name="l02550"></a>02550   <span class="keywordflow">if</span> (<a class="code" href="stack_8c.html#a47beab727091bf3c0ed6747aa51e88a4">last_displayed_sal_is_valid</a> ())
<a name="l02551"></a>02551     sals = <a class="code" href="linespec_8c.html#ad8b0e76089f41873cf0fb2c14cd2d569">decode_line_1</a> (&amp;<span class="keywordtype">string</span>, flags,
<a name="l02552"></a>02552                           <a class="code" href="stack_8c.html#afdef12055c64d642f37c595fc63be5f2">get_last_displayed_symtab</a> (),
<a name="l02553"></a>02553                           <a class="code" href="stack_8c.html#a94a7a8437ec860efe5c514ed72cae337">get_last_displayed_line</a> ());
<a name="l02554"></a>02554   <span class="keywordflow">else</span>
<a name="l02555"></a>02555     sals = <a class="code" href="linespec_8c.html#ad8b0e76089f41873cf0fb2c14cd2d569">decode_line_1</a> (&amp;<span class="keywordtype">string</span>, flags, (<span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *) NULL, 0);
<a name="l02556"></a>02556 
<a name="l02557"></a>02557   <span class="keywordflow">if</span> (*<span class="keywordtype">string</span>)
<a name="l02558"></a>02558     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Junk at end of line specification: %s&quot;</span>), <span class="keywordtype">string</span>);
<a name="l02559"></a>02559   <span class="keywordflow">return</span> <a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a>;
<a name="l02560"></a>02560 }
<a name="l02561"></a>02561 
<a name="l02562"></a>02562 
<a name="l02563"></a>02563 
<a name="l02564"></a>02564 <span class="comment">/* First, some functions to initialize stuff at the beggining of the</span>
<a name="l02565"></a>02565 <span class="comment">   function.  */</span>
<a name="l02566"></a>02566 
<a name="l02567"></a>02567 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02568"></a><a class="code" href="linespec_8c.html#a4791ffcdee3b1d956cc1ff1dcdeb2cb4">02568</a> <a class="code" href="linespec_8c.html#a4791ffcdee3b1d956cc1ff1dcdeb2cb4">initialize_defaults</a> (<span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> **default_symtab, <span class="keywordtype">int</span> *default_line)
<a name="l02569"></a>02569 {
<a name="l02570"></a>02570   <span class="keywordflow">if</span> (*default_symtab == 0)
<a name="l02571"></a>02571     {
<a name="l02572"></a>02572       <span class="comment">/* Use whatever we have for the default source line.  We don&#39;t use</span>
<a name="l02573"></a>02573 <span class="comment">         get_current_or_default_symtab_and_line as it can recurse and call</span>
<a name="l02574"></a>02574 <span class="comment">         us back!  */</span>
<a name="l02575"></a>02575       <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a> cursal = 
<a name="l02576"></a>02576         <a class="code" href="source_8c.html#a387b0906b103c4b3dec9d7cfdd41a9ad">get_current_source_symtab_and_line</a> ();
<a name="l02577"></a>02577       
<a name="l02578"></a>02578       *default_symtab = cursal.<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a>;
<a name="l02579"></a>02579       *default_line = cursal.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a>;
<a name="l02580"></a>02580     }
<a name="l02581"></a>02581 }
<a name="l02582"></a>02582 
<a name="l02583"></a>02583 
<a name="l02584"></a>02584 
<a name="l02585"></a>02585 <span class="comment">/* Evaluate the expression pointed to by EXP_PTR into a CORE_ADDR,</span>
<a name="l02586"></a>02586 <span class="comment">   advancing EXP_PTR past any parsed text.  */</span>
<a name="l02587"></a>02587 
<a name="l02588"></a>02588 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l02589"></a><a class="code" href="linespec_8c.html#aa339d8b806f7f77d62dfa9179713c5d5">02589</a> <a class="code" href="linespec_8c.html#aa339d8b806f7f77d62dfa9179713c5d5">linespec_expression_to_pc</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> **exp_ptr)
<a name="l02590"></a>02590 {
<a name="l02591"></a>02591   <span class="keywordflow">if</span> (<a class="code" href="progspace_8c.html#a07722ff15a98814c086dda44f93380c9">current_program_space</a>-&gt;<a class="code" href="structprogram__space.html#a66c8a669a715e0f3c717bf0fd8951724">executing_startup</a>)
<a name="l02592"></a>02592     <span class="comment">/* The error message doesn&#39;t really matter, because this case</span>
<a name="l02593"></a>02593 <span class="comment">       should only hit during breakpoint reset.  */</span>
<a name="l02594"></a>02594     <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot evaluate expressions while &quot;</span>
<a name="l02595"></a>02595                                     <span class="stringliteral">&quot;program space is in startup&quot;</span>));
<a name="l02596"></a>02596 
<a name="l02597"></a>02597   (*exp_ptr)++;
<a name="l02598"></a>02598   <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a2e64d8ca2ab5480e05097c6b2df1aa02">value_as_address</a> (<a class="code" href="eval_8c.html#a5327f4a6f2481c9f8d6c13bb9b621688">parse_to_comma_and_eval</a> (exp_ptr));
<a name="l02599"></a>02599 }
<a name="l02600"></a>02600 
<a name="l02601"></a>02601 
<a name="l02602"></a>02602 
<a name="l02603"></a>02603 <span class="comment">/* Here&#39;s where we recognise an Objective-C Selector.  An Objective C</span>
<a name="l02604"></a>02604 <span class="comment">   selector may be implemented by more than one class, therefore it</span>
<a name="l02605"></a>02605 <span class="comment">   may represent more than one method/function.  This gives us a</span>
<a name="l02606"></a>02606 <span class="comment">   situation somewhat analogous to C++ overloading.  If there&#39;s more</span>
<a name="l02607"></a>02607 <span class="comment">   than one method that could represent the selector, then use some of</span>
<a name="l02608"></a>02608 <span class="comment">   the existing C++ code to let the user choose one.  */</span>
<a name="l02609"></a>02609 
<a name="l02610"></a>02610 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a>
<a name="l02611"></a><a class="code" href="linespec_8c.html#a57904262d36d2d6d5c1dfaf9cb181e2e">02611</a> <a class="code" href="linespec_8c.html#a57904262d36d2d6d5c1dfaf9cb181e2e">decode_objc</a> (struct <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>, linespec_p ls, <span class="keyword">const</span> <span class="keywordtype">char</span> **argptr)
<a name="l02612"></a>02612 {
<a name="l02613"></a>02613   <span class="keyword">struct </span><a class="code" href="structcollect__info.html">collect_info</a> info;
<a name="l02614"></a>02614   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>) *symbol_names = NULL;
<a name="l02615"></a>02615   <span class="keyword">struct </span><a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> values;
<a name="l02616"></a>02616   <span class="keyword">const</span> <span class="keywordtype">char</span> *new_argptr;
<a name="l02617"></a>02617   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a> = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="vec_8h.html#a92a6114eb727b9274e1523d0e9dd2e61">VEC_cleanup</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>),
<a name="l02618"></a>02618                                           &amp;symbol_names);
<a name="l02619"></a>02619 
<a name="l02620"></a>02620   info.<a class="code" href="structcollect__info.html#ac705a97bd9a86bbe604d50e5b2a1019e">state</a> = <span class="keyword">self</span>;
<a name="l02621"></a>02621   info.file_symtabs = NULL;
<a name="l02622"></a>02622   <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, info.file_symtabs, NULL);
<a name="l02623"></a>02623   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="vec_8h.html#a92a6114eb727b9274e1523d0e9dd2e61">VEC_cleanup</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>), &amp;info.file_symtabs);
<a name="l02624"></a>02624   info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.symbols = NULL;
<a name="l02625"></a>02625   info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.minimal_symbols = NULL;
<a name="l02626"></a>02626   values.<a class="code" href="structsymtabs__and__lines.html#a1c8b832fc2f8c096c95144a2acedd36a">nelts</a> = 0;
<a name="l02627"></a>02627   values.<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a> = NULL;
<a name="l02628"></a>02628 
<a name="l02629"></a>02629   new_argptr = <a class="code" href="objc-lang_8c.html#a21137af45dfab935797a6bc6eaf71298">find_imps</a> (*argptr, &amp;symbol_names); 
<a name="l02630"></a>02630   <span class="keywordflow">if</span> (<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>, symbol_names))
<a name="l02631"></a>02631     {
<a name="l02632"></a>02632       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l02633"></a>02633       <span class="keywordflow">return</span> values;
<a name="l02634"></a>02634     }
<a name="l02635"></a>02635 
<a name="l02636"></a>02636   <a class="code" href="linespec_8c.html#a13d81637e51dfec2090f555b8c5af46f">add_all_symbol_names_from_pspace</a> (&amp;info, NULL, symbol_names);
<a name="l02637"></a>02637 
<a name="l02638"></a>02638   <span class="keywordflow">if</span> (!<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (symbolp, info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.symbols)
<a name="l02639"></a>02639       || !<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.minimal_symbols))
<a name="l02640"></a>02640     {
<a name="l02641"></a>02641       <span class="keywordtype">char</span> *saved_arg;
<a name="l02642"></a>02642 
<a name="l02643"></a>02643       saved_arg = alloca (new_argptr - *argptr + 1);
<a name="l02644"></a>02644       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (saved_arg, *argptr, new_argptr - *argptr);
<a name="l02645"></a>02645       saved_arg[new_argptr - *argptr] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l02646"></a>02646 
<a name="l02647"></a>02647       ls-&gt;function_name = xstrdup (saved_arg);
<a name="l02648"></a>02648       ls-&gt;function_symbols = info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.symbols;
<a name="l02649"></a>02649       ls-&gt;minimal_symbols = info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.minimal_symbols;
<a name="l02650"></a>02650       values = <a class="code" href="linespec_8c.html#a75da5dad27012741422eaf456b0b1595">convert_linespec_to_sals</a> (<span class="keyword">self</span>, ls);
<a name="l02651"></a>02651 
<a name="l02652"></a>02652       <span class="keywordflow">if</span> (self-&gt;canonical)
<a name="l02653"></a>02653         {
<a name="l02654"></a>02654           <span class="keyword">self</span>-&gt;canonical-&gt;pre_expanded = 1;
<a name="l02655"></a>02655           <span class="keywordflow">if</span> (ls-&gt;source_filename)
<a name="l02656"></a>02656             <span class="keyword">self</span>-&gt;canonical-&gt;addr_string
<a name="l02657"></a>02657               = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;%s:%s&quot;</span>, ls-&gt;source_filename, saved_arg);
<a name="l02658"></a>02658           <span class="keywordflow">else</span>
<a name="l02659"></a>02659             <span class="keyword">self</span>-&gt;canonical-&gt;addr_string = xstrdup (saved_arg);
<a name="l02660"></a>02660         }
<a name="l02661"></a>02661     }
<a name="l02662"></a>02662 
<a name="l02663"></a>02663   *argptr = new_argptr;
<a name="l02664"></a>02664 
<a name="l02665"></a>02665   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l02666"></a>02666 
<a name="l02667"></a>02667   <span class="keywordflow">return</span> values;
<a name="l02668"></a>02668 }
<a name="l02669"></a>02669 
<a name="l02670"></a>02670 <span class="comment">/* An instance of this type is used when collecting prefix symbols for</span>
<a name="l02671"></a>02671 <span class="comment">   decode_compound.  */</span>
<a name="l02672"></a>02672 
<a name="l02673"></a><a class="code" href="structdecode__compound__collector.html">02673</a> <span class="keyword">struct </span><a class="code" href="structdecode__compound__collector.html">decode_compound_collector</a>
<a name="l02674"></a>02674 {
<a name="l02675"></a>02675   <span class="comment">/* The result vector.  */</span>
<a name="l02676"></a>02676   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) *symbols;
<a name="l02677"></a>02677 
<a name="l02678"></a>02678   <span class="comment">/* A hash table of all symbols we found.  We use this to avoid</span>
<a name="l02679"></a>02679 <span class="comment">     adding any symbol more than once.  */</span>
<a name="l02680"></a>02680   htab_t unique_syms;
<a name="l02681"></a>02681 };
<a name="l02682"></a>02682 
<a name="l02683"></a>02683 <span class="comment">/* A callback for iterate_over_symbols that is used by</span>
<a name="l02684"></a>02684 <span class="comment">   lookup_prefix_sym to collect type symbols.  */</span>
<a name="l02685"></a>02685 
<a name="l02686"></a>02686 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02687"></a><a class="code" href="linespec_8c.html#a2b83f379845c68c2349d21d4dbdfddc2">02687</a> <a class="code" href="linespec_8c.html#a2b83f379845c68c2349d21d4dbdfddc2">collect_one_symbol</a> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym, <span class="keywordtype">void</span> *d)
<a name="l02688"></a>02688 {
<a name="l02689"></a>02689   <span class="keyword">struct </span><a class="code" href="structdecode__compound__collector.html">decode_compound_collector</a> *collector = d;
<a name="l02690"></a>02690   <span class="keywordtype">void</span> **slot;
<a name="l02691"></a>02691   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *t;
<a name="l02692"></a>02692 
<a name="l02693"></a>02693   <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) != <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>)
<a name="l02694"></a>02694     <span class="keywordflow">return</span> 1; <span class="comment">/* Continue iterating.  */</span>
<a name="l02695"></a>02695 
<a name="l02696"></a>02696   t = <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym);
<a name="l02697"></a>02697   <a class="code" href="gdbtypes_8h.html#ae2f9348c644babaa9038b4dc18bffaac">CHECK_TYPEDEF</a> (t);
<a name="l02698"></a>02698   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l02699"></a>02699       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>
<a name="l02700"></a>02700       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae5cdf73186d3029211503380f64949b6">TYPE_CODE_NAMESPACE</a>)
<a name="l02701"></a>02701     <span class="keywordflow">return</span> 1; <span class="comment">/* Continue iterating.  */</span>
<a name="l02702"></a>02702 
<a name="l02703"></a>02703   slot = htab_find_slot (collector-&gt;unique_syms, sym, INSERT);
<a name="l02704"></a>02704   <span class="keywordflow">if</span> (!*slot)
<a name="l02705"></a>02705     {
<a name="l02706"></a>02706       *slot = sym;
<a name="l02707"></a>02707       <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (symbolp, collector-&gt;symbols, sym);
<a name="l02708"></a>02708     }
<a name="l02709"></a>02709 
<a name="l02710"></a>02710   <span class="keywordflow">return</span> 1; <span class="comment">/* Continue iterating.  */</span>
<a name="l02711"></a>02711 }
<a name="l02712"></a>02712 
<a name="l02713"></a>02713 <span class="comment">/* Return any symbols corresponding to CLASS_NAME in FILE_SYMTABS.  */</span>
<a name="l02714"></a>02714 
<a name="l02715"></a><a class="code" href="linespec_8c.html#a7a775e4c27287d2fcc43acb25956f5eb">02715</a> <span class="keyword">static</span> <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) *
<a name="l02716"></a>02716 lookup_prefix_sym (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *state, <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) *file_symtabs,
<a name="l02717"></a>02717                    <span class="keyword">const</span> <span class="keywordtype">char</span> *class_name)
<a name="l02718"></a>02718 {
<a name="l02719"></a>02719   <span class="keywordtype">int</span> ix;
<a name="l02720"></a>02720   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *elt;
<a name="l02721"></a>02721   <span class="keyword">struct </span><a class="code" href="structdecode__compound__collector.html">decode_compound_collector</a> collector;
<a name="l02722"></a>02722   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *outer;
<a name="l02723"></a>02723   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l02724"></a>02724 
<a name="l02725"></a>02725   collector.symbols = NULL;
<a name="l02726"></a>02726   outer = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="vec_8h.html#a92a6114eb727b9274e1523d0e9dd2e61">VEC_cleanup</a> (symbolp), &amp;collector.symbols);
<a name="l02727"></a>02727 
<a name="l02728"></a>02728   collector.unique_syms = htab_create_alloc (1, htab_hash_pointer,
<a name="l02729"></a>02729                                              htab_eq_pointer, NULL,
<a name="l02730"></a>02730                                              <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a>, <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>);
<a name="l02731"></a>02731   cleanup = <a class="code" href="utils_8c.html#ad5977a7d9e282b65846100111cd95c76">make_cleanup_htab_delete</a> (collector.unique_syms);
<a name="l02732"></a>02732 
<a name="l02733"></a>02733   <span class="keywordflow">for</span> (ix = 0; <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, file_symtabs, ix, elt); ++ix)
<a name="l02734"></a>02734     {
<a name="l02735"></a>02735       <span class="keywordflow">if</span> (elt == NULL)
<a name="l02736"></a>02736         {
<a name="l02737"></a>02737           <a class="code" href="linespec_8c.html#ad601fce792b86d88730bf57a2703cbba">iterate_over_all_matching_symtabs</a> (state, class_name, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa1f05a16e681efd2e892974878c353f11">STRUCT_DOMAIN</a>,
<a name="l02738"></a>02738                                              <a class="code" href="linespec_8c.html#a2b83f379845c68c2349d21d4dbdfddc2">collect_one_symbol</a>, &amp;collector,
<a name="l02739"></a>02739                                              NULL, 0);
<a name="l02740"></a>02740           <a class="code" href="linespec_8c.html#ad601fce792b86d88730bf57a2703cbba">iterate_over_all_matching_symtabs</a> (state, class_name, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>,
<a name="l02741"></a>02741                                              <a class="code" href="linespec_8c.html#a2b83f379845c68c2349d21d4dbdfddc2">collect_one_symbol</a>, &amp;collector,
<a name="l02742"></a>02742                                              NULL, 0);
<a name="l02743"></a>02743         }
<a name="l02744"></a>02744       <span class="keywordflow">else</span>
<a name="l02745"></a>02745         {
<a name="l02746"></a>02746           <span class="comment">/* Program spaces that are executing startup should have</span>
<a name="l02747"></a>02747 <span class="comment">             been filtered out earlier.  */</span>
<a name="l02748"></a>02748           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!<a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (elt)-&gt;executing_startup);
<a name="l02749"></a>02749           <a class="code" href="progspace_8c.html#a394457638b3e584a3ecd019df372209f">set_current_program_space</a> (<a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (elt));
<a name="l02750"></a>02750           <a class="code" href="linespec_8c.html#a69960965426eda86edc8cda619e5918e">iterate_over_file_blocks</a> (elt, class_name, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa1f05a16e681efd2e892974878c353f11">STRUCT_DOMAIN</a>,
<a name="l02751"></a>02751                                     <a class="code" href="linespec_8c.html#a2b83f379845c68c2349d21d4dbdfddc2">collect_one_symbol</a>, &amp;collector);
<a name="l02752"></a>02752           <a class="code" href="linespec_8c.html#a69960965426eda86edc8cda619e5918e">iterate_over_file_blocks</a> (elt, class_name, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>,
<a name="l02753"></a>02753                                     <a class="code" href="linespec_8c.html#a2b83f379845c68c2349d21d4dbdfddc2">collect_one_symbol</a>, &amp;collector);
<a name="l02754"></a>02754         }
<a name="l02755"></a>02755     }
<a name="l02756"></a>02756 
<a name="l02757"></a>02757   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l02758"></a>02758   <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (outer);
<a name="l02759"></a>02759   <span class="keywordflow">return</span> collector.symbols;
<a name="l02760"></a>02760 }
<a name="l02761"></a>02761 
<a name="l02762"></a>02762 <span class="comment">/* A qsort comparison function for symbols.  The resulting order does</span>
<a name="l02763"></a>02763 <span class="comment">   not actually matter; we just need to be able to sort them so that</span>
<a name="l02764"></a>02764 <span class="comment">   symbols with the same program space end up next to each other.  */</span>
<a name="l02765"></a>02765 
<a name="l02766"></a>02766 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02767"></a><a class="code" href="linespec_8c.html#acb5414cbc70f2fd3932d5448208cfc3c">02767</a> <a class="code" href="linespec_8c.html#acb5414cbc70f2fd3932d5448208cfc3c">compare_symbols</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)
<a name="l02768"></a>02768 {
<a name="l02769"></a>02769   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> * <span class="keyword">const</span> *sa = a;
<a name="l02770"></a>02770   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> * <span class="keyword">const</span> *sb = b;
<a name="l02771"></a>02771   uintptr_t uia, uib;
<a name="l02772"></a>02772 
<a name="l02773"></a>02773   uia = (uintptr_t) <a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (<a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (*sa));
<a name="l02774"></a>02774   uib = (uintptr_t) <a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (<a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (*sb));
<a name="l02775"></a>02775 
<a name="l02776"></a>02776   <span class="keywordflow">if</span> (uia &lt; uib)
<a name="l02777"></a>02777     <span class="keywordflow">return</span> -1;
<a name="l02778"></a>02778   <span class="keywordflow">if</span> (uia &gt; uib)
<a name="l02779"></a>02779     <span class="keywordflow">return</span> 1;
<a name="l02780"></a>02780 
<a name="l02781"></a>02781   uia = (uintptr_t) *sa;
<a name="l02782"></a>02782   uib = (uintptr_t) *sb;
<a name="l02783"></a>02783 
<a name="l02784"></a>02784   <span class="keywordflow">if</span> (uia &lt; uib)
<a name="l02785"></a>02785     <span class="keywordflow">return</span> -1;
<a name="l02786"></a>02786   <span class="keywordflow">if</span> (uia &gt; uib)
<a name="l02787"></a>02787     <span class="keywordflow">return</span> 1;
<a name="l02788"></a>02788 
<a name="l02789"></a>02789   <span class="keywordflow">return</span> 0;
<a name="l02790"></a>02790 }
<a name="l02791"></a>02791 
<a name="l02792"></a>02792 <span class="comment">/* Like compare_symbols but for minimal symbols.  */</span>
<a name="l02793"></a>02793 
<a name="l02794"></a>02794 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02795"></a><a class="code" href="linespec_8c.html#a70dc083f4402e21d9de69d372c31dc4e">02795</a> <a class="code" href="linespec_8c.html#a70dc083f4402e21d9de69d372c31dc4e">compare_msymbols</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)
<a name="l02796"></a>02796 {
<a name="l02797"></a>02797   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol</a> *sa = a;
<a name="l02798"></a>02798   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol</a> *sb = b;
<a name="l02799"></a>02799   uintptr_t uia, uib;
<a name="l02800"></a>02800 
<a name="l02801"></a>02801   uia = (uintptr_t) sa-&gt;<a class="code" href="structbound__minimal__symbol.html#a070e0e47d191675f0f4892e0b321d663">objfile</a>-&gt;<a class="code" href="structobjfile.html#a1f6ab738ce0b1fb1588709351b0c9091">pspace</a>;
<a name="l02802"></a>02802   uib = (uintptr_t) sa-&gt;<a class="code" href="structbound__minimal__symbol.html#a070e0e47d191675f0f4892e0b321d663">objfile</a>-&gt;<a class="code" href="structobjfile.html#a1f6ab738ce0b1fb1588709351b0c9091">pspace</a>;
<a name="l02803"></a>02803 
<a name="l02804"></a>02804   <span class="keywordflow">if</span> (uia &lt; uib)
<a name="l02805"></a>02805     <span class="keywordflow">return</span> -1;
<a name="l02806"></a>02806   <span class="keywordflow">if</span> (uia &gt; uib)
<a name="l02807"></a>02807     <span class="keywordflow">return</span> 1;
<a name="l02808"></a>02808 
<a name="l02809"></a>02809   uia = (uintptr_t) sa-&gt;<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>;
<a name="l02810"></a>02810   uib = (uintptr_t) sb-&gt;<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>;
<a name="l02811"></a>02811 
<a name="l02812"></a>02812   <span class="keywordflow">if</span> (uia &lt; uib)
<a name="l02813"></a>02813     <span class="keywordflow">return</span> -1;
<a name="l02814"></a>02814   <span class="keywordflow">if</span> (uia &gt; uib)
<a name="l02815"></a>02815     <span class="keywordflow">return</span> 1;
<a name="l02816"></a>02816 
<a name="l02817"></a>02817   <span class="keywordflow">return</span> 0;
<a name="l02818"></a>02818 }
<a name="l02819"></a>02819 
<a name="l02820"></a>02820 <span class="comment">/* Look for all the matching instances of each symbol in NAMES.  Only</span>
<a name="l02821"></a>02821 <span class="comment">   instances from PSPACE are considered; other program spaces are</span>
<a name="l02822"></a>02822 <span class="comment">   handled by our caller.  If PSPACE is NULL, then all program spaces</span>
<a name="l02823"></a>02823 <span class="comment">   are considered.  Results are stored into INFO.  */</span>
<a name="l02824"></a>02824 
<a name="l02825"></a>02825 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02826"></a><a class="code" href="linespec_8c.html#a13d81637e51dfec2090f555b8c5af46f">02826</a> <a class="code" href="linespec_8c.html#a13d81637e51dfec2090f555b8c5af46f">add_all_symbol_names_from_pspace</a> (<span class="keyword">struct</span> <a class="code" href="structcollect__info.html">collect_info</a> *info,
<a name="l02827"></a>02827                                   <span class="keyword">struct</span> <a class="code" href="structprogram__space.html">program_space</a> *pspace,
<a name="l02828"></a>02828                                   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>) *names)
<a name="l02829"></a>02829 {
<a name="l02830"></a>02830   <span class="keywordtype">int</span> ix;
<a name="l02831"></a>02831   <span class="keyword">const</span> <span class="keywordtype">char</span> *iter;
<a name="l02832"></a>02832 
<a name="l02833"></a>02833   <span class="keywordflow">for</span> (ix = 0; <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>, names, ix, iter); ++ix)
<a name="l02834"></a>02834     <a class="code" href="linespec_8c.html#a9a911b477c6a45e4fd33ada11d1a1db8">add_matching_symbols_to_info</a> (iter, info, pspace);
<a name="l02835"></a>02835 }
<a name="l02836"></a>02836 
<a name="l02837"></a>02837 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02838"></a><a class="code" href="linespec_8c.html#a76c49630e4961a63ec0baa067c1a1c44">02838</a> <a class="code" href="linespec_8c.html#a76c49630e4961a63ec0baa067c1a1c44">find_superclass_methods</a> (<a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (typep) *superclasses,
<a name="l02839"></a>02839                          <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l02840"></a>02840                          <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>) **result_names)
<a name="l02841"></a>02841 {
<a name="l02842"></a>02842   <span class="keywordtype">int</span> old_len = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>, *result_names);
<a name="l02843"></a>02843   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (typep) *iter_classes;
<a name="l02844"></a>02844   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a> = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, NULL);
<a name="l02845"></a>02845 
<a name="l02846"></a>02846   iter_classes = superclasses;
<a name="l02847"></a>02847   <span class="keywordflow">while</span> (1)
<a name="l02848"></a>02848     {
<a name="l02849"></a>02849       <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (typep) *new_supers = NULL;
<a name="l02850"></a>02850       <span class="keywordtype">int</span> ix;
<a name="l02851"></a>02851       <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *t;
<a name="l02852"></a>02852 
<a name="l02853"></a>02853       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="vec_8h.html#a92a6114eb727b9274e1523d0e9dd2e61">VEC_cleanup</a> (typep), &amp;new_supers);
<a name="l02854"></a>02854       <span class="keywordflow">for</span> (ix = 0; <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (typep, iter_classes, ix, t); ++ix)
<a name="l02855"></a>02855         <a class="code" href="linespec_8c.html#aa15d13cd1d9d59f8f67c87aea9f03840">find_methods</a> (t, name, result_names, &amp;new_supers);
<a name="l02856"></a>02856 
<a name="l02857"></a>02857       <span class="keywordflow">if</span> (<a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>, *result_names) != old_len
<a name="l02858"></a>02858           || <a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (typep, new_supers))
<a name="l02859"></a>02859         <span class="keywordflow">break</span>;
<a name="l02860"></a>02860 
<a name="l02861"></a>02861       iter_classes = new_supers;
<a name="l02862"></a>02862     }
<a name="l02863"></a>02863 
<a name="l02864"></a>02864   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l02865"></a>02865 }
<a name="l02866"></a>02866 
<a name="l02867"></a>02867 <span class="comment">/* This finds the method METHOD_NAME in the class CLASS_NAME whose type is</span>
<a name="l02868"></a>02868 <span class="comment">   given by one of the symbols in SYM_CLASSES.  Matches are returned</span>
<a name="l02869"></a>02869 <span class="comment">   in SYMBOLS (for debug symbols) and MINSYMS (for minimal symbols).  */</span>
<a name="l02870"></a>02870 
<a name="l02871"></a>02871 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02872"></a><a class="code" href="linespec_8c.html#aebdb4a21f3554cac7974b5477cdda67f">02872</a> <a class="code" href="linespec_8c.html#aebdb4a21f3554cac7974b5477cdda67f">find_method</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>, <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) *file_symtabs,
<a name="l02873"></a>02873              <span class="keyword">const</span> <span class="keywordtype">char</span> *class_name, <span class="keyword">const</span> <span class="keywordtype">char</span> *method_name,
<a name="l02874"></a>02874              <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) *sym_classes, <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) **symbols,
<a name="l02875"></a>02875              <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>) **minsyms)
<a name="l02876"></a>02876 {
<a name="l02877"></a>02877   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l02878"></a>02878   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a> = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, NULL);
<a name="l02879"></a>02879   <span class="keywordtype">int</span> ix;
<a name="l02880"></a>02880   <span class="keywordtype">int</span> last_result_len;
<a name="l02881"></a>02881   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (typep) *superclass_vec;
<a name="l02882"></a>02882   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>) *result_names;
<a name="l02883"></a>02883   <span class="keyword">struct </span><a class="code" href="structcollect__info.html">collect_info</a> info;
<a name="l02884"></a>02884 
<a name="l02885"></a>02885   <span class="comment">/* Sort symbols so that symbols with the same program space are next</span>
<a name="l02886"></a>02886 <span class="comment">     to each other.  */</span>
<a name="l02887"></a>02887   <a class="code" href="ada-exp_8c.html#a849e2297facde4d3c80dc4f45f8abbdb">qsort</a> (<a class="code" href="vec_8h.html#a99adc2006a668acc675e3758d9375ad5">VEC_address</a> (symbolp, sym_classes),
<a name="l02888"></a>02888          <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (symbolp, sym_classes),
<a name="l02889"></a>02889          <span class="keyword">sizeof</span> (symbolp),
<a name="l02890"></a>02890          <a class="code" href="linespec_8c.html#acb5414cbc70f2fd3932d5448208cfc3c">compare_symbols</a>);
<a name="l02891"></a>02891 
<a name="l02892"></a>02892   info.<a class="code" href="structcollect__info.html#ac705a97bd9a86bbe604d50e5b2a1019e">state</a> = <span class="keyword">self</span>;
<a name="l02893"></a>02893   info.file_symtabs = file_symtabs;
<a name="l02894"></a>02894   info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.symbols = NULL;
<a name="l02895"></a>02895   info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.minimal_symbols = NULL;
<a name="l02896"></a>02896 
<a name="l02897"></a>02897   <span class="comment">/* Iterate over all the types, looking for the names of existing</span>
<a name="l02898"></a>02898 <span class="comment">     methods matching METHOD_NAME.  If we cannot find a direct method in a</span>
<a name="l02899"></a>02899 <span class="comment">     given program space, then we consider inherited methods; this is</span>
<a name="l02900"></a>02900 <span class="comment">     not ideal (ideal would be to respect C++ hiding rules), but it</span>
<a name="l02901"></a>02901 <span class="comment">     seems good enough and is what GDB has historically done.  We only</span>
<a name="l02902"></a>02902 <span class="comment">     need to collect the names because later we find all symbols with</span>
<a name="l02903"></a>02903 <span class="comment">     those names.  This loop is written in a somewhat funny way</span>
<a name="l02904"></a>02904 <span class="comment">     because we collect data across the program space before deciding</span>
<a name="l02905"></a>02905 <span class="comment">     what to do.  */</span>
<a name="l02906"></a>02906   superclass_vec = NULL;
<a name="l02907"></a>02907   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="vec_8h.html#a92a6114eb727b9274e1523d0e9dd2e61">VEC_cleanup</a> (typep), &amp;superclass_vec);
<a name="l02908"></a>02908   result_names = NULL;
<a name="l02909"></a>02909   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="vec_8h.html#a92a6114eb727b9274e1523d0e9dd2e61">VEC_cleanup</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>), &amp;result_names);
<a name="l02910"></a>02910   last_result_len = 0;
<a name="l02911"></a>02911   <span class="keywordflow">for</span> (ix = 0; <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (symbolp, sym_classes, ix, sym); ++ix)
<a name="l02912"></a>02912     {
<a name="l02913"></a>02913       <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *t;
<a name="l02914"></a>02914       <span class="keyword">struct </span><a class="code" href="structprogram__space.html">program_space</a> *pspace;
<a name="l02915"></a>02915 
<a name="l02916"></a>02916       <span class="comment">/* Program spaces that are executing startup should have</span>
<a name="l02917"></a>02917 <span class="comment">         been filtered out earlier.  */</span>
<a name="l02918"></a>02918       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!<a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (<a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (sym))-&gt;<a class="code" href="structprogram__space.html#a66c8a669a715e0f3c717bf0fd8951724">executing_startup</a>);
<a name="l02919"></a>02919       pspace = <a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (<a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (sym));
<a name="l02920"></a>02920       <a class="code" href="progspace_8c.html#a394457638b3e584a3ecd019df372209f">set_current_program_space</a> (pspace);
<a name="l02921"></a>02921       t = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym));
<a name="l02922"></a>02922       <a class="code" href="linespec_8c.html#aa15d13cd1d9d59f8f67c87aea9f03840">find_methods</a> (t, method_name, &amp;result_names, &amp;superclass_vec);
<a name="l02923"></a>02923 
<a name="l02924"></a>02924       <span class="comment">/* Handle all items from a single program space at once; and be</span>
<a name="l02925"></a>02925 <span class="comment">         sure not to miss the last batch.  */</span>
<a name="l02926"></a>02926       <span class="keywordflow">if</span> (ix == <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (symbolp, sym_classes) - 1
<a name="l02927"></a>02927           || (pspace
<a name="l02928"></a>02928               != <a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (<a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (<a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (symbolp, sym_classes,
<a name="l02929"></a>02929                                                           ix + 1)))))
<a name="l02930"></a>02930         {
<a name="l02931"></a>02931           <span class="comment">/* If we did not find a direct implementation anywhere in</span>
<a name="l02932"></a>02932 <span class="comment">             this program space, consider superclasses.  */</span>
<a name="l02933"></a>02933           <span class="keywordflow">if</span> (<a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>, result_names) == last_result_len)
<a name="l02934"></a>02934             <a class="code" href="linespec_8c.html#a76c49630e4961a63ec0baa067c1a1c44">find_superclass_methods</a> (superclass_vec, method_name,
<a name="l02935"></a>02935                                      &amp;result_names);
<a name="l02936"></a>02936 
<a name="l02937"></a>02937           <span class="comment">/* We have a list of candidate symbol names, so now we</span>
<a name="l02938"></a>02938 <span class="comment">             iterate over the symbol tables looking for all</span>
<a name="l02939"></a>02939 <span class="comment">             matches in this pspace.  */</span>
<a name="l02940"></a>02940           <a class="code" href="linespec_8c.html#a13d81637e51dfec2090f555b8c5af46f">add_all_symbol_names_from_pspace</a> (&amp;info, pspace, result_names);
<a name="l02941"></a>02941 
<a name="l02942"></a>02942           <a class="code" href="vec_8h.html#a7b3dd1d44acb431cf333c2406e1c000d">VEC_truncate</a> (typep, superclass_vec, 0);
<a name="l02943"></a>02943           last_result_len = <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>, result_names);
<a name="l02944"></a>02944         }
<a name="l02945"></a>02945     }
<a name="l02946"></a>02946 
<a name="l02947"></a>02947   <span class="keywordflow">if</span> (!<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (symbolp, info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.symbols)
<a name="l02948"></a>02948       || !<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.minimal_symbols))
<a name="l02949"></a>02949     {
<a name="l02950"></a>02950       *symbols = info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.symbols;
<a name="l02951"></a>02951       *minsyms = info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.minimal_symbols;
<a name="l02952"></a>02952       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l02953"></a>02953       <span class="keywordflow">return</span>;
<a name="l02954"></a>02954     }
<a name="l02955"></a>02955 
<a name="l02956"></a>02956   <span class="comment">/* Throw an NOT_FOUND_ERROR.  This will be caught by the caller</span>
<a name="l02957"></a>02957 <span class="comment">     and other attempts to locate the symbol will be made.  */</span>
<a name="l02958"></a>02958   <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;see caller, this text doesn&#39;t matter&quot;</span>));
<a name="l02959"></a>02959 }
<a name="l02960"></a>02960 
<a name="l02961"></a>02961 
<a name="l02962"></a>02962 
<a name="l02963"></a>02963 <span class="comment">/* This object is used when collecting all matching symtabs.  */</span>
<a name="l02964"></a>02964 
<a name="l02965"></a><a class="code" href="structsymtab__collector.html">02965</a> <span class="keyword">struct </span><a class="code" href="structsymtab__collector.html">symtab_collector</a>
<a name="l02966"></a>02966 {
<a name="l02967"></a>02967   <span class="comment">/* The result vector of symtabs.  */</span>
<a name="l02968"></a>02968   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) *symtabs;
<a name="l02969"></a>02969 
<a name="l02970"></a>02970   <span class="comment">/* This is used to ensure the symtabs are unique.  */</span>
<a name="l02971"></a>02971   htab_t symtab_table;
<a name="l02972"></a>02972 };
<a name="l02973"></a>02973 
<a name="l02974"></a>02974 <span class="comment">/* Callback for iterate_over_symtabs.  */</span>
<a name="l02975"></a>02975 
<a name="l02976"></a>02976 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02977"></a><a class="code" href="linespec_8c.html#a59e1ffb110dc02bfbdac0d7fa2eb4c96">02977</a> <a class="code" href="linespec_8c.html#a59e1ffb110dc02bfbdac0d7fa2eb4c96">add_symtabs_to_list</a> (<span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structsymtab.html">symtab</a>, <span class="keywordtype">void</span> *d)
<a name="l02978"></a>02978 {
<a name="l02979"></a>02979   <span class="keyword">struct </span><a class="code" href="structsymtab__collector.html">symtab_collector</a> *data = d;
<a name="l02980"></a>02980   <span class="keywordtype">void</span> **slot;
<a name="l02981"></a>02981 
<a name="l02982"></a>02982   slot = htab_find_slot (data-&gt;symtab_table, symtab, INSERT);
<a name="l02983"></a>02983   <span class="keywordflow">if</span> (!*slot)
<a name="l02984"></a>02984     {
<a name="l02985"></a>02985       *slot = symtab;
<a name="l02986"></a>02986       <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, data-&gt;symtabs, symtab);
<a name="l02987"></a>02987     }
<a name="l02988"></a>02988 
<a name="l02989"></a>02989   <span class="keywordflow">return</span> 0;
<a name="l02990"></a>02990 }
<a name="l02991"></a>02991 
<a name="l02992"></a>02992 <span class="comment">/* Given a file name, return a VEC of all matching symtabs.  */</span>
<a name="l02993"></a>02993 
<a name="l02994"></a><a class="code" href="linespec_8c.html#acce61016211166c4c936ef3e6b136569">02994</a> <span class="keyword">static</span> <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) *
<a name="l02995"></a>02995 collect_symtabs_from_filename (<span class="keyword">const</span> <span class="keywordtype">char</span> *file)
<a name="l02996"></a>02996 {
<a name="l02997"></a>02997   <span class="keyword">struct </span><a class="code" href="structsymtab__collector.html">symtab_collector</a> collector;
<a name="l02998"></a>02998   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *cleanups;
<a name="l02999"></a>02999   <span class="keyword">struct </span><a class="code" href="structprogram__space.html">program_space</a> *pspace;
<a name="l03000"></a>03000 
<a name="l03001"></a>03001   collector.symtabs = NULL;
<a name="l03002"></a>03002   collector.symtab_table = htab_create (1, htab_hash_pointer, htab_eq_pointer,
<a name="l03003"></a>03003                                         NULL);
<a name="l03004"></a>03004   cleanups = <a class="code" href="utils_8c.html#ad5977a7d9e282b65846100111cd95c76">make_cleanup_htab_delete</a> (collector.symtab_table);
<a name="l03005"></a>03005 
<a name="l03006"></a>03006   <span class="comment">/* Find that file&#39;s data.  */</span>
<a name="l03007"></a>03007   <a class="code" href="progspace_8h.html#a9e4091a3fcf8c96cb18cf2042cbe21f6">ALL_PSPACES</a> (pspace)
<a name="l03008"></a>03008   {
<a name="l03009"></a>03009     <span class="keywordflow">if</span> (pspace-&gt;<a class="code" href="structprogram__space.html#a66c8a669a715e0f3c717bf0fd8951724">executing_startup</a>)
<a name="l03010"></a>03010       <span class="keywordflow">continue</span>;
<a name="l03011"></a>03011 
<a name="l03012"></a>03012     <a class="code" href="progspace_8c.html#a394457638b3e584a3ecd019df372209f">set_current_program_space</a> (pspace);
<a name="l03013"></a>03013     <a class="code" href="symtab_8c.html#ae52367ee41cadb233f01d4dbed59eb7b">iterate_over_symtabs</a> (file, <a class="code" href="linespec_8c.html#a59e1ffb110dc02bfbdac0d7fa2eb4c96">add_symtabs_to_list</a>, &amp;collector);
<a name="l03014"></a>03014   }
<a name="l03015"></a>03015 
<a name="l03016"></a>03016   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l03017"></a>03017   <span class="keywordflow">return</span> collector.symtabs;
<a name="l03018"></a>03018 }
<a name="l03019"></a>03019 
<a name="l03020"></a>03020 <span class="comment">/* Return all the symtabs associated to the FILENAME.  */</span>
<a name="l03021"></a>03021 
<a name="l03022"></a>03022 <span class="keyword">static</span> <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) *
<a name="l03023"></a>03023 symtabs_from_filename (<span class="keyword">const</span> <span class="keywordtype">char</span> *filename)
<a name="l03024"></a>03024 {
<a name="l03025"></a>03025   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) *result;
<a name="l03026"></a>03026   
<a name="l03027"></a>03027   result = collect_symtabs_from_filename (filename);
<a name="l03028"></a>03028 
<a name="l03029"></a>03029   <span class="keywordflow">if</span> (<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, result))
<a name="l03030"></a>03030     {
<a name="l03031"></a>03031       <span class="keywordflow">if</span> (!<a class="code" href="objfiles_8c.html#aed27a8abad788fa9b74e13a3bb97c8ee">have_full_symbols</a> () &amp;&amp; !<a class="code" href="objfiles_8c.html#aa8d7d1a2b68ac871a50d0fcbca14518d">have_partial_symbols</a> ())
<a name="l03032"></a>03032         <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>,
<a name="l03033"></a>03033                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No symbol table is loaded.  &quot;</span>
<a name="l03034"></a>03034                        <span class="stringliteral">&quot;Use the \&quot;file\&quot; command.&quot;</span>));
<a name="l03035"></a>03035       <a class="code" href="exceptions_8c.html#a366e9b618421f1f94a3318e81cc0489c">throw_error</a> (<a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No source file named %s.&quot;</span>), filename);
<a name="l03036"></a>03036     }
<a name="l03037"></a>03037 
<a name="l03038"></a>03038   <span class="keywordflow">return</span> result;
<a name="l03039"></a>03039 }
<a name="l03040"></a>03040 
<a name="l03041"></a>03041 <span class="comment">/* Look up a function symbol named NAME in symtabs FILE_SYMTABS.  Matching</span>
<a name="l03042"></a>03042 <span class="comment">   debug symbols are returned in SYMBOLS.  Matching minimal symbols are</span>
<a name="l03043"></a>03043 <span class="comment">   returned in MINSYMS.  */</span>
<a name="l03044"></a>03044 
<a name="l03045"></a>03045 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03046"></a><a class="code" href="linespec_8c.html#a36ed038b3a9156393cb32bc38f2e6ba4">03046</a> <a class="code" href="linespec_8c.html#a36ed038b3a9156393cb32bc38f2e6ba4">find_function_symbols</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *state,
<a name="l03047"></a>03047                        <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) *file_symtabs, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l03048"></a>03048                        <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) **symbols,
<a name="l03049"></a>03049                        <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>) **minsyms)
<a name="l03050"></a>03050 {
<a name="l03051"></a>03051   <span class="keyword">struct </span><a class="code" href="structcollect__info.html">collect_info</a> info;
<a name="l03052"></a>03052   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>) *symbol_names = NULL;
<a name="l03053"></a>03053   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a> = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="vec_8h.html#a92a6114eb727b9274e1523d0e9dd2e61">VEC_cleanup</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>),
<a name="l03054"></a>03054                                           &amp;symbol_names);
<a name="l03055"></a>03055 
<a name="l03056"></a>03056   info.<a class="code" href="structcollect__info.html#ac705a97bd9a86bbe604d50e5b2a1019e">state</a> = state;
<a name="l03057"></a>03057   info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.symbols = NULL;
<a name="l03058"></a>03058   info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.minimal_symbols = NULL;
<a name="l03059"></a>03059   info.file_symtabs = file_symtabs;
<a name="l03060"></a>03060 
<a name="l03061"></a>03061   <span class="comment">/* Try NAME as an Objective-C selector.  */</span>
<a name="l03062"></a>03062   <a class="code" href="objc-lang_8c.html#a21137af45dfab935797a6bc6eaf71298">find_imps</a> (name, &amp;symbol_names);
<a name="l03063"></a>03063   <span class="keywordflow">if</span> (!<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (<a class="code" href="gdb__vecs_8h.html#a88d1fb873d629b523bfa7335f8819f98">const_char_ptr</a>, symbol_names))
<a name="l03064"></a>03064     <a class="code" href="linespec_8c.html#a13d81637e51dfec2090f555b8c5af46f">add_all_symbol_names_from_pspace</a> (&amp;info, NULL, symbol_names);
<a name="l03065"></a>03065   <span class="keywordflow">else</span>
<a name="l03066"></a>03066     <a class="code" href="linespec_8c.html#a9a911b477c6a45e4fd33ada11d1a1db8">add_matching_symbols_to_info</a> (name, &amp;info, NULL);
<a name="l03067"></a>03067 
<a name="l03068"></a>03068   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l03069"></a>03069 
<a name="l03070"></a>03070   <span class="keywordflow">if</span> (<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (symbolp, info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.symbols))
<a name="l03071"></a>03071     {
<a name="l03072"></a>03072       <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (symbolp, info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.symbols);
<a name="l03073"></a>03073       *symbols = NULL;
<a name="l03074"></a>03074     }
<a name="l03075"></a>03075   <span class="keywordflow">else</span>
<a name="l03076"></a>03076     *symbols = info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.symbols;
<a name="l03077"></a>03077 
<a name="l03078"></a>03078   <span class="keywordflow">if</span> (<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.minimal_symbols))
<a name="l03079"></a>03079     {
<a name="l03080"></a>03080       <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.minimal_symbols);
<a name="l03081"></a>03081       *minsyms = NULL;
<a name="l03082"></a>03082     }
<a name="l03083"></a>03083   <span class="keywordflow">else</span>
<a name="l03084"></a>03084     *minsyms = info.<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.minimal_symbols;
<a name="l03085"></a>03085 }
<a name="l03086"></a>03086 
<a name="l03087"></a>03087 <span class="comment">/* Find all symbols named NAME in FILE_SYMTABS, returning debug symbols</span>
<a name="l03088"></a>03088 <span class="comment">   in SYMBOLS and minimal symbols in MINSYMS.  */</span>
<a name="l03089"></a>03089 
<a name="l03090"></a>03090 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03091"></a><a class="code" href="linespec_8c.html#aade11e4b850f57d619e2c4f2a841942f">03091</a> <a class="code" href="linespec_8c.html#aade11e4b850f57d619e2c4f2a841942f">find_linespec_symbols</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *state,
<a name="l03092"></a>03092                        <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>) *file_symtabs,
<a name="l03093"></a>03093                        <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l03094"></a>03094                        <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) **symbols,
<a name="l03095"></a>03095                        <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>) **minsyms)
<a name="l03096"></a>03096 {
<a name="l03097"></a>03097   <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l03098"></a>03098   <span class="keywordtype">char</span> *canon;
<a name="l03099"></a>03099   <span class="keyword">const</span> <span class="keywordtype">char</span> *lookup_name;
<a name="l03100"></a>03100   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> except;
<a name="l03101"></a>03101 
<a name="l03102"></a>03102   cleanup = <a class="code" href="symtab_8c.html#a662dc740bb7969e0cfff6bdb5a19d521">demangle_for_lookup</a> (name, state-&gt;<a class="code" href="structlinespec__state.html#a075a4742ad9d3652c6dd46765f84a0cb">language</a>-&gt;<a class="code" href="structlanguage__defn.html#a1395b7eb05a09e5798dc29257f30810a">la_language</a>,
<a name="l03103"></a>03103                                  &amp;lookup_name);
<a name="l03104"></a>03104   <span class="keywordflow">if</span> (state-&gt;<a class="code" href="structlinespec__state.html#a075a4742ad9d3652c6dd46765f84a0cb">language</a>-&gt;<a class="code" href="structlanguage__defn.html#a1395b7eb05a09e5798dc29257f30810a">la_language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l03105"></a>03105     {
<a name="l03106"></a>03106       <span class="comment">/* In Ada, the symbol lookups are performed using the encoded</span>
<a name="l03107"></a>03107 <span class="comment">         name rather than the demangled name.  */</span>
<a name="l03108"></a>03108       lookup_name = <a class="code" href="ada-lang_8c.html#af661b130d2c06e0913500e03a6bb26a2">ada_name_for_lookup</a> (name);
<a name="l03109"></a>03109       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, (<span class="keywordtype">void</span> *) lookup_name);
<a name="l03110"></a>03110     }
<a name="l03111"></a>03111 
<a name="l03112"></a>03112   canon = <a class="code" href="cp-support_8c.html#aaf9c874ab77ecdf8d9a4ceb0c4a8588f">cp_canonicalize_string_no_typedefs</a> (lookup_name);
<a name="l03113"></a>03113   <span class="keywordflow">if</span> (canon != NULL)
<a name="l03114"></a>03114     {
<a name="l03115"></a>03115       lookup_name = canon;
<a name="l03116"></a>03116       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, canon);
<a name="l03117"></a>03117     }
<a name="l03118"></a>03118 
<a name="l03119"></a>03119   <span class="comment">/* It&#39;s important to not call expand_symtabs_matching unnecessarily</span>
<a name="l03120"></a>03120 <span class="comment">     as it can really slow things down (by unnecessarily expanding</span>
<a name="l03121"></a>03121 <span class="comment">     potentially 1000s of symtabs, which when debugging some apps can</span>
<a name="l03122"></a>03122 <span class="comment">     cost 100s of seconds).  Avoid this to some extent by *first* calling</span>
<a name="l03123"></a>03123 <span class="comment">     find_function_symbols, and only if that doesn&#39;t find anything</span>
<a name="l03124"></a>03124 <span class="comment">     *then* call find_method.  This handles two important cases:</span>
<a name="l03125"></a>03125 <span class="comment">     1) break (anonymous namespace)::foo</span>
<a name="l03126"></a>03126 <span class="comment">     2) break class::method where method is in class (and not a baseclass)  */</span>
<a name="l03127"></a>03127 
<a name="l03128"></a>03128   <a class="code" href="linespec_8c.html#a36ed038b3a9156393cb32bc38f2e6ba4">find_function_symbols</a> (state, file_symtabs, lookup_name,
<a name="l03129"></a>03129                          symbols, minsyms);
<a name="l03130"></a>03130 
<a name="l03131"></a>03131   <span class="comment">/* If we were unable to locate a symbol of the same name, try dividing</span>
<a name="l03132"></a>03132 <span class="comment">     the name into class and method names and searching the class and its</span>
<a name="l03133"></a>03133 <span class="comment">     baseclasses.  */</span>
<a name="l03134"></a>03134   <span class="keywordflow">if</span> (<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (symbolp, *symbols)
<a name="l03135"></a>03135       &amp;&amp; <a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, *minsyms))
<a name="l03136"></a>03136     {
<a name="l03137"></a>03137       <span class="keywordtype">char</span> *klass, *method;
<a name="l03138"></a>03138       <span class="keyword">const</span> <span class="keywordtype">char</span> *last, *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>, *scope_op;
<a name="l03139"></a>03139       <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) *classes;
<a name="l03140"></a>03140 
<a name="l03141"></a>03141       <span class="comment">/* See if we can find a scope operator and break this symbol</span>
<a name="l03142"></a>03142 <span class="comment">         name into namespaces${SCOPE_OPERATOR}class_name and method_name.  */</span>
<a name="l03143"></a>03143       scope_op = <span class="stringliteral">&quot;::&quot;</span>;
<a name="l03144"></a>03144       p = <a class="code" href="linespec_8c.html#a82b623f622646a274151cec40f12153a">find_toplevel_string</a> (lookup_name, scope_op);
<a name="l03145"></a>03145       <span class="keywordflow">if</span> (p == NULL)
<a name="l03146"></a>03146         {
<a name="l03147"></a>03147           <span class="comment">/* No C++ scope operator.  Try Java.  */</span>
<a name="l03148"></a>03148           scope_op = <span class="stringliteral">&quot;.&quot;</span>;
<a name="l03149"></a>03149           p = <a class="code" href="linespec_8c.html#a82b623f622646a274151cec40f12153a">find_toplevel_string</a> (lookup_name, scope_op);
<a name="l03150"></a>03150         }
<a name="l03151"></a>03151 
<a name="l03152"></a>03152       last = NULL;
<a name="l03153"></a>03153       <span class="keywordflow">while</span> (p != NULL)
<a name="l03154"></a>03154         {
<a name="l03155"></a>03155           last = p;
<a name="l03156"></a>03156           p = <a class="code" href="linespec_8c.html#a82b623f622646a274151cec40f12153a">find_toplevel_string</a> (p + strlen (scope_op), scope_op);
<a name="l03157"></a>03157         }
<a name="l03158"></a>03158 
<a name="l03159"></a>03159       <span class="comment">/* If no scope operator was found, there is nothing more we can do;</span>
<a name="l03160"></a>03160 <span class="comment">         we already attempted to lookup the entire name as a symbol</span>
<a name="l03161"></a>03161 <span class="comment">         and failed.  */</span>
<a name="l03162"></a>03162       <span class="keywordflow">if</span> (last == NULL)
<a name="l03163"></a>03163         {
<a name="l03164"></a>03164           <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l03165"></a>03165           <span class="keywordflow">return</span>;
<a name="l03166"></a>03166         }
<a name="l03167"></a>03167 
<a name="l03168"></a>03168       <span class="comment">/* LOOKUP_NAME points to the class name.</span>
<a name="l03169"></a>03169 <span class="comment">         LAST points to the method name.  */</span>
<a name="l03170"></a>03170       klass = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> ((last - lookup_name + 1) * <span class="keyword">sizeof</span> (<span class="keywordtype">char</span>));
<a name="l03171"></a>03171       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, klass);
<a name="l03172"></a>03172       strncpy (klass, lookup_name, last - lookup_name);
<a name="l03173"></a>03173       klass[last - lookup_name] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03174"></a>03174 
<a name="l03175"></a>03175       <span class="comment">/* Skip past the scope operator.  */</span>
<a name="l03176"></a>03176       last += strlen (scope_op);
<a name="l03177"></a>03177       method = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> ((strlen (last) + 1) * <span class="keyword">sizeof</span> (<span class="keywordtype">char</span>));
<a name="l03178"></a>03178       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, method);
<a name="l03179"></a>03179       strcpy (method, last);
<a name="l03180"></a>03180 
<a name="l03181"></a>03181       <span class="comment">/* Find a list of classes named KLASS.  */</span>
<a name="l03182"></a>03182       classes = lookup_prefix_sym (state, file_symtabs, klass);
<a name="l03183"></a>03183       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="vec_8h.html#a92a6114eb727b9274e1523d0e9dd2e61">VEC_cleanup</a> (symbolp), &amp;classes);
<a name="l03184"></a>03184 
<a name="l03185"></a>03185       <span class="keywordflow">if</span> (!<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (symbolp, classes))
<a name="l03186"></a>03186         {
<a name="l03187"></a>03187           <span class="comment">/* Now locate a list of suitable methods named METHOD.  */</span>
<a name="l03188"></a>03188           <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l03189"></a>03189             {
<a name="l03190"></a>03190               <a class="code" href="linespec_8c.html#aebdb4a21f3554cac7974b5477cdda67f">find_method</a> (state, file_symtabs, klass, method, classes,
<a name="l03191"></a>03191                            symbols, minsyms);
<a name="l03192"></a>03192             }
<a name="l03193"></a>03193 
<a name="l03194"></a>03194           <span class="comment">/* If successful, we&#39;re done.  If NOT_FOUND_ERROR</span>
<a name="l03195"></a>03195 <span class="comment">             was not thrown, rethrow the exception that we did get.  */</span>
<a name="l03196"></a>03196           <span class="keywordflow">if</span> (except.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0 &amp;&amp; except.<a class="code" href="structgdb__exception.html#ab5a701a197af7b5c953242d029c18e75">error</a> != <a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a513a53522eb4741e8910f010e0ff9530">NOT_FOUND_ERROR</a>)
<a name="l03197"></a>03197             <a class="code" href="exceptions_8c.html#a541d1b545da68efe4f8b729a945f83e7">throw_exception</a> (except);
<a name="l03198"></a>03198         }
<a name="l03199"></a>03199     }
<a name="l03200"></a>03200 
<a name="l03201"></a>03201   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l03202"></a>03202 }
<a name="l03203"></a>03203 
<a name="l03204"></a>03204 <span class="comment">/* Return all labels named NAME in FUNCTION_SYMBOLS.  Return the</span>
<a name="l03205"></a>03205 <span class="comment">   actual function symbol in which the label was found in LABEL_FUNC_RET.  */</span>
<a name="l03206"></a>03206 
<a name="l03207"></a>03207 <span class="keyword">static</span> <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) *
<a name="l03208"></a>03208 find_label_symbols (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l03209"></a>03209                     <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) *function_symbols,
<a name="l03210"></a>03210                     <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) **label_funcs_ret, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l03211"></a>03211 {
<a name="l03212"></a>03212   <span class="keywordtype">int</span> ix;
<a name="l03213"></a>03213   <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>;
<a name="l03214"></a>03214   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l03215"></a>03215   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *fn_sym;
<a name="l03216"></a>03216   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (symbolp) *result = NULL;
<a name="l03217"></a>03217 
<a name="l03218"></a>03218   <span class="keywordflow">if</span> (function_symbols == NULL)
<a name="l03219"></a>03219     {
<a name="l03220"></a>03220       <a class="code" href="progspace_8c.html#a394457638b3e584a3ecd019df372209f">set_current_program_space</a> (self-&gt;program_space);
<a name="l03221"></a>03221       block = <a class="code" href="linespec_8c.html#a58710768d426155e3738efb013f279f4">get_current_search_block</a> ();
<a name="l03222"></a>03222 
<a name="l03223"></a>03223       <span class="keywordflow">for</span> (;
<a name="l03224"></a>03224            block &amp;&amp; !<a class="code" href="block_8h.html#aeea4a00e65c2be0c8674106f38d8ab65">BLOCK_FUNCTION</a> (block);
<a name="l03225"></a>03225            block = <a class="code" href="block_8h.html#a8b7633ab6d6feadf9b2ee58e10ad8397">BLOCK_SUPERBLOCK</a> (block))
<a name="l03226"></a>03226         ;
<a name="l03227"></a>03227       <span class="keywordflow">if</span> (!block)
<a name="l03228"></a>03228         <span class="keywordflow">return</span> NULL;
<a name="l03229"></a>03229       fn_sym = <a class="code" href="block_8h.html#aeea4a00e65c2be0c8674106f38d8ab65">BLOCK_FUNCTION</a> (block);
<a name="l03230"></a>03230 
<a name="l03231"></a>03231       sym = <a class="code" href="symtab_8c.html#a8a5c3f803198aed047a55c0e4f61b315">lookup_symbol</a> (name, block, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa56127af42926055244b2318cbdbc8413">LABEL_DOMAIN</a>, 0);
<a name="l03232"></a>03232 
<a name="l03233"></a>03233       <span class="keywordflow">if</span> (sym != NULL)
<a name="l03234"></a>03234         {
<a name="l03235"></a>03235           <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (symbolp, result, sym);
<a name="l03236"></a>03236           <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (symbolp, *label_funcs_ret, fn_sym);
<a name="l03237"></a>03237         }
<a name="l03238"></a>03238     }
<a name="l03239"></a>03239   <span class="keywordflow">else</span>
<a name="l03240"></a>03240     {
<a name="l03241"></a>03241       <span class="keywordflow">for</span> (ix = 0;
<a name="l03242"></a>03242            <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (symbolp, function_symbols, ix, fn_sym); ++ix)
<a name="l03243"></a>03243         {
<a name="l03244"></a>03244           <a class="code" href="progspace_8c.html#a394457638b3e584a3ecd019df372209f">set_current_program_space</a> (<a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (<a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (fn_sym)));
<a name="l03245"></a>03245           block = <a class="code" href="symtab_8h.html#a2c83ea82b28e9a9d8f9b655c2d502593">SYMBOL_BLOCK_VALUE</a> (fn_sym);
<a name="l03246"></a>03246           sym = <a class="code" href="symtab_8c.html#a8a5c3f803198aed047a55c0e4f61b315">lookup_symbol</a> (name, block, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa56127af42926055244b2318cbdbc8413">LABEL_DOMAIN</a>, 0);
<a name="l03247"></a>03247 
<a name="l03248"></a>03248           <span class="keywordflow">if</span> (sym != NULL)
<a name="l03249"></a>03249             {
<a name="l03250"></a>03250               <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (symbolp, result, sym);
<a name="l03251"></a>03251               <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (symbolp, *label_funcs_ret, fn_sym);
<a name="l03252"></a>03252             }
<a name="l03253"></a>03253         }
<a name="l03254"></a>03254     }
<a name="l03255"></a>03255 
<a name="l03256"></a>03256   <span class="keywordflow">return</span> result;
<a name="l03257"></a>03257 }
<a name="l03258"></a>03258 
<a name="l03259"></a>03259 
<a name="l03260"></a>03260 
<a name="l03261"></a>03261 <span class="comment">/* A helper for create_sals_line_offset that handles the &#39;list_mode&#39; case.  */</span>
<a name="l03262"></a>03262 
<a name="l03263"></a>03263 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03264"></a><a class="code" href="linespec_8c.html#a50516c9f4476c1915ea4a16a87e6482a">03264</a> <a class="code" href="linespec_8c.html#a50516c9f4476c1915ea4a16a87e6482a">decode_digits_list_mode</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l03265"></a>03265                          linespec_p ls,
<a name="l03266"></a>03266                          <span class="keyword">struct</span> <a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> *values,
<a name="l03267"></a>03267                          <span class="keyword">struct</span> <a class="code" href="structsymtab__and__line.html">symtab_and_line</a> val)
<a name="l03268"></a>03268 {
<a name="l03269"></a>03269   <span class="keywordtype">int</span> ix;
<a name="l03270"></a>03270   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *elt;
<a name="l03271"></a>03271 
<a name="l03272"></a>03272   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (self-&gt;list_mode);
<a name="l03273"></a>03273 
<a name="l03274"></a>03274   <span class="keywordflow">for</span> (ix = 0; <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, ls-&gt;file_symtabs, ix, elt);
<a name="l03275"></a>03275        ++ix)
<a name="l03276"></a>03276     {
<a name="l03277"></a>03277       <span class="comment">/* The logic above should ensure this.  */</span>
<a name="l03278"></a>03278       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (elt != NULL);
<a name="l03279"></a>03279 
<a name="l03280"></a>03280       <a class="code" href="progspace_8c.html#a394457638b3e584a3ecd019df372209f">set_current_program_space</a> (<a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (elt));
<a name="l03281"></a>03281 
<a name="l03282"></a>03282       <span class="comment">/* Simplistic search just for the list command.  */</span>
<a name="l03283"></a>03283       val.<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a> = <a class="code" href="symtab_8c.html#af46e4960b0ac5174414cff33bd291fad">find_line_symtab</a> (elt, val.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a>, NULL, NULL);
<a name="l03284"></a>03284       <span class="keywordflow">if</span> (val.<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a> == NULL)
<a name="l03285"></a>03285         val.<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a> = elt;
<a name="l03286"></a>03286       val.<a class="code" href="structsymtab__and__line.html#acc91f0276f4648cb5a970f17ddcbaf09">pspace</a> = <a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (elt);
<a name="l03287"></a>03287       val.<a class="code" href="structsymtab__and__line.html#a77665fa461ad187cb755efa256ba44d7">pc</a> = 0;
<a name="l03288"></a>03288       val.<a class="code" href="structsymtab__and__line.html#a410b4ee060f0de75397dd244fcad54da">explicit_line</a> = 1;
<a name="l03289"></a>03289 
<a name="l03290"></a>03290       <a class="code" href="linespec_8c.html#abe07dbe47bca0f2cfca183745cb34f7d">add_sal_to_sals</a> (<span class="keyword">self</span>, values, &amp;val, NULL, 0);
<a name="l03291"></a>03291     }
<a name="l03292"></a>03292 }
<a name="l03293"></a>03293 
<a name="l03294"></a>03294 <span class="comment">/* A helper for create_sals_line_offset that iterates over the symtabs,</span>
<a name="l03295"></a>03295 <span class="comment">   adding lines to the VEC.  */</span>
<a name="l03296"></a>03296 
<a name="l03297"></a>03297 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03298"></a><a class="code" href="linespec_8c.html#a27499bc4b74043e033d15c885f16d809">03298</a> <a class="code" href="linespec_8c.html#a27499bc4b74043e033d15c885f16d809">decode_digits_ordinary</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>,
<a name="l03299"></a>03299                         linespec_p ls,
<a name="l03300"></a>03300                         <span class="keywordtype">int</span> <a class="code" href="symtab_8h.html#a41ebd28ef1d7c6ade45642cb6acc1039">line</a>,
<a name="l03301"></a>03301                         <span class="keyword">struct</span> <a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> *sals,
<a name="l03302"></a>03302                         <span class="keyword">struct</span> <a class="code" href="structlinetable__entry.html">linetable_entry</a> **<a class="code" href="symtab_8h.html#ac5e7b5c1b729fc27d6717b73d9644f85">best_entry</a>)
<a name="l03303"></a>03303 {
<a name="l03304"></a>03304   <span class="keywordtype">int</span> ix;
<a name="l03305"></a>03305   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *elt;
<a name="l03306"></a>03306 
<a name="l03307"></a>03307   <span class="keywordflow">for</span> (ix = 0; <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, ls-&gt;file_symtabs, ix, elt); ++ix)
<a name="l03308"></a>03308     {
<a name="l03309"></a>03309       <span class="keywordtype">int</span> i;
<a name="l03310"></a>03310       <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) *pcs;
<a name="l03311"></a>03311       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc;
<a name="l03312"></a>03312 
<a name="l03313"></a>03313       <span class="comment">/* The logic above should ensure this.  */</span>
<a name="l03314"></a>03314       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (elt != NULL);
<a name="l03315"></a>03315 
<a name="l03316"></a>03316       <a class="code" href="progspace_8c.html#a394457638b3e584a3ecd019df372209f">set_current_program_space</a> (<a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (elt));
<a name="l03317"></a>03317 
<a name="l03318"></a>03318       pcs = find_pcs_for_symtab_line (elt, line, best_entry);
<a name="l03319"></a>03319       <span class="keywordflow">for</span> (i = 0; <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, pcs, i, pc); ++i)
<a name="l03320"></a>03320         {
<a name="l03321"></a>03321           <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a> sal;
<a name="l03322"></a>03322 
<a name="l03323"></a>03323           <a class="code" href="symtab_8c.html#aca3a01a4f0e1a09f99e8308faecc9028">init_sal</a> (&amp;sal);
<a name="l03324"></a>03324           sal.<a class="code" href="structsymtab__and__line.html#acc91f0276f4648cb5a970f17ddcbaf09">pspace</a> = <a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (elt);
<a name="l03325"></a>03325           sal.<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a> = elt;
<a name="l03326"></a>03326           sal.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a> = <a class="code" href="symtab_8h.html#a41ebd28ef1d7c6ade45642cb6acc1039">line</a>;
<a name="l03327"></a>03327           sal.<a class="code" href="structsymtab__and__line.html#a77665fa461ad187cb755efa256ba44d7">pc</a> = <a class="code" href="structsymtab__and__line.html#a77665fa461ad187cb755efa256ba44d7">pc</a>;
<a name="l03328"></a>03328           <a class="code" href="linespec_8c.html#adc0b6166d4a7ea4c37ccbd1468790954">add_sal_to_sals_basic</a> (sals, &amp;sal);
<a name="l03329"></a>03329         }
<a name="l03330"></a>03330 
<a name="l03331"></a>03331       <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, pcs);
<a name="l03332"></a>03332     }
<a name="l03333"></a>03333 }
<a name="l03334"></a>03334 
<a name="l03335"></a>03335 
<a name="l03336"></a>03336 
<a name="l03337"></a>03337 <span class="comment">/* Return the line offset represented by VARIABLE.  */</span>
<a name="l03338"></a>03338 
<a name="l03339"></a>03339 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structline__offset.html">line_offset</a>
<a name="l03340"></a><a class="code" href="linespec_8c.html#a4f9761a36dffbb858aa4123c570964fe">03340</a> <a class="code" href="linespec_8c.html#a4f9761a36dffbb858aa4123c570964fe">linespec_parse_variable</a> (struct <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *variable)
<a name="l03341"></a>03341 {
<a name="l03342"></a>03342   <span class="keywordtype">int</span> index = 0;
<a name="l03343"></a>03343   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>;
<a name="l03344"></a>03344   <span class="keyword">struct </span><a class="code" href="structline__offset.html">line_offset</a> offset = {0, <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376a6476a4ac46c8b156670deb1f9094a206">LINE_OFFSET_NONE</a>};
<a name="l03345"></a>03345 
<a name="l03346"></a>03346   p = (variable[1] == <span class="charliteral">&#39;$&#39;</span>) ? variable + 2 : variable + 1;
<a name="l03347"></a>03347   <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39;$&#39;</span>)
<a name="l03348"></a>03348     ++p;
<a name="l03349"></a>03349   <span class="keywordflow">while</span> (*p &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; *p &lt;= <span class="charliteral">&#39;9&#39;</span>)
<a name="l03350"></a>03350     ++p;
<a name="l03351"></a>03351   <span class="keywordflow">if</span> (!*p)              <span class="comment">/* Reached end of token without hitting non-digit.  */</span>
<a name="l03352"></a>03352     {
<a name="l03353"></a>03353       <span class="comment">/* We have a value history reference.  */</span>
<a name="l03354"></a>03354       <span class="keyword">struct </span><a class="code" href="structvalue.html">value</a> *val_history;
<a name="l03355"></a>03355 
<a name="l03356"></a>03356       sscanf ((variable[1] == <span class="charliteral">&#39;$&#39;</span>) ? variable + 2 : variable + 1, <span class="stringliteral">&quot;%d&quot;</span>, &amp;index);
<a name="l03357"></a>03357       val_history
<a name="l03358"></a>03358         = <a class="code" href="value_8c.html#a0ff31b66986cc1b1363fbcfcff419596">access_value_history</a> ((variable[1] == <span class="charliteral">&#39;$&#39;</span>) ? -index : index);
<a name="l03359"></a>03359       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val_history)) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>)
<a name="l03360"></a>03360         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;History values used in line &quot;</span>
<a name="l03361"></a>03361                  <span class="stringliteral">&quot;specs must have integer values.&quot;</span>));
<a name="l03362"></a>03362       offset.<a class="code" href="structline__offset.html#a67b3ef5291f38b482121139dc421a84f">offset</a> = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (val_history);
<a name="l03363"></a>03363     }
<a name="l03364"></a>03364   <span class="keywordflow">else</span>
<a name="l03365"></a>03365     {
<a name="l03366"></a>03366       <span class="comment">/* Not all digits -- may be user variable/function or a</span>
<a name="l03367"></a>03367 <span class="comment">         convenience variable.  */</span>
<a name="l03368"></a>03368       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> valx;
<a name="l03369"></a>03369       <span class="keyword">struct </span><a class="code" href="structinternalvar.html">internalvar</a> *ivar;
<a name="l03370"></a>03370 
<a name="l03371"></a>03371       <span class="comment">/* Try it as a convenience variable.  If it is not a convenience</span>
<a name="l03372"></a>03372 <span class="comment">         variable, return and allow normal symbol lookup to occur.  */</span>
<a name="l03373"></a>03373       ivar = <a class="code" href="value_8c.html#a71c6e480acfc24d263dc97557a66dfbe">lookup_only_internalvar</a> (variable + 1);
<a name="l03374"></a>03374       <span class="keywordflow">if</span> (ivar == NULL)
<a name="l03375"></a>03375         <span class="comment">/* No internal variable with that name.  Mark the offset</span>
<a name="l03376"></a>03376 <span class="comment">           as unknown to allow the name to be looked up as a symbol.  */</span>
<a name="l03377"></a>03377         offset.<a class="code" href="structline__offset.html#a472435e8559e52f51621869a9dc9f927">sign</a> = <a class="code" href="linespec_8c.html#a42866de95116a0ef09def987e7909376abf2fff5ff94b498a10942f7e2b22f251">LINE_OFFSET_UNKNOWN</a>;
<a name="l03378"></a>03378       <span class="keywordflow">else</span>
<a name="l03379"></a>03379         {
<a name="l03380"></a>03380           <span class="comment">/* We found a valid variable name.  If it is not an integer,</span>
<a name="l03381"></a>03381 <span class="comment">             throw an error.  */</span>
<a name="l03382"></a>03382           <span class="keywordflow">if</span> (!<a class="code" href="value_8c.html#ae774e3d61fd5b2886be7d322f255339a">get_internalvar_integer</a> (ivar, &amp;valx))
<a name="l03383"></a>03383             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Convenience variables used in line &quot;</span>
<a name="l03384"></a>03384                      <span class="stringliteral">&quot;specs must have integer values.&quot;</span>));
<a name="l03385"></a>03385           <span class="keywordflow">else</span>
<a name="l03386"></a>03386             offset.<a class="code" href="structline__offset.html#a67b3ef5291f38b482121139dc421a84f">offset</a> = valx;
<a name="l03387"></a>03387         }
<a name="l03388"></a>03388     }
<a name="l03389"></a>03389 
<a name="l03390"></a>03390   <span class="keywordflow">return</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l03391"></a>03391 }
<a name="l03392"></a>03392 
<a name="l03393"></a>03393 
<a name="l03394"></a>03394 <span class="comment">/* A callback used to possibly add a symbol to the results.  */</span>
<a name="l03395"></a>03395 
<a name="l03396"></a>03396 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03397"></a><a class="code" href="linespec_8c.html#a271c69e567d762eef7e0023cebd2f25e">03397</a> <a class="code" href="linespec_8c.html#a271c69e567d762eef7e0023cebd2f25e">collect_symbols</a> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym, <span class="keywordtype">void</span> *data)
<a name="l03398"></a>03398 {
<a name="l03399"></a>03399   <span class="keyword">struct </span><a class="code" href="structcollect__info.html">collect_info</a> *info = data;
<a name="l03400"></a>03400 
<a name="l03401"></a>03401   <span class="comment">/* In list mode, add all matching symbols, regardless of class.</span>
<a name="l03402"></a>03402 <span class="comment">     This allows the user to type &quot;list a_global_variable&quot;.  */</span>
<a name="l03403"></a>03403   <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a> || info-&gt;<a class="code" href="structcollect__info.html#ac705a97bd9a86bbe604d50e5b2a1019e">state</a>-&gt;<a class="code" href="structlinespec__state.html#a34df2f5baa443f6a4277703e03765f3e">list_mode</a>)
<a name="l03404"></a>03404     <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (symbolp, info-&gt;<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.symbols, sym);
<a name="l03405"></a>03405   <span class="keywordflow">return</span> 1; <span class="comment">/* Continue iterating.  */</span>
<a name="l03406"></a>03406 }
<a name="l03407"></a>03407 
<a name="l03408"></a>03408 <span class="comment">/* We&#39;ve found a minimal symbol MSYMBOL in OBJFILE to associate with our</span>
<a name="l03409"></a>03409 <span class="comment">   linespec; return the SAL in RESULT.  */</span>
<a name="l03410"></a>03410 
<a name="l03411"></a>03411 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03412"></a><a class="code" href="linespec_8c.html#a578832c419d6702dc6f0f644224002ed">03412</a> <a class="code" href="linespec_8c.html#a578832c419d6702dc6f0f644224002ed">minsym_found</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__state.html">linespec_state</a> *<span class="keyword">self</span>, <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l03413"></a>03413               <span class="keyword">struct</span> <a class="code" href="structminimal__symbol.html">minimal_symbol</a> *msymbol,
<a name="l03414"></a>03414               <span class="keyword">struct</span> <a class="code" href="structsymtabs__and__lines.html">symtabs_and_lines</a> *result)
<a name="l03415"></a>03415 {
<a name="l03416"></a>03416   <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l03417"></a>03417   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc;
<a name="l03418"></a>03418   <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a> sal;
<a name="l03419"></a>03419 
<a name="l03420"></a>03420   sal = <a class="code" href="symtab_8c.html#a8370be588c9e67d637b813e8f565c7f0">find_pc_sect_line</a> (<a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (msymbol),
<a name="l03421"></a>03421                            (<span class="keyword">struct</span> <a class="code" href="structobj__section.html">obj_section</a> *) 0, 0);
<a name="l03422"></a>03422   sal.section = <a class="code" href="symtab_8h.html#a68f0685d666b6934c762f89d9b996c63">SYMBOL_OBJ_SECTION</a> (objfile, msymbol);
<a name="l03423"></a>03423 
<a name="l03424"></a>03424   <span class="comment">/* The minimal symbol might point to a function descriptor;</span>
<a name="l03425"></a>03425 <span class="comment">     resolve it to the actual code address instead.  */</span>
<a name="l03426"></a>03426   pc = <a class="code" href="gdbarch_8c.html#adc1ce8006630950c775890c6fe36faa1">gdbarch_convert_from_func_ptr_addr</a> (gdbarch, sal.pc, &amp;<a class="code" href="target_8h.html#a2d8640b030266b58d3821eb5cfd112b9">current_target</a>);
<a name="l03427"></a>03427   <span class="keywordflow">if</span> (pc != sal.pc)
<a name="l03428"></a>03428     sal = <a class="code" href="symtab_8c.html#a8370be588c9e67d637b813e8f565c7f0">find_pc_sect_line</a> (pc, NULL, 0);
<a name="l03429"></a>03429 
<a name="l03430"></a>03430   <span class="keywordflow">if</span> (self-&gt;funfirstline)
<a name="l03431"></a>03431     <a class="code" href="symtab_8c.html#a735ed7fdbb5870bad2b89eb8908f79b2">skip_prologue_sal</a> (&amp;sal);
<a name="l03432"></a>03432 
<a name="l03433"></a>03433   <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#adb625ed35c6026ec3265189c615e7e07">maybe_add_address</a> (self-&gt;addr_set, objfile-&gt;<a class="code" href="structobjfile.html#a1f6ab738ce0b1fb1588709351b0c9091">pspace</a>, sal.pc))
<a name="l03434"></a>03434     <a class="code" href="linespec_8c.html#abe07dbe47bca0f2cfca183745cb34f7d">add_sal_to_sals</a> (<span class="keyword">self</span>, result, &amp;sal, <a class="code" href="symtab_8h.html#a243e66afa96ff58a851b38f428bb3394">SYMBOL_NATURAL_NAME</a> (msymbol), 0);
<a name="l03435"></a>03435 }
<a name="l03436"></a>03436 
<a name="l03437"></a>03437 <span class="comment">/* A helper struct to pass some data through</span>
<a name="l03438"></a>03438 <span class="comment">   iterate_over_minimal_symbols.  */</span>
<a name="l03439"></a>03439 
<a name="l03440"></a><a class="code" href="structcollect__minsyms.html">03440</a> <span class="keyword">struct </span><a class="code" href="structcollect__minsyms.html">collect_minsyms</a>
<a name="l03441"></a>03441 {
<a name="l03442"></a>03442   <span class="comment">/* The objfile we&#39;re examining.  */</span>
<a name="l03443"></a><a class="code" href="structcollect__minsyms.html#af239ebabaf7ae8a55db37d62eead75d9">03443</a>   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structcollect__minsyms.html#af239ebabaf7ae8a55db37d62eead75d9">objfile</a>;
<a name="l03444"></a>03444 
<a name="l03445"></a>03445   <span class="comment">/* The funfirstline setting from the initial call.  */</span>
<a name="l03446"></a><a class="code" href="structcollect__minsyms.html#a1a3fe6704848a333717a4f5384baee17">03446</a>   <span class="keywordtype">int</span> <a class="code" href="structcollect__minsyms.html#a1a3fe6704848a333717a4f5384baee17">funfirstline</a>;
<a name="l03447"></a>03447 
<a name="l03448"></a>03448   <span class="comment">/* The list_mode setting from the initial call.  */</span>
<a name="l03449"></a><a class="code" href="structcollect__minsyms.html#a531be5de123e46345bbca496a1de4754">03449</a>   <span class="keywordtype">int</span> <a class="code" href="structcollect__minsyms.html#a531be5de123e46345bbca496a1de4754">list_mode</a>;
<a name="l03450"></a>03450 
<a name="l03451"></a>03451   <span class="comment">/* The resulting symbols.  */</span>
<a name="l03452"></a>03452   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>) *msyms;
<a name="l03453"></a>03453 };
<a name="l03454"></a>03454 
<a name="l03455"></a>03455 <span class="comment">/* A helper function to classify a minimal_symbol_type according to</span>
<a name="l03456"></a>03456 <span class="comment">   priority.  */</span>
<a name="l03457"></a>03457 
<a name="l03458"></a>03458 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03459"></a><a class="code" href="linespec_8c.html#ae13a23b67eb79191151973faa9acde13">03459</a> <a class="code" href="linespec_8c.html#ae13a23b67eb79191151973faa9acde13">classify_mtype</a> (<span class="keyword">enum</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036">minimal_symbol_type</a> t)
<a name="l03460"></a>03460 {
<a name="l03461"></a>03461   <span class="keywordflow">switch</span> (t)
<a name="l03462"></a>03462     {
<a name="l03463"></a>03463     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036abe55ea8e467b6e7517e226164aa94adb">mst_file_text</a>:
<a name="l03464"></a>03464     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036ad2119ba8e1b909d5c67d8d53bf772eab">mst_file_data</a>:
<a name="l03465"></a>03465     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036afcbb0b5fa236563bce133159d8aba081">mst_file_bss</a>:
<a name="l03466"></a>03466       <span class="comment">/* Intermediate priority.  */</span>
<a name="l03467"></a>03467       <span class="keywordflow">return</span> 1;
<a name="l03468"></a>03468 
<a name="l03469"></a>03469     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036aa6ace68113ace3aafa25e705d9fce85d">mst_solib_trampoline</a>:
<a name="l03470"></a>03470       <span class="comment">/* Lowest priority.  */</span>
<a name="l03471"></a>03471       <span class="keywordflow">return</span> 2;
<a name="l03472"></a>03472 
<a name="l03473"></a>03473     <span class="keywordflow">default</span>:
<a name="l03474"></a>03474       <span class="comment">/* Highest priority.  */</span>
<a name="l03475"></a>03475       <span class="keywordflow">return</span> 0;
<a name="l03476"></a>03476     }
<a name="l03477"></a>03477 }
<a name="l03478"></a>03478 
<a name="l03479"></a>03479 <span class="comment">/* Callback for qsort that sorts symbols by priority.  */</span>
<a name="l03480"></a>03480 
<a name="l03481"></a>03481 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03482"></a><a class="code" href="linespec_8c.html#ab054f828f1de221ab3c0f6f8d5cc865f">03482</a> <a class="code" href="linespec_8c.html#ab054f828f1de221ab3c0f6f8d5cc865f">compare_msyms</a> (<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b)
<a name="l03483"></a>03483 {
<a name="l03484"></a>03484   <span class="keyword">const</span> <a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a> *moa = a;
<a name="l03485"></a>03485   <span class="keyword">const</span> <a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a> *mob = b;
<a name="l03486"></a>03486   <span class="keyword">enum</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036">minimal_symbol_type</a> ta = <a class="code" href="symtab_8h.html#a1d0b27d446f2622f464727b6a06ae263">MSYMBOL_TYPE</a> (moa-&gt;<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>);
<a name="l03487"></a>03487   <span class="keyword">enum</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036">minimal_symbol_type</a> tb = <a class="code" href="symtab_8h.html#a1d0b27d446f2622f464727b6a06ae263">MSYMBOL_TYPE</a> (mob-&gt;<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>);
<a name="l03488"></a>03488 
<a name="l03489"></a>03489   <span class="keywordflow">return</span> <a class="code" href="linespec_8c.html#ae13a23b67eb79191151973faa9acde13">classify_mtype</a> (ta) - <a class="code" href="linespec_8c.html#ae13a23b67eb79191151973faa9acde13">classify_mtype</a> (tb);
<a name="l03490"></a>03490 }
<a name="l03491"></a>03491 
<a name="l03492"></a>03492 <span class="comment">/* Callback for iterate_over_minimal_symbols that adds the symbol to</span>
<a name="l03493"></a>03493 <span class="comment">   the result.  */</span>
<a name="l03494"></a>03494 
<a name="l03495"></a>03495 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03496"></a><a class="code" href="linespec_8c.html#a63a4a461fc9e970f6cb49d3eec0c5826">03496</a> <a class="code" href="linespec_8c.html#a63a4a461fc9e970f6cb49d3eec0c5826">add_minsym</a> (<span class="keyword">struct</span> <a class="code" href="structminimal__symbol.html">minimal_symbol</a> *minsym, <span class="keywordtype">void</span> *d)
<a name="l03497"></a>03497 {
<a name="l03498"></a>03498   <span class="keyword">struct </span><a class="code" href="structcollect__minsyms.html">collect_minsyms</a> *info = d;
<a name="l03499"></a>03499   <a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a> mo;
<a name="l03500"></a>03500 
<a name="l03501"></a>03501   <span class="comment">/* Exclude data symbols when looking for breakpoint locations.   */</span>
<a name="l03502"></a>03502   <span class="keywordflow">if</span> (!info-&gt;<a class="code" href="structcollect__minsyms.html#a531be5de123e46345bbca496a1de4754">list_mode</a>)
<a name="l03503"></a>03503     <span class="keywordflow">switch</span> (minsym-&gt;type)
<a name="l03504"></a>03504       {
<a name="l03505"></a>03505         <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036acc9a9bdfca0dfaffb30738070e32bec4">mst_slot_got_plt</a>:
<a name="l03506"></a>03506         <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036a71b45da3c83c4939f9ff3b2b641c05b0">mst_data</a>:
<a name="l03507"></a>03507         <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036a5ead91e96fa8091e4b168773f8d69242">mst_bss</a>:
<a name="l03508"></a>03508         <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036a2090b7ce32fc7dc63f28781b045a6a81">mst_abs</a>:
<a name="l03509"></a>03509         <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036ad2119ba8e1b909d5c67d8d53bf772eab">mst_file_data</a>:
<a name="l03510"></a>03510         <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036afcbb0b5fa236563bce133159d8aba081">mst_file_bss</a>:
<a name="l03511"></a>03511           {
<a name="l03512"></a>03512             <span class="comment">/* Make sure this minsym is not a function descriptor</span>
<a name="l03513"></a>03513 <span class="comment">               before we decide to discard it.  */</span>
<a name="l03514"></a>03514             <span class="keyword">struct </span><a class="code" href="structgdbarch.html">gdbarch</a> *<a class="code" href="structgdbarch.html">gdbarch</a> = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (info-&gt;<a class="code" href="structcollect__minsyms.html#af239ebabaf7ae8a55db37d62eead75d9">objfile</a>);
<a name="l03515"></a>03515             <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr = <a class="code" href="gdbarch_8c.html#adc1ce8006630950c775890c6fe36faa1">gdbarch_convert_from_func_ptr_addr</a>
<a name="l03516"></a>03516                                (gdbarch, <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (minsym),
<a name="l03517"></a>03517                                 &amp;<a class="code" href="target_8h.html#a2d8640b030266b58d3821eb5cfd112b9">current_target</a>);
<a name="l03518"></a>03518 
<a name="l03519"></a>03519             <span class="keywordflow">if</span> (addr == <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (minsym))
<a name="l03520"></a>03520               <span class="keywordflow">return</span>;
<a name="l03521"></a>03521           }
<a name="l03522"></a>03522       }
<a name="l03523"></a>03523 
<a name="l03524"></a>03524   mo.<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a> = minsym;
<a name="l03525"></a>03525   mo.<a class="code" href="structbound__minimal__symbol.html#a070e0e47d191675f0f4892e0b321d663">objfile</a> = info-&gt;<a class="code" href="structcollect__minsyms.html#af239ebabaf7ae8a55db37d62eead75d9">objfile</a>;
<a name="l03526"></a>03526   <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, info-&gt;msyms, &amp;mo);
<a name="l03527"></a>03527 }
<a name="l03528"></a>03528 
<a name="l03529"></a>03529 <span class="comment">/* Search minimal symbols in all objfiles for NAME.  If SEARCH_PSPACE</span>
<a name="l03530"></a>03530 <span class="comment">   is not NULL, the search is restricted to just that program</span>
<a name="l03531"></a>03531 <span class="comment">   space.  */</span>
<a name="l03532"></a>03532 
<a name="l03533"></a>03533 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03534"></a><a class="code" href="linespec_8c.html#a24d295458907345119008873154d9e6d">03534</a> <a class="code" href="linespec_8c.html#a24d295458907345119008873154d9e6d">search_minsyms_for_name</a> (<span class="keyword">struct</span> <a class="code" href="structcollect__info.html">collect_info</a> *info, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l03535"></a>03535                          <span class="keyword">struct</span> <a class="code" href="structprogram__space.html">program_space</a> *search_pspace)
<a name="l03536"></a>03536 {
<a name="l03537"></a>03537   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>;
<a name="l03538"></a>03538   <span class="keyword">struct </span><a class="code" href="structprogram__space.html">program_space</a> *pspace;
<a name="l03539"></a>03539 
<a name="l03540"></a>03540   <a class="code" href="progspace_8h.html#a9e4091a3fcf8c96cb18cf2042cbe21f6">ALL_PSPACES</a> (pspace)
<a name="l03541"></a>03541   {
<a name="l03542"></a>03542     <span class="keyword">struct </span><a class="code" href="structcollect__minsyms.html">collect_minsyms</a> local;
<a name="l03543"></a>03543     <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *<a class="code" href="structcleanup.html">cleanup</a>;
<a name="l03544"></a>03544 
<a name="l03545"></a>03545     <span class="keywordflow">if</span> (search_pspace != NULL &amp;&amp; search_pspace != pspace)
<a name="l03546"></a>03546       <span class="keywordflow">continue</span>;
<a name="l03547"></a>03547     <span class="keywordflow">if</span> (pspace-&gt;<a class="code" href="structprogram__space.html#a66c8a669a715e0f3c717bf0fd8951724">executing_startup</a>)
<a name="l03548"></a>03548       <span class="keywordflow">continue</span>;
<a name="l03549"></a>03549 
<a name="l03550"></a>03550     <a class="code" href="progspace_8c.html#a394457638b3e584a3ecd019df372209f">set_current_program_space</a> (pspace);
<a name="l03551"></a>03551 
<a name="l03552"></a>03552     <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;local, 0, <span class="keyword">sizeof</span> (local));
<a name="l03553"></a>03553     local.<a class="code" href="structcollect__minsyms.html#a1a3fe6704848a333717a4f5384baee17">funfirstline</a> = info-&gt;<a class="code" href="structcollect__info.html#ac705a97bd9a86bbe604d50e5b2a1019e">state</a>-&gt;<a class="code" href="structlinespec__state.html#a945da3d4b8141bed24fef0d0a1f4a2c0">funfirstline</a>;
<a name="l03554"></a>03554     local.<a class="code" href="structcollect__minsyms.html#a531be5de123e46345bbca496a1de4754">list_mode</a> = info-&gt;<a class="code" href="structcollect__info.html#ac705a97bd9a86bbe604d50e5b2a1019e">state</a>-&gt;<a class="code" href="structlinespec__state.html#a34df2f5baa443f6a4277703e03765f3e">list_mode</a>;
<a name="l03555"></a>03555 
<a name="l03556"></a>03556     cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="vec_8h.html#a92a6114eb727b9274e1523d0e9dd2e61">VEC_cleanup</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>),
<a name="l03557"></a>03557                             &amp;local.msyms);
<a name="l03558"></a>03558 
<a name="l03559"></a>03559     <a class="code" href="objfiles_8h.html#a8efee3b85a322006131a6056d45058b3">ALL_OBJFILES</a> (objfile)
<a name="l03560"></a>03560     {
<a name="l03561"></a>03561       local.<a class="code" href="structcollect__minsyms.html#af239ebabaf7ae8a55db37d62eead75d9">objfile</a> = objfile;
<a name="l03562"></a>03562       <a class="code" href="minsyms_8c.html#ae9d8751215fc93c1f6a4b33277984c60">iterate_over_minimal_symbols</a> (objfile, name, <a class="code" href="linespec_8c.html#a63a4a461fc9e970f6cb49d3eec0c5826">add_minsym</a>, &amp;local);
<a name="l03563"></a>03563     }
<a name="l03564"></a>03564 
<a name="l03565"></a>03565     <span class="keywordflow">if</span> (!<a class="code" href="vec_8h.html#ac9981d313a5e114db0e05b7b9cd16319">VEC_empty</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, local.msyms))
<a name="l03566"></a>03566       {
<a name="l03567"></a>03567         <span class="keywordtype">int</span> classification;
<a name="l03568"></a>03568         <span class="keywordtype">int</span> ix;
<a name="l03569"></a>03569         <a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a> *item;
<a name="l03570"></a>03570 
<a name="l03571"></a>03571         <a class="code" href="ada-exp_8c.html#a849e2297facde4d3c80dc4f45f8abbdb">qsort</a> (<a class="code" href="vec_8h.html#a99adc2006a668acc675e3758d9375ad5">VEC_address</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, local.msyms),
<a name="l03572"></a>03572                <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, local.msyms),
<a name="l03573"></a>03573                sizeof (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>),
<a name="l03574"></a>03574                <a class="code" href="linespec_8c.html#ab054f828f1de221ab3c0f6f8d5cc865f">compare_msyms</a>);
<a name="l03575"></a>03575 
<a name="l03576"></a>03576         <span class="comment">/* Now the minsyms are in classification order.  So, we walk</span>
<a name="l03577"></a>03577 <span class="comment">           over them and process just the minsyms with the same</span>
<a name="l03578"></a>03578 <span class="comment">           classification as the very first minsym in the list.  */</span>
<a name="l03579"></a>03579         item = <a class="code" href="vec_8h.html#a49c128c353995ea8fca27be70829ca52">VEC_index</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, local.msyms, 0);
<a name="l03580"></a>03580         classification = <a class="code" href="linespec_8c.html#ae13a23b67eb79191151973faa9acde13">classify_mtype</a> (<a class="code" href="symtab_8h.html#a1d0b27d446f2622f464727b6a06ae263">MSYMBOL_TYPE</a> (item-&gt;<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>));
<a name="l03581"></a>03581 
<a name="l03582"></a>03582         <span class="keywordflow">for</span> (ix = 0;
<a name="l03583"></a>03583              <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>, local.msyms, ix, item);
<a name="l03584"></a>03584              ++ix)
<a name="l03585"></a>03585           {
<a name="l03586"></a>03586             <span class="keywordflow">if</span> (<a class="code" href="linespec_8c.html#ae13a23b67eb79191151973faa9acde13">classify_mtype</a> (<a class="code" href="symtab_8h.html#a1d0b27d446f2622f464727b6a06ae263">MSYMBOL_TYPE</a> (item-&gt;<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>)) != classification)
<a name="l03587"></a>03587               <span class="keywordflow">break</span>;
<a name="l03588"></a>03588 
<a name="l03589"></a>03589             <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol_d</a>,
<a name="l03590"></a>03590                            info-&gt;<a class="code" href="structcollect__info.html#a8a0dffbefaa23f5f3ecf652b96970c73">result</a>.minimal_symbols, item);
<a name="l03591"></a>03591           }
<a name="l03592"></a>03592       }
<a name="l03593"></a>03593 
<a name="l03594"></a>03594     <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup);
<a name="l03595"></a>03595   }
<a name="l03596"></a>03596 }
<a name="l03597"></a>03597 
<a name="l03598"></a>03598 <span class="comment">/* A helper function to add all symbols matching NAME to INFO.  If</span>
<a name="l03599"></a>03599 <span class="comment">   PSPACE is not NULL, the search is restricted to just that program</span>
<a name="l03600"></a>03600 <span class="comment">   space.  */</span>
<a name="l03601"></a>03601 
<a name="l03602"></a>03602 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03603"></a><a class="code" href="linespec_8c.html#a9a911b477c6a45e4fd33ada11d1a1db8">03603</a> <a class="code" href="linespec_8c.html#a9a911b477c6a45e4fd33ada11d1a1db8">add_matching_symbols_to_info</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l03604"></a>03604                               <span class="keyword">struct</span> <a class="code" href="structcollect__info.html">collect_info</a> *info,
<a name="l03605"></a>03605                               <span class="keyword">struct</span> <a class="code" href="structprogram__space.html">program_space</a> *pspace)
<a name="l03606"></a>03606 {
<a name="l03607"></a>03607   <span class="keywordtype">int</span> ix;
<a name="l03608"></a>03608   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *elt;
<a name="l03609"></a>03609 
<a name="l03610"></a>03610   <span class="keywordflow">for</span> (ix = 0; <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="structsymtab.html">symtab_ptr</a>, info-&gt;file_symtabs, ix, elt); ++ix)
<a name="l03611"></a>03611     {
<a name="l03612"></a>03612       <span class="keywordflow">if</span> (elt == NULL)
<a name="l03613"></a>03613         {
<a name="l03614"></a>03614           <a class="code" href="linespec_8c.html#ad601fce792b86d88730bf57a2703cbba">iterate_over_all_matching_symtabs</a> (info-&gt;<a class="code" href="structcollect__info.html#ac705a97bd9a86bbe604d50e5b2a1019e">state</a>, name, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>,
<a name="l03615"></a>03615                                              <a class="code" href="linespec_8c.html#a271c69e567d762eef7e0023cebd2f25e">collect_symbols</a>, info,
<a name="l03616"></a>03616                                              pspace, 1);
<a name="l03617"></a>03617           <a class="code" href="linespec_8c.html#a24d295458907345119008873154d9e6d">search_minsyms_for_name</a> (info, name, pspace);
<a name="l03618"></a>03618         }
<a name="l03619"></a>03619       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pspace == NULL || pspace == <a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (elt))
<a name="l03620"></a>03620         {
<a name="l03621"></a>03621           <span class="comment">/* Program spaces that are executing startup should have</span>
<a name="l03622"></a>03622 <span class="comment">             been filtered out earlier.  */</span>
<a name="l03623"></a>03623           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!<a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (elt)-&gt;executing_startup);
<a name="l03624"></a>03624           <a class="code" href="progspace_8c.html#a394457638b3e584a3ecd019df372209f">set_current_program_space</a> (<a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (elt));
<a name="l03625"></a>03625           <a class="code" href="linespec_8c.html#a69960965426eda86edc8cda619e5918e">iterate_over_file_blocks</a> (elt, name, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>,
<a name="l03626"></a>03626                                     <a class="code" href="linespec_8c.html#a271c69e567d762eef7e0023cebd2f25e">collect_symbols</a>, info);
<a name="l03627"></a>03627         }
<a name="l03628"></a>03628     }
<a name="l03629"></a>03629 }
<a name="l03630"></a>03630 
<a name="l03631"></a>03631 
<a name="l03632"></a>03632 
<a name="l03633"></a>03633 <span class="comment">/* Now come some functions that are called from multiple places within</span>
<a name="l03634"></a>03634 <span class="comment">   decode_line_1.  */</span>
<a name="l03635"></a>03635 
<a name="l03636"></a>03636 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03637"></a><a class="code" href="linespec_8c.html#aa85de32bcb33630e5e698928cac16baf">03637</a> <a class="code" href="linespec_8c.html#aa85de32bcb33630e5e698928cac16baf">symbol_to_sal</a> (<span class="keyword">struct</span> <a class="code" href="structsymtab__and__line.html">symtab_and_line</a> *result,
<a name="l03638"></a>03638                <span class="keywordtype">int</span> funfirstline, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym)
<a name="l03639"></a>03639 {
<a name="l03640"></a>03640   <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>)
<a name="l03641"></a>03641     {
<a name="l03642"></a>03642       *result = <a class="code" href="symtab_8c.html#ab927e83e70b2cff20b3750daff6f84c5">find_function_start_sal</a> (sym, funfirstline);
<a name="l03643"></a>03643       <span class="keywordflow">return</span> 1;
<a name="l03644"></a>03644     }
<a name="l03645"></a>03645   <span class="keywordflow">else</span>
<a name="l03646"></a>03646     {
<a name="l03647"></a>03647       <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a246b44ddd9acee8dac2a7d9d2c5d7c6e">LOC_LABEL</a> &amp;&amp; <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (sym) != 0)
<a name="l03648"></a>03648         {
<a name="l03649"></a>03649           <a class="code" href="symtab_8c.html#aca3a01a4f0e1a09f99e8308faecc9028">init_sal</a> (result);
<a name="l03650"></a>03650           result-&gt;<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a> = <a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (sym);
<a name="l03651"></a>03651           result-&gt;<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a> = <a class="code" href="symtab_8h.html#aaaa694c80f2e32770027d7561a171a55">SYMBOL_LINE</a> (sym);
<a name="l03652"></a>03652           result-&gt;<a class="code" href="structsymtab__and__line.html#a77665fa461ad187cb755efa256ba44d7">pc</a> = <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (sym);
<a name="l03653"></a>03653           result-&gt;<a class="code" href="structsymtab__and__line.html#acc91f0276f4648cb5a970f17ddcbaf09">pspace</a> = <a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (<a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (sym));
<a name="l03654"></a>03654           result-&gt;<a class="code" href="structsymtab__and__line.html#aa1cadecc3ac47f587f6725c2851a73ac">explicit_pc</a> = 1;
<a name="l03655"></a>03655           <span class="keywordflow">return</span> 1;
<a name="l03656"></a>03656         }
<a name="l03657"></a>03657       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (funfirstline)
<a name="l03658"></a>03658         {
<a name="l03659"></a>03659           <span class="comment">/* Nothing.  */</span>
<a name="l03660"></a>03660         }
<a name="l03661"></a>03661       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#aaaa694c80f2e32770027d7561a171a55">SYMBOL_LINE</a> (sym) != 0)
<a name="l03662"></a>03662         {
<a name="l03663"></a>03663           <span class="comment">/* We know its line number.  */</span>
<a name="l03664"></a>03664           <a class="code" href="symtab_8c.html#aca3a01a4f0e1a09f99e8308faecc9028">init_sal</a> (result);
<a name="l03665"></a>03665           result-&gt;<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a> = <a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (sym);
<a name="l03666"></a>03666           result-&gt;<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a> = <a class="code" href="symtab_8h.html#aaaa694c80f2e32770027d7561a171a55">SYMBOL_LINE</a> (sym);
<a name="l03667"></a>03667           result-&gt;<a class="code" href="structsymtab__and__line.html#acc91f0276f4648cb5a970f17ddcbaf09">pspace</a> = <a class="code" href="symtab_8h.html#a2a71e72ee45ded613d9284b7423a90c2">SYMTAB_PSPACE</a> (<a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (sym));
<a name="l03668"></a>03668           <span class="keywordflow">return</span> 1;
<a name="l03669"></a>03669         }
<a name="l03670"></a>03670     }
<a name="l03671"></a>03671 
<a name="l03672"></a>03672   <span class="keywordflow">return</span> 0;
<a name="l03673"></a>03673 }
<a name="l03674"></a>03674 
<a name="l03675"></a>03675 <span class="comment">/* See the comment in linespec.h.  */</span>
<a name="l03676"></a>03676 
<a name="l03677"></a>03677 <span class="keywordtype">void</span>
<a name="l03678"></a><a class="code" href="linespec_8h.html#a9635ab693c8fa49e8abb19570516c1a2">03678</a> <a class="code" href="linespec_8c.html#a7264361d0a42e631634188c78dd8a96e">init_linespec_result</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__result.html">linespec_result</a> *lr)
<a name="l03679"></a>03679 {
<a name="l03680"></a>03680   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (lr, 0, <span class="keyword">sizeof</span> (*lr));
<a name="l03681"></a>03681 }
<a name="l03682"></a>03682 
<a name="l03683"></a>03683 <span class="comment">/* See the comment in linespec.h.  */</span>
<a name="l03684"></a>03684 
<a name="l03685"></a>03685 <span class="keywordtype">void</span>
<a name="l03686"></a><a class="code" href="linespec_8h.html#affa0286bccf7e3384b6b5a5f2a13a23e">03686</a> <a class="code" href="linespec_8c.html#a414e9a3f3213cb2db079a126177024bb">destroy_linespec_result</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__result.html">linespec_result</a> *ls)
<a name="l03687"></a>03687 {
<a name="l03688"></a>03688   <span class="keywordtype">int</span> i;
<a name="l03689"></a>03689   <span class="keyword">struct </span><a class="code" href="structlinespec__sals.html">linespec_sals</a> *lsal;
<a name="l03690"></a>03690 
<a name="l03691"></a>03691   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (ls-&gt;<a class="code" href="structlinespec__result.html#abfccf5d367c072077ac366af4d3f23f9">addr_string</a>);
<a name="l03692"></a>03692   <span class="keywordflow">for</span> (i = 0; <a class="code" href="vec_8h.html#ae7795b0c8e65f45eb49aac5ec2c0fa52">VEC_iterate</a> (<a class="code" href="structlinespec__sals.html">linespec_sals</a>, ls-&gt;sals, i, lsal); ++i)
<a name="l03693"></a>03693     {
<a name="l03694"></a>03694       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (lsal-&gt;<a class="code" href="structlinespec__sals.html#a5a6b2c7bb2c9b91d8077fb7186a6c466">canonical</a>);
<a name="l03695"></a>03695       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (lsal-&gt;<a class="code" href="structlinespec__sals.html#a34ac2e438b2835722c998f409c85dcee">sals</a>.<a class="code" href="structsymtabs__and__lines.html#ab601f48fdf29c3b190ba068f57983df4">sals</a>);
<a name="l03696"></a>03696     }
<a name="l03697"></a>03697   <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structlinespec__sals.html">linespec_sals</a>, ls-&gt;sals);
<a name="l03698"></a>03698 }
<a name="l03699"></a>03699 
<a name="l03700"></a>03700 <span class="comment">/* Cleanup function for a linespec_result.  */</span>
<a name="l03701"></a>03701 
<a name="l03702"></a>03702 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03703"></a><a class="code" href="linespec_8c.html#acf484cd4e2a6ef7b14190cb69fe46974">03703</a> <a class="code" href="linespec_8c.html#acf484cd4e2a6ef7b14190cb69fe46974">cleanup_linespec_result</a> (<span class="keywordtype">void</span> *a)
<a name="l03704"></a>03704 {
<a name="l03705"></a>03705   <a class="code" href="linespec_8c.html#a414e9a3f3213cb2db079a126177024bb">destroy_linespec_result</a> (a);
<a name="l03706"></a>03706 }
<a name="l03707"></a>03707 
<a name="l03708"></a>03708 <span class="comment">/* See the comment in linespec.h.  */</span>
<a name="l03709"></a>03709 
<a name="l03710"></a>03710 <span class="keyword">struct </span><a class="code" href="structcleanup.html">cleanup</a> *
<a name="l03711"></a><a class="code" href="linespec_8h.html#a2eb69c8196ab06db73aadca9923dbe32">03711</a> <a class="code" href="linespec_8c.html#ac681b7d9043443fa8be585a1fcf735bf">make_cleanup_destroy_linespec_result</a> (<span class="keyword">struct</span> <a class="code" href="structlinespec__result.html">linespec_result</a> *ls)
<a name="l03712"></a>03712 {
<a name="l03713"></a>03713   <span class="keywordflow">return</span> <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="linespec_8c.html#acf484cd4e2a6ef7b14190cb69fe46974">cleanup_linespec_result</a>, ls);
<a name="l03714"></a>03714 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:13:29 for GDB (xrefs) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
