<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (API): /home/stan/gdb/src/gdb/avr-tdep.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (API)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/avr-tdep.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="avr-tdep_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Target-dependent code for Atmel AVR, for GDB.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 1996-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   This file is part of GDB.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00010"></a>00010 <span class="comment">   (at your option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00018"></a>00018 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="comment">/* Contributed by Theodore A. Roth, troth@openavr.org */</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="comment">/* Portions of this file were taken from the original gdb-4.18 patch developed</span>
<a name="l00023"></a>00023 <span class="comment">   by Denis Chertykov, denisc@overta.ru */</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="frame_8h.html">frame.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="frame-unwind_8h.html">frame-unwind.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="frame-base_8h.html">frame-base.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="trad-frame_8h.html">trad-frame.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="gdbcmd_8h.html">gdbcmd.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="gdbcore_8h.html">gdbcore.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="gdbtypes_8h.html">gdbtypes.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="inferior_8h.html">inferior.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="symfile_8h.html">symfile.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="arch-utils_8h.html">arch-utils.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="regcache_8h.html">regcache.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="gdb__string_8h.html">gdb_string.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;dis-asm.h&quot;</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="comment">/* AVR Background:</span>
<a name="l00041"></a>00041 <span class="comment"></span>
<a name="l00042"></a>00042 <span class="comment">   (AVR micros are pure Harvard Architecture processors.)</span>
<a name="l00043"></a>00043 <span class="comment"></span>
<a name="l00044"></a>00044 <span class="comment">   The AVR family of microcontrollers have three distinctly different memory</span>
<a name="l00045"></a>00045 <span class="comment">   spaces: flash, sram and eeprom.  The flash is 16 bits wide and is used for</span>
<a name="l00046"></a>00046 <span class="comment">   the most part to store program instructions.  The sram is 8 bits wide and is</span>
<a name="l00047"></a>00047 <span class="comment">   used for the stack and the heap.  Some devices lack sram and some can have</span>
<a name="l00048"></a>00048 <span class="comment">   an additional external sram added on as a peripheral.</span>
<a name="l00049"></a>00049 <span class="comment"></span>
<a name="l00050"></a>00050 <span class="comment">   The eeprom is 8 bits wide and is used to store data when the device is</span>
<a name="l00051"></a>00051 <span class="comment">   powered down.  Eeprom is not directly accessible, it can only be accessed</span>
<a name="l00052"></a>00052 <span class="comment">   via io-registers using a special algorithm.  Accessing eeprom via gdb&#39;s</span>
<a name="l00053"></a>00053 <span class="comment">   remote serial protocol (&#39;m&#39; or &#39;M&#39; packets) looks difficult to do and is</span>
<a name="l00054"></a>00054 <span class="comment">   not included at this time.</span>
<a name="l00055"></a>00055 <span class="comment"></span>
<a name="l00056"></a>00056 <span class="comment">   [The eeprom could be read manually via ``x/b &lt;eaddr + AVR_EMEM_START&gt;&#39;&#39; or</span>
<a name="l00057"></a>00057 <span class="comment">   written using ``set {unsigned char}&lt;eaddr + AVR_EMEM_START&gt;&#39;&#39;.  For this to</span>
<a name="l00058"></a>00058 <span class="comment">   work, the remote target must be able to handle eeprom accesses and perform</span>
<a name="l00059"></a>00059 <span class="comment">   the address translation.]</span>
<a name="l00060"></a>00060 <span class="comment"></span>
<a name="l00061"></a>00061 <span class="comment">   All three memory spaces have physical addresses beginning at 0x0.  In</span>
<a name="l00062"></a>00062 <span class="comment">   addition, the flash is addressed by gcc/binutils/gdb with respect to 8 bit</span>
<a name="l00063"></a>00063 <span class="comment">   bytes instead of the 16 bit wide words used by the real device for the</span>
<a name="l00064"></a>00064 <span class="comment">   Program Counter.</span>
<a name="l00065"></a>00065 <span class="comment"></span>
<a name="l00066"></a>00066 <span class="comment">   In order for remote targets to work correctly, extra bits must be added to</span>
<a name="l00067"></a>00067 <span class="comment">   addresses before they are send to the target or received from the target</span>
<a name="l00068"></a>00068 <span class="comment">   via the remote serial protocol.  The extra bits are the MSBs and are used to</span>
<a name="l00069"></a>00069 <span class="comment">   decode which memory space the address is referring to.  */</span>
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="comment">/* Constants: prefixed with AVR_ to avoid name space clashes */</span>
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="keyword">enum</span>
<a name="l00074"></a>00074 {
<a name="l00075"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a652fc0cf7c2db10c7dfca264435b52fb">00075</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a652fc0cf7c2db10c7dfca264435b52fb">AVR_REG_W</a> = 24,
<a name="l00076"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4accef1724831c66a2e570cc8934b0356a">00076</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4accef1724831c66a2e570cc8934b0356a">AVR_REG_X</a> = 26,
<a name="l00077"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a5b9cabe1580e2485e2b288612f0033c9">00077</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a5b9cabe1580e2485e2b288612f0033c9">AVR_REG_Y</a> = 28,
<a name="l00078"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a79792e0be3fc1fdaebbf23abe831e456">00078</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a79792e0be3fc1fdaebbf23abe831e456">AVR_FP_REGNUM</a> = 28,
<a name="l00079"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ae291ec78c7c4dbb247a8f72308f6b297">00079</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ae291ec78c7c4dbb247a8f72308f6b297">AVR_REG_Z</a> = 30,
<a name="l00080"></a>00080 
<a name="l00081"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a1d72844524e7bfb35b2573fad0558db0">00081</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a1d72844524e7bfb35b2573fad0558db0">AVR_SREG_REGNUM</a> = 32,
<a name="l00082"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ad429b7dd2405a2fa524c985584d29f18">00082</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ad429b7dd2405a2fa524c985584d29f18">AVR_SP_REGNUM</a> = 33,
<a name="l00083"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a710fcdc3ebf642dac1c9071077d5a253">00083</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a710fcdc3ebf642dac1c9071077d5a253">AVR_PC_REGNUM</a> = 34,
<a name="l00084"></a>00084 
<a name="l00085"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a66c557cfface61bbcbf634853c30e94b">00085</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a66c557cfface61bbcbf634853c30e94b">AVR_NUM_REGS</a> = 32 + 1 <span class="comment">/*SREG*/</span> + 1 <span class="comment">/*SP*/</span> + 1 <span class="comment">/*PC*/</span>,
<a name="l00086"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a39b89e67beb4e08cb199b5a29fef87f4">00086</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a39b89e67beb4e08cb199b5a29fef87f4">AVR_NUM_REG_BYTES</a> = 32 + 1 <span class="comment">/*SREG*/</span> + 2 <span class="comment">/*SP*/</span> + 4 <span class="comment">/*PC*/</span>,
<a name="l00087"></a>00087 
<a name="l00088"></a>00088   <span class="comment">/* Pseudo registers.  */</span>
<a name="l00089"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ac2913e1229c3d0deea6ebd6bad5aef96">00089</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ac2913e1229c3d0deea6ebd6bad5aef96">AVR_PSEUDO_PC_REGNUM</a> = 35,
<a name="l00090"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4af83e4975d2d8fa50a0297faf0110c152">00090</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4af83e4975d2d8fa50a0297faf0110c152">AVR_NUM_PSEUDO_REGS</a> = 1,
<a name="l00091"></a>00091 
<a name="l00092"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a4a97b3650bee309ab6548128a35c4906">00092</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a4a97b3650bee309ab6548128a35c4906">AVR_PC_REG_INDEX</a> = 35,        <span class="comment">/* index into array of registers */</span>
<a name="l00093"></a>00093 
<a name="l00094"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ac4b08939f44d50500c8e8a7326bef5f6">00094</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ac4b08939f44d50500c8e8a7326bef5f6">AVR_MAX_PROLOGUE_SIZE</a> = 64,   <span class="comment">/* bytes */</span>
<a name="l00095"></a>00095 
<a name="l00096"></a>00096   <span class="comment">/* Count of pushed registers.  From r2 to r17 (inclusively), r28, r29 */</span>
<a name="l00097"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ad8be1e95dc56302b0aee9e9738761156">00097</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ad8be1e95dc56302b0aee9e9738761156">AVR_MAX_PUSHES</a> = 18,
<a name="l00098"></a>00098 
<a name="l00099"></a>00099   <span class="comment">/* Number of the last pushed register.  r17 for current avr-gcc */</span>
<a name="l00100"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a284722ad2548ff488902f2e6e14accfe">00100</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a284722ad2548ff488902f2e6e14accfe">AVR_LAST_PUSHED_REGNUM</a> = 17,
<a name="l00101"></a>00101 
<a name="l00102"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a9e2366bf8866f4aa9a976b748de094c3">00102</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a9e2366bf8866f4aa9a976b748de094c3">AVR_ARG1_REGNUM</a> = 24,         <span class="comment">/* Single byte argument */</span>
<a name="l00103"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a2ff00eb0b451e9354886694e5a0b162e">00103</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a2ff00eb0b451e9354886694e5a0b162e">AVR_ARGN_REGNUM</a> = 25,         <span class="comment">/* Multi byte argments */</span>
<a name="l00104"></a>00104 
<a name="l00105"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a9d5417274855774cb8fb0ca981dc24bd">00105</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a9d5417274855774cb8fb0ca981dc24bd">AVR_RET1_REGNUM</a> = 24,         <span class="comment">/* Single byte return value */</span>
<a name="l00106"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a883c2c39e970d99b925ea384a947a001">00106</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a883c2c39e970d99b925ea384a947a001">AVR_RETN_REGNUM</a> = 25,         <span class="comment">/* Multi byte return value */</span>
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <span class="comment">/* FIXME: TRoth/2002-01-??: Can we shift all these memory masks left 8</span>
<a name="l00109"></a>00109 <span class="comment">     bits?  Do these have to match the bfd vma values?  It sure would make</span>
<a name="l00110"></a>00110 <span class="comment">     things easier in the future if they didn&#39;t need to match.</span>
<a name="l00111"></a>00111 <span class="comment"></span>
<a name="l00112"></a>00112 <span class="comment">     Note: I chose these values so as to be consistent with bfd vma</span>
<a name="l00113"></a>00113 <span class="comment">     addresses.</span>
<a name="l00114"></a>00114 <span class="comment"></span>
<a name="l00115"></a>00115 <span class="comment">     TRoth/2002-04-08: There is already a conflict with very large programs</span>
<a name="l00116"></a>00116 <span class="comment">     in the mega128.  The mega128 has 128K instruction bytes (64K words),</span>
<a name="l00117"></a>00117 <span class="comment">     thus the Most Significant Bit is 0x10000 which gets masked off my</span>
<a name="l00118"></a>00118 <span class="comment">     AVR_MEM_MASK.</span>
<a name="l00119"></a>00119 <span class="comment"></span>
<a name="l00120"></a>00120 <span class="comment">     The problem manifests itself when trying to set a breakpoint in a</span>
<a name="l00121"></a>00121 <span class="comment">     function which resides in the upper half of the instruction space and</span>
<a name="l00122"></a>00122 <span class="comment">     thus requires a 17-bit address.</span>
<a name="l00123"></a>00123 <span class="comment"></span>
<a name="l00124"></a>00124 <span class="comment">     For now, I&#39;ve just removed the EEPROM mask and changed AVR_MEM_MASK</span>
<a name="l00125"></a>00125 <span class="comment">     from 0x00ff0000 to 0x00f00000.  Eeprom is not accessible from gdb yet,</span>
<a name="l00126"></a>00126 <span class="comment">     but could be for some remote targets by just adding the correct offset</span>
<a name="l00127"></a>00127 <span class="comment">     to the address and letting the remote target handle the low-level</span>
<a name="l00128"></a>00128 <span class="comment">     details of actually accessing the eeprom.  */</span>
<a name="l00129"></a>00129 
<a name="l00130"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4aee97bb197d7404fd47f54f783c576f0f">00130</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4aee97bb197d7404fd47f54f783c576f0f">AVR_IMEM_START</a> = 0x00000000,  <span class="comment">/* INSN memory */</span>
<a name="l00131"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4aa688fbf903aac794eb477fc75fb9fc21">00131</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4aa688fbf903aac794eb477fc75fb9fc21">AVR_SMEM_START</a> = 0x00800000,  <span class="comment">/* SRAM memory */</span>
<a name="l00132"></a>00132 <span class="preprocessor">#if 1</span>
<a name="l00133"></a>00133 <span class="preprocessor"></span>  <span class="comment">/* No eeprom mask defined */</span>
<a name="l00134"></a><a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a6c7c8d8cd0b408e5575b1883fc7cd246">00134</a>   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a6c7c8d8cd0b408e5575b1883fc7cd246">AVR_MEM_MASK</a> = 0x00f00000,    <span class="comment">/* mask to determine memory space */</span>
<a name="l00135"></a>00135 <span class="preprocessor">#else</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span>  AVR_EMEM_START = 0x00810000,  <span class="comment">/* EEPROM memory */</span>
<a name="l00137"></a>00137   <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a6c7c8d8cd0b408e5575b1883fc7cd246">AVR_MEM_MASK</a> = 0x00ff0000,    <span class="comment">/* mask to determine memory space */</span>
<a name="l00138"></a>00138 <span class="preprocessor">#endif</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span>};
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="comment">/* Prologue types:</span>
<a name="l00142"></a>00142 <span class="comment"></span>
<a name="l00143"></a>00143 <span class="comment">   NORMAL and CALL are the typical types (the -mcall-prologues gcc option</span>
<a name="l00144"></a>00144 <span class="comment">   causes the generation of the CALL type prologues).  */</span>
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="keyword">enum</span> {
<a name="l00147"></a><a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310ae06fb66b67f360c1e0c599f93ed429ba">00147</a>     <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310ae06fb66b67f360c1e0c599f93ed429ba">AVR_PROLOGUE_NONE</a>,              <span class="comment">/* No prologue */</span>
<a name="l00148"></a><a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310ab6a9eca819be834fd33fb8f0494c8d12">00148</a>     <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310ab6a9eca819be834fd33fb8f0494c8d12">AVR_PROLOGUE_NORMAL</a>,
<a name="l00149"></a><a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310a448aecc5036d9c857e8b48aed24a8b53">00149</a>     <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310a448aecc5036d9c857e8b48aed24a8b53">AVR_PROLOGUE_CALL</a>,              <span class="comment">/* -mcall-prologues */</span>
<a name="l00150"></a><a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310ad64e1b7dad564c9a9fc61428705edaa9">00150</a>     <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310ad64e1b7dad564c9a9fc61428705edaa9">AVR_PROLOGUE_MAIN</a>,
<a name="l00151"></a><a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310af904cee433b357fa966af535c0fb6680">00151</a>     <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310af904cee433b357fa966af535c0fb6680">AVR_PROLOGUE_INTR</a>,              <span class="comment">/* interrupt handler */</span>
<a name="l00152"></a><a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310a00e1a951d99588fa3add97aea10e9044">00152</a>     <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310a00e1a951d99588fa3add97aea10e9044">AVR_PROLOGUE_SIG</a>,               <span class="comment">/* signal handler */</span>
<a name="l00153"></a>00153 };
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 <span class="comment">/* Any function with a frame looks like this</span>
<a name="l00156"></a>00156 <span class="comment">   .......    &lt;-SP POINTS HERE</span>
<a name="l00157"></a>00157 <span class="comment">   LOCALS1    &lt;-FP POINTS HERE</span>
<a name="l00158"></a>00158 <span class="comment">   LOCALS0</span>
<a name="l00159"></a>00159 <span class="comment">   SAVED FP</span>
<a name="l00160"></a>00160 <span class="comment">   SAVED R3</span>
<a name="l00161"></a>00161 <span class="comment">   SAVED R2</span>
<a name="l00162"></a>00162 <span class="comment">   RET PC</span>
<a name="l00163"></a>00163 <span class="comment">   FIRST ARG</span>
<a name="l00164"></a>00164 <span class="comment">   SECOND ARG */</span>
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 <span class="keyword">struct </span>avr_unwind_cache
<a name="l00167"></a>00167 {
<a name="l00168"></a>00168   <span class="comment">/* The previous frame&#39;s inner most stack address.  Used as this</span>
<a name="l00169"></a>00169 <span class="comment">     frame ID&#39;s stack_addr.  */</span>
<a name="l00170"></a>00170   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> prev_sp;
<a name="l00171"></a>00171   <span class="comment">/* The frame&#39;s base, optionally used by the high-level debug info.  */</span>
<a name="l00172"></a>00172   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> base;
<a name="l00173"></a>00173   <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l00174"></a>00174   <span class="keywordtype">int</span> prologue_type;
<a name="l00175"></a>00175   <span class="comment">/* Table indicating the location of each and every register.  */</span>
<a name="l00176"></a>00176   <span class="keyword">struct </span><a class="code" href="structtrad__frame__saved__reg.html">trad_frame_saved_reg</a> *saved_regs;
<a name="l00177"></a>00177 };
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a>
<a name="l00180"></a>00180 {
<a name="l00181"></a>00181   <span class="comment">/* Number of bytes stored to the stack by call instructions.</span>
<a name="l00182"></a>00182 <span class="comment">     2 bytes for avr1-5, 3 bytes for avr6.  */</span>
<a name="l00183"></a><a class="code" href="structgdbarch__tdep.html#a21863283280c459591999555b6062a6e">00183</a>   <span class="keywordtype">int</span> <a class="code" href="structgdbarch__tdep.html#a21863283280c459591999555b6062a6e">call_length</a>;
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   <span class="comment">/* Type for void.  */</span>
<a name="l00186"></a><a class="code" href="structgdbarch__tdep.html#ad159819964eb302372730437c3cc5765">00186</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structgdbarch__tdep.html#ad159819964eb302372730437c3cc5765">void_type</a>;
<a name="l00187"></a>00187   <span class="comment">/* Type for a function returning void.  */</span>
<a name="l00188"></a><a class="code" href="structgdbarch__tdep.html#a761302fd75c883786d1d0012fed0f133">00188</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structgdbarch__tdep.html#a761302fd75c883786d1d0012fed0f133">func_void_type</a>;
<a name="l00189"></a>00189   <span class="comment">/* Type for a pointer to a function.  Used for the type of PC.  */</span>
<a name="l00190"></a><a class="code" href="structgdbarch__tdep.html#a5d2773c93a7aa393a6d05583e0971b0f">00190</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structgdbarch__tdep.html#a5d2773c93a7aa393a6d05583e0971b0f">pc_type</a>;
<a name="l00191"></a>00191 };
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="comment">/* Lookup the name of a register given it&#39;s number.  */</span>
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00196"></a>00196 avr_register_name (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> <a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>)
<a name="l00197"></a>00197 {
<a name="l00198"></a>00198   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> register_names[] = {
<a name="l00199"></a>00199     <span class="stringliteral">&quot;r0&quot;</span>, <span class="stringliteral">&quot;r1&quot;</span>, <span class="stringliteral">&quot;r2&quot;</span>, <span class="stringliteral">&quot;r3&quot;</span>, <span class="stringliteral">&quot;r4&quot;</span>, <span class="stringliteral">&quot;r5&quot;</span>, <span class="stringliteral">&quot;r6&quot;</span>, <span class="stringliteral">&quot;r7&quot;</span>,
<a name="l00200"></a>00200     <span class="stringliteral">&quot;r8&quot;</span>, <span class="stringliteral">&quot;r9&quot;</span>, <span class="stringliteral">&quot;r10&quot;</span>, <span class="stringliteral">&quot;r11&quot;</span>, <span class="stringliteral">&quot;r12&quot;</span>, <span class="stringliteral">&quot;r13&quot;</span>, <span class="stringliteral">&quot;r14&quot;</span>, <span class="stringliteral">&quot;r15&quot;</span>,
<a name="l00201"></a>00201     <span class="stringliteral">&quot;r16&quot;</span>, <span class="stringliteral">&quot;r17&quot;</span>, <span class="stringliteral">&quot;r18&quot;</span>, <span class="stringliteral">&quot;r19&quot;</span>, <span class="stringliteral">&quot;r20&quot;</span>, <span class="stringliteral">&quot;r21&quot;</span>, <span class="stringliteral">&quot;r22&quot;</span>, <span class="stringliteral">&quot;r23&quot;</span>,
<a name="l00202"></a>00202     <span class="stringliteral">&quot;r24&quot;</span>, <span class="stringliteral">&quot;r25&quot;</span>, <span class="stringliteral">&quot;r26&quot;</span>, <span class="stringliteral">&quot;r27&quot;</span>, <span class="stringliteral">&quot;r28&quot;</span>, <span class="stringliteral">&quot;r29&quot;</span>, <span class="stringliteral">&quot;r30&quot;</span>, <span class="stringliteral">&quot;r31&quot;</span>,
<a name="l00203"></a>00203     <span class="stringliteral">&quot;SREG&quot;</span>, <span class="stringliteral">&quot;SP&quot;</span>, <span class="stringliteral">&quot;PC2&quot;</span>,
<a name="l00204"></a>00204     <span class="stringliteral">&quot;pc&quot;</span>
<a name="l00205"></a>00205   };
<a name="l00206"></a>00206   <span class="keywordflow">if</span> (regnum &lt; 0)
<a name="l00207"></a>00207     <span class="keywordflow">return</span> NULL;
<a name="l00208"></a>00208   <span class="keywordflow">if</span> (regnum &gt;= (<span class="keyword">sizeof</span> (register_names) / <span class="keyword">sizeof</span> (*register_names)))
<a name="l00209"></a>00209     <span class="keywordflow">return</span> NULL;
<a name="l00210"></a>00210   <span class="keywordflow">return</span> register_names[<a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>];
<a name="l00211"></a>00211 }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="comment">/* Return the GDB type object for the &quot;standard&quot; data type</span>
<a name="l00214"></a>00214 <span class="comment">   of data in register N.  */</span>
<a name="l00215"></a>00215 
<a name="l00216"></a>00216 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l00217"></a>00217 avr_register_type (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> reg_nr)
<a name="l00218"></a>00218 {
<a name="l00219"></a>00219   <span class="keywordflow">if</span> (reg_nr == <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a710fcdc3ebf642dac1c9071077d5a253">AVR_PC_REGNUM</a>)
<a name="l00220"></a>00220     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a7d0cf7d4e93c3cd2f1b744a18fa23b80">builtin_uint32</a>;
<a name="l00221"></a>00221   <span class="keywordflow">if</span> (reg_nr == <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ac2913e1229c3d0deea6ebd6bad5aef96">AVR_PSEUDO_PC_REGNUM</a>)
<a name="l00222"></a>00222     <span class="keywordflow">return</span> <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a5d2773c93a7aa393a6d05583e0971b0f">pc_type</a>;
<a name="l00223"></a>00223   <span class="keywordflow">if</span> (reg_nr == <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ad429b7dd2405a2fa524c985584d29f18">AVR_SP_REGNUM</a>)
<a name="l00224"></a>00224     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a55f6f9ff7436431777683d8ba62f662a">builtin_data_ptr</a>;
<a name="l00225"></a>00225   <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#ad57a1250e3b718be55d3810f484bdc3a">builtin_uint8</a>;
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="comment">/* Instruction address checks and convertions.  */</span>
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l00231"></a>00231 avr_make_iaddr (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> x)
<a name="l00232"></a>00232 {
<a name="l00233"></a>00233   <span class="keywordflow">return</span> ((x) | <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4aee97bb197d7404fd47f54f783c576f0f">AVR_IMEM_START</a>);
<a name="l00234"></a>00234 }
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="comment">/* FIXME: TRoth: Really need to use a larger mask for instructions.  Some</span>
<a name="l00237"></a>00237 <span class="comment">   devices are already up to 128KBytes of flash space.</span>
<a name="l00238"></a>00238 <span class="comment"></span>
<a name="l00239"></a>00239 <span class="comment">   TRoth/2002-04-8: See comment above where AVR_IMEM_START is defined.  */</span>
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l00242"></a>00242 avr_convert_iaddr_to_raw (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> x)
<a name="l00243"></a>00243 {
<a name="l00244"></a>00244   <span class="keywordflow">return</span> ((x) &amp; 0xffffffff);
<a name="l00245"></a>00245 }
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 <span class="comment">/* SRAM address checks and convertions.  */</span>
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l00250"></a>00250 avr_make_saddr (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> x)
<a name="l00251"></a>00251 {
<a name="l00252"></a>00252   <span class="comment">/* Return 0 for NULL.  */</span>
<a name="l00253"></a>00253   <span class="keywordflow">if</span> (x == 0)
<a name="l00254"></a>00254     <span class="keywordflow">return</span> 0;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256   <span class="keywordflow">return</span> ((x) | <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4aa688fbf903aac794eb477fc75fb9fc21">AVR_SMEM_START</a>);
<a name="l00257"></a>00257 }
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l00260"></a>00260 avr_convert_saddr_to_raw (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> x)
<a name="l00261"></a>00261 {
<a name="l00262"></a>00262   <span class="keywordflow">return</span> ((x) &amp; 0xffffffff);
<a name="l00263"></a>00263 }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 <span class="comment">/* EEPROM address checks and convertions.  I don&#39;t know if these will ever</span>
<a name="l00266"></a>00266 <span class="comment">   actually be used, but I&#39;ve added them just the same.  TRoth */</span>
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 <span class="comment">/* TRoth/2002-04-08: Commented out for now to allow fix for problem with large</span>
<a name="l00269"></a>00269 <span class="comment">   programs in the mega128.  */</span>
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 <span class="comment">/*  static CORE_ADDR */</span>
<a name="l00272"></a>00272 <span class="comment">/*  avr_make_eaddr (CORE_ADDR x) */</span>
<a name="l00273"></a>00273 <span class="comment">/*  { */</span>
<a name="l00274"></a>00274 <span class="comment">/*    return ((x) | AVR_EMEM_START); */</span>
<a name="l00275"></a>00275 <span class="comment">/*  } */</span>
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="comment">/*  static int */</span>
<a name="l00278"></a>00278 <span class="comment">/*  avr_eaddr_p (CORE_ADDR x) */</span>
<a name="l00279"></a>00279 <span class="comment">/*  { */</span>
<a name="l00280"></a>00280 <span class="comment">/*    return (((x) &amp; AVR_MEM_MASK) == AVR_EMEM_START); */</span>
<a name="l00281"></a>00281 <span class="comment">/*  } */</span>
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="comment">/*  static CORE_ADDR */</span>
<a name="l00284"></a>00284 <span class="comment">/*  avr_convert_eaddr_to_raw (CORE_ADDR x) */</span>
<a name="l00285"></a>00285 <span class="comment">/*  { */</span>
<a name="l00286"></a>00286 <span class="comment">/*    return ((x) &amp; 0xffffffff); */</span>
<a name="l00287"></a>00287 <span class="comment">/*  } */</span>
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="comment">/* Convert from address to pointer and vice-versa.  */</span>
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00292"></a>00292 avr_address_to_pointer (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l00293"></a>00293                         <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr)
<a name="l00294"></a>00294 {
<a name="l00295"></a>00295   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l00296"></a>00296 
<a name="l00297"></a>00297   <span class="comment">/* Is it a code address?  */</span>
<a name="l00298"></a>00298   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>
<a name="l00299"></a>00299       || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a581771a1410949e8b505dd51426949e9">TYPE_CODE_METHOD</a>)
<a name="l00300"></a>00300     {
<a name="l00301"></a>00301       <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (buf, <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type), byte_order,
<a name="l00302"></a>00302                               avr_convert_iaddr_to_raw (addr &gt;&gt; 1));
<a name="l00303"></a>00303     }
<a name="l00304"></a>00304   <span class="keywordflow">else</span>
<a name="l00305"></a>00305     {
<a name="l00306"></a>00306       <span class="comment">/* Strip off any upper segment bits.  */</span>
<a name="l00307"></a>00307       <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (buf, <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type), byte_order,
<a name="l00308"></a>00308                               avr_convert_saddr_to_raw (addr));
<a name="l00309"></a>00309     }
<a name="l00310"></a>00310 }
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l00313"></a>00313 avr_pointer_to_address (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l00314"></a>00314                         <span class="keyword">struct</span> type *type, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l00315"></a>00315 {
<a name="l00316"></a>00316   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l00317"></a>00317   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr
<a name="l00318"></a>00318     = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf, <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type), byte_order);
<a name="l00319"></a>00319 
<a name="l00320"></a>00320   <span class="comment">/* Is it a code address?  */</span>
<a name="l00321"></a>00321   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>
<a name="l00322"></a>00322       || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a581771a1410949e8b505dd51426949e9">TYPE_CODE_METHOD</a>
<a name="l00323"></a>00323       || <a class="code" href="gdbtypes_8h.html#ae19e562fa8c4081f26ac130602744e7a">TYPE_CODE_SPACE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)))
<a name="l00324"></a>00324     <span class="keywordflow">return</span> avr_make_iaddr (addr &lt;&lt; 1);
<a name="l00325"></a>00325   <span class="keywordflow">else</span>
<a name="l00326"></a>00326     <span class="keywordflow">return</span> avr_make_saddr (addr);
<a name="l00327"></a>00327 }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l00330"></a>00330 avr_integer_to_address (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l00331"></a>00331                         <span class="keyword">struct</span> type *type, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l00332"></a>00332 {
<a name="l00333"></a>00333   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> addr = <a class="code" href="value_8c.html#af8ee32c3e2a2e1cd7cdfe92be37a759f">unpack_long</a> (type, buf);
<a name="l00334"></a>00334 
<a name="l00335"></a>00335   <span class="keywordflow">return</span> avr_make_saddr (addr);
<a name="l00336"></a>00336 }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l00339"></a>00339 avr_read_pc (<span class="keyword">struct</span> regcache *regcache)
<a name="l00340"></a>00340 {
<a name="l00341"></a>00341   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> pc;
<a name="l00342"></a>00342   <a class="code" href="regcache_8c.html#a959a077d769de1641d4f9754cc7b4a1f">regcache_cooked_read_unsigned</a> (regcache, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a710fcdc3ebf642dac1c9071077d5a253">AVR_PC_REGNUM</a>, &amp;pc);
<a name="l00343"></a>00343   <span class="keywordflow">return</span> avr_make_iaddr (pc);
<a name="l00344"></a>00344 }
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00347"></a>00347 avr_write_pc (<span class="keyword">struct</span> regcache *regcache, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> val)
<a name="l00348"></a>00348 {
<a name="l00349"></a>00349   <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a> (regcache, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a710fcdc3ebf642dac1c9071077d5a253">AVR_PC_REGNUM</a>,
<a name="l00350"></a>00350                                   avr_convert_iaddr_to_raw (val));
<a name="l00351"></a>00351 }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00354"></a>00354 avr_pseudo_register_read (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> regcache *regcache,
<a name="l00355"></a>00355                           <span class="keywordtype">int</span> regnum, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l00356"></a>00356 {
<a name="l00357"></a>00357   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> val;
<a name="l00358"></a>00358   <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   <span class="keywordflow">switch</span> (regnum)
<a name="l00361"></a>00361     {
<a name="l00362"></a>00362     <span class="keywordflow">case</span> <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ac2913e1229c3d0deea6ebd6bad5aef96">AVR_PSEUDO_PC_REGNUM</a>:
<a name="l00363"></a>00363       status = <a class="code" href="regcache_8c.html#a465c747dfdb94bb985d56e0374eb4481">regcache_raw_read_unsigned</a> (regcache, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a710fcdc3ebf642dac1c9071077d5a253">AVR_PC_REGNUM</a>, &amp;val);
<a name="l00364"></a>00364       <span class="keywordflow">if</span> (status != <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>)
<a name="l00365"></a>00365         <span class="keywordflow">return</span> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00366"></a>00366       val &gt;&gt;= 1;
<a name="l00367"></a>00367       <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (buf, 4, <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch), val);
<a name="l00368"></a>00368       <span class="keywordflow">return</span> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00369"></a>00369     <span class="keywordflow">default</span>:
<a name="l00370"></a>00370       <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;invalid regnum&quot;</span>));
<a name="l00371"></a>00371     }
<a name="l00372"></a>00372 }
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00375"></a>00375 avr_pseudo_register_write (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> regcache *regcache,
<a name="l00376"></a>00376                            <span class="keywordtype">int</span> regnum, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l00377"></a>00377 {
<a name="l00378"></a>00378   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> val;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380   <span class="keywordflow">switch</span> (regnum)
<a name="l00381"></a>00381     {
<a name="l00382"></a>00382     <span class="keywordflow">case</span> <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ac2913e1229c3d0deea6ebd6bad5aef96">AVR_PSEUDO_PC_REGNUM</a>:
<a name="l00383"></a>00383       val = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf, 4, <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch));
<a name="l00384"></a>00384       val &lt;&lt;= 1;
<a name="l00385"></a>00385       <a class="code" href="regcache_8c.html#aabf28852a01dbc9342b054408225d396">regcache_raw_write_unsigned</a> (regcache, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a710fcdc3ebf642dac1c9071077d5a253">AVR_PC_REGNUM</a>, val);
<a name="l00386"></a>00386       <span class="keywordflow">break</span>;
<a name="l00387"></a>00387     <span class="keywordflow">default</span>:
<a name="l00388"></a>00388       <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;invalid regnum&quot;</span>));
<a name="l00389"></a>00389     }
<a name="l00390"></a>00390 }
<a name="l00391"></a>00391 
<a name="l00392"></a>00392 <span class="comment">/* Function: avr_scan_prologue</span>
<a name="l00393"></a>00393 <span class="comment"></span>
<a name="l00394"></a>00394 <span class="comment">   This function decodes an AVR function prologue to determine:</span>
<a name="l00395"></a>00395 <span class="comment">     1) the size of the stack frame</span>
<a name="l00396"></a>00396 <span class="comment">     2) which registers are saved on it</span>
<a name="l00397"></a>00397 <span class="comment">     3) the offsets of saved regs</span>
<a name="l00398"></a>00398 <span class="comment">   This information is stored in the avr_unwind_cache structure.</span>
<a name="l00399"></a>00399 <span class="comment"></span>
<a name="l00400"></a>00400 <span class="comment">   Some devices lack the sbiw instruction, so on those replace this:</span>
<a name="l00401"></a>00401 <span class="comment">        sbiw    r28, XX</span>
<a name="l00402"></a>00402 <span class="comment">   with this:</span>
<a name="l00403"></a>00403 <span class="comment">        subi    r28,lo8(XX)</span>
<a name="l00404"></a>00404 <span class="comment">        sbci    r29,hi8(XX)</span>
<a name="l00405"></a>00405 <span class="comment"></span>
<a name="l00406"></a>00406 <span class="comment">   A typical AVR function prologue with a frame pointer might look like this:</span>
<a name="l00407"></a>00407 <span class="comment">        push    rXX        ; saved regs</span>
<a name="l00408"></a>00408 <span class="comment">        ...</span>
<a name="l00409"></a>00409 <span class="comment">        push    r28</span>
<a name="l00410"></a>00410 <span class="comment">        push    r29</span>
<a name="l00411"></a>00411 <span class="comment">        in      r28,__SP_L__</span>
<a name="l00412"></a>00412 <span class="comment">        in      r29,__SP_H__</span>
<a name="l00413"></a>00413 <span class="comment">        sbiw    r28,&lt;LOCALS_SIZE&gt;</span>
<a name="l00414"></a>00414 <span class="comment">        in      __tmp_reg__,__SREG__</span>
<a name="l00415"></a>00415 <span class="comment">        cli</span>
<a name="l00416"></a>00416 <span class="comment">        out     __SP_H__,r29</span>
<a name="l00417"></a>00417 <span class="comment">        out     __SREG__,__tmp_reg__</span>
<a name="l00418"></a>00418 <span class="comment">        out     __SP_L__,r28</span>
<a name="l00419"></a>00419 <span class="comment"></span>
<a name="l00420"></a>00420 <span class="comment">   A typical AVR function prologue without a frame pointer might look like</span>
<a name="l00421"></a>00421 <span class="comment">   this:</span>
<a name="l00422"></a>00422 <span class="comment">        push    rXX        ; saved regs</span>
<a name="l00423"></a>00423 <span class="comment">        ...</span>
<a name="l00424"></a>00424 <span class="comment"></span>
<a name="l00425"></a>00425 <span class="comment">   A main function prologue looks like this:</span>
<a name="l00426"></a>00426 <span class="comment">        ldi     r28,lo8(&lt;RAM_ADDR&gt; - &lt;LOCALS_SIZE&gt;)</span>
<a name="l00427"></a>00427 <span class="comment">        ldi     r29,hi8(&lt;RAM_ADDR&gt; - &lt;LOCALS_SIZE&gt;)</span>
<a name="l00428"></a>00428 <span class="comment">        out     __SP_H__,r29</span>
<a name="l00429"></a>00429 <span class="comment">        out     __SP_L__,r28</span>
<a name="l00430"></a>00430 <span class="comment"></span>
<a name="l00431"></a>00431 <span class="comment">   A signal handler prologue looks like this:</span>
<a name="l00432"></a>00432 <span class="comment">        push    __zero_reg__</span>
<a name="l00433"></a>00433 <span class="comment">        push    __tmp_reg__</span>
<a name="l00434"></a>00434 <span class="comment">        in      __tmp_reg__, __SREG__</span>
<a name="l00435"></a>00435 <span class="comment">        push    __tmp_reg__</span>
<a name="l00436"></a>00436 <span class="comment">        clr     __zero_reg__</span>
<a name="l00437"></a>00437 <span class="comment">        push    rXX             ; save registers r18:r27, r30:r31</span>
<a name="l00438"></a>00438 <span class="comment">        ...</span>
<a name="l00439"></a>00439 <span class="comment">        push    r28             ; save frame pointer</span>
<a name="l00440"></a>00440 <span class="comment">        push    r29</span>
<a name="l00441"></a>00441 <span class="comment">        in      r28, __SP_L__</span>
<a name="l00442"></a>00442 <span class="comment">        in      r29, __SP_H__</span>
<a name="l00443"></a>00443 <span class="comment">        sbiw    r28, &lt;LOCALS_SIZE&gt;</span>
<a name="l00444"></a>00444 <span class="comment">        out     __SP_H__, r29</span>
<a name="l00445"></a>00445 <span class="comment">        out     __SP_L__, r28</span>
<a name="l00446"></a>00446 <span class="comment">        </span>
<a name="l00447"></a>00447 <span class="comment">   A interrupt handler prologue looks like this:</span>
<a name="l00448"></a>00448 <span class="comment">        sei</span>
<a name="l00449"></a>00449 <span class="comment">        push    __zero_reg__</span>
<a name="l00450"></a>00450 <span class="comment">        push    __tmp_reg__</span>
<a name="l00451"></a>00451 <span class="comment">        in      __tmp_reg__, __SREG__</span>
<a name="l00452"></a>00452 <span class="comment">        push    __tmp_reg__</span>
<a name="l00453"></a>00453 <span class="comment">        clr     __zero_reg__</span>
<a name="l00454"></a>00454 <span class="comment">        push    rXX             ; save registers r18:r27, r30:r31</span>
<a name="l00455"></a>00455 <span class="comment">        ...</span>
<a name="l00456"></a>00456 <span class="comment">        push    r28             ; save frame pointer</span>
<a name="l00457"></a>00457 <span class="comment">        push    r29</span>
<a name="l00458"></a>00458 <span class="comment">        in      r28, __SP_L__</span>
<a name="l00459"></a>00459 <span class="comment">        in      r29, __SP_H__</span>
<a name="l00460"></a>00460 <span class="comment">        sbiw    r28, &lt;LOCALS_SIZE&gt;</span>
<a name="l00461"></a>00461 <span class="comment">        cli</span>
<a name="l00462"></a>00462 <span class="comment">        out     __SP_H__, r29</span>
<a name="l00463"></a>00463 <span class="comment">        sei     </span>
<a name="l00464"></a>00464 <span class="comment">        out     __SP_L__, r28</span>
<a name="l00465"></a>00465 <span class="comment"></span>
<a name="l00466"></a>00466 <span class="comment">   A `-mcall-prologues&#39; prologue looks like this (Note that the megas use a</span>
<a name="l00467"></a>00467 <span class="comment">   jmp instead of a rjmp, thus the prologue is one word larger since jmp is a</span>
<a name="l00468"></a>00468 <span class="comment">   32 bit insn and rjmp is a 16 bit insn):</span>
<a name="l00469"></a>00469 <span class="comment">        ldi     r26,lo8(&lt;LOCALS_SIZE&gt;)</span>
<a name="l00470"></a>00470 <span class="comment">        ldi     r27,hi8(&lt;LOCALS_SIZE&gt;)</span>
<a name="l00471"></a>00471 <span class="comment">        ldi     r30,pm_lo8(.L_foo_body)</span>
<a name="l00472"></a>00472 <span class="comment">        ldi     r31,pm_hi8(.L_foo_body)</span>
<a name="l00473"></a>00473 <span class="comment">        rjmp    __prologue_saves__+RRR</span>
<a name="l00474"></a>00474 <span class="comment">        .L_foo_body:  */</span>
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 <span class="comment">/* Not really part of a prologue, but still need to scan for it, is when a</span>
<a name="l00477"></a>00477 <span class="comment">   function prologue moves values passed via registers as arguments to new</span>
<a name="l00478"></a>00478 <span class="comment">   registers.  In this case, all local variables live in registers, so there</span>
<a name="l00479"></a>00479 <span class="comment">   may be some register saves.  This is what it looks like:</span>
<a name="l00480"></a>00480 <span class="comment">        movw    rMM, rNN</span>
<a name="l00481"></a>00481 <span class="comment">        ...</span>
<a name="l00482"></a>00482 <span class="comment"></span>
<a name="l00483"></a>00483 <span class="comment">   There could be multiple movw&#39;s.  If the target doesn&#39;t have a movw insn, it</span>
<a name="l00484"></a>00484 <span class="comment">   will use two mov insns.  This could be done after any of the above prologue</span>
<a name="l00485"></a>00485 <span class="comment">   types.  */</span>
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l00488"></a>00488 avr_scan_prologue (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc_beg, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc_end,
<a name="l00489"></a>00489                    <span class="keyword">struct</span> avr_unwind_cache *info)
<a name="l00490"></a>00490 {
<a name="l00491"></a>00491   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l00492"></a>00492   <span class="keywordtype">int</span> i;
<a name="l00493"></a>00493   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> insn;
<a name="l00494"></a>00494   <span class="keywordtype">int</span> scan_stage = 0;
<a name="l00495"></a>00495   <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *msymbol;
<a name="l00496"></a>00496   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> prologue[<a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ac4b08939f44d50500c8e8a7326bef5f6">AVR_MAX_PROLOGUE_SIZE</a>];
<a name="l00497"></a>00497   <span class="keywordtype">int</span> vpc = 0;
<a name="l00498"></a>00498   <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l00499"></a>00499 
<a name="l00500"></a>00500   len = pc_end - pc_beg;
<a name="l00501"></a>00501   <span class="keywordflow">if</span> (len &gt; <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ac4b08939f44d50500c8e8a7326bef5f6">AVR_MAX_PROLOGUE_SIZE</a>)
<a name="l00502"></a>00502     len = <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ac4b08939f44d50500c8e8a7326bef5f6">AVR_MAX_PROLOGUE_SIZE</a>;
<a name="l00503"></a>00503 
<a name="l00504"></a>00504   <span class="comment">/* FIXME: TRoth/2003-06-11: This could be made more efficient by only</span>
<a name="l00505"></a>00505 <span class="comment">     reading in the bytes of the prologue.  The problem is that the figuring</span>
<a name="l00506"></a>00506 <span class="comment">     out where the end of the prologue is is a bit difficult.  The old code </span>
<a name="l00507"></a>00507 <span class="comment">     tried to do that, but failed quite often.  */</span>
<a name="l00508"></a>00508   <a class="code" href="corefile_8c.html#a5e0189c6f21f1c9321b379877183b819">read_memory</a> (pc_beg, prologue, len);
<a name="l00509"></a>00509 
<a name="l00510"></a>00510   <span class="comment">/* Scanning main()&#39;s prologue</span>
<a name="l00511"></a>00511 <span class="comment">     ldi r28,lo8(&lt;RAM_ADDR&gt; - &lt;LOCALS_SIZE&gt;)</span>
<a name="l00512"></a>00512 <span class="comment">     ldi r29,hi8(&lt;RAM_ADDR&gt; - &lt;LOCALS_SIZE&gt;)</span>
<a name="l00513"></a>00513 <span class="comment">     out __SP_H__,r29</span>
<a name="l00514"></a>00514 <span class="comment">     out __SP_L__,r28 */</span>
<a name="l00515"></a>00515 
<a name="l00516"></a>00516   <span class="keywordflow">if</span> (len &gt;= 4)
<a name="l00517"></a>00517     {
<a name="l00518"></a>00518       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="mi-cmd-stack_8c.html#a625c209a7d483c3accc5021a8955806aa60e699f8faac88427bad42a4e486616d">locals</a>;
<a name="l00519"></a>00519       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> img[] = {
<a name="l00520"></a>00520         0xde, 0xbf,             <span class="comment">/* out __SP_H__,r29 */</span>
<a name="l00521"></a>00521         0xcd, 0xbf              <span class="comment">/* out __SP_L__,r28 */</span>
<a name="l00522"></a>00522       };
<a name="l00523"></a>00523 
<a name="l00524"></a>00524       insn = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;prologue[vpc], 2, byte_order);
<a name="l00525"></a>00525       <span class="comment">/* ldi r28,lo8(&lt;RAM_ADDR&gt; - &lt;LOCALS_SIZE&gt;) */</span>
<a name="l00526"></a>00526       <span class="keywordflow">if</span> ((insn &amp; 0xf0f0) == 0xe0c0)
<a name="l00527"></a>00527         {
<a name="l00528"></a>00528           locals = (insn &amp; 0xf) | ((insn &amp; 0x0f00) &gt;&gt; 4);
<a name="l00529"></a>00529           insn = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;prologue[vpc + 2], 2, byte_order);
<a name="l00530"></a>00530           <span class="comment">/* ldi r29,hi8(&lt;RAM_ADDR&gt; - &lt;LOCALS_SIZE&gt;) */</span>
<a name="l00531"></a>00531           <span class="keywordflow">if</span> ((insn &amp; 0xf0f0) == 0xe0d0)
<a name="l00532"></a>00532             {
<a name="l00533"></a>00533               locals |= ((insn &amp; 0xf) | ((insn &amp; 0x0f00) &gt;&gt; 4)) &lt;&lt; 8;
<a name="l00534"></a>00534               <span class="keywordflow">if</span> (vpc + 4 + <span class="keyword">sizeof</span> (img) &lt; len
<a name="l00535"></a>00535                   &amp;&amp; <a class="code" href="gdb__string_8h.html#a65c3e6b23d6855c86acaf147853c82cc">memcmp</a> (prologue + vpc + 4, img, <span class="keyword">sizeof</span> (img)) == 0)
<a name="l00536"></a>00536                 {
<a name="l00537"></a>00537                   info-&gt;prologue_type = <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310ad64e1b7dad564c9a9fc61428705edaa9">AVR_PROLOGUE_MAIN</a>;
<a name="l00538"></a>00538                   info-&gt;base = <a class="code" href="mi-cmd-stack_8c.html#a625c209a7d483c3accc5021a8955806aa60e699f8faac88427bad42a4e486616d">locals</a>;
<a name="l00539"></a>00539                   <span class="keywordflow">return</span> pc_beg + 4;
<a name="l00540"></a>00540                 }
<a name="l00541"></a>00541             }
<a name="l00542"></a>00542         }
<a name="l00543"></a>00543     }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="comment">/* Scanning `-mcall-prologues&#39; prologue</span>
<a name="l00546"></a>00546 <span class="comment">     Classic prologue is 10 bytes, mega prologue is a 12 bytes long */</span>
<a name="l00547"></a>00547 
<a name="l00548"></a>00548   <span class="keywordflow">while</span> (1)     <span class="comment">/* Using a while to avoid many goto&#39;s */</span>
<a name="l00549"></a>00549     {
<a name="l00550"></a>00550       <span class="keywordtype">int</span> loc_size;
<a name="l00551"></a>00551       <span class="keywordtype">int</span> body_addr;
<a name="l00552"></a>00552       <span class="keywordtype">unsigned</span> num_pushes;
<a name="l00553"></a>00553       <span class="keywordtype">int</span> pc_offset = 0;
<a name="l00554"></a>00554 
<a name="l00555"></a>00555       <span class="comment">/* At least the fifth instruction must have been executed to</span>
<a name="l00556"></a>00556 <span class="comment">         modify frame shape.  */</span>
<a name="l00557"></a>00557       <span class="keywordflow">if</span> (len &lt; 10)
<a name="l00558"></a>00558         <span class="keywordflow">break</span>;
<a name="l00559"></a>00559 
<a name="l00560"></a>00560       insn = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;prologue[vpc], 2, byte_order);
<a name="l00561"></a>00561       <span class="comment">/* ldi r26,&lt;LOCALS_SIZE&gt; */</span>
<a name="l00562"></a>00562       <span class="keywordflow">if</span> ((insn &amp; 0xf0f0) != 0xe0a0)
<a name="l00563"></a>00563         <span class="keywordflow">break</span>;
<a name="l00564"></a>00564       loc_size = (insn &amp; 0xf) | ((insn &amp; 0x0f00) &gt;&gt; 4);
<a name="l00565"></a>00565       pc_offset += 2;
<a name="l00566"></a>00566 
<a name="l00567"></a>00567       insn = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;prologue[vpc + 2], 2, byte_order);
<a name="l00568"></a>00568       <span class="comment">/* ldi r27,&lt;LOCALS_SIZE&gt; / 256 */</span>
<a name="l00569"></a>00569       <span class="keywordflow">if</span> ((insn &amp; 0xf0f0) != 0xe0b0)
<a name="l00570"></a>00570         <span class="keywordflow">break</span>;
<a name="l00571"></a>00571       loc_size |= ((insn &amp; 0xf) | ((insn &amp; 0x0f00) &gt;&gt; 4)) &lt;&lt; 8;
<a name="l00572"></a>00572       pc_offset += 2;
<a name="l00573"></a>00573 
<a name="l00574"></a>00574       insn = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;prologue[vpc + 4], 2, byte_order);
<a name="l00575"></a>00575       <span class="comment">/* ldi r30,pm_lo8(.L_foo_body) */</span>
<a name="l00576"></a>00576       <span class="keywordflow">if</span> ((insn &amp; 0xf0f0) != 0xe0e0)
<a name="l00577"></a>00577         <span class="keywordflow">break</span>;
<a name="l00578"></a>00578       body_addr = (insn &amp; 0xf) | ((insn &amp; 0x0f00) &gt;&gt; 4);
<a name="l00579"></a>00579       pc_offset += 2;
<a name="l00580"></a>00580 
<a name="l00581"></a>00581       insn = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;prologue[vpc + 6], 2, byte_order);
<a name="l00582"></a>00582       <span class="comment">/* ldi r31,pm_hi8(.L_foo_body) */</span>
<a name="l00583"></a>00583       <span class="keywordflow">if</span> ((insn &amp; 0xf0f0) != 0xe0f0)
<a name="l00584"></a>00584         <span class="keywordflow">break</span>;
<a name="l00585"></a>00585       body_addr |= ((insn &amp; 0xf) | ((insn &amp; 0x0f00) &gt;&gt; 4)) &lt;&lt; 8;
<a name="l00586"></a>00586       pc_offset += 2;
<a name="l00587"></a>00587 
<a name="l00588"></a>00588       msymbol = <a class="code" href="minsyms_8c.html#af87f7a894386515074ddd71365bc09b8">lookup_minimal_symbol</a> (<span class="stringliteral">&quot;__prologue_saves__&quot;</span>, NULL, NULL);
<a name="l00589"></a>00589       <span class="keywordflow">if</span> (!msymbol)
<a name="l00590"></a>00590         <span class="keywordflow">break</span>;
<a name="l00591"></a>00591 
<a name="l00592"></a>00592       insn = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;prologue[vpc + 8], 2, byte_order);
<a name="l00593"></a>00593       <span class="comment">/* rjmp __prologue_saves__+RRR */</span>
<a name="l00594"></a>00594       <span class="keywordflow">if</span> ((insn &amp; 0xf000) == 0xc000)
<a name="l00595"></a>00595         {
<a name="l00596"></a>00596           <span class="comment">/* Extract PC relative offset from RJMP */</span>
<a name="l00597"></a>00597           i = (insn &amp; 0xfff) | (insn &amp; 0x800 ? (-1 ^ 0xfff) : 0);
<a name="l00598"></a>00598           <span class="comment">/* Convert offset to byte addressable mode */</span>
<a name="l00599"></a>00599           i *= 2;
<a name="l00600"></a>00600           <span class="comment">/* Destination address */</span>
<a name="l00601"></a>00601           i += pc_beg + 10;
<a name="l00602"></a>00602 
<a name="l00603"></a>00603           <span class="keywordflow">if</span> (body_addr != (pc_beg + 10)/2)
<a name="l00604"></a>00604             <span class="keywordflow">break</span>;
<a name="l00605"></a>00605 
<a name="l00606"></a>00606           pc_offset += 2;
<a name="l00607"></a>00607         }
<a name="l00608"></a>00608       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((insn &amp; 0xfe0e) == 0x940c)
<a name="l00609"></a>00609         {
<a name="l00610"></a>00610           <span class="comment">/* Extract absolute PC address from JMP */</span>
<a name="l00611"></a>00611           i = (((insn &amp; 0x1) | ((insn &amp; 0x1f0) &gt;&gt; 3) &lt;&lt; 16)
<a name="l00612"></a>00612                | (<a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;prologue[vpc + 10], 2, byte_order)
<a name="l00613"></a>00613                   &amp; 0xffff));
<a name="l00614"></a>00614           <span class="comment">/* Convert address to byte addressable mode */</span>
<a name="l00615"></a>00615           i *= 2;
<a name="l00616"></a>00616 
<a name="l00617"></a>00617           <span class="keywordflow">if</span> (body_addr != (pc_beg + 12)/2)
<a name="l00618"></a>00618             <span class="keywordflow">break</span>;
<a name="l00619"></a>00619 
<a name="l00620"></a>00620           pc_offset += 4;
<a name="l00621"></a>00621         }
<a name="l00622"></a>00622       <span class="keywordflow">else</span>
<a name="l00623"></a>00623         <span class="keywordflow">break</span>;
<a name="l00624"></a>00624 
<a name="l00625"></a>00625       <span class="comment">/* Resolve offset (in words) from __prologue_saves__ symbol.</span>
<a name="l00626"></a>00626 <span class="comment">         Which is a pushes count in `-mcall-prologues&#39; mode */</span>
<a name="l00627"></a>00627       num_pushes = <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ad8be1e95dc56302b0aee9e9738761156">AVR_MAX_PUSHES</a> - (i - <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (msymbol)) / 2;
<a name="l00628"></a>00628 
<a name="l00629"></a>00629       <span class="keywordflow">if</span> (num_pushes &gt; <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ad8be1e95dc56302b0aee9e9738761156">AVR_MAX_PUSHES</a>)
<a name="l00630"></a>00630         {
<a name="l00631"></a>00631           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Num pushes too large: %d\n&quot;</span>),
<a name="l00632"></a>00632                               num_pushes);
<a name="l00633"></a>00633           num_pushes = 0;
<a name="l00634"></a>00634         }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636       <span class="keywordflow">if</span> (num_pushes)
<a name="l00637"></a>00637         {
<a name="l00638"></a>00638           <span class="keywordtype">int</span> <a class="code" href="varobj_8h.html#a43396decd62b46fa01cc6c66a84cbba1">from</a>;
<a name="l00639"></a>00639 
<a name="l00640"></a>00640           info-&gt;saved_regs[<a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a79792e0be3fc1fdaebbf23abe831e456">AVR_FP_REGNUM</a> + 1].addr = num_pushes;
<a name="l00641"></a>00641           <span class="keywordflow">if</span> (num_pushes &gt;= 2)
<a name="l00642"></a>00642             info-&gt;saved_regs[<a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a79792e0be3fc1fdaebbf23abe831e456">AVR_FP_REGNUM</a>].addr = num_pushes - 1;
<a name="l00643"></a>00643 
<a name="l00644"></a>00644           i = 0;
<a name="l00645"></a>00645           <span class="keywordflow">for</span> (from = <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a284722ad2548ff488902f2e6e14accfe">AVR_LAST_PUSHED_REGNUM</a> + 1 - (num_pushes - 2);
<a name="l00646"></a>00646                from &lt;= <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a284722ad2548ff488902f2e6e14accfe">AVR_LAST_PUSHED_REGNUM</a>; ++<a class="code" href="varobj_8h.html#a43396decd62b46fa01cc6c66a84cbba1">from</a>)
<a name="l00647"></a>00647             info-&gt;saved_regs [from].addr = ++i;
<a name="l00648"></a>00648         }
<a name="l00649"></a>00649       info-&gt;size = loc_size + num_pushes;
<a name="l00650"></a>00650       info-&gt;prologue_type = <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310a448aecc5036d9c857e8b48aed24a8b53">AVR_PROLOGUE_CALL</a>;
<a name="l00651"></a>00651 
<a name="l00652"></a>00652       <span class="keywordflow">return</span> pc_beg + pc_offset;
<a name="l00653"></a>00653     }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655   <span class="comment">/* Scan for the beginning of the prologue for an interrupt or signal</span>
<a name="l00656"></a>00656 <span class="comment">     function.  Note that we have to set the prologue type here since the</span>
<a name="l00657"></a>00657 <span class="comment">     third stage of the prologue may not be present (e.g. no saved registered</span>
<a name="l00658"></a>00658 <span class="comment">     or changing of the SP register).  */</span>
<a name="l00659"></a>00659 
<a name="l00660"></a>00660   <span class="keywordflow">if</span> (1)
<a name="l00661"></a>00661     {
<a name="l00662"></a>00662       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> img[] = {
<a name="l00663"></a>00663         0x78, 0x94,             <span class="comment">/* sei */</span>
<a name="l00664"></a>00664         0x1f, 0x92,             <span class="comment">/* push r1 */</span>
<a name="l00665"></a>00665         0x0f, 0x92,             <span class="comment">/* push r0 */</span>
<a name="l00666"></a>00666         0x0f, 0xb6,             <span class="comment">/* in r0,0x3f SREG */</span>
<a name="l00667"></a>00667         0x0f, 0x92,             <span class="comment">/* push r0 */</span>
<a name="l00668"></a>00668         0x11, 0x24              <span class="comment">/* clr r1 */</span>
<a name="l00669"></a>00669       };
<a name="l00670"></a>00670       <span class="keywordflow">if</span> (len &gt;= <span class="keyword">sizeof</span> (img)
<a name="l00671"></a>00671           &amp;&amp; <a class="code" href="gdb__string_8h.html#a65c3e6b23d6855c86acaf147853c82cc">memcmp</a> (prologue, img, <span class="keyword">sizeof</span> (img)) == 0)
<a name="l00672"></a>00672         {
<a name="l00673"></a>00673           info-&gt;prologue_type = <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310af904cee433b357fa966af535c0fb6680">AVR_PROLOGUE_INTR</a>;
<a name="l00674"></a>00674           vpc += <span class="keyword">sizeof</span> (img);
<a name="l00675"></a>00675           info-&gt;saved_regs[<a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a1d72844524e7bfb35b2573fad0558db0">AVR_SREG_REGNUM</a>].addr = 3;
<a name="l00676"></a>00676           info-&gt;saved_regs[0].addr = 2;
<a name="l00677"></a>00677           info-&gt;saved_regs[1].addr = 1;
<a name="l00678"></a>00678           info-&gt;size += 3;
<a name="l00679"></a>00679         }
<a name="l00680"></a>00680       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (len &gt;= <span class="keyword">sizeof</span> (img) - 2
<a name="l00681"></a>00681                &amp;&amp; <a class="code" href="gdb__string_8h.html#a65c3e6b23d6855c86acaf147853c82cc">memcmp</a> (img + 2, prologue, <span class="keyword">sizeof</span> (img) - 2) == 0)
<a name="l00682"></a>00682         {
<a name="l00683"></a>00683           info-&gt;prologue_type = <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310a00e1a951d99588fa3add97aea10e9044">AVR_PROLOGUE_SIG</a>;
<a name="l00684"></a>00684           vpc += <span class="keyword">sizeof</span> (img) - 2;
<a name="l00685"></a>00685           info-&gt;saved_regs[<a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a1d72844524e7bfb35b2573fad0558db0">AVR_SREG_REGNUM</a>].addr = 3;
<a name="l00686"></a>00686           info-&gt;saved_regs[0].addr = 2;
<a name="l00687"></a>00687           info-&gt;saved_regs[1].addr = 1;
<a name="l00688"></a>00688           info-&gt;size += 2;
<a name="l00689"></a>00689         }
<a name="l00690"></a>00690     }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692   <span class="comment">/* First stage of the prologue scanning.</span>
<a name="l00693"></a>00693 <span class="comment">     Scan pushes (saved registers) */</span>
<a name="l00694"></a>00694 
<a name="l00695"></a>00695   <span class="keywordflow">for</span> (; vpc &lt; <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>; vpc += 2)
<a name="l00696"></a>00696     {
<a name="l00697"></a>00697       insn = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;prologue[vpc], 2, byte_order);
<a name="l00698"></a>00698       <span class="keywordflow">if</span> ((insn &amp; 0xfe0f) == 0x920f)    <span class="comment">/* push rXX */</span>
<a name="l00699"></a>00699         {
<a name="l00700"></a>00700           <span class="comment">/* Bits 4-9 contain a mask for registers R0-R32.  */</span>
<a name="l00701"></a>00701           <span class="keywordtype">int</span> regno = (insn &amp; 0x1f0) &gt;&gt; 4;
<a name="l00702"></a>00702           info-&gt;size++;
<a name="l00703"></a>00703           info-&gt;saved_regs[regno].addr = info-&gt;size;
<a name="l00704"></a>00704           scan_stage = 1;
<a name="l00705"></a>00705         }
<a name="l00706"></a>00706       <span class="keywordflow">else</span>
<a name="l00707"></a>00707         <span class="keywordflow">break</span>;
<a name="l00708"></a>00708     }
<a name="l00709"></a>00709 
<a name="l00710"></a>00710   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (vpc &lt; <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ac4b08939f44d50500c8e8a7326bef5f6">AVR_MAX_PROLOGUE_SIZE</a>);
<a name="l00711"></a>00711 
<a name="l00712"></a>00712   <span class="comment">/* Handle static small stack allocation using rcall or push.  */</span>
<a name="l00713"></a>00713 
<a name="l00714"></a>00714   <span class="keywordflow">while</span> (scan_stage == 1 &amp;&amp; vpc &lt; len)
<a name="l00715"></a>00715     {
<a name="l00716"></a>00716       insn = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;prologue[vpc], 2, byte_order);
<a name="l00717"></a>00717       <span class="keywordflow">if</span> (insn == 0xd000)       <span class="comment">/* rcall .+0 */</span>
<a name="l00718"></a>00718         {
<a name="l00719"></a>00719           info-&gt;size += <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a21863283280c459591999555b6062a6e">call_length</a>;
<a name="l00720"></a>00720           vpc += 2;
<a name="l00721"></a>00721         }
<a name="l00722"></a>00722       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (insn == 0x920f)  <span class="comment">/* push r0 */</span>
<a name="l00723"></a>00723         {
<a name="l00724"></a>00724           info-&gt;size += 1;
<a name="l00725"></a>00725           vpc += 2;
<a name="l00726"></a>00726         }
<a name="l00727"></a>00727       <span class="keywordflow">else</span>
<a name="l00728"></a>00728         <span class="keywordflow">break</span>;
<a name="l00729"></a>00729     }
<a name="l00730"></a>00730 
<a name="l00731"></a>00731   <span class="comment">/* Second stage of the prologue scanning.</span>
<a name="l00732"></a>00732 <span class="comment">     Scan:</span>
<a name="l00733"></a>00733 <span class="comment">     in r28,__SP_L__</span>
<a name="l00734"></a>00734 <span class="comment">     in r29,__SP_H__ */</span>
<a name="l00735"></a>00735 
<a name="l00736"></a>00736   <span class="keywordflow">if</span> (scan_stage == 1 &amp;&amp; vpc &lt; len)
<a name="l00737"></a>00737     {
<a name="l00738"></a>00738       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> img[] = {
<a name="l00739"></a>00739         0xcd, 0xb7,             <span class="comment">/* in r28,__SP_L__ */</span>
<a name="l00740"></a>00740         0xde, 0xb7              <span class="comment">/* in r29,__SP_H__ */</span>
<a name="l00741"></a>00741       };
<a name="l00742"></a>00742 
<a name="l00743"></a>00743       <span class="keywordflow">if</span> (vpc + <span class="keyword">sizeof</span> (img) &lt; len
<a name="l00744"></a>00744           &amp;&amp; <a class="code" href="gdb__string_8h.html#a65c3e6b23d6855c86acaf147853c82cc">memcmp</a> (prologue + vpc, img, <span class="keyword">sizeof</span> (img)) == 0)
<a name="l00745"></a>00745         {
<a name="l00746"></a>00746           vpc += 4;
<a name="l00747"></a>00747           scan_stage = 2;
<a name="l00748"></a>00748         }
<a name="l00749"></a>00749     }
<a name="l00750"></a>00750 
<a name="l00751"></a>00751   <span class="comment">/* Third stage of the prologue scanning.  (Really two stages).</span>
<a name="l00752"></a>00752 <span class="comment">     Scan for:</span>
<a name="l00753"></a>00753 <span class="comment">     sbiw r28,XX or subi r28,lo8(XX)</span>
<a name="l00754"></a>00754 <span class="comment">                    sbci r29,hi8(XX)</span>
<a name="l00755"></a>00755 <span class="comment">     in __tmp_reg__,__SREG__</span>
<a name="l00756"></a>00756 <span class="comment">     cli</span>
<a name="l00757"></a>00757 <span class="comment">     out __SP_H__,r29</span>
<a name="l00758"></a>00758 <span class="comment">     out __SREG__,__tmp_reg__</span>
<a name="l00759"></a>00759 <span class="comment">     out __SP_L__,r28 */</span>
<a name="l00760"></a>00760 
<a name="l00761"></a>00761   <span class="keywordflow">if</span> (scan_stage == 2 &amp;&amp; vpc &lt; len)
<a name="l00762"></a>00762     {
<a name="l00763"></a>00763       <span class="keywordtype">int</span> locals_size = 0;
<a name="l00764"></a>00764       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> img[] = {
<a name="l00765"></a>00765         0x0f, 0xb6,             <span class="comment">/* in r0,0x3f */</span>
<a name="l00766"></a>00766         0xf8, 0x94,             <span class="comment">/* cli */</span>
<a name="l00767"></a>00767         0xde, 0xbf,             <span class="comment">/* out 0x3e,r29 ; SPH */</span>
<a name="l00768"></a>00768         0x0f, 0xbe,             <span class="comment">/* out 0x3f,r0  ; SREG */</span>
<a name="l00769"></a>00769         0xcd, 0xbf              <span class="comment">/* out 0x3d,r28 ; SPL */</span>
<a name="l00770"></a>00770       };
<a name="l00771"></a>00771       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> img_sig[] = {
<a name="l00772"></a>00772         0xde, 0xbf,             <span class="comment">/* out 0x3e,r29 ; SPH */</span>
<a name="l00773"></a>00773         0xcd, 0xbf              <span class="comment">/* out 0x3d,r28 ; SPL */</span>
<a name="l00774"></a>00774       };
<a name="l00775"></a>00775       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> img_int[] = {
<a name="l00776"></a>00776         0xf8, 0x94,             <span class="comment">/* cli */</span>
<a name="l00777"></a>00777         0xde, 0xbf,             <span class="comment">/* out 0x3e,r29 ; SPH */</span>
<a name="l00778"></a>00778         0x78, 0x94,             <span class="comment">/* sei */</span>
<a name="l00779"></a>00779         0xcd, 0xbf              <span class="comment">/* out 0x3d,r28 ; SPL */</span>
<a name="l00780"></a>00780       };
<a name="l00781"></a>00781 
<a name="l00782"></a>00782       insn = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;prologue[vpc], 2, byte_order);
<a name="l00783"></a>00783       <span class="keywordflow">if</span> ((insn &amp; 0xff30) == 0x9720)    <span class="comment">/* sbiw r28,XXX */</span>
<a name="l00784"></a>00784         {
<a name="l00785"></a>00785           locals_size = (insn &amp; 0xf) | ((insn &amp; 0xc0) &gt;&gt; 2);
<a name="l00786"></a>00786           vpc += 2;
<a name="l00787"></a>00787         }
<a name="l00788"></a>00788       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((insn &amp; 0xf0f0) == 0x50c0)       <span class="comment">/* subi r28,lo8(XX) */</span>
<a name="l00789"></a>00789         {
<a name="l00790"></a>00790           locals_size = (insn &amp; 0xf) | ((insn &amp; 0xf00) &gt;&gt; 4);
<a name="l00791"></a>00791           vpc += 2;
<a name="l00792"></a>00792           insn = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;prologue[vpc], 2, byte_order);
<a name="l00793"></a>00793           vpc += 2;
<a name="l00794"></a>00794           locals_size += ((insn &amp; 0xf) | ((insn &amp; 0xf00) &gt;&gt; 4)) &lt;&lt; 8;
<a name="l00795"></a>00795         }
<a name="l00796"></a>00796       <span class="keywordflow">else</span>
<a name="l00797"></a>00797         <span class="keywordflow">return</span> pc_beg + vpc;
<a name="l00798"></a>00798 
<a name="l00799"></a>00799       <span class="comment">/* Scan the last part of the prologue.  May not be present for interrupt</span>
<a name="l00800"></a>00800 <span class="comment">         or signal handler functions, which is why we set the prologue type</span>
<a name="l00801"></a>00801 <span class="comment">         when we saw the beginning of the prologue previously.  */</span>
<a name="l00802"></a>00802 
<a name="l00803"></a>00803       <span class="keywordflow">if</span> (vpc + <span class="keyword">sizeof</span> (img_sig) &lt; len
<a name="l00804"></a>00804           &amp;&amp; <a class="code" href="gdb__string_8h.html#a65c3e6b23d6855c86acaf147853c82cc">memcmp</a> (prologue + vpc, img_sig, <span class="keyword">sizeof</span> (img_sig)) == 0)
<a name="l00805"></a>00805         {
<a name="l00806"></a>00806           vpc += <span class="keyword">sizeof</span> (img_sig);
<a name="l00807"></a>00807         }
<a name="l00808"></a>00808       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vpc + <span class="keyword">sizeof</span> (img_int) &lt; len 
<a name="l00809"></a>00809                &amp;&amp; <a class="code" href="gdb__string_8h.html#a65c3e6b23d6855c86acaf147853c82cc">memcmp</a> (prologue + vpc, img_int, <span class="keyword">sizeof</span> (img_int)) == 0)
<a name="l00810"></a>00810         {
<a name="l00811"></a>00811           vpc += <span class="keyword">sizeof</span> (img_int);
<a name="l00812"></a>00812         }
<a name="l00813"></a>00813       <span class="keywordflow">if</span> (vpc + <span class="keyword">sizeof</span> (img) &lt; len
<a name="l00814"></a>00814           &amp;&amp; <a class="code" href="gdb__string_8h.html#a65c3e6b23d6855c86acaf147853c82cc">memcmp</a> (prologue + vpc, img, <span class="keyword">sizeof</span> (img)) == 0)
<a name="l00815"></a>00815         {
<a name="l00816"></a>00816           info-&gt;prologue_type = <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310ab6a9eca819be834fd33fb8f0494c8d12">AVR_PROLOGUE_NORMAL</a>;
<a name="l00817"></a>00817           vpc += <span class="keyword">sizeof</span> (img);
<a name="l00818"></a>00818         }
<a name="l00819"></a>00819 
<a name="l00820"></a>00820       info-&gt;size += locals_size;
<a name="l00821"></a>00821 
<a name="l00822"></a>00822       <span class="comment">/* Fall through.  */</span>
<a name="l00823"></a>00823     }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825   <span class="comment">/* If we got this far, we could not scan the prologue, so just return the pc</span>
<a name="l00826"></a>00826 <span class="comment">     of the frame plus an adjustment for argument move insns.  */</span>
<a name="l00827"></a>00827 
<a name="l00828"></a>00828   <span class="keywordflow">for</span> (; vpc &lt; <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>; vpc += 2)
<a name="l00829"></a>00829     {
<a name="l00830"></a>00830       insn = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;prologue[vpc], 2, byte_order);
<a name="l00831"></a>00831       <span class="keywordflow">if</span> ((insn &amp; 0xff00) == 0x0100)    <span class="comment">/* movw rXX, rYY */</span>
<a name="l00832"></a>00832         <span class="keywordflow">continue</span>;
<a name="l00833"></a>00833       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((insn &amp; 0xfc00) == 0x2c00) <span class="comment">/* mov rXX, rYY */</span>
<a name="l00834"></a>00834         <span class="keywordflow">continue</span>;
<a name="l00835"></a>00835       <span class="keywordflow">else</span>
<a name="l00836"></a>00836           <span class="keywordflow">break</span>;
<a name="l00837"></a>00837     }
<a name="l00838"></a>00838     
<a name="l00839"></a>00839   <span class="keywordflow">return</span> pc_beg + vpc;
<a name="l00840"></a>00840 }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l00843"></a>00843 avr_skip_prologue (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc)
<a name="l00844"></a>00844 {
<a name="l00845"></a>00845   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> func_addr, func_end;
<a name="l00846"></a>00846   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> post_prologue_pc;
<a name="l00847"></a>00847 
<a name="l00848"></a>00848   <span class="comment">/* See what the symbol table says */</span>
<a name="l00849"></a>00849 
<a name="l00850"></a>00850   <span class="keywordflow">if</span> (!<a class="code" href="blockframe_8c.html#a2dae2257ad1417604d2c26f8b9071ca9">find_pc_partial_function</a> (pc, NULL, &amp;func_addr, &amp;func_end))
<a name="l00851"></a>00851     <span class="keywordflow">return</span> pc;
<a name="l00852"></a>00852 
<a name="l00853"></a>00853   post_prologue_pc = <a class="code" href="symtab_8c.html#a5e411a18b63476022fe4b9420138ae44">skip_prologue_using_sal</a> (gdbarch, func_addr);
<a name="l00854"></a>00854   <span class="keywordflow">if</span> (post_prologue_pc != 0)
<a name="l00855"></a>00855     <span class="keywordflow">return</span> <a class="code" href="environ_8c.html#affe776513b24d84b39af8ab0930fef7f">max</a> (pc, post_prologue_pc);
<a name="l00856"></a>00856 
<a name="l00857"></a>00857   {
<a name="l00858"></a>00858     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> prologue_end = pc;
<a name="l00859"></a>00859     <span class="keyword">struct </span>avr_unwind_cache info = {0};
<a name="l00860"></a>00860     <span class="keyword">struct </span><a class="code" href="structtrad__frame__saved__reg.html">trad_frame_saved_reg</a> saved_regs[<a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a66c557cfface61bbcbf634853c30e94b">AVR_NUM_REGS</a>];
<a name="l00861"></a>00861 
<a name="l00862"></a>00862     info.saved_regs = saved_regs;
<a name="l00863"></a>00863     
<a name="l00864"></a>00864     <span class="comment">/* Need to run the prologue scanner to figure out if the function has a</span>
<a name="l00865"></a>00865 <span class="comment">       prologue and possibly skip over moving arguments passed via registers</span>
<a name="l00866"></a>00866 <span class="comment">       to other registers.  */</span>
<a name="l00867"></a>00867     
<a name="l00868"></a>00868     prologue_end = avr_scan_prologue (gdbarch, func_addr, func_end, &amp;info);
<a name="l00869"></a>00869     
<a name="l00870"></a>00870     <span class="keywordflow">if</span> (info.prologue_type != <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310ae06fb66b67f360c1e0c599f93ed429ba">AVR_PROLOGUE_NONE</a>)
<a name="l00871"></a>00871       <span class="keywordflow">return</span> prologue_end;
<a name="l00872"></a>00872   }
<a name="l00873"></a>00873 
<a name="l00874"></a>00874   <span class="comment">/* Either we didn&#39;t find the start of this function (nothing we can do),</span>
<a name="l00875"></a>00875 <span class="comment">     or there&#39;s no line info, or the line after the prologue is after</span>
<a name="l00876"></a>00876 <span class="comment">     the end of the function (there probably isn&#39;t a prologue).  */</span>
<a name="l00877"></a>00877 
<a name="l00878"></a>00878   <span class="keywordflow">return</span> pc;
<a name="l00879"></a>00879 }
<a name="l00880"></a>00880 
<a name="l00881"></a>00881 <span class="comment">/* Not all avr devices support the BREAK insn.  Those that don&#39;t should treat</span>
<a name="l00882"></a>00882 <span class="comment">   it as a NOP.  Thus, it should be ok.  Since the avr is currently a remote</span>
<a name="l00883"></a>00883 <span class="comment">   only target, this shouldn&#39;t be a problem (I hope).  TRoth/2003-05-14  */</span>
<a name="l00884"></a>00884 
<a name="l00885"></a>00885 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *
<a name="l00886"></a>00886 avr_breakpoint_from_pc (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l00887"></a>00887                         <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *pcptr, <span class="keywordtype">int</span> *lenptr)
<a name="l00888"></a>00888 {
<a name="l00889"></a>00889     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> avr_break_insn [] = { 0x98, 0x95 };
<a name="l00890"></a>00890     *lenptr = <span class="keyword">sizeof</span> (avr_break_insn);
<a name="l00891"></a>00891     <span class="keywordflow">return</span> avr_break_insn;
<a name="l00892"></a>00892 }
<a name="l00893"></a>00893 
<a name="l00894"></a>00894 <span class="comment">/* Determine, for architecture GDBARCH, how a return value of TYPE</span>
<a name="l00895"></a>00895 <span class="comment">   should be returned.  If it is supposed to be returned in registers,</span>
<a name="l00896"></a>00896 <span class="comment">   and READBUF is non-zero, read the appropriate value from REGCACHE,</span>
<a name="l00897"></a>00897 <span class="comment">   and copy it into READBUF.  If WRITEBUF is non-zero, write the value</span>
<a name="l00898"></a>00898 <span class="comment">   from WRITEBUF into REGCACHE.  */</span>
<a name="l00899"></a>00899 
<a name="l00900"></a>00900 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5">return_value_convention</a>
<a name="l00901"></a>00901 avr_return_value (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> value *<span class="keyword">function</span>,
<a name="l00902"></a>00902                   <span class="keyword">struct</span> type *valtype, <span class="keyword">struct</span> regcache *regcache,
<a name="l00903"></a>00903                   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *readbuf, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *writebuf)
<a name="l00904"></a>00904 {
<a name="l00905"></a>00905   <span class="keywordtype">int</span> i;
<a name="l00906"></a>00906   <span class="comment">/* Single byte are returned in r24.</span>
<a name="l00907"></a>00907 <span class="comment">     Otherwise, the MSB of the return value is always in r25, calculate which</span>
<a name="l00908"></a>00908 <span class="comment">     register holds the LSB.  */</span>
<a name="l00909"></a>00909   <span class="keywordtype">int</span> lsb_reg;
<a name="l00910"></a>00910 
<a name="l00911"></a>00911   <span class="keywordflow">if</span> ((<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (valtype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l00912"></a>00912        || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (valtype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>
<a name="l00913"></a>00913        || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (valtype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l00914"></a>00914       &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (valtype) &gt; 8)
<a name="l00915"></a>00915     <span class="keywordflow">return</span> <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5a1fab6a0bfd44af88ba17a143673dc937">RETURN_VALUE_STRUCT_CONVENTION</a>;
<a name="l00916"></a>00916 
<a name="l00917"></a>00917   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (valtype) &lt;= 2)
<a name="l00918"></a>00918     lsb_reg = 24;
<a name="l00919"></a>00919   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (valtype) &lt;= 4)
<a name="l00920"></a>00920     lsb_reg = 22;
<a name="l00921"></a>00921   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (valtype) &lt;= 8)
<a name="l00922"></a>00922     lsb_reg = 18;
<a name="l00923"></a>00923   <span class="keywordflow">else</span>
<a name="l00924"></a>00924     <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;unexpected type length&quot;</span>);
<a name="l00925"></a>00925 
<a name="l00926"></a>00926   <span class="keywordflow">if</span> (writebuf != NULL)
<a name="l00927"></a>00927     {
<a name="l00928"></a>00928       <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (valtype); i++)
<a name="l00929"></a>00929         <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (regcache, lsb_reg + i, writebuf + i);
<a name="l00930"></a>00930     }
<a name="l00931"></a>00931 
<a name="l00932"></a>00932   <span class="keywordflow">if</span> (readbuf != NULL)
<a name="l00933"></a>00933     {
<a name="l00934"></a>00934       <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (valtype); i++)
<a name="l00935"></a>00935         <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (regcache, lsb_reg + i, readbuf + i);
<a name="l00936"></a>00936     }
<a name="l00937"></a>00937 
<a name="l00938"></a>00938   <span class="keywordflow">return</span> <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5a0cd14b7546740080384acc0c7e5caf3b">RETURN_VALUE_REGISTER_CONVENTION</a>;
<a name="l00939"></a>00939 }
<a name="l00940"></a>00940 
<a name="l00941"></a>00941 
<a name="l00942"></a>00942 <span class="comment">/* Put here the code to store, into fi-&gt;saved_regs, the addresses of</span>
<a name="l00943"></a>00943 <span class="comment">   the saved registers of frame described by FRAME_INFO.  This</span>
<a name="l00944"></a>00944 <span class="comment">   includes special registers such as pc and fp saved in special ways</span>
<a name="l00945"></a>00945 <span class="comment">   in the stack frame.  sp is even more special: the address we return</span>
<a name="l00946"></a>00946 <span class="comment">   for it IS the sp for the next frame.  */</span>
<a name="l00947"></a>00947 
<a name="l00948"></a>00948 <span class="keyword">static</span> <span class="keyword">struct </span>avr_unwind_cache *
<a name="l00949"></a>00949 avr_frame_unwind_cache (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l00950"></a>00950                         <span class="keywordtype">void</span> **this_prologue_cache)
<a name="l00951"></a>00951 {
<a name="l00952"></a>00952   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_pc, current_pc;
<a name="l00953"></a>00953   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> prev_sp;
<a name="l00954"></a>00954   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> this_base;
<a name="l00955"></a>00955   <span class="keyword">struct </span>avr_unwind_cache *info;
<a name="l00956"></a>00956   <span class="keyword">struct </span>gdbarch *gdbarch;
<a name="l00957"></a>00957   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep;
<a name="l00958"></a>00958   <span class="keywordtype">int</span> i;
<a name="l00959"></a>00959 
<a name="l00960"></a>00960   <span class="keywordflow">if</span> (*this_prologue_cache)
<a name="l00961"></a>00961     <span class="keywordflow">return</span> *this_prologue_cache;
<a name="l00962"></a>00962 
<a name="l00963"></a>00963   info = <a class="code" href="frame_8h.html#af9f5c3008a0d58374aa310c5c63af552">FRAME_OBSTACK_ZALLOC</a> (<span class="keyword">struct</span> avr_unwind_cache);
<a name="l00964"></a>00964   *this_prologue_cache = info;
<a name="l00965"></a>00965   info-&gt;saved_regs = <a class="code" href="trad-frame_8c.html#a6b21318e80642c2b5e38b983f27cecec">trad_frame_alloc_saved_regs</a> (this_frame);
<a name="l00966"></a>00966 
<a name="l00967"></a>00967   info-&gt;size = 0;
<a name="l00968"></a>00968   info-&gt;prologue_type = <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310ae06fb66b67f360c1e0c599f93ed429ba">AVR_PROLOGUE_NONE</a>;
<a name="l00969"></a>00969 
<a name="l00970"></a>00970   start_pc = <a class="code" href="frame_8c.html#ac64c0ce600cc134b2256c0d507f57cde">get_frame_func</a> (this_frame);
<a name="l00971"></a>00971   current_pc = <a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a> (this_frame);
<a name="l00972"></a>00972   <span class="keywordflow">if</span> ((start_pc &gt; 0) &amp;&amp; (start_pc &lt;= current_pc))
<a name="l00973"></a>00973     avr_scan_prologue (<a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame),
<a name="l00974"></a>00974                        start_pc, current_pc, info);
<a name="l00975"></a>00975 
<a name="l00976"></a>00976   <span class="keywordflow">if</span> ((info-&gt;prologue_type != <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310ae06fb66b67f360c1e0c599f93ed429ba">AVR_PROLOGUE_NONE</a>)
<a name="l00977"></a>00977       &amp;&amp; (info-&gt;prologue_type != <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310ad64e1b7dad564c9a9fc61428705edaa9">AVR_PROLOGUE_MAIN</a>))
<a name="l00978"></a>00978     {
<a name="l00979"></a>00979       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> high_base;       <span class="comment">/* High byte of FP */</span>
<a name="l00980"></a>00980 
<a name="l00981"></a>00981       <span class="comment">/* The SP was moved to the FP.  This indicates that a new frame</span>
<a name="l00982"></a>00982 <span class="comment">         was created.  Get THIS frame&#39;s FP value by unwinding it from</span>
<a name="l00983"></a>00983 <span class="comment">         the next frame.  */</span>
<a name="l00984"></a>00984       this_base = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a79792e0be3fc1fdaebbf23abe831e456">AVR_FP_REGNUM</a>);
<a name="l00985"></a>00985       high_base = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a79792e0be3fc1fdaebbf23abe831e456">AVR_FP_REGNUM</a> + 1);
<a name="l00986"></a>00986       this_base += (high_base &lt;&lt; 8);
<a name="l00987"></a>00987       
<a name="l00988"></a>00988       <span class="comment">/* The FP points at the last saved register.  Adjust the FP back</span>
<a name="l00989"></a>00989 <span class="comment">         to before the first saved register giving the SP.  */</span>
<a name="l00990"></a>00990       prev_sp = this_base + info-&gt;size; 
<a name="l00991"></a>00991    }
<a name="l00992"></a>00992   <span class="keywordflow">else</span>
<a name="l00993"></a>00993     {
<a name="l00994"></a>00994       <span class="comment">/* Assume that the FP is this frame&#39;s SP but with that pushed</span>
<a name="l00995"></a>00995 <span class="comment">         stack space added back.  */</span>
<a name="l00996"></a>00996       this_base = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ad429b7dd2405a2fa524c985584d29f18">AVR_SP_REGNUM</a>);
<a name="l00997"></a>00997       prev_sp = this_base + info-&gt;size;
<a name="l00998"></a>00998     }
<a name="l00999"></a>00999 
<a name="l01000"></a>01000   <span class="comment">/* Add 1 here to adjust for the post-decrement nature of the push</span>
<a name="l01001"></a>01001 <span class="comment">     instruction.*/</span>
<a name="l01002"></a>01002   info-&gt;prev_sp = avr_make_saddr (prev_sp + 1);
<a name="l01003"></a>01003   info-&gt;base = avr_make_saddr (this_base);
<a name="l01004"></a>01004 
<a name="l01005"></a>01005   gdbarch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame);
<a name="l01006"></a>01006 
<a name="l01007"></a>01007   <span class="comment">/* Adjust all the saved registers so that they contain addresses and not</span>
<a name="l01008"></a>01008 <span class="comment">     offsets.  */</span>
<a name="l01009"></a>01009   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (gdbarch) - 1; i++)
<a name="l01010"></a>01010     <span class="keywordflow">if</span> (info-&gt;saved_regs[i].addr &gt; 0)
<a name="l01011"></a>01011       info-&gt;saved_regs[i].addr = info-&gt;prev_sp - info-&gt;saved_regs[i].addr;
<a name="l01012"></a>01012 
<a name="l01013"></a>01013   <span class="comment">/* Except for the main and startup code, the return PC is always saved on</span>
<a name="l01014"></a>01014 <span class="comment">     the stack and is at the base of the frame.  */</span>
<a name="l01015"></a>01015 
<a name="l01016"></a>01016   <span class="keywordflow">if</span> (info-&gt;prologue_type != <a class="code" href="avr-tdep_8c.html#a94798fdadfbf49a7c658ace669a1d310ad64e1b7dad564c9a9fc61428705edaa9">AVR_PROLOGUE_MAIN</a>)
<a name="l01017"></a>01017     info-&gt;saved_regs[<a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a710fcdc3ebf642dac1c9071077d5a253">AVR_PC_REGNUM</a>].addr = info-&gt;prev_sp;
<a name="l01018"></a>01018 
<a name="l01019"></a>01019   <span class="comment">/* The previous frame&#39;s SP needed to be computed.  Save the computed</span>
<a name="l01020"></a>01020 <span class="comment">     value.  */</span>
<a name="l01021"></a>01021   tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l01022"></a>01022   <a class="code" href="trad-frame_8c.html#aba845c5704e0bebe84b2a84eb8c9e962">trad_frame_set_value</a> (info-&gt;saved_regs, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ad429b7dd2405a2fa524c985584d29f18">AVR_SP_REGNUM</a>,
<a name="l01023"></a>01023                         info-&gt;prev_sp - 1 + tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a21863283280c459591999555b6062a6e">call_length</a>);
<a name="l01024"></a>01024 
<a name="l01025"></a>01025   <span class="keywordflow">return</span> info;
<a name="l01026"></a>01026 }
<a name="l01027"></a>01027 
<a name="l01028"></a>01028 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01029"></a>01029 avr_unwind_pc (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> frame_info *next_frame)
<a name="l01030"></a>01030 {
<a name="l01031"></a>01031   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structgdbarch__tdep.html#ab7a207d4e85b564c48238283745247b8">pc</a>;
<a name="l01032"></a>01032 
<a name="l01033"></a>01033   pc = <a class="code" href="frame_8c.html#a294f6912118884550787fd59f2a08ff6">frame_unwind_register_unsigned</a> (next_frame, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a710fcdc3ebf642dac1c9071077d5a253">AVR_PC_REGNUM</a>);
<a name="l01034"></a>01034 
<a name="l01035"></a>01035   <span class="keywordflow">return</span> avr_make_iaddr (pc);
<a name="l01036"></a>01036 }
<a name="l01037"></a>01037 
<a name="l01038"></a>01038 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01039"></a>01039 avr_unwind_sp (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> frame_info *next_frame)
<a name="l01040"></a>01040 {
<a name="l01041"></a>01041   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>;
<a name="l01042"></a>01042 
<a name="l01043"></a>01043   sp = <a class="code" href="frame_8c.html#a294f6912118884550787fd59f2a08ff6">frame_unwind_register_unsigned</a> (next_frame, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ad429b7dd2405a2fa524c985584d29f18">AVR_SP_REGNUM</a>);
<a name="l01044"></a>01044 
<a name="l01045"></a>01045   <span class="keywordflow">return</span> avr_make_saddr (sp);
<a name="l01046"></a>01046 }
<a name="l01047"></a>01047 
<a name="l01048"></a>01048 <span class="comment">/* Given a GDB frame, determine the address of the calling function&#39;s</span>
<a name="l01049"></a>01049 <span class="comment">   frame.  This will be used to create a new GDB frame struct.  */</span>
<a name="l01050"></a>01050 
<a name="l01051"></a>01051 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01052"></a>01052 avr_frame_this_id (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01053"></a>01053                    <span class="keywordtype">void</span> **this_prologue_cache,
<a name="l01054"></a>01054                    <span class="keyword">struct</span> <a class="code" href="structframe__id.html">frame_id</a> *this_id)
<a name="l01055"></a>01055 {
<a name="l01056"></a>01056   <span class="keyword">struct </span>avr_unwind_cache *info
<a name="l01057"></a>01057     = avr_frame_unwind_cache (this_frame, this_prologue_cache);
<a name="l01058"></a>01058   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> base;
<a name="l01059"></a>01059   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>;
<a name="l01060"></a>01060   <span class="keyword">struct </span><a class="code" href="structframe__id.html">frame_id</a> id;
<a name="l01061"></a>01061 
<a name="l01062"></a>01062   <span class="comment">/* The FUNC is easy.  */</span>
<a name="l01063"></a>01063   func = <a class="code" href="frame_8c.html#ac64c0ce600cc134b2256c0d507f57cde">get_frame_func</a> (this_frame);
<a name="l01064"></a>01064 
<a name="l01065"></a>01065   <span class="comment">/* Hopefully the prologue analysis either correctly determined the</span>
<a name="l01066"></a>01066 <span class="comment">     frame&#39;s base (which is the SP from the previous frame), or set</span>
<a name="l01067"></a>01067 <span class="comment">     that base to &quot;NULL&quot;.  */</span>
<a name="l01068"></a>01068   base = info-&gt;prev_sp;
<a name="l01069"></a>01069   <span class="keywordflow">if</span> (base == 0)
<a name="l01070"></a>01070     <span class="keywordflow">return</span>;
<a name="l01071"></a>01071 
<a name="l01072"></a>01072   <span class="keywordtype">id</span> = <a class="code" href="frame_8c.html#a7f32da6ddc275b4684c301448d891f5b">frame_id_build</a> (base, func);
<a name="l01073"></a>01073   (*this_id) = id;
<a name="l01074"></a>01074 }
<a name="l01075"></a>01075 
<a name="l01076"></a>01076 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l01077"></a>01077 avr_frame_prev_register (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01078"></a>01078                          <span class="keywordtype">void</span> **this_prologue_cache, <span class="keywordtype">int</span> regnum)
<a name="l01079"></a>01079 {
<a name="l01080"></a>01080   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame);
<a name="l01081"></a>01081   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l01082"></a>01082   <span class="keyword">struct </span>avr_unwind_cache *info
<a name="l01083"></a>01083     = avr_frame_unwind_cache (this_frame, this_prologue_cache);
<a name="l01084"></a>01084 
<a name="l01085"></a>01085   <span class="keywordflow">if</span> (regnum == <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a710fcdc3ebf642dac1c9071077d5a253">AVR_PC_REGNUM</a> || regnum == <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ac2913e1229c3d0deea6ebd6bad5aef96">AVR_PSEUDO_PC_REGNUM</a>)
<a name="l01086"></a>01086     {
<a name="l01087"></a>01087       <span class="keywordflow">if</span> (<a class="code" href="trad-frame_8c.html#aa3a0e933330792e061147f62a08b7a32">trad_frame_addr_p</a> (info-&gt;saved_regs, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a710fcdc3ebf642dac1c9071077d5a253">AVR_PC_REGNUM</a>))
<a name="l01088"></a>01088         {
<a name="l01089"></a>01089           <span class="comment">/* Reading the return PC from the PC register is slightly</span>
<a name="l01090"></a>01090 <span class="comment">             abnormal.  register_size(AVR_PC_REGNUM) says it is 4 bytes,</span>
<a name="l01091"></a>01091 <span class="comment">             but in reality, only two bytes (3 in upcoming mega256) are</span>
<a name="l01092"></a>01092 <span class="comment">             stored on the stack.</span>
<a name="l01093"></a>01093 <span class="comment"></span>
<a name="l01094"></a>01094 <span class="comment">             Also, note that the value on the stack is an addr to a word</span>
<a name="l01095"></a>01095 <span class="comment">             not a byte, so we will need to multiply it by two at some</span>
<a name="l01096"></a>01096 <span class="comment">             point. </span>
<a name="l01097"></a>01097 <span class="comment"></span>
<a name="l01098"></a>01098 <span class="comment">             And to confuse matters even more, the return address stored</span>
<a name="l01099"></a>01099 <span class="comment">             on the stack is in big endian byte order, even though most</span>
<a name="l01100"></a>01100 <span class="comment">             everything else about the avr is little endian.  Ick!  */</span>
<a name="l01101"></a>01101           <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> pc;
<a name="l01102"></a>01102           <span class="keywordtype">int</span> i;
<a name="l01103"></a>01103           <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> buf[3];
<a name="l01104"></a>01104           <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame);
<a name="l01105"></a>01105           <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l01106"></a>01106 
<a name="l01107"></a>01107           <a class="code" href="corefile_8c.html#a5e0189c6f21f1c9321b379877183b819">read_memory</a> (info-&gt;saved_regs[<a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a710fcdc3ebf642dac1c9071077d5a253">AVR_PC_REGNUM</a>].addr,
<a name="l01108"></a>01108                        buf, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a21863283280c459591999555b6062a6e">call_length</a>);
<a name="l01109"></a>01109 
<a name="l01110"></a>01110           <span class="comment">/* Extract the PC read from memory as a big-endian.  */</span>
<a name="l01111"></a>01111           pc = 0;
<a name="l01112"></a>01112           <span class="keywordflow">for</span> (i = 0; i &lt; tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a21863283280c459591999555b6062a6e">call_length</a>; i++)
<a name="l01113"></a>01113             pc = (pc &lt;&lt; 8) | buf[i];
<a name="l01114"></a>01114 
<a name="l01115"></a>01115           <span class="keywordflow">if</span> (regnum == <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a710fcdc3ebf642dac1c9071077d5a253">AVR_PC_REGNUM</a>)
<a name="l01116"></a>01116             pc &lt;&lt;= 1;
<a name="l01117"></a>01117 
<a name="l01118"></a>01118           <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#ac7df103c9cdd8847accaa5752e4f52ea">frame_unwind_got_constant</a> (this_frame, regnum, pc);
<a name="l01119"></a>01119         }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121       <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#a67cc0ab2f5ae49818e1f9648bea131c9">frame_unwind_got_optimized</a> (this_frame, regnum);
<a name="l01122"></a>01122     }
<a name="l01123"></a>01123 
<a name="l01124"></a>01124   <span class="keywordflow">return</span> <a class="code" href="trad-frame_8c.html#a942094830577eeb218e28c3c84452d59">trad_frame_get_prev_register</a> (this_frame, info-&gt;saved_regs, regnum);
<a name="l01125"></a>01125 }
<a name="l01126"></a>01126 
<a name="l01127"></a>01127 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structframe__unwind.html">frame_unwind</a> avr_frame_unwind = {
<a name="l01128"></a>01128   <a class="code" href="frame_8h.html#a3ca2c0bc7578bf3d337e34b2c08a6c5faeb4f7fd6d9e397d1141feb133746637a">NORMAL_FRAME</a>,
<a name="l01129"></a>01129   <a class="code" href="frame-unwind_8c.html#aa950afe60921514574c6150f0821f05c">default_frame_unwind_stop_reason</a>,
<a name="l01130"></a>01130   avr_frame_this_id,
<a name="l01131"></a>01131   avr_frame_prev_register,
<a name="l01132"></a>01132   NULL,
<a name="l01133"></a>01133   <a class="code" href="frame-unwind_8c.html#ade64a9807fa508622581cc779b10ff9c">default_frame_sniffer</a>
<a name="l01134"></a>01134 };
<a name="l01135"></a>01135 
<a name="l01136"></a>01136 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01137"></a>01137 avr_frame_base_address (<span class="keyword">struct</span> frame_info *this_frame, <span class="keywordtype">void</span> **this_cache)
<a name="l01138"></a>01138 {
<a name="l01139"></a>01139   <span class="keyword">struct </span>avr_unwind_cache *info
<a name="l01140"></a>01140     = avr_frame_unwind_cache (this_frame, this_cache);
<a name="l01141"></a>01141 
<a name="l01142"></a>01142   <span class="keywordflow">return</span> info-&gt;base;
<a name="l01143"></a>01143 }
<a name="l01144"></a>01144 
<a name="l01145"></a>01145 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structframe__base.html">frame_base</a> avr_frame_base = {
<a name="l01146"></a>01146   &amp;avr_frame_unwind,
<a name="l01147"></a>01147   avr_frame_base_address,
<a name="l01148"></a>01148   avr_frame_base_address,
<a name="l01149"></a>01149   avr_frame_base_address
<a name="l01150"></a>01150 };
<a name="l01151"></a>01151 
<a name="l01152"></a>01152 <span class="comment">/* Assuming THIS_FRAME is a dummy, return the frame ID of that dummy</span>
<a name="l01153"></a>01153 <span class="comment">   frame.  The frame ID&#39;s base needs to match the TOS value saved by</span>
<a name="l01154"></a>01154 <span class="comment">   save_dummy_frame_tos(), and the PC match the dummy frame&#39;s breakpoint.  */</span>
<a name="l01155"></a>01155 
<a name="l01156"></a>01156 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structframe__id.html">frame_id</a>
<a name="l01157"></a>01157 avr_dummy_id (struct gdbarch *gdbarch, <span class="keyword">struct </span>frame_info *this_frame)
<a name="l01158"></a>01158 {
<a name="l01159"></a>01159   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> base;
<a name="l01160"></a>01160 
<a name="l01161"></a>01161   base = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ad429b7dd2405a2fa524c985584d29f18">AVR_SP_REGNUM</a>);
<a name="l01162"></a>01162   <span class="keywordflow">return</span> <a class="code" href="frame_8c.html#a7f32da6ddc275b4684c301448d891f5b">frame_id_build</a> (avr_make_saddr (base), <a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a> (this_frame));
<a name="l01163"></a>01163 }
<a name="l01164"></a>01164 
<a name="l01165"></a>01165 <span class="comment">/* When arguments must be pushed onto the stack, they go on in reverse</span>
<a name="l01166"></a>01166 <span class="comment">   order.  The below implements a FILO (stack) to do this.  */</span>
<a name="l01167"></a>01167 
<a name="l01168"></a>01168 <span class="keyword">struct </span>stack_item
<a name="l01169"></a>01169 {
<a name="l01170"></a>01170   <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l01171"></a>01171   <span class="keyword">struct </span>stack_item *prev;
<a name="l01172"></a>01172   <span class="keywordtype">void</span> *data;
<a name="l01173"></a>01173 };
<a name="l01174"></a>01174 
<a name="l01175"></a>01175 <span class="keyword">static</span> <span class="keyword">struct </span>stack_item *
<a name="l01176"></a>01176 push_stack_item (<span class="keyword">struct</span> stack_item *prev, <span class="keyword">const</span> bfd_byte *contents, <span class="keywordtype">int</span> len)
<a name="l01177"></a>01177 {
<a name="l01178"></a>01178   <span class="keyword">struct </span>stack_item *si;
<a name="l01179"></a>01179   si = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> stack_item));
<a name="l01180"></a>01180   si-&gt;data = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (len);
<a name="l01181"></a>01181   si-&gt;len = <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l01182"></a>01182   si-&gt;prev = prev;
<a name="l01183"></a>01183   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (si-&gt;data, contents, len);
<a name="l01184"></a>01184   <span class="keywordflow">return</span> si;
<a name="l01185"></a>01185 }
<a name="l01186"></a>01186 
<a name="l01187"></a>01187 <span class="keyword">static</span> <span class="keyword">struct </span>stack_item *pop_stack_item (<span class="keyword">struct</span> stack_item *si);
<a name="l01188"></a>01188 <span class="keyword">static</span> <span class="keyword">struct </span>stack_item *
<a name="l01189"></a>01189 pop_stack_item (<span class="keyword">struct</span> stack_item *si)
<a name="l01190"></a>01190 {
<a name="l01191"></a>01191   <span class="keyword">struct </span>stack_item *dead = si;
<a name="l01192"></a>01192   si = si-&gt;prev;
<a name="l01193"></a>01193   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (dead-&gt;data);
<a name="l01194"></a>01194   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (dead);
<a name="l01195"></a>01195   <span class="keywordflow">return</span> si;
<a name="l01196"></a>01196 }
<a name="l01197"></a>01197 
<a name="l01198"></a>01198 <span class="comment">/* Setup the function arguments for calling a function in the inferior.</span>
<a name="l01199"></a>01199 <span class="comment"></span>
<a name="l01200"></a>01200 <span class="comment">   On the AVR architecture, there are 18 registers (R25 to R8) which are</span>
<a name="l01201"></a>01201 <span class="comment">   dedicated for passing function arguments.  Up to the first 18 arguments</span>
<a name="l01202"></a>01202 <span class="comment">   (depending on size) may go into these registers.  The rest go on the stack.</span>
<a name="l01203"></a>01203 <span class="comment"></span>
<a name="l01204"></a>01204 <span class="comment">   All arguments are aligned to start in even-numbered registers (odd-sized</span>
<a name="l01205"></a>01205 <span class="comment">   arguments, including char, have one free register above them).  For example,</span>
<a name="l01206"></a>01206 <span class="comment">   an int in arg1 and a char in arg2 would be passed as such:</span>
<a name="l01207"></a>01207 <span class="comment"></span>
<a name="l01208"></a>01208 <span class="comment">      arg1 -&gt; r25:r24</span>
<a name="l01209"></a>01209 <span class="comment">      arg2 -&gt; r22</span>
<a name="l01210"></a>01210 <span class="comment"></span>
<a name="l01211"></a>01211 <span class="comment">   Arguments that are larger than 2 bytes will be split between two or more</span>
<a name="l01212"></a>01212 <span class="comment">   registers as available, but will NOT be split between a register and the</span>
<a name="l01213"></a>01213 <span class="comment">   stack.  Arguments that go onto the stack are pushed last arg first (this is</span>
<a name="l01214"></a>01214 <span class="comment">   similar to the d10v).  */</span>
<a name="l01215"></a>01215 
<a name="l01216"></a>01216 <span class="comment">/* NOTE: TRoth/2003-06-17: The rest of this comment is old looks to be</span>
<a name="l01217"></a>01217 <span class="comment">   inaccurate.</span>
<a name="l01218"></a>01218 <span class="comment"></span>
<a name="l01219"></a>01219 <span class="comment">   An exceptional case exists for struct arguments (and possibly other</span>
<a name="l01220"></a>01220 <span class="comment">   aggregates such as arrays) -- if the size is larger than WORDSIZE bytes but</span>
<a name="l01221"></a>01221 <span class="comment">   not a multiple of WORDSIZE bytes.  In this case the argument is never split</span>
<a name="l01222"></a>01222 <span class="comment">   between the registers and the stack, but instead is copied in its entirety</span>
<a name="l01223"></a>01223 <span class="comment">   onto the stack, AND also copied into as many registers as there is room</span>
<a name="l01224"></a>01224 <span class="comment">   for.  In other words, space in registers permitting, two copies of the same</span>
<a name="l01225"></a>01225 <span class="comment">   argument are passed in.  As far as I can tell, only the one on the stack is</span>
<a name="l01226"></a>01226 <span class="comment">   used, although that may be a function of the level of compiler</span>
<a name="l01227"></a>01227 <span class="comment">   optimization.  I suspect this is a compiler bug.  Arguments of these odd</span>
<a name="l01228"></a>01228 <span class="comment">   sizes are left-justified within the word (as opposed to arguments smaller</span>
<a name="l01229"></a>01229 <span class="comment">   than WORDSIZE bytes, which are right-justified).</span>
<a name="l01230"></a>01230 <span class="comment"> </span>
<a name="l01231"></a>01231 <span class="comment">   If the function is to return an aggregate type such as a struct, the caller</span>
<a name="l01232"></a>01232 <span class="comment">   must allocate space into which the callee will copy the return value.  In</span>
<a name="l01233"></a>01233 <span class="comment">   this case, a pointer to the return value location is passed into the callee</span>
<a name="l01234"></a>01234 <span class="comment">   in register R0, which displaces one of the other arguments passed in via</span>
<a name="l01235"></a>01235 <span class="comment">   registers R0 to R2.  */</span>
<a name="l01236"></a>01236 
<a name="l01237"></a>01237 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01238"></a>01238 avr_push_dummy_call (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> value *<span class="keyword">function</span>,
<a name="l01239"></a>01239                      <span class="keyword">struct</span> regcache *regcache, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> bp_addr,
<a name="l01240"></a>01240                      <span class="keywordtype">int</span> nargs, <span class="keyword">struct</span> value **args, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> sp,
<a name="l01241"></a>01241                      <span class="keywordtype">int</span> <a class="code" href="arm-tdep_8h.html#aabb639d85dec2f973451bb1e7b6d1be8">struct_return</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> struct_addr)
<a name="l01242"></a>01242 {
<a name="l01243"></a>01243   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l01244"></a>01244   <span class="keywordtype">int</span> i;
<a name="l01245"></a>01245   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> buf[3];
<a name="l01246"></a>01246   <span class="keywordtype">int</span> call_length = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a21863283280c459591999555b6062a6e">call_length</a>;
<a name="l01247"></a>01247   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> return_pc = avr_convert_iaddr_to_raw (bp_addr);
<a name="l01248"></a>01248   <span class="keywordtype">int</span> regnum = <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a2ff00eb0b451e9354886694e5a0b162e">AVR_ARGN_REGNUM</a>;
<a name="l01249"></a>01249   <span class="keyword">struct </span>stack_item *si = NULL;
<a name="l01250"></a>01250 
<a name="l01251"></a>01251   <span class="keywordflow">if</span> (struct_return)
<a name="l01252"></a>01252     {
<a name="l01253"></a>01253       <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a>
<a name="l01254"></a>01254         (regcache, regnum--, (struct_addr &gt;&gt; 8) &amp; 0xff);
<a name="l01255"></a>01255       <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a>
<a name="l01256"></a>01256         (regcache, regnum--, struct_addr &amp; 0xff);
<a name="l01257"></a>01257       <span class="comment">/* SP being post decremented, we need to reserve one byte so that the</span>
<a name="l01258"></a>01258 <span class="comment">         return address won&#39;t overwrite the result (or vice-versa).  */</span>
<a name="l01259"></a>01259       <span class="keywordflow">if</span> (sp == struct_addr)
<a name="l01260"></a>01260         sp--;
<a name="l01261"></a>01261     }
<a name="l01262"></a>01262 
<a name="l01263"></a>01263   <span class="keywordflow">for</span> (i = 0; i &lt; nargs; i++)
<a name="l01264"></a>01264     {
<a name="l01265"></a>01265       <span class="keywordtype">int</span> last_regnum;
<a name="l01266"></a>01266       <span class="keywordtype">int</span> j;
<a name="l01267"></a>01267       <span class="keyword">struct </span>value *arg = args[i];
<a name="l01268"></a>01268       <span class="keyword">struct </span>type *type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg));
<a name="l01269"></a>01269       <span class="keyword">const</span> bfd_byte *contents = <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (arg);
<a name="l01270"></a>01270       <span class="keywordtype">int</span> len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type);
<a name="l01271"></a>01271 
<a name="l01272"></a>01272       <span class="comment">/* Calculate the potential last register needed.  */</span>
<a name="l01273"></a>01273       last_regnum = regnum - (len + (len &amp; 1));
<a name="l01274"></a>01274 
<a name="l01275"></a>01275       <span class="comment">/* If there are registers available, use them.  Once we start putting</span>
<a name="l01276"></a>01276 <span class="comment">         stuff on the stack, all subsequent args go on stack.  */</span>
<a name="l01277"></a>01277       <span class="keywordflow">if</span> ((si == NULL) &amp;&amp; (last_regnum &gt;= 8))
<a name="l01278"></a>01278         {
<a name="l01279"></a>01279           <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> val;
<a name="l01280"></a>01280 
<a name="l01281"></a>01281           <span class="comment">/* Skip a register for odd length args.  */</span>
<a name="l01282"></a>01282           <span class="keywordflow">if</span> (len &amp; 1)
<a name="l01283"></a>01283             regnum--;
<a name="l01284"></a>01284 
<a name="l01285"></a>01285           val = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (contents, len, byte_order);
<a name="l01286"></a>01286           <span class="keywordflow">for</span> (j = 0; j &lt; <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>; j++)
<a name="l01287"></a>01287             <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a>
<a name="l01288"></a>01288               (regcache, regnum--, val &gt;&gt; (8 * (len - j - 1)));
<a name="l01289"></a>01289         }
<a name="l01290"></a>01290       <span class="comment">/* No registers available, push the args onto the stack.  */</span>
<a name="l01291"></a>01291       <span class="keywordflow">else</span>
<a name="l01292"></a>01292         {
<a name="l01293"></a>01293           <span class="comment">/* From here on, we don&#39;t care about regnum.  */</span>
<a name="l01294"></a>01294           si = push_stack_item (si, contents, len);
<a name="l01295"></a>01295         }
<a name="l01296"></a>01296     }
<a name="l01297"></a>01297 
<a name="l01298"></a>01298   <span class="comment">/* Push args onto the stack.  */</span>
<a name="l01299"></a>01299   <span class="keywordflow">while</span> (si)
<a name="l01300"></a>01300     {
<a name="l01301"></a>01301       sp -= si-&gt;len;
<a name="l01302"></a>01302       <span class="comment">/* Add 1 to sp here to account for post decr nature of pushes.  */</span>
<a name="l01303"></a>01303       <a class="code" href="corefile_8c.html#a05c568c157071d9349667fab589228e5">write_memory</a> (sp + 1, si-&gt;data, si-&gt;len);
<a name="l01304"></a>01304       si = pop_stack_item (si);
<a name="l01305"></a>01305     }
<a name="l01306"></a>01306 
<a name="l01307"></a>01307   <span class="comment">/* Set the return address.  For the avr, the return address is the BP_ADDR.</span>
<a name="l01308"></a>01308 <span class="comment">     Need to push the return address onto the stack noting that it needs to be</span>
<a name="l01309"></a>01309 <span class="comment">     in big-endian order on the stack.  */</span>
<a name="l01310"></a>01310   <span class="keywordflow">for</span> (i = 1; i &lt;= call_length; i++)
<a name="l01311"></a>01311     {
<a name="l01312"></a>01312       buf[call_length - i] = return_pc &amp; 0xff;
<a name="l01313"></a>01313       return_pc &gt;&gt;= 8;
<a name="l01314"></a>01314     }
<a name="l01315"></a>01315 
<a name="l01316"></a>01316   sp -= call_length;
<a name="l01317"></a>01317   <span class="comment">/* Use &#39;sp + 1&#39; since pushes are post decr ops.  */</span>
<a name="l01318"></a>01318   <a class="code" href="corefile_8c.html#a05c568c157071d9349667fab589228e5">write_memory</a> (sp + 1, buf, call_length);
<a name="l01319"></a>01319 
<a name="l01320"></a>01320   <span class="comment">/* Finally, update the SP register.  */</span>
<a name="l01321"></a>01321   <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a> (regcache, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ad429b7dd2405a2fa524c985584d29f18">AVR_SP_REGNUM</a>,
<a name="l01322"></a>01322                                   avr_convert_saddr_to_raw (sp));
<a name="l01323"></a>01323 
<a name="l01324"></a>01324   <span class="comment">/* Return SP value for the dummy frame, where the return address hasn&#39;t been</span>
<a name="l01325"></a>01325 <span class="comment">     pushed.  */</span>
<a name="l01326"></a>01326   <span class="keywordflow">return</span> sp + call_length;
<a name="l01327"></a>01327 }
<a name="l01328"></a>01328 
<a name="l01329"></a>01329 <span class="comment">/* Unfortunately dwarf2 register for SP is 32.  */</span>
<a name="l01330"></a>01330 
<a name="l01331"></a>01331 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01332"></a>01332 avr_dwarf_reg_to_regnum (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> <a class="code" href="structreg.html">reg</a>)
<a name="l01333"></a>01333 {
<a name="l01334"></a>01334   <span class="keywordflow">if</span> (reg &gt;= 0 &amp;&amp; reg &lt; 32)
<a name="l01335"></a>01335     <span class="keywordflow">return</span> reg;
<a name="l01336"></a>01336   <span class="keywordflow">if</span> (reg == 32)
<a name="l01337"></a>01337     <span class="keywordflow">return</span> <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ad429b7dd2405a2fa524c985584d29f18">AVR_SP_REGNUM</a>;
<a name="l01338"></a>01338 
<a name="l01339"></a>01339   <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unmapped DWARF Register #%d encountered.&quot;</span>), reg);
<a name="l01340"></a>01340 
<a name="l01341"></a>01341   <span class="keywordflow">return</span> -1;
<a name="l01342"></a>01342 }
<a name="l01343"></a>01343 
<a name="l01344"></a>01344 <span class="comment">/* Initialize the gdbarch structure for the AVR&#39;s.  */</span>
<a name="l01345"></a>01345 
<a name="l01346"></a>01346 <span class="keyword">static</span> <span class="keyword">struct </span>gdbarch *
<a name="l01347"></a>01347 avr_gdbarch_init (<span class="keyword">struct</span> <a class="code" href="structgdbarch__info.html">gdbarch_info</a> info, <span class="keyword">struct</span> <a class="code" href="structgdbarch__list.html">gdbarch_list</a> *arches)
<a name="l01348"></a>01348 {
<a name="l01349"></a>01349   <span class="keyword">struct </span>gdbarch *gdbarch;
<a name="l01350"></a>01350   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep;
<a name="l01351"></a>01351   <span class="keyword">struct </span><a class="code" href="structgdbarch__list.html">gdbarch_list</a> *best_arch;
<a name="l01352"></a>01352   <span class="keywordtype">int</span> call_length;
<a name="l01353"></a>01353 
<a name="l01354"></a>01354   <span class="comment">/* Avr-6 call instructions save 3 bytes.  */</span>
<a name="l01355"></a>01355   <span class="keywordflow">switch</span> (info.<a class="code" href="structgdbarch__info.html#ad42b7b45e0927c2482ba178db64b2fa7">bfd_arch_info</a>-&gt;mach)
<a name="l01356"></a>01356     {
<a name="l01357"></a>01357     <span class="keywordflow">case</span> bfd_mach_avr1:
<a name="l01358"></a>01358     <span class="keywordflow">case</span> bfd_mach_avr2:
<a name="l01359"></a>01359     <span class="keywordflow">case</span> bfd_mach_avr3:
<a name="l01360"></a>01360     <span class="keywordflow">case</span> bfd_mach_avr4:
<a name="l01361"></a>01361     <span class="keywordflow">case</span> bfd_mach_avr5:
<a name="l01362"></a>01362     <span class="keywordflow">default</span>:
<a name="l01363"></a>01363       call_length = 2;
<a name="l01364"></a>01364       <span class="keywordflow">break</span>;
<a name="l01365"></a>01365     <span class="keywordflow">case</span> bfd_mach_avr6:
<a name="l01366"></a>01366       call_length = 3;
<a name="l01367"></a>01367       <span class="keywordflow">break</span>;
<a name="l01368"></a>01368     }
<a name="l01369"></a>01369 
<a name="l01370"></a>01370   <span class="comment">/* If there is already a candidate, use it.  */</span>
<a name="l01371"></a>01371   <span class="keywordflow">for</span> (best_arch = <a class="code" href="gdbarch_8c.html#aa3ea1c25a21a533dfd0d924a7d9778e4">gdbarch_list_lookup_by_info</a> (arches, &amp;info);
<a name="l01372"></a>01372        best_arch != NULL;
<a name="l01373"></a>01373        best_arch = <a class="code" href="gdbarch_8c.html#aa3ea1c25a21a533dfd0d924a7d9778e4">gdbarch_list_lookup_by_info</a> (best_arch-&gt;<a class="code" href="structgdbarch__list.html#a9da6f84112797b67d5d8e7b8d4e26b14">next</a>, &amp;info))
<a name="l01374"></a>01374     {
<a name="l01375"></a>01375       <span class="keywordflow">if</span> (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (best_arch-&gt;<a class="code" href="structgdbarch__list.html#a6c51da8c4c95249704dfe18394fd08f9">gdbarch</a>)-&gt;<a class="code" href="structgdbarch__tdep.html#a21863283280c459591999555b6062a6e">call_length</a> == call_length)
<a name="l01376"></a>01376         <span class="keywordflow">return</span> best_arch-&gt;<a class="code" href="structgdbarch__list.html#a6c51da8c4c95249704dfe18394fd08f9">gdbarch</a>;
<a name="l01377"></a>01377     }
<a name="l01378"></a>01378 
<a name="l01379"></a>01379   <span class="comment">/* None found, create a new architecture from the information provided.  */</span>
<a name="l01380"></a>01380   tdep = <a class="code" href="defs_8h.html#ab6751cea794fc22fa3696fe15df3139b">XMALLOC</a> (<span class="keyword">struct</span> <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a>);
<a name="l01381"></a>01381   gdbarch = <a class="code" href="gdbarch_8c.html#a9e0b0979fa2cb7439f41f66deda8dec5">gdbarch_alloc</a> (&amp;info, tdep);
<a name="l01382"></a>01382   
<a name="l01383"></a>01383   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a21863283280c459591999555b6062a6e">call_length</a> = call_length;
<a name="l01384"></a>01384 
<a name="l01385"></a>01385   <span class="comment">/* Create a type for PC.  We can&#39;t use builtin types here, as they may not</span>
<a name="l01386"></a>01386 <span class="comment">     be defined.  */</span>
<a name="l01387"></a>01387   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad159819964eb302372730437c3cc5765">void_type</a> = <a class="code" href="gdbtypes_8c.html#a4b444f0f6cfacb3f35d68fd7866402e2">arch_type</a> (gdbarch, <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>, 1, <span class="stringliteral">&quot;void&quot;</span>);
<a name="l01388"></a>01388   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a761302fd75c883786d1d0012fed0f133">func_void_type</a> = <a class="code" href="gdbtypes_8c.html#a0faf05fe325d2ad028dcc2630056fb88">make_function_type</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad159819964eb302372730437c3cc5765">void_type</a>, NULL);
<a name="l01389"></a>01389   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a5d2773c93a7aa393a6d05583e0971b0f">pc_type</a> = <a class="code" href="gdbtypes_8c.html#a4b444f0f6cfacb3f35d68fd7866402e2">arch_type</a> (gdbarch, <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>, 4, NULL);
<a name="l01390"></a>01390   <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a5d2773c93a7aa393a6d05583e0971b0f">pc_type</a>) = tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a761302fd75c883786d1d0012fed0f133">func_void_type</a>;
<a name="l01391"></a>01391   <a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">TYPE_UNSIGNED</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a5d2773c93a7aa393a6d05583e0971b0f">pc_type</a>) = 1;
<a name="l01392"></a>01392 
<a name="l01393"></a>01393   <a class="code" href="gdbarch_8c.html#aa8ab344aebdb71839678ff3d3e248f9b">set_gdbarch_short_bit</a> (gdbarch, 2 * TARGET_CHAR_BIT);
<a name="l01394"></a>01394   <a class="code" href="gdbarch_8c.html#a4dbde89c15b9ee9f1808a4e01f2a758d">set_gdbarch_int_bit</a> (gdbarch, 2 * TARGET_CHAR_BIT);
<a name="l01395"></a>01395   <a class="code" href="gdbarch_8c.html#ab661d4332c2357c6242d5f3f57f1bc44">set_gdbarch_long_bit</a> (gdbarch, 4 * TARGET_CHAR_BIT);
<a name="l01396"></a>01396   <a class="code" href="gdbarch_8c.html#a00b33f93ffedea6960d0ed4a9d7e1fba">set_gdbarch_long_long_bit</a> (gdbarch, 8 * TARGET_CHAR_BIT);
<a name="l01397"></a>01397   <a class="code" href="gdbarch_8c.html#abaaa21a756f3f8a689513c6df8b47ced">set_gdbarch_ptr_bit</a> (gdbarch, 2 * TARGET_CHAR_BIT);
<a name="l01398"></a>01398   <a class="code" href="gdbarch_8c.html#a028fd40e003f89fcf02d7c2f9335b6ad">set_gdbarch_addr_bit</a> (gdbarch, 32);
<a name="l01399"></a>01399 
<a name="l01400"></a>01400   <a class="code" href="gdbarch_8c.html#aa04e7a5715ca0c94652f8d35f44411f7">set_gdbarch_float_bit</a> (gdbarch, 4 * TARGET_CHAR_BIT);
<a name="l01401"></a>01401   <a class="code" href="gdbarch_8c.html#a6dde6fbd6439a96136e99bed4a7d98cd">set_gdbarch_double_bit</a> (gdbarch, 4 * TARGET_CHAR_BIT);
<a name="l01402"></a>01402   <a class="code" href="gdbarch_8c.html#ada51ef491e1e7d747c9a974639adf84d">set_gdbarch_long_double_bit</a> (gdbarch, 4 * TARGET_CHAR_BIT);
<a name="l01403"></a>01403 
<a name="l01404"></a>01404   <a class="code" href="gdbarch_8c.html#af3d3823011ac395f80e7f616ba59d252">set_gdbarch_float_format</a> (gdbarch, <a class="code" href="gdbtypes_8c.html#a2fcc5f34f85af43cce0eb78225fd2a11">floatformats_ieee_single</a>);
<a name="l01405"></a>01405   <a class="code" href="gdbarch_8c.html#aeda072f3599a56ad1fdfe82f4c99f1f8">set_gdbarch_double_format</a> (gdbarch, <a class="code" href="gdbtypes_8c.html#a2fcc5f34f85af43cce0eb78225fd2a11">floatformats_ieee_single</a>);
<a name="l01406"></a>01406   <a class="code" href="gdbarch_8c.html#a882287a38d1557dce54fdb2172756b2f">set_gdbarch_long_double_format</a> (gdbarch, <a class="code" href="gdbtypes_8c.html#a2fcc5f34f85af43cce0eb78225fd2a11">floatformats_ieee_single</a>);
<a name="l01407"></a>01407 
<a name="l01408"></a>01408   <a class="code" href="gdbarch_8c.html#ab63f129c7af7d29dcea12aabd9048c1f">set_gdbarch_read_pc</a> (gdbarch, avr_read_pc);
<a name="l01409"></a>01409   <a class="code" href="gdbarch_8c.html#a3209bbcdaee096f4977ef11291f0be48">set_gdbarch_write_pc</a> (gdbarch, avr_write_pc);
<a name="l01410"></a>01410 
<a name="l01411"></a>01411   <a class="code" href="gdbarch_8c.html#ad8417c5d66cf04d0587f58f82de94c48">set_gdbarch_num_regs</a> (gdbarch, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a66c557cfface61bbcbf634853c30e94b">AVR_NUM_REGS</a>);
<a name="l01412"></a>01412 
<a name="l01413"></a>01413   <a class="code" href="gdbarch_8c.html#a81a92a88a67093d18e59fd5650fda352">set_gdbarch_sp_regnum</a> (gdbarch, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4ad429b7dd2405a2fa524c985584d29f18">AVR_SP_REGNUM</a>);
<a name="l01414"></a>01414   <a class="code" href="gdbarch_8c.html#a8852f70e2afc74953a57521ed08a3381">set_gdbarch_pc_regnum</a> (gdbarch, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4a710fcdc3ebf642dac1c9071077d5a253">AVR_PC_REGNUM</a>);
<a name="l01415"></a>01415 
<a name="l01416"></a>01416   <a class="code" href="gdbarch_8c.html#a378ba40a6275393e204873c5bba602ad">set_gdbarch_register_name</a> (gdbarch, avr_register_name);
<a name="l01417"></a>01417   <a class="code" href="gdbarch_8c.html#a21919f6adfae80ed36e69e89cdfea531">set_gdbarch_register_type</a> (gdbarch, avr_register_type);
<a name="l01418"></a>01418 
<a name="l01419"></a>01419   <a class="code" href="gdbarch_8c.html#aaf72e08f972ba348d5d28f6b6b8db638">set_gdbarch_num_pseudo_regs</a> (gdbarch, <a class="code" href="avr-tdep_8c.html#aaf8fd5f0e57d456151c951e0f3715fc4af83e4975d2d8fa50a0297faf0110c152">AVR_NUM_PSEUDO_REGS</a>);
<a name="l01420"></a>01420   <a class="code" href="gdbarch_8c.html#a99fd57c1a882cf61c413e64028937a1b">set_gdbarch_pseudo_register_read</a> (gdbarch, avr_pseudo_register_read);
<a name="l01421"></a>01421   <a class="code" href="gdbarch_8c.html#ae463eca1992acf69ff1bc28ed8ca3aea">set_gdbarch_pseudo_register_write</a> (gdbarch, avr_pseudo_register_write);
<a name="l01422"></a>01422 
<a name="l01423"></a>01423   <a class="code" href="gdbarch_8c.html#ad9b13a9323cac027c4b805953b4fff63">set_gdbarch_return_value</a> (gdbarch, avr_return_value);
<a name="l01424"></a>01424   <a class="code" href="gdbarch_8c.html#a0c9e9e391e44d476b74debefc407e9bb">set_gdbarch_print_insn</a> (gdbarch, print_insn_avr);
<a name="l01425"></a>01425 
<a name="l01426"></a>01426   <a class="code" href="gdbarch_8c.html#a853528dceff46211c1bb8c57b77dca31">set_gdbarch_push_dummy_call</a> (gdbarch, avr_push_dummy_call);
<a name="l01427"></a>01427 
<a name="l01428"></a>01428   <a class="code" href="gdbarch_8c.html#a43ca55f05fcf599681eb376bbc6c8ece">set_gdbarch_dwarf2_reg_to_regnum</a> (gdbarch, avr_dwarf_reg_to_regnum);
<a name="l01429"></a>01429 
<a name="l01430"></a>01430   <a class="code" href="gdbarch_8c.html#a6c82f1dbe30d9e90f292191a8990a083">set_gdbarch_address_to_pointer</a> (gdbarch, avr_address_to_pointer);
<a name="l01431"></a>01431   <a class="code" href="gdbarch_8c.html#a32663d81b453b7b64760943b2e34900f">set_gdbarch_pointer_to_address</a> (gdbarch, avr_pointer_to_address);
<a name="l01432"></a>01432   <a class="code" href="gdbarch_8c.html#adf7a3ade5decd91ce5049182253c69d7">set_gdbarch_integer_to_address</a> (gdbarch, avr_integer_to_address);
<a name="l01433"></a>01433 
<a name="l01434"></a>01434   <a class="code" href="gdbarch_8c.html#a841509ae0070f2f12aa9b3b7fd52b92f">set_gdbarch_skip_prologue</a> (gdbarch, avr_skip_prologue);
<a name="l01435"></a>01435   <a class="code" href="gdbarch_8c.html#ad66381ed135b13aa5635f0485211ca71">set_gdbarch_inner_than</a> (gdbarch, <a class="code" href="arch-utils_8c.html#aaceae1c07203f3091df647f813b9f20e">core_addr_lessthan</a>);
<a name="l01436"></a>01436 
<a name="l01437"></a>01437   <a class="code" href="gdbarch_8c.html#ad738cdf37fa27f4cf3642107cadf61d3">set_gdbarch_breakpoint_from_pc</a> (gdbarch, avr_breakpoint_from_pc);
<a name="l01438"></a>01438 
<a name="l01439"></a>01439   <a class="code" href="frame-unwind_8c.html#afa4de8a130514bfd524d46f32e35a534">frame_unwind_append_unwinder</a> (gdbarch, &amp;avr_frame_unwind);
<a name="l01440"></a>01440   <a class="code" href="frame-base_8c.html#afc9e209b41e14278fb1ab72c1d3c6e5d">frame_base_set_default</a> (gdbarch, &amp;avr_frame_base);
<a name="l01441"></a>01441 
<a name="l01442"></a>01442   <a class="code" href="gdbarch_8c.html#a23da982924f904d22d0b58639a48bccf">set_gdbarch_dummy_id</a> (gdbarch, avr_dummy_id);
<a name="l01443"></a>01443 
<a name="l01444"></a>01444   <a class="code" href="gdbarch_8c.html#a1974f5f26c09a4cd32165286c3769621">set_gdbarch_unwind_pc</a> (gdbarch, avr_unwind_pc);
<a name="l01445"></a>01445   <a class="code" href="gdbarch_8c.html#ababd871cc4b5fac1831e52f7331d7572">set_gdbarch_unwind_sp</a> (gdbarch, avr_unwind_sp);
<a name="l01446"></a>01446 
<a name="l01447"></a>01447   <span class="keywordflow">return</span> <a class="code" href="structgdbarch__list.html#a6c51da8c4c95249704dfe18394fd08f9">gdbarch</a>;
<a name="l01448"></a>01448 }
<a name="l01449"></a>01449 
<a name="l01450"></a>01450 <span class="comment">/* Send a query request to the avr remote target asking for values of the io</span>
<a name="l01451"></a>01451 <span class="comment">   registers.  If args parameter is not NULL, then the user has requested info</span>
<a name="l01452"></a>01452 <span class="comment">   on a specific io register [This still needs implemented and is ignored for</span>
<a name="l01453"></a>01453 <span class="comment">   now].  The query string should be one of these forms:</span>
<a name="l01454"></a>01454 <span class="comment"></span>
<a name="l01455"></a>01455 <span class="comment">   &quot;Ravr.io_reg&quot; -&gt; reply is &quot;NN&quot; number of io registers</span>
<a name="l01456"></a>01456 <span class="comment"></span>
<a name="l01457"></a>01457 <span class="comment">   &quot;Ravr.io_reg:addr,len&quot; where addr is first register and len is number of</span>
<a name="l01458"></a>01458 <span class="comment">   registers to be read.  The reply should be &quot;&lt;NAME&gt;,VV;&quot; for each io register</span>
<a name="l01459"></a>01459 <span class="comment">   where, &lt;NAME&gt; is a string, and VV is the hex value of the register.</span>
<a name="l01460"></a>01460 <span class="comment"></span>
<a name="l01461"></a>01461 <span class="comment">   All io registers are 8-bit.  */</span>
<a name="l01462"></a>01462 
<a name="l01463"></a>01463 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01464"></a>01464 avr_io_reg_read_command (<span class="keywordtype">char</span> *args, <span class="keywordtype">int</span> from_tty)
<a name="l01465"></a>01465 {
<a name="l01466"></a>01466   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> bufsiz = 0;
<a name="l01467"></a>01467   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf;
<a name="l01468"></a>01468   <span class="keyword">const</span> <span class="keywordtype">char</span> *bufstr;
<a name="l01469"></a>01469   <span class="keywordtype">char</span> <a class="code" href="utils_8c.html#a4b369431cd1ce5d26bccf6b79a44c085">query</a>[400];
<a name="l01470"></a>01470   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>;
<a name="l01471"></a>01471   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nreg = 0;
<a name="l01472"></a>01472   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> val;
<a name="l01473"></a>01473   <span class="keywordtype">int</span> i, j, k, step;
<a name="l01474"></a>01474 
<a name="l01475"></a>01475   <span class="comment">/* Find out how many io registers the target has.  */</span>
<a name="l01476"></a>01476   bufsiz = <a class="code" href="target_8c.html#a3fa3cddea970cd3b7fb5a5ecfb62eeac">target_read_alloc</a> (&amp;current_target, <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a074051087c9979ebe807137f66a84445">TARGET_OBJECT_AVR</a>,
<a name="l01477"></a>01477                               <span class="stringliteral">&quot;avr.io_reg&quot;</span>, &amp;buf);
<a name="l01478"></a>01478   bufstr = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) buf;
<a name="l01479"></a>01479 
<a name="l01480"></a>01480   <span class="keywordflow">if</span> (bufsiz &lt;= 0)
<a name="l01481"></a>01481     {
<a name="l01482"></a>01482       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>,
<a name="l01483"></a>01483                           <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;ERR: info io_registers NOT supported &quot;</span>
<a name="l01484"></a>01484                             <span class="stringliteral">&quot;by current target\n&quot;</span>));
<a name="l01485"></a>01485       <span class="keywordflow">return</span>;
<a name="l01486"></a>01486     }
<a name="l01487"></a>01487 
<a name="l01488"></a>01488   <span class="keywordflow">if</span> (sscanf (bufstr, <span class="stringliteral">&quot;%x&quot;</span>, &amp;nreg) != 1)
<a name="l01489"></a>01489     {
<a name="l01490"></a>01490       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>,
<a name="l01491"></a>01491                           <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Error fetching number of io registers\n&quot;</span>));
<a name="l01492"></a>01492       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (buf);
<a name="l01493"></a>01493       <span class="keywordflow">return</span>;
<a name="l01494"></a>01494     }
<a name="l01495"></a>01495 
<a name="l01496"></a>01496   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (buf);
<a name="l01497"></a>01497 
<a name="l01498"></a>01498   <a class="code" href="utils_8c.html#a2f835956ba26653a2eb636e25cd9dfb9">reinitialize_more_filter</a> ();
<a name="l01499"></a>01499 
<a name="l01500"></a>01500   <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Target has %u io registers:\n\n&quot;</span>), nreg);
<a name="l01501"></a>01501 
<a name="l01502"></a>01502   <span class="comment">/* only fetch up to 8 registers at a time to keep the buffer small */</span>
<a name="l01503"></a>01503   step = 8;
<a name="l01504"></a>01504 
<a name="l01505"></a>01505   <span class="keywordflow">for</span> (i = 0; i &lt; nreg; i += step)
<a name="l01506"></a>01506     {
<a name="l01507"></a>01507       <span class="comment">/* how many registers this round? */</span>
<a name="l01508"></a>01508       j = step;
<a name="l01509"></a>01509       <span class="keywordflow">if</span> ((i+j) &gt;= nreg)
<a name="l01510"></a>01510         j = nreg - i;           <span class="comment">/* last block is less than 8 registers */</span>
<a name="l01511"></a>01511 
<a name="l01512"></a>01512       snprintf (query, <span class="keyword">sizeof</span> (query) - 1, <span class="stringliteral">&quot;avr.io_reg:%x,%x&quot;</span>, i, j);
<a name="l01513"></a>01513       bufsiz = <a class="code" href="target_8c.html#a3fa3cddea970cd3b7fb5a5ecfb62eeac">target_read_alloc</a> (&amp;current_target, <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a074051087c9979ebe807137f66a84445">TARGET_OBJECT_AVR</a>,
<a name="l01514"></a>01514                                   query, &amp;buf);
<a name="l01515"></a>01515 
<a name="l01516"></a>01516       p = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) buf;
<a name="l01517"></a>01517       <span class="keywordflow">for</span> (k = i; k &lt; (i + j); k++)
<a name="l01518"></a>01518         {
<a name="l01519"></a>01519           <span class="keywordflow">if</span> (sscanf (p, <span class="stringliteral">&quot;%[^,],%x;&quot;</span>, query, &amp;val) == 2)
<a name="l01520"></a>01520             {
<a name="l01521"></a>01521               <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<span class="stringliteral">&quot;[%02x] %-15s : %02x\n&quot;</span>, k, query, val);
<a name="l01522"></a>01522               <span class="keywordflow">while</span> ((*p != <span class="charliteral">&#39;;&#39;</span>) &amp;&amp; (*p != <span class="charliteral">&#39;\0&#39;</span>))
<a name="l01523"></a>01523                 p++;
<a name="l01524"></a>01524               p++;              <span class="comment">/* skip over &#39;;&#39; */</span>
<a name="l01525"></a>01525               <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l01526"></a>01526                 <span class="keywordflow">break</span>;
<a name="l01527"></a>01527             }
<a name="l01528"></a>01528         }
<a name="l01529"></a>01529 
<a name="l01530"></a>01530       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (buf);
<a name="l01531"></a>01531     }
<a name="l01532"></a>01532 }
<a name="l01533"></a>01533 
<a name="l01534"></a>01534 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#a686ed07d4fdcdc366f2bc677216ca08d">initialize_file_ftype</a> <a class="code" href="avr-tdep_8c.html#a9517c1ae2f6bf04970b6dabaf81f8130">_initialize_avr_tdep</a>; <span class="comment">/* -Wmissing-prototypes */</span>
<a name="l01535"></a>01535 
<a name="l01536"></a>01536 <span class="keywordtype">void</span>
<a name="l01537"></a><a class="code" href="avr-tdep_8c.html#a5518d79c0b767f8f6485d4cb9d30fdcd">01537</a> _initialize_avr_tdep (<span class="keywordtype">void</span>)
<a name="l01538"></a>01538 {
<a name="l01539"></a>01539   <a class="code" href="gdbarch_8c.html#adb96505b62850783929ff38de0c39062">register_gdbarch_init</a> (bfd_arch_avr, avr_gdbarch_init);
<a name="l01540"></a>01540 
<a name="l01541"></a>01541   <span class="comment">/* Add a new command to allow the user to query the avr remote target for</span>
<a name="l01542"></a>01542 <span class="comment">     the values of the io space registers in a saner way than just using</span>
<a name="l01543"></a>01543 <span class="comment">     `x/NNNb ADDR`.  */</span>
<a name="l01544"></a>01544 
<a name="l01545"></a>01545   <span class="comment">/* FIXME: TRoth/2002-02-18: This should probably be changed to &#39;info avr</span>
<a name="l01546"></a>01546 <span class="comment">     io_registers&#39; to signify it is not available on other platforms.  */</span>
<a name="l01547"></a>01547 
<a name="l01548"></a>01548   <a class="code" href="cli-decode_8c.html#ab87b0ba51ed9aa4c8aac0c96373537f8">add_cmd</a> (<span class="stringliteral">&quot;io_registers&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49afeb5c4e1710a4f7dfc804136248d274d">class_info</a>, avr_io_reg_read_command,
<a name="l01549"></a>01549            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;query remote avr target for io space register values&quot;</span>),
<a name="l01550"></a>01550            &amp;<a class="code" href="cli-cmds_8c.html#a2b65c04ff262047fd6fee65572dcfc43">infolist</a>);
<a name="l01551"></a>01551 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:12:10 for GDB (API) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
