<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (API): /home/stan/gdb/src/gdb/solib-spu.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (API)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/solib-spu.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="solib-spu_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Cell SPU GNU/Linux support -- shared library handling.</span>
<a name="l00002"></a>00002 <span class="comment">   Copyright (C) 2009-2013 Free Software Foundation, Inc.</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">   Contributed by Ulrich Weigand &lt;uweigand@de.ibm.com&gt;.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">   This file is part of GDB.</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00010"></a>00010 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00011"></a>00011 <span class="comment">   (at your option) any later version.</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00014"></a>00014 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00015"></a>00015 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00016"></a>00016 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00019"></a>00019 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="solib-spu_8h.html">solib-spu.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="gdbcore_8h.html">gdbcore.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="gdb__string_8h.html">gdb_string.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="gdb__assert_8h.html">gdb_assert.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="gdb__stat_8h.html">gdb_stat.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="arch-utils_8h.html">arch-utils.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;bfd.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="solib_8h.html">solib.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="solib-svr4_8h.html">solib-svr4.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="solist_8h.html">solist.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="inferior_8h.html">inferior.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="objfiles_8h.html">objfiles.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="observer_8h.html">observer.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="breakpoint_8h.html">breakpoint.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="gdbthread_8h.html">gdbthread.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="exceptions_8h.html">exceptions.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="gdb__bfd_8h.html">gdb_bfd.h</a>&quot;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="spu-tdep_8h.html">spu-tdep.h</a>&quot;</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="comment">/* Highest SPE id (file handle) the inferior may have.  */</span>
<a name="l00044"></a><a class="code" href="solib-spu_8c.html#aa83fff56d82b32923d6c7b4061613017">00044</a> <span class="preprocessor">#define MAX_SPE_FD 1024</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>
<a name="l00046"></a>00046 <span class="comment">/* Stand-alone SPE executable?  */</span>
<a name="l00047"></a><a class="code" href="solib-spu_8c.html#a27a8dcc43080d527eabafb6cbf668104">00047</a> <span class="preprocessor">#define spu_standalone_p() \</span>
<a name="l00048"></a>00048 <span class="preprocessor">  (symfile_objfile &amp;&amp; symfile_objfile-&gt;obfd \</span>
<a name="l00049"></a>00049 <span class="preprocessor">   &amp;&amp; bfd_get_arch (symfile_objfile-&gt;obfd) == bfd_arch_spu)</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">/* Relocate main SPE executable.  */</span>
<a name="l00053"></a>00053 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00054"></a>00054 spu_relocate_main_executable (<span class="keywordtype">int</span> spufs_fd)
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056   <span class="keyword">struct </span><a class="code" href="structsection__offsets.html">section_offsets</a> *new_offsets;
<a name="l00057"></a>00057   <span class="keywordtype">int</span> i;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059   <span class="keywordflow">if</span> (<a class="code" href="progspace_8h.html#a4e703bd0d59c70e069bed3b4d9e1936b">symfile_objfile</a> == NULL)
<a name="l00060"></a>00060     <span class="keywordflow">return</span>;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062   new_offsets = alloca (<a class="code" href="progspace_8h.html#a4e703bd0d59c70e069bed3b4d9e1936b">symfile_objfile</a>-&gt;num_sections
<a name="l00063"></a>00063                         * sizeof (<span class="keyword">struct</span> <a class="code" href="structsection__offsets.html">section_offsets</a>));
<a name="l00064"></a>00064 
<a name="l00065"></a>00065   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="progspace_8h.html#a4e703bd0d59c70e069bed3b4d9e1936b">symfile_objfile</a>-&gt;num_sections; i++)
<a name="l00066"></a>00066     new_offsets-&gt;<a class="code" href="structsection__offsets.html#a2fa3d08ad14bf2b0e56956936c233337">offsets</a>[i] = <a class="code" href="spu-tdep_8h.html#a9dd6343d7c2ebf90bf29d78289bdb110">SPUADDR</a> (spufs_fd, 0);
<a name="l00067"></a>00067 
<a name="l00068"></a>00068   <a class="code" href="objfiles_8c.html#a5b94685cf3f1097c15df6690ee4cf600">objfile_relocate</a> (<a class="code" href="progspace_8h.html#a4e703bd0d59c70e069bed3b4d9e1936b">symfile_objfile</a>, new_offsets);
<a name="l00069"></a>00069 }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="comment">/* When running a stand-alone SPE executable, we may need to skip one more</span>
<a name="l00072"></a>00072 <span class="comment">   exec event on startup, to get past the binfmt_misc loader.  */</span>
<a name="l00073"></a>00073 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00074"></a>00074 spu_skip_standalone_loader (<span class="keywordtype">void</span>)
<a name="l00075"></a>00075 {
<a name="l00076"></a>00076   <span class="keywordflow">if</span> (<a class="code" href="target_8h.html#a85885df22f7c1304269eaba1e1d618b7">target_has_execution</a> &amp;&amp; !<a class="code" href="inferior_8c.html#a9e592c83e7c0c1f89f1a4a392bd1a277">current_inferior</a> ()-&gt;attach_flag)
<a name="l00077"></a>00077     {
<a name="l00078"></a>00078       <span class="keyword">struct </span><a class="code" href="structtarget__waitstatus.html">target_waitstatus</a> ws;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080       <span class="comment">/* Only some kernels report an extra SIGTRAP with the binfmt_misc</span>
<a name="l00081"></a>00081 <span class="comment">         loader; others do not.  In addition, if we have attached to an</span>
<a name="l00082"></a>00082 <span class="comment">         already running inferior instead of starting a new one, we will</span>
<a name="l00083"></a>00083 <span class="comment">         not see the extra SIGTRAP -- and we cannot readily distinguish</span>
<a name="l00084"></a>00084 <span class="comment">         the two cases, in particular with the extended-remote target.</span>
<a name="l00085"></a>00085 <span class="comment"></span>
<a name="l00086"></a>00086 <span class="comment">         Thus we issue a single-step here.  If no extra SIGTRAP was pending,</span>
<a name="l00087"></a>00087 <span class="comment">         this will step past the first instruction of the stand-alone SPE</span>
<a name="l00088"></a>00088 <span class="comment">         executable loader, but we don&#39;t care about that.  */</span>
<a name="l00089"></a>00089 
<a name="l00090"></a>00090       <a class="code" href="gdbthread_8h.html#a668af1dd99cac24599dc0f3ef6458924">inferior_thread</a> ()-&gt;<a class="code" href="structthread__info.html#a223c3ebf1726773195c6e75c247ddd3c">control</a>.<a class="code" href="structthread__control__state.html#a340358c8f365b4f792bbfc16059a4e0a">in_infcall</a> = 1; <span class="comment">/* Suppress MI messages.  */</span>
<a name="l00091"></a>00091 
<a name="l00092"></a>00092       <a class="code" href="target_8c.html#a10cefb24ce83949fae9ba2756d0bf476">target_resume</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>, 1, GDB_SIGNAL_0);
<a name="l00093"></a>00093       <a class="code" href="target_8c.html#a0b3c864fc80f441532a0c3f9dad5eb3b">target_wait</a> (<a class="code" href="ptid_8c.html#ae865e32ccc6c9636dcec8ff779f99514">minus_one_ptid</a>, &amp;ws, 0);
<a name="l00094"></a>00094       <a class="code" href="gdbthread_8h.html#aad3b8d632ce5bff091990e407e7b4105">set_executing</a> (<a class="code" href="ptid_8c.html#ae865e32ccc6c9636dcec8ff779f99514">minus_one_ptid</a>, 0);
<a name="l00095"></a>00095 
<a name="l00096"></a>00096       <a class="code" href="gdbthread_8h.html#a668af1dd99cac24599dc0f3ef6458924">inferior_thread</a> ()-&gt;<a class="code" href="structthread__info.html#a223c3ebf1726773195c6e75c247ddd3c">control</a>.<a class="code" href="structthread__control__state.html#a340358c8f365b4f792bbfc16059a4e0a">in_infcall</a> = 0;
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098 }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>objfile_data *ocl_program_data_key;
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="comment">/* Appends OpenCL programs to the list of `struct so_list&#39; objects.  */</span>
<a name="l00103"></a>00103 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00104"></a>00104 append_ocl_sos (<span class="keyword">struct</span> <a class="code" href="structso__list.html">so_list</a> **link_ptr)
<a name="l00105"></a>00105 {
<a name="l00106"></a>00106   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *ocl_program_addr_base;
<a name="l00107"></a>00107   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109   <a class="code" href="objfiles_8h.html#a8efee3b85a322006131a6056d45058b3">ALL_OBJFILES</a> (objfile)
<a name="l00110"></a>00110     {
<a name="l00111"></a>00111       ocl_program_addr_base = objfile_data (objfile, ocl_program_data_key);
<a name="l00112"></a>00112       <span class="keywordflow">if</span> (ocl_program_addr_base != NULL)
<a name="l00113"></a>00113         {
<a name="l00114"></a>00114           <span class="keyword">enum</span> bfd_endian byte_order = bfd_big_endian (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>)?
<a name="l00115"></a>00115                                          BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;
<a name="l00116"></a>00116           <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> ex;
<a name="l00117"></a>00117           <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (ex, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6ab50fde886a7de8c013bf2bd4e7c073a4">RETURN_MASK_ALL</a>)
<a name="l00118"></a>00118             {
<a name="l00119"></a>00119               <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> data =
<a name="l00120"></a>00120                 <a class="code" href="corefile_8c.html#a280cf81e766f60b30618ae3011f2cb07">read_memory_unsigned_integer</a> (*ocl_program_addr_base,
<a name="l00121"></a>00121                                               <span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>),
<a name="l00122"></a>00122                                               byte_order);
<a name="l00123"></a>00123               <span class="keywordflow">if</span> (data != 0x0)
<a name="l00124"></a>00124                 {
<a name="l00125"></a>00125                   <span class="keyword">struct </span><a class="code" href="structso__list.html">so_list</a> *<span class="keyword">new</span>;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127                   <span class="comment">/* Allocate so_list structure.  */</span>
<a name="l00128"></a>00128                   <span class="keyword">new</span> = <a class="code" href="defs_8h.html#ab004b072c2eba9eb35ffb7b86a72b8c0">XZALLOC</a> (<span class="keyword">struct</span> <a class="code" href="structso__list.html">so_list</a>);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130                   <span class="comment">/* Encode FD and object ID in path name.  */</span>
<a name="l00131"></a>00131                   <a class="code" href="common-utils_8c.html#ad9940337ec98983dae9951c947879fc8">xsnprintf</a> (new-&gt;so_name, <span class="keyword">sizeof</span> new-&gt;so_name, <span class="stringliteral">&quot;@%s &lt;%d&gt;&quot;</span>,
<a name="l00132"></a>00132                              <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (data),
<a name="l00133"></a>00133                              <a class="code" href="spu-tdep_8h.html#afafb4132b7fe5507e3c9ff629b54fcbb">SPUADDR_SPU</a> (*ocl_program_addr_base));
<a name="l00134"></a>00134                   strcpy (new-&gt;so_original_name, new-&gt;so_name);
<a name="l00135"></a>00135 
<a name="l00136"></a>00136                   *link_ptr = <span class="keyword">new</span>;
<a name="l00137"></a>00137                   link_ptr = &amp;<span class="keyword">new</span>-&gt;<a class="code" href="structso__list.html#abd46cbdf1660c79a104e6af57af31df9">next</a>;
<a name="l00138"></a>00138                 }
<a name="l00139"></a>00139             }
<a name="l00140"></a>00140           <span class="keywordflow">if</span> (ex.reason &lt; 0)
<a name="l00141"></a>00141             {
<a name="l00142"></a>00142               <span class="comment">/* Ignore memory errors.  */</span>
<a name="l00143"></a>00143               <span class="keywordflow">switch</span> (ex.error)
<a name="l00144"></a>00144                 {
<a name="l00145"></a>00145                 <span class="keywordflow">case</span> <a class="code" href="exceptions_8h.html#acc42076253600be964e110149b458971a04b71fa0e894a082da3e23e99453a1ab">MEMORY_ERROR</a>:
<a name="l00146"></a>00146                   <span class="keywordflow">break</span>;
<a name="l00147"></a>00147                 <span class="keywordflow">default</span>:
<a name="l00148"></a>00148                   <a class="code" href="exceptions_8c.html#a541d1b545da68efe4f8b729a945f83e7">throw_exception</a> (ex);
<a name="l00149"></a>00149                   <span class="keywordflow">break</span>;
<a name="l00150"></a>00150                 }
<a name="l00151"></a>00151             }
<a name="l00152"></a>00152         }
<a name="l00153"></a>00153     }
<a name="l00154"></a>00154 }
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 <span class="comment">/* Build a list of `struct so_list&#39; objects describing the shared</span>
<a name="l00157"></a>00157 <span class="comment">   objects currently loaded in the inferior.  */</span>
<a name="l00158"></a>00158 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structso__list.html">so_list</a> *
<a name="l00159"></a>00159 spu_current_sos (<span class="keywordtype">void</span>)
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ());
<a name="l00162"></a>00162   <span class="keyword">struct </span><a class="code" href="structso__list.html">so_list</a> *head;
<a name="l00163"></a>00163   <span class="keyword">struct </span><a class="code" href="structso__list.html">so_list</a> **link_ptr;
<a name="l00164"></a>00164 
<a name="l00165"></a>00165   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> buf[<a class="code" href="solib-spu_8c.html#aa83fff56d82b32923d6c7b4061613017">MAX_SPE_FD</a> * 4];
<a name="l00166"></a>00166   <span class="keywordtype">int</span> i, <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l00167"></a>00167 
<a name="l00168"></a>00168   <span class="comment">/* First, retrieve the SVR4 shared library list.  */</span>
<a name="l00169"></a>00169   head = <a class="code" href="solib-svr4_8c.html#a774e40725f199c140776a60e8a9db959">svr4_so_ops</a>.<a class="code" href="structtarget__so__ops.html#a05f7d4465c729343bac0446a25a77b1d">current_sos</a> ();
<a name="l00170"></a>00170 
<a name="l00171"></a>00171   <span class="comment">/* Append our libraries to the end of the list.  */</span>
<a name="l00172"></a>00172   <span class="keywordflow">for</span> (link_ptr = &amp;head; *link_ptr; link_ptr = &amp;(*link_ptr)-&gt;<a class="code" href="structso__list.html#abd46cbdf1660c79a104e6af57af31df9">next</a>)
<a name="l00173"></a>00173     ;
<a name="l00174"></a>00174 
<a name="l00175"></a>00175   <span class="comment">/* Determine list of SPU ids.  */</span>
<a name="l00176"></a>00176   size = <a class="code" href="target_8c.html#aac7df8f3a1d061c97c45219ed0cace6c">target_read</a> (&amp;current_target, <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a09790d59558546bb5ab8aa15ae6fbc74">TARGET_OBJECT_SPU</a>, NULL,
<a name="l00177"></a>00177                       buf, 0, <span class="keyword">sizeof</span> buf);
<a name="l00178"></a>00178 
<a name="l00179"></a>00179   <span class="comment">/* Do not add stand-alone SPE executable context as shared library,</span>
<a name="l00180"></a>00180 <span class="comment">     but relocate main SPE executable objfile.  */</span>
<a name="l00181"></a>00181   <span class="keywordflow">if</span> (<a class="code" href="solib-spu_8c.html#a27a8dcc43080d527eabafb6cbf668104">spu_standalone_p</a> ())
<a name="l00182"></a>00182     {
<a name="l00183"></a>00183       <span class="keywordflow">if</span> (size == 4)
<a name="l00184"></a>00184         {
<a name="l00185"></a>00185           <span class="keywordtype">int</span> fd = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf, 4, byte_order);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187           spu_relocate_main_executable (fd);
<a name="l00188"></a>00188 
<a name="l00189"></a>00189           <span class="comment">/* Re-enable breakpoints after main SPU context was established;</span>
<a name="l00190"></a>00190 <span class="comment">             see also comments in spu_solib_create_inferior_hook.  */</span>
<a name="l00191"></a>00191           <a class="code" href="breakpoint_8c.html#a56e8c9fd394ef7b7c7bb3c800c9a13e6">enable_breakpoints_after_startup</a> ();
<a name="l00192"></a>00192         }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194       <span class="keywordflow">return</span> head;
<a name="l00195"></a>00195     }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   <span class="comment">/* Create an so_list entry for each SPU id.  */</span>
<a name="l00198"></a>00198   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>; i += 4)
<a name="l00199"></a>00199     {
<a name="l00200"></a>00200       <span class="keywordtype">int</span> fd = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf + i, 4, byte_order);
<a name="l00201"></a>00201       <span class="keyword">struct </span><a class="code" href="structso__list.html">so_list</a> *<span class="keyword">new</span>;
<a name="l00202"></a>00202 
<a name="l00203"></a>00203       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> addr;
<a name="l00204"></a>00204       <span class="keywordtype">char</span> annex[32], <span class="keywordtype">id</span>[100];
<a name="l00205"></a>00205       <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207       <span class="comment">/* Read object ID.  There&#39;s a race window where the inferior may have</span>
<a name="l00208"></a>00208 <span class="comment">         already created the SPE context, but not installed the object-id</span>
<a name="l00209"></a>00209 <span class="comment">         yet.  Skip such entries; we&#39;ll be back for them later.  */</span>
<a name="l00210"></a>00210       <a class="code" href="common-utils_8c.html#ad9940337ec98983dae9951c947879fc8">xsnprintf</a> (annex, <span class="keyword">sizeof</span> annex, <span class="stringliteral">&quot;%d/object-id&quot;</span>, fd);
<a name="l00211"></a>00211       len = <a class="code" href="target_8c.html#aac7df8f3a1d061c97c45219ed0cace6c">target_read</a> (&amp;current_target, <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a09790d59558546bb5ab8aa15ae6fbc74">TARGET_OBJECT_SPU</a>, annex,
<a name="l00212"></a>00212                          (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *) <span class="keywordtype">id</span>, 0, <span class="keyword">sizeof</span> <span class="keywordtype">id</span>);
<a name="l00213"></a>00213       <span class="keywordflow">if</span> (len &lt;= 0 || len &gt;= <span class="keyword">sizeof</span> <span class="keywordtype">id</span>)
<a name="l00214"></a>00214         <span class="keywordflow">continue</span>;
<a name="l00215"></a>00215       <span class="keywordtype">id</span>[<a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>] = 0;
<a name="l00216"></a>00216       <span class="keywordflow">if</span> (sscanf (<span class="keywordtype">id</span>, <span class="stringliteral">&quot;0x%llx&quot;</span>, &amp;addr) != 1 || !addr)
<a name="l00217"></a>00217         <span class="keywordflow">continue</span>;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219       <span class="comment">/* Allocate so_list structure.  */</span>
<a name="l00220"></a>00220       <span class="keyword">new</span> = <a class="code" href="defs_8h.html#ab004b072c2eba9eb35ffb7b86a72b8c0">XZALLOC</a> (<span class="keyword">struct</span> <a class="code" href="structso__list.html">so_list</a>);
<a name="l00221"></a>00221 
<a name="l00222"></a>00222       <span class="comment">/* Encode FD and object ID in path name.  Choose the name so as not</span>
<a name="l00223"></a>00223 <span class="comment">         to conflict with any (normal) SVR4 library path name.  */</span>
<a name="l00224"></a>00224       <a class="code" href="common-utils_8c.html#ad9940337ec98983dae9951c947879fc8">xsnprintf</a> (new-&gt;so_name, <span class="keyword">sizeof</span> new-&gt;so_name, <span class="stringliteral">&quot;@%s &lt;%d&gt;&quot;</span>,
<a name="l00225"></a>00225                  <a class="code" href="utils_8c.html#a4178635f8faef38f4f9af755a8b16edb">hex_string</a> (addr), fd);
<a name="l00226"></a>00226       strcpy (new-&gt;so_original_name, new-&gt;so_name);
<a name="l00227"></a>00227 
<a name="l00228"></a>00228       *link_ptr = <span class="keyword">new</span>;
<a name="l00229"></a>00229       link_ptr = &amp;<span class="keyword">new</span>-&gt;<a class="code" href="structso__list.html#abd46cbdf1660c79a104e6af57af31df9">next</a>;
<a name="l00230"></a>00230     }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232   <span class="comment">/* Append OpenCL sos.  */</span>
<a name="l00233"></a>00233   append_ocl_sos (link_ptr);
<a name="l00234"></a>00234 
<a name="l00235"></a>00235   <span class="keywordflow">return</span> head;
<a name="l00236"></a>00236 }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="comment">/* Free so_list information.  */</span>
<a name="l00239"></a>00239 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00240"></a>00240 spu_free_so (<span class="keyword">struct</span> <a class="code" href="structso__list.html">so_list</a> *so)
<a name="l00241"></a>00241 {
<a name="l00242"></a>00242   <span class="keywordflow">if</span> (so-&gt;<a class="code" href="structso__list.html#acaf1629339fc6d9e734dcc6b9ce02bbf">so_original_name</a>[0] != <span class="charliteral">&#39;@&#39;</span>)
<a name="l00243"></a>00243     <a class="code" href="solib-svr4_8c.html#a774e40725f199c140776a60e8a9db959">svr4_so_ops</a>.<a class="code" href="structtarget__so__ops.html#a7f1d1b450ebd9724199b09575f9b2841">free_so</a> (so);
<a name="l00244"></a>00244 }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246 <span class="comment">/* Relocate section addresses.  */</span>
<a name="l00247"></a>00247 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00248"></a>00248 spu_relocate_section_addresses (<span class="keyword">struct</span> <a class="code" href="structso__list.html">so_list</a> *so,
<a name="l00249"></a>00249                                 <span class="keyword">struct</span> <a class="code" href="structtarget__section.html">target_section</a> *sec)
<a name="l00250"></a>00250 {
<a name="l00251"></a>00251   <span class="keywordflow">if</span> (so-&gt;<a class="code" href="structso__list.html#acaf1629339fc6d9e734dcc6b9ce02bbf">so_original_name</a>[0] != <span class="charliteral">&#39;@&#39;</span>)
<a name="l00252"></a>00252     <a class="code" href="solib-svr4_8c.html#a774e40725f199c140776a60e8a9db959">svr4_so_ops</a>.<a class="code" href="structtarget__so__ops.html#a2ecaeca7f25e93824463cbf97f288fd8">relocate_section_addresses</a> (so, sec);
<a name="l00253"></a>00253   <span class="keywordflow">else</span>
<a name="l00254"></a>00254     {
<a name="l00255"></a>00255       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> addr;
<a name="l00256"></a>00256       <span class="keywordtype">int</span> fd;
<a name="l00257"></a>00257 
<a name="l00258"></a>00258       <span class="comment">/* Set addr_low/high to just LS offset for display.  */</span>
<a name="l00259"></a>00259       <span class="keywordflow">if</span> (so-&gt;<a class="code" href="structso__list.html#afb4c2609ac1d34a1f0501ed51f4ce262">addr_low</a> == 0 &amp;&amp; so-&gt;<a class="code" href="structso__list.html#a368c10a6a2b60168d577b19cb9444958">addr_high</a> == 0
<a name="l00260"></a>00260           &amp;&amp; strcmp (sec-&gt;<a class="code" href="structtarget__section.html#a3eeadf384747cb6a6e8cbb07db089723">the_bfd_section</a>-&gt;name, <span class="stringliteral">&quot;.text&quot;</span>) == 0)
<a name="l00261"></a>00261         {
<a name="l00262"></a>00262           so-&gt;<a class="code" href="structso__list.html#afb4c2609ac1d34a1f0501ed51f4ce262">addr_low</a> = sec-&gt;<a class="code" href="structtarget__section.html#a3e4564d6ceb39f962f70bb7afdd3b260">addr</a>;
<a name="l00263"></a>00263           so-&gt;<a class="code" href="structso__list.html#a368c10a6a2b60168d577b19cb9444958">addr_high</a> = sec-&gt;<a class="code" href="structtarget__section.html#a2c1890ede65bfce986a3e16682e76072">endaddr</a>;
<a name="l00264"></a>00264         }
<a name="l00265"></a>00265 
<a name="l00266"></a>00266       <span class="comment">/* Decode object ID.  */</span>
<a name="l00267"></a>00267       <span class="keywordflow">if</span> (sscanf (so-&gt;<a class="code" href="structso__list.html#acaf1629339fc6d9e734dcc6b9ce02bbf">so_original_name</a>, <span class="stringliteral">&quot;@0x%llx &lt;%d&gt;&quot;</span>, &amp;addr, &amp;fd) != 2)
<a name="l00268"></a>00268         <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__, <span class="stringliteral">&quot;bad object ID&quot;</span>);
<a name="l00269"></a>00269 
<a name="l00270"></a>00270       sec-&gt;<a class="code" href="structtarget__section.html#a3e4564d6ceb39f962f70bb7afdd3b260">addr</a> = <a class="code" href="spu-tdep_8h.html#a9dd6343d7c2ebf90bf29d78289bdb110">SPUADDR</a> (fd, sec-&gt;<a class="code" href="structtarget__section.html#a3e4564d6ceb39f962f70bb7afdd3b260">addr</a>);
<a name="l00271"></a>00271       sec-&gt;<a class="code" href="structtarget__section.html#a2c1890ede65bfce986a3e16682e76072">endaddr</a> = <a class="code" href="spu-tdep_8h.html#a9dd6343d7c2ebf90bf29d78289bdb110">SPUADDR</a> (fd, sec-&gt;<a class="code" href="structtarget__section.html#a2c1890ede65bfce986a3e16682e76072">endaddr</a>);
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273 }
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 <span class="comment">/* Inferior memory should contain an SPE executable image at location ADDR.</span>
<a name="l00277"></a>00277 <span class="comment">   Allocate a BFD representing that executable.  Return NULL on error.  */</span>
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="keyword">static</span> <span class="keywordtype">void</span> *
<a name="l00280"></a>00280 spu_bfd_iovec_open (bfd *nbfd, <span class="keywordtype">void</span> *open_closure)
<a name="l00281"></a>00281 {
<a name="l00282"></a>00282   <span class="keywordflow">return</span> open_closure;
<a name="l00283"></a>00283 }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00286"></a>00286 spu_bfd_iovec_close (bfd *nbfd, <span class="keywordtype">void</span> *stream)
<a name="l00287"></a>00287 {
<a name="l00288"></a>00288   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (stream);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290   <span class="comment">/* Zero means success.  */</span>
<a name="l00291"></a>00291   <span class="keywordflow">return</span> 0;
<a name="l00292"></a>00292 }
<a name="l00293"></a>00293 
<a name="l00294"></a>00294 <span class="keyword">static</span> file_ptr
<a name="l00295"></a>00295 spu_bfd_iovec_pread (bfd *<a class="code" href="structso__list.html#a085f5e5f0ed4f1517849da60cff8001d">abfd</a>, <span class="keywordtype">void</span> *stream, <span class="keywordtype">void</span> *buf,
<a name="l00296"></a>00296                      file_ptr nbytes, file_ptr <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>)
<a name="l00297"></a>00297 {
<a name="l00298"></a>00298   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr = *(<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *)stream;
<a name="l00299"></a>00299   <span class="keywordtype">int</span> ret;
<a name="l00300"></a>00300 
<a name="l00301"></a>00301   ret = <a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (addr + offset, buf, nbytes);
<a name="l00302"></a>00302   <span class="keywordflow">if</span> (ret != 0)
<a name="l00303"></a>00303     {
<a name="l00304"></a>00304       bfd_set_error (bfd_error_invalid_operation);
<a name="l00305"></a>00305       <span class="keywordflow">return</span> -1;
<a name="l00306"></a>00306     }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308   <span class="keywordflow">return</span> nbytes;
<a name="l00309"></a>00309 }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00312"></a>00312 spu_bfd_iovec_stat (bfd *abfd, <span class="keywordtype">void</span> *stream, <span class="keyword">struct</span> stat *sb)
<a name="l00313"></a>00313 {
<a name="l00314"></a>00314   <span class="comment">/* We don&#39;t have an easy way of finding the size of embedded spu</span>
<a name="l00315"></a>00315 <span class="comment">     images.  We could parse the in-memory ELF header and section</span>
<a name="l00316"></a>00316 <span class="comment">     table to find the extent of the last section but that seems</span>
<a name="l00317"></a>00317 <span class="comment">     pointless when the size is needed only for checks of other</span>
<a name="l00318"></a>00318 <span class="comment">     parsed values in dbxread.c.  */</span>
<a name="l00319"></a>00319   sb-&gt;st_size = INT_MAX;
<a name="l00320"></a>00320   <span class="keywordflow">return</span> 0;
<a name="l00321"></a>00321 }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="keyword">static</span> bfd *
<a name="l00324"></a>00324 spu_bfd_fopen (<span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr)
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326   bfd *nbfd;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *open_closure = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>));
<a name="l00329"></a>00329   *open_closure = addr;
<a name="l00330"></a>00330 
<a name="l00331"></a>00331   nbfd = <a class="code" href="gdb__bfd_8c.html#aaee4261acdce3aeb058fde5e2f32a70c">gdb_bfd_openr_iovec</a> (name, <span class="stringliteral">&quot;elf32-spu&quot;</span>,
<a name="l00332"></a>00332                               spu_bfd_iovec_open, open_closure,
<a name="l00333"></a>00333                               spu_bfd_iovec_pread, spu_bfd_iovec_close,
<a name="l00334"></a>00334                               spu_bfd_iovec_stat);
<a name="l00335"></a>00335   <span class="keywordflow">if</span> (!nbfd)
<a name="l00336"></a>00336     <span class="keywordflow">return</span> NULL;
<a name="l00337"></a>00337 
<a name="l00338"></a>00338   <span class="keywordflow">if</span> (!bfd_check_format (nbfd, bfd_object))
<a name="l00339"></a>00339     {
<a name="l00340"></a>00340       <a class="code" href="gdb__bfd_8c.html#a1027b59a8494f937b5760901040dc125">gdb_bfd_unref</a> (nbfd);
<a name="l00341"></a>00341       <span class="keywordflow">return</span> NULL;
<a name="l00342"></a>00342     }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344   <span class="keywordflow">return</span> nbfd;
<a name="l00345"></a>00345 }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <span class="comment">/* Open shared library BFD.  */</span>
<a name="l00348"></a>00348 <span class="keyword">static</span> bfd *
<a name="l00349"></a>00349 spu_bfd_open (<span class="keywordtype">char</span> *pathname)
<a name="l00350"></a>00350 {
<a name="l00351"></a>00351   <span class="keywordtype">char</span> *original_name = <a class="code" href="gdb__string_8h.html#a5cbb8bbfc7174d9468b1853f1031efb3">strrchr</a> (pathname, <span class="charliteral">&#39;@&#39;</span>);
<a name="l00352"></a>00352   bfd *<a class="code" href="structso__list.html#a085f5e5f0ed4f1517849da60cff8001d">abfd</a>;
<a name="l00353"></a>00353   asection *spu_name;
<a name="l00354"></a>00354   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> addr;
<a name="l00355"></a>00355   <span class="keywordtype">int</span> fd;
<a name="l00356"></a>00356 
<a name="l00357"></a>00357   <span class="comment">/* Handle regular SVR4 libraries.  */</span>
<a name="l00358"></a>00358   <span class="keywordflow">if</span> (!original_name)
<a name="l00359"></a>00359     <span class="keywordflow">return</span> <a class="code" href="solib-svr4_8c.html#a774e40725f199c140776a60e8a9db959">svr4_so_ops</a>.<a class="code" href="structtarget__so__ops.html#a1a430ce429c2c8efbe6f87bea6bf6cf6">bfd_open</a> (pathname);
<a name="l00360"></a>00360 
<a name="l00361"></a>00361   <span class="comment">/* Decode object ID.  */</span>
<a name="l00362"></a>00362   <span class="keywordflow">if</span> (sscanf (original_name, <span class="stringliteral">&quot;@0x%llx &lt;%d&gt;&quot;</span>, &amp;addr, &amp;fd) != 2)
<a name="l00363"></a>00363     <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__, <span class="stringliteral">&quot;bad object ID&quot;</span>);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365   <span class="comment">/* Open BFD representing SPE executable.  */</span>
<a name="l00366"></a>00366   abfd = spu_bfd_fopen (original_name, (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) addr);
<a name="l00367"></a>00367   <span class="keywordflow">if</span> (!abfd)
<a name="l00368"></a>00368     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot read SPE executable at %s&quot;</span>), original_name);
<a name="l00369"></a>00369 
<a name="l00370"></a>00370   <span class="comment">/* Retrieve SPU name note.  */</span>
<a name="l00371"></a>00371   spu_name = bfd_get_section_by_name (abfd, <span class="stringliteral">&quot;.note.spu_name&quot;</span>);
<a name="l00372"></a>00372   <span class="keywordflow">if</span> (spu_name)
<a name="l00373"></a>00373     {
<a name="l00374"></a>00374       <span class="keywordtype">int</span> sect_size = bfd_section_size (abfd, spu_name);
<a name="l00375"></a>00375 
<a name="l00376"></a>00376       <span class="keywordflow">if</span> (sect_size &gt; 20)
<a name="l00377"></a>00377         {
<a name="l00378"></a>00378           <span class="keywordtype">char</span> *buf = alloca (sect_size - 20 + strlen (original_name) + 1);
<a name="l00379"></a>00379 
<a name="l00380"></a>00380           bfd_get_section_contents (abfd, spu_name, buf, 20, sect_size - 20);
<a name="l00381"></a>00381           buf[sect_size - 20] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00382"></a>00382 
<a name="l00383"></a>00383           strcat (buf, original_name);
<a name="l00384"></a>00384 
<a name="l00385"></a>00385           <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> ((<span class="keywordtype">char</span> *)abfd-&gt;filename);
<a name="l00386"></a>00386           abfd-&gt;filename = xstrdup (buf);
<a name="l00387"></a>00387         }
<a name="l00388"></a>00388     }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390   <span class="keywordflow">return</span> <a class="code" href="structso__list.html#a085f5e5f0ed4f1517849da60cff8001d">abfd</a>;
<a name="l00391"></a>00391 }
<a name="l00392"></a>00392 
<a name="l00393"></a>00393 <span class="comment">/* Lookup global symbol in a SPE executable.  */</span>
<a name="l00394"></a>00394 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *
<a name="l00395"></a>00395 spu_lookup_lib_symbol (<span class="keyword">const</span> <span class="keyword">struct</span> objfile *objfile,
<a name="l00396"></a>00396                        <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00397"></a>00397                        <span class="keyword">const</span> <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> domain)
<a name="l00398"></a>00398 {
<a name="l00399"></a>00399   <span class="keywordflow">if</span> (bfd_get_arch (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>) == bfd_arch_spu)
<a name="l00400"></a>00400     <span class="keywordflow">return</span> <a class="code" href="symtab_8c.html#a5aac7376fe53651f0601b19e32825abc">lookup_global_symbol_from_objfile</a> (objfile, name, domain);
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   <span class="keywordflow">if</span> (<a class="code" href="solib-svr4_8c.html#a774e40725f199c140776a60e8a9db959">svr4_so_ops</a>.<a class="code" href="structtarget__so__ops.html#a72d8dfaa55af85f4eb3d5ebcefb26864">lookup_lib_global_symbol</a> != NULL)
<a name="l00403"></a>00403     <span class="keywordflow">return</span> <a class="code" href="solib-svr4_8c.html#a774e40725f199c140776a60e8a9db959">svr4_so_ops</a>.<a class="code" href="structtarget__so__ops.html#a72d8dfaa55af85f4eb3d5ebcefb26864">lookup_lib_global_symbol</a> (objfile, name, domain);
<a name="l00404"></a>00404   <span class="keywordflow">return</span> NULL;
<a name="l00405"></a>00405 }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 <span class="comment">/* Enable shared library breakpoint.  */</span>
<a name="l00408"></a>00408 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00409"></a>00409 spu_enable_break (<span class="keyword">struct</span> objfile *objfile)
<a name="l00410"></a>00410 {
<a name="l00411"></a>00411   <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *spe_event_sym = NULL;
<a name="l00412"></a>00412 
<a name="l00413"></a>00413   <span class="comment">/* The libspe library will call __spe_context_update_event whenever any</span>
<a name="l00414"></a>00414 <span class="comment">     SPE context is allocated or destroyed.  */</span>
<a name="l00415"></a>00415   spe_event_sym = <a class="code" href="minsyms_8c.html#af87f7a894386515074ddd71365bc09b8">lookup_minimal_symbol</a> (<span class="stringliteral">&quot;__spe_context_update_event&quot;</span>,
<a name="l00416"></a>00416                                          NULL, objfile);
<a name="l00417"></a>00417 
<a name="l00418"></a>00418   <span class="comment">/* Place a solib_event breakpoint on the symbol.  */</span>
<a name="l00419"></a>00419   <span class="keywordflow">if</span> (spe_event_sym)
<a name="l00420"></a>00420     {
<a name="l00421"></a>00421       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr = <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (spe_event_sym);
<a name="l00422"></a>00422 
<a name="l00423"></a>00423       addr = <a class="code" href="gdbarch_8c.html#adc1ce8006630950c775890c6fe36faa1">gdbarch_convert_from_func_ptr_addr</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> (), addr,
<a name="l00424"></a>00424                                                  &amp;current_target);
<a name="l00425"></a>00425       <a class="code" href="breakpoint_8c.html#a77e5eba285ff0706303f27d268e9b997">create_solib_event_breakpoint</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> (), addr);
<a name="l00426"></a>00426       <span class="keywordflow">return</span> 1;
<a name="l00427"></a>00427     }
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="keywordflow">return</span> 0;
<a name="l00430"></a>00430 }
<a name="l00431"></a>00431 
<a name="l00432"></a>00432 <span class="comment">/* Enable shared library breakpoint for the</span>
<a name="l00433"></a>00433 <span class="comment">   OpenCL runtime running on the SPU.  */</span>
<a name="l00434"></a>00434 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00435"></a>00435 ocl_enable_break (<span class="keyword">struct</span> objfile *objfile)
<a name="l00436"></a>00436 {
<a name="l00437"></a>00437   <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *event_sym = NULL;
<a name="l00438"></a>00438   <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *addr_sym = NULL;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440   <span class="comment">/* The OpenCL runtime on the SPU will call __opencl_program_update_event</span>
<a name="l00441"></a>00441 <span class="comment">     whenever an OpenCL program is loaded.  */</span>
<a name="l00442"></a>00442   event_sym = <a class="code" href="minsyms_8c.html#af87f7a894386515074ddd71365bc09b8">lookup_minimal_symbol</a> (<span class="stringliteral">&quot;__opencl_program_update_event&quot;</span>, NULL,
<a name="l00443"></a>00443                                      objfile);
<a name="l00444"></a>00444   <span class="comment">/* The PPU address of the OpenCL program can be found</span>
<a name="l00445"></a>00445 <span class="comment">     at opencl_elf_image_address.  */</span>
<a name="l00446"></a>00446   addr_sym = <a class="code" href="minsyms_8c.html#af87f7a894386515074ddd71365bc09b8">lookup_minimal_symbol</a> (<span class="stringliteral">&quot;opencl_elf_image_address&quot;</span>, NULL, objfile);
<a name="l00447"></a>00447 
<a name="l00448"></a>00448   <span class="keywordflow">if</span> (event_sym &amp;&amp; addr_sym)
<a name="l00449"></a>00449     {
<a name="l00450"></a>00450       <span class="comment">/* Place a solib_event breakpoint on the symbol.  */</span>
<a name="l00451"></a>00451       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> event_addr = <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (event_sym);
<a name="l00452"></a>00452       <a class="code" href="breakpoint_8c.html#a77e5eba285ff0706303f27d268e9b997">create_solib_event_breakpoint</a> (<a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile), event_addr);
<a name="l00453"></a>00453 
<a name="l00454"></a>00454       <span class="comment">/* Store the address of the symbol that will point to OpenCL program</span>
<a name="l00455"></a>00455 <span class="comment">         using the per-objfile private data mechanism.  */</span>
<a name="l00456"></a>00456       <span class="keywordflow">if</span> (objfile_data (objfile, ocl_program_data_key) == NULL)
<a name="l00457"></a>00457         {
<a name="l00458"></a>00458           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *ocl_program_addr_base = <a class="code" href="gdb__obstack_8h.html#ade84d21769345a1fad382ba39d83eb90">OBSTACK_CALLOC</a> (
<a name="l00459"></a>00459                   &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l00460"></a>00460                   objfile-&gt;<a class="code" href="structobjfile.html#a14f54389e81e2ae3efa512a6fa3365ea">sections_end</a> - objfile-&gt;<a class="code" href="structobjfile.html#a728f934c27b3d13bb44fbba47edc37f7">sections</a>,
<a name="l00461"></a>00461                   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>);
<a name="l00462"></a>00462           *ocl_program_addr_base = <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (addr_sym);
<a name="l00463"></a>00463           set_objfile_data (objfile, ocl_program_data_key,
<a name="l00464"></a>00464                             ocl_program_addr_base);
<a name="l00465"></a>00465         }
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467 }
<a name="l00468"></a>00468 
<a name="l00469"></a>00469 <span class="comment">/* Create inferior hook.  */</span>
<a name="l00470"></a>00470 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00471"></a>00471 spu_solib_create_inferior_hook (<span class="keywordtype">int</span> from_tty)
<a name="l00472"></a>00472 {
<a name="l00473"></a>00473   <span class="comment">/* Handle SPE stand-alone executables.  */</span>
<a name="l00474"></a>00474   <span class="keywordflow">if</span> (<a class="code" href="solib-spu_8c.html#a27a8dcc43080d527eabafb6cbf668104">spu_standalone_p</a> ())
<a name="l00475"></a>00475     {
<a name="l00476"></a>00476       <span class="comment">/* After an SPE stand-alone executable was loaded, we&#39;ll receive</span>
<a name="l00477"></a>00477 <span class="comment">         an additional trap due to the binfmt_misc handler.  Make sure</span>
<a name="l00478"></a>00478 <span class="comment">         to skip that trap.  */</span>
<a name="l00479"></a>00479       spu_skip_standalone_loader ();
<a name="l00480"></a>00480 
<a name="l00481"></a>00481       <span class="comment">/* If the user established breakpoints before starting the inferior, GDB</span>
<a name="l00482"></a>00482 <span class="comment">         would attempt to insert those now.  This would fail because the SPU</span>
<a name="l00483"></a>00483 <span class="comment">         context has not yet been created and the SPU executable has not yet</span>
<a name="l00484"></a>00484 <span class="comment">         been loaded.  To prevent such failures, we disable all user-created</span>
<a name="l00485"></a>00485 <span class="comment">         breakpoints now; they will be re-enabled in spu_current_sos once the</span>
<a name="l00486"></a>00486 <span class="comment">         main SPU context has been detected.  */</span>
<a name="l00487"></a>00487       <a class="code" href="breakpoint_8c.html#a9cdbf98f4d3af10d31df95d5ddbe494d">disable_breakpoints_before_startup</a> ();
<a name="l00488"></a>00488 
<a name="l00489"></a>00489       <span class="comment">/* A special case arises when re-starting an executable, because at</span>
<a name="l00490"></a>00490 <span class="comment">         this point it still resides at the relocated address range that was</span>
<a name="l00491"></a>00491 <span class="comment">         determined during its last execution.  We need to undo the relocation</span>
<a name="l00492"></a>00492 <span class="comment">         so that that multi-architecture target recognizes the stand-alone</span>
<a name="l00493"></a>00493 <span class="comment">         initialization special case.  */</span>
<a name="l00494"></a>00494       spu_relocate_main_executable (-1);
<a name="l00495"></a>00495     }
<a name="l00496"></a>00496 
<a name="l00497"></a>00497   <span class="comment">/* Call SVR4 hook -- this will re-insert the SVR4 solib breakpoints.  */</span>
<a name="l00498"></a>00498   <a class="code" href="solib-svr4_8c.html#a774e40725f199c140776a60e8a9db959">svr4_so_ops</a>.<a class="code" href="structtarget__so__ops.html#add929a52c64b345eabcb62350b23c44f">solib_create_inferior_hook</a> (from_tty);
<a name="l00499"></a>00499 
<a name="l00500"></a>00500   <span class="comment">/* If the inferior is statically linked against libspe, we need to install</span>
<a name="l00501"></a>00501 <span class="comment">     our own solib breakpoint right now.  Otherwise, it will be installed by</span>
<a name="l00502"></a>00502 <span class="comment">     the solib_loaded observer below as soon as libspe is loaded.  */</span>
<a name="l00503"></a>00503   spu_enable_break (NULL);
<a name="l00504"></a>00504 }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 <span class="comment">/* Install SPE &quot;shared library&quot; handling.  This is called by -tdep code</span>
<a name="l00507"></a>00507 <span class="comment">   that wants to support SPU as a secondary architecture.  */</span>
<a name="l00508"></a>00508 <span class="keywordtype">void</span>
<a name="l00509"></a><a class="code" href="solib-spu_8h.html#a33994d154efa87713aa70f07cdb5b5b1">00509</a> <a class="code" href="solib-spu_8c.html#a33994d154efa87713aa70f07cdb5b5b1">set_spu_solib_ops</a> (<span class="keyword">struct</span> gdbarch *gdbarch)
<a name="l00510"></a>00510 {
<a name="l00511"></a>00511   <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtarget__so__ops.html">target_so_ops</a> spu_so_ops;
<a name="l00512"></a>00512 
<a name="l00513"></a>00513   <span class="comment">/* Initialize this lazily, to avoid an initialization order</span>
<a name="l00514"></a>00514 <span class="comment">     dependency on solib-svr4.c&#39;s _initialize routine.  */</span>
<a name="l00515"></a>00515   <span class="keywordflow">if</span> (spu_so_ops.<a class="code" href="structtarget__so__ops.html#a05f7d4465c729343bac0446a25a77b1d">current_sos</a> == NULL)
<a name="l00516"></a>00516     {
<a name="l00517"></a>00517       spu_so_ops = <a class="code" href="solib-svr4_8c.html#a774e40725f199c140776a60e8a9db959">svr4_so_ops</a>;
<a name="l00518"></a>00518       spu_so_ops.<a class="code" href="structtarget__so__ops.html#add929a52c64b345eabcb62350b23c44f">solib_create_inferior_hook</a> = spu_solib_create_inferior_hook;
<a name="l00519"></a>00519       spu_so_ops.<a class="code" href="structtarget__so__ops.html#a2ecaeca7f25e93824463cbf97f288fd8">relocate_section_addresses</a> = spu_relocate_section_addresses;
<a name="l00520"></a>00520       spu_so_ops.<a class="code" href="structtarget__so__ops.html#a7f1d1b450ebd9724199b09575f9b2841">free_so</a> = spu_free_so;
<a name="l00521"></a>00521       spu_so_ops.<a class="code" href="structtarget__so__ops.html#a05f7d4465c729343bac0446a25a77b1d">current_sos</a> = spu_current_sos;
<a name="l00522"></a>00522       spu_so_ops.<a class="code" href="structtarget__so__ops.html#a1a430ce429c2c8efbe6f87bea6bf6cf6">bfd_open</a> = spu_bfd_open;
<a name="l00523"></a>00523       spu_so_ops.<a class="code" href="structtarget__so__ops.html#a72d8dfaa55af85f4eb3d5ebcefb26864">lookup_lib_global_symbol</a> = spu_lookup_lib_symbol;
<a name="l00524"></a>00524     }
<a name="l00525"></a>00525 
<a name="l00526"></a>00526   <a class="code" href="solib_8c.html#a17e243f2c7b22e10ef981fb7defc8b52">set_solib_ops</a> (gdbarch, &amp;spu_so_ops);
<a name="l00527"></a>00527 }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 <span class="comment">/* Observer for the solib_loaded event.  Used to install our breakpoint</span>
<a name="l00530"></a>00530 <span class="comment">   if libspe is a shared library.  */</span>
<a name="l00531"></a>00531 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00532"></a>00532 spu_solib_loaded (<span class="keyword">struct</span> <a class="code" href="structso__list.html">so_list</a> *so)
<a name="l00533"></a>00533 {
<a name="l00534"></a>00534   <span class="keywordflow">if</span> (<a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (so-&gt;<a class="code" href="structso__list.html#acaf1629339fc6d9e734dcc6b9ce02bbf">so_original_name</a>, <span class="stringliteral">&quot;/libspe&quot;</span>) != NULL)
<a name="l00535"></a>00535     {
<a name="l00536"></a>00536       <a class="code" href="solib_8c.html#ab84a2ead489326d22cfac6d2752a177d">solib_read_symbols</a> (so, 0);
<a name="l00537"></a>00537       spu_enable_break (so-&gt;<a class="code" href="structso__list.html#ada33ba2c171b3b53b3414f616b680b8e">objfile</a>);
<a name="l00538"></a>00538     }
<a name="l00539"></a>00539   <span class="comment">/* In case the OpenCL runtime is loaded we install a breakpoint</span>
<a name="l00540"></a>00540 <span class="comment">     to get notified whenever an OpenCL program gets loaded.  */</span>
<a name="l00541"></a>00541   <span class="keywordflow">if</span> (<a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (so-&gt;<a class="code" href="structso__list.html#a140beac8c60259f8debd88cd693b8fb4">so_name</a>, <span class="stringliteral">&quot;CLRuntimeAccelCellSPU@&quot;</span>) != NULL)
<a name="l00542"></a>00542     {
<a name="l00543"></a>00543       <a class="code" href="solib_8c.html#ab84a2ead489326d22cfac6d2752a177d">solib_read_symbols</a> (so, 0);
<a name="l00544"></a>00544       ocl_enable_break (so-&gt;<a class="code" href="structso__list.html#ada33ba2c171b3b53b3414f616b680b8e">objfile</a>);
<a name="l00545"></a>00545     }
<a name="l00546"></a>00546 }
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 <span class="comment">/* -Wmissing-prototypes */</span>
<a name="l00549"></a>00549 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#a686ed07d4fdcdc366f2bc677216ca08d">initialize_file_ftype</a> <a class="code" href="solib-spu_8c.html#a36209fe7477947d5471646cee75211ce">_initialize_spu_solib</a>;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 <span class="keywordtype">void</span>
<a name="l00552"></a><a class="code" href="solib-spu_8c.html#a9049b7f08897b668c0d770d9be3792de">00552</a> _initialize_spu_solib (<span class="keywordtype">void</span>)
<a name="l00553"></a>00553 {
<a name="l00554"></a>00554   <a class="code" href="observer_8h.html#a904016e858720098d746deea3aaada6f">observer_attach_solib_loaded</a> (spu_solib_loaded);
<a name="l00555"></a>00555   ocl_program_data_key = register_objfile_data ();
<a name="l00556"></a>00556 }
<a name="l00557"></a>00557 
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:12:25 for GDB (API) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
