<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (API): /home/stan/gdb/src/gdb/prologue-value.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (API)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/prologue-value.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="prologue-value_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Interface to prologue value handling for GDB.</span>
<a name="l00002"></a>00002 <span class="comment">   Copyright (C) 2003-2013 Free Software Foundation, Inc.</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">   This file is part of GDB.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00008"></a>00008 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00009"></a>00009 <span class="comment">   (at your option) any later version.</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00012"></a>00012 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00013"></a>00013 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00014"></a>00014 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#ifndef PROLOGUE_VALUE_H</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#define PROLOGUE_VALUE_H</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span>
<a name="l00022"></a>00022 <span class="comment">/* When we analyze a prologue, we&#39;re really doing &#39;abstract</span>
<a name="l00023"></a>00023 <span class="comment">   interpretation&#39; or &#39;pseudo-evaluation&#39;: running the function&#39;s code</span>
<a name="l00024"></a>00024 <span class="comment">   in simulation, but using conservative approximations of the values</span>
<a name="l00025"></a>00025 <span class="comment">   it would have when it actually runs.  For example, if our function</span>
<a name="l00026"></a>00026 <span class="comment">   starts with the instruction:</span>
<a name="l00027"></a>00027 <span class="comment"></span>
<a name="l00028"></a>00028 <span class="comment">      addi r1, 42     # add 42 to r1</span>
<a name="l00029"></a>00029 <span class="comment"></span>
<a name="l00030"></a>00030 <span class="comment">   we don&#39;t know exactly what value will be in r1 after executing this</span>
<a name="l00031"></a>00031 <span class="comment">   instruction, but we do know it&#39;ll be 42 greater than its original</span>
<a name="l00032"></a>00032 <span class="comment">   value.</span>
<a name="l00033"></a>00033 <span class="comment"></span>
<a name="l00034"></a>00034 <span class="comment">   If we then see an instruction like:</span>
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 <span class="comment">      addi r1, 22     # add 22 to r1</span>
<a name="l00037"></a>00037 <span class="comment"></span>
<a name="l00038"></a>00038 <span class="comment">   we still don&#39;t know what r1&#39;s value is, but again, we can say it is</span>
<a name="l00039"></a>00039 <span class="comment">   now 64 greater than its original value.</span>
<a name="l00040"></a>00040 <span class="comment"></span>
<a name="l00041"></a>00041 <span class="comment">   If the next instruction were:</span>
<a name="l00042"></a>00042 <span class="comment"></span>
<a name="l00043"></a>00043 <span class="comment">      mov r2, r1      # set r2 to r1&#39;s value</span>
<a name="l00044"></a>00044 <span class="comment"></span>
<a name="l00045"></a>00045 <span class="comment">   then we can say that r2&#39;s value is now the original value of r1</span>
<a name="l00046"></a>00046 <span class="comment">   plus 64.</span>
<a name="l00047"></a>00047 <span class="comment"></span>
<a name="l00048"></a>00048 <span class="comment">   It&#39;s common for prologues to save registers on the stack, so we&#39;ll</span>
<a name="l00049"></a>00049 <span class="comment">   need to track the values of stack frame slots, as well as the</span>
<a name="l00050"></a>00050 <span class="comment">   registers.  So after an instruction like this:</span>
<a name="l00051"></a>00051 <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment">      mov (fp+4), r2</span>
<a name="l00053"></a>00053 <span class="comment"></span>
<a name="l00054"></a>00054 <span class="comment">   then we&#39;d know that the stack slot four bytes above the frame</span>
<a name="l00055"></a>00055 <span class="comment">   pointer holds the original value of r1 plus 64.</span>
<a name="l00056"></a>00056 <span class="comment"></span>
<a name="l00057"></a>00057 <span class="comment">   And so on.</span>
<a name="l00058"></a>00058 <span class="comment"></span>
<a name="l00059"></a>00059 <span class="comment">   Of course, this can only go so far before it gets unreasonable.  If</span>
<a name="l00060"></a>00060 <span class="comment">   we wanted to be able to say anything about the value of r1 after</span>
<a name="l00061"></a>00061 <span class="comment">   the instruction:</span>
<a name="l00062"></a>00062 <span class="comment"></span>
<a name="l00063"></a>00063 <span class="comment">      xor r1, r3      # exclusive-or r1 and r3, place result in r1</span>
<a name="l00064"></a>00064 <span class="comment"></span>
<a name="l00065"></a>00065 <span class="comment">   then things would get pretty complex.  But remember, we&#39;re just</span>
<a name="l00066"></a>00066 <span class="comment">   doing a conservative approximation; if exclusive-or instructions</span>
<a name="l00067"></a>00067 <span class="comment">   aren&#39;t relevant to prologues, we can just say r1&#39;s value is now</span>
<a name="l00068"></a>00068 <span class="comment">   &#39;unknown&#39;.  We can ignore things that are too complex, if that loss</span>
<a name="l00069"></a>00069 <span class="comment">   of information is acceptable for our application.</span>
<a name="l00070"></a>00070 <span class="comment"></span>
<a name="l00071"></a>00071 <span class="comment">   So when I say &quot;conservative approximation&quot; here, what I mean is an</span>
<a name="l00072"></a>00072 <span class="comment">   approximation that is either accurate, or marked &quot;unknown&quot;, but</span>
<a name="l00073"></a>00073 <span class="comment">   never inaccurate.</span>
<a name="l00074"></a>00074 <span class="comment"></span>
<a name="l00075"></a>00075 <span class="comment">   Once you&#39;ve reached the current PC, or an instruction that you</span>
<a name="l00076"></a>00076 <span class="comment">   don&#39;t know how to simulate, you stop.  Now you can examine the</span>
<a name="l00077"></a>00077 <span class="comment">   state of the registers and stack slots you&#39;ve kept track of.</span>
<a name="l00078"></a>00078 <span class="comment"></span>
<a name="l00079"></a>00079 <span class="comment">   - To see how large your stack frame is, just check the value of the</span>
<a name="l00080"></a>00080 <span class="comment">     stack pointer register; if it&#39;s the original value of the SP</span>
<a name="l00081"></a>00081 <span class="comment">     minus a constant, then that constant is the stack frame&#39;s size.</span>
<a name="l00082"></a>00082 <span class="comment">     If the SP&#39;s value has been marked as &#39;unknown&#39;, then that means</span>
<a name="l00083"></a>00083 <span class="comment">     the prologue has done something too complex for us to track, and</span>
<a name="l00084"></a>00084 <span class="comment">     we don&#39;t know the frame size.</span>
<a name="l00085"></a>00085 <span class="comment"></span>
<a name="l00086"></a>00086 <span class="comment">   - To see where we&#39;ve saved the previous frame&#39;s registers, we just</span>
<a name="l00087"></a>00087 <span class="comment">     search the values we&#39;ve tracked --- stack slots, usually, but</span>
<a name="l00088"></a>00088 <span class="comment">     registers, too, if you want --- for something equal to the</span>
<a name="l00089"></a>00089 <span class="comment">     register&#39;s original value.  If the ABI suggests a standard place</span>
<a name="l00090"></a>00090 <span class="comment">     to save a given register, then we can check there first, but</span>
<a name="l00091"></a>00091 <span class="comment">     really, anything that will get us back the original value will</span>
<a name="l00092"></a>00092 <span class="comment">     probably work.</span>
<a name="l00093"></a>00093 <span class="comment"></span>
<a name="l00094"></a>00094 <span class="comment">   Sure, this takes some work.  But prologue analyzers aren&#39;t</span>
<a name="l00095"></a>00095 <span class="comment">   quick-and-simple pattern patching to recognize a few fixed prologue</span>
<a name="l00096"></a>00096 <span class="comment">   forms any more; they&#39;re big, hairy functions.  Along with inferior</span>
<a name="l00097"></a>00097 <span class="comment">   function calls, prologue analysis accounts for a substantial</span>
<a name="l00098"></a>00098 <span class="comment">   portion of the time needed to stabilize a GDB port.  So I think</span>
<a name="l00099"></a>00099 <span class="comment">   it&#39;s worthwhile to look for an approach that will be easier to</span>
<a name="l00100"></a>00100 <span class="comment">   understand and maintain.  In the approach used here:</span>
<a name="l00101"></a>00101 <span class="comment"></span>
<a name="l00102"></a>00102 <span class="comment">   - It&#39;s easier to see that the analyzer is correct: you just see</span>
<a name="l00103"></a>00103 <span class="comment">     whether the analyzer properly (albiet conservatively) simulates</span>
<a name="l00104"></a>00104 <span class="comment">     the effect of each instruction.</span>
<a name="l00105"></a>00105 <span class="comment"></span>
<a name="l00106"></a>00106 <span class="comment">   - It&#39;s easier to extend the analyzer: you can add support for new</span>
<a name="l00107"></a>00107 <span class="comment">     instructions, and know that you haven&#39;t broken anything that</span>
<a name="l00108"></a>00108 <span class="comment">     wasn&#39;t already broken before.</span>
<a name="l00109"></a>00109 <span class="comment"></span>
<a name="l00110"></a>00110 <span class="comment">   - It&#39;s orthogonal: to gather new information, you don&#39;t need to</span>
<a name="l00111"></a>00111 <span class="comment">     complicate the code for each instruction.  As long as your domain</span>
<a name="l00112"></a>00112 <span class="comment">     of conservative values is already detailed enough to tell you</span>
<a name="l00113"></a>00113 <span class="comment">     what you need, then all the existing instruction simulations are</span>
<a name="l00114"></a>00114 <span class="comment">     already gathering the right data for you.</span>
<a name="l00115"></a>00115 <span class="comment"></span>
<a name="l00116"></a>00116 <span class="comment">   A &#39;struct prologue_value&#39; is a conservative approximation of the</span>
<a name="l00117"></a>00117 <span class="comment">   real value the register or stack slot will have.  */</span>
<a name="l00118"></a>00118 
<a name="l00119"></a><a class="code" href="structprologue__value.html">00119</a> <span class="keyword">struct </span><a class="code" href="structprologue__value.html">prologue_value</a> {
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   <span class="comment">/* What sort of value is this?  This determines the interpretation</span>
<a name="l00122"></a>00122 <span class="comment">     of subsequent fields.  */</span>
<a name="l00123"></a>00123   <span class="keyword">enum</span> {
<a name="l00124"></a>00124 
<a name="l00125"></a>00125     <span class="comment">/* We don&#39;t know anything about the value.  This is also used for</span>
<a name="l00126"></a>00126 <span class="comment">       values we could have kept track of, when doing so would have</span>
<a name="l00127"></a>00127 <span class="comment">       been too complex and we don&#39;t want to bother.  The bottom of</span>
<a name="l00128"></a>00128 <span class="comment">       our lattice.  */</span>
<a name="l00129"></a><a class="code" href="structprologue__value.html#a0e27b25ebe5787ddc230c1d2336c7836a107a04530f63c8dee5379f0fee31fdb1">00129</a>     <a class="code" href="structprologue__value.html#a0e27b25ebe5787ddc230c1d2336c7836a107a04530f63c8dee5379f0fee31fdb1">pvk_unknown</a>,
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="comment">/* A known constant.  K is its value.  */</span>
<a name="l00132"></a><a class="code" href="structprologue__value.html#a0e27b25ebe5787ddc230c1d2336c7836a54d5f49c595511a5838753c293a036f9">00132</a>     <a class="code" href="structprologue__value.html#a0e27b25ebe5787ddc230c1d2336c7836a54d5f49c595511a5838753c293a036f9">pvk_constant</a>,
<a name="l00133"></a>00133 
<a name="l00134"></a>00134     <span class="comment">/* The value that register REG originally had *UPON ENTRY TO THE</span>
<a name="l00135"></a>00135 <span class="comment">       FUNCTION*, plus K.  If K is zero, this means, obviously, just</span>
<a name="l00136"></a>00136 <span class="comment">       the value REG had upon entry to the function.  REG is a GDB</span>
<a name="l00137"></a>00137 <span class="comment">       register number.  Before we start interpreting, we initialize</span>
<a name="l00138"></a>00138 <span class="comment">       every register R to { pvk_register, R, 0 }.  */</span>
<a name="l00139"></a><a class="code" href="structprologue__value.html#a0e27b25ebe5787ddc230c1d2336c7836a8a8d034750d45c0badf4530c782ddf04">00139</a>     <a class="code" href="structprologue__value.html#a0e27b25ebe5787ddc230c1d2336c7836a8a8d034750d45c0badf4530c782ddf04">pvk_register</a>,
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   } <a class="code" href="structprologue__value.html#a6b52b744f67b02d26add61c3e6bf4e7f">kind</a>;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143   <span class="comment">/* The meanings of the following fields depend on &#39;kind&#39;; see the</span>
<a name="l00144"></a>00144 <span class="comment">     comments for the specific &#39;kind&#39; values.  */</span>
<a name="l00145"></a><a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">00145</a>   <span class="keywordtype">int</span> <a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a>;
<a name="l00146"></a><a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">00146</a>   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a>;
<a name="l00147"></a>00147 };
<a name="l00148"></a>00148 
<a name="l00149"></a><a class="code" href="prologue-value_8h.html#a47fb2baa4dcc16d75a19861a2aab59d7">00149</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structprologue__value.html">prologue_value</a> <a class="code" href="structprologue__value.html">pv_t</a>;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="comment">/* Return the unknown prologue value --- { pvk_unknown, ?, ? }.  */</span>
<a name="l00153"></a>00153 <a class="code" href="structprologue__value.html">pv_t</a> <a class="code" href="prologue-value_8c.html#a33fab5d191479bf6d3f68569c1f2a508">pv_unknown</a> (<span class="keywordtype">void</span>);
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 <span class="comment">/* Return the prologue value representing the constant K.  */</span>
<a name="l00156"></a>00156 <a class="code" href="structprologue__value.html">pv_t</a> <a class="code" href="prologue-value_8c.html#a1d35dc4423d652ac8f7cbdfb94df117b">pv_constant</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a>);
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="comment">/* Return the prologue value representing the original value of</span>
<a name="l00159"></a>00159 <span class="comment">   register REG, plus the constant K.  */</span>
<a name="l00160"></a>00160 <a class="code" href="structprologue__value.html">pv_t</a> <a class="code" href="prologue-value_8c.html#a34b5d4a01cdf3fdb23cc9b69a407acc2">pv_register</a> (<span class="keywordtype">int</span> <a class="code" href="structreg.html">reg</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a>);
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">/* Return conservative approximations of the results of the following</span>
<a name="l00164"></a>00164 <span class="comment">   operations.  */</span>
<a name="l00165"></a>00165 <a class="code" href="structprologue__value.html">pv_t</a> <a class="code" href="prologue-value_8c.html#a9bd6922d20b5d35a25036c73b6d572ce">pv_add</a> (<a class="code" href="structprologue__value.html">pv_t</a> a, <a class="code" href="structprologue__value.html">pv_t</a> b);               <span class="comment">/* a + b */</span>
<a name="l00166"></a>00166 <a class="code" href="structprologue__value.html">pv_t</a> <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (<a class="code" href="structprologue__value.html">pv_t</a> v, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a>); <span class="comment">/* a + k */</span>
<a name="l00167"></a>00167 <a class="code" href="structprologue__value.html">pv_t</a> <a class="code" href="prologue-value_8c.html#a00a4a7681b4fd1a74d5e6f32bab6b973">pv_subtract</a> (<a class="code" href="structprologue__value.html">pv_t</a> a, <a class="code" href="structprologue__value.html">pv_t</a> b);          <span class="comment">/* a - b */</span>
<a name="l00168"></a>00168 <a class="code" href="structprologue__value.html">pv_t</a> <a class="code" href="prologue-value_8c.html#ab8fdc3bbaed87676f2e1cc23612f8b21">pv_logical_and</a> (<a class="code" href="structprologue__value.html">pv_t</a> a, <a class="code" href="structprologue__value.html">pv_t</a> b);       <span class="comment">/* a &amp; b */</span>
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="comment">/* Return non-zero iff A and B are identical expressions.</span>
<a name="l00172"></a>00172 <span class="comment"></span>
<a name="l00173"></a>00173 <span class="comment">   This is not the same as asking if the two values are equal; the</span>
<a name="l00174"></a>00174 <span class="comment">   result of such a comparison would have to be a pv_boolean, and</span>
<a name="l00175"></a>00175 <span class="comment">   asking whether two &#39;unknown&#39; values were equal would give you</span>
<a name="l00176"></a>00176 <span class="comment">   pv_maybe.  Same for comparing, say, { pvk_register, R1, 0 } and {</span>
<a name="l00177"></a>00177 <span class="comment">   pvk_register, R2, 0}.</span>
<a name="l00178"></a>00178 <span class="comment"></span>
<a name="l00179"></a>00179 <span class="comment">   Instead, this function asks whether the two representations are the</span>
<a name="l00180"></a>00180 <span class="comment">   same.  */</span>
<a name="l00181"></a>00181 <span class="keywordtype">int</span> <a class="code" href="prologue-value_8c.html#a3c9e13a6dc53cd468eb98e73968f52c9">pv_is_identical</a> (<a class="code" href="structprologue__value.html">pv_t</a> a, <a class="code" href="structprologue__value.html">pv_t</a> b);
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="comment">/* Return non-zero if A is known to be a constant.  */</span>
<a name="l00185"></a>00185 <span class="keywordtype">int</span> <a class="code" href="prologue-value_8c.html#ae54ca4de092a4d35d4e583fb7fbd838c">pv_is_constant</a> (<a class="code" href="structprologue__value.html">pv_t</a> a);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="comment">/* Return non-zero if A is the original value of register number R</span>
<a name="l00188"></a>00188 <span class="comment">   plus some constant, zero otherwise.  */</span>
<a name="l00189"></a>00189 <span class="keywordtype">int</span> <a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (<a class="code" href="structprologue__value.html">pv_t</a> a, <span class="keywordtype">int</span> r);
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 <span class="comment">/* Return non-zero if A is the original value of register R plus the</span>
<a name="l00193"></a>00193 <span class="comment">   constant K.  */</span>
<a name="l00194"></a>00194 <span class="keywordtype">int</span> <a class="code" href="prologue-value_8c.html#a2a8f42226ec88b80bd295476a6648df6">pv_is_register_k</a> (<a class="code" href="structprologue__value.html">pv_t</a> a, <span class="keywordtype">int</span> r, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a>);
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 <span class="comment">/* A conservative boolean type, including &quot;maybe&quot;, when we can&#39;t</span>
<a name="l00197"></a>00197 <span class="comment">   figure out whether something is true or not.  */</span>
<a name="l00198"></a><a class="code" href="prologue-value_8h.html#adbeb1bbc9d02d65588adbcda125c3e1f">00198</a> <span class="keyword">enum</span> <a class="code" href="prologue-value_8h.html#adbeb1bbc9d02d65588adbcda125c3e1f">pv_boolean</a> {
<a name="l00199"></a><a class="code" href="prologue-value_8h.html#adbeb1bbc9d02d65588adbcda125c3e1faf2806f523617ab21e38328afd225bd2a">00199</a>   <a class="code" href="prologue-value_8h.html#adbeb1bbc9d02d65588adbcda125c3e1faf2806f523617ab21e38328afd225bd2a">pv_maybe</a>,
<a name="l00200"></a><a class="code" href="prologue-value_8h.html#adbeb1bbc9d02d65588adbcda125c3e1faaf4bf64bbe424d57448c9a255fc04ae0">00200</a>   <a class="code" href="prologue-value_8h.html#adbeb1bbc9d02d65588adbcda125c3e1faaf4bf64bbe424d57448c9a255fc04ae0">pv_definite_yes</a>,
<a name="l00201"></a><a class="code" href="prologue-value_8h.html#adbeb1bbc9d02d65588adbcda125c3e1fa6c34630da70d62303bafdc20a4874686">00201</a>   <a class="code" href="prologue-value_8h.html#adbeb1bbc9d02d65588adbcda125c3e1fa6c34630da70d62303bafdc20a4874686">pv_definite_no</a>,
<a name="l00202"></a>00202 };
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="comment">/* Decide whether a reference to SIZE bytes at ADDR refers exactly to</span>
<a name="l00206"></a>00206 <span class="comment">   an element of an array.  The array starts at ARRAY_ADDR, and has</span>
<a name="l00207"></a>00207 <span class="comment">   ARRAY_LEN values of ELT_SIZE bytes each.  If ADDR definitely does</span>
<a name="l00208"></a>00208 <span class="comment">   refer to an array element, set *I to the index of the referenced</span>
<a name="l00209"></a>00209 <span class="comment">   element in the array, and return pv_definite_yes.  If it definitely</span>
<a name="l00210"></a>00210 <span class="comment">   doesn&#39;t, return pv_definite_no.  If we can&#39;t tell, return pv_maybe.</span>
<a name="l00211"></a>00211 <span class="comment"></span>
<a name="l00212"></a>00212 <span class="comment">   If the reference does touch the array, but doesn&#39;t fall exactly on</span>
<a name="l00213"></a>00213 <span class="comment">   an element boundary, or doesn&#39;t refer to the whole element, return</span>
<a name="l00214"></a>00214 <span class="comment">   pv_maybe.  */</span>
<a name="l00215"></a>00215 <span class="keyword">enum</span> <a class="code" href="prologue-value_8h.html#adbeb1bbc9d02d65588adbcda125c3e1f">pv_boolean</a> <a class="code" href="prologue-value_8c.html#ad7f57f1c7f5189ee882ef38053bfcf93">pv_is_array_ref</a> (<a class="code" href="structprologue__value.html">pv_t</a> addr, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>,
<a name="l00216"></a>00216                                  <a class="code" href="structprologue__value.html">pv_t</a> array_addr, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> array_len,
<a name="l00217"></a>00217                                  <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> elt_size,
<a name="l00218"></a>00218                                  <span class="keywordtype">int</span> *i);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 <span class="comment">/* A &#39;struct pv_area&#39; keeps track of values stored in a particular</span>
<a name="l00222"></a>00222 <span class="comment">   region of memory.  */</span>
<a name="l00223"></a>00223 <span class="keyword">struct </span>pv_area;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="comment">/* Create a new area, tracking stores relative to the original value</span>
<a name="l00226"></a>00226 <span class="comment">   of BASE_REG.  If BASE_REG is SP, then this effectively records the</span>
<a name="l00227"></a>00227 <span class="comment">   contents of the stack frame: the original value of the SP is the</span>
<a name="l00228"></a>00228 <span class="comment">   frame&#39;s CFA, or some constant offset from it.</span>
<a name="l00229"></a>00229 <span class="comment"></span>
<a name="l00230"></a>00230 <span class="comment">   Stores to constant addresses, unknown addresses, or to addresses</span>
<a name="l00231"></a>00231 <span class="comment">   relative to registers other than BASE_REG will trash this area; see</span>
<a name="l00232"></a>00232 <span class="comment">   pv_area_store_would_trash.</span>
<a name="l00233"></a>00233 <span class="comment"></span>
<a name="l00234"></a>00234 <span class="comment">   To check whether a pointer refers to this area, only the low</span>
<a name="l00235"></a>00235 <span class="comment">   ADDR_BIT bits will be compared.  */</span>
<a name="l00236"></a>00236 <span class="keyword">struct </span>pv_area *<a class="code" href="prologue-value_8c.html#a962e98d46aef2ed10288f8ae28b713f0">make_pv_area</a> (<span class="keywordtype">int</span> base_reg, <span class="keywordtype">int</span> addr_bit);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="comment">/* Free AREA.  */</span>
<a name="l00239"></a>00239 <span class="keywordtype">void</span> <a class="code" href="prologue-value_8c.html#af64b24209426a8a0714a52f0bc03dd9d">free_pv_area</a> (<span class="keyword">struct</span> pv_area *area);
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 <span class="comment">/* Register a cleanup to free AREA.  */</span>
<a name="l00243"></a>00243 <span class="keyword">struct </span>cleanup *<a class="code" href="prologue-value_8c.html#aa46c9e6e63a97230bb9be62b15d2cb96">make_cleanup_free_pv_area</a> (<span class="keyword">struct</span> pv_area *area);
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 
<a name="l00246"></a>00246 <span class="comment">/* Store the SIZE-byte value VALUE at ADDR in AREA.</span>
<a name="l00247"></a>00247 <span class="comment"></span>
<a name="l00248"></a>00248 <span class="comment">   If ADDR is not relative to the same base register we used in</span>
<a name="l00249"></a>00249 <span class="comment">   creating AREA, then we can&#39;t tell which values here the stored</span>
<a name="l00250"></a>00250 <span class="comment">   value might overlap, and we&#39;ll have to mark everything as</span>
<a name="l00251"></a>00251 <span class="comment">   unknown.  */</span>
<a name="l00252"></a>00252 <span class="keywordtype">void</span> <a class="code" href="prologue-value_8c.html#af1c1f51f05db124191cd6bf1a4077f3f">pv_area_store</a> (<span class="keyword">struct</span> pv_area *area,
<a name="l00253"></a>00253                     <a class="code" href="structprologue__value.html">pv_t</a> addr,
<a name="l00254"></a>00254                     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>,
<a name="l00255"></a>00255                     <a class="code" href="structprologue__value.html">pv_t</a> value);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="comment">/* Return the SIZE-byte value at ADDR in AREA.  This may return</span>
<a name="l00258"></a>00258 <span class="comment">   pv_unknown ().  */</span>
<a name="l00259"></a>00259 <a class="code" href="structprologue__value.html">pv_t</a> <a class="code" href="prologue-value_8c.html#ab467d5c80e75828bd5889f4c2b16ca48">pv_area_fetch</a> (<span class="keyword">struct</span> pv_area *area, <a class="code" href="structprologue__value.html">pv_t</a> addr, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>);
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 <span class="comment">/* Return true if storing to address ADDR in AREA would force us to</span>
<a name="l00262"></a>00262 <span class="comment">   mark the contents of the entire area as unknown.  This could happen</span>
<a name="l00263"></a>00263 <span class="comment">   if, say, ADDR is unknown, since we could be storing anywhere.  Or,</span>
<a name="l00264"></a>00264 <span class="comment">   it could happen if ADDR is relative to a different register than</span>
<a name="l00265"></a>00265 <span class="comment">   the other stores base register, since we don&#39;t know the relative</span>
<a name="l00266"></a>00266 <span class="comment">   values of the two registers.</span>
<a name="l00267"></a>00267 <span class="comment"></span>
<a name="l00268"></a>00268 <span class="comment">   If you&#39;ve reached such a store, it may be better to simply stop the</span>
<a name="l00269"></a>00269 <span class="comment">   prologue analysis, and return the information you&#39;ve gathered,</span>
<a name="l00270"></a>00270 <span class="comment">   instead of losing all that information, most of which is probably</span>
<a name="l00271"></a>00271 <span class="comment">   okay.  */</span>
<a name="l00272"></a>00272 <span class="keywordtype">int</span> <a class="code" href="prologue-value_8c.html#af16f8e9cb043efd0a97c592f199d4aa7">pv_area_store_would_trash</a> (<span class="keyword">struct</span> pv_area *area, <a class="code" href="structprologue__value.html">pv_t</a> addr);
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="comment">/* Search AREA for the original value of REGISTER.  If we can&#39;t find</span>
<a name="l00276"></a>00276 <span class="comment">   it, return zero; if we can find it, return a non-zero value, and if</span>
<a name="l00277"></a>00277 <span class="comment">   OFFSET_P is non-zero, set *OFFSET_P to the register&#39;s offset within</span>
<a name="l00278"></a>00278 <span class="comment">   AREA.  GDBARCH is the architecture of which REGISTER is a member.</span>
<a name="l00279"></a>00279 <span class="comment"></span>
<a name="l00280"></a>00280 <span class="comment">   In the worst case, this takes time proportional to the number of</span>
<a name="l00281"></a>00281 <span class="comment">   items stored in AREA.  If you plan to gather a lot of information</span>
<a name="l00282"></a>00282 <span class="comment">   about registers saved in AREA, consider calling pv_area_scan</span>
<a name="l00283"></a>00283 <span class="comment">   instead, and collecting all your information in one pass.  */</span>
<a name="l00284"></a>00284 <span class="keywordtype">int</span> <a class="code" href="prologue-value_8c.html#af2ee40cc8963d3782b9a8f95dc0ca7d0">pv_area_find_reg</a> (<span class="keyword">struct</span> pv_area *area,
<a name="l00285"></a>00285                       <span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l00286"></a>00286                       <span class="keywordtype">int</span> <a class="code" href="structreg.html">reg</a>,
<a name="l00287"></a>00287                       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *offset_p);
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 
<a name="l00290"></a>00290 <span class="comment">/* For every part of AREA whose value we know, apply FUNC to CLOSURE,</span>
<a name="l00291"></a>00291 <span class="comment">   the value&#39;s address, its size, and the value itself.  */</span>
<a name="l00292"></a>00292 <span class="keywordtype">void</span> <a class="code" href="prologue-value_8c.html#a4401a7a0b5fb6495e7db332f34e89db4">pv_area_scan</a> (<span class="keyword">struct</span> pv_area *area,
<a name="l00293"></a>00293                    <span class="keywordtype">void</span> (*<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>) (<span class="keywordtype">void</span> *closure,
<a name="l00294"></a>00294                                  <a class="code" href="structprologue__value.html">pv_t</a> addr,
<a name="l00295"></a>00295                                  <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>,
<a name="l00296"></a>00296                                  <a class="code" href="structprologue__value.html">pv_t</a> value),
<a name="l00297"></a>00297                    <span class="keywordtype">void</span> *closure);
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 <span class="preprocessor">#endif </span><span class="comment">/* PROLOGUE_VALUE_H */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:12:22 for GDB (API) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
