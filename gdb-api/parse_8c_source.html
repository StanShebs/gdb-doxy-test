<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (API): /home/stan/gdb/src/gdb/parse.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (API)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/parse.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="parse_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Parse expressions for GDB.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 1986-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   Modified from expread.y by the Department of Computer Science at the</span>
<a name="l00006"></a>00006 <span class="comment">   State University of New York at Buffalo, 1991.</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">   This file is part of GDB.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00011"></a>00011 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00012"></a>00012 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00013"></a>00013 <span class="comment">   (at your option) any later version.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00016"></a>00016 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00017"></a>00017 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00018"></a>00018 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00021"></a>00021 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">/* Parse an expression from text in a string,</span>
<a name="l00024"></a>00024 <span class="comment">   and return the result as a struct expression pointer.</span>
<a name="l00025"></a>00025 <span class="comment">   That structure contains arithmetic operations in reverse polish,</span>
<a name="l00026"></a>00026 <span class="comment">   with constants represented by operations that are followed by special data.</span>
<a name="l00027"></a>00027 <span class="comment">   See expression.h for the details of the format.</span>
<a name="l00028"></a>00028 <span class="comment">   What is important here is that it can be built up sequentially</span>
<a name="l00029"></a>00029 <span class="comment">   during the process of parsing; the lower levels of the tree always</span>
<a name="l00030"></a>00030 <span class="comment">   come first in the result.  */</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="arch-utils_8h.html">arch-utils.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="gdb__string_8h.html">gdb_string.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="gdbtypes_8h.html">gdbtypes.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="frame_8h.html">frame.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="expression_8h.html">expression.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="value_8h.html">value.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="command_8h.html">command.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="language_8h.html">language.h</a>&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="f-lang_8h.html">f-lang.h</a>&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="parser-defs_8h.html">parser-defs.h</a>&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="gdbcmd_8h.html">gdbcmd.h</a>&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;<a class="code" href="symfile_8h.html">symfile.h</a>&quot;</span>            <span class="comment">/* for overlay functions */</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="inferior_8h.html">inferior.h</a>&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="doublest_8h.html">doublest.h</a>&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;<a class="code" href="gdb__assert_8h.html">gdb_assert.h</a>&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;<a class="code" href="block_8h.html">block.h</a>&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;<a class="code" href="source_8h.html">source.h</a>&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;<a class="code" href="objfiles_8h.html">objfiles.h</a>&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;<a class="code" href="exceptions_8h.html">exceptions.h</a>&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;<a class="code" href="user-regs_8h.html">user-regs.h</a>&quot;</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="comment">/* Standard set of definitions for printing, dumping, prefixifying,</span>
<a name="l00057"></a>00057 <span class="comment"> * and evaluating expressions.  */</span>
<a name="l00058"></a>00058 
<a name="l00059"></a><a class="code" href="parser-defs_8h.html#a8877cf075f1571de350c15a6adbfded1">00059</a> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structexp__descriptor.html">exp_descriptor</a> <a class="code" href="parse_8c.html#a8877cf075f1571de350c15a6adbfded1">exp_descriptor_standard</a> = 
<a name="l00060"></a>00060   {
<a name="l00061"></a>00061     <a class="code" href="expprint_8c.html#a461e4507de8fa316a5744d83f061e203">print_subexp_standard</a>,
<a name="l00062"></a>00062     <a class="code" href="parse_8c.html#a63b798abb9b9b89ab5f422b1d5c1d16f">operator_length_standard</a>,
<a name="l00063"></a>00063     <a class="code" href="parse_8c.html#a3c5d5d877d396d73ba4e16142a96a9ad">operator_check_standard</a>,
<a name="l00064"></a>00064     <a class="code" href="expprint_8c.html#aed49bccbec4ce41f27a5b7478fe97145">op_name_standard</a>,
<a name="l00065"></a>00065     <a class="code" href="expprint_8c.html#a41602f65fa035d559466175ce1e77cf2">dump_subexp_body_standard</a>,
<a name="l00066"></a>00066     <a class="code" href="eval_8c.html#aac37a75d90c006cb91019b11d6ebb6ef">evaluate_subexp_standard</a>
<a name="l00067"></a>00067   };
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">/* Global variables declared in parser-defs.h (and commented there).  */</span>
<a name="l00070"></a><a class="code" href="parser-defs_8h.html#a7c6040b4038ada3eebe2f1168c13b965">00070</a> <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *<a class="code" href="parse_8c.html#a7c6040b4038ada3eebe2f1168c13b965">expout</a>;
<a name="l00071"></a><a class="code" href="parser-defs_8h.html#a74d514629651e8432694ef0d387b0f58">00071</a> <span class="keywordtype">int</span> <a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a>;
<a name="l00072"></a><a class="code" href="parser-defs_8h.html#a979f38678d589f7c5f9c7ff140c16f7a">00072</a> <span class="keywordtype">int</span> <a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a>;
<a name="l00073"></a><a class="code" href="parser-defs_8h.html#a306adef9b3e7fceca5cbd6896ca49d59">00073</a> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *<a class="code" href="parse_8c.html#a306adef9b3e7fceca5cbd6896ca49d59">expression_context_block</a>;
<a name="l00074"></a><a class="code" href="parser-defs_8h.html#a811508c86cb88db3a7f9e1cabb9588c4">00074</a> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="parse_8c.html#a811508c86cb88db3a7f9e1cabb9588c4">expression_context_pc</a>;
<a name="l00075"></a><a class="code" href="parser-defs_8h.html#a6b2028f35010cd9648aa5d5e8f7d653d">00075</a> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *<a class="code" href="expression_8h.html#a6b2028f35010cd9648aa5d5e8f7d653d">innermost_block</a>;
<a name="l00076"></a><a class="code" href="parser-defs_8h.html#a48ba962fc1014028fb4c811f758ea282">00076</a> <span class="keywordtype">int</span> <a class="code" href="parse_8c.html#a48ba962fc1014028fb4c811f758ea282">arglist_len</a>;
<a name="l00077"></a>00077 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype__stack.html">type_stack</a> <a class="code" href="structtype__stack.html">type_stack</a>;
<a name="l00078"></a><a class="code" href="parser-defs_8h.html#af6623656a3ce409076adb197314172e2">00078</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="parse_8c.html#af6623656a3ce409076adb197314172e2">lexptr</a>;
<a name="l00079"></a><a class="code" href="parser-defs_8h.html#aff224611563d397a490b23bdb581c11b">00079</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="parse_8c.html#aff224611563d397a490b23bdb581c11b">prev_lexptr</a>;
<a name="l00080"></a><a class="code" href="parser-defs_8h.html#a931a02e52cc8d96b0e353f0659c6ef7b">00080</a> <span class="keywordtype">int</span> <a class="code" href="parse_8c.html#a931a02e52cc8d96b0e353f0659c6ef7b">paren_depth</a>;
<a name="l00081"></a><a class="code" href="parser-defs_8h.html#adae301d904eeea4bfe269ac71990d05e">00081</a> <span class="keywordtype">int</span> <a class="code" href="parse_8c.html#adae301d904eeea4bfe269ac71990d05e">comma_terminates</a>;
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="comment">/* True if parsing an expression to attempt completion.  */</span>
<a name="l00084"></a><a class="code" href="parse_8c.html#a7cdba29abd014ae348e7a95cb9fb5aff">00084</a> <span class="keywordtype">int</span> <a class="code" href="expression_8h.html#a7cdba29abd014ae348e7a95cb9fb5aff">parse_completion</a>;
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="comment">/* The index of the last struct expression directly before a &#39;.&#39; or</span>
<a name="l00087"></a>00087 <span class="comment">   &#39;-&gt;&#39;.  This is set when parsing and is only used when completing a</span>
<a name="l00088"></a>00088 <span class="comment">   field name.  It is -1 if no dereference operation was found.  */</span>
<a name="l00089"></a>00089 <span class="keyword">static</span> <span class="keywordtype">int</span> expout_last_struct = -1;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="comment">/* If we are completing a tagged type name, this will be nonzero.  */</span>
<a name="l00092"></a>00092 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> expout_tag_completion_type = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ac0ed09886a958d1a94646893440004a8">TYPE_CODE_UNDEF</a>;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="comment">/* The token for tagged type name completion.  */</span>
<a name="l00095"></a>00095 <span class="keyword">static</span> <span class="keywordtype">char</span> *expout_completion_name;
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> expressiondebug = 0;
<a name="l00099"></a>00099 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00100"></a>00100 show_expressiondebug (<span class="keyword">struct</span> ui_file *file, <span class="keywordtype">int</span> from_tty,
<a name="l00101"></a>00101                       <span class="keyword">struct</span> <a class="code" href="structcmd__list__element.html">cmd_list_element</a> *c, <span class="keyword">const</span> <span class="keywordtype">char</span> *value)
<a name="l00102"></a>00102 {
<a name="l00103"></a>00103   <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (file, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Expression debugging is %s.\n&quot;</span>), value);
<a name="l00104"></a>00104 }
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="comment">/* Non-zero if an expression parser should set yydebug.  */</span>
<a name="l00108"></a><a class="code" href="parser-defs_8h.html#a20ba618f37578ad21378433550516222">00108</a> <span class="keywordtype">int</span> <a class="code" href="parse_8c.html#a20ba618f37578ad21378433550516222">parser_debug</a>;
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00111"></a>00111 show_parserdebug (<span class="keyword">struct</span> ui_file *file, <span class="keywordtype">int</span> from_tty,
<a name="l00112"></a>00112                   <span class="keyword">struct</span> <a class="code" href="structcmd__list__element.html">cmd_list_element</a> *c, <span class="keyword">const</span> <span class="keywordtype">char</span> *value)
<a name="l00113"></a>00113 {
<a name="l00114"></a>00114   <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (file, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Parser debugging is %s.\n&quot;</span>), value);
<a name="l00115"></a>00115 }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 <span class="keyword">static</span> <span class="keywordtype">void</span> free_funcalls (<span class="keywordtype">void</span> *ignore);
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="keyword">static</span> <span class="keywordtype">int</span> prefixify_subexp (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *, <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *, <span class="keywordtype">int</span>,
<a name="l00121"></a>00121                              <span class="keywordtype">int</span>);
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *parse_exp_in_context (<span class="keyword">const</span> <span class="keywordtype">char</span> **, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>,
<a name="l00124"></a>00124                                                 <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *, <span class="keywordtype">int</span>, 
<a name="l00125"></a>00125                                                 <span class="keywordtype">int</span>, <span class="keywordtype">int</span> *);
<a name="l00126"></a>00126 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *parse_exp_in_context_1 (<span class="keyword">const</span> <span class="keywordtype">char</span> **, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>,
<a name="l00127"></a>00127                                                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *, <span class="keywordtype">int</span>,
<a name="l00128"></a>00128                                                   <span class="keywordtype">int</span>, <span class="keywordtype">int</span> *);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="keywordtype">void</span> <a class="code" href="init_8c.html#acf8a218d8b4b0cdb6759cf71c07243aa">_initialize_parse</a> (<span class="keywordtype">void</span>);
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 <span class="comment">/* Data structure for saving values of arglist_len for function calls whose</span>
<a name="l00133"></a>00133 <span class="comment">   arguments contain other function calls.  */</span>
<a name="l00134"></a>00134 
<a name="l00135"></a>00135 <span class="keyword">struct </span>funcall
<a name="l00136"></a>00136   {
<a name="l00137"></a>00137     <span class="keyword">struct </span>funcall *next;
<a name="l00138"></a>00138     <span class="keywordtype">int</span> <a class="code" href="parse_8c.html#a48ba962fc1014028fb4c811f758ea282">arglist_len</a>;
<a name="l00139"></a>00139   };
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="keyword">static</span> <span class="keyword">struct </span>funcall *funcall_chain;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="comment">/* Begin counting arguments for a function call,</span>
<a name="l00144"></a>00144 <span class="comment">   saving the data about any containing call.  */</span>
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="keywordtype">void</span>
<a name="l00147"></a><a class="code" href="parser-defs_8h.html#a83bcacd185dedf9df28e211808d4c81a">00147</a> <a class="code" href="parse_8c.html#a83bcacd185dedf9df28e211808d4c81a">start_arglist</a> (<span class="keywordtype">void</span>)
<a name="l00148"></a>00148 {
<a name="l00149"></a>00149   <span class="keyword">struct </span>funcall *<span class="keyword">new</span>;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151   <span class="keyword">new</span> = (<span class="keyword">struct </span>funcall *) <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> funcall));
<a name="l00152"></a>00152   <span class="keyword">new</span>-&gt;next = funcall_chain;
<a name="l00153"></a>00153   <span class="keyword">new</span>-&gt;arglist_len = <a class="code" href="parse_8c.html#a48ba962fc1014028fb4c811f758ea282">arglist_len</a>;
<a name="l00154"></a>00154   <a class="code" href="parse_8c.html#a48ba962fc1014028fb4c811f758ea282">arglist_len</a> = 0;
<a name="l00155"></a>00155   funcall_chain = <span class="keyword">new</span>;
<a name="l00156"></a>00156 }
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="comment">/* Return the number of arguments in a function call just terminated,</span>
<a name="l00159"></a>00159 <span class="comment">   and restore the data for the containing function call.  */</span>
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="keywordtype">int</span>
<a name="l00162"></a><a class="code" href="parser-defs_8h.html#a81771ed01f5cba90d3fea2e004cd0b50">00162</a> <a class="code" href="parse_8c.html#a81771ed01f5cba90d3fea2e004cd0b50">end_arglist</a> (<span class="keywordtype">void</span>)
<a name="l00163"></a>00163 {
<a name="l00164"></a>00164   <span class="keywordtype">int</span> val = <a class="code" href="parse_8c.html#a48ba962fc1014028fb4c811f758ea282">arglist_len</a>;
<a name="l00165"></a>00165   <span class="keyword">struct </span>funcall *call = funcall_chain;
<a name="l00166"></a>00166 
<a name="l00167"></a>00167   funcall_chain = call-&gt;next;
<a name="l00168"></a>00168   <a class="code" href="parse_8c.html#a48ba962fc1014028fb4c811f758ea282">arglist_len</a> = call-&gt;arglist_len;
<a name="l00169"></a>00169   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (call);
<a name="l00170"></a>00170   <span class="keywordflow">return</span> val;
<a name="l00171"></a>00171 }
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 <span class="comment">/* Free everything in the funcall chain.</span>
<a name="l00174"></a>00174 <span class="comment">   Used when there is an error inside parsing.  */</span>
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00177"></a>00177 free_funcalls (<span class="keywordtype">void</span> *ignore)
<a name="l00178"></a>00178 {
<a name="l00179"></a>00179   <span class="keyword">struct </span>funcall *call, *next;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181   <span class="keywordflow">for</span> (call = funcall_chain; call; call = next)
<a name="l00182"></a>00182     {
<a name="l00183"></a>00183       next = call-&gt;next;
<a name="l00184"></a>00184       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (call);
<a name="l00185"></a>00185     }
<a name="l00186"></a>00186 }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="comment">/* This page contains the functions for adding data to the struct expression</span>
<a name="l00189"></a>00189 <span class="comment">   being constructed.  */</span>
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 <span class="comment">/* See definition in parser-defs.h.  */</span>
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="keywordtype">void</span>
<a name="l00194"></a><a class="code" href="parser-defs_8h.html#a57995bd043904143dd791d2cab4638e6">00194</a> <a class="code" href="parse_8c.html#ab607e77af18b398c64054bbf723c59b1">initialize_expout</a> (<span class="keywordtype">int</span> initial_size, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structlanguage__defn.html">language_defn</a> *lang,
<a name="l00195"></a>00195                    <span class="keyword">struct</span> gdbarch *gdbarch)
<a name="l00196"></a>00196 {
<a name="l00197"></a>00197   <a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a> = initial_size;
<a name="l00198"></a>00198   <a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a> = 0;
<a name="l00199"></a>00199   expout = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a>)
<a name="l00200"></a>00200                     + <a class="code" href="expression_8h.html#a0c3bd719efe17f3c1df1fe790f4ffd0d">EXP_ELEM_TO_BYTES</a> (<a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a>));
<a name="l00201"></a>00201   expout-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a> = lang;
<a name="l00202"></a>00202   expout-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a> = gdbarch;
<a name="l00203"></a>00203 }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="comment">/* See definition in parser-defs.h.  */</span>
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 <span class="keywordtype">void</span>
<a name="l00208"></a><a class="code" href="parser-defs_8h.html#a9293197f4dcc544f9d707c0cce399bcf">00208</a> <a class="code" href="parse_8c.html#a9293197f4dcc544f9d707c0cce399bcf">reallocate_expout</a> (<span class="keywordtype">void</span>)
<a name="l00209"></a>00209 {
<a name="l00210"></a>00210   <span class="comment">/* Record the actual number of expression elements, and then</span>
<a name="l00211"></a>00211 <span class="comment">     reallocate the expression memory so that we free up any</span>
<a name="l00212"></a>00212 <span class="comment">     excess elements.  */</span>
<a name="l00213"></a>00213 
<a name="l00214"></a>00214   expout-&gt;<a class="code" href="structexpression.html#ad5e1dbc7e3732d94d29b8c3d61696123">nelts</a> = <a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a>;
<a name="l00215"></a>00215   expout = <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> ((<span class="keywordtype">char</span> *) expout,
<a name="l00216"></a>00216                      <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a>)
<a name="l00217"></a>00217                      + <a class="code" href="expression_8h.html#a0c3bd719efe17f3c1df1fe790f4ffd0d">EXP_ELEM_TO_BYTES</a> (<a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a>));
<a name="l00218"></a>00218 }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 <span class="comment">/* Add one element to the end of the expression.  */</span>
<a name="l00221"></a>00221 
<a name="l00222"></a>00222 <span class="comment">/* To avoid a bug in the Sun 4 compiler, we pass things that can fit into</span>
<a name="l00223"></a>00223 <span class="comment">   a register through here.  */</span>
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00226"></a>00226 write_exp_elt (<span class="keyword">const</span> <span class="keyword">union</span> <a class="code" href="unionexp__element.html">exp_element</a> *expelt)
<a name="l00227"></a>00227 {
<a name="l00228"></a>00228   <span class="keywordflow">if</span> (<a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a> &gt;= <a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a>)
<a name="l00229"></a>00229     {
<a name="l00230"></a>00230       <a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a> *= 2;
<a name="l00231"></a>00231       expout = (<span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *)
<a name="l00232"></a>00232         <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> ((<span class="keywordtype">char</span> *) <a class="code" href="parse_8c.html#a7c6040b4038ada3eebe2f1168c13b965">expout</a>, <span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a>)
<a name="l00233"></a>00233                   + <a class="code" href="expression_8h.html#a0c3bd719efe17f3c1df1fe790f4ffd0d">EXP_ELEM_TO_BYTES</a> (<a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a>));
<a name="l00234"></a>00234     }
<a name="l00235"></a>00235   expout-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[<a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a>++] = *expelt;
<a name="l00236"></a>00236 }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="keywordtype">void</span>
<a name="l00239"></a><a class="code" href="parser-defs_8h.html#a2002f0d881e7e9aee334e2f759528d16">00239</a> <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (<span class="keyword">enum</span> <a class="code" href="expression_8h.html#a13f8bfc7b2a183fe56716508bfddae41">exp_opcode</a> expelt)
<a name="l00240"></a>00240 {
<a name="l00241"></a>00241   <span class="keyword">union </span><a class="code" href="unionexp__element.html">exp_element</a> tmp;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;tmp, 0, <span class="keyword">sizeof</span> (<span class="keyword">union</span> <a class="code" href="unionexp__element.html">exp_element</a>));
<a name="l00244"></a>00244   tmp.<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a> = expelt;
<a name="l00245"></a>00245   write_exp_elt (&amp;tmp);
<a name="l00246"></a>00246 }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="keywordtype">void</span>
<a name="l00249"></a><a class="code" href="parser-defs_8h.html#a1621e7d28be035f45ba970cedb5adbb4">00249</a> <a class="code" href="parse_8c.html#a786c3106f7e316d7a240cf54fb6395cd">write_exp_elt_sym</a> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *expelt)
<a name="l00250"></a>00250 {
<a name="l00251"></a>00251   <span class="keyword">union </span><a class="code" href="unionexp__element.html">exp_element</a> tmp;
<a name="l00252"></a>00252 
<a name="l00253"></a>00253   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;tmp, 0, <span class="keyword">sizeof</span> (<span class="keyword">union</span> <a class="code" href="unionexp__element.html">exp_element</a>));
<a name="l00254"></a>00254   tmp.<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a> = expelt;
<a name="l00255"></a>00255   write_exp_elt (&amp;tmp);
<a name="l00256"></a>00256 }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 <span class="keywordtype">void</span>
<a name="l00259"></a><a class="code" href="parser-defs_8h.html#a923cf1b0e51eaa17d5999abe20c3ed39">00259</a> <a class="code" href="parse_8c.html#a29c5ee518bbab042a1d1f4ee7c7e7e57">write_exp_elt_block</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *b)
<a name="l00260"></a>00260 {
<a name="l00261"></a>00261   <span class="keyword">union </span><a class="code" href="unionexp__element.html">exp_element</a> tmp;
<a name="l00262"></a>00262 
<a name="l00263"></a>00263   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;tmp, 0, <span class="keyword">sizeof</span> (<span class="keyword">union</span> <a class="code" href="unionexp__element.html">exp_element</a>));
<a name="l00264"></a>00264   tmp.<a class="code" href="unionexp__element.html#a140894cc6f8f336a98a4ec9340c7859b">block</a> = b;
<a name="l00265"></a>00265   write_exp_elt (&amp;tmp);
<a name="l00266"></a>00266 }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 <span class="keywordtype">void</span>
<a name="l00269"></a><a class="code" href="parser-defs_8h.html#a8f15f40d7b112c5fa96de2bf82d2da51">00269</a> <a class="code" href="parse_8c.html#a8f15f40d7b112c5fa96de2bf82d2da51">write_exp_elt_objfile</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>)
<a name="l00270"></a>00270 {
<a name="l00271"></a>00271   <span class="keyword">union </span><a class="code" href="unionexp__element.html">exp_element</a> tmp;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;tmp, 0, <span class="keyword">sizeof</span> (<span class="keyword">union</span> <a class="code" href="unionexp__element.html">exp_element</a>));
<a name="l00274"></a>00274   tmp.<a class="code" href="unionexp__element.html#a966b14b1d361ed6b2f7cfc2053d5fa1f">objfile</a> = <a class="code" href="unionexp__element.html#a966b14b1d361ed6b2f7cfc2053d5fa1f">objfile</a>;
<a name="l00275"></a>00275   write_exp_elt (&amp;tmp);
<a name="l00276"></a>00276 }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 <span class="keywordtype">void</span>
<a name="l00279"></a><a class="code" href="parser-defs_8h.html#a8ee23be21ec18a185a44770eefab2919">00279</a> <a class="code" href="parse_8c.html#a64ae80b2d7d8330fcdf8c76e982b04cc">write_exp_elt_longcst</a> (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> expelt)
<a name="l00280"></a>00280 {
<a name="l00281"></a>00281   <span class="keyword">union </span><a class="code" href="unionexp__element.html">exp_element</a> tmp;
<a name="l00282"></a>00282 
<a name="l00283"></a>00283   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;tmp, 0, <span class="keyword">sizeof</span> (<span class="keyword">union</span> <a class="code" href="unionexp__element.html">exp_element</a>));
<a name="l00284"></a>00284   tmp.<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a> = expelt;
<a name="l00285"></a>00285   write_exp_elt (&amp;tmp);
<a name="l00286"></a>00286 }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 <span class="keywordtype">void</span>
<a name="l00289"></a><a class="code" href="parser-defs_8h.html#ac54196593edb037489b7a97fd077b672">00289</a> <a class="code" href="parse_8c.html#a5ed0808c91626de42f9b70933789a190">write_exp_elt_dblcst</a> (<a class="code" href="doublest_8h.html#ac1812677a2f11158956252854ec47a77">DOUBLEST</a> expelt)
<a name="l00290"></a>00290 {
<a name="l00291"></a>00291   <span class="keyword">union </span><a class="code" href="unionexp__element.html">exp_element</a> tmp;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;tmp, 0, <span class="keyword">sizeof</span> (<span class="keyword">union</span> <a class="code" href="unionexp__element.html">exp_element</a>));
<a name="l00294"></a>00294   tmp.<a class="code" href="unionexp__element.html#a8796ca8eaac2b403d1df7fc1cd952597">doubleconst</a> = expelt;
<a name="l00295"></a>00295   write_exp_elt (&amp;tmp);
<a name="l00296"></a>00296 }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="keywordtype">void</span>
<a name="l00299"></a><a class="code" href="parse_8c.html#aed8fa5eb66abe10612af7e35995e3a2c">00299</a> <a class="code" href="parse_8c.html#aed8fa5eb66abe10612af7e35995e3a2c">write_exp_elt_decfloatcst</a> (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> expelt[16])
<a name="l00300"></a>00300 {
<a name="l00301"></a>00301   <span class="keyword">union </span><a class="code" href="unionexp__element.html">exp_element</a> tmp;
<a name="l00302"></a>00302   <span class="keywordtype">int</span> index;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   <span class="keywordflow">for</span> (index = 0; index &lt; 16; index++)
<a name="l00305"></a>00305     tmp.<a class="code" href="unionexp__element.html#a81c0faa08ad8313e2b8a6b0578e27281">decfloatconst</a>[index] = expelt[index];
<a name="l00306"></a>00306 
<a name="l00307"></a>00307   write_exp_elt (&amp;tmp);
<a name="l00308"></a>00308 }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 <span class="keywordtype">void</span>
<a name="l00311"></a><a class="code" href="parser-defs_8h.html#a0cac5cfb7e2d4ebd9b9edae4c40728be">00311</a> <a class="code" href="parse_8c.html#a18da22a62164984a3f77d4d32f197ab1">write_exp_elt_type</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *expelt)
<a name="l00312"></a>00312 {
<a name="l00313"></a>00313   <span class="keyword">union </span><a class="code" href="unionexp__element.html">exp_element</a> tmp;
<a name="l00314"></a>00314 
<a name="l00315"></a>00315   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;tmp, 0, <span class="keyword">sizeof</span> (<span class="keyword">union</span> <a class="code" href="unionexp__element.html">exp_element</a>));
<a name="l00316"></a>00316   tmp.<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a> = expelt;
<a name="l00317"></a>00317   write_exp_elt (&amp;tmp);
<a name="l00318"></a>00318 }
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 <span class="keywordtype">void</span>
<a name="l00321"></a><a class="code" href="parser-defs_8h.html#a50fe2bb2ca207e498369315f267853f1">00321</a> <a class="code" href="parse_8c.html#a45f25d4fb6c53d059d9c7ee37a88fd55">write_exp_elt_intern</a> (<span class="keyword">struct</span> <a class="code" href="unionexp__element.html#a88d336fc104d34356be7910e76008a28">internalvar</a> *expelt)
<a name="l00322"></a>00322 {
<a name="l00323"></a>00323   <span class="keyword">union </span><a class="code" href="unionexp__element.html">exp_element</a> tmp;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;tmp, 0, <span class="keyword">sizeof</span> (<span class="keyword">union</span> <a class="code" href="unionexp__element.html">exp_element</a>));
<a name="l00326"></a>00326   tmp.<a class="code" href="unionexp__element.html#a88d336fc104d34356be7910e76008a28">internalvar</a> = expelt;
<a name="l00327"></a>00327   write_exp_elt (&amp;tmp);
<a name="l00328"></a>00328 }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 <span class="comment">/* Add a string constant to the end of the expression.</span>
<a name="l00331"></a>00331 <span class="comment"></span>
<a name="l00332"></a>00332 <span class="comment">   String constants are stored by first writing an expression element</span>
<a name="l00333"></a>00333 <span class="comment">   that contains the length of the string, then stuffing the string</span>
<a name="l00334"></a>00334 <span class="comment">   constant itself into however many expression elements are needed</span>
<a name="l00335"></a>00335 <span class="comment">   to hold it, and then writing another expression element that contains</span>
<a name="l00336"></a>00336 <span class="comment">   the length of the string.  I.e. an expression element at each end of</span>
<a name="l00337"></a>00337 <span class="comment">   the string records the string length, so you can skip over the </span>
<a name="l00338"></a>00338 <span class="comment">   expression elements containing the actual string bytes from either</span>
<a name="l00339"></a>00339 <span class="comment">   end of the string.  Note that this also allows gdb to handle</span>
<a name="l00340"></a>00340 <span class="comment">   strings with embedded null bytes, as is required for some languages.</span>
<a name="l00341"></a>00341 <span class="comment"></span>
<a name="l00342"></a>00342 <span class="comment">   Don&#39;t be fooled by the fact that the string is null byte terminated,</span>
<a name="l00343"></a>00343 <span class="comment">   this is strictly for the convenience of debugging gdb itself.</span>
<a name="l00344"></a>00344 <span class="comment">   Gdb does not depend up the string being null terminated, since the</span>
<a name="l00345"></a>00345 <span class="comment">   actual length is recorded in expression elements at each end of the</span>
<a name="l00346"></a>00346 <span class="comment">   string.  The null byte is taken into consideration when computing how</span>
<a name="l00347"></a>00347 <span class="comment">   many expression elements are required to hold the string constant, of</span>
<a name="l00348"></a>00348 <span class="comment">   course.  */</span>
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 
<a name="l00351"></a>00351 <span class="keywordtype">void</span>
<a name="l00352"></a><a class="code" href="parser-defs_8h.html#aada5e5280832c12f518a9a50e388f4ce">00352</a> <a class="code" href="parse_8c.html#a55b5f06af751f5dbe925473bd79e9b50">write_exp_string</a> (<span class="keyword">struct</span> <a class="code" href="structstoken.html">stoken</a> str)
<a name="l00353"></a>00353 {
<a name="l00354"></a>00354   <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a> = str.<a class="code" href="structstoken.html#a3b824e51aedbb867bf3e560fd9e05913">length</a>;
<a name="l00355"></a>00355   <span class="keywordtype">int</span> lenelt;
<a name="l00356"></a>00356   <span class="keywordtype">char</span> *strdata;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358   <span class="comment">/* Compute the number of expression elements required to hold the string</span>
<a name="l00359"></a>00359 <span class="comment">     (including a null byte terminator), along with one expression element</span>
<a name="l00360"></a>00360 <span class="comment">     at each end to record the actual string length (not including the</span>
<a name="l00361"></a>00361 <span class="comment">     null byte terminator).  */</span>
<a name="l00362"></a>00362 
<a name="l00363"></a>00363   lenelt = 2 + <a class="code" href="expression_8h.html#a8a1be157bb41aa92434ac6ce0e0fcf78">BYTES_TO_EXP_ELEM</a> (len + 1);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365   <span class="comment">/* Ensure that we have enough available expression elements to store</span>
<a name="l00366"></a>00366 <span class="comment">     everything.  */</span>
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <span class="keywordflow">if</span> ((<a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a> + lenelt) &gt;= <a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a>)
<a name="l00369"></a>00369     {
<a name="l00370"></a>00370       <a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a> = <a class="code" href="environ_8c.html#affe776513b24d84b39af8ab0930fef7f">max</a> (<a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a> * 2, <a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a> + lenelt + 10);
<a name="l00371"></a>00371       expout = (<span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *)
<a name="l00372"></a>00372         <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> ((<span class="keywordtype">char</span> *) <a class="code" href="parse_8c.html#a7c6040b4038ada3eebe2f1168c13b965">expout</a>, (<span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a>)
<a name="l00373"></a>00373                                     + EXP_ELEM_TO_BYTES (expout_size)));
<a name="l00374"></a>00374     }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376   <span class="comment">/* Write the leading length expression element (which advances the current</span>
<a name="l00377"></a>00377 <span class="comment">     expression element index), then write the string constant followed by a</span>
<a name="l00378"></a>00378 <span class="comment">     terminating null byte, and then write the trailing length expression</span>
<a name="l00379"></a>00379 <span class="comment">     element.  */</span>
<a name="l00380"></a>00380 
<a name="l00381"></a>00381   <a class="code" href="parse_8c.html#a64ae80b2d7d8330fcdf8c76e982b04cc">write_exp_elt_longcst</a> ((<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) len);
<a name="l00382"></a>00382   strdata = (<span class="keywordtype">char</span> *) &amp;expout-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[<a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a>];
<a name="l00383"></a>00383   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (strdata, str.<a class="code" href="structstoken.html#ae1c7b64f20fe8b3277827877ac961e90">ptr</a>, len);
<a name="l00384"></a>00384   *(strdata + <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>) = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00385"></a>00385   <a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a> += lenelt - 2;
<a name="l00386"></a>00386   <a class="code" href="parse_8c.html#a64ae80b2d7d8330fcdf8c76e982b04cc">write_exp_elt_longcst</a> ((<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) len);
<a name="l00387"></a>00387 }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 <span class="comment">/* Add a vector of string constants to the end of the expression.</span>
<a name="l00390"></a>00390 <span class="comment"></span>
<a name="l00391"></a>00391 <span class="comment">   This adds an OP_STRING operation, but encodes the contents</span>
<a name="l00392"></a>00392 <span class="comment">   differently from write_exp_string.  The language is expected to</span>
<a name="l00393"></a>00393 <span class="comment">   handle evaluation of this expression itself.</span>
<a name="l00394"></a>00394 <span class="comment">   </span>
<a name="l00395"></a>00395 <span class="comment">   After the usual OP_STRING header, TYPE is written into the</span>
<a name="l00396"></a>00396 <span class="comment">   expression as a long constant.  The interpretation of this field is</span>
<a name="l00397"></a>00397 <span class="comment">   up to the language evaluator.</span>
<a name="l00398"></a>00398 <span class="comment">   </span>
<a name="l00399"></a>00399 <span class="comment">   Next, each string in VEC is written.  The length is written as a</span>
<a name="l00400"></a>00400 <span class="comment">   long constant, followed by the contents of the string.  */</span>
<a name="l00401"></a>00401 
<a name="l00402"></a>00402 <span class="keywordtype">void</span>
<a name="l00403"></a><a class="code" href="parser-defs_8h.html#a5d743a6c5911a5c3acd9df892ea69324">00403</a> <a class="code" href="parse_8c.html#a5d743a6c5911a5c3acd9df892ea69324">write_exp_string_vector</a> (<span class="keywordtype">int</span> <a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> <a class="code" href="structstoken__vector.html">stoken_vector</a> *vec)
<a name="l00404"></a>00404 {
<a name="l00405"></a>00405   <span class="keywordtype">int</span> i, n_slots, <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l00406"></a>00406 
<a name="l00407"></a>00407   <span class="comment">/* Compute the size.  We compute the size in number of slots to</span>
<a name="l00408"></a>00408 <span class="comment">     avoid issues with string padding.  */</span>
<a name="l00409"></a>00409   n_slots = 0;
<a name="l00410"></a>00410   <span class="keywordflow">for</span> (i = 0; i &lt; vec-&gt;<a class="code" href="structstoken__vector.html#ac66b5be98f56ea51ee39ce80fc8a8a53">len</a>; ++i)
<a name="l00411"></a>00411     {
<a name="l00412"></a>00412       <span class="comment">/* One slot for the length of this element, plus the number of</span>
<a name="l00413"></a>00413 <span class="comment">         slots needed for this string.  */</span>
<a name="l00414"></a>00414       n_slots += 1 + <a class="code" href="expression_8h.html#a8a1be157bb41aa92434ac6ce0e0fcf78">BYTES_TO_EXP_ELEM</a> (vec-&gt;<a class="code" href="structstoken__vector.html#abc6ecdabc29db20c8a326e49e4e25090">tokens</a>[i].<a class="code" href="structtyped__stoken.html#a5ab4463e0a7e4b84c2596a474f07d932">length</a>);
<a name="l00415"></a>00415     }
<a name="l00416"></a>00416 
<a name="l00417"></a>00417   <span class="comment">/* One more slot for the type of the string.  */</span>
<a name="l00418"></a>00418   ++n_slots;
<a name="l00419"></a>00419 
<a name="l00420"></a>00420   <span class="comment">/* Now compute a phony string length.  */</span>
<a name="l00421"></a>00421   len = <a class="code" href="expression_8h.html#a0c3bd719efe17f3c1df1fe790f4ffd0d">EXP_ELEM_TO_BYTES</a> (n_slots) - 1;
<a name="l00422"></a>00422 
<a name="l00423"></a>00423   n_slots += 4;
<a name="l00424"></a>00424   <span class="keywordflow">if</span> ((<a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a> + n_slots) &gt;= <a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a>)
<a name="l00425"></a>00425     {
<a name="l00426"></a>00426       <a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a> = <a class="code" href="environ_8c.html#affe776513b24d84b39af8ab0930fef7f">max</a> (<a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a> * 2, <a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a> + n_slots + 10);
<a name="l00427"></a>00427       expout = (<span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *)
<a name="l00428"></a>00428         <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> ((<span class="keywordtype">char</span> *) <a class="code" href="parse_8c.html#a7c6040b4038ada3eebe2f1168c13b965">expout</a>, (<span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a>)
<a name="l00429"></a>00429                                     + EXP_ELEM_TO_BYTES (expout_size)));
<a name="l00430"></a>00430     }
<a name="l00431"></a>00431 
<a name="l00432"></a>00432   <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (OP_STRING);
<a name="l00433"></a>00433   <a class="code" href="parse_8c.html#a64ae80b2d7d8330fcdf8c76e982b04cc">write_exp_elt_longcst</a> (len);
<a name="l00434"></a>00434   <a class="code" href="parse_8c.html#a64ae80b2d7d8330fcdf8c76e982b04cc">write_exp_elt_longcst</a> (type);
<a name="l00435"></a>00435 
<a name="l00436"></a>00436   <span class="keywordflow">for</span> (i = 0; i &lt; vec-&gt;<a class="code" href="structstoken__vector.html#ac66b5be98f56ea51ee39ce80fc8a8a53">len</a>; ++i)
<a name="l00437"></a>00437     {
<a name="l00438"></a>00438       <a class="code" href="parse_8c.html#a64ae80b2d7d8330fcdf8c76e982b04cc">write_exp_elt_longcst</a> (vec-&gt;<a class="code" href="structstoken__vector.html#abc6ecdabc29db20c8a326e49e4e25090">tokens</a>[i].<a class="code" href="structtyped__stoken.html#a5ab4463e0a7e4b84c2596a474f07d932">length</a>);
<a name="l00439"></a>00439       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (&amp;expout-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[<a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a>], vec-&gt;<a class="code" href="structstoken__vector.html#abc6ecdabc29db20c8a326e49e4e25090">tokens</a>[i].<a class="code" href="structtyped__stoken.html#a93bc2edd5eab0b35a487075cc72f3be2">ptr</a>,
<a name="l00440"></a>00440               vec-&gt;<a class="code" href="structstoken__vector.html#abc6ecdabc29db20c8a326e49e4e25090">tokens</a>[i].<a class="code" href="structtyped__stoken.html#a5ab4463e0a7e4b84c2596a474f07d932">length</a>);
<a name="l00441"></a>00441       <a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a> += <a class="code" href="expression_8h.html#a8a1be157bb41aa92434ac6ce0e0fcf78">BYTES_TO_EXP_ELEM</a> (vec-&gt;<a class="code" href="structstoken__vector.html#abc6ecdabc29db20c8a326e49e4e25090">tokens</a>[i].<a class="code" href="structtyped__stoken.html#a5ab4463e0a7e4b84c2596a474f07d932">length</a>);
<a name="l00442"></a>00442     }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444   <a class="code" href="parse_8c.html#a64ae80b2d7d8330fcdf8c76e982b04cc">write_exp_elt_longcst</a> (len);
<a name="l00445"></a>00445   <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (OP_STRING);
<a name="l00446"></a>00446 }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448 <span class="comment">/* Add a bitstring constant to the end of the expression.</span>
<a name="l00449"></a>00449 <span class="comment"></span>
<a name="l00450"></a>00450 <span class="comment">   Bitstring constants are stored by first writing an expression element</span>
<a name="l00451"></a>00451 <span class="comment">   that contains the length of the bitstring (in bits), then stuffing the</span>
<a name="l00452"></a>00452 <span class="comment">   bitstring constant itself into however many expression elements are</span>
<a name="l00453"></a>00453 <span class="comment">   needed to hold it, and then writing another expression element that</span>
<a name="l00454"></a>00454 <span class="comment">   contains the length of the bitstring.  I.e. an expression element at</span>
<a name="l00455"></a>00455 <span class="comment">   each end of the bitstring records the bitstring length, so you can skip</span>
<a name="l00456"></a>00456 <span class="comment">   over the expression elements containing the actual bitstring bytes from</span>
<a name="l00457"></a>00457 <span class="comment">   either end of the bitstring.  */</span>
<a name="l00458"></a>00458 
<a name="l00459"></a>00459 <span class="keywordtype">void</span>
<a name="l00460"></a><a class="code" href="parser-defs_8h.html#a67650e1bd5b8ec36c7bde3e7c0cc6e98">00460</a> <a class="code" href="parse_8c.html#acae95369ac544e27420b32644c6a6cc1">write_exp_bitstring</a> (<span class="keyword">struct</span> <a class="code" href="structstoken.html">stoken</a> str)
<a name="l00461"></a>00461 {
<a name="l00462"></a>00462   <span class="keywordtype">int</span> <a class="code" href="arm-tdep_8c.html#a6d53921cd0f216408c4aed2806a0cb1f">bits</a> = str.<a class="code" href="structstoken.html#a3b824e51aedbb867bf3e560fd9e05913">length</a>;        <span class="comment">/* length in bits */</span>
<a name="l00463"></a>00463   <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a> = (bits + <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - 1) / <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l00464"></a>00464   <span class="keywordtype">int</span> lenelt;
<a name="l00465"></a>00465   <span class="keywordtype">char</span> *strdata;
<a name="l00466"></a>00466 
<a name="l00467"></a>00467   <span class="comment">/* Compute the number of expression elements required to hold the bitstring,</span>
<a name="l00468"></a>00468 <span class="comment">     along with one expression element at each end to record the actual</span>
<a name="l00469"></a>00469 <span class="comment">     bitstring length in bits.  */</span>
<a name="l00470"></a>00470 
<a name="l00471"></a>00471   lenelt = 2 + <a class="code" href="expression_8h.html#a8a1be157bb41aa92434ac6ce0e0fcf78">BYTES_TO_EXP_ELEM</a> (len);
<a name="l00472"></a>00472 
<a name="l00473"></a>00473   <span class="comment">/* Ensure that we have enough available expression elements to store</span>
<a name="l00474"></a>00474 <span class="comment">     everything.  */</span>
<a name="l00475"></a>00475 
<a name="l00476"></a>00476   <span class="keywordflow">if</span> ((<a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a> + lenelt) &gt;= <a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a>)
<a name="l00477"></a>00477     {
<a name="l00478"></a>00478       <a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a> = <a class="code" href="environ_8c.html#affe776513b24d84b39af8ab0930fef7f">max</a> (<a class="code" href="parse_8c.html#a74d514629651e8432694ef0d387b0f58">expout_size</a> * 2, <a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a> + lenelt + 10);
<a name="l00479"></a>00479       expout = (<span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *)
<a name="l00480"></a>00480         <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> ((<span class="keywordtype">char</span> *) <a class="code" href="parse_8c.html#a7c6040b4038ada3eebe2f1168c13b965">expout</a>, (<span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a>)
<a name="l00481"></a>00481                                     + EXP_ELEM_TO_BYTES (expout_size)));
<a name="l00482"></a>00482     }
<a name="l00483"></a>00483 
<a name="l00484"></a>00484   <span class="comment">/* Write the leading length expression element (which advances the current</span>
<a name="l00485"></a>00485 <span class="comment">     expression element index), then write the bitstring constant, and then</span>
<a name="l00486"></a>00486 <span class="comment">     write the trailing length expression element.  */</span>
<a name="l00487"></a>00487 
<a name="l00488"></a>00488   <a class="code" href="parse_8c.html#a64ae80b2d7d8330fcdf8c76e982b04cc">write_exp_elt_longcst</a> ((<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) bits);
<a name="l00489"></a>00489   strdata = (<span class="keywordtype">char</span> *) &amp;expout-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[<a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a>];
<a name="l00490"></a>00490   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (strdata, str.<a class="code" href="structstoken.html#ae1c7b64f20fe8b3277827877ac961e90">ptr</a>, len);
<a name="l00491"></a>00491   <a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a> += lenelt - 2;
<a name="l00492"></a>00492   <a class="code" href="parse_8c.html#a64ae80b2d7d8330fcdf8c76e982b04cc">write_exp_elt_longcst</a> ((<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) bits);
<a name="l00493"></a>00493 }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495 <span class="comment">/* Add the appropriate elements for a minimal symbol to the end of</span>
<a name="l00496"></a>00496 <span class="comment">   the expression.  */</span>
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 <span class="keywordtype">void</span>
<a name="l00499"></a><a class="code" href="parser-defs_8h.html#a2e2e044dd416cc122b2f8da5c8f79b38">00499</a> <a class="code" href="parse_8c.html#a2a1de4c05adb546aeb191749135950cc">write_exp_msymbol</a> (<span class="keyword">struct</span> <a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol</a> bound_msym)
<a name="l00500"></a>00500 {
<a name="l00501"></a>00501   <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *msymbol = bound_msym.<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>;
<a name="l00502"></a>00502   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a> = bound_msym.<a class="code" href="structbound__minimal__symbol.html#a070e0e47d191675f0f4892e0b321d663">objfile</a>;
<a name="l00503"></a>00503   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l00504"></a>00504 
<a name="l00505"></a>00505   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr = <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (msymbol);
<a name="l00506"></a>00506   <span class="keyword">struct </span><a class="code" href="structobj__section.html">obj_section</a> *section = <a class="code" href="symtab_8h.html#a68f0685d666b6934c762f89d9b996c63">SYMBOL_OBJ_SECTION</a> (objfile, msymbol);
<a name="l00507"></a>00507   <span class="keyword">enum</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036">minimal_symbol_type</a> <a class="code" href="structtype.html">type</a> = <a class="code" href="symtab_8h.html#a1d0b27d446f2622f464727b6a06ae263">MSYMBOL_TYPE</a> (msymbol);
<a name="l00508"></a>00508   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc;
<a name="l00509"></a>00509 
<a name="l00510"></a>00510   <span class="comment">/* The minimal symbol might point to a function descriptor;</span>
<a name="l00511"></a>00511 <span class="comment">     resolve it to the actual code address instead.  */</span>
<a name="l00512"></a>00512   pc = <a class="code" href="gdbarch_8c.html#adc1ce8006630950c775890c6fe36faa1">gdbarch_convert_from_func_ptr_addr</a> (gdbarch, addr, &amp;<a class="code" href="target_8h.html#a2d8640b030266b58d3821eb5cfd112b9">current_target</a>);
<a name="l00513"></a>00513   <span class="keywordflow">if</span> (pc != addr)
<a name="l00514"></a>00514     {
<a name="l00515"></a>00515       <span class="keyword">struct </span><a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol</a> ifunc_msym = <a class="code" href="minsyms_8c.html#ad4b48b6ef6c913138a8ac33f8c3cfeb2">lookup_minimal_symbol_by_pc</a> (pc);
<a name="l00516"></a>00516 
<a name="l00517"></a>00517       <span class="comment">/* In this case, assume we have a code symbol instead of</span>
<a name="l00518"></a>00518 <span class="comment">         a data symbol.  */</span>
<a name="l00519"></a>00519 
<a name="l00520"></a>00520       <span class="keywordflow">if</span> (ifunc_msym.<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a> != NULL
<a name="l00521"></a>00521           &amp;&amp; <a class="code" href="symtab_8h.html#a1d0b27d446f2622f464727b6a06ae263">MSYMBOL_TYPE</a> (ifunc_msym.<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>) == <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036af6ba30d7a115e1618b8480a5628349e4">mst_text_gnu_ifunc</a>
<a name="l00522"></a>00522           &amp;&amp; <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (ifunc_msym.<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>) == pc)
<a name="l00523"></a>00523         {
<a name="l00524"></a>00524           <span class="comment">/* A function descriptor has been resolved but PC is still in the</span>
<a name="l00525"></a>00525 <span class="comment">             STT_GNU_IFUNC resolver body (such as because inferior does not</span>
<a name="l00526"></a>00526 <span class="comment">             run to be able to call it).  */</span>
<a name="l00527"></a>00527 
<a name="l00528"></a>00528           type = <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036af6ba30d7a115e1618b8480a5628349e4">mst_text_gnu_ifunc</a>;
<a name="l00529"></a>00529         }
<a name="l00530"></a>00530       <span class="keywordflow">else</span>
<a name="l00531"></a>00531         type = <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036af24db58d8996f50560c2f03d9c8514c0">mst_text</a>;
<a name="l00532"></a>00532       section = NULL;
<a name="l00533"></a>00533       addr = pc;
<a name="l00534"></a>00534     }
<a name="l00535"></a>00535 
<a name="l00536"></a>00536   <span class="keywordflow">if</span> (<a class="code" href="symfile_8c.html#ad96d01ef61ee2925825b3992d37408f5">overlay_debugging</a>)
<a name="l00537"></a>00537     addr = <a class="code" href="symfile_8c.html#af36fea5340bbbbbae5c9e8979b40d700">symbol_overlayed_address</a> (addr, section);
<a name="l00538"></a>00538 
<a name="l00539"></a>00539   <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (OP_LONG);
<a name="l00540"></a>00540   <span class="comment">/* Let&#39;s make the type big enough to hold a 64-bit address.  */</span>
<a name="l00541"></a>00541   <a class="code" href="parse_8c.html#a18da22a62164984a3f77d4d32f197ab1">write_exp_elt_type</a> (<a class="code" href="structobjfile__type.html">objfile_type</a> (objfile)-&gt;builtin_core_addr);
<a name="l00542"></a>00542   <a class="code" href="parse_8c.html#a64ae80b2d7d8330fcdf8c76e982b04cc">write_exp_elt_longcst</a> ((<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) addr);
<a name="l00543"></a>00543   <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (OP_LONG);
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="keywordflow">if</span> (section &amp;&amp; section-&gt;<a class="code" href="structobj__section.html#ad233927d4d1037bde66ab9628ae82345">the_bfd_section</a>-&gt;flags &amp; SEC_THREAD_LOCAL)
<a name="l00546"></a>00546     {
<a name="l00547"></a>00547       <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (UNOP_MEMVAL_TLS);
<a name="l00548"></a>00548       <a class="code" href="parse_8c.html#a8f15f40d7b112c5fa96de2bf82d2da51">write_exp_elt_objfile</a> (objfile);
<a name="l00549"></a>00549       <a class="code" href="parse_8c.html#a18da22a62164984a3f77d4d32f197ab1">write_exp_elt_type</a> (<a class="code" href="structobjfile__type.html">objfile_type</a> (objfile)-&gt;nodebug_tls_symbol);
<a name="l00550"></a>00550       <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (UNOP_MEMVAL_TLS);
<a name="l00551"></a>00551       <span class="keywordflow">return</span>;
<a name="l00552"></a>00552     }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554   <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (UNOP_MEMVAL);
<a name="l00555"></a>00555   <span class="keywordflow">switch</span> (type)
<a name="l00556"></a>00556     {
<a name="l00557"></a>00557     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036af24db58d8996f50560c2f03d9c8514c0">mst_text</a>:
<a name="l00558"></a>00558     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036abe55ea8e467b6e7517e226164aa94adb">mst_file_text</a>:
<a name="l00559"></a>00559     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036aa6ace68113ace3aafa25e705d9fce85d">mst_solib_trampoline</a>:
<a name="l00560"></a>00560       <a class="code" href="parse_8c.html#a18da22a62164984a3f77d4d32f197ab1">write_exp_elt_type</a> (<a class="code" href="structobjfile__type.html">objfile_type</a> (objfile)-&gt;nodebug_text_symbol);
<a name="l00561"></a>00561       <span class="keywordflow">break</span>;
<a name="l00562"></a>00562 
<a name="l00563"></a>00563     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036af6ba30d7a115e1618b8480a5628349e4">mst_text_gnu_ifunc</a>:
<a name="l00564"></a>00564       <a class="code" href="parse_8c.html#a18da22a62164984a3f77d4d32f197ab1">write_exp_elt_type</a> (<a class="code" href="structobjfile__type.html">objfile_type</a> (objfile)
<a name="l00565"></a>00565                                                -&gt;nodebug_text_gnu_ifunc_symbol);
<a name="l00566"></a>00566       <span class="keywordflow">break</span>;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036a71b45da3c83c4939f9ff3b2b641c05b0">mst_data</a>:
<a name="l00569"></a>00569     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036ad2119ba8e1b909d5c67d8d53bf772eab">mst_file_data</a>:
<a name="l00570"></a>00570     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036a5ead91e96fa8091e4b168773f8d69242">mst_bss</a>:
<a name="l00571"></a>00571     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036afcbb0b5fa236563bce133159d8aba081">mst_file_bss</a>:
<a name="l00572"></a>00572       <a class="code" href="parse_8c.html#a18da22a62164984a3f77d4d32f197ab1">write_exp_elt_type</a> (<a class="code" href="structobjfile__type.html">objfile_type</a> (objfile)-&gt;nodebug_data_symbol);
<a name="l00573"></a>00573       <span class="keywordflow">break</span>;
<a name="l00574"></a>00574 
<a name="l00575"></a>00575     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036acc9a9bdfca0dfaffb30738070e32bec4">mst_slot_got_plt</a>:
<a name="l00576"></a>00576       <a class="code" href="parse_8c.html#a18da22a62164984a3f77d4d32f197ab1">write_exp_elt_type</a> (<a class="code" href="structobjfile__type.html">objfile_type</a> (objfile)-&gt;nodebug_got_plt_symbol);
<a name="l00577"></a>00577       <span class="keywordflow">break</span>;
<a name="l00578"></a>00578 
<a name="l00579"></a>00579     <span class="keywordflow">default</span>:
<a name="l00580"></a>00580       <a class="code" href="parse_8c.html#a18da22a62164984a3f77d4d32f197ab1">write_exp_elt_type</a> (<a class="code" href="structobjfile__type.html">objfile_type</a> (objfile)-&gt;nodebug_unknown_symbol);
<a name="l00581"></a>00581       <span class="keywordflow">break</span>;
<a name="l00582"></a>00582     }
<a name="l00583"></a>00583   <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (UNOP_MEMVAL);
<a name="l00584"></a>00584 }
<a name="l00585"></a>00585 
<a name="l00586"></a>00586 <span class="comment">/* Mark the current index as the starting location of a structure</span>
<a name="l00587"></a>00587 <span class="comment">   expression.  This is used when completing on field names.  */</span>
<a name="l00588"></a>00588 
<a name="l00589"></a>00589 <span class="keywordtype">void</span>
<a name="l00590"></a><a class="code" href="parser-defs_8h.html#a8d5a956772a65c17f8b723f1d7593ca8">00590</a> <a class="code" href="parse_8c.html#a8d5a956772a65c17f8b723f1d7593ca8">mark_struct_expression</a> (<span class="keywordtype">void</span>)
<a name="l00591"></a>00591 {
<a name="l00592"></a>00592   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="expression_8h.html#a7cdba29abd014ae348e7a95cb9fb5aff">parse_completion</a>
<a name="l00593"></a>00593               &amp;&amp; expout_tag_completion_type == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ac0ed09886a958d1a94646893440004a8">TYPE_CODE_UNDEF</a>);
<a name="l00594"></a>00594   expout_last_struct = <a class="code" href="parse_8c.html#a979f38678d589f7c5f9c7ff140c16f7a">expout_ptr</a>;
<a name="l00595"></a>00595 }
<a name="l00596"></a>00596 
<a name="l00597"></a>00597 <span class="comment">/* Indicate that the current parser invocation is completing a tag.</span>
<a name="l00598"></a>00598 <span class="comment">   TAG is the type code of the tag, and PTR and LENGTH represent the</span>
<a name="l00599"></a>00599 <span class="comment">   start of the tag name.  */</span>
<a name="l00600"></a>00600 
<a name="l00601"></a>00601 <span class="keywordtype">void</span>
<a name="l00602"></a><a class="code" href="parser-defs_8h.html#a37eb5e8eb69a395e2911bfe26eabb2d0">00602</a> <a class="code" href="parse_8c.html#a5f37d72439bae1e892717122a51ef383">mark_completion_tag</a> (<span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> tag, <span class="keyword">const</span> <span class="keywordtype">char</span> *ptr, <span class="keywordtype">int</span> length)
<a name="l00603"></a>00603 {
<a name="l00604"></a>00604   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="expression_8h.html#a7cdba29abd014ae348e7a95cb9fb5aff">parse_completion</a>
<a name="l00605"></a>00605               &amp;&amp; expout_tag_completion_type == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ac0ed09886a958d1a94646893440004a8">TYPE_CODE_UNDEF</a>
<a name="l00606"></a>00606               &amp;&amp; expout_completion_name == NULL
<a name="l00607"></a>00607               &amp;&amp; expout_last_struct == -1);
<a name="l00608"></a>00608   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (tag == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>
<a name="l00609"></a>00609               || tag == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l00610"></a>00610               || tag == <a class="code" href="gdbtypes_8h.html#a9f70b67b4d14548a879667f544eab4ef">TYPE_CODE_CLASS</a>
<a name="l00611"></a>00611               || tag == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>);
<a name="l00612"></a>00612   expout_tag_completion_type = tag;
<a name="l00613"></a>00613   expout_completion_name = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (length + 1);
<a name="l00614"></a>00614   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (expout_completion_name, ptr, length);
<a name="l00615"></a>00615   expout_completion_name[length] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00616"></a>00616 }
<a name="l00617"></a>00617 
<a name="l00618"></a>00618 
<a name="l00619"></a>00619 <span class="comment">/* Recognize tokens that start with &#39;$&#39;.  These include:</span>
<a name="l00620"></a>00620 <span class="comment"></span>
<a name="l00621"></a>00621 <span class="comment">   $regname     A native register name or a &quot;standard</span>
<a name="l00622"></a>00622 <span class="comment">   register name&quot;.</span>
<a name="l00623"></a>00623 <span class="comment"></span>
<a name="l00624"></a>00624 <span class="comment">   $variable    A convenience variable with a name chosen</span>
<a name="l00625"></a>00625 <span class="comment">   by the user.</span>
<a name="l00626"></a>00626 <span class="comment"></span>
<a name="l00627"></a>00627 <span class="comment">   $digits              Value history with index &lt;digits&gt;, starting</span>
<a name="l00628"></a>00628 <span class="comment">   from the first value which has index 1.</span>
<a name="l00629"></a>00629 <span class="comment"></span>
<a name="l00630"></a>00630 <span class="comment">   $$digits     Value history with index &lt;digits&gt; relative</span>
<a name="l00631"></a>00631 <span class="comment">   to the last value.  I.e. $$0 is the last</span>
<a name="l00632"></a>00632 <span class="comment">   value, $$1 is the one previous to that, $$2</span>
<a name="l00633"></a>00633 <span class="comment">   is the one previous to $$1, etc.</span>
<a name="l00634"></a>00634 <span class="comment"></span>
<a name="l00635"></a>00635 <span class="comment">   $ | $0 | $$0 The last value in the value history.</span>
<a name="l00636"></a>00636 <span class="comment"></span>
<a name="l00637"></a>00637 <span class="comment">   $$           An abbreviation for the second to the last</span>
<a name="l00638"></a>00638 <span class="comment">   value in the value history, I.e. $$1  */</span>
<a name="l00639"></a>00639 
<a name="l00640"></a>00640 <span class="keywordtype">void</span>
<a name="l00641"></a><a class="code" href="parser-defs_8h.html#a39873835b13269590cab0dceaa7af5dc">00641</a> <a class="code" href="parse_8c.html#a39873835b13269590cab0dceaa7af5dc">write_dollar_variable</a> (<span class="keyword">struct</span> <a class="code" href="structstoken.html">stoken</a> str)
<a name="l00642"></a>00642 {
<a name="l00643"></a>00643   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym = NULL;
<a name="l00644"></a>00644   <span class="keyword">struct </span><a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol</a> msym;
<a name="l00645"></a>00645   <span class="keyword">struct </span>internalvar *isym = NULL;
<a name="l00646"></a>00646 
<a name="l00647"></a>00647   <span class="comment">/* Handle the tokens $digits; also $ (short for $0) and $$ (short for $$1)</span>
<a name="l00648"></a>00648 <span class="comment">     and $$digits (equivalent to $&lt;-digits&gt; if you could type that).  */</span>
<a name="l00649"></a>00649 
<a name="l00650"></a>00650   <span class="keywordtype">int</span> negate = 0;
<a name="l00651"></a>00651   <span class="keywordtype">int</span> i = 1;
<a name="l00652"></a>00652   <span class="comment">/* Double dollar means negate the number and add -1 as well.</span>
<a name="l00653"></a>00653 <span class="comment">     Thus $$ alone means -1.  */</span>
<a name="l00654"></a>00654   <span class="keywordflow">if</span> (str.<a class="code" href="structstoken.html#a3b824e51aedbb867bf3e560fd9e05913">length</a> &gt;= 2 &amp;&amp; str.<a class="code" href="structstoken.html#ae1c7b64f20fe8b3277827877ac961e90">ptr</a>[1] == <span class="charliteral">&#39;$&#39;</span>)
<a name="l00655"></a>00655     {
<a name="l00656"></a>00656       negate = 1;
<a name="l00657"></a>00657       i = 2;
<a name="l00658"></a>00658     }
<a name="l00659"></a>00659   <span class="keywordflow">if</span> (i == str.<a class="code" href="structstoken.html#a3b824e51aedbb867bf3e560fd9e05913">length</a>)
<a name="l00660"></a>00660     {
<a name="l00661"></a>00661       <span class="comment">/* Just dollars (one or two).  */</span>
<a name="l00662"></a>00662       i = -negate;
<a name="l00663"></a>00663       <span class="keywordflow">goto</span> handle_last;
<a name="l00664"></a>00664     }
<a name="l00665"></a>00665   <span class="comment">/* Is the rest of the token digits?  */</span>
<a name="l00666"></a>00666   <span class="keywordflow">for</span> (; i &lt; str.<a class="code" href="structstoken.html#a3b824e51aedbb867bf3e560fd9e05913">length</a>; i++)
<a name="l00667"></a>00667     <span class="keywordflow">if</span> (!(str.<a class="code" href="structstoken.html#ae1c7b64f20fe8b3277827877ac961e90">ptr</a>[i] &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; str.<a class="code" href="structstoken.html#ae1c7b64f20fe8b3277827877ac961e90">ptr</a>[i] &lt;= <span class="charliteral">&#39;9&#39;</span>))
<a name="l00668"></a>00668       <span class="keywordflow">break</span>;
<a name="l00669"></a>00669   <span class="keywordflow">if</span> (i == str.<a class="code" href="structstoken.html#a3b824e51aedbb867bf3e560fd9e05913">length</a>)
<a name="l00670"></a>00670     {
<a name="l00671"></a>00671       i = atoi (str.<a class="code" href="structstoken.html#ae1c7b64f20fe8b3277827877ac961e90">ptr</a> + 1 + negate);
<a name="l00672"></a>00672       <span class="keywordflow">if</span> (negate)
<a name="l00673"></a>00673         i = -i;
<a name="l00674"></a>00674       <span class="keywordflow">goto</span> handle_last;
<a name="l00675"></a>00675     }
<a name="l00676"></a>00676 
<a name="l00677"></a>00677   <span class="comment">/* Handle tokens that refer to machine registers:</span>
<a name="l00678"></a>00678 <span class="comment">     $ followed by a register name.  */</span>
<a name="l00679"></a>00679   i = <a class="code" href="user-regs_8c.html#a73129d16744501cecc45fb94c573c277">user_reg_map_name_to_regnum</a> (<a class="code" href="parser-defs_8h.html#ab29b33d73e1262c7c1c7aaab63c57ba9">parse_gdbarch</a>,
<a name="l00680"></a>00680                                    str.<a class="code" href="structstoken.html#ae1c7b64f20fe8b3277827877ac961e90">ptr</a> + 1, str.<a class="code" href="structstoken.html#a3b824e51aedbb867bf3e560fd9e05913">length</a> - 1);
<a name="l00681"></a>00681   <span class="keywordflow">if</span> (i &gt;= 0)
<a name="l00682"></a>00682     <span class="keywordflow">goto</span> handle_register;
<a name="l00683"></a>00683 
<a name="l00684"></a>00684   <span class="comment">/* Any names starting with $ are probably debugger internal variables.  */</span>
<a name="l00685"></a>00685 
<a name="l00686"></a>00686   isym = <a class="code" href="value_8c.html#a71c6e480acfc24d263dc97557a66dfbe">lookup_only_internalvar</a> (<a class="code" href="parse_8c.html#ae2c3f5e61c639d2b9821cbb548bbe10c">copy_name</a> (str) + 1);
<a name="l00687"></a>00687   <span class="keywordflow">if</span> (isym)
<a name="l00688"></a>00688     {
<a name="l00689"></a>00689       <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (OP_INTERNALVAR);
<a name="l00690"></a>00690       <a class="code" href="parse_8c.html#a45f25d4fb6c53d059d9c7ee37a88fd55">write_exp_elt_intern</a> (isym);
<a name="l00691"></a>00691       <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (OP_INTERNALVAR);
<a name="l00692"></a>00692       <span class="keywordflow">return</span>;
<a name="l00693"></a>00693     }
<a name="l00694"></a>00694 
<a name="l00695"></a>00695   <span class="comment">/* On some systems, such as HP-UX and hppa-linux, certain system routines </span>
<a name="l00696"></a>00696 <span class="comment">     have names beginning with $ or $$.  Check for those, first.  */</span>
<a name="l00697"></a>00697 
<a name="l00698"></a>00698   sym = <a class="code" href="symtab_8c.html#a8a5c3f803198aed047a55c0e4f61b315">lookup_symbol</a> (<a class="code" href="parse_8c.html#ae2c3f5e61c639d2b9821cbb548bbe10c">copy_name</a> (str), (<span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *) NULL,
<a name="l00699"></a>00699                        <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>, NULL);
<a name="l00700"></a>00700   <span class="keywordflow">if</span> (sym)
<a name="l00701"></a>00701     {
<a name="l00702"></a>00702       <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (OP_VAR_VALUE);
<a name="l00703"></a>00703       <a class="code" href="parse_8c.html#a29c5ee518bbab042a1d1f4ee7c7e7e57">write_exp_elt_block</a> (<a class="code" href="parser-defs_8h.html#a4b63b4fd2a25331b4da688f1936187a6">block_found</a>);        <span class="comment">/* set by lookup_symbol */</span>
<a name="l00704"></a>00704       <a class="code" href="parse_8c.html#a786c3106f7e316d7a240cf54fb6395cd">write_exp_elt_sym</a> (sym);
<a name="l00705"></a>00705       <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (OP_VAR_VALUE);
<a name="l00706"></a>00706       <span class="keywordflow">return</span>;
<a name="l00707"></a>00707     }
<a name="l00708"></a>00708   msym = <a class="code" href="minsyms_8c.html#a897792988bedbb8b26bdc46838516a90">lookup_bound_minimal_symbol</a> (<a class="code" href="parse_8c.html#ae2c3f5e61c639d2b9821cbb548bbe10c">copy_name</a> (str));
<a name="l00709"></a>00709   <span class="keywordflow">if</span> (msym.<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>)
<a name="l00710"></a>00710     {
<a name="l00711"></a>00711       <a class="code" href="parse_8c.html#a2a1de4c05adb546aeb191749135950cc">write_exp_msymbol</a> (msym);
<a name="l00712"></a>00712       <span class="keywordflow">return</span>;
<a name="l00713"></a>00713     }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715   <span class="comment">/* Any other names are assumed to be debugger internal variables.  */</span>
<a name="l00716"></a>00716 
<a name="l00717"></a>00717   <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (OP_INTERNALVAR);
<a name="l00718"></a>00718   <a class="code" href="parse_8c.html#a45f25d4fb6c53d059d9c7ee37a88fd55">write_exp_elt_intern</a> (<a class="code" href="value_8c.html#ac4984ad6ed224b545df319e6a8259798">create_internalvar</a> (<a class="code" href="parse_8c.html#ae2c3f5e61c639d2b9821cbb548bbe10c">copy_name</a> (str) + 1));
<a name="l00719"></a>00719   <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (OP_INTERNALVAR);
<a name="l00720"></a>00720   <span class="keywordflow">return</span>;
<a name="l00721"></a>00721 handle_last:
<a name="l00722"></a>00722   <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (OP_LAST);
<a name="l00723"></a>00723   <a class="code" href="parse_8c.html#a64ae80b2d7d8330fcdf8c76e982b04cc">write_exp_elt_longcst</a> ((<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) i);
<a name="l00724"></a>00724   <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (OP_LAST);
<a name="l00725"></a>00725   <span class="keywordflow">return</span>;
<a name="l00726"></a>00726 handle_register:
<a name="l00727"></a>00727   <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (OP_REGISTER);
<a name="l00728"></a>00728   str.<a class="code" href="structstoken.html#a3b824e51aedbb867bf3e560fd9e05913">length</a>--;
<a name="l00729"></a>00729   str.<a class="code" href="structstoken.html#ae1c7b64f20fe8b3277827877ac961e90">ptr</a>++;
<a name="l00730"></a>00730   <a class="code" href="parse_8c.html#a55b5f06af751f5dbe925473bd79e9b50">write_exp_string</a> (str);
<a name="l00731"></a>00731   <a class="code" href="parse_8c.html#a609d0f31c6ee03ad8a531647ff6cf7d5">write_exp_elt_opcode</a> (OP_REGISTER);
<a name="l00732"></a>00732   <span class="keywordflow">return</span>;
<a name="l00733"></a>00733 }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735 
<a name="l00736"></a>00736 <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00737"></a><a class="code" href="parser-defs_8h.html#ac24ea03d12c7c1fe051640e8615b3db7">00737</a> <a class="code" href="parse_8c.html#ac01366adc14521d1a067005600fe165b">find_template_name_end</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *p)
<a name="l00738"></a>00738 {
<a name="l00739"></a>00739   <span class="keywordtype">int</span> depth = 1;
<a name="l00740"></a>00740   <span class="keywordtype">int</span> just_seen_right = 0;
<a name="l00741"></a>00741   <span class="keywordtype">int</span> just_seen_colon = 0;
<a name="l00742"></a>00742   <span class="keywordtype">int</span> just_seen_space = 0;
<a name="l00743"></a>00743 
<a name="l00744"></a>00744   <span class="keywordflow">if</span> (!p || (*p != <span class="charliteral">&#39;&lt;&#39;</span>))
<a name="l00745"></a>00745     <span class="keywordflow">return</span> 0;
<a name="l00746"></a>00746 
<a name="l00747"></a>00747   <span class="keywordflow">while</span> (*++p)
<a name="l00748"></a>00748     {
<a name="l00749"></a>00749       <span class="keywordflow">switch</span> (*p)
<a name="l00750"></a>00750         {
<a name="l00751"></a>00751         <span class="keywordflow">case</span> <span class="charliteral">&#39;\&#39;&#39;</span>:
<a name="l00752"></a>00752         <span class="keywordflow">case</span> <span class="charliteral">&#39;\&quot;&#39;</span>:
<a name="l00753"></a>00753         <span class="keywordflow">case</span> <span class="charliteral">&#39;{&#39;</span>:
<a name="l00754"></a>00754         <span class="keywordflow">case</span> <span class="charliteral">&#39;}&#39;</span>:
<a name="l00755"></a>00755           <span class="comment">/* In future, may want to allow these??  */</span>
<a name="l00756"></a>00756           <span class="keywordflow">return</span> 0;
<a name="l00757"></a>00757         <span class="keywordflow">case</span> <span class="charliteral">&#39;&lt;&#39;</span>:
<a name="l00758"></a>00758           depth++;              <span class="comment">/* start nested template */</span>
<a name="l00759"></a>00759           <span class="keywordflow">if</span> (just_seen_colon || just_seen_right || just_seen_space)
<a name="l00760"></a>00760             <span class="keywordflow">return</span> 0;           <span class="comment">/* but not after : or :: or &gt; or space */</span>
<a name="l00761"></a>00761           <span class="keywordflow">break</span>;
<a name="l00762"></a>00762         <span class="keywordflow">case</span> <span class="charliteral">&#39;&gt;&#39;</span>:
<a name="l00763"></a>00763           <span class="keywordflow">if</span> (just_seen_colon || just_seen_right)
<a name="l00764"></a>00764             <span class="keywordflow">return</span> 0;           <span class="comment">/* end a (nested?) template */</span>
<a name="l00765"></a>00765           just_seen_right = 1;  <span class="comment">/* but not after : or :: */</span>
<a name="l00766"></a>00766           <span class="keywordflow">if</span> (--depth == 0)     <span class="comment">/* also disallow &gt;&gt;, insist on &gt; &gt; */</span>
<a name="l00767"></a>00767             <span class="keywordflow">return</span> ++p;         <span class="comment">/* if outermost ended, return */</span>
<a name="l00768"></a>00768           <span class="keywordflow">break</span>;
<a name="l00769"></a>00769         <span class="keywordflow">case</span> <span class="charliteral">&#39;:&#39;</span>:
<a name="l00770"></a>00770           <span class="keywordflow">if</span> (just_seen_space || (just_seen_colon &gt; 1))
<a name="l00771"></a>00771             <span class="keywordflow">return</span> 0;           <span class="comment">/* nested class spec coming up */</span>
<a name="l00772"></a>00772           just_seen_colon++;    <span class="comment">/* we allow :: but not :::: */</span>
<a name="l00773"></a>00773           <span class="keywordflow">break</span>;
<a name="l00774"></a>00774         <span class="keywordflow">case</span> <span class="charliteral">&#39; &#39;</span>:
<a name="l00775"></a>00775           <span class="keywordflow">break</span>;
<a name="l00776"></a>00776         <span class="keywordflow">default</span>:
<a name="l00777"></a>00777           <span class="keywordflow">if</span> (!((*p &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;&amp; *p &lt;= <span class="charliteral">&#39;z&#39;</span>) ||     <span class="comment">/* allow token chars */</span>
<a name="l00778"></a>00778                 (*p &gt;= <span class="charliteral">&#39;A&#39;</span> &amp;&amp; *p &lt;= <span class="charliteral">&#39;Z&#39;</span>) ||
<a name="l00779"></a>00779                 (*p &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; *p &lt;= <span class="charliteral">&#39;9&#39;</span>) ||
<a name="l00780"></a>00780                 (*p == <span class="charliteral">&#39;_&#39;</span>) || (*p == <span class="charliteral">&#39;,&#39;</span>) ||   <span class="comment">/* commas for template args */</span>
<a name="l00781"></a>00781                 (*p == <span class="charliteral">&#39;&amp;&#39;</span>) || (*p == <span class="charliteral">&#39;*&#39;</span>) ||   <span class="comment">/* pointer and ref types */</span>
<a name="l00782"></a>00782                 (*p == <span class="charliteral">&#39;(&#39;</span>) || (*p == <span class="charliteral">&#39;)&#39;</span>) ||   <span class="comment">/* function types */</span>
<a name="l00783"></a>00783                 (*p == <span class="charliteral">&#39;[&#39;</span>) || (*p == <span class="charliteral">&#39;]&#39;</span>)))    <span class="comment">/* array types */</span>
<a name="l00784"></a>00784             <span class="keywordflow">return</span> 0;
<a name="l00785"></a>00785         }
<a name="l00786"></a>00786       <span class="keywordflow">if</span> (*p != <span class="charliteral">&#39; &#39;</span>)
<a name="l00787"></a>00787         just_seen_space = 0;
<a name="l00788"></a>00788       <span class="keywordflow">if</span> (*p != <span class="charliteral">&#39;:&#39;</span>)
<a name="l00789"></a>00789         just_seen_colon = 0;
<a name="l00790"></a>00790       <span class="keywordflow">if</span> (*p != <span class="charliteral">&#39;&gt;&#39;</span>)
<a name="l00791"></a>00791         just_seen_right = 0;
<a name="l00792"></a>00792     }
<a name="l00793"></a>00793   <span class="keywordflow">return</span> 0;
<a name="l00794"></a>00794 }
<a name="l00795"></a>00795 
<a name="l00796"></a>00796 
<a name="l00797"></a>00797 <span class="comment">/* Return a null-terminated temporary copy of the name of a string token.</span>
<a name="l00798"></a>00798 <span class="comment"></span>
<a name="l00799"></a>00799 <span class="comment">   Tokens that refer to names do so with explicit pointer and length,</span>
<a name="l00800"></a>00800 <span class="comment">   so they can share the storage that lexptr is parsing.</span>
<a name="l00801"></a>00801 <span class="comment">   When it is necessary to pass a name to a function that expects</span>
<a name="l00802"></a>00802 <span class="comment">   a null-terminated string, the substring is copied out</span>
<a name="l00803"></a>00803 <span class="comment">   into a separate block of storage.</span>
<a name="l00804"></a>00804 <span class="comment"></span>
<a name="l00805"></a>00805 <span class="comment">   N.B. A single buffer is reused on each call.  */</span>
<a name="l00806"></a>00806 
<a name="l00807"></a>00807 <span class="keywordtype">char</span> *
<a name="l00808"></a><a class="code" href="parser-defs_8h.html#a0632b44e2a6e44c5894c50fee93b59ae">00808</a> <a class="code" href="parse_8c.html#ae2c3f5e61c639d2b9821cbb548bbe10c">copy_name</a> (<span class="keyword">struct</span> <a class="code" href="structstoken.html">stoken</a> <a class="code" href="m2-exp_8c.html#a8abb7e972adc09624edab301e021dc5f">token</a>)
<a name="l00809"></a>00809 {
<a name="l00810"></a>00810   <span class="comment">/* A temporary buffer for identifiers, so we can null-terminate them.</span>
<a name="l00811"></a>00811 <span class="comment">     We allocate this with xrealloc.  parse_exp_1 used to allocate with</span>
<a name="l00812"></a>00812 <span class="comment">     alloca, using the size of the whole expression as a conservative</span>
<a name="l00813"></a>00813 <span class="comment">     estimate of the space needed.  However, macro expansion can</span>
<a name="l00814"></a>00814 <span class="comment">     introduce names longer than the original expression; there&#39;s no</span>
<a name="l00815"></a>00815 <span class="comment">     practical way to know beforehand how large that might be.  */</span>
<a name="l00816"></a>00816   <span class="keyword">static</span> <span class="keywordtype">char</span> *namecopy;
<a name="l00817"></a>00817   <span class="keyword">static</span> <span class="keywordtype">size_t</span> namecopy_size;
<a name="l00818"></a>00818 
<a name="l00819"></a>00819   <span class="comment">/* Make sure there&#39;s enough space for the token.  */</span>
<a name="l00820"></a>00820   <span class="keywordflow">if</span> (namecopy_size &lt; token.<a class="code" href="structstoken.html#a3b824e51aedbb867bf3e560fd9e05913">length</a> + 1)
<a name="l00821"></a>00821     {
<a name="l00822"></a>00822       namecopy_size = token.<a class="code" href="structstoken.html#a3b824e51aedbb867bf3e560fd9e05913">length</a> + 1;
<a name="l00823"></a>00823       namecopy = <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (namecopy, token.<a class="code" href="structstoken.html#a3b824e51aedbb867bf3e560fd9e05913">length</a> + 1);
<a name="l00824"></a>00824     }
<a name="l00825"></a>00825       
<a name="l00826"></a>00826   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (namecopy, token.<a class="code" href="structstoken.html#ae1c7b64f20fe8b3277827877ac961e90">ptr</a>, token.<a class="code" href="structstoken.html#a3b824e51aedbb867bf3e560fd9e05913">length</a>);
<a name="l00827"></a>00827   namecopy[token.<a class="code" href="structstoken.html#a3b824e51aedbb867bf3e560fd9e05913">length</a>] = 0;
<a name="l00828"></a>00828 
<a name="l00829"></a>00829   <span class="keywordflow">return</span> namecopy;
<a name="l00830"></a>00830 }
<a name="l00831"></a>00831 
<a name="l00832"></a>00832 
<a name="l00833"></a>00833 <span class="comment">/* See comments on parser-defs.h.  */</span>
<a name="l00834"></a>00834 
<a name="l00835"></a>00835 <span class="keywordtype">int</span>
<a name="l00836"></a><a class="code" href="parser-defs_8h.html#a67e1acfd759076996fae2ce8385d77b5">00836</a> <a class="code" href="parse_8c.html#a67e1acfd759076996fae2ce8385d77b5">prefixify_expression</a> (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *expr)
<a name="l00837"></a>00837 {
<a name="l00838"></a>00838   <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a> = <span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a>) + EXP_ELEM_TO_BYTES (expr-&gt;nelts);
<a name="l00839"></a>00839   <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *temp;
<a name="l00840"></a>00840   <span class="keywordtype">int</span> inpos = expr-&gt;<a class="code" href="structexpression.html#ad5e1dbc7e3732d94d29b8c3d61696123">nelts</a>, outpos = 0;
<a name="l00841"></a>00841 
<a name="l00842"></a>00842   temp = (<span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *) alloca (len);
<a name="l00843"></a>00843 
<a name="l00844"></a>00844   <span class="comment">/* Copy the original expression into temp.  */</span>
<a name="l00845"></a>00845   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (temp, expr, len);
<a name="l00846"></a>00846 
<a name="l00847"></a>00847   <span class="keywordflow">return</span> prefixify_subexp (temp, expr, inpos, outpos);
<a name="l00848"></a>00848 }
<a name="l00849"></a>00849 
<a name="l00850"></a>00850 <span class="comment">/* Return the number of exp_elements in the postfix subexpression </span>
<a name="l00851"></a>00851 <span class="comment">   of EXPR whose operator is at index ENDPOS - 1 in EXPR.  */</span>
<a name="l00852"></a>00852 
<a name="l00853"></a>00853 <span class="keywordtype">int</span>
<a name="l00854"></a><a class="code" href="parser-defs_8h.html#a75e224671917530298ddd719e38ad834">00854</a> <a class="code" href="parse_8c.html#a5fa672fb43d8810c29f337a785cfc067">length_of_subexp</a> (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *expr, <span class="keywordtype">int</span> endpos)
<a name="l00855"></a>00855 {
<a name="l00856"></a>00856   <span class="keywordtype">int</span> oplen, args;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858   <a class="code" href="parse_8c.html#a0c5c1cb429e3f2236be9a18e3629913c">operator_length </a>(expr, endpos, &amp;oplen, &amp;args);
<a name="l00859"></a>00859 
<a name="l00860"></a>00860   <span class="keywordflow">while</span> (args &gt; 0)
<a name="l00861"></a>00861     {
<a name="l00862"></a>00862       oplen += <a class="code" href="parse_8c.html#a5fa672fb43d8810c29f337a785cfc067">length_of_subexp</a> (expr, endpos - oplen);
<a name="l00863"></a>00863       args--;
<a name="l00864"></a>00864     }
<a name="l00865"></a>00865 
<a name="l00866"></a>00866   <span class="keywordflow">return</span> oplen;
<a name="l00867"></a>00867 }
<a name="l00868"></a>00868 
<a name="l00869"></a>00869 <span class="comment">/* Sets *OPLENP to the length of the operator whose (last) index is </span>
<a name="l00870"></a>00870 <span class="comment">   ENDPOS - 1 in EXPR, and sets *ARGSP to the number of arguments that</span>
<a name="l00871"></a>00871 <span class="comment">   operator takes.  */</span>
<a name="l00872"></a>00872 
<a name="l00873"></a>00873 <span class="keywordtype">void</span>
<a name="l00874"></a><a class="code" href="parser-defs_8h.html#a14ce6d77169b45e5d8f0f6407af6ea03">00874</a> <a class="code" href="parse_8c.html#a0c5c1cb429e3f2236be9a18e3629913c">operator_length </a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *expr, <span class="keywordtype">int</span> endpos, <span class="keywordtype">int</span> *oplenp,
<a name="l00875"></a>00875                  <span class="keywordtype">int</span> *argsp)
<a name="l00876"></a>00876 {
<a name="l00877"></a>00877   expr-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>-&gt;<a class="code" href="structlanguage__defn.html#a3879525090f7fa0b979218c0fd329015">la_exp_desc</a>-&gt;<a class="code" href="structexp__descriptor.html#a6b33d484fe3f35ff4f94fdd1fb3dd1bb">operator_length</a> (expr, endpos,
<a name="l00878"></a>00878                                                      oplenp, argsp);
<a name="l00879"></a>00879 }
<a name="l00880"></a>00880 
<a name="l00881"></a>00881 <span class="comment">/* Default value for operator_length in exp_descriptor vectors.  */</span>
<a name="l00882"></a>00882 
<a name="l00883"></a>00883 <span class="keywordtype">void</span>
<a name="l00884"></a><a class="code" href="parser-defs_8h.html#aa8dbd4ead27014951aa008f59a8aaa3c">00884</a> <a class="code" href="parse_8c.html#a63b798abb9b9b89ab5f422b1d5c1d16f">operator_length_standard </a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *expr, <span class="keywordtype">int</span> endpos,
<a name="l00885"></a>00885                           <span class="keywordtype">int</span> *oplenp, <span class="keywordtype">int</span> *argsp)
<a name="l00886"></a>00886 {
<a name="l00887"></a>00887   <span class="keywordtype">int</span> oplen = 1;
<a name="l00888"></a>00888   <span class="keywordtype">int</span> args = 0;
<a name="l00889"></a>00889   <span class="keyword">enum</span> <a class="code" href="f-lang_8h.html#aeab7a2a6ecf04ca2839e7a2150ad2491">f90_range_type</a> range_type;
<a name="l00890"></a>00890   <span class="keywordtype">int</span> i;
<a name="l00891"></a>00891 
<a name="l00892"></a>00892   <span class="keywordflow">if</span> (endpos &lt; 1)
<a name="l00893"></a>00893     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;?error in operator_length_standard&quot;</span>));
<a name="l00894"></a>00894 
<a name="l00895"></a>00895   i = (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>) expr-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[endpos - 1].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a>;
<a name="l00896"></a>00896 
<a name="l00897"></a>00897   switch (i)
<a name="l00898"></a>00898     {
<a name="l00899"></a>00899       <span class="comment">/* C++  */</span>
<a name="l00900"></a>00900     <span class="keywordflow">case</span> OP_SCOPE:
<a name="l00901"></a>00901       oplen = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (expr-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[endpos - 2].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l00902"></a>00902       oplen = 5 + <a class="code" href="expression_8h.html#a8a1be157bb41aa92434ac6ce0e0fcf78">BYTES_TO_EXP_ELEM</a> (oplen + 1);
<a name="l00903"></a>00903       <span class="keywordflow">break</span>;
<a name="l00904"></a>00904 
<a name="l00905"></a>00905     <span class="keywordflow">case</span> OP_LONG:
<a name="l00906"></a>00906     <span class="keywordflow">case</span> OP_DOUBLE:
<a name="l00907"></a>00907     <span class="keywordflow">case</span> OP_DECFLOAT:
<a name="l00908"></a>00908     <span class="keywordflow">case</span> OP_VAR_VALUE:
<a name="l00909"></a>00909       oplen = 4;
<a name="l00910"></a>00910       <span class="keywordflow">break</span>;
<a name="l00911"></a>00911 
<a name="l00912"></a>00912     <span class="keywordflow">case</span> OP_TYPE:
<a name="l00913"></a>00913     <span class="keywordflow">case</span> OP_BOOL:
<a name="l00914"></a>00914     <span class="keywordflow">case</span> OP_LAST:
<a name="l00915"></a>00915     <span class="keywordflow">case</span> OP_INTERNALVAR:
<a name="l00916"></a>00916     <span class="keywordflow">case</span> OP_VAR_ENTRY_VALUE:
<a name="l00917"></a>00917       oplen = 3;
<a name="l00918"></a>00918       <span class="keywordflow">break</span>;
<a name="l00919"></a>00919 
<a name="l00920"></a>00920     <span class="keywordflow">case</span> OP_COMPLEX:
<a name="l00921"></a>00921       oplen = 3;
<a name="l00922"></a>00922       args = 2;
<a name="l00923"></a>00923       <span class="keywordflow">break</span>;
<a name="l00924"></a>00924 
<a name="l00925"></a>00925     <span class="keywordflow">case</span> OP_FUNCALL:
<a name="l00926"></a>00926     <span class="keywordflow">case</span> OP_F77_UNDETERMINED_ARGLIST:
<a name="l00927"></a>00927       oplen = 3;
<a name="l00928"></a>00928       args = 1 + <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (expr-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[endpos - 2].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l00929"></a>00929       <span class="keywordflow">break</span>;
<a name="l00930"></a>00930 
<a name="l00931"></a>00931     <span class="keywordflow">case</span> TYPE_INSTANCE:
<a name="l00932"></a>00932       oplen = 4 + <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (expr-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[endpos - 2].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l00933"></a>00933       args = 1;
<a name="l00934"></a>00934       <span class="keywordflow">break</span>;
<a name="l00935"></a>00935 
<a name="l00936"></a>00936     <span class="keywordflow">case</span> OP_OBJC_MSGCALL:       <span class="comment">/* Objective C message (method) call.  */</span>
<a name="l00937"></a>00937       oplen = 4;
<a name="l00938"></a>00938       args = 1 + <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (expr-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[endpos - 2].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l00939"></a>00939       <span class="keywordflow">break</span>;
<a name="l00940"></a>00940 
<a name="l00941"></a>00941     <span class="keywordflow">case</span> UNOP_MAX:
<a name="l00942"></a>00942     <span class="keywordflow">case</span> UNOP_MIN:
<a name="l00943"></a>00943       oplen = 3;
<a name="l00944"></a>00944       <span class="keywordflow">break</span>;
<a name="l00945"></a>00945 
<a name="l00946"></a>00946     <span class="keywordflow">case</span> UNOP_CAST_TYPE:
<a name="l00947"></a>00947     <span class="keywordflow">case</span> UNOP_DYNAMIC_CAST:
<a name="l00948"></a>00948     <span class="keywordflow">case</span> UNOP_REINTERPRET_CAST:
<a name="l00949"></a>00949     <span class="keywordflow">case</span> UNOP_MEMVAL_TYPE:
<a name="l00950"></a>00950       oplen = 1;
<a name="l00951"></a>00951       args = 2;
<a name="l00952"></a>00952       <span class="keywordflow">break</span>;
<a name="l00953"></a>00953 
<a name="l00954"></a>00954     <span class="keywordflow">case</span> BINOP_VAL:
<a name="l00955"></a>00955     <span class="keywordflow">case</span> UNOP_CAST:
<a name="l00956"></a>00956     <span class="keywordflow">case</span> UNOP_MEMVAL:
<a name="l00957"></a>00957       oplen = 3;
<a name="l00958"></a>00958       args = 1;
<a name="l00959"></a>00959       <span class="keywordflow">break</span>;
<a name="l00960"></a>00960 
<a name="l00961"></a>00961     <span class="keywordflow">case</span> UNOP_MEMVAL_TLS:
<a name="l00962"></a>00962       oplen = 4;
<a name="l00963"></a>00963       args = 1;
<a name="l00964"></a>00964       <span class="keywordflow">break</span>;
<a name="l00965"></a>00965 
<a name="l00966"></a>00966     <span class="keywordflow">case</span> UNOP_ABS:
<a name="l00967"></a>00967     <span class="keywordflow">case</span> UNOP_CAP:
<a name="l00968"></a>00968     <span class="keywordflow">case</span> UNOP_CHR:
<a name="l00969"></a>00969     <span class="keywordflow">case</span> UNOP_FLOAT:
<a name="l00970"></a>00970     <span class="keywordflow">case</span> UNOP_HIGH:
<a name="l00971"></a>00971     <span class="keywordflow">case</span> UNOP_ODD:
<a name="l00972"></a>00972     <span class="keywordflow">case</span> UNOP_ORD:
<a name="l00973"></a>00973     <span class="keywordflow">case</span> UNOP_TRUNC:
<a name="l00974"></a>00974     <span class="keywordflow">case</span> OP_TYPEOF:
<a name="l00975"></a>00975     <span class="keywordflow">case</span> OP_DECLTYPE:
<a name="l00976"></a>00976     <span class="keywordflow">case</span> OP_TYPEID:
<a name="l00977"></a>00977       oplen = 1;
<a name="l00978"></a>00978       args = 1;
<a name="l00979"></a>00979       <span class="keywordflow">break</span>;
<a name="l00980"></a>00980 
<a name="l00981"></a>00981     <span class="keywordflow">case</span> OP_ADL_FUNC:
<a name="l00982"></a>00982       oplen = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (expr-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[endpos - 2].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l00983"></a>00983       oplen = 4 + <a class="code" href="expression_8h.html#a8a1be157bb41aa92434ac6ce0e0fcf78">BYTES_TO_EXP_ELEM</a> (oplen + 1);
<a name="l00984"></a>00984       oplen++;
<a name="l00985"></a>00985       oplen++;
<a name="l00986"></a>00986       <span class="keywordflow">break</span>;
<a name="l00987"></a>00987 
<a name="l00988"></a>00988     <span class="keywordflow">case</span> STRUCTOP_STRUCT:
<a name="l00989"></a>00989     <span class="keywordflow">case</span> STRUCTOP_PTR:
<a name="l00990"></a>00990       args = 1;
<a name="l00991"></a>00991       <span class="comment">/* fall through */</span>
<a name="l00992"></a>00992     <span class="keywordflow">case</span> OP_REGISTER:
<a name="l00993"></a>00993     <span class="keywordflow">case</span> OP_M2_STRING:
<a name="l00994"></a>00994     <span class="keywordflow">case</span> OP_STRING:
<a name="l00995"></a>00995     <span class="keywordflow">case</span> OP_OBJC_NSSTRING:      <span class="comment">/* Objective C Foundation Class</span>
<a name="l00996"></a>00996 <span class="comment">                                   NSString constant.  */</span>
<a name="l00997"></a>00997     <span class="keywordflow">case</span> OP_OBJC_SELECTOR:      <span class="comment">/* Objective C &quot;@selector&quot; pseudo-op.  */</span>
<a name="l00998"></a>00998     <span class="keywordflow">case</span> OP_NAME:
<a name="l00999"></a>00999       oplen = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (expr-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[endpos - 2].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l01000"></a>01000       oplen = 4 + <a class="code" href="expression_8h.html#a8a1be157bb41aa92434ac6ce0e0fcf78">BYTES_TO_EXP_ELEM</a> (oplen + 1);
<a name="l01001"></a>01001       <span class="keywordflow">break</span>;
<a name="l01002"></a>01002 
<a name="l01003"></a>01003     <span class="keywordflow">case</span> OP_ARRAY:
<a name="l01004"></a>01004       oplen = 4;
<a name="l01005"></a>01005       args = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (expr-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[endpos - 2].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l01006"></a>01006       args -= <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (expr-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[endpos - 3].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l01007"></a>01007       args += 1;
<a name="l01008"></a>01008       <span class="keywordflow">break</span>;
<a name="l01009"></a>01009 
<a name="l01010"></a>01010     <span class="keywordflow">case</span> TERNOP_COND:
<a name="l01011"></a>01011     <span class="keywordflow">case</span> TERNOP_SLICE:
<a name="l01012"></a>01012       args = 3;
<a name="l01013"></a>01013       <span class="keywordflow">break</span>;
<a name="l01014"></a>01014 
<a name="l01015"></a>01015       <span class="comment">/* Modula-2 */</span>
<a name="l01016"></a>01016     <span class="keywordflow">case</span> MULTI_SUBSCRIPT:
<a name="l01017"></a>01017       oplen = 3;
<a name="l01018"></a>01018       args = 1 + <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (expr-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[endpos - 2].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l01019"></a>01019       <span class="keywordflow">break</span>;
<a name="l01020"></a>01020 
<a name="l01021"></a>01021     <span class="keywordflow">case</span> BINOP_ASSIGN_MODIFY:
<a name="l01022"></a>01022       oplen = 3;
<a name="l01023"></a>01023       args = 2;
<a name="l01024"></a>01024       <span class="keywordflow">break</span>;
<a name="l01025"></a>01025 
<a name="l01026"></a>01026       <span class="comment">/* C++ */</span>
<a name="l01027"></a>01027     <span class="keywordflow">case</span> OP_THIS:
<a name="l01028"></a>01028       oplen = 2;
<a name="l01029"></a>01029       <span class="keywordflow">break</span>;
<a name="l01030"></a>01030 
<a name="l01031"></a>01031     <span class="keywordflow">case</span> OP_F90_RANGE:
<a name="l01032"></a>01032       oplen = 3;
<a name="l01033"></a>01033 
<a name="l01034"></a>01034       range_type = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (expr-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[endpos - 2].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l01035"></a>01035       <span class="keywordflow">switch</span> (range_type)
<a name="l01036"></a>01036         {
<a name="l01037"></a>01037         <span class="keywordflow">case</span> <a class="code" href="f-lang_8h.html#aeab7a2a6ecf04ca2839e7a2150ad2491a93996e3c3fbe40c2d983939ea7c5cbad">LOW_BOUND_DEFAULT</a>:
<a name="l01038"></a>01038         <span class="keywordflow">case</span> <a class="code" href="f-lang_8h.html#aeab7a2a6ecf04ca2839e7a2150ad2491a9599ea8b1d95f08659e7fc6c9dea87d1">HIGH_BOUND_DEFAULT</a>:
<a name="l01039"></a>01039           args = 1;
<a name="l01040"></a>01040           <span class="keywordflow">break</span>;
<a name="l01041"></a>01041         <span class="keywordflow">case</span> <a class="code" href="f-lang_8h.html#aeab7a2a6ecf04ca2839e7a2150ad2491afed1548c93597bd7f5f2496b4764d7df">BOTH_BOUND_DEFAULT</a>:
<a name="l01042"></a>01042           args = 0;
<a name="l01043"></a>01043           <span class="keywordflow">break</span>;
<a name="l01044"></a>01044         <span class="keywordflow">case</span> <a class="code" href="f-lang_8h.html#aeab7a2a6ecf04ca2839e7a2150ad2491a791bb4ac6b5a32a414ee364c2bcf9b91">NONE_BOUND_DEFAULT</a>:
<a name="l01045"></a>01045           args = 2;
<a name="l01046"></a>01046           <span class="keywordflow">break</span>;
<a name="l01047"></a>01047         }
<a name="l01048"></a>01048 
<a name="l01049"></a>01049       <span class="keywordflow">break</span>;
<a name="l01050"></a>01050 
<a name="l01051"></a>01051     <span class="keywordflow">default</span>:
<a name="l01052"></a>01052       args = 1 + (i &lt; (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>) BINOP_END);
<a name="l01053"></a>01053     }
<a name="l01054"></a>01054 
<a name="l01055"></a>01055   *oplenp = oplen;
<a name="l01056"></a>01056   *argsp = args;
<a name="l01057"></a>01057 }
<a name="l01058"></a>01058 
<a name="l01059"></a>01059 <span class="comment">/* Copy the subexpression ending just before index INEND in INEXPR</span>
<a name="l01060"></a>01060 <span class="comment">   into OUTEXPR, starting at index OUTBEG.</span>
<a name="l01061"></a>01061 <span class="comment">   In the process, convert it from suffix to prefix form.</span>
<a name="l01062"></a>01062 <span class="comment">   If EXPOUT_LAST_STRUCT is -1, then this function always returns -1.</span>
<a name="l01063"></a>01063 <span class="comment">   Otherwise, it returns the index of the subexpression which is the</span>
<a name="l01064"></a>01064 <span class="comment">   left-hand-side of the expression at EXPOUT_LAST_STRUCT.  */</span>
<a name="l01065"></a>01065 
<a name="l01066"></a>01066 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01067"></a>01067 prefixify_subexp (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *inexpr,
<a name="l01068"></a>01068                   <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *outexpr, <span class="keywordtype">int</span> inend, <span class="keywordtype">int</span> outbeg)
<a name="l01069"></a>01069 {
<a name="l01070"></a>01070   <span class="keywordtype">int</span> oplen;
<a name="l01071"></a>01071   <span class="keywordtype">int</span> args;
<a name="l01072"></a>01072   <span class="keywordtype">int</span> i;
<a name="l01073"></a>01073   <span class="keywordtype">int</span> *arglens;
<a name="l01074"></a>01074   <span class="keywordtype">int</span> result = -1;
<a name="l01075"></a>01075 
<a name="l01076"></a>01076   <a class="code" href="parse_8c.html#a0c5c1cb429e3f2236be9a18e3629913c">operator_length </a>(inexpr, inend, &amp;oplen, &amp;args);
<a name="l01077"></a>01077 
<a name="l01078"></a>01078   <span class="comment">/* Copy the final operator itself, from the end of the input</span>
<a name="l01079"></a>01079 <span class="comment">     to the beginning of the output.  */</span>
<a name="l01080"></a>01080   inend -= oplen;
<a name="l01081"></a>01081   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (&amp;outexpr-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[outbeg], &amp;inexpr-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[inend],
<a name="l01082"></a>01082           <a class="code" href="expression_8h.html#a0c3bd719efe17f3c1df1fe790f4ffd0d">EXP_ELEM_TO_BYTES</a> (oplen));
<a name="l01083"></a>01083   outbeg += oplen;
<a name="l01084"></a>01084 
<a name="l01085"></a>01085   <span class="keywordflow">if</span> (expout_last_struct == inend)
<a name="l01086"></a>01086     result = outbeg - oplen;
<a name="l01087"></a>01087 
<a name="l01088"></a>01088   <span class="comment">/* Find the lengths of the arg subexpressions.  */</span>
<a name="l01089"></a>01089   arglens = (<span class="keywordtype">int</span> *) alloca (args * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));
<a name="l01090"></a>01090   <span class="keywordflow">for</span> (i = args - 1; i &gt;= 0; i--)
<a name="l01091"></a>01091     {
<a name="l01092"></a>01092       oplen = <a class="code" href="parse_8c.html#a5fa672fb43d8810c29f337a785cfc067">length_of_subexp</a> (inexpr, inend);
<a name="l01093"></a>01093       arglens[i] = oplen;
<a name="l01094"></a>01094       inend -= oplen;
<a name="l01095"></a>01095     }
<a name="l01096"></a>01096 
<a name="l01097"></a>01097   <span class="comment">/* Now copy each subexpression, preserving the order of</span>
<a name="l01098"></a>01098 <span class="comment">     the subexpressions, but prefixifying each one.</span>
<a name="l01099"></a>01099 <span class="comment">     In this loop, inend starts at the beginning of</span>
<a name="l01100"></a>01100 <span class="comment">     the expression this level is working on</span>
<a name="l01101"></a>01101 <span class="comment">     and marches forward over the arguments.</span>
<a name="l01102"></a>01102 <span class="comment">     outbeg does similarly in the output.  */</span>
<a name="l01103"></a>01103   <span class="keywordflow">for</span> (i = 0; i &lt; args; i++)
<a name="l01104"></a>01104     {
<a name="l01105"></a>01105       <span class="keywordtype">int</span> r;
<a name="l01106"></a>01106 
<a name="l01107"></a>01107       oplen = arglens[i];
<a name="l01108"></a>01108       inend += oplen;
<a name="l01109"></a>01109       r = prefixify_subexp (inexpr, outexpr, inend, outbeg);
<a name="l01110"></a>01110       <span class="keywordflow">if</span> (r != -1)
<a name="l01111"></a>01111         {
<a name="l01112"></a>01112           <span class="comment">/* Return immediately.  We probably have only parsed a</span>
<a name="l01113"></a>01113 <span class="comment">             partial expression, so we don&#39;t want to try to reverse</span>
<a name="l01114"></a>01114 <span class="comment">             the other operands.  */</span>
<a name="l01115"></a>01115           <span class="keywordflow">return</span> r;
<a name="l01116"></a>01116         }
<a name="l01117"></a>01117       outbeg += oplen;
<a name="l01118"></a>01118     }
<a name="l01119"></a>01119 
<a name="l01120"></a>01120   <span class="keywordflow">return</span> result;
<a name="l01121"></a>01121 }
<a name="l01122"></a>01122 
<a name="l01123"></a>01123 <span class="comment">/* Read an expression from the string *STRINGPTR points to,</span>
<a name="l01124"></a>01124 <span class="comment">   parse it, and return a pointer to a struct expression that we malloc.</span>
<a name="l01125"></a>01125 <span class="comment">   Use block BLOCK as the lexical context for variable names;</span>
<a name="l01126"></a>01126 <span class="comment">   if BLOCK is zero, use the block of the selected stack frame.</span>
<a name="l01127"></a>01127 <span class="comment">   Meanwhile, advance *STRINGPTR to point after the expression,</span>
<a name="l01128"></a>01128 <span class="comment">   at the first nonwhite character that is not part of the expression</span>
<a name="l01129"></a>01129 <span class="comment">   (possibly a null character).</span>
<a name="l01130"></a>01130 <span class="comment"></span>
<a name="l01131"></a>01131 <span class="comment">   If COMMA is nonzero, stop if a comma is reached.  */</span>
<a name="l01132"></a>01132 
<a name="l01133"></a>01133 <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *
<a name="l01134"></a><a class="code" href="parse_8c.html#ae07a6a934a641af225e1e9aaea4cbd91">01134</a> <a class="code" href="expression_8h.html#abdad295cc4b5351f6e6ec024ab665475">parse_exp_1</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> **stringptr, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>,
<a name="l01135"></a>01135              <span class="keywordtype">int</span> comma)
<a name="l01136"></a>01136 {
<a name="l01137"></a>01137   <span class="keywordflow">return</span> parse_exp_in_context (stringptr, pc, block, comma, 0, NULL);
<a name="l01138"></a>01138 }
<a name="l01139"></a>01139 
<a name="l01140"></a>01140 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *
<a name="l01141"></a>01141 parse_exp_in_context (<span class="keyword">const</span> <span class="keywordtype">char</span> **stringptr, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc,
<a name="l01142"></a>01142                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>,
<a name="l01143"></a>01143                       <span class="keywordtype">int</span> comma, <span class="keywordtype">int</span> void_context_p, <span class="keywordtype">int</span> *out_subexp)
<a name="l01144"></a>01144 {
<a name="l01145"></a>01145   <span class="keywordflow">return</span> parse_exp_in_context_1 (stringptr, pc, block, comma,
<a name="l01146"></a>01146                                  void_context_p, out_subexp);
<a name="l01147"></a>01147 }
<a name="l01148"></a>01148 
<a name="l01149"></a>01149 <span class="comment">/* As for parse_exp_1, except that if VOID_CONTEXT_P, then</span>
<a name="l01150"></a>01150 <span class="comment">   no value is expected from the expression.</span>
<a name="l01151"></a>01151 <span class="comment">   OUT_SUBEXP is set when attempting to complete a field name; in this</span>
<a name="l01152"></a>01152 <span class="comment">   case it is set to the index of the subexpression on the</span>
<a name="l01153"></a>01153 <span class="comment">   left-hand-side of the struct op.  If not doing such completion, it</span>
<a name="l01154"></a>01154 <span class="comment">   is left untouched.  */</span>
<a name="l01155"></a>01155 
<a name="l01156"></a>01156 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *
<a name="l01157"></a>01157 parse_exp_in_context_1 (<span class="keyword">const</span> <span class="keywordtype">char</span> **stringptr, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc,
<a name="l01158"></a>01158                         <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>,
<a name="l01159"></a>01159                         <span class="keywordtype">int</span> comma, <span class="keywordtype">int</span> void_context_p, <span class="keywordtype">int</span> *out_subexp)
<a name="l01160"></a>01160 {
<a name="l01161"></a>01161   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> except;
<a name="l01162"></a>01162   <span class="keyword">struct </span>cleanup *old_chain, *inner_chain;
<a name="l01163"></a>01163   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlanguage__defn.html">language_defn</a> *lang = NULL;
<a name="l01164"></a>01164   <span class="keywordtype">int</span> subexp;
<a name="l01165"></a>01165 
<a name="l01166"></a>01166   <a class="code" href="parse_8c.html#af6623656a3ce409076adb197314172e2">lexptr</a> = *stringptr;
<a name="l01167"></a>01167   <a class="code" href="parse_8c.html#aff224611563d397a490b23bdb581c11b">prev_lexptr</a> = NULL;
<a name="l01168"></a>01168 
<a name="l01169"></a>01169   <a class="code" href="parse_8c.html#a931a02e52cc8d96b0e353f0659c6ef7b">paren_depth</a> = 0;
<a name="l01170"></a>01170   <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a> = 0;
<a name="l01171"></a>01171   expout_last_struct = -1;
<a name="l01172"></a>01172   expout_tag_completion_type = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ac0ed09886a958d1a94646893440004a8">TYPE_CODE_UNDEF</a>;
<a name="l01173"></a>01173   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (expout_completion_name);
<a name="l01174"></a>01174   expout_completion_name = NULL;
<a name="l01175"></a>01175 
<a name="l01176"></a>01176   <a class="code" href="parse_8c.html#adae301d904eeea4bfe269ac71990d05e">comma_terminates</a> = comma;
<a name="l01177"></a>01177 
<a name="l01178"></a>01178   <span class="keywordflow">if</span> (<a class="code" href="parse_8c.html#af6623656a3ce409076adb197314172e2">lexptr</a> == 0 || *<a class="code" href="parse_8c.html#af6623656a3ce409076adb197314172e2">lexptr</a> == 0)
<a name="l01179"></a>01179     <a class="code" href="cli-cmds_8c.html#a68aef78cdf72abc9df2495a4618842c3">error_no_arg</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;expression to compute&quot;</span>));
<a name="l01180"></a>01180 
<a name="l01181"></a>01181   old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (free_funcalls, 0 <span class="comment">/*ignore*/</span>);
<a name="l01182"></a>01182   funcall_chain = 0;
<a name="l01183"></a>01183 
<a name="l01184"></a>01184   expression_context_block = block;
<a name="l01185"></a>01185 
<a name="l01186"></a>01186   <span class="comment">/* If no context specified, try using the current frame, if any.  */</span>
<a name="l01187"></a>01187   <span class="keywordflow">if</span> (!expression_context_block)
<a name="l01188"></a>01188     expression_context_block = <a class="code" href="frame_8h.html#a91efbdcf182d840c28d378def97cfc23">get_selected_block</a> (&amp;<a class="code" href="parse_8c.html#a811508c86cb88db3a7f9e1cabb9588c4">expression_context_pc</a>);
<a name="l01189"></a>01189   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pc == 0)
<a name="l01190"></a>01190     <a class="code" href="parse_8c.html#a811508c86cb88db3a7f9e1cabb9588c4">expression_context_pc</a> = <a class="code" href="block_8h.html#a08fdff319bcd75e92b61c79139592af6">BLOCK_START</a> (expression_context_block);
<a name="l01191"></a>01191   <span class="keywordflow">else</span>
<a name="l01192"></a>01192     <a class="code" href="parse_8c.html#a811508c86cb88db3a7f9e1cabb9588c4">expression_context_pc</a> = pc;
<a name="l01193"></a>01193 
<a name="l01194"></a>01194   <span class="comment">/* Fall back to using the current source static context, if any.  */</span>
<a name="l01195"></a>01195 
<a name="l01196"></a>01196   <span class="keywordflow">if</span> (!expression_context_block)
<a name="l01197"></a>01197     {
<a name="l01198"></a>01198       <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a> cursal = <a class="code" href="source_8c.html#a387b0906b103c4b3dec9d7cfdd41a9ad">get_current_source_symtab_and_line</a> ();
<a name="l01199"></a>01199       <span class="keywordflow">if</span> (cursal.<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a>)
<a name="l01200"></a>01200         expression_context_block
<a name="l01201"></a>01201           = <a class="code" href="block_8h.html#a84c4a3aa7b6b4d9a127a1c018dd6a776">BLOCKVECTOR_BLOCK</a> (<a class="code" href="symtab_8h.html#a6cd84410d73680ff8006ac44b1b98a9c">BLOCKVECTOR</a> (cursal.<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a>), <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124a4842990ca5391ee943c2069b28443a99">STATIC_BLOCK</a>);
<a name="l01202"></a>01202       <span class="keywordflow">if</span> (expression_context_block)
<a name="l01203"></a>01203         <a class="code" href="parse_8c.html#a811508c86cb88db3a7f9e1cabb9588c4">expression_context_pc</a> = <a class="code" href="block_8h.html#a08fdff319bcd75e92b61c79139592af6">BLOCK_START</a> (expression_context_block);
<a name="l01204"></a>01204     }
<a name="l01205"></a>01205 
<a name="l01206"></a>01206   <span class="keywordflow">if</span> (<a class="code" href="language_8h.html#ae32fb3eb29743dbdbc197316b4b83f4e">language_mode</a> == <a class="code" href="language_8h.html#ae32fb3eb29743dbdbc197316b4b83f4ea45a4096e956feff249efbb38f3be6c7e">language_mode_auto</a> &amp;&amp; block != NULL)
<a name="l01207"></a>01207     {
<a name="l01208"></a>01208       <span class="comment">/* Find the language associated to the given context block.</span>
<a name="l01209"></a>01209 <span class="comment">         Default to the current language if it can not be determined.</span>
<a name="l01210"></a>01210 <span class="comment"></span>
<a name="l01211"></a>01211 <span class="comment">         Note that using the language corresponding to the current frame</span>
<a name="l01212"></a>01212 <span class="comment">         can sometimes give unexpected results.  For instance, this</span>
<a name="l01213"></a>01213 <span class="comment">         routine is often called several times during the inferior</span>
<a name="l01214"></a>01214 <span class="comment">         startup phase to re-parse breakpoint expressions after</span>
<a name="l01215"></a>01215 <span class="comment">         a new shared library has been loaded.  The language associated</span>
<a name="l01216"></a>01216 <span class="comment">         to the current frame at this moment is not relevant for</span>
<a name="l01217"></a>01217 <span class="comment">         the breakpoint.  Using it would therefore be silly, so it seems</span>
<a name="l01218"></a>01218 <span class="comment">         better to rely on the current language rather than relying on</span>
<a name="l01219"></a>01219 <span class="comment">         the current frame language to parse the expression.  That&#39;s why</span>
<a name="l01220"></a>01220 <span class="comment">         we do the following language detection only if the context block</span>
<a name="l01221"></a>01221 <span class="comment">         has been specifically provided.  */</span>
<a name="l01222"></a>01222       <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a> = <a class="code" href="block_8c.html#a79d1eee3f8ad664338ecfcccf6e5d2a0">block_linkage_function</a> (block);
<a name="l01223"></a>01223 
<a name="l01224"></a>01224       <span class="keywordflow">if</span> (func != NULL)
<a name="l01225"></a>01225         lang = <a class="code" href="language_8c.html#adba6bd079cb2f1df763354ec97abe0cd">language_def</a> (<a class="code" href="symtab_8h.html#a82fc22e60b1007c826a5ebf7d6593e78">SYMBOL_LANGUAGE</a> (func));
<a name="l01226"></a>01226       <span class="keywordflow">if</span> (lang == NULL || lang-&gt;<a class="code" href="structlanguage__defn.html#a1395b7eb05a09e5798dc29257f30810a">la_language</a> == <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a3082c2da456a8ca3aa34f721de2c3565">language_unknown</a>)
<a name="l01227"></a>01227         lang = <a class="code" href="language_8c.html#acd2505a014a95629da9c836f8914fc79">current_language</a>;
<a name="l01228"></a>01228     }
<a name="l01229"></a>01229   <span class="keywordflow">else</span>
<a name="l01230"></a>01230     lang = <a class="code" href="language_8c.html#acd2505a014a95629da9c836f8914fc79">current_language</a>;
<a name="l01231"></a>01231 
<a name="l01232"></a>01232   <span class="comment">/* get_current_arch may reset CURRENT_LANGUAGE via select_frame.</span>
<a name="l01233"></a>01233 <span class="comment">     While we need CURRENT_LANGUAGE to be set to LANG (for lookup_symbol</span>
<a name="l01234"></a>01234 <span class="comment">     and others called from *.y) ensure CURRENT_LANGUAGE gets restored</span>
<a name="l01235"></a>01235 <span class="comment">     to the value matching SELECTED_FRAME as set by get_current_arch.  */</span>
<a name="l01236"></a>01236   <a class="code" href="parse_8c.html#ab607e77af18b398c64054bbf723c59b1">initialize_expout</a> (10, lang, <a class="code" href="arch-utils_8c.html#a0fe1e68475f442e5d6dda589e0c62454">get_current_arch</a> ());
<a name="l01237"></a>01237   inner_chain = <a class="code" href="utils_8c.html#a1c069ceda71920d79c7ed36cc9a0f91d">make_cleanup_restore_current_language</a> ();
<a name="l01238"></a>01238   <a class="code" href="language_8c.html#a87176c846a3ec717ada5e5622fe18550">set_language</a> (lang-&gt;<a class="code" href="structlanguage__defn.html#a1395b7eb05a09e5798dc29257f30810a">la_language</a>);
<a name="l01239"></a>01239 
<a name="l01240"></a>01240   <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6ab50fde886a7de8c013bf2bd4e7c073a4">RETURN_MASK_ALL</a>)
<a name="l01241"></a>01241     {
<a name="l01242"></a>01242       <span class="keywordflow">if</span> (lang-&gt;<a class="code" href="structlanguage__defn.html#aade06882132927cb6456d34a8aace273">la_parser</a> ())
<a name="l01243"></a>01243         lang-&gt;<a class="code" href="structlanguage__defn.html#a5849368695891bb2e5ea7e7cde472637">la_error</a> (NULL);
<a name="l01244"></a>01244     }
<a name="l01245"></a>01245   <span class="keywordflow">if</span> (except.reason &lt; 0)
<a name="l01246"></a>01246     {
<a name="l01247"></a>01247       <span class="keywordflow">if</span> (! <a class="code" href="expression_8h.html#a7cdba29abd014ae348e7a95cb9fb5aff">parse_completion</a>)
<a name="l01248"></a>01248         {
<a name="l01249"></a>01249           <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (expout);
<a name="l01250"></a>01250           <a class="code" href="exceptions_8c.html#a541d1b545da68efe4f8b729a945f83e7">throw_exception</a> (except);
<a name="l01251"></a>01251         }
<a name="l01252"></a>01252     }
<a name="l01253"></a>01253 
<a name="l01254"></a>01254   <a class="code" href="parse_8c.html#a9293197f4dcc544f9d707c0cce399bcf">reallocate_expout</a> ();
<a name="l01255"></a>01255 
<a name="l01256"></a>01256   <span class="comment">/* Convert expression from postfix form as generated by yacc</span>
<a name="l01257"></a>01257 <span class="comment">     parser, to a prefix form.  */</span>
<a name="l01258"></a>01258 
<a name="l01259"></a>01259   <span class="keywordflow">if</span> (expressiondebug)
<a name="l01260"></a>01260     <a class="code" href="expprint_8c.html#a62b5b6342c85fb34efc2577536bca09e">dump_raw_expression</a> (expout, <a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l01261"></a>01261                          <span class="stringliteral">&quot;before conversion to prefix form&quot;</span>);
<a name="l01262"></a>01262 
<a name="l01263"></a>01263   subexp = <a class="code" href="parse_8c.html#a67e1acfd759076996fae2ce8385d77b5">prefixify_expression</a> (expout);
<a name="l01264"></a>01264   <span class="keywordflow">if</span> (out_subexp)
<a name="l01265"></a>01265     *out_subexp = subexp;
<a name="l01266"></a>01266 
<a name="l01267"></a>01267   lang-&gt;<a class="code" href="structlanguage__defn.html#af11bc6ed2ffbaf614e3f3cc0de5efa2b">la_post_parser</a> (&amp;expout, void_context_p);
<a name="l01268"></a>01268 
<a name="l01269"></a>01269   <span class="keywordflow">if</span> (expressiondebug)
<a name="l01270"></a>01270     <a class="code" href="expprint_8c.html#a99d103eb0b9ece100471afedd2e95b16">dump_prefix_expression</a> (expout, <a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>);
<a name="l01271"></a>01271 
<a name="l01272"></a>01272   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (inner_chain);
<a name="l01273"></a>01273   <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (old_chain);
<a name="l01274"></a>01274 
<a name="l01275"></a>01275   *stringptr = <a class="code" href="parse_8c.html#af6623656a3ce409076adb197314172e2">lexptr</a>;
<a name="l01276"></a>01276   <span class="keywordflow">return</span> <a class="code" href="parse_8c.html#a7c6040b4038ada3eebe2f1168c13b965">expout</a>;
<a name="l01277"></a>01277 }
<a name="l01278"></a>01278 
<a name="l01279"></a>01279 <span class="comment">/* Parse STRING as an expression, and complain if this fails</span>
<a name="l01280"></a>01280 <span class="comment">   to use up all of the contents of STRING.  */</span>
<a name="l01281"></a>01281 
<a name="l01282"></a>01282 <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *
<a name="l01283"></a><a class="code" href="parse_8c.html#a41e54a18a90631624dcdb2199dc7e6b6">01283</a> <a class="code" href="expression_8h.html#a286599225dbfecf78c83d1eb5261f25a">parse_expression</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>)
<a name="l01284"></a>01284 {
<a name="l01285"></a>01285   <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *exp;
<a name="l01286"></a>01286 
<a name="l01287"></a>01287   exp = <a class="code" href="expression_8h.html#abdad295cc4b5351f6e6ec024ab665475">parse_exp_1</a> (&amp;<span class="keywordtype">string</span>, 0, 0, 0);
<a name="l01288"></a>01288   <span class="keywordflow">if</span> (*<span class="keywordtype">string</span>)
<a name="l01289"></a>01289     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Junk after end of expression.&quot;</span>));
<a name="l01290"></a>01290   <span class="keywordflow">return</span> exp;
<a name="l01291"></a>01291 }
<a name="l01292"></a>01292 
<a name="l01293"></a>01293 <span class="comment">/* Parse STRING as an expression.  If parsing ends in the middle of a</span>
<a name="l01294"></a>01294 <span class="comment">   field reference, return the type of the left-hand-side of the</span>
<a name="l01295"></a>01295 <span class="comment">   reference; furthermore, if the parsing ends in the field name,</span>
<a name="l01296"></a>01296 <span class="comment">   return the field name in *NAME.  If the parsing ends in the middle</span>
<a name="l01297"></a>01297 <span class="comment">   of a field reference, but the reference is somehow invalid, throw</span>
<a name="l01298"></a>01298 <span class="comment">   an exception.  In all other cases, return NULL.  Returned non-NULL</span>
<a name="l01299"></a>01299 <span class="comment">   *NAME must be freed by the caller.  */</span>
<a name="l01300"></a>01300 
<a name="l01301"></a>01301 <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l01302"></a><a class="code" href="parse_8c.html#a1345832ca61aebb2aa765cb36fe56f86">01302</a> <a class="code" href="expression_8h.html#a8ceaea92539a80c00650d1e15ddd0c1e">parse_expression_for_completion</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>, <span class="keywordtype">char</span> **<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>,
<a name="l01303"></a>01303                                  <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> *<a class="code" href="ser-unix_8c.html#a45a5b7c00a796a23f01673cef1dbe0a9">code</a>)
<a name="l01304"></a>01304 {
<a name="l01305"></a>01305   <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *exp = NULL;
<a name="l01306"></a>01306   <span class="keyword">struct </span>value *val;
<a name="l01307"></a>01307   <span class="keywordtype">int</span> subexp;
<a name="l01308"></a>01308   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> except;
<a name="l01309"></a>01309 
<a name="l01310"></a>01310   <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (except, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l01311"></a>01311     {
<a name="l01312"></a>01312       <a class="code" href="expression_8h.html#a7cdba29abd014ae348e7a95cb9fb5aff">parse_completion</a> = 1;
<a name="l01313"></a>01313       exp = parse_exp_in_context (&amp;<span class="keywordtype">string</span>, 0, 0, 0, 0, &amp;subexp);
<a name="l01314"></a>01314     }
<a name="l01315"></a>01315   <a class="code" href="expression_8h.html#a7cdba29abd014ae348e7a95cb9fb5aff">parse_completion</a> = 0;
<a name="l01316"></a>01316   <span class="keywordflow">if</span> (except.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0 || ! exp)
<a name="l01317"></a>01317     <span class="keywordflow">return</span> NULL;
<a name="l01318"></a>01318 
<a name="l01319"></a>01319   <span class="keywordflow">if</span> (expout_tag_completion_type != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ac0ed09886a958d1a94646893440004a8">TYPE_CODE_UNDEF</a>)
<a name="l01320"></a>01320     {
<a name="l01321"></a>01321       *code = expout_tag_completion_type;
<a name="l01322"></a>01322       *name = expout_completion_name;
<a name="l01323"></a>01323       expout_completion_name = NULL;
<a name="l01324"></a>01324       <span class="keywordflow">return</span> NULL;
<a name="l01325"></a>01325     }
<a name="l01326"></a>01326 
<a name="l01327"></a>01327   <span class="keywordflow">if</span> (expout_last_struct == -1)
<a name="l01328"></a>01328     {
<a name="l01329"></a>01329       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (exp);
<a name="l01330"></a>01330       <span class="keywordflow">return</span> NULL;
<a name="l01331"></a>01331     }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333   *name = <a class="code" href="eval_8c.html#a48251e8fb9c0909d2cbfca8267886a85">extract_field_op</a> (exp, &amp;subexp);
<a name="l01334"></a>01334   <span class="keywordflow">if</span> (!*name)
<a name="l01335"></a>01335     {
<a name="l01336"></a>01336       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (exp);
<a name="l01337"></a>01337       <span class="keywordflow">return</span> NULL;
<a name="l01338"></a>01338     }
<a name="l01339"></a>01339 
<a name="l01340"></a>01340   <span class="comment">/* This might throw an exception.  If so, we want to let it</span>
<a name="l01341"></a>01341 <span class="comment">     propagate.  */</span>
<a name="l01342"></a>01342   val = <a class="code" href="eval_8c.html#a9ac1b0a4c2359b36763bd2de0d751d69">evaluate_subexpression_type</a> (exp, subexp);
<a name="l01343"></a>01343   <span class="comment">/* (*NAME) is a part of the EXP memory block freed below.  */</span>
<a name="l01344"></a>01344   *name = xstrdup (*name);
<a name="l01345"></a>01345   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (exp);
<a name="l01346"></a>01346 
<a name="l01347"></a>01347   <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val);
<a name="l01348"></a>01348 }
<a name="l01349"></a>01349 
<a name="l01350"></a>01350 <span class="comment">/* A post-parser that does nothing.  */</span>
<a name="l01351"></a>01351 
<a name="l01352"></a>01352 <span class="keywordtype">void</span>
<a name="l01353"></a><a class="code" href="parser-defs_8h.html#ae38169f794a412952c6c7a8a90f8901f">01353</a> <a class="code" href="parse_8c.html#aa04ce44b24dbe3d4424adac28d7f8495">null_post_parser</a> (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> **exp, <span class="keywordtype">int</span> void_context_p)
<a name="l01354"></a>01354 {
<a name="l01355"></a>01355 }
<a name="l01356"></a>01356 
<a name="l01357"></a>01357 <span class="comment">/* Parse floating point value P of length LEN.</span>
<a name="l01358"></a>01358 <span class="comment">   Return 0 (false) if invalid, 1 (true) if valid.</span>
<a name="l01359"></a>01359 <span class="comment">   The successfully parsed number is stored in D.</span>
<a name="l01360"></a>01360 <span class="comment">   *SUFFIX points to the suffix of the number in P.</span>
<a name="l01361"></a>01361 <span class="comment"></span>
<a name="l01362"></a>01362 <span class="comment">   NOTE: This accepts the floating point syntax that sscanf accepts.  */</span>
<a name="l01363"></a>01363 
<a name="l01364"></a>01364 <span class="keywordtype">int</span>
<a name="l01365"></a><a class="code" href="parser-defs_8h.html#ad82cccabcd02e3a42a9d67da0194022b">01365</a> <a class="code" href="parse_8c.html#ad82cccabcd02e3a42a9d67da0194022b">parse_float</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *p, <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>, <a class="code" href="doublest_8h.html#ac1812677a2f11158956252854ec47a77">DOUBLEST</a> *d, <span class="keyword">const</span> <span class="keywordtype">char</span> **suffix)
<a name="l01366"></a>01366 {
<a name="l01367"></a>01367   <span class="keywordtype">char</span> *copy;
<a name="l01368"></a>01368   <span class="keywordtype">int</span> n, num;
<a name="l01369"></a>01369 
<a name="l01370"></a>01370   copy = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (len + 1);
<a name="l01371"></a>01371   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (copy, p, len);
<a name="l01372"></a>01372   copy[<a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>] = 0;
<a name="l01373"></a>01373 
<a name="l01374"></a>01374   num = sscanf (copy, <span class="stringliteral">&quot;%&quot;</span> <a class="code" href="doublest_8h.html#aa951fcca1f031ca1e767af9358ad2634">DOUBLEST_SCAN_FORMAT</a> <span class="stringliteral">&quot;%n&quot;</span>, d, &amp;n);
<a name="l01375"></a>01375   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (copy);
<a name="l01376"></a>01376 
<a name="l01377"></a>01377   <span class="comment">/* The sscanf man page suggests not making any assumptions on the effect</span>
<a name="l01378"></a>01378 <span class="comment">     of %n on the result, so we don&#39;t.</span>
<a name="l01379"></a>01379 <span class="comment">     That is why we simply test num == 0.  */</span>
<a name="l01380"></a>01380   <span class="keywordflow">if</span> (num == 0)
<a name="l01381"></a>01381     <span class="keywordflow">return</span> 0;
<a name="l01382"></a>01382 
<a name="l01383"></a>01383   *suffix = p + n;
<a name="l01384"></a>01384   <span class="keywordflow">return</span> 1;
<a name="l01385"></a>01385 }
<a name="l01386"></a>01386 
<a name="l01387"></a>01387 <span class="comment">/* Parse floating point value P of length LEN, using the C syntax for floats.</span>
<a name="l01388"></a>01388 <span class="comment">   Return 0 (false) if invalid, 1 (true) if valid.</span>
<a name="l01389"></a>01389 <span class="comment">   The successfully parsed number is stored in *D.</span>
<a name="l01390"></a>01390 <span class="comment">   Its type is taken from builtin_type (gdbarch) and is stored in *T.  */</span>
<a name="l01391"></a>01391 
<a name="l01392"></a>01392 <span class="keywordtype">int</span>
<a name="l01393"></a><a class="code" href="parser-defs_8h.html#ab704702849a00092c8515e77cb24ae82">01393</a> <a class="code" href="parse_8c.html#ab704702849a00092c8515e77cb24ae82">parse_c_float</a> (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">const</span> <span class="keywordtype">char</span> *p, <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>,
<a name="l01394"></a>01394                <a class="code" href="doublest_8h.html#ac1812677a2f11158956252854ec47a77">DOUBLEST</a> *d, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **t)
<a name="l01395"></a>01395 {
<a name="l01396"></a>01396   <span class="keyword">const</span> <span class="keywordtype">char</span> *suffix;
<a name="l01397"></a>01397   <span class="keywordtype">int</span> suffix_len;
<a name="l01398"></a>01398   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structbuiltin__type.html">builtin_type</a> *builtin_types = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch);
<a name="l01399"></a>01399 
<a name="l01400"></a>01400   <span class="keywordflow">if</span> (! <a class="code" href="parse_8c.html#ad82cccabcd02e3a42a9d67da0194022b">parse_float</a> (p, len, d, &amp;suffix))
<a name="l01401"></a>01401     <span class="keywordflow">return</span> 0;
<a name="l01402"></a>01402 
<a name="l01403"></a>01403   suffix_len = p + len - suffix;
<a name="l01404"></a>01404 
<a name="l01405"></a>01405   <span class="keywordflow">if</span> (suffix_len == 0)
<a name="l01406"></a>01406     *t = builtin_types-&gt;<a class="code" href="structbuiltin__type.html#a29f1e28c1aa70321c4c7d4094f672b57">builtin_double</a>;
<a name="l01407"></a>01407   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (suffix_len == 1)
<a name="l01408"></a>01408     {
<a name="l01409"></a>01409       <span class="comment">/* Handle suffixes: &#39;f&#39; for float, &#39;l&#39; for long double.  */</span>
<a name="l01410"></a>01410       <span class="keywordflow">if</span> (tolower (*suffix) == <span class="charliteral">&#39;f&#39;</span>)
<a name="l01411"></a>01411         *t = builtin_types-&gt;<a class="code" href="structbuiltin__type.html#af44abaec1868fa0a34efaab02a436d6a">builtin_float</a>;
<a name="l01412"></a>01412       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tolower (*suffix) == <span class="charliteral">&#39;l&#39;</span>)
<a name="l01413"></a>01413         *t = builtin_types-&gt;<a class="code" href="structbuiltin__type.html#a715dea24631a6825a39dbb26d85c87f5">builtin_long_double</a>;
<a name="l01414"></a>01414       <span class="keywordflow">else</span>
<a name="l01415"></a>01415         <span class="keywordflow">return</span> 0;
<a name="l01416"></a>01416     }
<a name="l01417"></a>01417   <span class="keywordflow">else</span>
<a name="l01418"></a>01418     <span class="keywordflow">return</span> 0;
<a name="l01419"></a>01419 
<a name="l01420"></a>01420   <span class="keywordflow">return</span> 1;
<a name="l01421"></a>01421 }
<a name="l01422"></a>01422 
<a name="l01423"></a>01423 <span class="comment">/* Stuff for maintaining a stack of types.  Currently just used by C, but</span>
<a name="l01424"></a>01424 <span class="comment">   probably useful for any language which declares its types &quot;backwards&quot;.  */</span>
<a name="l01425"></a>01425 
<a name="l01426"></a>01426 <span class="comment">/* Ensure that there are HOWMUCH open slots on the type stack STACK.  */</span>
<a name="l01427"></a>01427 
<a name="l01428"></a>01428 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01429"></a>01429 type_stack_reserve (<span class="keyword">struct</span> <a class="code" href="structtype__stack.html">type_stack</a> *stack, <span class="keywordtype">int</span> howmuch)
<a name="l01430"></a>01430 {
<a name="l01431"></a>01431   <span class="keywordflow">if</span> (stack-&gt;<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a> + howmuch &gt;= stack-&gt;<a class="code" href="structtype__stack.html#aff3ad06253c1369f85a6751b6adf3d02">size</a>)
<a name="l01432"></a>01432     {
<a name="l01433"></a>01433       stack-&gt;<a class="code" href="structtype__stack.html#aff3ad06253c1369f85a6751b6adf3d02">size</a> *= 2;
<a name="l01434"></a>01434       <span class="keywordflow">if</span> (stack-&gt;<a class="code" href="structtype__stack.html#aff3ad06253c1369f85a6751b6adf3d02">size</a> &lt; howmuch)
<a name="l01435"></a>01435         stack-&gt;<a class="code" href="structtype__stack.html#aff3ad06253c1369f85a6751b6adf3d02">size</a> = howmuch;
<a name="l01436"></a>01436       stack-&gt;<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a> = <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (stack-&gt;<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>,
<a name="l01437"></a>01437                                   stack-&gt;<a class="code" href="structtype__stack.html#aff3ad06253c1369f85a6751b6adf3d02">size</a> * sizeof (<span class="keyword">union</span> <a class="code" href="uniontype__stack__elt.html">type_stack_elt</a>));
<a name="l01438"></a>01438     }
<a name="l01439"></a>01439 }
<a name="l01440"></a>01440 
<a name="l01441"></a>01441 <span class="comment">/* Ensure that there is a single open slot in the global type stack.  */</span>
<a name="l01442"></a>01442 
<a name="l01443"></a>01443 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01444"></a>01444 check_type_stack_depth (<span class="keywordtype">void</span>)
<a name="l01445"></a>01445 {
<a name="l01446"></a>01446   type_stack_reserve (&amp;<a class="code" href="structtype__stack.html">type_stack</a>, 1);
<a name="l01447"></a>01447 }
<a name="l01448"></a>01448 
<a name="l01449"></a>01449 <span class="comment">/* A helper function for insert_type and insert_type_address_space.</span>
<a name="l01450"></a>01450 <span class="comment">   This does work of expanding the type stack and inserting the new</span>
<a name="l01451"></a>01451 <span class="comment">   element, ELEMENT, into the stack at location SLOT.  */</span>
<a name="l01452"></a>01452 
<a name="l01453"></a>01453 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01454"></a>01454 insert_into_type_stack (<span class="keywordtype">int</span> slot, <span class="keyword">union</span> <a class="code" href="uniontype__stack__elt.html">type_stack_elt</a> element)
<a name="l01455"></a>01455 {
<a name="l01456"></a>01456   check_type_stack_depth ();
<a name="l01457"></a>01457 
<a name="l01458"></a>01458   <span class="keywordflow">if</span> (slot &lt; <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>)
<a name="l01459"></a>01459     <a class="code" href="gdb__string_8h.html#a83bff071dce86912d77444c20c9fcb72">memmove</a> (&amp;<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>[slot + 1], &amp;<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>[slot],
<a name="l01460"></a>01460              (<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a> - slot) * sizeof (<span class="keyword">union</span> <a class="code" href="uniontype__stack__elt.html">type_stack_elt</a>));
<a name="l01461"></a>01461   <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>[slot] = element;
<a name="l01462"></a>01462   ++<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>;
<a name="l01463"></a>01463 }
<a name="l01464"></a>01464 
<a name="l01465"></a>01465 <span class="comment">/* Insert a new type, TP, at the bottom of the type stack.  If TP is</span>
<a name="l01466"></a>01466 <span class="comment">   tp_pointer or tp_reference, it is inserted at the bottom.  If TP is</span>
<a name="l01467"></a>01467 <span class="comment">   a qualifier, it is inserted at slot 1 (just above a previous</span>
<a name="l01468"></a>01468 <span class="comment">   tp_pointer) if there is anything on the stack, or simply pushed if</span>
<a name="l01469"></a>01469 <span class="comment">   the stack is empty.  Other values for TP are invalid.  */</span>
<a name="l01470"></a>01470 
<a name="l01471"></a>01471 <span class="keywordtype">void</span>
<a name="l01472"></a><a class="code" href="parser-defs_8h.html#abf7dcda1b9e481558ebcec63c01f598a">01472</a> <a class="code" href="parse_8c.html#ac3af77595738e21285c5bea59c470b35">insert_type</a> (<span class="keyword">enum</span> <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742">type_pieces</a> tp)
<a name="l01473"></a>01473 {
<a name="l01474"></a>01474   <span class="keyword">union </span><a class="code" href="uniontype__stack__elt.html">type_stack_elt</a> element;
<a name="l01475"></a>01475   <span class="keywordtype">int</span> slot;
<a name="l01476"></a>01476 
<a name="l01477"></a>01477   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (tp == <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742a93167d54d04361d199142a637dcb6402">tp_pointer</a> || tp == <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742ac827f8ab0c1266137cbc96f945bd0aca">tp_reference</a>
<a name="l01478"></a>01478               || tp == <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742a515272b2a741275b1b4d31b37c671e52">tp_const</a> || tp == <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742a6e0f9ed434569237eacdf32462f77f40">tp_volatile</a>);
<a name="l01479"></a>01479 
<a name="l01480"></a>01480   <span class="comment">/* If there is anything on the stack (we know it will be a</span>
<a name="l01481"></a>01481 <span class="comment">     tp_pointer), insert the qualifier above it.  Otherwise, simply</span>
<a name="l01482"></a>01482 <span class="comment">     push this on the top of the stack.  */</span>
<a name="l01483"></a>01483   <span class="keywordflow">if</span> (<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a> &amp;&amp; (tp == <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742a515272b2a741275b1b4d31b37c671e52">tp_const</a> || tp == <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742a6e0f9ed434569237eacdf32462f77f40">tp_volatile</a>))
<a name="l01484"></a>01484     slot = 1;
<a name="l01485"></a>01485   <span class="keywordflow">else</span>
<a name="l01486"></a>01486     slot = 0;
<a name="l01487"></a>01487 
<a name="l01488"></a>01488   element.<a class="code" href="uniontype__stack__elt.html#ae1f4f3cc539d7499e2bbdf9281338a47">piece</a> = tp;
<a name="l01489"></a>01489   insert_into_type_stack (slot, element);
<a name="l01490"></a>01490 }
<a name="l01491"></a>01491 
<a name="l01492"></a>01492 <span class="keywordtype">void</span>
<a name="l01493"></a><a class="code" href="parser-defs_8h.html#afcfeb6def3202ee803d2f55f9d5ad683">01493</a> <a class="code" href="parse_8c.html#acccee7cd5dc64221a705fb3a49d73b9b">push_type</a> (<span class="keyword">enum</span> <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742">type_pieces</a> tp)
<a name="l01494"></a>01494 {
<a name="l01495"></a>01495   check_type_stack_depth ();
<a name="l01496"></a>01496   <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>[<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>++].<a class="code" href="uniontype__stack__elt.html#ae1f4f3cc539d7499e2bbdf9281338a47">piece</a> = tp;
<a name="l01497"></a>01497 }
<a name="l01498"></a>01498 
<a name="l01499"></a>01499 <span class="keywordtype">void</span>
<a name="l01500"></a><a class="code" href="parser-defs_8h.html#a83366d6456780e504bfe3628c95db143">01500</a> <a class="code" href="parse_8c.html#ac886afb02b3779e6c53017a3f8b446bd">push_type_int</a> (<span class="keywordtype">int</span> n)
<a name="l01501"></a>01501 {
<a name="l01502"></a>01502   check_type_stack_depth ();
<a name="l01503"></a>01503   <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>[<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>++].<a class="code" href="uniontype__stack__elt.html#a8177d1cc7b912479c3555947cbe01cb7">int_val</a> = n;
<a name="l01504"></a>01504 }
<a name="l01505"></a>01505 
<a name="l01506"></a>01506 <span class="comment">/* Insert a tp_space_identifier and the corresponding address space</span>
<a name="l01507"></a>01507 <span class="comment">   value into the stack.  STRING is the name of an address space, as</span>
<a name="l01508"></a>01508 <span class="comment">   recognized by address_space_name_to_int.  If the stack is empty,</span>
<a name="l01509"></a>01509 <span class="comment">   the new elements are simply pushed.  If the stack is not empty,</span>
<a name="l01510"></a>01510 <span class="comment">   this function assumes that the first item on the stack is a</span>
<a name="l01511"></a>01511 <span class="comment">   tp_pointer, and the new values are inserted above the first</span>
<a name="l01512"></a>01512 <span class="comment">   item.  */</span>
<a name="l01513"></a>01513 
<a name="l01514"></a>01514 <span class="keywordtype">void</span>
<a name="l01515"></a><a class="code" href="parser-defs_8h.html#a8fda890874919c018c75c53c673ff94b">01515</a> <a class="code" href="parse_8c.html#a740009b4161dacafedf62f3aeb5a5bd1">insert_type_address_space</a> (<span class="keywordtype">char</span> *<span class="keywordtype">string</span>)
<a name="l01516"></a>01516 {
<a name="l01517"></a>01517   <span class="keyword">union </span><a class="code" href="uniontype__stack__elt.html">type_stack_elt</a> element;
<a name="l01518"></a>01518   <span class="keywordtype">int</span> slot;
<a name="l01519"></a>01519 
<a name="l01520"></a>01520   <span class="comment">/* If there is anything on the stack (we know it will be a</span>
<a name="l01521"></a>01521 <span class="comment">     tp_pointer), insert the address space qualifier above it.</span>
<a name="l01522"></a>01522 <span class="comment">     Otherwise, simply push this on the top of the stack.  */</span>
<a name="l01523"></a>01523   <span class="keywordflow">if</span> (<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>)
<a name="l01524"></a>01524     slot = 1;
<a name="l01525"></a>01525   <span class="keywordflow">else</span>
<a name="l01526"></a>01526     slot = 0;
<a name="l01527"></a>01527 
<a name="l01528"></a>01528   element.<a class="code" href="uniontype__stack__elt.html#ae1f4f3cc539d7499e2bbdf9281338a47">piece</a> = <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742a534e9b0a5205724391bb6d78fbc1ec45">tp_space_identifier</a>;
<a name="l01529"></a>01529   insert_into_type_stack (slot, element);
<a name="l01530"></a>01530   element.<a class="code" href="uniontype__stack__elt.html#a8177d1cc7b912479c3555947cbe01cb7">int_val</a> = <a class="code" href="gdbtypes_8c.html#a9baa80b36263389d369e1624c12f4f62">address_space_name_to_int</a> (<a class="code" href="parser-defs_8h.html#ab29b33d73e1262c7c1c7aaab63c57ba9">parse_gdbarch</a>, <span class="keywordtype">string</span>);
<a name="l01531"></a>01531   insert_into_type_stack (slot, element);
<a name="l01532"></a>01532 }
<a name="l01533"></a>01533 
<a name="l01534"></a>01534 <span class="keyword">enum</span> <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742">type_pieces</a>
<a name="l01535"></a><a class="code" href="parser-defs_8h.html#a81d84027398e0742f849387f54a15364">01535</a> <a class="code" href="parse_8c.html#a81d84027398e0742f849387f54a15364">pop_type</a> (<span class="keywordtype">void</span>)
<a name="l01536"></a>01536 {
<a name="l01537"></a>01537   <span class="keywordflow">if</span> (<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>)
<a name="l01538"></a>01538     <span class="keywordflow">return</span> <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>[--<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>].<a class="code" href="uniontype__stack__elt.html#ae1f4f3cc539d7499e2bbdf9281338a47">piece</a>;
<a name="l01539"></a>01539   <span class="keywordflow">return</span> <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742ae5fdefef1fd943b989dacfed4090e22d">tp_end</a>;
<a name="l01540"></a>01540 }
<a name="l01541"></a>01541 
<a name="l01542"></a>01542 <span class="keywordtype">int</span>
<a name="l01543"></a><a class="code" href="parser-defs_8h.html#a24400b0145ec0c9fd5cec2559767c0f6">01543</a> <a class="code" href="parse_8c.html#a24400b0145ec0c9fd5cec2559767c0f6">pop_type_int</a> (<span class="keywordtype">void</span>)
<a name="l01544"></a>01544 {
<a name="l01545"></a>01545   <span class="keywordflow">if</span> (<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>)
<a name="l01546"></a>01546     <span class="keywordflow">return</span> <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>[--<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>].<a class="code" href="uniontype__stack__elt.html#a8177d1cc7b912479c3555947cbe01cb7">int_val</a>;
<a name="l01547"></a>01547   <span class="comment">/* &quot;Can&#39;t happen&quot;.  */</span>
<a name="l01548"></a>01548   <span class="keywordflow">return</span> 0;
<a name="l01549"></a>01549 }
<a name="l01550"></a>01550 
<a name="l01551"></a>01551 <span class="comment">/* Pop a type list element from the global type stack.  */</span>
<a name="l01552"></a>01552 
<a name="l01553"></a>01553 <span class="keyword">static</span> <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structtype.html">type_ptr</a>) *
<a name="l01554"></a>01554 pop_typelist (<span class="keywordtype">void</span>)
<a name="l01555"></a>01555 {
<a name="l01556"></a>01556   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>);
<a name="l01557"></a>01557   <span class="keywordflow">return</span> <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>[--<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>].typelist_val;
<a name="l01558"></a>01558 }
<a name="l01559"></a>01559 
<a name="l01560"></a>01560 <span class="comment">/* Pop a type_stack element from the global type stack.  */</span>
<a name="l01561"></a>01561 
<a name="l01562"></a>01562 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype__stack.html">type_stack</a> *
<a name="l01563"></a>01563 pop_type_stack (<span class="keywordtype">void</span>)
<a name="l01564"></a>01564 {
<a name="l01565"></a>01565   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>);
<a name="l01566"></a>01566   <span class="keywordflow">return</span> <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>[--<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>].<a class="code" href="uniontype__stack__elt.html#a9b783ee4c2e1c143c99d9a7b98f42b2f">stack_val</a>;
<a name="l01567"></a>01567 }
<a name="l01568"></a>01568 
<a name="l01569"></a>01569 <span class="comment">/* Append the elements of the type stack FROM to the type stack TO.</span>
<a name="l01570"></a>01570 <span class="comment">   Always returns TO.  */</span>
<a name="l01571"></a>01571 
<a name="l01572"></a>01572 <span class="keyword">struct </span><a class="code" href="structtype__stack.html">type_stack</a> *
<a name="l01573"></a><a class="code" href="parser-defs_8h.html#a8079d496a577d21c5e342bab6d6d4d35">01573</a> <a class="code" href="parse_8c.html#a8079d496a577d21c5e342bab6d6d4d35">append_type_stack</a> (<span class="keyword">struct</span> <a class="code" href="structtype__stack.html">type_stack</a> *<a class="code" href="varobj_8h.html#ae2a2635825813434f3201bf8ace439d2">to</a>, <span class="keyword">struct</span> <a class="code" href="structtype__stack.html">type_stack</a> *<a class="code" href="varobj_8h.html#a43396decd62b46fa01cc6c66a84cbba1">from</a>)
<a name="l01574"></a>01574 {
<a name="l01575"></a>01575   type_stack_reserve (to, from-&gt;<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>);
<a name="l01576"></a>01576 
<a name="l01577"></a>01577   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (&amp;to-&gt;<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>[to-&gt;<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>], &amp;from-&gt;<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>[0],
<a name="l01578"></a>01578           from-&gt;<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a> * sizeof (<span class="keyword">union</span> <a class="code" href="uniontype__stack__elt.html">type_stack_elt</a>));
<a name="l01579"></a>01579   to-&gt;<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a> += from-&gt;<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>;
<a name="l01580"></a>01580 
<a name="l01581"></a>01581   <span class="keywordflow">return</span> <a class="code" href="varobj_8h.html#ae2a2635825813434f3201bf8ace439d2">to</a>;
<a name="l01582"></a>01582 }
<a name="l01583"></a>01583 
<a name="l01584"></a>01584 <span class="comment">/* Push the type stack STACK as an element on the global type stack.  */</span>
<a name="l01585"></a>01585 
<a name="l01586"></a>01586 <span class="keywordtype">void</span>
<a name="l01587"></a><a class="code" href="parser-defs_8h.html#abc43dcd2744e2d657b08771a0d33b574">01587</a> <a class="code" href="parse_8c.html#abc43dcd2744e2d657b08771a0d33b574">push_type_stack</a> (<span class="keyword">struct</span> <a class="code" href="structtype__stack.html">type_stack</a> *stack)
<a name="l01588"></a>01588 {
<a name="l01589"></a>01589   check_type_stack_depth ();
<a name="l01590"></a>01590   <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>[<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>++].<a class="code" href="uniontype__stack__elt.html#a9b783ee4c2e1c143c99d9a7b98f42b2f">stack_val</a> = stack;
<a name="l01591"></a>01591   <a class="code" href="parse_8c.html#acccee7cd5dc64221a705fb3a49d73b9b">push_type</a> (<a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742ac9e41623b9286405f58ae768e1b02079">tp_type_stack</a>);
<a name="l01592"></a>01592 }
<a name="l01593"></a>01593 
<a name="l01594"></a>01594 <span class="comment">/* Copy the global type stack into a newly allocated type stack and</span>
<a name="l01595"></a>01595 <span class="comment">   return it.  The global stack is cleared.  The returned type stack</span>
<a name="l01596"></a>01596 <span class="comment">   must be freed with type_stack_cleanup.  */</span>
<a name="l01597"></a>01597 
<a name="l01598"></a>01598 <span class="keyword">struct </span><a class="code" href="structtype__stack.html">type_stack</a> *
<a name="l01599"></a><a class="code" href="parser-defs_8h.html#aff4c6d8b17e62eb1abe10ccaa9b83eb9">01599</a> <a class="code" href="parse_8c.html#aff4c6d8b17e62eb1abe10ccaa9b83eb9">get_type_stack</a> (<span class="keywordtype">void</span>)
<a name="l01600"></a>01600 {
<a name="l01601"></a>01601   <span class="keyword">struct </span><a class="code" href="structtype__stack.html">type_stack</a> *result = XNEW (<span class="keyword">struct</span> <a class="code" href="structtype__stack.html">type_stack</a>);
<a name="l01602"></a>01602 
<a name="l01603"></a>01603   *result = <a class="code" href="structtype__stack.html">type_stack</a>;
<a name="l01604"></a>01604   <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a> = 0;
<a name="l01605"></a>01605   <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#aff3ad06253c1369f85a6751b6adf3d02">size</a> = 0;
<a name="l01606"></a>01606   <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a> = NULL;
<a name="l01607"></a>01607 
<a name="l01608"></a>01608   <span class="keywordflow">return</span> result;
<a name="l01609"></a>01609 }
<a name="l01610"></a>01610 
<a name="l01611"></a>01611 <span class="comment">/* A cleanup function that destroys a single type stack.  */</span>
<a name="l01612"></a>01612 
<a name="l01613"></a>01613 <span class="keywordtype">void</span>
<a name="l01614"></a><a class="code" href="parser-defs_8h.html#ad57dcf5c4d373f0c11fd1c6989169c16">01614</a> <a class="code" href="parse_8c.html#ad57dcf5c4d373f0c11fd1c6989169c16">type_stack_cleanup</a> (<span class="keywordtype">void</span> *arg)
<a name="l01615"></a>01615 {
<a name="l01616"></a>01616   <span class="keyword">struct </span><a class="code" href="structtype__stack.html">type_stack</a> *stack = arg;
<a name="l01617"></a>01617 
<a name="l01618"></a>01618   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (stack-&gt;<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>);
<a name="l01619"></a>01619   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (stack);
<a name="l01620"></a>01620 }
<a name="l01621"></a>01621 
<a name="l01622"></a>01622 <span class="comment">/* Push a function type with arguments onto the global type stack.</span>
<a name="l01623"></a>01623 <span class="comment">   LIST holds the argument types.  If the final item in LIST is NULL,</span>
<a name="l01624"></a>01624 <span class="comment">   then the function will be varargs.  */</span>
<a name="l01625"></a>01625 
<a name="l01626"></a>01626 <span class="keywordtype">void</span>
<a name="l01627"></a><a class="code" href="parser-defs_8h.html#a96ba47d8bf1fc87a21d1d2a7ea5d2568">01627</a> <a class="code" href="parse_8c.html#aa367a3ec70aea72ed9a0c7d446371a37">push_typelist</a> (<a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structtype.html">type_ptr</a>) *list)
<a name="l01628"></a>01628 {
<a name="l01629"></a>01629   check_type_stack_depth ();
<a name="l01630"></a>01630   <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a>[<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a>++].typelist_val = list;
<a name="l01631"></a>01631   <a class="code" href="parse_8c.html#acccee7cd5dc64221a705fb3a49d73b9b">push_type</a> (<a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742aaaad7be164c275eaded91c24ed82f4e8">tp_function_with_arguments</a>);
<a name="l01632"></a>01632 }
<a name="l01633"></a>01633 
<a name="l01634"></a>01634 <span class="comment">/* Pop the type stack and return the type which corresponds to FOLLOW_TYPE</span>
<a name="l01635"></a>01635 <span class="comment">   as modified by all the stuff on the stack.  */</span>
<a name="l01636"></a>01636 <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l01637"></a><a class="code" href="parser-defs_8h.html#acb10e09978e18c18b1f13a58085515ac">01637</a> <a class="code" href="parse_8c.html#a32d426c50b081da23fe24793ad540628">follow_types</a> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *follow_type)
<a name="l01638"></a>01638 {
<a name="l01639"></a>01639   <span class="keywordtype">int</span> done = 0;
<a name="l01640"></a>01640   <span class="keywordtype">int</span> make_const = 0;
<a name="l01641"></a>01641   <span class="keywordtype">int</span> make_volatile = 0;
<a name="l01642"></a>01642   <span class="keywordtype">int</span> make_addr_space = 0;
<a name="l01643"></a>01643   <span class="keywordtype">int</span> array_size;
<a name="l01644"></a>01644 
<a name="l01645"></a>01645   <span class="keywordflow">while</span> (!done)
<a name="l01646"></a>01646     <span class="keywordflow">switch</span> (<a class="code" href="parse_8c.html#a81d84027398e0742f849387f54a15364">pop_type</a> ())
<a name="l01647"></a>01647       {
<a name="l01648"></a>01648       <span class="keywordflow">case</span> <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742ae5fdefef1fd943b989dacfed4090e22d">tp_end</a>:
<a name="l01649"></a>01649         done = 1;
<a name="l01650"></a>01650         <span class="keywordflow">if</span> (make_const)
<a name="l01651"></a>01651           follow_type = <a class="code" href="gdbtypes_8c.html#ab5e31dbb249efdac4f48d4871290bf46">make_cv_type</a> (make_const, 
<a name="l01652"></a>01652                                       <a class="code" href="gdbtypes_8h.html#a85371642c55e599b0d13fc95d0108ad1">TYPE_VOLATILE</a> (follow_type), 
<a name="l01653"></a>01653                                       follow_type, 0);
<a name="l01654"></a>01654         <span class="keywordflow">if</span> (make_volatile)
<a name="l01655"></a>01655           follow_type = <a class="code" href="gdbtypes_8c.html#ab5e31dbb249efdac4f48d4871290bf46">make_cv_type</a> (<a class="code" href="gdbtypes_8h.html#a82b926a1727ba5c6b856145197495a34">TYPE_CONST</a> (follow_type), 
<a name="l01656"></a>01656                                       make_volatile, 
<a name="l01657"></a>01657                                       follow_type, 0);
<a name="l01658"></a>01658         <span class="keywordflow">if</span> (make_addr_space)
<a name="l01659"></a>01659           follow_type = <a class="code" href="gdbtypes_8c.html#aad73132bd29e0c9552b8ecf04473241d">make_type_with_address_space</a> (follow_type, 
<a name="l01660"></a>01660                                                       make_addr_space);
<a name="l01661"></a>01661         make_const = make_volatile = 0;
<a name="l01662"></a>01662         make_addr_space = 0;
<a name="l01663"></a>01663         <span class="keywordflow">break</span>;
<a name="l01664"></a>01664       <span class="keywordflow">case</span> <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742a515272b2a741275b1b4d31b37c671e52">tp_const</a>:
<a name="l01665"></a>01665         make_const = 1;
<a name="l01666"></a>01666         <span class="keywordflow">break</span>;
<a name="l01667"></a>01667       <span class="keywordflow">case</span> <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742a6e0f9ed434569237eacdf32462f77f40">tp_volatile</a>:
<a name="l01668"></a>01668         make_volatile = 1;
<a name="l01669"></a>01669         <span class="keywordflow">break</span>;
<a name="l01670"></a>01670       <span class="keywordflow">case</span> <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742a534e9b0a5205724391bb6d78fbc1ec45">tp_space_identifier</a>:
<a name="l01671"></a>01671         make_addr_space = <a class="code" href="parse_8c.html#a24400b0145ec0c9fd5cec2559767c0f6">pop_type_int</a> ();
<a name="l01672"></a>01672         <span class="keywordflow">break</span>;
<a name="l01673"></a>01673       <span class="keywordflow">case</span> <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742a93167d54d04361d199142a637dcb6402">tp_pointer</a>:
<a name="l01674"></a>01674         follow_type = <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (follow_type);
<a name="l01675"></a>01675         <span class="keywordflow">if</span> (make_const)
<a name="l01676"></a>01676           follow_type = <a class="code" href="gdbtypes_8c.html#ab5e31dbb249efdac4f48d4871290bf46">make_cv_type</a> (make_const, 
<a name="l01677"></a>01677                                       <a class="code" href="gdbtypes_8h.html#a85371642c55e599b0d13fc95d0108ad1">TYPE_VOLATILE</a> (follow_type), 
<a name="l01678"></a>01678                                       follow_type, 0);
<a name="l01679"></a>01679         <span class="keywordflow">if</span> (make_volatile)
<a name="l01680"></a>01680           follow_type = <a class="code" href="gdbtypes_8c.html#ab5e31dbb249efdac4f48d4871290bf46">make_cv_type</a> (<a class="code" href="gdbtypes_8h.html#a82b926a1727ba5c6b856145197495a34">TYPE_CONST</a> (follow_type), 
<a name="l01681"></a>01681                                       make_volatile, 
<a name="l01682"></a>01682                                       follow_type, 0);
<a name="l01683"></a>01683         <span class="keywordflow">if</span> (make_addr_space)
<a name="l01684"></a>01684           follow_type = <a class="code" href="gdbtypes_8c.html#aad73132bd29e0c9552b8ecf04473241d">make_type_with_address_space</a> (follow_type, 
<a name="l01685"></a>01685                                                       make_addr_space);
<a name="l01686"></a>01686         make_const = make_volatile = 0;
<a name="l01687"></a>01687         make_addr_space = 0;
<a name="l01688"></a>01688         <span class="keywordflow">break</span>;
<a name="l01689"></a>01689       <span class="keywordflow">case</span> <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742ac827f8ab0c1266137cbc96f945bd0aca">tp_reference</a>:
<a name="l01690"></a>01690         follow_type = <a class="code" href="gdbtypes_8c.html#afa9bb6a94856e413a9932abea7356e22">lookup_reference_type</a> (follow_type);
<a name="l01691"></a>01691         <span class="keywordflow">if</span> (make_const)
<a name="l01692"></a>01692           follow_type = <a class="code" href="gdbtypes_8c.html#ab5e31dbb249efdac4f48d4871290bf46">make_cv_type</a> (make_const, 
<a name="l01693"></a>01693                                       <a class="code" href="gdbtypes_8h.html#a85371642c55e599b0d13fc95d0108ad1">TYPE_VOLATILE</a> (follow_type), 
<a name="l01694"></a>01694                                       follow_type, 0);
<a name="l01695"></a>01695         <span class="keywordflow">if</span> (make_volatile)
<a name="l01696"></a>01696           follow_type = <a class="code" href="gdbtypes_8c.html#ab5e31dbb249efdac4f48d4871290bf46">make_cv_type</a> (<a class="code" href="gdbtypes_8h.html#a82b926a1727ba5c6b856145197495a34">TYPE_CONST</a> (follow_type), 
<a name="l01697"></a>01697                                       make_volatile, 
<a name="l01698"></a>01698                                       follow_type, 0);
<a name="l01699"></a>01699         <span class="keywordflow">if</span> (make_addr_space)
<a name="l01700"></a>01700           follow_type = <a class="code" href="gdbtypes_8c.html#aad73132bd29e0c9552b8ecf04473241d">make_type_with_address_space</a> (follow_type, 
<a name="l01701"></a>01701                                                       make_addr_space);
<a name="l01702"></a>01702         make_const = make_volatile = 0;
<a name="l01703"></a>01703         make_addr_space = 0;
<a name="l01704"></a>01704         <span class="keywordflow">break</span>;
<a name="l01705"></a>01705       <span class="keywordflow">case</span> <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742a7e7082eea45b55c36261e0ac29682314">tp_array</a>:
<a name="l01706"></a>01706         array_size = <a class="code" href="parse_8c.html#a24400b0145ec0c9fd5cec2559767c0f6">pop_type_int</a> ();
<a name="l01707"></a>01707         <span class="comment">/* FIXME-type-allocation: need a way to free this type when we are</span>
<a name="l01708"></a>01708 <span class="comment">           done with it.  */</span>
<a name="l01709"></a>01709         follow_type =
<a name="l01710"></a>01710           <a class="code" href="gdbtypes_8c.html#a91c24db4658fe0833c46b6fe5d677159">lookup_array_range_type</a> (follow_type,
<a name="l01711"></a>01711                                    0, array_size &gt;= 0 ? array_size - 1 : 0);
<a name="l01712"></a>01712         <span class="keywordflow">if</span> (array_size &lt; 0)
<a name="l01713"></a>01713           <a class="code" href="gdbtypes_8h.html#a54487ac042b1fcfca60cf43c158af526">TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED</a> (follow_type) = 1;
<a name="l01714"></a>01714         <span class="keywordflow">break</span>;
<a name="l01715"></a>01715       <span class="keywordflow">case</span> <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742a4d121590db2401c8d18a8c07ccdb38ff">tp_function</a>:
<a name="l01716"></a>01716         <span class="comment">/* FIXME-type-allocation: need a way to free this type when we are</span>
<a name="l01717"></a>01717 <span class="comment">           done with it.  */</span>
<a name="l01718"></a>01718         follow_type = <a class="code" href="gdbtypes_8c.html#ab21dd6531306fba2a7078534017df6fb">lookup_function_type</a> (follow_type);
<a name="l01719"></a>01719         <span class="keywordflow">break</span>;
<a name="l01720"></a>01720 
<a name="l01721"></a>01721       <span class="keywordflow">case</span> <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742aaaad7be164c275eaded91c24ed82f4e8">tp_function_with_arguments</a>:
<a name="l01722"></a>01722         {
<a name="l01723"></a>01723           <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structtype.html">type_ptr</a>) *args = pop_typelist ();
<a name="l01724"></a>01724 
<a name="l01725"></a>01725           follow_type
<a name="l01726"></a>01726             = <a class="code" href="gdbtypes_8c.html#a8691b190da815f4a90d21dd0c0ae921e">lookup_function_type_with_arguments</a> (follow_type,
<a name="l01727"></a>01727                                                    <a class="code" href="vec_8h.html#a844523bba6d0565ef73a0f4a63e48d19">VEC_length</a> (<a class="code" href="structtype.html">type_ptr</a>, args),
<a name="l01728"></a>01728                                                    <a class="code" href="vec_8h.html#a99adc2006a668acc675e3758d9375ad5">VEC_address</a> (<a class="code" href="structtype.html">type_ptr</a>,
<a name="l01729"></a>01729                                                                 args));
<a name="l01730"></a>01730           <a class="code" href="vec_8h.html#af5724b2bbce65103300279f9abe7f577">VEC_free</a> (<a class="code" href="structtype.html">type_ptr</a>, args);
<a name="l01731"></a>01731         }
<a name="l01732"></a>01732         <span class="keywordflow">break</span>;
<a name="l01733"></a>01733 
<a name="l01734"></a>01734       <span class="keywordflow">case</span> <a class="code" href="parser-defs_8h.html#a32b52d9971ee194e6f7a00feaa9ae742ac9e41623b9286405f58ae768e1b02079">tp_type_stack</a>:
<a name="l01735"></a>01735         {
<a name="l01736"></a>01736           <span class="keyword">struct </span><a class="code" href="structtype__stack.html">type_stack</a> *stack = pop_type_stack ();
<a name="l01737"></a>01737           <span class="comment">/* Sort of ugly, but not really much worse than the</span>
<a name="l01738"></a>01738 <span class="comment">             alternatives.  */</span>
<a name="l01739"></a>01739           <span class="keyword">struct </span><a class="code" href="structtype__stack.html">type_stack</a> save = <a class="code" href="structtype__stack.html">type_stack</a>;
<a name="l01740"></a>01740 
<a name="l01741"></a>01741           <a class="code" href="structtype__stack.html">type_stack</a> = *stack;
<a name="l01742"></a>01742           follow_type = <a class="code" href="parse_8c.html#a32d426c50b081da23fe24793ad540628">follow_types</a> (follow_type);
<a name="l01743"></a>01743           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a> == 0);
<a name="l01744"></a>01744 
<a name="l01745"></a>01745           <a class="code" href="structtype__stack.html">type_stack</a> = <a class="code" href="namespaceSession.html#a760bd9a972f5c93149918376625ad07f">save</a>;
<a name="l01746"></a>01746         }
<a name="l01747"></a>01747         <span class="keywordflow">break</span>;
<a name="l01748"></a>01748       <span class="keywordflow">default</span>:
<a name="l01749"></a>01749         <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;unrecognized tp_ value in follow_types&quot;</span>);
<a name="l01750"></a>01750       }
<a name="l01751"></a>01751   <span class="keywordflow">return</span> follow_type;
<a name="l01752"></a>01752 }
<a name="l01753"></a>01753 
<a name="l01754"></a>01754 <span class="comment">/* This function avoids direct calls to fprintf </span>
<a name="l01755"></a>01755 <span class="comment">   in the parser generated debug code.  */</span>
<a name="l01756"></a>01756 <span class="keywordtype">void</span>
<a name="l01757"></a><a class="code" href="parse_8c.html#a3d19aacec5ab9030149fed4b5380c4fc">01757</a> <a class="code" href="parse_8c.html#a3d19aacec5ab9030149fed4b5380c4fc">parser_fprintf</a> (FILE *x, <span class="keyword">const</span> <span class="keywordtype">char</span> *y, ...)
<a name="l01758"></a>01758 { 
<a name="l01759"></a>01759   va_list args;
<a name="l01760"></a>01760 
<a name="l01761"></a>01761   va_start (args, y);
<a name="l01762"></a>01762   <span class="keywordflow">if</span> (x == stderr)
<a name="l01763"></a>01763     <a class="code" href="utils_8c.html#ab5fb0d7dc6e4ae2c661fb663955e90ac">vfprintf_unfiltered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, y, args); 
<a name="l01764"></a>01764   <span class="keywordflow">else</span>
<a name="l01765"></a>01765     {
<a name="l01766"></a>01766       <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, <span class="stringliteral">&quot; Unknown FILE used.\n&quot;</span>);
<a name="l01767"></a>01767       <a class="code" href="utils_8c.html#ab5fb0d7dc6e4ae2c661fb663955e90ac">vfprintf_unfiltered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, y, args);
<a name="l01768"></a>01768     }
<a name="l01769"></a>01769   va_end (args);
<a name="l01770"></a>01770 }
<a name="l01771"></a>01771 
<a name="l01772"></a>01772 <span class="comment">/* Implementation of the exp_descriptor method operator_check.  */</span>
<a name="l01773"></a>01773 
<a name="l01774"></a>01774 <span class="keywordtype">int</span>
<a name="l01775"></a><a class="code" href="parser-defs_8h.html#a3c5d5d877d396d73ba4e16142a96a9ad">01775</a> <a class="code" href="parse_8c.html#a3c5d5d877d396d73ba4e16142a96a9ad">operator_check_standard </a>(<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp, <span class="keywordtype">int</span> pos,
<a name="l01776"></a>01776                          <span class="keywordtype">int</span> (*objfile_func) (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l01777"></a>01777                                               <span class="keywordtype">void</span> *data),
<a name="l01778"></a>01778                          <span class="keywordtype">void</span> *data)
<a name="l01779"></a>01779 {
<a name="l01780"></a>01780   <span class="keyword">const</span> <span class="keyword">union </span><a class="code" href="unionexp__element.html">exp_element</a> *<span class="keyword">const</span> elts = exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>;
<a name="l01781"></a>01781   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = NULL;
<a name="l01782"></a>01782   <span class="keyword">struct </span>objfile *objfile = NULL;
<a name="l01783"></a>01783 
<a name="l01784"></a>01784   <span class="comment">/* Extended operators should have been already handled by exp_descriptor</span>
<a name="l01785"></a>01785 <span class="comment">     iterate method of its specific language.  */</span>
<a name="l01786"></a>01786   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (elts[pos].opcode &lt; OP_EXTENDED0);
<a name="l01787"></a>01787 
<a name="l01788"></a>01788   <span class="comment">/* Track the callers of write_exp_elt_type for this table.  */</span>
<a name="l01789"></a>01789 
<a name="l01790"></a>01790   <span class="keywordflow">switch</span> (elts[pos].opcode)
<a name="l01791"></a>01791     {
<a name="l01792"></a>01792     <span class="keywordflow">case</span> BINOP_VAL:
<a name="l01793"></a>01793     <span class="keywordflow">case</span> OP_COMPLEX:
<a name="l01794"></a>01794     <span class="keywordflow">case</span> OP_DECFLOAT:
<a name="l01795"></a>01795     <span class="keywordflow">case</span> OP_DOUBLE:
<a name="l01796"></a>01796     <span class="keywordflow">case</span> OP_LONG:
<a name="l01797"></a>01797     <span class="keywordflow">case</span> OP_SCOPE:
<a name="l01798"></a>01798     <span class="keywordflow">case</span> OP_TYPE:
<a name="l01799"></a>01799     <span class="keywordflow">case</span> UNOP_CAST:
<a name="l01800"></a>01800     <span class="keywordflow">case</span> UNOP_MAX:
<a name="l01801"></a>01801     <span class="keywordflow">case</span> UNOP_MEMVAL:
<a name="l01802"></a>01802     <span class="keywordflow">case</span> UNOP_MIN:
<a name="l01803"></a>01803       type = elts[pos + 1].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>;
<a name="l01804"></a>01804       <span class="keywordflow">break</span>;
<a name="l01805"></a>01805 
<a name="l01806"></a>01806     <span class="keywordflow">case</span> TYPE_INSTANCE:
<a name="l01807"></a>01807       {
<a name="l01808"></a>01808         <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> arg, nargs = elts[pos + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>;
<a name="l01809"></a>01809 
<a name="l01810"></a>01810         <span class="keywordflow">for</span> (arg = 0; arg &lt; nargs; arg++)
<a name="l01811"></a>01811           {
<a name="l01812"></a>01812             <span class="keyword">struct </span>type *type = elts[pos + 2 + arg].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>;
<a name="l01813"></a>01813             <span class="keyword">struct </span>objfile *objfile = <a class="code" href="gdbtypes_8h.html#aff6665865a3226d047330d04c05bcb3d">TYPE_OBJFILE</a> (type);
<a name="l01814"></a>01814 
<a name="l01815"></a>01815             <span class="keywordflow">if</span> (objfile &amp;&amp; (*objfile_func) (objfile, data))
<a name="l01816"></a>01816               <span class="keywordflow">return</span> 1;
<a name="l01817"></a>01817           }
<a name="l01818"></a>01818       }
<a name="l01819"></a>01819       <span class="keywordflow">break</span>;
<a name="l01820"></a>01820 
<a name="l01821"></a>01821     <span class="keywordflow">case</span> UNOP_MEMVAL_TLS:
<a name="l01822"></a>01822       objfile = elts[pos + 1].<a class="code" href="unionexp__element.html#a966b14b1d361ed6b2f7cfc2053d5fa1f">objfile</a>;
<a name="l01823"></a>01823       type = elts[pos + 2].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>;
<a name="l01824"></a>01824       <span class="keywordflow">break</span>;
<a name="l01825"></a>01825 
<a name="l01826"></a>01826     <span class="keywordflow">case</span> OP_VAR_VALUE:
<a name="l01827"></a>01827       {
<a name="l01828"></a>01828         <span class="keyword">const</span> <span class="keyword">struct </span>block *<span class="keyword">const</span> block = elts[pos + 1].<a class="code" href="unionexp__element.html#a140894cc6f8f336a98a4ec9340c7859b">block</a>;
<a name="l01829"></a>01829         <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *<span class="keyword">const</span> <a class="code" href="structsymbol.html">symbol</a> = elts[pos + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>;
<a name="l01830"></a>01830 
<a name="l01831"></a>01831         <span class="comment">/* Check objfile where the variable itself is placed.</span>
<a name="l01832"></a>01832 <span class="comment">           SYMBOL_OBJ_SECTION (symbol) may be NULL.  */</span>
<a name="l01833"></a>01833         <span class="keywordflow">if</span> ((*objfile_func) (<a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (symbol)-&gt;objfile, data))
<a name="l01834"></a>01834           <span class="keywordflow">return</span> 1;
<a name="l01835"></a>01835 
<a name="l01836"></a>01836         <span class="comment">/* Check objfile where is placed the code touching the variable.  */</span>
<a name="l01837"></a>01837         objfile = <a class="code" href="symtab_8c.html#ad8b96047323c72511df9c46ea54ab648">lookup_objfile_from_block</a> (block);
<a name="l01838"></a>01838 
<a name="l01839"></a>01839         type = <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (symbol);
<a name="l01840"></a>01840       }
<a name="l01841"></a>01841       <span class="keywordflow">break</span>;
<a name="l01842"></a>01842     }
<a name="l01843"></a>01843 
<a name="l01844"></a>01844   <span class="comment">/* Invoke callbacks for TYPE and OBJFILE if they were set as non-NULL.  */</span>
<a name="l01845"></a>01845 
<a name="l01846"></a>01846   <span class="keywordflow">if</span> (type &amp;&amp; <a class="code" href="gdbtypes_8h.html#aff6665865a3226d047330d04c05bcb3d">TYPE_OBJFILE</a> (type)
<a name="l01847"></a>01847       &amp;&amp; (*objfile_func) (<a class="code" href="gdbtypes_8h.html#aff6665865a3226d047330d04c05bcb3d">TYPE_OBJFILE</a> (type), data))
<a name="l01848"></a>01848     <span class="keywordflow">return</span> 1;
<a name="l01849"></a>01849   <span class="keywordflow">if</span> (objfile &amp;&amp; (*objfile_func) (objfile, data))
<a name="l01850"></a>01850     <span class="keywordflow">return</span> 1;
<a name="l01851"></a>01851 
<a name="l01852"></a>01852   <span class="keywordflow">return</span> 0;
<a name="l01853"></a>01853 }
<a name="l01854"></a>01854 
<a name="l01855"></a>01855 <span class="comment">/* Call OBJFILE_FUNC for any TYPE and OBJFILE found being referenced by EXP.</span>
<a name="l01856"></a>01856 <span class="comment">   The functions are never called with NULL OBJFILE.  Functions get passed an</span>
<a name="l01857"></a>01857 <span class="comment">   arbitrary caller supplied DATA pointer.  If any of the functions returns</span>
<a name="l01858"></a>01858 <span class="comment">   non-zero value then (any other) non-zero value is immediately returned to</span>
<a name="l01859"></a>01859 <span class="comment">   the caller.  Otherwise zero is returned after iterating through whole EXP.</span>
<a name="l01860"></a>01860 <span class="comment">   */</span>
<a name="l01861"></a>01861 
<a name="l01862"></a>01862 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01863"></a>01863 exp_iterate (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp,
<a name="l01864"></a>01864              <span class="keywordtype">int</span> (*objfile_func) (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>, <span class="keywordtype">void</span> *data),
<a name="l01865"></a>01865              <span class="keywordtype">void</span> *data)
<a name="l01866"></a>01866 {
<a name="l01867"></a>01867   <span class="keywordtype">int</span> endpos;
<a name="l01868"></a>01868 
<a name="l01869"></a>01869   <span class="keywordflow">for</span> (endpos = exp-&gt;<a class="code" href="structexpression.html#ad5e1dbc7e3732d94d29b8c3d61696123">nelts</a>; endpos &gt; 0; )
<a name="l01870"></a>01870     {
<a name="l01871"></a>01871       <span class="keywordtype">int</span> pos, args, oplen = 0;
<a name="l01872"></a>01872 
<a name="l01873"></a>01873       <a class="code" href="parse_8c.html#a0c5c1cb429e3f2236be9a18e3629913c">operator_length </a>(exp, endpos, &amp;oplen, &amp;args);
<a name="l01874"></a>01874       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (oplen &gt; 0);
<a name="l01875"></a>01875 
<a name="l01876"></a>01876       pos = endpos - oplen;
<a name="l01877"></a>01877       <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>-&gt;<a class="code" href="structlanguage__defn.html#a3879525090f7fa0b979218c0fd329015">la_exp_desc</a>-&gt;<a class="code" href="structexp__descriptor.html#a50ada5e7751ce917e796cdd04322bd3f">operator_check</a> (exp, pos,
<a name="l01878"></a>01878                                                            objfile_func, data))
<a name="l01879"></a>01879         <span class="keywordflow">return</span> 1;
<a name="l01880"></a>01880 
<a name="l01881"></a>01881       endpos = pos;
<a name="l01882"></a>01882     }
<a name="l01883"></a>01883 
<a name="l01884"></a>01884   <span class="keywordflow">return</span> 0;
<a name="l01885"></a>01885 }
<a name="l01886"></a>01886 
<a name="l01887"></a>01887 <span class="comment">/* Helper for exp_uses_objfile.  */</span>
<a name="l01888"></a>01888 
<a name="l01889"></a>01889 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01890"></a>01890 exp_uses_objfile_iter (<span class="keyword">struct</span> objfile *exp_objfile, <span class="keywordtype">void</span> *objfile_voidp)
<a name="l01891"></a>01891 {
<a name="l01892"></a>01892   <span class="keyword">struct </span>objfile *objfile = objfile_voidp;
<a name="l01893"></a>01893 
<a name="l01894"></a>01894   <span class="keywordflow">if</span> (exp_objfile-&gt;<a class="code" href="structobjfile.html#a1ef5fed06f7a9c5864c9a0ce46a87710">separate_debug_objfile_backlink</a>)
<a name="l01895"></a>01895     exp_objfile = exp_objfile-&gt;<a class="code" href="structobjfile.html#a1ef5fed06f7a9c5864c9a0ce46a87710">separate_debug_objfile_backlink</a>;
<a name="l01896"></a>01896 
<a name="l01897"></a>01897   <span class="keywordflow">return</span> exp_objfile == objfile;
<a name="l01898"></a>01898 }
<a name="l01899"></a>01899 
<a name="l01900"></a>01900 <span class="comment">/* Return 1 if EXP uses OBJFILE (and will become dangling when OBJFILE</span>
<a name="l01901"></a>01901 <span class="comment">   is unloaded), otherwise return 0.  OBJFILE must not be a separate debug info</span>
<a name="l01902"></a>01902 <span class="comment">   file.  */</span>
<a name="l01903"></a>01903 
<a name="l01904"></a>01904 <span class="keywordtype">int</span>
<a name="l01905"></a><a class="code" href="parser-defs_8h.html#adec7454ce368ba160241209a1e9a12b4">01905</a> <a class="code" href="parse_8c.html#a3df56a662b304ee72766f154d7890b6b">exp_uses_objfile</a> (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp, <span class="keyword">struct</span> objfile *objfile)
<a name="l01906"></a>01906 {
<a name="l01907"></a>01907   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (objfile-&gt;<a class="code" href="structobjfile.html#a1ef5fed06f7a9c5864c9a0ce46a87710">separate_debug_objfile_backlink</a> == NULL);
<a name="l01908"></a>01908 
<a name="l01909"></a>01909   <span class="keywordflow">return</span> exp_iterate (exp, exp_uses_objfile_iter, objfile);
<a name="l01910"></a>01910 }
<a name="l01911"></a>01911 
<a name="l01912"></a>01912 <span class="keywordtype">void</span>
<a name="l01913"></a><a class="code" href="init_8c.html#acf8a218d8b4b0cdb6759cf71c07243aa">01913</a> <a class="code" href="init_8c.html#acf8a218d8b4b0cdb6759cf71c07243aa">_initialize_parse</a> (<span class="keywordtype">void</span>)
<a name="l01914"></a>01914 {
<a name="l01915"></a>01915   <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#aff3ad06253c1369f85a6751b6adf3d02">size</a> = 0;
<a name="l01916"></a>01916   <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a3b56065aa6a784fb6cbdba9d6205a66b">depth</a> = 0;
<a name="l01917"></a>01917   <a class="code" href="structtype__stack.html">type_stack</a>.<a class="code" href="structtype__stack.html#a4b5c75cd75a3aafd33327f827aeb7c4f">elements</a> = NULL;
<a name="l01918"></a>01918 
<a name="l01919"></a>01919   <a class="code" href="cli-decode_8c.html#ae32b914a6e0676efa41e6281007a75c1">add_setshow_zuinteger_cmd</a> (<span class="stringliteral">&quot;expression&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a502c7b57c7172ac88ef735f68070bb59">class_maintenance</a>,
<a name="l01920"></a>01920                              &amp;expressiondebug,
<a name="l01921"></a>01921                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Set expression debugging.&quot;</span>),
<a name="l01922"></a>01922                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Show expression debugging.&quot;</span>),
<a name="l01923"></a>01923                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;When non-zero, the internal representation &quot;</span>
<a name="l01924"></a>01924                                <span class="stringliteral">&quot;of expressions will be printed.&quot;</span>),
<a name="l01925"></a>01925                              NULL,
<a name="l01926"></a>01926                              show_expressiondebug,
<a name="l01927"></a>01927                              &amp;<a class="code" href="cli-cmds_8c.html#ae5f16c782e4a29124f3175f4a6285244">setdebuglist</a>, &amp;<a class="code" href="cli-cmds_8c.html#a7e2eed475764f70df1e9c0f5d2476a11">showdebuglist</a>);
<a name="l01928"></a>01928   <a class="code" href="cli-decode_8c.html#ad86a0f135b6c546ae7ffbb41fd72e14f">add_setshow_boolean_cmd</a> (<span class="stringliteral">&quot;parser&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a502c7b57c7172ac88ef735f68070bb59">class_maintenance</a>,
<a name="l01929"></a>01929                             &amp;<a class="code" href="parse_8c.html#a20ba618f37578ad21378433550516222">parser_debug</a>,
<a name="l01930"></a>01930                            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Set parser debugging.&quot;</span>),
<a name="l01931"></a>01931                            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Show parser debugging.&quot;</span>),
<a name="l01932"></a>01932                            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;When non-zero, expression parser &quot;</span>
<a name="l01933"></a>01933                              <span class="stringliteral">&quot;tracing will be enabled.&quot;</span>),
<a name="l01934"></a>01934                             NULL,
<a name="l01935"></a>01935                             show_parserdebug,
<a name="l01936"></a>01936                             &amp;<a class="code" href="cli-cmds_8c.html#ae5f16c782e4a29124f3175f4a6285244">setdebuglist</a>, &amp;<a class="code" href="cli-cmds_8c.html#a7e2eed475764f70df1e9c0f5d2476a11">showdebuglist</a>);
<a name="l01937"></a>01937 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:12:21 for GDB (API) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
