<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (API): /home/stan/gdb/src/gdb/coffread.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (API)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/coffread.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="coffread_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Read coff symbol tables and convert to internal format, for GDB.</span>
<a name="l00002"></a>00002 <span class="comment">   Copyright (C) 1987-2013 Free Software Foundation, Inc.</span>
<a name="l00003"></a>00003 <span class="comment">   Contributed by David D. Johnson, Brown University (ddj@cs.brown.edu).</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   This file is part of GDB.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00010"></a>00010 <span class="comment">   (at your option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00018"></a>00018 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="gdbtypes_8h.html">gdbtypes.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;demangle.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="breakpoint_8h.html">breakpoint.h</a>&quot;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;bfd.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="gdb__obstack_8h.html">gdb_obstack.h</a>&quot;</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="gdb__string_8h.html">gdb_string.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;coff/internal.h&quot;</span>      <span class="comment">/* Internal format of COFF symbols in BFD */</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;libcoff.h&quot;</span>            <span class="comment">/* FIXME secret internal data from BFD */</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="objfiles_8h.html">objfiles.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="buildsym_8h.html">buildsym.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="gdb-stabs_8h.html">gdb-stabs.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="stabsread_8h.html">stabsread.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="complaints_8h.html">complaints.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="target_8h.html">target.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="gdb__assert_8h.html">gdb_assert.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="block_8h.html">block.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="dictionary_8h.html">dictionary.h</a>&quot;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="coff-pe-read_8h.html">coff-pe-read.h</a>&quot;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;<a class="code" href="psymtab_8h.html">psymtab.h</a>&quot;</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="init_8c.html#a5bdf181feb330a434255a2eacb09f820">_initialize_coffread</a> (<span class="keywordtype">void</span>);
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="comment">/* Key for COFF-associated data.  */</span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>objfile_data *coff_objfile_data_key;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">/* The objfile we are currently reading.  */</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *coffread_objfile;
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="keyword">struct </span>coff_symfile_info
<a name="l00059"></a>00059   {
<a name="l00060"></a>00060     file_ptr min_lineno_offset; <span class="comment">/* Where in file lowest line#s are.  */</span>
<a name="l00061"></a>00061     file_ptr max_lineno_offset; <span class="comment">/* 1+last byte of line#s in file.  */</span>
<a name="l00062"></a>00062 
<a name="l00063"></a>00063     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> textaddr;         <span class="comment">/* Addr of .text section.  */</span>
<a name="l00064"></a>00064     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> textsize;      <span class="comment">/* Size of .text section.  */</span>
<a name="l00065"></a>00065     <span class="keyword">struct </span><a class="code" href="structstab__section__list.html">stab_section_list</a> *stabsects;        <span class="comment">/* .stab sections.  */</span>
<a name="l00066"></a>00066     asection *stabstrsect;      <span class="comment">/* Section pointer for .stab section.  */</span>
<a name="l00067"></a>00067     <span class="keywordtype">char</span> *stabstrdata;
<a name="l00068"></a>00068   };
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="comment">/* Translate an external name string into a user-visible name.  */</span>
<a name="l00071"></a><a class="code" href="coffread_8c.html#ad0ce851a5c1199535edf32fd6d254502">00071</a> <span class="preprocessor">#define EXTERNAL_NAME(string, abfd) \</span>
<a name="l00072"></a>00072 <span class="preprocessor">        (string[0] == bfd_get_symbol_leading_char (abfd) \</span>
<a name="l00073"></a>00073 <span class="preprocessor">        ? string + 1 : string)</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span>
<a name="l00075"></a>00075 <span class="comment">/* To be an sdb debug type, type must have at least a basic or primary</span>
<a name="l00076"></a>00076 <span class="comment">   derived type.  Using this rather than checking against T_NULL is</span>
<a name="l00077"></a>00077 <span class="comment">   said to prevent core dumps if we try to operate on Michael Bloom</span>
<a name="l00078"></a>00078 <span class="comment">   dbx-in-coff file.  */</span>
<a name="l00079"></a>00079 
<a name="l00080"></a><a class="code" href="coffread_8c.html#a524571ce1b33bf4a8a0b63de733e8789">00080</a> <span class="preprocessor">#define SDB_TYPE(type) (BTYPE(type) | (type &amp; N_TMASK))</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span>
<a name="l00082"></a>00082 <span class="comment">/* Core address of start and end of text of current source file.</span>
<a name="l00083"></a>00083 <span class="comment">   This comes from a &quot;.text&quot; symbol where x_nlinno &gt; 0.  */</span>
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> current_source_start_addr;
<a name="l00086"></a>00086 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> current_source_end_addr;
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="comment">/* The addresses of the symbol table stream and number of symbols</span>
<a name="l00089"></a>00089 <span class="comment">   of the object file we are reading (as copied into core).  */</span>
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="keyword">static</span> bfd *nlist_bfd_global;
<a name="l00092"></a>00092 <span class="keyword">static</span> <span class="keywordtype">int</span> nlist_nsyms_global;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="comment">/* Pointers to scratch storage, used for reading raw symbols and</span>
<a name="l00096"></a>00096 <span class="comment">   auxents.  */</span>
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="keyword">static</span> <span class="keywordtype">char</span> *temp_sym;
<a name="l00099"></a>00099 <span class="keyword">static</span> <span class="keywordtype">char</span> *temp_aux;
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="comment">/* Local variables that hold the shift and mask values for the</span>
<a name="l00102"></a>00102 <span class="comment">   COFF file that we are currently reading.  These come back to us</span>
<a name="l00103"></a>00103 <span class="comment">   from BFD, and are referenced by their macro names, as well as</span>
<a name="l00104"></a>00104 <span class="comment">   internally to the BTYPE, ISPTR, ISFCN, ISARY, ISTAG, and DECREF</span>
<a name="l00105"></a>00105 <span class="comment">   macros from include/coff/internal.h .  */</span>
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> local_n_btmask;
<a name="l00108"></a>00108 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> local_n_btshft;
<a name="l00109"></a>00109 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> local_n_tmask;
<a name="l00110"></a>00110 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> local_n_tshift;
<a name="l00111"></a>00111 
<a name="l00112"></a><a class="code" href="coffread_8c.html#a78aef007804b13d1913a62b3191ba275">00112</a> <span class="preprocessor">#define N_BTMASK        local_n_btmask</span>
<a name="l00113"></a><a class="code" href="coffread_8c.html#a82bfac14e79312143bbfa58439d96283">00113</a> <span class="preprocessor"></span><span class="preprocessor">#define N_BTSHFT        local_n_btshft</span>
<a name="l00114"></a><a class="code" href="coffread_8c.html#a5cc1b847217b70afa9527ea731874f3e">00114</a> <span class="preprocessor"></span><span class="preprocessor">#define N_TMASK         local_n_tmask</span>
<a name="l00115"></a><a class="code" href="coffread_8c.html#af62895c0f111e1413558bd3ad139c855">00115</a> <span class="preprocessor"></span><span class="preprocessor">#define N_TSHIFT        local_n_tshift</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span>
<a name="l00117"></a>00117 <span class="comment">/* Local variables that hold the sizes in the file of various COFF</span>
<a name="l00118"></a>00118 <span class="comment">   structures.  (We only need to know this to read them from the file</span>
<a name="l00119"></a>00119 <span class="comment">   -- BFD will then translate the data in them, into `internal_xxx&#39;</span>
<a name="l00120"></a>00120 <span class="comment">   structs in the right byte order, alignment, etc.)  */</span>
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> local_linesz;
<a name="l00123"></a>00123 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> local_symesz;
<a name="l00124"></a>00124 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> local_auxesz;
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="comment">/* This is set if this is a PE format file.  */</span>
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 <span class="keyword">static</span> <span class="keywordtype">int</span> pe_file;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="comment">/* Chain of typedefs of pointers to empty struct/union types.</span>
<a name="l00131"></a>00131 <span class="comment">   They are chained thru the SYMBOL_VALUE_CHAIN.  */</span>
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *opaque_type_chain[<a class="code" href="buildsym_8h.html#a2b4054af9a8f1ec4104846747ded1675">HASHSIZE</a>];
<a name="l00134"></a>00134 
<a name="l00135"></a>00135 <span class="comment">/* Simplified internal version of coff symbol table information.  */</span>
<a name="l00136"></a>00136 
<a name="l00137"></a>00137 <span class="keyword">struct </span>coff_symbol
<a name="l00138"></a>00138   {
<a name="l00139"></a>00139     <span class="keywordtype">char</span> *c_name;
<a name="l00140"></a>00140     <span class="keywordtype">int</span> c_symnum;               <span class="comment">/* Symbol number of this entry.  */</span>
<a name="l00141"></a>00141     <span class="keywordtype">int</span> c_naux;                 <span class="comment">/* 0 if syment only, 1 if syment +</span>
<a name="l00142"></a>00142 <span class="comment">                                   auxent, etc.  */</span>
<a name="l00143"></a>00143     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> c_value;
<a name="l00144"></a>00144     <span class="keywordtype">int</span> c_sclass;
<a name="l00145"></a>00145     <span class="keywordtype">int</span> c_secnum;
<a name="l00146"></a>00146     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c_type;
<a name="l00147"></a>00147   };
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="comment">/* Vector of types defined so far, indexed by their type numbers.  */</span>
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> **type_vector;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="comment">/* Number of elements allocated for type_vector currently.  */</span>
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 <span class="keyword">static</span> <span class="keywordtype">int</span> type_vector_length;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <span class="comment">/* Initial size of type vector.  Is realloc&#39;d larger if needed, and</span>
<a name="l00158"></a>00158 <span class="comment">   realloc&#39;d down to the size actually used, when completed.  */</span>
<a name="l00159"></a>00159 
<a name="l00160"></a><a class="code" href="coffread_8c.html#a860c01b52099d41e71894ed50296fcb1">00160</a> <span class="preprocessor">#define INITIAL_TYPE_VECTOR_LENGTH 160</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span>
<a name="l00162"></a>00162 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="coffread_8c.html#aaf92fbf8bca35c59f653dff4d1ad8e1f">stabsread_clear_cache</a> (<span class="keywordtype">void</span>);
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *coff_read_struct_type (<span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>,
<a name="l00165"></a>00165                                            <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *decode_base_type (<span class="keyword">struct</span> coff_symbol *,
<a name="l00168"></a>00168                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>,
<a name="l00169"></a>00169                                       <span class="keyword">union</span> internal_auxent *,
<a name="l00170"></a>00170                                       <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *decode_type (<span class="keyword">struct</span> coff_symbol *, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>,
<a name="l00173"></a>00173                                  <span class="keyword">union</span> internal_auxent *,
<a name="l00174"></a>00174                                  <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *decode_function_type (<span class="keyword">struct</span> coff_symbol *,
<a name="l00177"></a>00177                                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>,
<a name="l00178"></a>00178                                           <span class="keyword">union</span> internal_auxent *,
<a name="l00179"></a>00179                                           <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *coff_read_enum_type (<span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>,
<a name="l00182"></a>00182                                          <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *process_coff_symbol (<span class="keyword">struct</span> coff_symbol *,
<a name="l00185"></a>00185                                            <span class="keyword">union</span> internal_auxent *,
<a name="l00186"></a>00186                                            <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="keyword">static</span> <span class="keywordtype">void</span> patch_opaque_types (<span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *);
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 <span class="keyword">static</span> <span class="keywordtype">void</span> enter_linenos (<span class="keywordtype">long</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 <span class="keyword">static</span> <span class="keywordtype">void</span> free_linetab (<span class="keywordtype">void</span>);
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 <span class="keyword">static</span> <span class="keywordtype">void</span> free_linetab_cleanup (<span class="keywordtype">void</span> *ignore);
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 <span class="keyword">static</span> <span class="keywordtype">int</span> init_lineno (bfd *, <span class="keywordtype">long</span>, <span class="keywordtype">int</span>);
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 <span class="keyword">static</span> <span class="keywordtype">char</span> *getsymname (<span class="keyword">struct</span> internal_syment *);
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *coff_getfilename (<span class="keyword">union</span> internal_auxent *);
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 <span class="keyword">static</span> <span class="keywordtype">void</span> free_stringtab (<span class="keywordtype">void</span>);
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="keyword">static</span> <span class="keywordtype">void</span> free_stringtab_cleanup (<span class="keywordtype">void</span> *ignore);
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 <span class="keyword">static</span> <span class="keywordtype">int</span> init_stringtab (bfd *, <span class="keywordtype">long</span>);
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 <span class="keyword">static</span> <span class="keywordtype">void</span> read_one_sym (<span class="keyword">struct</span> coff_symbol *,
<a name="l00209"></a>00209                           <span class="keyword">struct</span> internal_syment *,
<a name="l00210"></a>00210                           <span class="keyword">union</span> internal_auxent *);
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="keyword">static</span> <span class="keywordtype">void</span> coff_symtab_read (<span class="keywordtype">long</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00213"></a>00213 
<a name="l00214"></a>00214 <span class="comment">/* We are called once per section from coff_symfile_read.  We</span>
<a name="l00215"></a>00215 <span class="comment">   need to examine each section we are passed, check to see</span>
<a name="l00216"></a>00216 <span class="comment">   if it is something we are interested in processing, and</span>
<a name="l00217"></a>00217 <span class="comment">   if so, stash away some access information for the section.</span>
<a name="l00218"></a>00218 <span class="comment"></span>
<a name="l00219"></a>00219 <span class="comment">   FIXME: The section names should not be hardwired strings (what</span>
<a name="l00220"></a>00220 <span class="comment">   should they be?  I don&#39;t think most object file formats have enough</span>
<a name="l00221"></a>00221 <span class="comment">   section flags to specify what kind of debug section it is</span>
<a name="l00222"></a>00222 <span class="comment">   -kingdon).  */</span>
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00225"></a>00225 coff_locate_sections (bfd *abfd, asection *sectp, <span class="keywordtype">void</span> *csip)
<a name="l00226"></a>00226 {
<a name="l00227"></a>00227   <span class="keyword">struct </span>coff_symfile_info *csi;
<a name="l00228"></a>00228   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l00229"></a>00229 
<a name="l00230"></a>00230   csi = (<span class="keyword">struct </span>coff_symfile_info *) csip;
<a name="l00231"></a>00231   name = bfd_get_section_name (abfd, sectp);
<a name="l00232"></a>00232   <span class="keywordflow">if</span> (strcmp (name, <span class="stringliteral">&quot;.text&quot;</span>) == 0)
<a name="l00233"></a>00233     {
<a name="l00234"></a>00234       csi-&gt;textaddr = bfd_section_vma (abfd, sectp);
<a name="l00235"></a>00235       csi-&gt;textsize += bfd_section_size (abfd, sectp);
<a name="l00236"></a>00236     }
<a name="l00237"></a>00237   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp (name, <span class="stringliteral">&quot;.text&quot;</span>, <span class="keyword">sizeof</span> <span class="stringliteral">&quot;.text&quot;</span> - 1) == 0)
<a name="l00238"></a>00238     {
<a name="l00239"></a>00239       csi-&gt;textsize += bfd_section_size (abfd, sectp);
<a name="l00240"></a>00240     }
<a name="l00241"></a>00241   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (name, <span class="stringliteral">&quot;.stabstr&quot;</span>) == 0)
<a name="l00242"></a>00242     {
<a name="l00243"></a>00243       csi-&gt;stabstrsect = sectp;
<a name="l00244"></a>00244     }
<a name="l00245"></a>00245   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp (name, <span class="stringliteral">&quot;.stab&quot;</span>, <span class="keyword">sizeof</span> <span class="stringliteral">&quot;.stab&quot;</span> - 1) == 0)
<a name="l00246"></a>00246     {
<a name="l00247"></a>00247       <span class="keyword">const</span> <span class="keywordtype">char</span> *s;
<a name="l00248"></a>00248 
<a name="l00249"></a>00249       <span class="comment">/* We can have multiple .stab sections if linked with</span>
<a name="l00250"></a>00250 <span class="comment">         --split-by-reloc.  */</span>
<a name="l00251"></a>00251       <span class="keywordflow">for</span> (s = name + <span class="keyword">sizeof</span> <span class="stringliteral">&quot;.stab&quot;</span> - 1; *s != <span class="charliteral">&#39;\0&#39;</span>; s++)
<a name="l00252"></a>00252         <span class="keywordflow">if</span> (!isdigit (*s))
<a name="l00253"></a>00253           <span class="keywordflow">break</span>;
<a name="l00254"></a>00254       <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l00255"></a>00255         {
<a name="l00256"></a>00256           <span class="keyword">struct </span><a class="code" href="structstab__section__list.html">stab_section_list</a> *n, **pn;
<a name="l00257"></a>00257 
<a name="l00258"></a>00258           n = ((<span class="keyword">struct </span><a class="code" href="structstab__section__list.html">stab_section_list</a> *)
<a name="l00259"></a>00259                <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structstab__section__list.html">stab_section_list</a>)));
<a name="l00260"></a>00260           n-&gt;<a class="code" href="structstab__section__list.html#a4986a8751d40744b3b6423afb7c1d58d">section</a> = sectp;
<a name="l00261"></a>00261           n-&gt;<a class="code" href="structstab__section__list.html#a24ca386e119bc6443d0c00f146a8d2b8">next</a> = NULL;
<a name="l00262"></a>00262           <span class="keywordflow">for</span> (pn = &amp;csi-&gt;stabsects; *pn != NULL; pn = &amp;(*pn)-&gt;<a class="code" href="structstab__section__list.html#a24ca386e119bc6443d0c00f146a8d2b8">next</a>)
<a name="l00263"></a>00263             ;
<a name="l00264"></a>00264           *pn = n;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266           <span class="comment">/* This will be run after coffstab_build_psymtabs is called</span>
<a name="l00267"></a>00267 <span class="comment">             in coff_symfile_read, at which point we no longer need</span>
<a name="l00268"></a>00268 <span class="comment">             the information.  */</span>
<a name="l00269"></a>00269           <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, n);
<a name="l00270"></a>00270         }
<a name="l00271"></a>00271     }
<a name="l00272"></a>00272 }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 <span class="comment">/* Return the section_offsets* that CS points to.  */</span>
<a name="l00275"></a>00275 <span class="keyword">static</span> <span class="keywordtype">int</span> cs_to_section (<span class="keyword">struct</span> coff_symbol *, <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="keyword">struct </span>find_targ_sec_arg
<a name="l00278"></a>00278   {
<a name="l00279"></a>00279     <span class="keywordtype">int</span> targ_index;
<a name="l00280"></a>00280     asection **resultp;
<a name="l00281"></a>00281   };
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00284"></a>00284 find_targ_sec (bfd *abfd, asection *sect, <span class="keywordtype">void</span> *obj)
<a name="l00285"></a>00285 {
<a name="l00286"></a>00286   <span class="keyword">struct </span>find_targ_sec_arg *args = (<span class="keyword">struct </span>find_targ_sec_arg *) obj;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   <span class="keywordflow">if</span> (sect-&gt;target_index == args-&gt;targ_index)
<a name="l00289"></a>00289     *args-&gt;resultp = sect;
<a name="l00290"></a>00290 }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 <span class="comment">/* Return the bfd_section that CS points to.  */</span>
<a name="l00293"></a>00293 <span class="keyword">static</span> <span class="keyword">struct </span>bfd_section*
<a name="l00294"></a>00294 cs_to_bfd_section (<span class="keyword">struct</span> coff_symbol *cs, <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>)
<a name="l00295"></a>00295 {
<a name="l00296"></a>00296   asection *sect = NULL;
<a name="l00297"></a>00297   <span class="keyword">struct </span>find_targ_sec_arg args;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299   args.targ_index = cs-&gt;c_secnum;
<a name="l00300"></a>00300   args.resultp = &amp;sect;
<a name="l00301"></a>00301   bfd_map_over_sections (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>, find_targ_sec, &amp;args);
<a name="l00302"></a>00302   <span class="keywordflow">return</span> sect;
<a name="l00303"></a>00303 }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 <span class="comment">/* Return the section number (SECT_OFF_*) that CS points to.  */</span>
<a name="l00306"></a>00306 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00307"></a>00307 cs_to_section (<span class="keyword">struct</span> coff_symbol *cs, <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>)
<a name="l00308"></a>00308 {
<a name="l00309"></a>00309   asection *sect = cs_to_bfd_section (cs, objfile);
<a name="l00310"></a>00310 
<a name="l00311"></a>00311   <span class="keywordflow">if</span> (sect == NULL)
<a name="l00312"></a>00312     <span class="keywordflow">return</span> <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile);
<a name="l00313"></a>00313   <span class="keywordflow">return</span> <a class="code" href="gdb__bfd_8c.html#a84e2e9693416658ad0fae083d8bbdd04">gdb_bfd_section_index</a> (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>, sect);
<a name="l00314"></a>00314 }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="comment">/* Return the address of the section of a COFF symbol.  */</span>
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> cs_section_address (<span class="keyword">struct</span> coff_symbol *, bfd *);
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l00321"></a>00321 cs_section_address (<span class="keyword">struct</span> coff_symbol *cs, bfd *abfd)
<a name="l00322"></a>00322 {
<a name="l00323"></a>00323   asection *sect = NULL;
<a name="l00324"></a>00324   <span class="keyword">struct </span>find_targ_sec_arg args;
<a name="l00325"></a>00325   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr = 0;
<a name="l00326"></a>00326 
<a name="l00327"></a>00327   args.targ_index = cs-&gt;c_secnum;
<a name="l00328"></a>00328   args.resultp = &amp;sect;
<a name="l00329"></a>00329   bfd_map_over_sections (abfd, find_targ_sec, &amp;args);
<a name="l00330"></a>00330   <span class="keywordflow">if</span> (sect != NULL)
<a name="l00331"></a>00331     addr = bfd_get_section_vma (abfd, sect);
<a name="l00332"></a>00332   <span class="keywordflow">return</span> addr;
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="comment">/* Look up a coff type-number index.  Return the address of the slot</span>
<a name="l00336"></a>00336 <span class="comment">   where the type for that index is stored.</span>
<a name="l00337"></a>00337 <span class="comment">   The type-number is in INDEX. </span>
<a name="l00338"></a>00338 <span class="comment"></span>
<a name="l00339"></a>00339 <span class="comment">   This can be used for finding the type associated with that index</span>
<a name="l00340"></a>00340 <span class="comment">   or for associating a new type with the index.  */</span>
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> **
<a name="l00343"></a>00343 coff_lookup_type (<span class="keywordtype">int</span> index)
<a name="l00344"></a>00344 {
<a name="l00345"></a>00345   <span class="keywordflow">if</span> (index &gt;= type_vector_length)
<a name="l00346"></a>00346     {
<a name="l00347"></a>00347       <span class="keywordtype">int</span> old_vector_length = type_vector_length;
<a name="l00348"></a>00348 
<a name="l00349"></a>00349       type_vector_length *= 2;
<a name="l00350"></a>00350       <span class="keywordflow">if</span> (index <span class="comment">/* is still */</span>  &gt;= type_vector_length)
<a name="l00351"></a>00351         type_vector_length = index * 2;
<a name="l00352"></a>00352 
<a name="l00353"></a>00353       type_vector = (<span class="keyword">struct </span><a class="code" href="structtype.html">type</a> **)
<a name="l00354"></a>00354         <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> ((<span class="keywordtype">char</span> *) type_vector,
<a name="l00355"></a>00355                   type_vector_length * <span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *));
<a name="l00356"></a>00356       <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;type_vector[old_vector_length], 0,
<a name="l00357"></a>00357          (type_vector_length - old_vector_length) * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *));
<a name="l00358"></a>00358     }
<a name="l00359"></a>00359   <span class="keywordflow">return</span> &amp;type_vector[index];
<a name="l00360"></a>00360 }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="comment">/* Make sure there is a type allocated for type number index</span>
<a name="l00363"></a>00363 <span class="comment">   and return the type object.</span>
<a name="l00364"></a>00364 <span class="comment">   This can create an empty (zeroed) type object.  */</span>
<a name="l00365"></a>00365 
<a name="l00366"></a>00366 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l00367"></a>00367 coff_alloc_type (<span class="keywordtype">int</span> index)
<a name="l00368"></a>00368 {
<a name="l00369"></a>00369   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> **type_addr = coff_lookup_type (index);
<a name="l00370"></a>00370   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a> = *type_addr;
<a name="l00371"></a>00371 
<a name="l00372"></a>00372   <span class="comment">/* If we are referring to a type not known at all yet,</span>
<a name="l00373"></a>00373 <span class="comment">     allocate an empty type for it.</span>
<a name="l00374"></a>00374 <span class="comment">     We will fill it in later if we find out how.  */</span>
<a name="l00375"></a>00375   <span class="keywordflow">if</span> (type == NULL)
<a name="l00376"></a>00376     {
<a name="l00377"></a>00377       type = <a class="code" href="gdbtypes_8c.html#a0929c0c96b083ea88998926b06d62d01">alloc_type</a> (coffread_objfile);
<a name="l00378"></a>00378       *type_addr = type;
<a name="l00379"></a>00379     }
<a name="l00380"></a>00380   <span class="keywordflow">return</span> type;
<a name="l00381"></a>00381 }
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 <span class="comment">/* Start a new symtab for a new source file.</span>
<a name="l00384"></a>00384 <span class="comment">   This is called when a COFF &quot;.file&quot; symbol is seen;</span>
<a name="l00385"></a>00385 <span class="comment">   it indicates the start of data for one original source file.  */</span>
<a name="l00386"></a>00386 
<a name="l00387"></a>00387 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00388"></a>00388 coff_start_symtab (<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l00389"></a>00389 {
<a name="l00390"></a>00390   <a class="code" href="buildsym_8c.html#a999baf4228b297244bfae8bbd78cd578">start_symtab</a> (
<a name="l00391"></a>00391   <span class="comment">/* We fill in the filename later.  start_symtab puts this pointer</span>
<a name="l00392"></a>00392 <span class="comment">     into last_source_file and we put it in subfiles-&gt;name, which</span>
<a name="l00393"></a>00393 <span class="comment">     end_symtab frees; that&#39;s why it must be malloc&#39;d.  */</span>
<a name="l00394"></a>00394                  xstrdup (name),
<a name="l00395"></a>00395   <span class="comment">/* We never know the directory name for COFF.  */</span>
<a name="l00396"></a>00396                  NULL,
<a name="l00397"></a>00397   <span class="comment">/* The start address is irrelevant, since we set</span>
<a name="l00398"></a>00398 <span class="comment">     last_source_start_addr in coff_end_symtab.  */</span>
<a name="l00399"></a>00399                  0);
<a name="l00400"></a>00400   <a class="code" href="buildsym_8c.html#a76a92cacc4928e0f51361dd056181de6">record_debugformat</a> (<span class="stringliteral">&quot;COFF&quot;</span>);
<a name="l00401"></a>00401 }
<a name="l00402"></a>00402 
<a name="l00403"></a>00403 <span class="comment">/* Save the vital information from when starting to read a file,</span>
<a name="l00404"></a>00404 <span class="comment">   for use when closing off the current file.</span>
<a name="l00405"></a>00405 <span class="comment">   NAME is the file name the symbols came from, START_ADDR is the</span>
<a name="l00406"></a>00406 <span class="comment">   first text address for the file, and SIZE is the number of bytes of</span>
<a name="l00407"></a>00407 <span class="comment">   text.  */</span>
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00410"></a>00410 <a class="code" href="xcoffread_8c.html#acc6f18948d48e4cae3b78e80636a9848">complete_symtab</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_addr, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>)
<a name="l00411"></a>00411 {
<a name="l00412"></a>00412   <a class="code" href="buildsym_8c.html#a7f829e2a76d56399cfc7885b8fabb15a">set_last_source_file</a> (name);
<a name="l00413"></a>00413   current_source_start_addr = start_addr;
<a name="l00414"></a>00414   current_source_end_addr = start_addr + <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l00415"></a>00415 }
<a name="l00416"></a>00416 
<a name="l00417"></a>00417 <span class="comment">/* Finish the symbol definitions for one main source file, close off</span>
<a name="l00418"></a>00418 <span class="comment">   all the lexical contexts for that file (creating struct block&#39;s for</span>
<a name="l00419"></a>00419 <span class="comment">   them), then make the struct symtab for that file and put it in the</span>
<a name="l00420"></a>00420 <span class="comment">   list of all such.  */</span>
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00423"></a>00423 coff_end_symtab (<span class="keyword">struct</span> objfile *objfile)
<a name="l00424"></a>00424 {
<a name="l00425"></a>00425   <a class="code" href="buildsym_8h.html#af2136b58b1b253d5edc8dfca7f386c57">last_source_start_addr</a> = current_source_start_addr;
<a name="l00426"></a>00426 
<a name="l00427"></a>00427   <a class="code" href="buildsym_8c.html#a29e6795dae4eee97d15ba57c4a411830">end_symtab</a> (current_source_end_addr, objfile,
<a name="l00428"></a>00428               <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l00429"></a>00429 
<a name="l00430"></a>00430   <span class="comment">/* Reinitialize for beginning of new file.  */</span>
<a name="l00431"></a>00431   <a class="code" href="buildsym_8c.html#a7f829e2a76d56399cfc7885b8fabb15a">set_last_source_file</a> (NULL);
<a name="l00432"></a>00432 }
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 <span class="comment">/* The linker sometimes generates some non-function symbols inside</span>
<a name="l00435"></a>00435 <span class="comment">   functions referencing variables imported from another DLL.</span>
<a name="l00436"></a>00436 <span class="comment">   Return nonzero if the given symbol corresponds to one of them.  */</span>
<a name="l00437"></a>00437 
<a name="l00438"></a>00438 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00439"></a>00439 is_import_fixup_symbol (<span class="keyword">struct</span> coff_symbol *cs,
<a name="l00440"></a>00440                         <span class="keyword">enum</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036">minimal_symbol_type</a> type)
<a name="l00441"></a>00441 {
<a name="l00442"></a>00442   <span class="comment">/* The following is a bit of a heuristic using the characterictics</span>
<a name="l00443"></a>00443 <span class="comment">     of these fixup symbols, but should work well in practice...  */</span>
<a name="l00444"></a>00444   <span class="keywordtype">int</span> i;
<a name="l00445"></a>00445 
<a name="l00446"></a>00446   <span class="comment">/* Must be a non-static text symbol.  */</span>
<a name="l00447"></a>00447   <span class="keywordflow">if</span> (type != <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036af24db58d8996f50560c2f03d9c8514c0">mst_text</a>)
<a name="l00448"></a>00448     <span class="keywordflow">return</span> 0;
<a name="l00449"></a>00449 
<a name="l00450"></a>00450   <span class="comment">/* Must be a non-function symbol.  */</span>
<a name="l00451"></a>00451   <span class="keywordflow">if</span> (ISFCN (cs-&gt;c_type))
<a name="l00452"></a>00452     <span class="keywordflow">return</span> 0;
<a name="l00453"></a>00453 
<a name="l00454"></a>00454   <span class="comment">/* The name must start with &quot;__fu&lt;digits&gt;__&quot;.  */</span>
<a name="l00455"></a>00455   <span class="keywordflow">if</span> (strncmp (cs-&gt;c_name, <span class="stringliteral">&quot;__fu&quot;</span>, 4) != 0)
<a name="l00456"></a>00456     <span class="keywordflow">return</span> 0;
<a name="l00457"></a>00457   <span class="keywordflow">if</span> (! isdigit (cs-&gt;c_name[4]))
<a name="l00458"></a>00458     <span class="keywordflow">return</span> 0;
<a name="l00459"></a>00459   <span class="keywordflow">for</span> (i = 5; cs-&gt;c_name[i] != <span class="charliteral">&#39;\0&#39;</span> &amp;&amp; isdigit (cs-&gt;c_name[i]); i++)
<a name="l00460"></a>00460     <span class="comment">/* Nothing, just incrementing index past all digits.  */</span>;
<a name="l00461"></a>00461   <span class="keywordflow">if</span> (cs-&gt;c_name[i] != <span class="charliteral">&#39;_&#39;</span> || cs-&gt;c_name[i + 1] != <span class="charliteral">&#39;_&#39;</span>)
<a name="l00462"></a>00462     <span class="keywordflow">return</span> 0;
<a name="l00463"></a>00463 
<a name="l00464"></a>00464   <span class="keywordflow">return</span> 1;
<a name="l00465"></a>00465 }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *
<a name="l00468"></a>00468 record_minimal_symbol (<span class="keyword">struct</span> coff_symbol *cs, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address,
<a name="l00469"></a>00469                        <span class="keyword">enum</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036">minimal_symbol_type</a> type, <span class="keywordtype">int</span> section, 
<a name="l00470"></a>00470                        <span class="keyword">struct</span> objfile *objfile)
<a name="l00471"></a>00471 {
<a name="l00472"></a>00472   <span class="comment">/* We don&#39;t want TDESC entry points in the minimal symbol table.  */</span>
<a name="l00473"></a>00473   <span class="keywordflow">if</span> (cs-&gt;c_name[0] == <span class="charliteral">&#39;@&#39;</span>)
<a name="l00474"></a>00474     <span class="keywordflow">return</span> NULL;
<a name="l00475"></a>00475 
<a name="l00476"></a>00476   <span class="keywordflow">if</span> (is_import_fixup_symbol (cs, type))
<a name="l00477"></a>00477     {
<a name="l00478"></a>00478       <span class="comment">/* Because the value of these symbols is within a function code</span>
<a name="l00479"></a>00479 <span class="comment">         range, these symbols interfere with the symbol-from-address</span>
<a name="l00480"></a>00480 <span class="comment">         reverse lookup; this manifests itselfs in backtraces, or any</span>
<a name="l00481"></a>00481 <span class="comment">         other commands that prints symbolic addresses.  Just pretend</span>
<a name="l00482"></a>00482 <span class="comment">         these symbols do not exist.  */</span>
<a name="l00483"></a>00483       <span class="keywordflow">return</span> NULL;
<a name="l00484"></a>00484     }
<a name="l00485"></a>00485 
<a name="l00486"></a>00486   <span class="keywordflow">return</span> <a class="code" href="minsyms_8c.html#af22e2bd261d3a8b482b7f848b5ccc845">prim_record_minimal_symbol_and_info</a> (cs-&gt;c_name, address,
<a name="l00487"></a>00487                                               type, section, objfile);
<a name="l00488"></a>00488 }
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 <span class="comment">/* coff_symfile_init ()</span>
<a name="l00491"></a>00491 <span class="comment">   is the coff-specific initialization routine for reading symbols.</span>
<a name="l00492"></a>00492 <span class="comment">   It is passed a struct objfile which contains, among other things,</span>
<a name="l00493"></a>00493 <span class="comment">   the BFD for the file whose symbols are being read, and a slot for</span>
<a name="l00494"></a>00494 <span class="comment">   a pointer to &quot;private data&quot; which we fill with cookies and other</span>
<a name="l00495"></a>00495 <span class="comment">   treats for coff_symfile_read ().</span>
<a name="l00496"></a>00496 <span class="comment"></span>
<a name="l00497"></a>00497 <span class="comment">   We will only be called if this is a COFF or COFF-like file.  BFD</span>
<a name="l00498"></a>00498 <span class="comment">   handles figuring out the format of the file, and code in symtab.c</span>
<a name="l00499"></a>00499 <span class="comment">   uses BFD&#39;s determination to vector to us.</span>
<a name="l00500"></a>00500 <span class="comment"></span>
<a name="l00501"></a>00501 <span class="comment">   The ultimate result is a new symtab (or, FIXME, eventually a</span>
<a name="l00502"></a>00502 <span class="comment">   psymtab).  */</span>
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00505"></a>00505 coff_symfile_init (<span class="keyword">struct</span> objfile *objfile)
<a name="l00506"></a>00506 {
<a name="l00507"></a>00507   <span class="keyword">struct </span><a class="code" href="structdbx__symfile__info.html">dbx_symfile_info</a> *dbx;
<a name="l00508"></a>00508   <span class="keyword">struct </span>coff_symfile_info *coff;
<a name="l00509"></a>00509 
<a name="l00510"></a>00510   <span class="comment">/* Allocate struct to keep track of stab reading.  */</span>
<a name="l00511"></a>00511   dbx = XCNEW (<span class="keyword">struct</span> <a class="code" href="structdbx__symfile__info.html">dbx_symfile_info</a>);
<a name="l00512"></a>00512   set_objfile_data (objfile, <a class="code" href="dbxread_8c.html#a702bf67931faf9cc1c48579e364be5f7">dbx_objfile_data_key</a>, dbx);
<a name="l00513"></a>00513 
<a name="l00514"></a>00514   <span class="comment">/* Allocate struct to keep track of the symfile.  */</span>
<a name="l00515"></a>00515   coff = XCNEW (<span class="keyword">struct</span> coff_symfile_info);
<a name="l00516"></a>00516   set_objfile_data (objfile, coff_objfile_data_key, coff);
<a name="l00517"></a>00517 
<a name="l00518"></a>00518   <span class="comment">/* COFF objects may be reordered, so set OBJF_REORDERED.  If we</span>
<a name="l00519"></a>00519 <span class="comment">     find this causes a significant slowdown in gdb then we could</span>
<a name="l00520"></a>00520 <span class="comment">     set it in the debug symbol readers only when necessary.  */</span>
<a name="l00521"></a>00521   objfile-&gt;<a class="code" href="structobjfile.html#a07578e542db3b2a277e146b24adf007e">flags</a> |= <a class="code" href="objfiles_8h.html#aebdb0f14c149fa8267a184b55130c4c6">OBJF_REORDERED</a>;
<a name="l00522"></a>00522 }
<a name="l00523"></a>00523 
<a name="l00524"></a>00524 <span class="comment">/* This function is called for every section; it finds the outer</span>
<a name="l00525"></a>00525 <span class="comment">   limits of the line table (minimum and maximum file offset) so that</span>
<a name="l00526"></a>00526 <span class="comment">   the mainline code can read the whole thing for efficiency.  */</span>
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00529"></a>00529 find_linenos (bfd *abfd, <span class="keyword">struct</span> bfd_section *asect, <span class="keywordtype">void</span> *vpinfo)
<a name="l00530"></a>00530 {
<a name="l00531"></a>00531   <span class="keyword">struct </span>coff_symfile_info *info;
<a name="l00532"></a>00532   <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>, count;
<a name="l00533"></a>00533   file_ptr <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, maxoff;
<a name="l00534"></a>00534 
<a name="l00535"></a>00535   <span class="comment">/* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */</span>
<a name="l00536"></a>00536   count = asect-&gt;lineno_count;
<a name="l00537"></a>00537   <span class="comment">/* End of warning.  */</span>
<a name="l00538"></a>00538 
<a name="l00539"></a>00539   <span class="keywordflow">if</span> (count == 0)
<a name="l00540"></a>00540     <span class="keywordflow">return</span>;
<a name="l00541"></a>00541   size = count * local_linesz;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543   info = (<span class="keyword">struct </span>coff_symfile_info *) vpinfo;
<a name="l00544"></a>00544   <span class="comment">/* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */</span>
<a name="l00545"></a>00545   offset = asect-&gt;line_filepos;
<a name="l00546"></a>00546   <span class="comment">/* End of warning.  */</span>
<a name="l00547"></a>00547 
<a name="l00548"></a>00548   <span class="keywordflow">if</span> (offset &lt; info-&gt;min_lineno_offset || info-&gt;min_lineno_offset == 0)
<a name="l00549"></a>00549     info-&gt;min_lineno_offset = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551   maxoff = offset + <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l00552"></a>00552   <span class="keywordflow">if</span> (maxoff &gt; info-&gt;max_lineno_offset)
<a name="l00553"></a>00553     info-&gt;max_lineno_offset = maxoff;
<a name="l00554"></a>00554 }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 
<a name="l00557"></a>00557 <span class="comment">/* The BFD for this file -- only good while we&#39;re actively reading</span>
<a name="l00558"></a>00558 <span class="comment">   symbols into a psymtab or a symtab.  */</span>
<a name="l00559"></a>00559 
<a name="l00560"></a>00560 <span class="keyword">static</span> bfd *symfile_bfd;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 <span class="comment">/* Read a symbol file, after initialization by coff_symfile_init.  */</span>
<a name="l00563"></a>00563 
<a name="l00564"></a>00564 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00565"></a>00565 coff_symfile_read (<span class="keyword">struct</span> objfile *objfile, <span class="keywordtype">int</span> symfile_flags)
<a name="l00566"></a>00566 {
<a name="l00567"></a>00567   <span class="keyword">struct </span>coff_symfile_info *info;
<a name="l00568"></a>00568   <span class="keyword">struct </span><a class="code" href="structdbx__symfile__info.html">dbx_symfile_info</a> *dbxinfo;
<a name="l00569"></a>00569   bfd *abfd = objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>;
<a name="l00570"></a>00570   coff_data_type *cdata = coff_data (abfd);
<a name="l00571"></a>00571   <span class="keywordtype">char</span> *name = bfd_get_filename (abfd);
<a name="l00572"></a>00572   <span class="keywordtype">int</span> val;
<a name="l00573"></a>00573   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_symbols;
<a name="l00574"></a>00574   <span class="keywordtype">int</span> <a class="code" href="structdbx__symfile__info.html#a11f383e80b6f05725cdb458a814bb0fb">symtab_offset</a>;
<a name="l00575"></a>00575   <span class="keywordtype">int</span> stringtab_offset;
<a name="l00576"></a>00576   <span class="keyword">struct </span>cleanup *back_to, *cleanup_minimal_symbols;
<a name="l00577"></a>00577   <span class="keywordtype">int</span> stabstrsize;
<a name="l00578"></a>00578   
<a name="l00579"></a>00579   info = objfile_data (objfile, coff_objfile_data_key);
<a name="l00580"></a>00580   dbxinfo = <a class="code" href="gdb-stabs_8h.html#ae3d582ffe0fc859e54a6bc8963cfba7b">DBX_SYMFILE_INFO</a> (objfile);
<a name="l00581"></a>00581   symfile_bfd = abfd;           <span class="comment">/* Kludge for swap routines.  */</span>
<a name="l00582"></a>00582 
<a name="l00583"></a>00583 <span class="comment">/* WARNING WILL ROBINSON!  ACCESSING BFD-PRIVATE DATA HERE!  FIXME!  */</span>
<a name="l00584"></a>00584   num_symbols = bfd_get_symcount (abfd);        <span class="comment">/* How many syms */</span>
<a name="l00585"></a>00585   symtab_offset = cdata-&gt;sym_filepos;   <span class="comment">/* Symbol table file offset */</span>
<a name="l00586"></a>00586   stringtab_offset = symtab_offset +    <span class="comment">/* String table file offset */</span>
<a name="l00587"></a>00587     num_symbols * cdata-&gt;local_symesz;
<a name="l00588"></a>00588 
<a name="l00589"></a>00589   <span class="comment">/* Set a few file-statics that give us specific information about</span>
<a name="l00590"></a>00590 <span class="comment">     the particular COFF file format we&#39;re reading.  */</span>
<a name="l00591"></a>00591   local_n_btmask = cdata-&gt;local_n_btmask;
<a name="l00592"></a>00592   local_n_btshft = cdata-&gt;local_n_btshft;
<a name="l00593"></a>00593   local_n_tmask = cdata-&gt;local_n_tmask;
<a name="l00594"></a>00594   local_n_tshift = cdata-&gt;local_n_tshift;
<a name="l00595"></a>00595   local_linesz = cdata-&gt;local_linesz;
<a name="l00596"></a>00596   local_symesz = cdata-&gt;local_symesz;
<a name="l00597"></a>00597   local_auxesz = cdata-&gt;local_auxesz;
<a name="l00598"></a>00598 
<a name="l00599"></a>00599   <span class="comment">/* Allocate space for raw symbol and aux entries, based on their</span>
<a name="l00600"></a>00600 <span class="comment">     space requirements as reported by BFD.  */</span>
<a name="l00601"></a>00601   temp_sym = (<span class="keywordtype">char</span> *) <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a>
<a name="l00602"></a>00602     (cdata-&gt;local_symesz + cdata-&gt;local_auxesz);
<a name="l00603"></a>00603   temp_aux = temp_sym + cdata-&gt;local_symesz;
<a name="l00604"></a>00604   back_to = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="utils_8c.html#a6d8c21606d3f67a431a7bfbb1f47d12e">free_current_contents</a>, &amp;temp_sym);
<a name="l00605"></a>00605 
<a name="l00606"></a>00606   <span class="comment">/* We need to know whether this is a PE file, because in PE files,</span>
<a name="l00607"></a>00607 <span class="comment">     unlike standard COFF files, symbol values are stored as offsets</span>
<a name="l00608"></a>00608 <span class="comment">     from the section address, rather than as absolute addresses.</span>
<a name="l00609"></a>00609 <span class="comment">     FIXME: We should use BFD to read the symbol table, and thus avoid</span>
<a name="l00610"></a>00610 <span class="comment">     this problem.  */</span>
<a name="l00611"></a>00611   pe_file =
<a name="l00612"></a>00612     strncmp (bfd_get_target (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>), <span class="stringliteral">&quot;pe&quot;</span>, 2) == 0
<a name="l00613"></a>00613     || strncmp (bfd_get_target (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>), <span class="stringliteral">&quot;epoc-pe&quot;</span>, 7) == 0;
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   <span class="comment">/* End of warning.  */</span>
<a name="l00616"></a>00616 
<a name="l00617"></a>00617   info-&gt;min_lineno_offset = 0;
<a name="l00618"></a>00618   info-&gt;max_lineno_offset = 0;
<a name="l00619"></a>00619 
<a name="l00620"></a>00620   <span class="comment">/* Only read line number information if we have symbols.</span>
<a name="l00621"></a>00621 <span class="comment"></span>
<a name="l00622"></a>00622 <span class="comment">     On Windows NT, some of the system&#39;s DLL&#39;s have sections with</span>
<a name="l00623"></a>00623 <span class="comment">     PointerToLinenumbers fields that are non-zero, but point at</span>
<a name="l00624"></a>00624 <span class="comment">     random places within the image file.  (In the case I found,</span>
<a name="l00625"></a>00625 <span class="comment">     KERNEL32.DLL&#39;s .text section has a line number info pointer that</span>
<a name="l00626"></a>00626 <span class="comment">     points into the middle of the string `lib\\i386\kernel32.dll&#39;.)</span>
<a name="l00627"></a>00627 <span class="comment"></span>
<a name="l00628"></a>00628 <span class="comment">     However, these DLL&#39;s also have no symbols.  The line number</span>
<a name="l00629"></a>00629 <span class="comment">     tables are meaningless without symbols.  And in fact, GDB never</span>
<a name="l00630"></a>00630 <span class="comment">     uses the line number information unless there are symbols.  So we</span>
<a name="l00631"></a>00631 <span class="comment">     can avoid spurious error messages (and maybe run a little</span>
<a name="l00632"></a>00632 <span class="comment">     faster!) by not even reading the line number table unless we have</span>
<a name="l00633"></a>00633 <span class="comment">     symbols.  */</span>
<a name="l00634"></a>00634   <span class="keywordflow">if</span> (num_symbols &gt; 0)
<a name="l00635"></a>00635     {
<a name="l00636"></a>00636       <span class="comment">/* Read the line number table, all at once.  */</span>
<a name="l00637"></a>00637       bfd_map_over_sections (abfd, find_linenos, (<span class="keywordtype">void</span> *) info);
<a name="l00638"></a>00638 
<a name="l00639"></a>00639       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (free_linetab_cleanup, 0 <span class="comment">/*ignore*/</span>);
<a name="l00640"></a>00640       val = init_lineno (abfd, info-&gt;min_lineno_offset,
<a name="l00641"></a>00641                          info-&gt;max_lineno_offset - info-&gt;min_lineno_offset);
<a name="l00642"></a>00642       <span class="keywordflow">if</span> (val &lt; 0)
<a name="l00643"></a>00643         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\&quot;%s\&quot;: error reading line numbers.&quot;</span>), name);
<a name="l00644"></a>00644     }
<a name="l00645"></a>00645 
<a name="l00646"></a>00646   <span class="comment">/* Now read the string table, all at once.  */</span>
<a name="l00647"></a>00647 
<a name="l00648"></a>00648   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (free_stringtab_cleanup, 0 <span class="comment">/*ignore*/</span>);
<a name="l00649"></a>00649   val = init_stringtab (abfd, stringtab_offset);
<a name="l00650"></a>00650   <span class="keywordflow">if</span> (val &lt; 0)
<a name="l00651"></a>00651     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\&quot;%s\&quot;: can&#39;t get string table&quot;</span>), name);
<a name="l00652"></a>00652 
<a name="l00653"></a>00653   <a class="code" href="minsyms_8c.html#aaaefee590c52127db295a05851b37dc9">init_minimal_symbol_collection</a> ();
<a name="l00654"></a>00654   cleanup_minimal_symbols = <a class="code" href="minsyms_8c.html#a241e1441e762c260c07c42a578d93507">make_cleanup_discard_minimal_symbols</a> ();
<a name="l00655"></a>00655 
<a name="l00656"></a>00656   <span class="comment">/* Now that the executable file is positioned at symbol table,</span>
<a name="l00657"></a>00657 <span class="comment">     process it and define symbols accordingly.  */</span>
<a name="l00658"></a>00658 
<a name="l00659"></a>00659   coff_symtab_read ((<span class="keywordtype">long</span>) symtab_offset, num_symbols, objfile);
<a name="l00660"></a>00660 
<a name="l00661"></a>00661   <span class="comment">/* Install any minimal symbols that have been collected as the</span>
<a name="l00662"></a>00662 <span class="comment">     current minimal symbols for this objfile.  */</span>
<a name="l00663"></a>00663 
<a name="l00664"></a>00664   <a class="code" href="minsyms_8c.html#ac68f7aa806438e885a7f56798d2e40c4">install_minimal_symbols</a> (objfile);
<a name="l00665"></a>00665 
<a name="l00666"></a>00666   <span class="keywordflow">if</span> (pe_file)
<a name="l00667"></a>00667     {
<a name="l00668"></a>00668       <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *msym;
<a name="l00669"></a>00669 
<a name="l00670"></a>00670       <a class="code" href="objfiles_8h.html#aab33f4a89ebfe4c8adb99dbe422081fe">ALL_OBJFILE_MSYMBOLS</a> (objfile, msym)
<a name="l00671"></a>00671         {
<a name="l00672"></a>00672           <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (msym);
<a name="l00673"></a>00673 
<a name="l00674"></a>00674           <span class="comment">/* If the minimal symbols whose name are prefixed by &quot;__imp_&quot;</span>
<a name="l00675"></a>00675 <span class="comment">             or &quot;_imp_&quot;, get rid of the prefix, and search the minimal</span>
<a name="l00676"></a>00676 <span class="comment">             symbol in OBJFILE.  Note that &#39;maintenance print msymbols&#39;</span>
<a name="l00677"></a>00677 <span class="comment">             shows that type of these &quot;_imp_XXXX&quot; symbols is mst_data.  */</span>
<a name="l00678"></a>00678           <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a1d0b27d446f2622f464727b6a06ae263">MSYMBOL_TYPE</a> (msym) == <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036a71b45da3c83c4939f9ff3b2b641c05b0">mst_data</a>
<a name="l00679"></a>00679               &amp;&amp; (strncmp (name, <span class="stringliteral">&quot;__imp_&quot;</span>, 6) == 0
<a name="l00680"></a>00680                   || strncmp (name, <span class="stringliteral">&quot;_imp_&quot;</span>, 5) == 0))
<a name="l00681"></a>00681             {
<a name="l00682"></a>00682               <span class="keyword">const</span> <span class="keywordtype">char</span> *name1 = (name[1] == <span class="charliteral">&#39;_&#39;</span> ? &amp;name[7] : &amp;name[6]);
<a name="l00683"></a>00683               <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *found;
<a name="l00684"></a>00684 
<a name="l00685"></a>00685               found = <a class="code" href="minsyms_8c.html#af87f7a894386515074ddd71365bc09b8">lookup_minimal_symbol</a> (name1, NULL, objfile);
<a name="l00686"></a>00686               <span class="comment">/* If found, there are symbols named &quot;_imp_foo&quot; and &quot;foo&quot;</span>
<a name="l00687"></a>00687 <span class="comment">                 respectively in OBJFILE.  Set the type of symbol &quot;foo&quot;</span>
<a name="l00688"></a>00688 <span class="comment">                 as &#39;mst_solib_trampoline&#39;.  */</span>
<a name="l00689"></a>00689               <span class="keywordflow">if</span> (found != NULL &amp;&amp; <a class="code" href="symtab_8h.html#a1d0b27d446f2622f464727b6a06ae263">MSYMBOL_TYPE</a> (found) == <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036af24db58d8996f50560c2f03d9c8514c0">mst_text</a>)
<a name="l00690"></a>00690                 <a class="code" href="symtab_8h.html#a1d0b27d446f2622f464727b6a06ae263">MSYMBOL_TYPE</a> (found) = <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036aa6ace68113ace3aafa25e705d9fce85d">mst_solib_trampoline</a>;
<a name="l00691"></a>00691             }
<a name="l00692"></a>00692         }
<a name="l00693"></a>00693     }
<a name="l00694"></a>00694 
<a name="l00695"></a>00695   <span class="comment">/* Free the installed minimal symbol data.  */</span>
<a name="l00696"></a>00696   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanup_minimal_symbols);
<a name="l00697"></a>00697 
<a name="l00698"></a>00698   bfd_map_over_sections (abfd, coff_locate_sections, (<span class="keywordtype">void</span> *) info);
<a name="l00699"></a>00699 
<a name="l00700"></a>00700   <span class="keywordflow">if</span> (info-&gt;stabsects)
<a name="l00701"></a>00701     {
<a name="l00702"></a>00702       <span class="keywordflow">if</span> (!info-&gt;stabstrsect)
<a name="l00703"></a>00703         {
<a name="l00704"></a>00704           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;The debugging information in `%s&#39; is corrupted.\nThe &quot;</span>
<a name="l00705"></a>00705                    <span class="stringliteral">&quot;file has a `.stabs&#39; section, but no `.stabstr&#39; section.&quot;</span>),
<a name="l00706"></a>00706                  name);
<a name="l00707"></a>00707         }
<a name="l00708"></a>00708 
<a name="l00709"></a>00709       <span class="comment">/* FIXME: dubious.  Why can&#39;t we use something normal like</span>
<a name="l00710"></a>00710 <span class="comment">         bfd_get_section_contents?  */</span>
<a name="l00711"></a>00711       bfd_seek (abfd, abfd-&gt;where, 0);
<a name="l00712"></a>00712 
<a name="l00713"></a>00713       stabstrsize = bfd_section_size (abfd, info-&gt;stabstrsect);
<a name="l00714"></a>00714 
<a name="l00715"></a>00715       <a class="code" href="dbxread_8c.html#ab5482ee373f73c783ee25c92a90cd26e">coffstab_build_psymtabs</a> (objfile,
<a name="l00716"></a>00716                                info-&gt;textaddr, info-&gt;textsize,
<a name="l00717"></a>00717                                info-&gt;stabsects,
<a name="l00718"></a>00718                                info-&gt;stabstrsect-&gt;filepos, stabstrsize);
<a name="l00719"></a>00719     }
<a name="l00720"></a>00720   <span class="keywordflow">if</span> (<a class="code" href="dwarf2read_8c.html#ab5b2c8045e6365e6d5609a79bbd76002">dwarf2_has_info</a> (objfile, NULL))
<a name="l00721"></a>00721     {
<a name="l00722"></a>00722       <span class="comment">/* DWARF2 sections.  */</span>
<a name="l00723"></a>00723       <a class="code" href="dwarf2read_8c.html#a63a783cfbadacf7115d7b1e3853710db">dwarf2_build_psymtabs</a> (objfile);
<a name="l00724"></a>00724     }
<a name="l00725"></a>00725 
<a name="l00726"></a>00726   <a class="code" href="dwarf2-frame_8c.html#a590b76958228bee4ccb8fff3b42a78bd">dwarf2_build_frame_info</a> (objfile);
<a name="l00727"></a>00727 
<a name="l00728"></a>00728   <span class="comment">/* Try to add separate debug file if no symbols table found.   */</span>
<a name="l00729"></a>00729   <span class="keywordflow">if</span> (!<a class="code" href="objfiles_8c.html#a9efbc153865ef5d6e2b555f168188ba9">objfile_has_partial_symbols</a> (objfile))
<a name="l00730"></a>00730     {
<a name="l00731"></a>00731       <span class="keywordtype">char</span> *debugfile;
<a name="l00732"></a>00732 
<a name="l00733"></a>00733       debugfile = <a class="code" href="symfile_8c.html#a92804420c21b9d15c0783016696ce4be">find_separate_debug_file_by_debuglink</a> (objfile);
<a name="l00734"></a>00734       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, debugfile);
<a name="l00735"></a>00735 
<a name="l00736"></a>00736       <span class="keywordflow">if</span> (debugfile)
<a name="l00737"></a>00737         {
<a name="l00738"></a>00738           bfd *abfd = <a class="code" href="symfile_8c.html#a87d6b7f23fd0a082df113a4a0ecfc411">symfile_bfd_open</a> (debugfile);
<a name="l00739"></a>00739 
<a name="l00740"></a>00740           <a class="code" href="utils_8c.html#aefcbd004e34c553d07ce2a6b4a196852">make_cleanup_bfd_unref</a> (abfd);
<a name="l00741"></a>00741           <a class="code" href="symfile_8c.html#aa70894a9465614bd3d8a3a711bab2402">symbol_file_add_separate</a> (abfd, debugfile, symfile_flags, objfile);
<a name="l00742"></a>00742         }
<a name="l00743"></a>00743     }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l00746"></a>00746 }
<a name="l00747"></a>00747 
<a name="l00748"></a>00748 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00749"></a>00749 coff_new_init (<span class="keyword">struct</span> objfile *ignore)
<a name="l00750"></a>00750 {
<a name="l00751"></a>00751 }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753 <span class="comment">/* Perform any local cleanups required when we are done with a</span>
<a name="l00754"></a>00754 <span class="comment">   particular objfile.  I.E, we are in the process of discarding all</span>
<a name="l00755"></a>00755 <span class="comment">   symbol information for an objfile, freeing up all memory held for</span>
<a name="l00756"></a>00756 <span class="comment">   it, and unlinking the objfile struct from the global list of known</span>
<a name="l00757"></a>00757 <span class="comment">   objfiles.  */</span>
<a name="l00758"></a>00758 
<a name="l00759"></a>00759 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00760"></a>00760 coff_symfile_finish (<span class="keyword">struct</span> objfile *objfile)
<a name="l00761"></a>00761 {
<a name="l00762"></a>00762   <span class="comment">/* Let stabs reader clean up.  */</span>
<a name="l00763"></a>00763   <a class="code" href="coffread_8c.html#aaf92fbf8bca35c59f653dff4d1ad8e1f">stabsread_clear_cache</a> ();
<a name="l00764"></a>00764 
<a name="l00765"></a>00765   <a class="code" href="dwarf2read_8c.html#a31f05f7243e0fe61d86ad46ee2e7e704">dwarf2_free_objfile</a> (objfile);
<a name="l00766"></a>00766 }
<a name="l00767"></a>00767 
<a name="l00768"></a>00768 
<a name="l00769"></a>00769 <span class="comment">/* Given pointers to a symbol table in coff style exec file,</span>
<a name="l00770"></a>00770 <span class="comment">   analyze them and create struct symtab&#39;s describing the symbols.</span>
<a name="l00771"></a>00771 <span class="comment">   NSYMS is the number of symbols in the symbol table.</span>
<a name="l00772"></a>00772 <span class="comment">   We read them one at a time using read_one_sym ().  */</span>
<a name="l00773"></a>00773 
<a name="l00774"></a>00774 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00775"></a>00775 coff_symtab_read (<span class="keywordtype">long</span> symtab_offset, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nsyms,
<a name="l00776"></a>00776                   <span class="keyword">struct</span> objfile *objfile)
<a name="l00777"></a>00777 {
<a name="l00778"></a>00778   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l00779"></a>00779   <span class="keyword">struct </span><a class="code" href="structcontext__stack.html">context_stack</a> *<span class="keyword">new</span>;
<a name="l00780"></a>00780   <span class="keyword">struct </span>coff_symbol coff_symbol;
<a name="l00781"></a>00781   <span class="keyword">struct </span>coff_symbol *cs = &amp;coff_symbol;
<a name="l00782"></a>00782   <span class="keyword">static</span> <span class="keyword">struct </span>internal_syment main_sym;
<a name="l00783"></a>00783   <span class="keyword">static</span> <span class="keyword">union </span>internal_auxent main_aux;
<a name="l00784"></a>00784   <span class="keyword">struct </span>coff_symbol fcn_cs_saved;
<a name="l00785"></a>00785   <span class="keyword">static</span> <span class="keyword">struct </span>internal_syment fcn_sym_saved;
<a name="l00786"></a>00786   <span class="keyword">static</span> <span class="keyword">union </span>internal_auxent fcn_aux_saved;
<a name="l00787"></a>00787   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *s;
<a name="l00788"></a>00788   <span class="comment">/* A .file is open.  */</span>
<a name="l00789"></a>00789   <span class="keywordtype">int</span> in_source_file = 0;
<a name="l00790"></a>00790   <span class="keywordtype">int</span> next_file_symnum = -1;
<a name="l00791"></a>00791   <span class="comment">/* Name of the current file.  */</span>
<a name="l00792"></a>00792   <span class="keyword">const</span> <span class="keywordtype">char</span> *filestring = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00793"></a>00793   <span class="keywordtype">int</span> depth = 0;
<a name="l00794"></a>00794   <span class="keywordtype">int</span> fcn_first_line = 0;
<a name="l00795"></a>00795   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> fcn_first_line_addr = 0;
<a name="l00796"></a>00796   <span class="keywordtype">int</span> fcn_last_line = 0;
<a name="l00797"></a>00797   <span class="keywordtype">int</span> fcn_start_addr = 0;
<a name="l00798"></a>00798   <span class="keywordtype">long</span> fcn_line_ptr = 0;
<a name="l00799"></a>00799   <span class="keywordtype">int</span> val;
<a name="l00800"></a>00800   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> tmpaddr;
<a name="l00801"></a>00801   <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *msym;
<a name="l00802"></a>00802 
<a name="l00803"></a>00803   <span class="comment">/* Work around a stdio bug in SunOS4.1.1 (this makes me nervous....</span>
<a name="l00804"></a>00804 <span class="comment">     it&#39;s hard to know I&#39;ve really worked around it.  The fix should</span>
<a name="l00805"></a>00805 <span class="comment">     be harmless, anyway).  The symptom of the bug is that the first</span>
<a name="l00806"></a>00806 <span class="comment">     fread (in read_one_sym), will (in my example) actually get data</span>
<a name="l00807"></a>00807 <span class="comment">     from file offset 268, when the fseek was to 264 (and ftell shows</span>
<a name="l00808"></a>00808 <span class="comment">     264).  This causes all hell to break loose.  I was unable to</span>
<a name="l00809"></a>00809 <span class="comment">     reproduce this on a short test program which operated on the same</span>
<a name="l00810"></a>00810 <span class="comment">     file, performing (I think) the same sequence of operations.</span>
<a name="l00811"></a>00811 <span class="comment"></span>
<a name="l00812"></a>00812 <span class="comment">     It stopped happening when I put in this (former) rewind().</span>
<a name="l00813"></a>00813 <span class="comment"></span>
<a name="l00814"></a>00814 <span class="comment">     FIXME: Find out if this has been reported to Sun, whether it has</span>
<a name="l00815"></a>00815 <span class="comment">     been fixed in a later release, etc.  */</span>
<a name="l00816"></a>00816 
<a name="l00817"></a>00817   bfd_seek (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>, 0, 0);
<a name="l00818"></a>00818 
<a name="l00819"></a>00819   <span class="comment">/* Position to read the symbol table.  */</span>
<a name="l00820"></a>00820   val = bfd_seek (objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>, (<span class="keywordtype">long</span>) symtab_offset, 0);
<a name="l00821"></a>00821   <span class="keywordflow">if</span> (val &lt; 0)
<a name="l00822"></a>00822     <a class="code" href="utils_8c.html#a14801ceb45147833b8ce111c89ea0d5f">perror_with_name</a> (<a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (objfile));
<a name="l00823"></a>00823 
<a name="l00824"></a>00824   coffread_objfile = objfile;
<a name="l00825"></a>00825   nlist_bfd_global = objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>;
<a name="l00826"></a>00826   nlist_nsyms_global = nsyms;
<a name="l00827"></a>00827   <a class="code" href="buildsym_8c.html#a7f829e2a76d56399cfc7885b8fabb15a">set_last_source_file</a> (NULL);
<a name="l00828"></a>00828   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (opaque_type_chain, 0, <span class="keyword">sizeof</span> opaque_type_chain);
<a name="l00829"></a>00829 
<a name="l00830"></a>00830   <span class="keywordflow">if</span> (type_vector)              <span class="comment">/* Get rid of previous one.  */</span>
<a name="l00831"></a>00831     <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (type_vector);
<a name="l00832"></a>00832   type_vector_length = <a class="code" href="coffread_8c.html#a860c01b52099d41e71894ed50296fcb1">INITIAL_TYPE_VECTOR_LENGTH</a>;
<a name="l00833"></a>00833   type_vector = (<span class="keyword">struct </span>type **)
<a name="l00834"></a>00834     <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (type_vector_length * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> type *));
<a name="l00835"></a>00835   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (type_vector, 0, type_vector_length * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> type *));
<a name="l00836"></a>00836 
<a name="l00837"></a>00837   coff_start_symtab (<span class="stringliteral">&quot;&quot;</span>);
<a name="l00838"></a>00838 
<a name="l00839"></a>00839   <a class="code" href="buildsym_8h.html#a79942374faad15785bb8f359a3d83886">symnum</a> = 0;
<a name="l00840"></a>00840   <span class="keywordflow">while</span> (<a class="code" href="buildsym_8h.html#a79942374faad15785bb8f359a3d83886">symnum</a> &lt; nsyms)
<a name="l00841"></a>00841     {
<a name="l00842"></a>00842       <a class="code" href="defs_8h.html#ad24e2b54375e12474e65ebf7175988fb">QUIT</a>;                     <span class="comment">/* Make this command interruptable.  */</span>
<a name="l00843"></a>00843 
<a name="l00844"></a>00844       read_one_sym (cs, &amp;main_sym, &amp;main_aux);
<a name="l00845"></a>00845 
<a name="l00846"></a>00846       <span class="keywordflow">if</span> (cs-&gt;c_symnum == next_file_symnum &amp;&amp; cs-&gt;c_sclass != C_FILE)
<a name="l00847"></a>00847         {
<a name="l00848"></a>00848           <span class="keywordflow">if</span> (<a class="code" href="buildsym_8c.html#afe8ed6edc2cd2aba80ae556eda4914fd">get_last_source_file</a> ())
<a name="l00849"></a>00849             coff_end_symtab (objfile);
<a name="l00850"></a>00850 
<a name="l00851"></a>00851           coff_start_symtab (<span class="stringliteral">&quot;_globals_&quot;</span>);
<a name="l00852"></a>00852           <span class="comment">/* coff_start_symtab will set the language of this symtab to</span>
<a name="l00853"></a>00853 <span class="comment">             language_unknown, since such a ``file name&#39;&#39; is not</span>
<a name="l00854"></a>00854 <span class="comment">             recognized.  Override that with the minimal language to</span>
<a name="l00855"></a>00855 <span class="comment">             allow printing values in this symtab.  */</span>
<a name="l00856"></a>00856           <a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>-&gt;<a class="code" href="structsubfile.html#ab029142a675cd734324b9d732ff44963">language</a> = <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a389b59241274e837cb0d28b1909013ac">language_minimal</a>;
<a name="l00857"></a>00857           <a class="code" href="xcoffread_8c.html#acc6f18948d48e4cae3b78e80636a9848">complete_symtab</a> (<span class="stringliteral">&quot;_globals_&quot;</span>, 0, 0);
<a name="l00858"></a>00858           <span class="comment">/* Done with all files, everything from here on out is</span>
<a name="l00859"></a>00859 <span class="comment">             globals.  */</span>
<a name="l00860"></a>00860         }
<a name="l00861"></a>00861 
<a name="l00862"></a>00862       <span class="comment">/* Special case for file with type declarations only, no</span>
<a name="l00863"></a>00863 <span class="comment">         text.  */</span>
<a name="l00864"></a>00864       <span class="keywordflow">if</span> (!<a class="code" href="buildsym_8c.html#afe8ed6edc2cd2aba80ae556eda4914fd">get_last_source_file</a> () &amp;&amp; <a class="code" href="coffread_8c.html#a524571ce1b33bf4a8a0b63de733e8789">SDB_TYPE</a> (cs-&gt;c_type)
<a name="l00865"></a>00865           &amp;&amp; cs-&gt;c_secnum == N_DEBUG)
<a name="l00866"></a>00866         <a class="code" href="xcoffread_8c.html#acc6f18948d48e4cae3b78e80636a9848">complete_symtab</a> (filestring, 0, 0);
<a name="l00867"></a>00867 
<a name="l00868"></a>00868       <span class="comment">/* Typedefs should not be treated as symbol definitions.  */</span>
<a name="l00869"></a>00869       <span class="keywordflow">if</span> (ISFCN (cs-&gt;c_type) &amp;&amp; cs-&gt;c_sclass != C_TPDEF)
<a name="l00870"></a>00870         {
<a name="l00871"></a>00871           <span class="comment">/* Record all functions -- external and static -- in</span>
<a name="l00872"></a>00872 <span class="comment">             minsyms.  */</span>
<a name="l00873"></a>00873           <span class="keywordtype">int</span> section = cs_to_section (cs, objfile);
<a name="l00874"></a>00874 
<a name="l00875"></a>00875           tmpaddr = cs-&gt;c_value + <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>,
<a name="l00876"></a>00876                                             <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l00877"></a>00877           record_minimal_symbol (cs, tmpaddr, <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036af24db58d8996f50560c2f03d9c8514c0">mst_text</a>,
<a name="l00878"></a>00878                                  section, objfile);
<a name="l00879"></a>00879 
<a name="l00880"></a>00880           fcn_line_ptr = main_aux.x_sym.x_fcnary.x_fcn.x_lnnoptr;
<a name="l00881"></a>00881           fcn_start_addr = tmpaddr;
<a name="l00882"></a>00882           fcn_cs_saved = *cs;
<a name="l00883"></a>00883           fcn_sym_saved = main_sym;
<a name="l00884"></a>00884           fcn_aux_saved = main_aux;
<a name="l00885"></a>00885           <span class="keywordflow">continue</span>;
<a name="l00886"></a>00886         }
<a name="l00887"></a>00887 
<a name="l00888"></a>00888       <span class="keywordflow">switch</span> (cs-&gt;c_sclass)
<a name="l00889"></a>00889         {
<a name="l00890"></a>00890         <span class="keywordflow">case</span> C_EFCN:
<a name="l00891"></a>00891         <span class="keywordflow">case</span> C_EXTDEF:
<a name="l00892"></a>00892         <span class="keywordflow">case</span> C_ULABEL:
<a name="l00893"></a>00893         <span class="keywordflow">case</span> C_USTATIC:
<a name="l00894"></a>00894         <span class="keywordflow">case</span> C_LINE:
<a name="l00895"></a>00895         <span class="keywordflow">case</span> C_ALIAS:
<a name="l00896"></a>00896         <span class="keywordflow">case</span> C_HIDDEN:
<a name="l00897"></a>00897           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l00898"></a>00898                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Bad n_sclass for symbol %s&quot;</span>),
<a name="l00899"></a>00899                      cs-&gt;c_name);
<a name="l00900"></a>00900           <span class="keywordflow">break</span>;
<a name="l00901"></a>00901 
<a name="l00902"></a>00902         <span class="keywordflow">case</span> C_FILE:
<a name="l00903"></a>00903           <span class="comment">/* c_value field contains symnum of next .file entry in</span>
<a name="l00904"></a>00904 <span class="comment">             table or symnum of first global after last .file.  */</span>
<a name="l00905"></a>00905           next_file_symnum = cs-&gt;c_value;
<a name="l00906"></a>00906           <span class="keywordflow">if</span> (cs-&gt;c_naux &gt; 0)
<a name="l00907"></a>00907             filestring = coff_getfilename (&amp;main_aux);
<a name="l00908"></a>00908           <span class="keywordflow">else</span>
<a name="l00909"></a>00909             filestring = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00910"></a>00910 
<a name="l00911"></a>00911           <span class="comment">/* Complete symbol table for last object file</span>
<a name="l00912"></a>00912 <span class="comment">             containing debugging information.  */</span>
<a name="l00913"></a>00913           <span class="keywordflow">if</span> (<a class="code" href="buildsym_8c.html#afe8ed6edc2cd2aba80ae556eda4914fd">get_last_source_file</a> ())
<a name="l00914"></a>00914             {
<a name="l00915"></a>00915               coff_end_symtab (objfile);
<a name="l00916"></a>00916               coff_start_symtab (filestring);
<a name="l00917"></a>00917             }
<a name="l00918"></a>00918           in_source_file = 1;
<a name="l00919"></a>00919           <span class="keywordflow">break</span>;
<a name="l00920"></a>00920 
<a name="l00921"></a>00921           <span class="comment">/* C_LABEL is used for labels and static functions.</span>
<a name="l00922"></a>00922 <span class="comment">             Including it here allows gdb to see static functions when</span>
<a name="l00923"></a>00923 <span class="comment">             no debug info is available.  */</span>
<a name="l00924"></a>00924         <span class="keywordflow">case</span> C_LABEL:
<a name="l00925"></a>00925           <span class="comment">/* However, labels within a function can make weird</span>
<a name="l00926"></a>00926 <span class="comment">             backtraces, so filter them out (from phdm@macqel.be).  */</span>
<a name="l00927"></a>00927           <span class="keywordflow">if</span> (<a class="code" href="buildsym_8h.html#ad12032827aa8d87fbe036b7e375d9190">within_function</a>)
<a name="l00928"></a>00928             <span class="keywordflow">break</span>;
<a name="l00929"></a>00929         <span class="keywordflow">case</span> C_STAT:
<a name="l00930"></a>00930         <span class="keywordflow">case</span> C_THUMBLABEL:
<a name="l00931"></a>00931         <span class="keywordflow">case</span> C_THUMBSTAT:
<a name="l00932"></a>00932         <span class="keywordflow">case</span> C_THUMBSTATFUNC:
<a name="l00933"></a>00933           <span class="keywordflow">if</span> (cs-&gt;c_name[0] == <span class="charliteral">&#39;.&#39;</span>)
<a name="l00934"></a>00934             {
<a name="l00935"></a>00935               <span class="keywordflow">if</span> (strcmp (cs-&gt;c_name, <span class="stringliteral">&quot;.text&quot;</span>) == 0)
<a name="l00936"></a>00936                 {
<a name="l00937"></a>00937                   <span class="comment">/* FIXME: don&#39;t wire in &quot;.text&quot; as section name or</span>
<a name="l00938"></a>00938 <span class="comment">                     symbol name!  */</span>
<a name="l00939"></a>00939                   <span class="comment">/* Check for in_source_file deals with case of a</span>
<a name="l00940"></a>00940 <span class="comment">                     file with debugging symbols followed by a later</span>
<a name="l00941"></a>00941 <span class="comment">                     file with no symbols.  */</span>
<a name="l00942"></a>00942                   <span class="keywordflow">if</span> (in_source_file)
<a name="l00943"></a>00943                     <a class="code" href="xcoffread_8c.html#acc6f18948d48e4cae3b78e80636a9848">complete_symtab</a> (filestring,
<a name="l00944"></a>00944                     cs-&gt;c_value + <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>,
<a name="l00945"></a>00945                                             <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile)),
<a name="l00946"></a>00946                                      main_aux.x_scn.x_scnlen);
<a name="l00947"></a>00947                   in_source_file = 0;
<a name="l00948"></a>00948                 }
<a name="l00949"></a>00949               <span class="comment">/* Flush rest of &#39;.&#39; symbols.  */</span>
<a name="l00950"></a>00950               <span class="keywordflow">break</span>;
<a name="l00951"></a>00951             }
<a name="l00952"></a>00952           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="coffread_8c.html#a524571ce1b33bf4a8a0b63de733e8789">SDB_TYPE</a> (cs-&gt;c_type)
<a name="l00953"></a>00953                    &amp;&amp; cs-&gt;c_name[0] == <span class="charliteral">&#39;L&#39;</span>
<a name="l00954"></a>00954                    &amp;&amp; (strncmp (cs-&gt;c_name, <span class="stringliteral">&quot;LI%&quot;</span>, 3) == 0
<a name="l00955"></a>00955                        || strncmp (cs-&gt;c_name, <span class="stringliteral">&quot;LF%&quot;</span>, 3) == 0
<a name="l00956"></a>00956                        || strncmp (cs-&gt;c_name, <span class="stringliteral">&quot;LC%&quot;</span>, 3) == 0
<a name="l00957"></a>00957                        || strncmp (cs-&gt;c_name, <span class="stringliteral">&quot;LP%&quot;</span>, 3) == 0
<a name="l00958"></a>00958                        || strncmp (cs-&gt;c_name, <span class="stringliteral">&quot;LPB%&quot;</span>, 4) == 0
<a name="l00959"></a>00959                        || strncmp (cs-&gt;c_name, <span class="stringliteral">&quot;LBB%&quot;</span>, 4) == 0
<a name="l00960"></a>00960                        || strncmp (cs-&gt;c_name, <span class="stringliteral">&quot;LBE%&quot;</span>, 4) == 0
<a name="l00961"></a>00961                        || strncmp (cs-&gt;c_name, <span class="stringliteral">&quot;LPBX%&quot;</span>, 5) == 0))
<a name="l00962"></a>00962             <span class="comment">/* At least on a 3b1, gcc generates swbeg and string labels</span>
<a name="l00963"></a>00963 <span class="comment">               that look like this.  Ignore them.  */</span>
<a name="l00964"></a>00964             <span class="keywordflow">break</span>;
<a name="l00965"></a>00965           <span class="comment">/* Fall in for static symbols that don&#39;t start with &#39;.&#39;  */</span>
<a name="l00966"></a>00966         <span class="keywordflow">case</span> C_THUMBEXT:
<a name="l00967"></a>00967         <span class="keywordflow">case</span> C_THUMBEXTFUNC:
<a name="l00968"></a>00968         <span class="keywordflow">case</span> C_EXT:
<a name="l00969"></a>00969           {
<a name="l00970"></a>00970             <span class="comment">/* Record it in the minimal symbols regardless of</span>
<a name="l00971"></a>00971 <span class="comment">               SDB_TYPE.  This parallels what we do for other debug</span>
<a name="l00972"></a>00972 <span class="comment">               formats, and probably is needed to make</span>
<a name="l00973"></a>00973 <span class="comment">               print_address_symbolic work right without the (now</span>
<a name="l00974"></a>00974 <span class="comment">               gone) &quot;set fast-symbolic-addr off&quot; kludge.  */</span>
<a name="l00975"></a>00975 
<a name="l00976"></a>00976             <span class="keyword">enum</span> <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036">minimal_symbol_type</a> ms_type;
<a name="l00977"></a>00977             <span class="keywordtype">int</span> sec;
<a name="l00978"></a>00978 
<a name="l00979"></a>00979             <span class="keywordflow">if</span> (cs-&gt;c_secnum == N_UNDEF)
<a name="l00980"></a>00980               {
<a name="l00981"></a>00981                 <span class="comment">/* This is a common symbol.  We used to rely on</span>
<a name="l00982"></a>00982 <span class="comment">                   the target to tell us whether it knows where</span>
<a name="l00983"></a>00983 <span class="comment">                   the symbol has been relocated to, but none of</span>
<a name="l00984"></a>00984 <span class="comment">                   the target implementations actually provided</span>
<a name="l00985"></a>00985 <span class="comment">                   that operation.  So we just ignore the symbol,</span>
<a name="l00986"></a>00986 <span class="comment">                   the same way we would do if we had a target-side</span>
<a name="l00987"></a>00987 <span class="comment">                   symbol lookup which returned no match.  */</span>
<a name="l00988"></a>00988                 <span class="keywordflow">break</span>;
<a name="l00989"></a>00989               }
<a name="l00990"></a>00990             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cs-&gt;c_secnum == N_ABS)
<a name="l00991"></a>00991               {
<a name="l00992"></a>00992                 <span class="comment">/* Use the correct minimal symbol type (and don&#39;t</span>
<a name="l00993"></a>00993 <span class="comment">                   relocate) for absolute values.  */</span>
<a name="l00994"></a>00994                 ms_type = <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036a2090b7ce32fc7dc63f28781b045a6a81">mst_abs</a>;
<a name="l00995"></a>00995                 sec = cs_to_section (cs, objfile);
<a name="l00996"></a>00996                 tmpaddr = cs-&gt;c_value;
<a name="l00997"></a>00997               }
<a name="l00998"></a>00998             <span class="keywordflow">else</span>
<a name="l00999"></a>00999               {
<a name="l01000"></a>01000                 asection *bfd_section = cs_to_bfd_section (cs, objfile);
<a name="l01001"></a>01001 
<a name="l01002"></a>01002                 sec = cs_to_section (cs, objfile);
<a name="l01003"></a>01003                 tmpaddr = cs-&gt;c_value;
<a name="l01004"></a>01004                 <span class="comment">/* Statics in a PE file also get relocated.  */</span>
<a name="l01005"></a>01005                 <span class="keywordflow">if</span> (cs-&gt;c_sclass == C_EXT
<a name="l01006"></a>01006                     || cs-&gt;c_sclass == C_THUMBEXTFUNC
<a name="l01007"></a>01007                     || cs-&gt;c_sclass == C_THUMBEXT
<a name="l01008"></a>01008                     || (pe_file &amp;&amp; (cs-&gt;c_sclass == C_STAT)))
<a name="l01009"></a>01009                   tmpaddr += <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>, sec);
<a name="l01010"></a>01010 
<a name="l01011"></a>01011                 <span class="keywordflow">if</span> (bfd_section-&gt;flags &amp; SEC_CODE)
<a name="l01012"></a>01012                   {
<a name="l01013"></a>01013                     ms_type =
<a name="l01014"></a>01014                       cs-&gt;c_sclass == C_EXT || cs-&gt;c_sclass == C_THUMBEXTFUNC
<a name="l01015"></a>01015                       || cs-&gt;c_sclass == C_THUMBEXT ?
<a name="l01016"></a>01016                       <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036af24db58d8996f50560c2f03d9c8514c0">mst_text</a> : <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036abe55ea8e467b6e7517e226164aa94adb">mst_file_text</a>;
<a name="l01017"></a>01017                     tmpaddr = <a class="code" href="gdbarch_8c.html#abee635dc7cb9e9793c6100971df1a859">gdbarch_addr_bits_remove</a> (gdbarch, tmpaddr);
<a name="l01018"></a>01018                   }
<a name="l01019"></a>01019                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bfd_section-&gt;flags &amp; SEC_ALLOC
<a name="l01020"></a>01020                          &amp;&amp; bfd_section-&gt;flags &amp; SEC_LOAD)
<a name="l01021"></a>01021                   {
<a name="l01022"></a>01022                     ms_type =
<a name="l01023"></a>01023                       cs-&gt;c_sclass == C_EXT || cs-&gt;c_sclass == C_THUMBEXT
<a name="l01024"></a>01024                       ? <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036a71b45da3c83c4939f9ff3b2b641c05b0">mst_data</a> : <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036ad2119ba8e1b909d5c67d8d53bf772eab">mst_file_data</a>;
<a name="l01025"></a>01025                   }
<a name="l01026"></a>01026                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bfd_section-&gt;flags &amp; SEC_ALLOC)
<a name="l01027"></a>01027                   {
<a name="l01028"></a>01028                     ms_type =
<a name="l01029"></a>01029                       cs-&gt;c_sclass == C_EXT || cs-&gt;c_sclass == C_THUMBEXT
<a name="l01030"></a>01030                       ? <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036a5ead91e96fa8091e4b168773f8d69242">mst_bss</a> : <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036afcbb0b5fa236563bce133159d8aba081">mst_file_bss</a>;
<a name="l01031"></a>01031                   }
<a name="l01032"></a>01032                 <span class="keywordflow">else</span>
<a name="l01033"></a>01033                   ms_type = <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036a88c9666eff0232b87e9653493ae21c92">mst_unknown</a>;
<a name="l01034"></a>01034               }
<a name="l01035"></a>01035 
<a name="l01036"></a>01036             msym = record_minimal_symbol (cs, tmpaddr, ms_type,
<a name="l01037"></a>01037                                           sec, objfile);
<a name="l01038"></a>01038             <span class="keywordflow">if</span> (msym)
<a name="l01039"></a>01039               <a class="code" href="gdbarch_8c.html#a1356631332b86aa5ccf7cefe5a97475c">gdbarch_coff_make_msymbol_special</a> (gdbarch,
<a name="l01040"></a>01040                                                  cs-&gt;c_sclass, msym);
<a name="l01041"></a>01041 
<a name="l01042"></a>01042             <span class="keywordflow">if</span> (<a class="code" href="coffread_8c.html#a524571ce1b33bf4a8a0b63de733e8789">SDB_TYPE</a> (cs-&gt;c_type))
<a name="l01043"></a>01043               {
<a name="l01044"></a>01044                 <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l01045"></a>01045 
<a name="l01046"></a>01046                 sym = process_coff_symbol
<a name="l01047"></a>01047                   (cs, &amp;main_aux, objfile);
<a name="l01048"></a>01048                 <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (sym) = tmpaddr;
<a name="l01049"></a>01049                 <a class="code" href="symtab_8h.html#a9e82ed3317c58c4b85104d87e738fada">SYMBOL_SECTION</a> (sym) = sec;
<a name="l01050"></a>01050               }
<a name="l01051"></a>01051           }
<a name="l01052"></a>01052           <span class="keywordflow">break</span>;
<a name="l01053"></a>01053 
<a name="l01054"></a>01054         <span class="keywordflow">case</span> C_FCN:
<a name="l01055"></a>01055           <span class="keywordflow">if</span> (strcmp (cs-&gt;c_name, <span class="stringliteral">&quot;.bf&quot;</span>) == 0)
<a name="l01056"></a>01056             {
<a name="l01057"></a>01057               <a class="code" href="buildsym_8h.html#ad12032827aa8d87fbe036b7e375d9190">within_function</a> = 1;
<a name="l01058"></a>01058 
<a name="l01059"></a>01059               <span class="comment">/* Value contains address of first non-init type</span>
<a name="l01060"></a>01060 <span class="comment">                 code.  */</span>
<a name="l01061"></a>01061               <span class="comment">/* main_aux.x_sym.x_misc.x_lnsz.x_lnno</span>
<a name="l01062"></a>01062 <span class="comment">                 contains line number of &#39;{&#39; }.  */</span>
<a name="l01063"></a>01063               <span class="keywordflow">if</span> (cs-&gt;c_naux != 1)
<a name="l01064"></a>01064                 <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01065"></a>01065                            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;`.bf&#39; symbol %d has no aux entry&quot;</span>),
<a name="l01066"></a>01066                            cs-&gt;c_symnum);
<a name="l01067"></a>01067               fcn_first_line = main_aux.x_sym.x_misc.x_lnsz.x_lnno;
<a name="l01068"></a>01068               fcn_first_line_addr = cs-&gt;c_value;
<a name="l01069"></a>01069 
<a name="l01070"></a>01070               <span class="comment">/* Might want to check that locals are 0 and</span>
<a name="l01071"></a>01071 <span class="comment">                 context_stack_depth is zero, and complain if not.  */</span>
<a name="l01072"></a>01072 
<a name="l01073"></a>01073               depth = 0;
<a name="l01074"></a>01074               <span class="keyword">new</span> = <a class="code" href="buildsym_8c.html#a10dcfe3c3dde25ce70e98261945cadd0">push_context</a> (depth, fcn_start_addr);
<a name="l01075"></a>01075               fcn_cs_saved.c_name = getsymname (&amp;fcn_sym_saved);
<a name="l01076"></a>01076               <span class="keyword">new</span>-&gt;name =
<a name="l01077"></a>01077                 process_coff_symbol (&amp;fcn_cs_saved, 
<a name="l01078"></a>01078                                      &amp;fcn_aux_saved, objfile);
<a name="l01079"></a>01079             }
<a name="l01080"></a>01080           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (cs-&gt;c_name, <span class="stringliteral">&quot;.ef&quot;</span>) == 0)
<a name="l01081"></a>01081             {
<a name="l01082"></a>01082               <span class="keywordflow">if</span> (!<a class="code" href="buildsym_8h.html#ad12032827aa8d87fbe036b7e375d9190">within_function</a>)
<a name="l01083"></a>01083                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Bad coff function information.&quot;</span>));
<a name="l01084"></a>01084               <span class="comment">/* The value of .ef is the address of epilogue code;</span>
<a name="l01085"></a>01085 <span class="comment">                 not useful for gdb.  */</span>
<a name="l01086"></a>01086               <span class="comment">/* { main_aux.x_sym.x_misc.x_lnsz.x_lnno</span>
<a name="l01087"></a>01087 <span class="comment">                 contains number of lines to &#39;}&#39; */</span>
<a name="l01088"></a>01088 
<a name="l01089"></a>01089               <span class="keywordflow">if</span> (<a class="code" href="buildsym_8h.html#ae0be96b381252ebd96109ede811ed7c4">context_stack_depth</a> &lt;= 0)
<a name="l01090"></a>01090                 {       <span class="comment">/* We attempted to pop an empty context stack.  */</span>
<a name="l01091"></a>01091                   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01092"></a>01092                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;`.ef&#39; symbol without matching `.bf&#39; &quot;</span>
<a name="l01093"></a>01093                                <span class="stringliteral">&quot;symbol ignored starting at symnum %d&quot;</span>),
<a name="l01094"></a>01094                              cs-&gt;c_symnum);
<a name="l01095"></a>01095                   <a class="code" href="buildsym_8h.html#ad12032827aa8d87fbe036b7e375d9190">within_function</a> = 0;
<a name="l01096"></a>01096                   <span class="keywordflow">break</span>;
<a name="l01097"></a>01097                 }
<a name="l01098"></a>01098 
<a name="l01099"></a>01099               <span class="keyword">new</span> = <a class="code" href="buildsym_8c.html#ae9abe41b6e678c647893e79758b4f0a5">pop_context</a> ();
<a name="l01100"></a>01100               <span class="comment">/* Stack must be empty now.  */</span>
<a name="l01101"></a>01101               <span class="keywordflow">if</span> (<a class="code" href="buildsym_8h.html#ae0be96b381252ebd96109ede811ed7c4">context_stack_depth</a> &gt; 0 || <span class="keyword">new</span> == NULL)
<a name="l01102"></a>01102                 {
<a name="l01103"></a>01103                   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01104"></a>01104                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unmatched .ef symbol(s) ignored &quot;</span>
<a name="l01105"></a>01105                                <span class="stringliteral">&quot;starting at symnum %d&quot;</span>),
<a name="l01106"></a>01106                              cs-&gt;c_symnum);
<a name="l01107"></a>01107                   <a class="code" href="buildsym_8h.html#ad12032827aa8d87fbe036b7e375d9190">within_function</a> = 0;
<a name="l01108"></a>01108                   <span class="keywordflow">break</span>;
<a name="l01109"></a>01109                 }
<a name="l01110"></a>01110               <span class="keywordflow">if</span> (cs-&gt;c_naux != 1)
<a name="l01111"></a>01111                 {
<a name="l01112"></a>01112                   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01113"></a>01113                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;`.ef&#39; symbol %d has no aux entry&quot;</span>),
<a name="l01114"></a>01114                              cs-&gt;c_symnum);
<a name="l01115"></a>01115                   fcn_last_line = 0x7FFFFFFF;
<a name="l01116"></a>01116                 }
<a name="l01117"></a>01117               <span class="keywordflow">else</span>
<a name="l01118"></a>01118                 {
<a name="l01119"></a>01119                   fcn_last_line = main_aux.x_sym.x_misc.x_lnsz.x_lnno;
<a name="l01120"></a>01120                 }
<a name="l01121"></a>01121               <span class="comment">/* fcn_first_line is the line number of the opening &#39;{&#39;.</span>
<a name="l01122"></a>01122 <span class="comment">                 Do not record it - because it would affect gdb&#39;s idea</span>
<a name="l01123"></a>01123 <span class="comment">                 of the line number of the first statement of the</span>
<a name="l01124"></a>01124 <span class="comment">                 function - except for one-line functions, for which</span>
<a name="l01125"></a>01125 <span class="comment">                 it is also the line number of all the statements and</span>
<a name="l01126"></a>01126 <span class="comment">                 of the closing &#39;}&#39;, and for which we do not have any</span>
<a name="l01127"></a>01127 <span class="comment">                 other statement-line-number.  */</span>
<a name="l01128"></a>01128               <span class="keywordflow">if</span> (fcn_last_line == 1)
<a name="l01129"></a>01129                 <a class="code" href="buildsym_8c.html#aa27b873635715b9ea33b19508c221891">record_line</a> (<a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>, fcn_first_line,
<a name="l01130"></a>01130                              <a class="code" href="gdbarch_8c.html#abee635dc7cb9e9793c6100971df1a859">gdbarch_addr_bits_remove</a> (gdbarch,
<a name="l01131"></a>01131                                                        fcn_first_line_addr));
<a name="l01132"></a>01132               <span class="keywordflow">else</span>
<a name="l01133"></a>01133                 enter_linenos (fcn_line_ptr, fcn_first_line,
<a name="l01134"></a>01134                                fcn_last_line, objfile);
<a name="l01135"></a>01135 
<a name="l01136"></a>01136               <a class="code" href="buildsym_8c.html#a382d9deb73200062937f3974c8d82cba">finish_block</a> (new-&gt;name, &amp;<a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a>,
<a name="l01137"></a>01137                             new-&gt;old_blocks, new-&gt;start_addr,
<a name="l01138"></a>01138                             fcn_cs_saved.c_value
<a name="l01139"></a>01139                             + fcn_aux_saved.x_sym.x_misc.x_fsize
<a name="l01140"></a>01140                             + <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>,
<a name="l01141"></a>01141                                         <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile)),
<a name="l01142"></a>01142                             objfile
<a name="l01143"></a>01143                 );
<a name="l01144"></a>01144               <a class="code" href="buildsym_8h.html#ad12032827aa8d87fbe036b7e375d9190">within_function</a> = 0;
<a name="l01145"></a>01145             }
<a name="l01146"></a>01146           <span class="keywordflow">break</span>;
<a name="l01147"></a>01147 
<a name="l01148"></a>01148         <span class="keywordflow">case</span> C_BLOCK:
<a name="l01149"></a>01149           <span class="keywordflow">if</span> (strcmp (cs-&gt;c_name, <span class="stringliteral">&quot;.bb&quot;</span>) == 0)
<a name="l01150"></a>01150             {
<a name="l01151"></a>01151               tmpaddr = cs-&gt;c_value;
<a name="l01152"></a>01152               tmpaddr += <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>,
<a name="l01153"></a>01153                                    <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l01154"></a>01154               <a class="code" href="buildsym_8c.html#a10dcfe3c3dde25ce70e98261945cadd0">push_context</a> (++depth, tmpaddr);
<a name="l01155"></a>01155             }
<a name="l01156"></a>01156           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (cs-&gt;c_name, <span class="stringliteral">&quot;.eb&quot;</span>) == 0)
<a name="l01157"></a>01157             {
<a name="l01158"></a>01158               <span class="keywordflow">if</span> (<a class="code" href="buildsym_8h.html#ae0be96b381252ebd96109ede811ed7c4">context_stack_depth</a> &lt;= 0)
<a name="l01159"></a>01159                 {       <span class="comment">/* We attempted to pop an empty context stack.  */</span>
<a name="l01160"></a>01160                   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01161"></a>01161                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;`.eb&#39; symbol without matching `.bb&#39; &quot;</span>
<a name="l01162"></a>01162                                <span class="stringliteral">&quot;symbol ignored starting at symnum %d&quot;</span>),
<a name="l01163"></a>01163                              cs-&gt;c_symnum);
<a name="l01164"></a>01164                   <span class="keywordflow">break</span>;
<a name="l01165"></a>01165                 }
<a name="l01166"></a>01166 
<a name="l01167"></a>01167               <span class="keyword">new</span> = <a class="code" href="buildsym_8c.html#ae9abe41b6e678c647893e79758b4f0a5">pop_context</a> ();
<a name="l01168"></a>01168               <span class="keywordflow">if</span> (depth-- != new-&gt;depth)
<a name="l01169"></a>01169                 {
<a name="l01170"></a>01170                   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01171"></a>01171                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Mismatched .eb symbol ignored &quot;</span>
<a name="l01172"></a>01172                                <span class="stringliteral">&quot;starting at symnum %d&quot;</span>),
<a name="l01173"></a>01173                              <a class="code" href="buildsym_8h.html#a79942374faad15785bb8f359a3d83886">symnum</a>);
<a name="l01174"></a>01174                   <span class="keywordflow">break</span>;
<a name="l01175"></a>01175                 }
<a name="l01176"></a>01176               <span class="keywordflow">if</span> (<a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a> &amp;&amp; <a class="code" href="buildsym_8h.html#ae0be96b381252ebd96109ede811ed7c4">context_stack_depth</a> &gt; 0)
<a name="l01177"></a>01177                 {
<a name="l01178"></a>01178                   tmpaddr =
<a name="l01179"></a>01179                     cs-&gt;c_value + <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>,
<a name="l01180"></a>01180                                             <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l01181"></a>01181                   <span class="comment">/* Make a block for the local symbols within.  */</span>
<a name="l01182"></a>01182                   <a class="code" href="buildsym_8c.html#a382d9deb73200062937f3974c8d82cba">finish_block</a> (0, &amp;<a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a>, new-&gt;old_blocks,
<a name="l01183"></a>01183                                 new-&gt;start_addr, tmpaddr, objfile);
<a name="l01184"></a>01184                 }
<a name="l01185"></a>01185               <span class="comment">/* Now pop locals of block just finished.  */</span>
<a name="l01186"></a>01186               <a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a> = <span class="keyword">new</span>-&gt;locals;
<a name="l01187"></a>01187             }
<a name="l01188"></a>01188           <span class="keywordflow">break</span>;
<a name="l01189"></a>01189 
<a name="l01190"></a>01190         <span class="keywordflow">default</span>:
<a name="l01191"></a>01191           process_coff_symbol (cs, &amp;main_aux, objfile);
<a name="l01192"></a>01192           <span class="keywordflow">break</span>;
<a name="l01193"></a>01193         }
<a name="l01194"></a>01194     }
<a name="l01195"></a>01195 
<a name="l01196"></a>01196   <span class="keywordflow">if</span> ((nsyms == 0) &amp;&amp; (pe_file))
<a name="l01197"></a>01197     {
<a name="l01198"></a>01198       <span class="comment">/* We&#39;ve got no debugging symbols, but it&#39;s a portable</span>
<a name="l01199"></a>01199 <span class="comment">         executable, so try to read the export table.  */</span>
<a name="l01200"></a>01200       <a class="code" href="coff-pe-read_8c.html#addc80cffe273d7406bc3410b032996cf">read_pe_exported_syms</a> (objfile);
<a name="l01201"></a>01201     }
<a name="l01202"></a>01202 
<a name="l01203"></a>01203   <span class="keywordflow">if</span> (<a class="code" href="buildsym_8c.html#afe8ed6edc2cd2aba80ae556eda4914fd">get_last_source_file</a> ())
<a name="l01204"></a>01204     coff_end_symtab (objfile);
<a name="l01205"></a>01205 
<a name="l01206"></a>01206   <span class="comment">/* Patch up any opaque types (references to types that are not defined</span>
<a name="l01207"></a>01207 <span class="comment">     in the file where they are referenced, e.g. &quot;struct foo *bar&quot;).  */</span>
<a name="l01208"></a>01208   <a class="code" href="objfiles_8h.html#ad881e45502f8c05088f9c61165fb7d14">ALL_OBJFILE_SYMTABS</a> (objfile, s)
<a name="l01209"></a>01209     patch_opaque_types (s);
<a name="l01210"></a>01210 
<a name="l01211"></a>01211   coffread_objfile = NULL;
<a name="l01212"></a>01212 }
<a name="l01213"></a>01213 
<a name="l01214"></a>01214 <span class="comment">/* Routines for reading headers and symbols from executable.  */</span>
<a name="l01215"></a>01215 
<a name="l01216"></a>01216 <span class="comment">/* Read the next symbol, swap it, and return it in both</span>
<a name="l01217"></a>01217 <span class="comment">   internal_syment form, and coff_symbol form.  Also return its first</span>
<a name="l01218"></a>01218 <span class="comment">   auxent, if any, in internal_auxent form, and skip any other</span>
<a name="l01219"></a>01219 <span class="comment">   auxents.  */</span>
<a name="l01220"></a>01220 
<a name="l01221"></a>01221 static <span class="keywordtype">void</span>
<a name="l01222"></a>01222 read_one_sym (struct coff_symbol *cs,
<a name="l01223"></a>01223               struct internal_syment *sym,
<a name="l01224"></a>01224               union internal_auxent *aux)
<a name="l01225"></a>01225 {
<a name="l01226"></a>01226   <span class="keywordtype">int</span> i;
<a name="l01227"></a>01227   bfd_size_type bytes;
<a name="l01228"></a>01228 
<a name="l01229"></a>01229   cs-&gt;c_symnum = <a class="code" href="buildsym_8h.html#a79942374faad15785bb8f359a3d83886">symnum</a>;
<a name="l01230"></a>01230   bytes = bfd_bread (temp_sym, local_symesz, nlist_bfd_global);
<a name="l01231"></a>01231   <span class="keywordflow">if</span> (bytes != local_symesz)
<a name="l01232"></a>01232     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;%s: error reading symbols&quot;</span>), <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (coffread_objfile));
<a name="l01233"></a>01233   bfd_coff_swap_sym_in (symfile_bfd, temp_sym, (<span class="keywordtype">char</span> *) sym);
<a name="l01234"></a>01234   cs-&gt;c_naux = sym-&gt;n_numaux &amp; 0xff;
<a name="l01235"></a>01235   <span class="keywordflow">if</span> (cs-&gt;c_naux &gt;= 1)
<a name="l01236"></a>01236     {
<a name="l01237"></a>01237       bytes  = bfd_bread (temp_aux, local_auxesz, nlist_bfd_global);
<a name="l01238"></a>01238       <span class="keywordflow">if</span> (bytes != local_auxesz)
<a name="l01239"></a>01239         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;%s: error reading symbols&quot;</span>), <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (coffread_objfile));
<a name="l01240"></a>01240       bfd_coff_swap_aux_in (symfile_bfd, temp_aux,
<a name="l01241"></a>01241                             sym-&gt;n_type, sym-&gt;n_sclass,
<a name="l01242"></a>01242                             0, cs-&gt;c_naux, (<span class="keywordtype">char</span> *) aux);
<a name="l01243"></a>01243       <span class="comment">/* If more than one aux entry, read past it (only the first aux</span>
<a name="l01244"></a>01244 <span class="comment">         is important).  */</span>
<a name="l01245"></a>01245       <span class="keywordflow">for</span> (i = 1; i &lt; cs-&gt;c_naux; i++)
<a name="l01246"></a>01246         {
<a name="l01247"></a>01247           bytes = bfd_bread (temp_aux, local_auxesz, nlist_bfd_global);
<a name="l01248"></a>01248           <span class="keywordflow">if</span> (bytes != local_auxesz)
<a name="l01249"></a>01249             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;%s: error reading symbols&quot;</span>),
<a name="l01250"></a>01250                    <a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (coffread_objfile));
<a name="l01251"></a>01251         }
<a name="l01252"></a>01252     }
<a name="l01253"></a>01253   cs-&gt;c_name = getsymname (sym);
<a name="l01254"></a>01254   cs-&gt;c_value = sym-&gt;n_value;
<a name="l01255"></a>01255   cs-&gt;c_sclass = (sym-&gt;n_sclass &amp; 0xff);
<a name="l01256"></a>01256   cs-&gt;c_secnum = sym-&gt;n_scnum;
<a name="l01257"></a>01257   cs-&gt;c_type = (unsigned) sym-&gt;n_type;
<a name="l01258"></a>01258   if (!<a class="code" href="coffread_8c.html#a524571ce1b33bf4a8a0b63de733e8789">SDB_TYPE</a> (cs-&gt;c_type))
<a name="l01259"></a>01259     cs-&gt;c_type = 0;
<a name="l01260"></a>01260 
<a name="l01261"></a>01261 #<span class="keywordflow">if</span> 0
<a name="l01262"></a>01262   if (cs-&gt;c_sclass &amp; 128)
<a name="l01263"></a>01263     printf (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;thumb symbol %s, class 0x%x\n&quot;</span>), cs-&gt;c_name, cs-&gt;c_sclass);
<a name="l01264"></a>01264 <span class="preprocessor">#endif</span>
<a name="l01265"></a>01265 <span class="preprocessor"></span>
<a name="l01266"></a>01266   <a class="code" href="buildsym_8h.html#a79942374faad15785bb8f359a3d83886">symnum</a> += 1 + cs-&gt;c_naux;
<a name="l01267"></a>01267 
<a name="l01268"></a>01268   <span class="comment">/* The PE file format stores symbol values as offsets within the</span>
<a name="l01269"></a>01269 <span class="comment">     section, rather than as absolute addresses.  We correct that</span>
<a name="l01270"></a>01270 <span class="comment">     here, if the symbol has an appropriate storage class.  FIXME: We</span>
<a name="l01271"></a>01271 <span class="comment">     should use BFD to read the symbols, rather than duplicating the</span>
<a name="l01272"></a>01272 <span class="comment">     work here.  */</span>
<a name="l01273"></a>01273   <span class="keywordflow">if</span> (pe_file)
<a name="l01274"></a>01274     {
<a name="l01275"></a>01275       <span class="keywordflow">switch</span> (cs-&gt;c_sclass)
<a name="l01276"></a>01276         {
<a name="l01277"></a>01277         <span class="keywordflow">case</span> C_EXT:
<a name="l01278"></a>01278         <span class="keywordflow">case</span> C_THUMBEXT:
<a name="l01279"></a>01279         <span class="keywordflow">case</span> C_THUMBEXTFUNC:
<a name="l01280"></a>01280         <span class="keywordflow">case</span> C_SECTION:
<a name="l01281"></a>01281         <span class="keywordflow">case</span> C_NT_WEAK:
<a name="l01282"></a>01282         <span class="keywordflow">case</span> C_STAT:
<a name="l01283"></a>01283         <span class="keywordflow">case</span> C_THUMBSTAT:
<a name="l01284"></a>01284         <span class="keywordflow">case</span> C_THUMBSTATFUNC:
<a name="l01285"></a>01285         <span class="keywordflow">case</span> C_LABEL:
<a name="l01286"></a>01286         <span class="keywordflow">case</span> C_THUMBLABEL:
<a name="l01287"></a>01287         <span class="keywordflow">case</span> C_BLOCK:
<a name="l01288"></a>01288         <span class="keywordflow">case</span> C_FCN:
<a name="l01289"></a>01289         <span class="keywordflow">case</span> C_EFCN:
<a name="l01290"></a>01290           <span class="keywordflow">if</span> (cs-&gt;c_secnum != 0)
<a name="l01291"></a>01291             cs-&gt;c_value += cs_section_address (cs, symfile_bfd);
<a name="l01292"></a>01292           <span class="keywordflow">break</span>;
<a name="l01293"></a>01293         }
<a name="l01294"></a>01294     }
<a name="l01295"></a>01295 }
<a name="l01296"></a>01296 
<a name="l01297"></a>01297 <span class="comment">/* Support for string table handling.  */</span>
<a name="l01298"></a>01298 
<a name="l01299"></a>01299 <span class="keyword">static</span> <span class="keywordtype">char</span> *stringtab = NULL;
<a name="l01300"></a>01300 
<a name="l01301"></a>01301 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01302"></a>01302 init_stringtab (bfd *abfd, <span class="keywordtype">long</span> offset)
<a name="l01303"></a>01303 {
<a name="l01304"></a>01304   <span class="keywordtype">long</span> length;
<a name="l01305"></a>01305   <span class="keywordtype">int</span> val;
<a name="l01306"></a>01306   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lengthbuf[4];
<a name="l01307"></a>01307 
<a name="l01308"></a>01308   free_stringtab ();
<a name="l01309"></a>01309 
<a name="l01310"></a>01310   <span class="comment">/* If the file is stripped, the offset might be zero, indicating no</span>
<a name="l01311"></a>01311 <span class="comment">     string table.  Just return with `stringtab&#39; set to null.  */</span>
<a name="l01312"></a>01312   <span class="keywordflow">if</span> (offset == 0)
<a name="l01313"></a>01313     <span class="keywordflow">return</span> 0;
<a name="l01314"></a>01314 
<a name="l01315"></a>01315   <span class="keywordflow">if</span> (bfd_seek (abfd, offset, 0) &lt; 0)
<a name="l01316"></a>01316     <span class="keywordflow">return</span> -1;
<a name="l01317"></a>01317 
<a name="l01318"></a>01318   val = bfd_bread ((<span class="keywordtype">char</span> *) lengthbuf, <span class="keyword">sizeof</span> lengthbuf, abfd);
<a name="l01319"></a>01319   length = bfd_h_get_32 (symfile_bfd, lengthbuf);
<a name="l01320"></a>01320 
<a name="l01321"></a>01321   <span class="comment">/* If no string table is needed, then the file may end immediately</span>
<a name="l01322"></a>01322 <span class="comment">     after the symbols.  Just return with `stringtab&#39; set to null.  */</span>
<a name="l01323"></a>01323   <span class="keywordflow">if</span> (val != <span class="keyword">sizeof</span> lengthbuf || length &lt; <span class="keyword">sizeof</span> lengthbuf)
<a name="l01324"></a>01324     <span class="keywordflow">return</span> 0;
<a name="l01325"></a>01325 
<a name="l01326"></a>01326   stringtab = (<span class="keywordtype">char</span> *) <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (length);
<a name="l01327"></a>01327   <span class="comment">/* This is in target format (probably not very useful, and not</span>
<a name="l01328"></a>01328 <span class="comment">     currently used), not host format.  */</span>
<a name="l01329"></a>01329   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (stringtab, lengthbuf, <span class="keyword">sizeof</span> lengthbuf);
<a name="l01330"></a>01330   <span class="keywordflow">if</span> (length == <span class="keyword">sizeof</span> length)  <span class="comment">/* Empty table -- just the count.  */</span>
<a name="l01331"></a>01331     <span class="keywordflow">return</span> 0;
<a name="l01332"></a>01332 
<a name="l01333"></a>01333   val = bfd_bread (stringtab + <span class="keyword">sizeof</span> lengthbuf, 
<a name="l01334"></a>01334                    length - <span class="keyword">sizeof</span> lengthbuf, abfd);
<a name="l01335"></a>01335   <span class="keywordflow">if</span> (val != length - <span class="keyword">sizeof</span> lengthbuf || stringtab[length - 1] != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l01336"></a>01336     <span class="keywordflow">return</span> -1;
<a name="l01337"></a>01337 
<a name="l01338"></a>01338   <span class="keywordflow">return</span> 0;
<a name="l01339"></a>01339 }
<a name="l01340"></a>01340 
<a name="l01341"></a>01341 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01342"></a>01342 free_stringtab (<span class="keywordtype">void</span>)
<a name="l01343"></a>01343 {
<a name="l01344"></a>01344   <span class="keywordflow">if</span> (stringtab)
<a name="l01345"></a>01345     <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (stringtab);
<a name="l01346"></a>01346   stringtab = NULL;
<a name="l01347"></a>01347 }
<a name="l01348"></a>01348 
<a name="l01349"></a>01349 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01350"></a>01350 free_stringtab_cleanup (<span class="keywordtype">void</span> *ignore)
<a name="l01351"></a>01351 {
<a name="l01352"></a>01352   free_stringtab ();
<a name="l01353"></a>01353 }
<a name="l01354"></a>01354 
<a name="l01355"></a>01355 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l01356"></a>01356 getsymname (<span class="keyword">struct</span> internal_syment *symbol_entry)
<a name="l01357"></a>01357 {
<a name="l01358"></a>01358   <span class="keyword">static</span> <span class="keywordtype">char</span> <a class="code" href="structbuffer.html">buffer</a>[SYMNMLEN + 1];
<a name="l01359"></a>01359   <span class="keywordtype">char</span> *result;
<a name="l01360"></a>01360 
<a name="l01361"></a>01361   <span class="keywordflow">if</span> (symbol_entry-&gt;_n._n_n._n_zeroes == 0)
<a name="l01362"></a>01362     {
<a name="l01363"></a>01363       <span class="comment">/* FIXME: Probably should be detecting corrupt symbol files by</span>
<a name="l01364"></a>01364 <span class="comment">         seeing whether offset points to within the stringtab.  */</span>
<a name="l01365"></a>01365       result = stringtab + symbol_entry-&gt;_n._n_n._n_offset;
<a name="l01366"></a>01366     }
<a name="l01367"></a>01367   <span class="keywordflow">else</span>
<a name="l01368"></a>01368     {
<a name="l01369"></a>01369       strncpy (buffer, symbol_entry-&gt;_n._n_name, SYMNMLEN);
<a name="l01370"></a>01370       buffer[SYMNMLEN] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l01371"></a>01371       result = buffer;
<a name="l01372"></a>01372     }
<a name="l01373"></a>01373   <span class="keywordflow">return</span> result;
<a name="l01374"></a>01374 }
<a name="l01375"></a>01375 
<a name="l01376"></a>01376 <span class="comment">/* Extract the file name from the aux entry of a C_FILE symbol.</span>
<a name="l01377"></a>01377 <span class="comment">   Return only the last component of the name.  Result is in static</span>
<a name="l01378"></a>01378 <span class="comment">   storage and is only good for temporary use.  */</span>
<a name="l01379"></a>01379 
<a name="l01380"></a>01380 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l01381"></a>01381 coff_getfilename (<span class="keyword">union</span> internal_auxent *aux_entry)
<a name="l01382"></a>01382 {
<a name="l01383"></a>01383   <span class="keyword">static</span> <span class="keywordtype">char</span> buffer[BUFSIZ];
<a name="l01384"></a>01384   <span class="keyword">const</span> <span class="keywordtype">char</span> *result;
<a name="l01385"></a>01385 
<a name="l01386"></a>01386   <span class="keywordflow">if</span> (aux_entry-&gt;x_file.x_n.x_zeroes == 0)
<a name="l01387"></a>01387     {
<a name="l01388"></a>01388       <span class="keywordflow">if</span> (strlen (stringtab + aux_entry-&gt;x_file.x_n.x_offset) &gt;= BUFSIZ)
<a name="l01389"></a>01389         <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;coff file name too long&quot;</span>));
<a name="l01390"></a>01390       strcpy (buffer, stringtab + aux_entry-&gt;x_file.x_n.x_offset);
<a name="l01391"></a>01391     }
<a name="l01392"></a>01392   <span class="keywordflow">else</span>
<a name="l01393"></a>01393     {
<a name="l01394"></a>01394       strncpy (buffer, aux_entry-&gt;x_file.x_fname, FILNMLEN);
<a name="l01395"></a>01395       buffer[FILNMLEN] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l01396"></a>01396     }
<a name="l01397"></a>01397   result = buffer;
<a name="l01398"></a>01398 
<a name="l01399"></a>01399   <span class="comment">/* FIXME: We should not be throwing away the information about what</span>
<a name="l01400"></a>01400 <span class="comment">     directory.  It should go into dirname of the symtab, or some such</span>
<a name="l01401"></a>01401 <span class="comment">     place.  */</span>
<a name="l01402"></a>01402   result = lbasename (result);
<a name="l01403"></a>01403   <span class="keywordflow">return</span> (result);
<a name="l01404"></a>01404 }
<a name="l01405"></a>01405 
<a name="l01406"></a>01406 <span class="comment">/* Support for line number handling.  */</span>
<a name="l01407"></a>01407 
<a name="l01408"></a>01408 <span class="keyword">static</span> <span class="keywordtype">char</span> *linetab = NULL;
<a name="l01409"></a>01409 <span class="keyword">static</span> <span class="keywordtype">long</span> linetab_offset;
<a name="l01410"></a>01410 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> linetab_size;
<a name="l01411"></a>01411 
<a name="l01412"></a>01412 <span class="comment">/* Read in all the line numbers for fast lookups later.  Leave them in</span>
<a name="l01413"></a>01413 <span class="comment">   external (unswapped) format in memory; we&#39;ll swap them as we enter</span>
<a name="l01414"></a>01414 <span class="comment">   them into GDB&#39;s data structures.  */</span>
<a name="l01415"></a>01415 
<a name="l01416"></a>01416 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01417"></a>01417 init_lineno (bfd *abfd, <span class="keywordtype">long</span> offset, <span class="keywordtype">int</span> size)
<a name="l01418"></a>01418 {
<a name="l01419"></a>01419   <span class="keywordtype">int</span> val;
<a name="l01420"></a>01420 
<a name="l01421"></a>01421   linetab_offset = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l01422"></a>01422   linetab_size = <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l01423"></a>01423 
<a name="l01424"></a>01424   free_linetab ();
<a name="l01425"></a>01425 
<a name="l01426"></a>01426   <span class="keywordflow">if</span> (size == 0)
<a name="l01427"></a>01427     <span class="keywordflow">return</span> 0;
<a name="l01428"></a>01428 
<a name="l01429"></a>01429   <span class="keywordflow">if</span> (bfd_seek (abfd, offset, 0) &lt; 0)
<a name="l01430"></a>01430     <span class="keywordflow">return</span> -1;
<a name="l01431"></a>01431 
<a name="l01432"></a>01432   <span class="comment">/* Allocate the desired table, plus a sentinel.  */</span>
<a name="l01433"></a>01433   linetab = (<span class="keywordtype">char</span> *) <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (size + local_linesz);
<a name="l01434"></a>01434 
<a name="l01435"></a>01435   val = bfd_bread (linetab, size, abfd);
<a name="l01436"></a>01436   <span class="keywordflow">if</span> (val != size)
<a name="l01437"></a>01437     <span class="keywordflow">return</span> -1;
<a name="l01438"></a>01438 
<a name="l01439"></a>01439   <span class="comment">/* Terminate it with an all-zero sentinel record.  */</span>
<a name="l01440"></a>01440   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (linetab + size, 0, local_linesz);
<a name="l01441"></a>01441 
<a name="l01442"></a>01442   <span class="keywordflow">return</span> 0;
<a name="l01443"></a>01443 }
<a name="l01444"></a>01444 
<a name="l01445"></a>01445 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01446"></a>01446 free_linetab (<span class="keywordtype">void</span>)
<a name="l01447"></a>01447 {
<a name="l01448"></a>01448   <span class="keywordflow">if</span> (linetab)
<a name="l01449"></a>01449     <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (linetab);
<a name="l01450"></a>01450   linetab = NULL;
<a name="l01451"></a>01451 }
<a name="l01452"></a>01452 
<a name="l01453"></a>01453 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01454"></a>01454 free_linetab_cleanup (<span class="keywordtype">void</span> *ignore)
<a name="l01455"></a>01455 {
<a name="l01456"></a>01456   free_linetab ();
<a name="l01457"></a>01457 }
<a name="l01458"></a>01458 
<a name="l01459"></a>01459 <span class="preprocessor">#if !defined (L_LNNO32)</span>
<a name="l01460"></a><a class="code" href="coffread_8c.html#a0bf8a030b9f0eeb07deab0bf2025724c">01460</a> <span class="preprocessor"></span><span class="preprocessor">#define L_LNNO32(lp) ((lp)-&gt;l_lnno)</span>
<a name="l01461"></a>01461 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01462"></a>01462 <span class="preprocessor"></span>
<a name="l01463"></a>01463 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01464"></a>01464 enter_linenos (<span class="keywordtype">long</span> file_offset, <span class="keywordtype">int</span> first_line,
<a name="l01465"></a>01465                <span class="keywordtype">int</span> last_line, <span class="keyword">struct</span> objfile *objfile)
<a name="l01466"></a>01466 {
<a name="l01467"></a>01467   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l01468"></a>01468   <span class="keywordtype">char</span> *rawptr;
<a name="l01469"></a>01469   <span class="keyword">struct </span>internal_lineno lptr;
<a name="l01470"></a>01470 
<a name="l01471"></a>01471   <span class="keywordflow">if</span> (!linetab)
<a name="l01472"></a>01472     <span class="keywordflow">return</span>;
<a name="l01473"></a>01473   <span class="keywordflow">if</span> (file_offset &lt; linetab_offset)
<a name="l01474"></a>01474     {
<a name="l01475"></a>01475       <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01476"></a>01476                  <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Line number pointer %ld lower than start of line numbers&quot;</span>),
<a name="l01477"></a>01477                  file_offset);
<a name="l01478"></a>01478       <span class="keywordflow">if</span> (file_offset &gt; linetab_size)   <span class="comment">/* Too big to be an offset?  */</span>
<a name="l01479"></a>01479         <span class="keywordflow">return</span>;
<a name="l01480"></a>01480       file_offset += linetab_offset;    <span class="comment">/* Try reading at that linetab</span>
<a name="l01481"></a>01481 <span class="comment">                                           offset.  */</span>
<a name="l01482"></a>01482     }
<a name="l01483"></a>01483 
<a name="l01484"></a>01484   rawptr = &amp;linetab[file_offset - linetab_offset];
<a name="l01485"></a>01485 
<a name="l01486"></a>01486   <span class="comment">/* Skip first line entry for each function.  */</span>
<a name="l01487"></a>01487   rawptr += local_linesz;
<a name="l01488"></a>01488   <span class="comment">/* Line numbers start at one for the first line of the function.  */</span>
<a name="l01489"></a>01489   first_line--;
<a name="l01490"></a>01490 
<a name="l01491"></a>01491   <span class="comment">/* If the line number table is full (e.g. 64K lines in COFF debug</span>
<a name="l01492"></a>01492 <span class="comment">     info), the next function&#39;s L_LNNO32 might not be zero, so don&#39;t</span>
<a name="l01493"></a>01493 <span class="comment">     overstep the table&#39;s end in any case.  */</span>
<a name="l01494"></a>01494   <span class="keywordflow">while</span> (rawptr &lt;= &amp;linetab[0] + linetab_size)
<a name="l01495"></a>01495     {
<a name="l01496"></a>01496       bfd_coff_swap_lineno_in (symfile_bfd, rawptr, &amp;lptr);
<a name="l01497"></a>01497       rawptr += local_linesz;
<a name="l01498"></a>01498       <span class="comment">/* The next function, or the sentinel, will have L_LNNO32 zero;</span>
<a name="l01499"></a>01499 <span class="comment">         we exit.  */</span>
<a name="l01500"></a>01500       <span class="keywordflow">if</span> (<a class="code" href="coffread_8c.html#a0bf8a030b9f0eeb07deab0bf2025724c">L_LNNO32</a> (&amp;lptr) &amp;&amp; <a class="code" href="coffread_8c.html#a0bf8a030b9f0eeb07deab0bf2025724c">L_LNNO32</a> (&amp;lptr) &lt;= last_line)
<a name="l01501"></a>01501         {
<a name="l01502"></a>01502           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr = lptr.l_addr.l_paddr;
<a name="l01503"></a>01503           addr += <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>,
<a name="l01504"></a>01504                             <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l01505"></a>01505           <a class="code" href="buildsym_8c.html#aa27b873635715b9ea33b19508c221891">record_line</a> (<a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>,
<a name="l01506"></a>01506                        first_line + <a class="code" href="coffread_8c.html#a0bf8a030b9f0eeb07deab0bf2025724c">L_LNNO32</a> (&amp;lptr),
<a name="l01507"></a>01507                        <a class="code" href="gdbarch_8c.html#abee635dc7cb9e9793c6100971df1a859">gdbarch_addr_bits_remove</a> (gdbarch, addr));
<a name="l01508"></a>01508         }
<a name="l01509"></a>01509       <span class="keywordflow">else</span>
<a name="l01510"></a>01510         <span class="keywordflow">break</span>;
<a name="l01511"></a>01511     }
<a name="l01512"></a>01512 }
<a name="l01513"></a>01513 
<a name="l01514"></a>01514 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01515"></a>01515 patch_type (<span class="keyword">struct</span> type *type, <span class="keyword">struct</span> type *real_type)
<a name="l01516"></a>01516 {
<a name="l01517"></a>01517   <span class="keyword">struct </span>type *target = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l01518"></a>01518   <span class="keyword">struct </span>type *real_target = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (real_type);
<a name="l01519"></a>01519   <span class="keywordtype">int</span> field_size = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (real_target) * <span class="keyword">sizeof</span> (<span class="keyword">struct </span>field);
<a name="l01520"></a>01520 
<a name="l01521"></a>01521   <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (target) = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (real_target);
<a name="l01522"></a>01522   <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (target) = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (real_target);
<a name="l01523"></a>01523   <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (target) = (<span class="keyword">struct </span>field *) <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (target,
<a name="l01524"></a>01524                                                       field_size);
<a name="l01525"></a>01525 
<a name="l01526"></a>01526   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (target), 
<a name="l01527"></a>01527           <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (real_target), 
<a name="l01528"></a>01528           field_size);
<a name="l01529"></a>01529 
<a name="l01530"></a>01530   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (real_target))
<a name="l01531"></a>01531     {
<a name="l01532"></a>01532       <span class="comment">/* The previous copy of TYPE_NAME is allocated by</span>
<a name="l01533"></a>01533 <span class="comment">         process_coff_symbol.  */</span>
<a name="l01534"></a>01534       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (target))
<a name="l01535"></a>01535         <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> ((<span class="keywordtype">char</span>*) <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (target));
<a name="l01536"></a>01536       <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (target) = xstrdup (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (real_target));
<a name="l01537"></a>01537     }
<a name="l01538"></a>01538 }
<a name="l01539"></a>01539 
<a name="l01540"></a>01540 <span class="comment">/* Patch up all appropriate typedef symbols in the opaque_type_chains</span>
<a name="l01541"></a>01541 <span class="comment">   so that they can be used to print out opaque data structures</span>
<a name="l01542"></a>01542 <span class="comment">   properly.  */</span>
<a name="l01543"></a>01543 
<a name="l01544"></a>01544 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01545"></a>01545 patch_opaque_types (<span class="keyword">struct</span> <a class="code" href="structsymtab.html">symtab</a> *s)
<a name="l01546"></a>01546 {
<a name="l01547"></a>01547   <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *b;
<a name="l01548"></a>01548   <span class="keyword">struct </span><a class="code" href="structblock__iterator.html">block_iterator</a> iter;
<a name="l01549"></a>01549   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *real_sym;
<a name="l01550"></a>01550 
<a name="l01551"></a>01551   <span class="comment">/* Go through the per-file symbols only.  */</span>
<a name="l01552"></a>01552   b = <a class="code" href="block_8h.html#a84c4a3aa7b6b4d9a127a1c018dd6a776">BLOCKVECTOR_BLOCK</a> (<a class="code" href="symtab_8h.html#a6cd84410d73680ff8006ac44b1b98a9c">BLOCKVECTOR</a> (s), <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124a4842990ca5391ee943c2069b28443a99">STATIC_BLOCK</a>);
<a name="l01553"></a>01553   <a class="code" href="block_8h.html#a0ffb1db4f5e3a6fd58700861fce48c2b">ALL_BLOCK_SYMBOLS</a> (b, iter, real_sym)
<a name="l01554"></a>01554     {
<a name="l01555"></a>01555       <span class="comment">/* Find completed typedefs to use to fix opaque ones.</span>
<a name="l01556"></a>01556 <span class="comment">         Remove syms from the chain when their types are stored,</span>
<a name="l01557"></a>01557 <span class="comment">         but search the whole chain, as there may be several syms</span>
<a name="l01558"></a>01558 <span class="comment">         from different files with the same name.  */</span>
<a name="l01559"></a>01559       <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (real_sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>
<a name="l01560"></a>01560           &amp;&amp; <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (real_sym) == <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>
<a name="l01561"></a>01561           &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (real_sym)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l01562"></a>01562           &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (real_sym))) != 0)
<a name="l01563"></a>01563         {
<a name="l01564"></a>01564           <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (real_sym);
<a name="l01565"></a>01565           <span class="keywordtype">int</span> <a class="code" href="bcache_8c.html#a680b4550cc69a0827af4a7169fe3c372">hash</a> = <a class="code" href="buildsym_8c.html#a74ea426b970d55be327c2e2b5c165c28">hashname</a> (name);
<a name="l01566"></a>01566           <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym, *prev;
<a name="l01567"></a>01567 
<a name="l01568"></a>01568           prev = 0;
<a name="l01569"></a>01569           <span class="keywordflow">for</span> (sym = opaque_type_chain[hash]; sym;)
<a name="l01570"></a>01570             {
<a name="l01571"></a>01571               <span class="keywordflow">if</span> (name[0] == <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym)[0]
<a name="l01572"></a>01572                   &amp;&amp; strcmp (name + 1, <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym) + 1) == 0)
<a name="l01573"></a>01573                 {
<a name="l01574"></a>01574                   <span class="keywordflow">if</span> (prev)
<a name="l01575"></a>01575                     {
<a name="l01576"></a>01576                       <a class="code" href="symtab_8h.html#a2178fcf28e88c29f3965bb1decdd6eaf">SYMBOL_VALUE_CHAIN</a> (prev) = <a class="code" href="symtab_8h.html#a2178fcf28e88c29f3965bb1decdd6eaf">SYMBOL_VALUE_CHAIN</a> (sym);
<a name="l01577"></a>01577                     }
<a name="l01578"></a>01578                   <span class="keywordflow">else</span>
<a name="l01579"></a>01579                     {
<a name="l01580"></a>01580                       opaque_type_chain[<a class="code" href="bcache_8c.html#a680b4550cc69a0827af4a7169fe3c372">hash</a>] = <a class="code" href="symtab_8h.html#a2178fcf28e88c29f3965bb1decdd6eaf">SYMBOL_VALUE_CHAIN</a> (sym);
<a name="l01581"></a>01581                     }
<a name="l01582"></a>01582 
<a name="l01583"></a>01583                   patch_type (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym), <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (real_sym));
<a name="l01584"></a>01584 
<a name="l01585"></a>01585                   <span class="keywordflow">if</span> (prev)
<a name="l01586"></a>01586                     {
<a name="l01587"></a>01587                       sym = <a class="code" href="symtab_8h.html#a2178fcf28e88c29f3965bb1decdd6eaf">SYMBOL_VALUE_CHAIN</a> (prev);
<a name="l01588"></a>01588                     }
<a name="l01589"></a>01589                   <span class="keywordflow">else</span>
<a name="l01590"></a>01590                     {
<a name="l01591"></a>01591                       sym = opaque_type_chain[<a class="code" href="bcache_8c.html#a680b4550cc69a0827af4a7169fe3c372">hash</a>];
<a name="l01592"></a>01592                     }
<a name="l01593"></a>01593                 }
<a name="l01594"></a>01594               <span class="keywordflow">else</span>
<a name="l01595"></a>01595                 {
<a name="l01596"></a>01596                   prev = sym;
<a name="l01597"></a>01597                   sym = <a class="code" href="symtab_8h.html#a2178fcf28e88c29f3965bb1decdd6eaf">SYMBOL_VALUE_CHAIN</a> (sym);
<a name="l01598"></a>01598                 }
<a name="l01599"></a>01599             }
<a name="l01600"></a>01600         }
<a name="l01601"></a>01601     }
<a name="l01602"></a>01602 }
<a name="l01603"></a>01603 
<a name="l01604"></a>01604 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01605"></a>01605 coff_reg_to_regnum (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym, <span class="keyword">struct</span> gdbarch *gdbarch)
<a name="l01606"></a>01606 {
<a name="l01607"></a>01607   <span class="keywordflow">return</span> <a class="code" href="gdbarch_8c.html#a2c757c3ad3fad5753e8b65d642e44f54">gdbarch_sdb_reg_to_regnum</a> (gdbarch, <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (sym));
<a name="l01608"></a>01608 }
<a name="l01609"></a>01609 
<a name="l01610"></a>01610 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structsymbol__register__ops.html">symbol_register_ops</a> coff_register_funcs = {
<a name="l01611"></a>01611   coff_reg_to_regnum
<a name="l01612"></a>01612 };
<a name="l01613"></a>01613 
<a name="l01614"></a>01614 <span class="comment">/* The &quot;aclass&quot; index for computed COFF symbols.  */</span>
<a name="l01615"></a>01615 
<a name="l01616"></a>01616 <span class="keyword">static</span> <span class="keywordtype">int</span> coff_register_index;
<a name="l01617"></a>01617 
<a name="l01618"></a>01618 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *
<a name="l01619"></a>01619 process_coff_symbol (<span class="keyword">struct</span> coff_symbol *cs,
<a name="l01620"></a>01620                      <span class="keyword">union</span> internal_auxent *aux,
<a name="l01621"></a>01621                      <span class="keyword">struct</span> objfile *objfile)
<a name="l01622"></a>01622 {
<a name="l01623"></a>01623   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym = <a class="code" href="symtab_8c.html#a6a7a23ba37378ec001ecd461c5137b83">allocate_symbol</a> (objfile);
<a name="l01624"></a>01624   <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01625"></a>01625 
<a name="l01626"></a>01626   name = cs-&gt;c_name;
<a name="l01627"></a>01627   name = <a class="code" href="coffread_8c.html#ad0ce851a5c1199535edf32fd6d254502">EXTERNAL_NAME</a> (name, objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>);
<a name="l01628"></a>01628   <a class="code" href="symtab_8h.html#add78e67f78de1edd9f8aa220f11bfd89">SYMBOL_SET_LANGUAGE</a> (sym, <a class="code" href="buildsym_8h.html#a49c8794479e81df105115bda8c1f297a">current_subfile</a>-&gt;<a class="code" href="structsubfile.html#ab029142a675cd734324b9d732ff44963">language</a>,
<a name="l01629"></a>01629                        &amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>);
<a name="l01630"></a>01630   <a class="code" href="symtab_8h.html#a1f31078ca0e1d9517eb48e71fe7d53f9">SYMBOL_SET_NAMES</a> (sym, name, strlen (name), 1, objfile);
<a name="l01631"></a>01631 
<a name="l01632"></a>01632   <span class="comment">/* default assumptions */</span>
<a name="l01633"></a>01633   <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (sym) = cs-&gt;c_value;
<a name="l01634"></a>01634   <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym) = <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>;
<a name="l01635"></a>01635   <a class="code" href="symtab_8h.html#a9e82ed3317c58c4b85104d87e738fada">SYMBOL_SECTION</a> (sym) = cs_to_section (cs, objfile);
<a name="l01636"></a>01636 
<a name="l01637"></a>01637   <span class="keywordflow">if</span> (ISFCN (cs-&gt;c_type))
<a name="l01638"></a>01638     {
<a name="l01639"></a>01639       <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (sym) += <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>,
<a name="l01640"></a>01640                                       <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l01641"></a>01641       <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym) =
<a name="l01642"></a>01642         <a class="code" href="gdbtypes_8c.html#ab21dd6531306fba2a7078534017df6fb">lookup_function_type</a> (decode_function_type (cs, cs-&gt;c_type,
<a name="l01643"></a>01643                                                     aux, objfile));
<a name="l01644"></a>01644 
<a name="l01645"></a>01645       <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>;
<a name="l01646"></a>01646       <span class="keywordflow">if</span> (cs-&gt;c_sclass == C_STAT || cs-&gt;c_sclass == C_THUMBSTAT
<a name="l01647"></a>01647           || cs-&gt;c_sclass == C_THUMBSTATFUNC)
<a name="l01648"></a>01648         <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, &amp;<a class="code" href="buildsym_8h.html#a2d83ed7f7eeffeffeb2e00320573fd0d">file_symbols</a>);
<a name="l01649"></a>01649       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cs-&gt;c_sclass == C_EXT || cs-&gt;c_sclass == C_THUMBEXT
<a name="l01650"></a>01650                || cs-&gt;c_sclass == C_THUMBEXTFUNC)
<a name="l01651"></a>01651         <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, &amp;<a class="code" href="buildsym_8h.html#a759a37cb08a814d2400a8241ce11387d">global_symbols</a>);
<a name="l01652"></a>01652     }
<a name="l01653"></a>01653   <span class="keywordflow">else</span>
<a name="l01654"></a>01654     {
<a name="l01655"></a>01655       <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym) = decode_type (cs, cs-&gt;c_type, aux, objfile);
<a name="l01656"></a>01656       <span class="keywordflow">switch</span> (cs-&gt;c_sclass)
<a name="l01657"></a>01657         {
<a name="l01658"></a>01658         <span class="keywordflow">case</span> C_NULL:
<a name="l01659"></a>01659           <span class="keywordflow">break</span>;
<a name="l01660"></a>01660 
<a name="l01661"></a>01661         <span class="keywordflow">case</span> C_AUTO:
<a name="l01662"></a>01662           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a495b83fa459ac0722b15a3e94afadbce">LOC_LOCAL</a>;
<a name="l01663"></a>01663           <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, &amp;<a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a>);
<a name="l01664"></a>01664           <span class="keywordflow">break</span>;
<a name="l01665"></a>01665 
<a name="l01666"></a>01666         <span class="keywordflow">case</span> C_THUMBEXT:
<a name="l01667"></a>01667         <span class="keywordflow">case</span> C_THUMBEXTFUNC:
<a name="l01668"></a>01668         <span class="keywordflow">case</span> C_EXT:
<a name="l01669"></a>01669           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a154b256439f7acd7ec7f6257d5881a0f">LOC_STATIC</a>;
<a name="l01670"></a>01670           <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (sym) = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) cs-&gt;c_value;
<a name="l01671"></a>01671           <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (sym) += <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>,
<a name="l01672"></a>01672                                                   <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l01673"></a>01673           <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, &amp;<a class="code" href="buildsym_8h.html#a759a37cb08a814d2400a8241ce11387d">global_symbols</a>);
<a name="l01674"></a>01674           <span class="keywordflow">break</span>;
<a name="l01675"></a>01675 
<a name="l01676"></a>01676         <span class="keywordflow">case</span> C_THUMBSTAT:
<a name="l01677"></a>01677         <span class="keywordflow">case</span> C_THUMBSTATFUNC:
<a name="l01678"></a>01678         <span class="keywordflow">case</span> C_STAT:
<a name="l01679"></a>01679           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a154b256439f7acd7ec7f6257d5881a0f">LOC_STATIC</a>;
<a name="l01680"></a>01680           <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (sym) = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) cs-&gt;c_value;
<a name="l01681"></a>01681           <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (sym) += <a class="code" href="symtab_8h.html#ab72b539d710f3a5a3857df5d387c4af3">ANOFFSET</a> (objfile-&gt;<a class="code" href="structobjfile.html#a6cd3e806ee207250016f8bebf864ade0">section_offsets</a>,
<a name="l01682"></a>01682                                                   <a class="code" href="objfiles_8h.html#a83de51cc69bcdda3864a605b939a518e">SECT_OFF_TEXT</a> (objfile));
<a name="l01683"></a>01683           <span class="keywordflow">if</span> (<a class="code" href="buildsym_8h.html#ad12032827aa8d87fbe036b7e375d9190">within_function</a>)
<a name="l01684"></a>01684             {
<a name="l01685"></a>01685               <span class="comment">/* Static symbol of local scope.  */</span>
<a name="l01686"></a>01686               <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, &amp;<a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a>);
<a name="l01687"></a>01687             }
<a name="l01688"></a>01688           <span class="keywordflow">else</span>
<a name="l01689"></a>01689             {
<a name="l01690"></a>01690               <span class="comment">/* Static symbol at top level of file.  */</span>
<a name="l01691"></a>01691               <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, &amp;<a class="code" href="buildsym_8h.html#a2d83ed7f7eeffeffeb2e00320573fd0d">file_symbols</a>);
<a name="l01692"></a>01692             }
<a name="l01693"></a>01693           <span class="keywordflow">break</span>;
<a name="l01694"></a>01694 
<a name="l01695"></a>01695 <span class="preprocessor">#ifdef C_GLBLREG                </span><span class="comment">/* AMD coff */</span>
<a name="l01696"></a>01696         <span class="keywordflow">case</span> C_GLBLREG:
<a name="l01697"></a>01697 <span class="preprocessor">#endif</span>
<a name="l01698"></a>01698 <span class="preprocessor"></span>        <span class="keywordflow">case</span> C_REG:
<a name="l01699"></a>01699           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = coff_register_index;
<a name="l01700"></a>01700           <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (sym) = cs-&gt;c_value;
<a name="l01701"></a>01701           <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, &amp;<a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a>);
<a name="l01702"></a>01702           <span class="keywordflow">break</span>;
<a name="l01703"></a>01703 
<a name="l01704"></a>01704         <span class="keywordflow">case</span> C_THUMBLABEL:
<a name="l01705"></a>01705         <span class="keywordflow">case</span> C_LABEL:
<a name="l01706"></a>01706           <span class="keywordflow">break</span>;
<a name="l01707"></a>01707 
<a name="l01708"></a>01708         <span class="keywordflow">case</span> C_ARG:
<a name="l01709"></a>01709           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3affc89e823125f8ae758aee5fb913b308">LOC_ARG</a>;
<a name="l01710"></a>01710           <a class="code" href="symtab_8h.html#ab3de6f2d8c380d3ca8bef520b1b4dfb9">SYMBOL_IS_ARGUMENT</a> (sym) = 1;
<a name="l01711"></a>01711           <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, &amp;<a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a>);
<a name="l01712"></a>01712           <span class="keywordflow">break</span>;
<a name="l01713"></a>01713 
<a name="l01714"></a>01714         <span class="keywordflow">case</span> C_REGPARM:
<a name="l01715"></a>01715           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = coff_register_index;
<a name="l01716"></a>01716           <a class="code" href="symtab_8h.html#ab3de6f2d8c380d3ca8bef520b1b4dfb9">SYMBOL_IS_ARGUMENT</a> (sym) = 1;
<a name="l01717"></a>01717           <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (sym) = cs-&gt;c_value;
<a name="l01718"></a>01718           <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, &amp;<a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a>);
<a name="l01719"></a>01719           <span class="keywordflow">break</span>;
<a name="l01720"></a>01720 
<a name="l01721"></a>01721         <span class="keywordflow">case</span> C_TPDEF:
<a name="l01722"></a>01722           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>;
<a name="l01723"></a>01723           <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym) = <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>;
<a name="l01724"></a>01724 
<a name="l01725"></a>01725           <span class="comment">/* If type has no name, give it one.  */</span>
<a name="l01726"></a>01726           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym)) == 0)
<a name="l01727"></a>01727             {
<a name="l01728"></a>01728               <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l01729"></a>01729                   || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>)
<a name="l01730"></a>01730                 {
<a name="l01731"></a>01731                   <span class="comment">/* If we are giving a name to a type such as</span>
<a name="l01732"></a>01732 <span class="comment">                     &quot;pointer to foo&quot; or &quot;function returning foo&quot;, we</span>
<a name="l01733"></a>01733 <span class="comment">                     better not set the TYPE_NAME.  If the program</span>
<a name="l01734"></a>01734 <span class="comment">                     contains &quot;typedef char *caddr_t;&quot;, we don&#39;t want </span>
<a name="l01735"></a>01735 <span class="comment">                     all variables of type char * to print as caddr_t.</span>
<a name="l01736"></a>01736 <span class="comment">                     This is not just a consequence of GDB&#39;s type</span>
<a name="l01737"></a>01737 <span class="comment">                     management; CC and GCC (at least through version</span>
<a name="l01738"></a>01738 <span class="comment">                     2.4) both output variables of either type char *</span>
<a name="l01739"></a>01739 <span class="comment">                     or caddr_t with the type refering to the C_TPDEF</span>
<a name="l01740"></a>01740 <span class="comment">                     symbol for caddr_t.  If a future compiler cleans</span>
<a name="l01741"></a>01741 <span class="comment">                     this up it GDB is not ready for it yet, but if it</span>
<a name="l01742"></a>01742 <span class="comment">                     becomes ready we somehow need to disable this</span>
<a name="l01743"></a>01743 <span class="comment">                     check (without breaking the PCC/GCC2.4 case).</span>
<a name="l01744"></a>01744 <span class="comment"></span>
<a name="l01745"></a>01745 <span class="comment">                     Sigh.</span>
<a name="l01746"></a>01746 <span class="comment"></span>
<a name="l01747"></a>01747 <span class="comment">                     Fortunately, this check seems not to be necessary</span>
<a name="l01748"></a>01748 <span class="comment">                     for anything except pointers or functions.  */</span>
<a name="l01749"></a>01749                   ;
<a name="l01750"></a>01750                 }
<a name="l01751"></a>01751               <span class="keywordflow">else</span>
<a name="l01752"></a>01752                 <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym)) =
<a name="l01753"></a>01753                   xstrdup (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym));
<a name="l01754"></a>01754             }
<a name="l01755"></a>01755 
<a name="l01756"></a>01756           <span class="comment">/* Keep track of any type which points to empty structured</span>
<a name="l01757"></a>01757 <span class="comment">             type, so it can be filled from a definition from another</span>
<a name="l01758"></a>01758 <span class="comment">             file.  A simple forward reference (TYPE_CODE_UNDEF) is</span>
<a name="l01759"></a>01759 <span class="comment">             not an empty structured type, though; the forward</span>
<a name="l01760"></a>01760 <span class="comment">             references work themselves out via the magic of</span>
<a name="l01761"></a>01761 <span class="comment">             coff_lookup_type.  */</span>
<a name="l01762"></a>01762           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l01763"></a>01763               &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym))) == 0
<a name="l01764"></a>01764               &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym)))
<a name="l01765"></a>01765                  != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ac0ed09886a958d1a94646893440004a8">TYPE_CODE_UNDEF</a>)
<a name="l01766"></a>01766             {
<a name="l01767"></a>01767               <span class="keywordtype">int</span> i = <a class="code" href="buildsym_8c.html#a74ea426b970d55be327c2e2b5c165c28">hashname</a> (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym));
<a name="l01768"></a>01768 
<a name="l01769"></a>01769               <a class="code" href="symtab_8h.html#a2178fcf28e88c29f3965bb1decdd6eaf">SYMBOL_VALUE_CHAIN</a> (sym) = opaque_type_chain[i];
<a name="l01770"></a>01770               opaque_type_chain[i] = sym;
<a name="l01771"></a>01771             }
<a name="l01772"></a>01772           <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, &amp;<a class="code" href="buildsym_8h.html#a2d83ed7f7eeffeffeb2e00320573fd0d">file_symbols</a>);
<a name="l01773"></a>01773           <span class="keywordflow">break</span>;
<a name="l01774"></a>01774 
<a name="l01775"></a>01775         <span class="keywordflow">case</span> C_STRTAG:
<a name="l01776"></a>01776         <span class="keywordflow">case</span> C_UNTAG:
<a name="l01777"></a>01777         <span class="keywordflow">case</span> C_ENTAG:
<a name="l01778"></a>01778           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>;
<a name="l01779"></a>01779           <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym) = <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa1f05a16e681efd2e892974878c353f11">STRUCT_DOMAIN</a>;
<a name="l01780"></a>01780 
<a name="l01781"></a>01781           <span class="comment">/* Some compilers try to be helpful by inventing &quot;fake&quot;</span>
<a name="l01782"></a>01782 <span class="comment">             names for anonymous enums, structures, and unions, like</span>
<a name="l01783"></a>01783 <span class="comment">             &quot;~0fake&quot; or &quot;.0fake&quot;.  Thanks, but no thanks...  */</span>
<a name="l01784"></a>01784           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym)) == 0)
<a name="l01785"></a>01785             <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym) != NULL
<a name="l01786"></a>01786                 &amp;&amp; *<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym) != <span class="charliteral">&#39;~&#39;</span>
<a name="l01787"></a>01787                 &amp;&amp; *<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym) != <span class="charliteral">&#39;.&#39;</span>)
<a name="l01788"></a>01788               <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym)) =
<a name="l01789"></a>01789                 concat (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym), (<span class="keywordtype">char</span> *)NULL);
<a name="l01790"></a>01790 
<a name="l01791"></a>01791           <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, &amp;<a class="code" href="buildsym_8h.html#a2d83ed7f7eeffeffeb2e00320573fd0d">file_symbols</a>);
<a name="l01792"></a>01792           <span class="keywordflow">break</span>;
<a name="l01793"></a>01793 
<a name="l01794"></a>01794         <span class="keywordflow">default</span>:
<a name="l01795"></a>01795           <span class="keywordflow">break</span>;
<a name="l01796"></a>01796         }
<a name="l01797"></a>01797     }
<a name="l01798"></a>01798   <span class="keywordflow">return</span> sym;
<a name="l01799"></a>01799 }
<a name="l01800"></a>01800 
<a name="l01801"></a>01801 <span class="comment">/* Decode a coff type specifier;  return the type that is meant.  */</span>
<a name="l01802"></a>01802 
<a name="l01803"></a>01803 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l01804"></a>01804 decode_type (<span class="keyword">struct</span> coff_symbol *cs, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c_type,
<a name="l01805"></a>01805              <span class="keyword">union</span> internal_auxent *aux, <span class="keyword">struct</span> objfile *objfile)
<a name="l01806"></a>01806 {
<a name="l01807"></a>01807   <span class="keyword">struct </span>type *type = 0;
<a name="l01808"></a>01808   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> new_c_type;
<a name="l01809"></a>01809 
<a name="l01810"></a>01810   <span class="keywordflow">if</span> (c_type &amp; ~<a class="code" href="coffread_8c.html#a78aef007804b13d1913a62b3191ba275">N_BTMASK</a>)
<a name="l01811"></a>01811     {
<a name="l01812"></a>01812       new_c_type = DECREF (c_type);
<a name="l01813"></a>01813       <span class="keywordflow">if</span> (ISPTR (c_type))
<a name="l01814"></a>01814         {
<a name="l01815"></a>01815           type = decode_type (cs, new_c_type, aux, objfile);
<a name="l01816"></a>01816           type = <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (type);
<a name="l01817"></a>01817         }
<a name="l01818"></a>01818       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ISFCN (c_type))
<a name="l01819"></a>01819         {
<a name="l01820"></a>01820           type = decode_type (cs, new_c_type, aux, objfile);
<a name="l01821"></a>01821           type = <a class="code" href="gdbtypes_8c.html#ab21dd6531306fba2a7078534017df6fb">lookup_function_type</a> (type);
<a name="l01822"></a>01822         }
<a name="l01823"></a>01823       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ISARY (c_type))
<a name="l01824"></a>01824         {
<a name="l01825"></a>01825           <span class="keywordtype">int</span> i, n;
<a name="l01826"></a>01826           <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> *dim;
<a name="l01827"></a>01827           <span class="keyword">struct </span>type *base_type, *index_type, *range_type;
<a name="l01828"></a>01828 
<a name="l01829"></a>01829           <span class="comment">/* Define an array type.  */</span>
<a name="l01830"></a>01830           <span class="comment">/* auxent refers to array, not base type.  */</span>
<a name="l01831"></a>01831           <span class="keywordflow">if</span> (aux-&gt;x_sym.x_tagndx.l == 0)
<a name="l01832"></a>01832             cs-&gt;c_naux = 0;
<a name="l01833"></a>01833 
<a name="l01834"></a>01834           <span class="comment">/* Shift the indices down.  */</span>
<a name="l01835"></a>01835           dim = &amp;aux-&gt;x_sym.x_fcnary.x_ary.x_dimen[0];
<a name="l01836"></a>01836           i = 1;
<a name="l01837"></a>01837           n = dim[0];
<a name="l01838"></a>01838           <span class="keywordflow">for</span> (i = 0; *dim &amp;&amp; i &lt; DIMNUM - 1; i++, dim++)
<a name="l01839"></a>01839             *dim = *(dim + 1);
<a name="l01840"></a>01840           *dim = 0;
<a name="l01841"></a>01841 
<a name="l01842"></a>01842           base_type = decode_type (cs, new_c_type, aux, objfile);
<a name="l01843"></a>01843           index_type = <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a2c06bc9a1e779eb8f0936d386382da9a">builtin_int</a>;
<a name="l01844"></a>01844           range_type =
<a name="l01845"></a>01845             <a class="code" href="gdbtypes_8c.html#ab0885fdae181c47ff3f958bcba70b82d">create_range_type</a> ((<span class="keyword">struct</span> type *) NULL, 
<a name="l01846"></a>01846                                index_type, 0, n - 1);
<a name="l01847"></a>01847           type =
<a name="l01848"></a>01848             <a class="code" href="gdbtypes_8c.html#a779bbebb8202264a73344b49b22d774e">create_array_type</a> ((<span class="keyword">struct</span> type *) NULL, 
<a name="l01849"></a>01849                                base_type, range_type);
<a name="l01850"></a>01850         }
<a name="l01851"></a>01851       <span class="keywordflow">return</span> type;
<a name="l01852"></a>01852     }
<a name="l01853"></a>01853 
<a name="l01854"></a>01854   <span class="comment">/* Reference to existing type.  This only occurs with the struct,</span>
<a name="l01855"></a>01855 <span class="comment">     union, and enum types.  EPI a29k coff fakes us out by producing</span>
<a name="l01856"></a>01856 <span class="comment">     aux entries with a nonzero x_tagndx for definitions of structs,</span>
<a name="l01857"></a>01857 <span class="comment">     unions, and enums, so we have to check the c_sclass field.  SCO</span>
<a name="l01858"></a>01858 <span class="comment">     3.2v4 cc gets confused with pointers to pointers to defined</span>
<a name="l01859"></a>01859 <span class="comment">     structs, and generates negative x_tagndx fields.  */</span>
<a name="l01860"></a>01860   <span class="keywordflow">if</span> (cs-&gt;c_naux &gt; 0 &amp;&amp; aux-&gt;x_sym.x_tagndx.l != 0)
<a name="l01861"></a>01861     {
<a name="l01862"></a>01862       <span class="keywordflow">if</span> (cs-&gt;c_sclass != C_STRTAG
<a name="l01863"></a>01863           &amp;&amp; cs-&gt;c_sclass != C_UNTAG
<a name="l01864"></a>01864           &amp;&amp; cs-&gt;c_sclass != C_ENTAG
<a name="l01865"></a>01865           &amp;&amp; aux-&gt;x_sym.x_tagndx.l &gt;= 0)
<a name="l01866"></a>01866         {
<a name="l01867"></a>01867           type = coff_alloc_type (aux-&gt;x_sym.x_tagndx.l);
<a name="l01868"></a>01868           <span class="keywordflow">return</span> type;
<a name="l01869"></a>01869         }
<a name="l01870"></a>01870       <span class="keywordflow">else</span>
<a name="l01871"></a>01871         {
<a name="l01872"></a>01872           <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>,
<a name="l01873"></a>01873                      <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Symbol table entry for %s has bad tagndx value&quot;</span>),
<a name="l01874"></a>01874                      cs-&gt;c_name);
<a name="l01875"></a>01875           <span class="comment">/* And fall through to decode_base_type...  */</span>
<a name="l01876"></a>01876         }
<a name="l01877"></a>01877     }
<a name="l01878"></a>01878 
<a name="l01879"></a>01879   <span class="keywordflow">return</span> decode_base_type (cs, BTYPE (c_type), aux, objfile);
<a name="l01880"></a>01880 }
<a name="l01881"></a>01881 
<a name="l01882"></a>01882 <span class="comment">/* Decode a coff type specifier for function definition;</span>
<a name="l01883"></a>01883 <span class="comment">   return the type that the function returns.  */</span>
<a name="l01884"></a>01884 
<a name="l01885"></a>01885 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l01886"></a>01886 decode_function_type (<span class="keyword">struct</span> coff_symbol *cs, 
<a name="l01887"></a>01887                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c_type,
<a name="l01888"></a>01888                       <span class="keyword">union</span> internal_auxent *aux, 
<a name="l01889"></a>01889                       <span class="keyword">struct</span> objfile *objfile)
<a name="l01890"></a>01890 {
<a name="l01891"></a>01891   <span class="keywordflow">if</span> (aux-&gt;x_sym.x_tagndx.l == 0)
<a name="l01892"></a>01892     cs-&gt;c_naux = 0;     <span class="comment">/* auxent refers to function, not base</span>
<a name="l01893"></a>01893 <span class="comment">                           type.  */</span>
<a name="l01894"></a>01894 
<a name="l01895"></a>01895   <span class="keywordflow">return</span> decode_type (cs, DECREF (c_type), aux, objfile);
<a name="l01896"></a>01896 }
<a name="l01897"></a>01897 
<a name="l01898"></a>01898 <span class="comment">/* Basic C types.  */</span>
<a name="l01899"></a>01899 
<a name="l01900"></a>01900 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l01901"></a>01901 decode_base_type (<span class="keyword">struct</span> coff_symbol *cs, 
<a name="l01902"></a>01902                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c_type,
<a name="l01903"></a>01903                   <span class="keyword">union</span> internal_auxent *aux, 
<a name="l01904"></a>01904                   <span class="keyword">struct</span> objfile *objfile)
<a name="l01905"></a>01905 {
<a name="l01906"></a>01906   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l01907"></a>01907   <span class="keyword">struct </span>type *type;
<a name="l01908"></a>01908 
<a name="l01909"></a>01909   <span class="keywordflow">switch</span> (c_type)
<a name="l01910"></a>01910     {
<a name="l01911"></a>01911     <span class="keywordflow">case</span> T_NULL:
<a name="l01912"></a>01912       <span class="comment">/* Shows up with &quot;void (*foo)();&quot; structure members.  */</span>
<a name="l01913"></a>01913       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a4143df3933c553aa6f862ea7d3140151">builtin_void</a>;
<a name="l01914"></a>01914 
<a name="l01915"></a>01915 <span class="preprocessor">#ifdef T_VOID</span>
<a name="l01916"></a>01916 <span class="preprocessor"></span>    <span class="keywordflow">case</span> T_VOID:
<a name="l01917"></a>01917       <span class="comment">/* Intel 960 COFF has this symbol and meaning.  */</span>
<a name="l01918"></a>01918       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a4143df3933c553aa6f862ea7d3140151">builtin_void</a>;
<a name="l01919"></a>01919 <span class="preprocessor">#endif</span>
<a name="l01920"></a>01920 <span class="preprocessor"></span>
<a name="l01921"></a>01921     <span class="keywordflow">case</span> T_CHAR:
<a name="l01922"></a>01922       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a695e84fb9969e5a0ae671609f4af9a47">builtin_char</a>;
<a name="l01923"></a>01923 
<a name="l01924"></a>01924     <span class="keywordflow">case</span> T_SHORT:
<a name="l01925"></a>01925       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a981fdcee74e5081af2fd39a2559e3109">builtin_short</a>;
<a name="l01926"></a>01926 
<a name="l01927"></a>01927     <span class="keywordflow">case</span> T_INT:
<a name="l01928"></a>01928       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a2c06bc9a1e779eb8f0936d386382da9a">builtin_int</a>;
<a name="l01929"></a>01929 
<a name="l01930"></a>01930     <span class="keywordflow">case</span> T_LONG:
<a name="l01931"></a>01931       <span class="keywordflow">if</span> (cs-&gt;c_sclass == C_FIELD
<a name="l01932"></a>01932           &amp;&amp; aux-&gt;x_sym.x_misc.x_lnsz.x_size
<a name="l01933"></a>01933              &gt; <a class="code" href="gdbarch_8c.html#adba59f763c7dd284b240b703c12d149a">gdbarch_long_bit</a> (gdbarch))
<a name="l01934"></a>01934         <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a6dc46bf069ce3bf8c351ee4ff89d2793">builtin_long_long</a>;
<a name="l01935"></a>01935       <span class="keywordflow">else</span>
<a name="l01936"></a>01936         <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a31625148de3baf58086a0fb73c365d80">builtin_long</a>;
<a name="l01937"></a>01937 
<a name="l01938"></a>01938     <span class="keywordflow">case</span> T_FLOAT:
<a name="l01939"></a>01939       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a7380f347f0e72ae3de6c1dee76445ca5">builtin_float</a>;
<a name="l01940"></a>01940 
<a name="l01941"></a>01941     <span class="keywordflow">case</span> T_DOUBLE:
<a name="l01942"></a>01942       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#af181bc724afe829bae50e9f0ae0486e7">builtin_double</a>;
<a name="l01943"></a>01943 
<a name="l01944"></a>01944     <span class="keywordflow">case</span> T_LNGDBL:
<a name="l01945"></a>01945       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a71e36bcbbe145df00eaa99daf644bb8d">builtin_long_double</a>;
<a name="l01946"></a>01946 
<a name="l01947"></a>01947     <span class="keywordflow">case</span> T_STRUCT:
<a name="l01948"></a>01948       <span class="keywordflow">if</span> (cs-&gt;c_naux != 1)
<a name="l01949"></a>01949         {
<a name="l01950"></a>01950           <span class="comment">/* Anonymous structure type.  */</span>
<a name="l01951"></a>01951           type = coff_alloc_type (cs-&gt;c_symnum);
<a name="l01952"></a>01952           <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>;
<a name="l01953"></a>01953           <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) = NULL;
<a name="l01954"></a>01954           <span class="comment">/* This used to set the tag to &quot;&lt;opaque&gt;&quot;.  But I think</span>
<a name="l01955"></a>01955 <span class="comment">             setting it to NULL is right, and the printing code can</span>
<a name="l01956"></a>01956 <span class="comment">             print it as &quot;struct {...}&quot;.  */</span>
<a name="l01957"></a>01957           <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) = NULL;
<a name="l01958"></a>01958           <a class="code" href="gdbtypes_8h.html#abce922c83265a58f62b491513b7a5aea">INIT_CPLUS_SPECIFIC</a> (type);
<a name="l01959"></a>01959           <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = 0;
<a name="l01960"></a>01960           <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (type) = 0;
<a name="l01961"></a>01961           <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) = 0;
<a name="l01962"></a>01962         }
<a name="l01963"></a>01963       <span class="keywordflow">else</span>
<a name="l01964"></a>01964         {
<a name="l01965"></a>01965           type = coff_read_struct_type (cs-&gt;c_symnum,
<a name="l01966"></a>01966                                         aux-&gt;x_sym.x_misc.x_lnsz.x_size,
<a name="l01967"></a>01967                                         aux-&gt;x_sym.x_fcnary.x_fcn.x_endndx.l,
<a name="l01968"></a>01968                                         objfile);
<a name="l01969"></a>01969         }
<a name="l01970"></a>01970       <span class="keywordflow">return</span> type;
<a name="l01971"></a>01971 
<a name="l01972"></a>01972     <span class="keywordflow">case</span> T_UNION:
<a name="l01973"></a>01973       <span class="keywordflow">if</span> (cs-&gt;c_naux != 1)
<a name="l01974"></a>01974         {
<a name="l01975"></a>01975           <span class="comment">/* Anonymous union type.  */</span>
<a name="l01976"></a>01976           type = coff_alloc_type (cs-&gt;c_symnum);
<a name="l01977"></a>01977           <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) = NULL;
<a name="l01978"></a>01978           <span class="comment">/* This used to set the tag to &quot;&lt;opaque&gt;&quot;.  But I think</span>
<a name="l01979"></a>01979 <span class="comment">             setting it to NULL is right, and the printing code can</span>
<a name="l01980"></a>01980 <span class="comment">             print it as &quot;union {...}&quot;.  */</span>
<a name="l01981"></a>01981           <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) = NULL;
<a name="l01982"></a>01982           <a class="code" href="gdbtypes_8h.html#abce922c83265a58f62b491513b7a5aea">INIT_CPLUS_SPECIFIC</a> (type);
<a name="l01983"></a>01983           <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = 0;
<a name="l01984"></a>01984           <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (type) = 0;
<a name="l01985"></a>01985           <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) = 0;
<a name="l01986"></a>01986         }
<a name="l01987"></a>01987       <span class="keywordflow">else</span>
<a name="l01988"></a>01988         {
<a name="l01989"></a>01989           type = coff_read_struct_type (cs-&gt;c_symnum,
<a name="l01990"></a>01990                                         aux-&gt;x_sym.x_misc.x_lnsz.x_size,
<a name="l01991"></a>01991                                         aux-&gt;x_sym.x_fcnary.x_fcn.x_endndx.l,
<a name="l01992"></a>01992                                         objfile);
<a name="l01993"></a>01993         }
<a name="l01994"></a>01994       <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>;
<a name="l01995"></a>01995       <span class="keywordflow">return</span> type;
<a name="l01996"></a>01996 
<a name="l01997"></a>01997     <span class="keywordflow">case</span> T_ENUM:
<a name="l01998"></a>01998       <span class="keywordflow">if</span> (cs-&gt;c_naux != 1)
<a name="l01999"></a>01999         {
<a name="l02000"></a>02000           <span class="comment">/* Anonymous enum type.  */</span>
<a name="l02001"></a>02001           type = coff_alloc_type (cs-&gt;c_symnum);
<a name="l02002"></a>02002           <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>;
<a name="l02003"></a>02003           <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) = NULL;
<a name="l02004"></a>02004           <span class="comment">/* This used to set the tag to &quot;&lt;opaque&gt;&quot;.  But I think</span>
<a name="l02005"></a>02005 <span class="comment">             setting it to NULL is right, and the printing code can</span>
<a name="l02006"></a>02006 <span class="comment">             print it as &quot;enum {...}&quot;.  */</span>
<a name="l02007"></a>02007           <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) = NULL;
<a name="l02008"></a>02008           <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = 0;
<a name="l02009"></a>02009           <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (type) = 0;
<a name="l02010"></a>02010           <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) = 0;
<a name="l02011"></a>02011         }
<a name="l02012"></a>02012       <span class="keywordflow">else</span>
<a name="l02013"></a>02013         {
<a name="l02014"></a>02014           type = coff_read_enum_type (cs-&gt;c_symnum,
<a name="l02015"></a>02015                                       aux-&gt;x_sym.x_misc.x_lnsz.x_size,
<a name="l02016"></a>02016                                       aux-&gt;x_sym.x_fcnary.x_fcn.x_endndx.l,
<a name="l02017"></a>02017                                       objfile);
<a name="l02018"></a>02018         }
<a name="l02019"></a>02019       <span class="keywordflow">return</span> type;
<a name="l02020"></a>02020 
<a name="l02021"></a>02021     <span class="keywordflow">case</span> T_MOE:
<a name="l02022"></a>02022       <span class="comment">/* Shouldn&#39;t show up here.  */</span>
<a name="l02023"></a>02023       <span class="keywordflow">break</span>;
<a name="l02024"></a>02024 
<a name="l02025"></a>02025     <span class="keywordflow">case</span> T_UCHAR:
<a name="l02026"></a>02026       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#aaffa5153f6021da3a0ecb3bc4d73866f">builtin_unsigned_char</a>;
<a name="l02027"></a>02027 
<a name="l02028"></a>02028     <span class="keywordflow">case</span> T_USHORT:
<a name="l02029"></a>02029       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#add288b2b113d0265f41b7fa98e93a95e">builtin_unsigned_short</a>;
<a name="l02030"></a>02030 
<a name="l02031"></a>02031     <span class="keywordflow">case</span> T_UINT:
<a name="l02032"></a>02032       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a2209786fd5d2ab9002b0b1e8c3a3e8a6">builtin_unsigned_int</a>;
<a name="l02033"></a>02033 
<a name="l02034"></a>02034     <span class="keywordflow">case</span> T_ULONG:
<a name="l02035"></a>02035       <span class="keywordflow">if</span> (cs-&gt;c_sclass == C_FIELD
<a name="l02036"></a>02036           &amp;&amp; aux-&gt;x_sym.x_misc.x_lnsz.x_size
<a name="l02037"></a>02037              &gt; <a class="code" href="gdbarch_8c.html#adba59f763c7dd284b240b703c12d149a">gdbarch_long_bit</a> (gdbarch))
<a name="l02038"></a>02038         <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#af8c91baa18000f7c19e4f24f30eaa357">builtin_unsigned_long_long</a>;
<a name="l02039"></a>02039       <span class="keywordflow">else</span>
<a name="l02040"></a>02040         <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a3b7e9cc9ecc601dd74e3ebe2bbc9e406">builtin_unsigned_long</a>;
<a name="l02041"></a>02041     }
<a name="l02042"></a>02042   <a class="code" href="complaints_8c.html#a4528e524e1d7da5becb9b882d044a733">complaint</a> (&amp;<a class="code" href="complaints_8c.html#abfd145c3005621d8aa52476a65f8ce4f">symfile_complaints</a>, 
<a name="l02043"></a>02043              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unexpected type for symbol %s&quot;</span>), cs-&gt;c_name);
<a name="l02044"></a>02044   <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ac2b95ded04f0520eec8b4d0d79a097d0">objfile_type</a> (objfile)-&gt;<a class="code" href="structobjfile__type.html#a4143df3933c553aa6f862ea7d3140151">builtin_void</a>;
<a name="l02045"></a>02045 }
<a name="l02046"></a>02046 
<a name="l02047"></a>02047 <span class="comment">/* This page contains subroutines of read_type.  */</span>
<a name="l02048"></a>02048 
<a name="l02049"></a>02049 <span class="comment">/* Read the description of a structure (or union type) and return an</span>
<a name="l02050"></a>02050 <span class="comment">   object describing the type.  */</span>
<a name="l02051"></a>02051 
<a name="l02052"></a>02052 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l02053"></a>02053 coff_read_struct_type (<span class="keywordtype">int</span> index, <span class="keywordtype">int</span> length, <span class="keywordtype">int</span> lastsym,
<a name="l02054"></a>02054                        <span class="keyword">struct</span> objfile *objfile)
<a name="l02055"></a>02055 {
<a name="l02056"></a>02056   <span class="keyword">struct </span>nextfield
<a name="l02057"></a>02057     {
<a name="l02058"></a>02058       <span class="keyword">struct </span>nextfield *next;
<a name="l02059"></a>02059       <span class="keyword">struct </span>field field;
<a name="l02060"></a>02060     };
<a name="l02061"></a>02061 
<a name="l02062"></a>02062   <span class="keyword">struct </span>type *type;
<a name="l02063"></a>02063   <span class="keyword">struct </span>nextfield *list = 0;
<a name="l02064"></a>02064   <span class="keyword">struct </span>nextfield *<span class="keyword">new</span>;
<a name="l02065"></a>02065   <span class="keywordtype">int</span> nfields = 0;
<a name="l02066"></a>02066   <span class="keywordtype">int</span> n;
<a name="l02067"></a>02067   <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l02068"></a>02068   <span class="keyword">struct </span>coff_symbol member_sym;
<a name="l02069"></a>02069   <span class="keyword">struct </span>coff_symbol *ms = &amp;member_sym;
<a name="l02070"></a>02070   <span class="keyword">struct </span>internal_syment sub_sym;
<a name="l02071"></a>02071   <span class="keyword">union </span>internal_auxent sub_aux;
<a name="l02072"></a>02072   <span class="keywordtype">int</span> done = 0;
<a name="l02073"></a>02073 
<a name="l02074"></a>02074   type = coff_alloc_type (index);
<a name="l02075"></a>02075   <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>;
<a name="l02076"></a>02076   <a class="code" href="gdbtypes_8h.html#abce922c83265a58f62b491513b7a5aea">INIT_CPLUS_SPECIFIC</a> (type);
<a name="l02077"></a>02077   <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = length;
<a name="l02078"></a>02078 
<a name="l02079"></a>02079   <span class="keywordflow">while</span> (!done &amp;&amp; <a class="code" href="buildsym_8h.html#a79942374faad15785bb8f359a3d83886">symnum</a> &lt; lastsym &amp;&amp; <a class="code" href="buildsym_8h.html#a79942374faad15785bb8f359a3d83886">symnum</a> &lt; nlist_nsyms_global)
<a name="l02080"></a>02080     {
<a name="l02081"></a>02081       read_one_sym (ms, &amp;sub_sym, &amp;sub_aux);
<a name="l02082"></a>02082       name = ms-&gt;c_name;
<a name="l02083"></a>02083       name = <a class="code" href="coffread_8c.html#ad0ce851a5c1199535edf32fd6d254502">EXTERNAL_NAME</a> (name, objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>);
<a name="l02084"></a>02084 
<a name="l02085"></a>02085       <span class="keywordflow">switch</span> (ms-&gt;c_sclass)
<a name="l02086"></a>02086         {
<a name="l02087"></a>02087         <span class="keywordflow">case</span> C_MOS:
<a name="l02088"></a>02088         <span class="keywordflow">case</span> C_MOU:
<a name="l02089"></a>02089 
<a name="l02090"></a>02090           <span class="comment">/* Get space to record the next field&#39;s data.  */</span>
<a name="l02091"></a>02091           <span class="keyword">new</span> = (<span class="keyword">struct </span>nextfield *) alloca (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> nextfield));
<a name="l02092"></a>02092           <span class="keyword">new</span>-&gt;next = list;
<a name="l02093"></a>02093           list = <span class="keyword">new</span>;
<a name="l02094"></a>02094 
<a name="l02095"></a>02095           <span class="comment">/* Save the data.  */</span>
<a name="l02096"></a>02096           list-&gt;field.name = obstack_copy0 (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l02097"></a>02097                                             name, strlen (name));
<a name="l02098"></a>02098           <a class="code" href="gdbtypes_8h.html#ae88bb60de05efe94bc1cbafee6fa3985">FIELD_TYPE</a> (list-&gt;field) = decode_type (ms, ms-&gt;c_type,
<a name="l02099"></a>02099                                                   &amp;sub_aux, objfile);
<a name="l02100"></a>02100           <a class="code" href="gdbtypes_8h.html#a3b785c6047f2bce21ac78987ab5a4b48">SET_FIELD_BITPOS</a> (list-&gt;field, 8 * ms-&gt;c_value);
<a name="l02101"></a>02101           <a class="code" href="gdbtypes_8h.html#af6b82d1dbebd01aa271ea0273efb0958">FIELD_BITSIZE</a> (list-&gt;field) = 0;
<a name="l02102"></a>02102           nfields++;
<a name="l02103"></a>02103           <span class="keywordflow">break</span>;
<a name="l02104"></a>02104 
<a name="l02105"></a>02105         <span class="keywordflow">case</span> C_FIELD:
<a name="l02106"></a>02106 
<a name="l02107"></a>02107           <span class="comment">/* Get space to record the next field&#39;s data.  */</span>
<a name="l02108"></a>02108           <span class="keyword">new</span> = (<span class="keyword">struct </span>nextfield *) alloca (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> nextfield));
<a name="l02109"></a>02109           <span class="keyword">new</span>-&gt;next = list;
<a name="l02110"></a>02110           list = <span class="keyword">new</span>;
<a name="l02111"></a>02111 
<a name="l02112"></a>02112           <span class="comment">/* Save the data.  */</span>
<a name="l02113"></a>02113           list-&gt;field.name = obstack_copy0 (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l02114"></a>02114                                             name, strlen (name));
<a name="l02115"></a>02115           <a class="code" href="gdbtypes_8h.html#ae88bb60de05efe94bc1cbafee6fa3985">FIELD_TYPE</a> (list-&gt;field) = decode_type (ms, ms-&gt;c_type,
<a name="l02116"></a>02116                                                   &amp;sub_aux, objfile);
<a name="l02117"></a>02117           <a class="code" href="gdbtypes_8h.html#a3b785c6047f2bce21ac78987ab5a4b48">SET_FIELD_BITPOS</a> (list-&gt;field, ms-&gt;c_value);
<a name="l02118"></a>02118           <a class="code" href="gdbtypes_8h.html#af6b82d1dbebd01aa271ea0273efb0958">FIELD_BITSIZE</a> (list-&gt;field) = sub_aux.x_sym.x_misc.x_lnsz.x_size;
<a name="l02119"></a>02119           nfields++;
<a name="l02120"></a>02120           <span class="keywordflow">break</span>;
<a name="l02121"></a>02121 
<a name="l02122"></a>02122         <span class="keywordflow">case</span> C_EOS:
<a name="l02123"></a>02123           done = 1;
<a name="l02124"></a>02124           <span class="keywordflow">break</span>;
<a name="l02125"></a>02125         }
<a name="l02126"></a>02126     }
<a name="l02127"></a>02127   <span class="comment">/* Now create the vector of fields, and record how big it is.  */</span>
<a name="l02128"></a>02128 
<a name="l02129"></a>02129   <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) = nfields;
<a name="l02130"></a>02130   <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (type) = (<span class="keyword">struct </span>field *)
<a name="l02131"></a>02131     <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (type, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> field) * nfields);
<a name="l02132"></a>02132 
<a name="l02133"></a>02133   <span class="comment">/* Copy the saved-up fields into the field vector.  */</span>
<a name="l02134"></a>02134 
<a name="l02135"></a>02135   <span class="keywordflow">for</span> (n = nfields; list; list = list-&gt;next)
<a name="l02136"></a>02136     <a class="code" href="gdbtypes_8h.html#a8beaef20f443a0d98c7b445bbcfcf031">TYPE_FIELD</a> (type, --n) = list-&gt;field;
<a name="l02137"></a>02137 
<a name="l02138"></a>02138   <span class="keywordflow">return</span> type;
<a name="l02139"></a>02139 }
<a name="l02140"></a>02140 
<a name="l02141"></a>02141 <span class="comment">/* Read a definition of an enumeration type,</span>
<a name="l02142"></a>02142 <span class="comment">   and create and return a suitable type object.</span>
<a name="l02143"></a>02143 <span class="comment">   Also defines the symbols that represent the values of the type.  */</span>
<a name="l02144"></a>02144 
<a name="l02145"></a>02145 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l02146"></a>02146 coff_read_enum_type (<span class="keywordtype">int</span> index, <span class="keywordtype">int</span> length, <span class="keywordtype">int</span> lastsym,
<a name="l02147"></a>02147                      <span class="keyword">struct</span> objfile *objfile)
<a name="l02148"></a>02148 {
<a name="l02149"></a>02149   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile);
<a name="l02150"></a>02150   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l02151"></a>02151   <span class="keyword">struct </span>type *type;
<a name="l02152"></a>02152   <span class="keywordtype">int</span> nsyms = 0;
<a name="l02153"></a>02153   <span class="keywordtype">int</span> done = 0;
<a name="l02154"></a>02154   <span class="keyword">struct </span><a class="code" href="structpending.html">pending</a> **symlist;
<a name="l02155"></a>02155   <span class="keyword">struct </span>coff_symbol member_sym;
<a name="l02156"></a>02156   <span class="keyword">struct </span>coff_symbol *ms = &amp;member_sym;
<a name="l02157"></a>02157   <span class="keyword">struct </span>internal_syment sub_sym;
<a name="l02158"></a>02158   <span class="keyword">union </span>internal_auxent sub_aux;
<a name="l02159"></a>02159   <span class="keyword">struct </span><a class="code" href="structpending.html">pending</a> *osyms, *syms;
<a name="l02160"></a>02160   <span class="keywordtype">int</span> o_nsyms;
<a name="l02161"></a>02161   <span class="keywordtype">int</span> n;
<a name="l02162"></a>02162   <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l02163"></a>02163   <span class="keywordtype">int</span> unsigned_enum = 1;
<a name="l02164"></a>02164 
<a name="l02165"></a>02165   type = coff_alloc_type (index);
<a name="l02166"></a>02166   <span class="keywordflow">if</span> (<a class="code" href="buildsym_8h.html#ad12032827aa8d87fbe036b7e375d9190">within_function</a>)
<a name="l02167"></a>02167     symlist = &amp;<a class="code" href="buildsym_8h.html#ab0fca1017caae2878bca90013177218c">local_symbols</a>;
<a name="l02168"></a>02168   <span class="keywordflow">else</span>
<a name="l02169"></a>02169     symlist = &amp;<a class="code" href="buildsym_8h.html#a2d83ed7f7eeffeffeb2e00320573fd0d">file_symbols</a>;
<a name="l02170"></a>02170   osyms = *symlist;
<a name="l02171"></a>02171   o_nsyms = osyms ? osyms-&gt;<a class="code" href="structpending.html#a1f89b726a8d3924c26ae5fd9dcd6553c">nsyms</a> : 0;
<a name="l02172"></a>02172 
<a name="l02173"></a>02173   <span class="keywordflow">while</span> (!done &amp;&amp; <a class="code" href="buildsym_8h.html#a79942374faad15785bb8f359a3d83886">symnum</a> &lt; lastsym &amp;&amp; <a class="code" href="buildsym_8h.html#a79942374faad15785bb8f359a3d83886">symnum</a> &lt; nlist_nsyms_global)
<a name="l02174"></a>02174     {
<a name="l02175"></a>02175       read_one_sym (ms, &amp;sub_sym, &amp;sub_aux);
<a name="l02176"></a>02176       name = ms-&gt;c_name;
<a name="l02177"></a>02177       name = <a class="code" href="coffread_8c.html#ad0ce851a5c1199535edf32fd6d254502">EXTERNAL_NAME</a> (name, objfile-&gt;<a class="code" href="structobjfile.html#a0b967b64f365ef71d618700b7308dcde">obfd</a>);
<a name="l02178"></a>02178 
<a name="l02179"></a>02179       <span class="keywordflow">switch</span> (ms-&gt;c_sclass)
<a name="l02180"></a>02180         {
<a name="l02181"></a>02181         <span class="keywordflow">case</span> C_MOE:
<a name="l02182"></a>02182           sym = <a class="code" href="symtab_8c.html#a6a7a23ba37378ec001ecd461c5137b83">allocate_symbol</a> (objfile);
<a name="l02183"></a>02183 
<a name="l02184"></a>02184           <a class="code" href="symtab_8h.html#ae6e6f554cc8caa302651cbfc09bf6dbc">SYMBOL_SET_LINKAGE_NAME</a> (sym,
<a name="l02185"></a>02185                                    obstack_copy0 (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l02186"></a>02186                                                   name, strlen (name)));
<a name="l02187"></a>02187           <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (sym) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a5268309778a6727d08106ff9f2966e54">LOC_CONST</a>;
<a name="l02188"></a>02188           <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym) = <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>;
<a name="l02189"></a>02189           <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (sym) = ms-&gt;c_value;
<a name="l02190"></a>02190           <a class="code" href="buildsym_8c.html#aee3d58d90bf0c32264f21cf20cf72974">add_symbol_to_list</a> (sym, symlist);
<a name="l02191"></a>02191           nsyms++;
<a name="l02192"></a>02192           <span class="keywordflow">break</span>;
<a name="l02193"></a>02193 
<a name="l02194"></a>02194         <span class="keywordflow">case</span> C_EOS:
<a name="l02195"></a>02195           <span class="comment">/* Sometimes the linker (on 386/ix 2.0.2 at least) screws</span>
<a name="l02196"></a>02196 <span class="comment">             up the count of how many symbols to read.  So stop</span>
<a name="l02197"></a>02197 <span class="comment">             on .eos.  */</span>
<a name="l02198"></a>02198           done = 1;
<a name="l02199"></a>02199           <span class="keywordflow">break</span>;
<a name="l02200"></a>02200         }
<a name="l02201"></a>02201     }
<a name="l02202"></a>02202 
<a name="l02203"></a>02203   <span class="comment">/* Now fill in the fields of the type-structure.  */</span>
<a name="l02204"></a>02204 
<a name="l02205"></a>02205   <span class="keywordflow">if</span> (length &gt; 0)
<a name="l02206"></a>02206     <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = length;
<a name="l02207"></a>02207   <span class="keywordflow">else</span> <span class="comment">/* Assume ints.  */</span>
<a name="l02208"></a>02208     <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = <a class="code" href="gdbarch_8c.html#a6f4f4c6b17870bbd5de1f5e2776f774b">gdbarch_int_bit</a> (gdbarch) / TARGET_CHAR_BIT;
<a name="l02209"></a>02209   <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>;
<a name="l02210"></a>02210   <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) = <a class="code" href="structpending.html#a1f89b726a8d3924c26ae5fd9dcd6553c">nsyms</a>;
<a name="l02211"></a>02211   <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (type) = (<span class="keyword">struct </span>field *)
<a name="l02212"></a>02212     <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (type, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> field) * nsyms);
<a name="l02213"></a>02213 
<a name="l02214"></a>02214   <span class="comment">/* Find the symbols for the values and put them into the type.</span>
<a name="l02215"></a>02215 <span class="comment">     The symbols can be found in the symlist that we put them on</span>
<a name="l02216"></a>02216 <span class="comment">     to cause them to be defined.  osyms contains the old value</span>
<a name="l02217"></a>02217 <span class="comment">     of that symlist; everything up to there was defined by us.  */</span>
<a name="l02218"></a>02218   <span class="comment">/* Note that we preserve the order of the enum constants, so</span>
<a name="l02219"></a>02219 <span class="comment">     that in something like &quot;enum {FOO, LAST_THING=FOO}&quot; we print</span>
<a name="l02220"></a>02220 <span class="comment">     FOO, not LAST_THING.  */</span>
<a name="l02221"></a>02221 
<a name="l02222"></a>02222   <span class="keywordflow">for</span> (syms = *symlist, n = 0; syms; syms = syms-&gt;<a class="code" href="structpending.html#aeaf41f56ecf48623bbf2ed11acb5baf8">next</a>)
<a name="l02223"></a>02223     {
<a name="l02224"></a>02224       <span class="keywordtype">int</span> j = 0;
<a name="l02225"></a>02225 
<a name="l02226"></a>02226       <span class="keywordflow">if</span> (syms == osyms)
<a name="l02227"></a>02227         j = o_nsyms;
<a name="l02228"></a>02228       <span class="keywordflow">for</span> (; j &lt; syms-&gt;<a class="code" href="structpending.html#a1f89b726a8d3924c26ae5fd9dcd6553c">nsyms</a>; j++, n++)
<a name="l02229"></a>02229         {
<a name="l02230"></a>02230           <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *xsym = syms-&gt;<a class="code" href="structpending.html#a28546830406173d2953af26ff13d416b">symbol</a>[j];
<a name="l02231"></a>02231 
<a name="l02232"></a>02232           <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (xsym) = <a class="code" href="structsymbol.html#ac930ee8b32bc2e6bbc23bf783df33559">type</a>;
<a name="l02233"></a>02233           <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, n) = <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (xsym);
<a name="l02234"></a>02234           <a class="code" href="gdbtypes_8h.html#a7c5d158b14cf4880b850a7dcd791582f">SET_FIELD_ENUMVAL</a> (<a class="code" href="gdbtypes_8h.html#a8beaef20f443a0d98c7b445bbcfcf031">TYPE_FIELD</a> (type, n), <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (xsym));
<a name="l02235"></a>02235           <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (xsym) &lt; 0)
<a name="l02236"></a>02236             unsigned_enum = 0;
<a name="l02237"></a>02237           <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (type, n) = 0;
<a name="l02238"></a>02238         }
<a name="l02239"></a>02239       <span class="keywordflow">if</span> (syms == osyms)
<a name="l02240"></a>02240         <span class="keywordflow">break</span>;
<a name="l02241"></a>02241     }
<a name="l02242"></a>02242 
<a name="l02243"></a>02243   <span class="keywordflow">if</span> (unsigned_enum)
<a name="l02244"></a>02244     <a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">TYPE_UNSIGNED</a> (type) = 1;
<a name="l02245"></a>02245 
<a name="l02246"></a>02246   <span class="keywordflow">return</span> <a class="code" href="structsymbol.html#ac930ee8b32bc2e6bbc23bf783df33559">type</a>;
<a name="l02247"></a>02247 }
<a name="l02248"></a>02248 
<a name="l02249"></a>02249 <span class="comment">/* Register our ability to parse symbols for coff BFD files.  */</span>
<a name="l02250"></a>02250 
<a name="l02251"></a>02251 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structsym__fns.html">sym_fns</a> coff_sym_fns =
<a name="l02252"></a>02252 {
<a name="l02253"></a>02253   coff_new_init,                <span class="comment">/* sym_new_init: init anything gbl to</span>
<a name="l02254"></a>02254 <span class="comment">                                   entire symtab */</span>
<a name="l02255"></a>02255   coff_symfile_init,            <span class="comment">/* sym_init: read initial info, setup</span>
<a name="l02256"></a>02256 <span class="comment">                                   for sym_read() */</span>
<a name="l02257"></a>02257   coff_symfile_read,            <span class="comment">/* sym_read: read a symbol file into</span>
<a name="l02258"></a>02258 <span class="comment">                                   symtab */</span>
<a name="l02259"></a>02259   NULL,                         <span class="comment">/* sym_read_psymbols */</span>
<a name="l02260"></a>02260   coff_symfile_finish,          <span class="comment">/* sym_finish: finished with file,</span>
<a name="l02261"></a>02261 <span class="comment">                                   cleanup */</span>
<a name="l02262"></a>02262   <a class="code" href="symfile_8c.html#a37177ded7859ee162c9ea103b9ed2303">default_symfile_offsets</a>,      <span class="comment">/* sym_offsets: xlate external to</span>
<a name="l02263"></a>02263 <span class="comment">                                   internal form */</span>
<a name="l02264"></a>02264   <a class="code" href="symfile_8c.html#a61f042c1a8c43917543781babf22e553">default_symfile_segments</a>,     <span class="comment">/* sym_segments: Get segment</span>
<a name="l02265"></a>02265 <span class="comment">                                   information from a file */</span>
<a name="l02266"></a>02266   NULL,                         <span class="comment">/* sym_read_linetable  */</span>
<a name="l02267"></a>02267 
<a name="l02268"></a>02268   <a class="code" href="symfile_8c.html#a22df64724860bdb2efb29f004c0c0499">default_symfile_relocate</a>,     <span class="comment">/* sym_relocate: Relocate a debug</span>
<a name="l02269"></a>02269 <span class="comment">                                   section.  */</span>
<a name="l02270"></a>02270   NULL,                         <span class="comment">/* sym_probe_fns */</span>
<a name="l02271"></a>02271   &amp;<a class="code" href="psymtab_8c.html#ac4f5f8556b4077b1396b89446cf220eb">psym_functions</a>
<a name="l02272"></a>02272 };
<a name="l02273"></a>02273 
<a name="l02274"></a>02274 <span class="comment">/* Free the per-objfile COFF data.  */</span>
<a name="l02275"></a>02275 
<a name="l02276"></a>02276 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02277"></a>02277 coff_free_info (<span class="keyword">struct</span> objfile *objfile, <span class="keywordtype">void</span> *arg)
<a name="l02278"></a>02278 {
<a name="l02279"></a>02279   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (arg);
<a name="l02280"></a>02280 }
<a name="l02281"></a>02281 
<a name="l02282"></a>02282 <span class="keywordtype">void</span>
<a name="l02283"></a><a class="code" href="init_8c.html#a5bdf181feb330a434255a2eacb09f820">02283</a> <a class="code" href="init_8c.html#a5bdf181feb330a434255a2eacb09f820">_initialize_coffread</a> (<span class="keywordtype">void</span>)
<a name="l02284"></a>02284 {
<a name="l02285"></a>02285   <a class="code" href="symfile_8c.html#a230156b04a4126703c1c0b2eb04a89d7">add_symtab_fns</a> (bfd_target_coff_flavour, &amp;coff_sym_fns);
<a name="l02286"></a>02286 
<a name="l02287"></a>02287   coff_objfile_data_key = register_objfile_data_with_cleanup (NULL,
<a name="l02288"></a>02288                                                               coff_free_info);
<a name="l02289"></a>02289 
<a name="l02290"></a>02290   coff_register_index
<a name="l02291"></a>02291     = <a class="code" href="symtab_8c.html#a16f9226c12a0668d21e38e13de5a538e">register_symbol_register_impl</a> (<a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a2a9bcb7d8487d7ccb3858184340712e7">LOC_REGISTER</a>, &amp;coff_register_funcs);
<a name="l02292"></a>02292 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:12:12 for GDB (API) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
