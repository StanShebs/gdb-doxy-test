<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (API): /home/stan/gdb/src/gdb/m32c-tdep.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (API)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/m32c-tdep.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="m32c-tdep_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Renesas M32C target-dependent code for GDB, the GNU debugger.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 2004-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   This file is part of GDB.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00010"></a>00010 <span class="comment">   (at your option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00018"></a>00018 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#if defined (HAVE_STRING_H)</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#endif</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="gdb__assert_8h.html">gdb_assert.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;elf-bfd.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;elf/m32c.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="sim-m32c_8h.html">gdb/sim-m32c.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;dis-asm.h&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="gdbtypes_8h.html">gdbtypes.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="regcache_8h.html">regcache.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="arch-utils_8h.html">arch-utils.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="frame_8h.html">frame.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="frame-unwind_8h.html">frame-unwind.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="dwarf2-frame_8h.html">dwarf2-frame.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="dwarf2expr_8h.html">dwarf2expr.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="gdbcore_8h.html">gdbcore.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="value_8h.html">value.h</a>&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="reggroups_8h.html">reggroups.h</a>&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="prologue-value_8h.html">prologue-value.h</a>&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="target_8h.html">target.h</a>&quot;</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="comment">/* The m32c tdep structure.  */</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="keyword">static</span> <span class="keyword">struct </span>reggroup *m32c_dma_reggroup;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="keyword">struct </span>m32c_reg;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">/* The type of a function that moves the value of REG between CACHE or</span>
<a name="l00055"></a>00055 <span class="comment">   BUF --- in either direction.  */</span>
<a name="l00056"></a>00056 <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a> (<a class="code" href="m32c-tdep_8c.html#abe597023c760a29c126c4408ee9fbd3f">m32c_move_reg_t</a>) (<span class="keyword">struct </span>m32c_reg *<a class="code" href="structreg.html">reg</a>,
<a name="l00057"></a>00057                                                 <span class="keyword">struct </span>regcache *cache,
<a name="l00058"></a>00058                                                 <span class="keywordtype">void</span> *buf);
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="keyword">struct </span>m32c_reg
<a name="l00061"></a>00061 {
<a name="l00062"></a>00062   <span class="comment">/* The name of this register.  */</span>
<a name="l00063"></a>00063   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l00064"></a>00064 
<a name="l00065"></a>00065   <span class="comment">/* Its type.  */</span>
<a name="l00066"></a>00066   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>;
<a name="l00067"></a>00067 
<a name="l00068"></a>00068   <span class="comment">/* The architecture this register belongs to.  */</span>
<a name="l00069"></a>00069   <span class="keyword">struct </span>gdbarch *arch;
<a name="l00070"></a>00070 
<a name="l00071"></a>00071   <span class="comment">/* Its GDB register number.  */</span>
<a name="l00072"></a>00072   <span class="keywordtype">int</span> num;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074   <span class="comment">/* Its sim register number.  */</span>
<a name="l00075"></a>00075   <span class="keywordtype">int</span> sim_num;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077   <span class="comment">/* Its DWARF register number, or -1 if it doesn&#39;t have one.  */</span>
<a name="l00078"></a>00078   <span class="keywordtype">int</span> dwarf_num;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   <span class="comment">/* Register group memberships.  */</span>
<a name="l00081"></a>00081   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> general_p : 1;
<a name="l00082"></a>00082   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dma_p : 1;
<a name="l00083"></a>00083   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> system_p : 1;
<a name="l00084"></a>00084   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> save_restore_p : 1;
<a name="l00085"></a>00085 
<a name="l00086"></a>00086   <span class="comment">/* Functions to read its value from a regcache, and write its value</span>
<a name="l00087"></a>00087 <span class="comment">     to a regcache.  */</span>
<a name="l00088"></a>00088   <a class="code" href="m32c-tdep_8c.html#abe597023c760a29c126c4408ee9fbd3f">m32c_move_reg_t</a> *<a class="code" href="expect-read1_8c.html#af32a16ad2dd9e48482f8f790db7dbbd2">read</a>, *write;
<a name="l00089"></a>00089 
<a name="l00090"></a>00090   <span class="comment">/* Data for READ and WRITE functions.  The exact meaning depends on</span>
<a name="l00091"></a>00091 <span class="comment">     the specific functions selected; see the comments for those</span>
<a name="l00092"></a>00092 <span class="comment">     functions.  */</span>
<a name="l00093"></a>00093   <span class="keyword">struct </span>m32c_reg *rx, *ry;
<a name="l00094"></a>00094   <span class="keywordtype">int</span> n;
<a name="l00095"></a>00095 };
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="comment">/* An overestimate of the number of raw and pseudoregisters we will</span>
<a name="l00099"></a>00099 <span class="comment">   have.  The exact answer depends on the variant of the architecture</span>
<a name="l00100"></a>00100 <span class="comment">   at hand, but we can use this to declare statically allocated</span>
<a name="l00101"></a>00101 <span class="comment">   arrays, and bump it up when needed.  */</span>
<a name="l00102"></a><a class="code" href="m32c-tdep_8c.html#a861d6bfdd85412bd19ecb0df0742277c">00102</a> <span class="preprocessor">#define M32C_MAX_NUM_REGS (75)</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span>
<a name="l00104"></a>00104 <span class="comment">/* The largest assigned DWARF register number.  */</span>
<a name="l00105"></a><a class="code" href="m32c-tdep_8c.html#ab5ab48b2c07f40b05ec22c677bd933b0">00105</a> <span class="preprocessor">#define M32C_MAX_DWARF_REGNUM (40)</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span>
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a>
<a name="l00109"></a>00109 {
<a name="l00110"></a>00110   <span class="comment">/* All the registers for this variant, indexed by GDB register</span>
<a name="l00111"></a>00111 <span class="comment">     number, and the number of registers present.  */</span>
<a name="l00112"></a><a class="code" href="structgdbarch__tdep.html#a1dafc33980aca4b7214915336ef2c55d">00112</a>   <span class="keyword">struct </span>m32c_reg <a class="code" href="structgdbarch__tdep.html#a1dafc33980aca4b7214915336ef2c55d">regs</a>[<a class="code" href="m32c-tdep_8c.html#a861d6bfdd85412bd19ecb0df0742277c">M32C_MAX_NUM_REGS</a>];
<a name="l00113"></a>00113 
<a name="l00114"></a>00114   <span class="comment">/* The number of valid registers.  */</span>
<a name="l00115"></a><a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">00115</a>   <span class="keywordtype">int</span> <a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">num_regs</a>;
<a name="l00116"></a>00116 
<a name="l00117"></a>00117   <span class="comment">/* Interesting registers.  These are pointers into REGS.  */</span>
<a name="l00118"></a><a class="code" href="structgdbarch__tdep.html#ab7a207d4e85b564c48238283745247b8">00118</a>   <span class="keyword">struct </span>m32c_reg *<a class="code" href="structgdbarch__tdep.html#ab7a207d4e85b564c48238283745247b8">pc</a>, *<a class="code" href="structgdbarch__tdep.html#a275600df025db6499c539773c4e12ed2">flg</a>;
<a name="l00119"></a><a class="code" href="structgdbarch__tdep.html#a6e38b2ae232e49034076dcdbc9e45518">00119</a>   <span class="keyword">struct </span>m32c_reg *<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>, *<a class="code" href="structgdbarch__tdep.html#ac171978c5c32b113e6b6ab9a920f4edb">r1</a>, *<a class="code" href="structgdbarch__tdep.html#ada3d7b322cd22af8c0e4da1c427113be">r2</a>, *<a class="code" href="structgdbarch__tdep.html#a6e38b2ae232e49034076dcdbc9e45518">r3</a>, *<a class="code" href="structgdbarch__tdep.html#afe752e13d941f920e6dc32eb30ef4a87">a0</a>, *<a class="code" href="structgdbarch__tdep.html#a079b5a09de437a19c5e635c50bcef794">a1</a>;
<a name="l00120"></a><a class="code" href="structgdbarch__tdep.html#ac22aca958ec1e37fef73f78934cae0ef">00120</a>   <span class="keyword">struct </span>m32c_reg *<a class="code" href="structgdbarch__tdep.html#acb65c541d13480f8cf593fb23667016b">r2r0</a>, *<a class="code" href="structgdbarch__tdep.html#ac22aca958ec1e37fef73f78934cae0ef">r3r2r1r0</a>, *<a class="code" href="structgdbarch__tdep.html#aae98be35ad2f439b8946ab8a1a87a103">r3r1r2r0</a>;
<a name="l00121"></a><a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">00121</a>   <span class="keyword">struct </span>m32c_reg *<a class="code" href="structgdbarch__tdep.html#a3a1da6409e72e5aa257543b183e2d0f1">sb</a>, *<a class="code" href="structgdbarch__tdep.html#a584c527b4e94c7bf12610034878bd377">fb</a>, *<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123   <span class="comment">/* A table indexed by DWARF register numbers, pointing into</span>
<a name="l00124"></a>00124 <span class="comment">     REGS.  */</span>
<a name="l00125"></a><a class="code" href="structgdbarch__tdep.html#aa5f0994f6e6048279b423dd2eaf0f11b">00125</a>   <span class="keyword">struct </span>m32c_reg *<a class="code" href="structgdbarch__tdep.html#aa5f0994f6e6048279b423dd2eaf0f11b">dwarf_regs</a>[<a class="code" href="m32c-tdep_8c.html#ab5ab48b2c07f40b05ec22c677bd933b0">M32C_MAX_DWARF_REGNUM</a> + 1];
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   <span class="comment">/* Types for this architecture.  We can&#39;t use the builtin_type_foo</span>
<a name="l00128"></a>00128 <span class="comment">     types, because they&#39;re not initialized when building a gdbarch</span>
<a name="l00129"></a>00129 <span class="comment">     structure.  */</span>
<a name="l00130"></a><a class="code" href="structgdbarch__tdep.html#a29f3ab8a2eff0bbe35a12ab69b822675">00130</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structgdbarch__tdep.html#a29f3ab8a2eff0bbe35a12ab69b822675">voyd</a>, *<a class="code" href="structgdbarch__tdep.html#a30e8983da01ed9b3f643e74e6d9b5953">ptr_voyd</a>, *<a class="code" href="structgdbarch__tdep.html#a70cee6f01a011b0664d3351371c5e4e0">func_voyd</a>;
<a name="l00131"></a><a class="code" href="structgdbarch__tdep.html#af122527ca5c4d52300d05f523cc165cd">00131</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structgdbarch__tdep.html#af122527ca5c4d52300d05f523cc165cd">uint8</a>, *<a class="code" href="structgdbarch__tdep.html#a2a8060c5ea0633c0790461083b65f805">uint16</a>;
<a name="l00132"></a><a class="code" href="structgdbarch__tdep.html#ad1c1365a84197bffdeeff7a2ae5e69fb">00132</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structgdbarch__tdep.html#ad1c1365a84197bffdeeff7a2ae5e69fb">int8</a>, *<a class="code" href="structgdbarch__tdep.html#aaaf615d424b9ef0a3696948cd3695233">int16</a>, *<a class="code" href="structgdbarch__tdep.html#a4c60d0a30f512a7e90bacb0594c1d5c3">int32</a>, *<a class="code" href="structgdbarch__tdep.html#a7c1e0d8113af1aff839c39a1500c0707">int64</a>;
<a name="l00133"></a>00133 
<a name="l00134"></a>00134   <span class="comment">/* The types for data address and code address registers.  */</span>
<a name="l00135"></a><a class="code" href="structgdbarch__tdep.html#a77153c59067bc16f74c30f814f855b87">00135</a>   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="structgdbarch__tdep.html#a77153c59067bc16f74c30f814f855b87">data_addr_reg_type</a>, *<a class="code" href="structgdbarch__tdep.html#af3af628b7fb648a77338a954a0baf027">code_addr_reg_type</a>;
<a name="l00136"></a>00136 
<a name="l00137"></a>00137   <span class="comment">/* The number of bytes a return address pushed by a &#39;jsr&#39; instruction</span>
<a name="l00138"></a>00138 <span class="comment">     occupies on the stack.  */</span>
<a name="l00139"></a><a class="code" href="structgdbarch__tdep.html#a4de8ed7c35aeafdd12cb430033dcdebc">00139</a>   <span class="keywordtype">int</span> <a class="code" href="structgdbarch__tdep.html#a4de8ed7c35aeafdd12cb430033dcdebc">ret_addr_bytes</a>;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   <span class="comment">/* The number of bytes an address register occupies on the stack</span>
<a name="l00142"></a>00142 <span class="comment">     when saved by an &#39;enter&#39; or &#39;pushm&#39; instruction.  */</span>
<a name="l00143"></a><a class="code" href="structgdbarch__tdep.html#ad29113ae8f09cddcf6315fed264d9490">00143</a>   <span class="keywordtype">int</span> <a class="code" href="structgdbarch__tdep.html#ad29113ae8f09cddcf6315fed264d9490">push_addr_bytes</a>;
<a name="l00144"></a>00144 };
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="comment">/* Types.  */</span>
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00150"></a>00150 make_types (<span class="keyword">struct</span> gdbarch *arch)
<a name="l00151"></a>00151 {
<a name="l00152"></a>00152   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (arch);
<a name="l00153"></a>00153   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mach = <a class="code" href="gdbarch_8c.html#a305465885963fbf0fb5a7543594a7bff">gdbarch_bfd_arch_info</a> (arch)-&gt;mach;
<a name="l00154"></a>00154   <span class="keywordtype">int</span> data_addr_reg_bits, code_addr_reg_bits;
<a name="l00155"></a>00155   <span class="keywordtype">char</span> type_name[50];
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <span class="preprocessor">#if 0</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span>  <span class="comment">/* This is used to clip CORE_ADDR values, so this value is</span>
<a name="l00159"></a>00159 <span class="comment">     appropriate both on the m32c, where pointers are 32 bits long,</span>
<a name="l00160"></a>00160 <span class="comment">     and on the m16c, where pointers are sixteen bits long, but there</span>
<a name="l00161"></a>00161 <span class="comment">     may be code above the 64k boundary.  */</span>
<a name="l00162"></a>00162   <a class="code" href="gdbarch_8c.html#a028fd40e003f89fcf02d7c2f9335b6ad">set_gdbarch_addr_bit</a> (arch, 24);
<a name="l00163"></a>00163 <span class="preprocessor">#else</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span>  <span class="comment">/* GCC uses 32 bits for addrs in the dwarf info, even though</span>
<a name="l00165"></a>00165 <span class="comment">     only 16/24 bits are used.  Setting addr_bit to 24 causes</span>
<a name="l00166"></a>00166 <span class="comment">     errors in reading the dwarf addresses.  */</span>
<a name="l00167"></a>00167   <a class="code" href="gdbarch_8c.html#a028fd40e003f89fcf02d7c2f9335b6ad">set_gdbarch_addr_bit</a> (arch, 32);
<a name="l00168"></a>00168 <span class="preprocessor">#endif</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span>
<a name="l00170"></a>00170   <a class="code" href="gdbarch_8c.html#a4dbde89c15b9ee9f1808a4e01f2a758d">set_gdbarch_int_bit</a> (arch, 16);
<a name="l00171"></a>00171   <span class="keywordflow">switch</span> (mach)
<a name="l00172"></a>00172     {
<a name="l00173"></a>00173     <span class="keywordflow">case</span> bfd_mach_m16c:
<a name="l00174"></a>00174       data_addr_reg_bits = 16;
<a name="l00175"></a>00175       code_addr_reg_bits = 24;
<a name="l00176"></a>00176       <a class="code" href="gdbarch_8c.html#abaaa21a756f3f8a689513c6df8b47ced">set_gdbarch_ptr_bit</a> (arch, 16);
<a name="l00177"></a>00177       tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4de8ed7c35aeafdd12cb430033dcdebc">ret_addr_bytes</a> = 3;
<a name="l00178"></a>00178       tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad29113ae8f09cddcf6315fed264d9490">push_addr_bytes</a> = 2;
<a name="l00179"></a>00179       <span class="keywordflow">break</span>;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181     <span class="keywordflow">case</span> bfd_mach_m32c:
<a name="l00182"></a>00182       data_addr_reg_bits = 24;
<a name="l00183"></a>00183       code_addr_reg_bits = 24;
<a name="l00184"></a>00184       <a class="code" href="gdbarch_8c.html#abaaa21a756f3f8a689513c6df8b47ced">set_gdbarch_ptr_bit</a> (arch, 32);
<a name="l00185"></a>00185       tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4de8ed7c35aeafdd12cb430033dcdebc">ret_addr_bytes</a> = 4;
<a name="l00186"></a>00186       tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad29113ae8f09cddcf6315fed264d9490">push_addr_bytes</a> = 4;
<a name="l00187"></a>00187       <span class="keywordflow">break</span>;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189     <span class="keywordflow">default</span>:
<a name="l00190"></a>00190       <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;unexpected mach&quot;</span>);
<a name="l00191"></a>00191     }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   <span class="comment">/* The builtin_type_mumble variables are sometimes uninitialized when</span>
<a name="l00194"></a>00194 <span class="comment">     this is called, so we avoid using them.  */</span>
<a name="l00195"></a>00195   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a29f3ab8a2eff0bbe35a12ab69b822675">voyd</a> = <a class="code" href="gdbtypes_8c.html#a4b444f0f6cfacb3f35d68fd7866402e2">arch_type</a> (arch, <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>, 1, <span class="stringliteral">&quot;void&quot;</span>);
<a name="l00196"></a>00196   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a30e8983da01ed9b3f643e74e6d9b5953">ptr_voyd</a>
<a name="l00197"></a>00197     = <a class="code" href="gdbtypes_8c.html#a4b444f0f6cfacb3f35d68fd7866402e2">arch_type</a> (arch, <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>, <a class="code" href="gdbarch_8c.html#ae356193e481873e4377ff922d984f13f">gdbarch_ptr_bit</a> (arch) / TARGET_CHAR_BIT,
<a name="l00198"></a>00198                  NULL);
<a name="l00199"></a>00199   <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a30e8983da01ed9b3f643e74e6d9b5953">ptr_voyd</a>) = tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a29f3ab8a2eff0bbe35a12ab69b822675">voyd</a>;
<a name="l00200"></a>00200   <a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">TYPE_UNSIGNED</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a30e8983da01ed9b3f643e74e6d9b5953">ptr_voyd</a>) = 1;
<a name="l00201"></a>00201   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a70cee6f01a011b0664d3351371c5e4e0">func_voyd</a> = <a class="code" href="gdbtypes_8c.html#ab21dd6531306fba2a7078534017df6fb">lookup_function_type</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a29f3ab8a2eff0bbe35a12ab69b822675">voyd</a>);
<a name="l00202"></a>00202 
<a name="l00203"></a>00203   <a class="code" href="common-utils_8c.html#ad9940337ec98983dae9951c947879fc8">xsnprintf</a> (type_name, <span class="keyword">sizeof</span> (type_name), <span class="stringliteral">&quot;%s_data_addr_t&quot;</span>,
<a name="l00204"></a>00204              <a class="code" href="gdbarch_8c.html#a305465885963fbf0fb5a7543594a7bff">gdbarch_bfd_arch_info</a> (arch)-&gt;printable_name);
<a name="l00205"></a>00205   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a77153c59067bc16f74c30f814f855b87">data_addr_reg_type</a>
<a name="l00206"></a>00206     = <a class="code" href="gdbtypes_8c.html#a4b444f0f6cfacb3f35d68fd7866402e2">arch_type</a> (arch, <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>, data_addr_reg_bits / TARGET_CHAR_BIT,
<a name="l00207"></a>00207                  xstrdup (type_name));
<a name="l00208"></a>00208   <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a77153c59067bc16f74c30f814f855b87">data_addr_reg_type</a>) = tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a29f3ab8a2eff0bbe35a12ab69b822675">voyd</a>;
<a name="l00209"></a>00209   <a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">TYPE_UNSIGNED</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a77153c59067bc16f74c30f814f855b87">data_addr_reg_type</a>) = 1;
<a name="l00210"></a>00210 
<a name="l00211"></a>00211   <a class="code" href="common-utils_8c.html#ad9940337ec98983dae9951c947879fc8">xsnprintf</a> (type_name, <span class="keyword">sizeof</span> (type_name), <span class="stringliteral">&quot;%s_code_addr_t&quot;</span>,
<a name="l00212"></a>00212              <a class="code" href="gdbarch_8c.html#a305465885963fbf0fb5a7543594a7bff">gdbarch_bfd_arch_info</a> (arch)-&gt;printable_name);
<a name="l00213"></a>00213   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#af3af628b7fb648a77338a954a0baf027">code_addr_reg_type</a>
<a name="l00214"></a>00214     = <a class="code" href="gdbtypes_8c.html#a4b444f0f6cfacb3f35d68fd7866402e2">arch_type</a> (arch, <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>, code_addr_reg_bits / TARGET_CHAR_BIT,
<a name="l00215"></a>00215                  xstrdup (type_name));
<a name="l00216"></a>00216   <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#af3af628b7fb648a77338a954a0baf027">code_addr_reg_type</a>) = tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a70cee6f01a011b0664d3351371c5e4e0">func_voyd</a>;
<a name="l00217"></a>00217   <a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">TYPE_UNSIGNED</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#af3af628b7fb648a77338a954a0baf027">code_addr_reg_type</a>) = 1;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#af122527ca5c4d52300d05f523cc165cd">uint8</a>  = <a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (arch,  8, 1, <span class="stringliteral">&quot;uint8_t&quot;</span>);
<a name="l00220"></a>00220   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a2a8060c5ea0633c0790461083b65f805">uint16</a> = <a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (arch, 16, 1, <span class="stringliteral">&quot;uint16_t&quot;</span>);
<a name="l00221"></a>00221   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad1c1365a84197bffdeeff7a2ae5e69fb">int8</a>   = <a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (arch,  8, 0, <span class="stringliteral">&quot;int8_t&quot;</span>);
<a name="l00222"></a>00222   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#aaaf615d424b9ef0a3696948cd3695233">int16</a>  = <a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (arch, 16, 0, <span class="stringliteral">&quot;int16_t&quot;</span>);
<a name="l00223"></a>00223   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4c60d0a30f512a7e90bacb0594c1d5c3">int32</a>  = <a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (arch, 32, 0, <span class="stringliteral">&quot;int32_t&quot;</span>);
<a name="l00224"></a>00224   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a7c1e0d8113af1aff839c39a1500c0707">int64</a>  = <a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (arch, 64, 0, <span class="stringliteral">&quot;int64_t&quot;</span>);
<a name="l00225"></a>00225 }
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="comment">/* Register set.  */</span>
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00232"></a>00232 m32c_register_name (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> num)
<a name="l00233"></a>00233 {
<a name="l00234"></a>00234   <span class="keywordflow">return</span> <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a1dafc33980aca4b7214915336ef2c55d">regs</a>[num].name;
<a name="l00235"></a>00235 }
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l00239"></a>00239 m32c_register_type (<span class="keyword">struct</span> gdbarch *arch, <span class="keywordtype">int</span> reg_nr)
<a name="l00240"></a>00240 {
<a name="l00241"></a>00241   <span class="keywordflow">return</span> <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (arch)-&gt;<a class="code" href="structgdbarch__tdep.html#a1dafc33980aca4b7214915336ef2c55d">regs</a>[reg_nr].type;
<a name="l00242"></a>00242 }
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00246"></a>00246 m32c_register_sim_regno (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> reg_nr)
<a name="l00247"></a>00247 {
<a name="l00248"></a>00248   <span class="keywordflow">return</span> <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a1dafc33980aca4b7214915336ef2c55d">regs</a>[reg_nr].sim_num;
<a name="l00249"></a>00249 }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00253"></a>00253 m32c_debug_info_reg_to_regnum (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> reg_nr)
<a name="l00254"></a>00254 {
<a name="l00255"></a>00255   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l00256"></a>00256   <span class="keywordflow">if</span> (0 &lt;= reg_nr &amp;&amp; reg_nr &lt;= <a class="code" href="m32c-tdep_8c.html#ab5ab48b2c07f40b05ec22c677bd933b0">M32C_MAX_DWARF_REGNUM</a>
<a name="l00257"></a>00257       &amp;&amp; tdep-&gt;<a class="code" href="structgdbarch__tdep.html#aa5f0994f6e6048279b423dd2eaf0f11b">dwarf_regs</a>[reg_nr])
<a name="l00258"></a>00258     <span class="keywordflow">return</span> tdep-&gt;<a class="code" href="structgdbarch__tdep.html#aa5f0994f6e6048279b423dd2eaf0f11b">dwarf_regs</a>[reg_nr]-&gt;num;
<a name="l00259"></a>00259   <span class="keywordflow">else</span>
<a name="l00260"></a>00260     <span class="comment">/* The DWARF CFI code expects to see -1 for invalid register</span>
<a name="l00261"></a>00261 <span class="comment">       numbers.  */</span>
<a name="l00262"></a>00262     <span class="keywordflow">return</span> -1;
<a name="l00263"></a>00263 }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 
<a name="l00266"></a>00266 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00267"></a>00267 m32c_register_reggroup_p (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> <a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>,
<a name="l00268"></a>00268                           <span class="keyword">struct</span> reggroup *group)
<a name="l00269"></a>00269 {
<a name="l00270"></a>00270   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l00271"></a>00271   <span class="keyword">struct </span>m32c_reg *<a class="code" href="structreg.html">reg</a> = &amp;tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a1dafc33980aca4b7214915336ef2c55d">regs</a>[<a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>];
<a name="l00272"></a>00272 
<a name="l00273"></a>00273   <span class="comment">/* The anonymous raw registers aren&#39;t in any groups.  */</span>
<a name="l00274"></a>00274   <span class="keywordflow">if</span> (! reg-&gt;name)
<a name="l00275"></a>00275     <span class="keywordflow">return</span> 0;
<a name="l00276"></a>00276 
<a name="l00277"></a>00277   <span class="keywordflow">if</span> (group == <a class="code" href="reggroups_8c.html#a1c7760844f4c40a5fb70e84f76f39676">all_reggroup</a>)
<a name="l00278"></a>00278     <span class="keywordflow">return</span> 1;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280   <span class="keywordflow">if</span> (group == <a class="code" href="reggroups_8c.html#a2409cc2e19cc71ae02448af0ec0308fd">general_reggroup</a>
<a name="l00281"></a>00281       &amp;&amp; reg-&gt;general_p)
<a name="l00282"></a>00282     <span class="keywordflow">return</span> 1;
<a name="l00283"></a>00283 
<a name="l00284"></a>00284   <span class="keywordflow">if</span> (group == m32c_dma_reggroup
<a name="l00285"></a>00285       &amp;&amp; reg-&gt;dma_p)
<a name="l00286"></a>00286     <span class="keywordflow">return</span> 1;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   <span class="keywordflow">if</span> (group == <a class="code" href="reggroups_8c.html#a55cfcb5dfb32653c793fa6b402564068">system_reggroup</a>
<a name="l00289"></a>00289       &amp;&amp; reg-&gt;system_p)
<a name="l00290"></a>00290     <span class="keywordflow">return</span> 1;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292   <span class="comment">/* Since the m32c DWARF register numbers refer to cooked registers, not</span>
<a name="l00293"></a>00293 <span class="comment">     raw registers, and frame_pop depends on the save and restore groups</span>
<a name="l00294"></a>00294 <span class="comment">     containing registers the DWARF CFI will actually mention, our save</span>
<a name="l00295"></a>00295 <span class="comment">     and restore groups are cooked registers, not raw registers.  (This is</span>
<a name="l00296"></a>00296 <span class="comment">     why we can&#39;t use the default reggroup function.)  */</span>
<a name="l00297"></a>00297   <span class="keywordflow">if</span> ((group == <a class="code" href="reggroups_8c.html#a9be54927c9d0393a70b8a3f0bc740de3">save_reggroup</a>
<a name="l00298"></a>00298        || group == <a class="code" href="reggroups_8c.html#a627d3b74a917560e7d81d93c472e915c">restore_reggroup</a>)
<a name="l00299"></a>00299       &amp;&amp; reg-&gt;save_restore_p)
<a name="l00300"></a>00300     <span class="keywordflow">return</span> 1;
<a name="l00301"></a>00301 
<a name="l00302"></a>00302   <span class="keywordflow">return</span> 0;
<a name="l00303"></a>00303 }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 
<a name="l00306"></a>00306 <span class="comment">/* Register move functions.  We declare them here using</span>
<a name="l00307"></a>00307 <span class="comment">   m32c_move_reg_t to check the types.  */</span>
<a name="l00308"></a>00308 <span class="keyword">static</span> <a class="code" href="m32c-tdep_8c.html#abe597023c760a29c126c4408ee9fbd3f">m32c_move_reg_t</a> m32c_raw_read,      m32c_raw_write;
<a name="l00309"></a>00309 <span class="keyword">static</span> <a class="code" href="m32c-tdep_8c.html#abe597023c760a29c126c4408ee9fbd3f">m32c_move_reg_t</a> m32c_banked_read,   m32c_banked_write;
<a name="l00310"></a>00310 <span class="keyword">static</span> <a class="code" href="m32c-tdep_8c.html#abe597023c760a29c126c4408ee9fbd3f">m32c_move_reg_t</a> m32c_sb_read,       m32c_sb_write;
<a name="l00311"></a>00311 <span class="keyword">static</span> <a class="code" href="m32c-tdep_8c.html#abe597023c760a29c126c4408ee9fbd3f">m32c_move_reg_t</a> m32c_part_read,     m32c_part_write;
<a name="l00312"></a>00312 <span class="keyword">static</span> <a class="code" href="m32c-tdep_8c.html#abe597023c760a29c126c4408ee9fbd3f">m32c_move_reg_t</a> m32c_cat_read,      m32c_cat_write;
<a name="l00313"></a>00313 <span class="keyword">static</span> <a class="code" href="m32c-tdep_8c.html#abe597023c760a29c126c4408ee9fbd3f">m32c_move_reg_t</a> m32c_r3r2r1r0_read, m32c_r3r2r1r0_write;
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="comment">/* Copy the value of the raw register REG from CACHE to BUF.  */</span>
<a name="l00317"></a>00317 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00318"></a>00318 m32c_raw_read (<span class="keyword">struct</span> m32c_reg *reg, <span class="keyword">struct</span> regcache *cache, <span class="keywordtype">void</span> *buf)
<a name="l00319"></a>00319 {
<a name="l00320"></a>00320   <span class="keywordflow">return</span> <a class="code" href="regcache_8c.html#a995b366cfa6f89eaa36c6e88227f3462">regcache_raw_read</a> (cache, reg-&gt;num, buf);
<a name="l00321"></a>00321 }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 <span class="comment">/* Copy the value of the raw register REG from BUF to CACHE.  */</span>
<a name="l00325"></a>00325 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00326"></a>00326 m32c_raw_write (<span class="keyword">struct</span> m32c_reg *reg, <span class="keyword">struct</span> regcache *cache, <span class="keywordtype">void</span> *buf)
<a name="l00327"></a>00327 {
<a name="l00328"></a>00328   <a class="code" href="regcache_8c.html#a1102769bb633fd84087614a3fc5c6e20">regcache_raw_write</a> (cache, reg-&gt;num, (<span class="keyword">const</span> <span class="keywordtype">void</span> *) buf);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330   <span class="keywordflow">return</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>;
<a name="l00331"></a>00331 }
<a name="l00332"></a>00332 
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 <span class="comment">/* Return the value of the &#39;flg&#39; register in CACHE.  */</span>
<a name="l00335"></a>00335 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00336"></a>00336 m32c_read_flg (<span class="keyword">struct</span> regcache *cache)
<a name="l00337"></a>00337 {
<a name="l00338"></a>00338   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (<a class="code" href="regcache_8c.html#ad4f6d0cdf256b1fa45d59a6d71b50659">get_regcache_arch</a> (cache));
<a name="l00339"></a>00339   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structgdbarch__tdep.html#a275600df025db6499c539773c4e12ed2">flg</a>;
<a name="l00340"></a>00340   <a class="code" href="regcache_8c.html#a465c747dfdb94bb985d56e0374eb4481">regcache_raw_read_unsigned</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a275600df025db6499c539773c4e12ed2">flg</a>-&gt;num, &amp;flg);
<a name="l00341"></a>00341   <span class="keywordflow">return</span> flg &amp; 0xffff;
<a name="l00342"></a>00342 }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 <span class="comment">/* Evaluate the real register number of a banked register.  */</span>
<a name="l00346"></a>00346 <span class="keyword">static</span> <span class="keyword">struct </span>m32c_reg *
<a name="l00347"></a>00347 m32c_banked_register (<span class="keyword">struct</span> m32c_reg *reg, <span class="keyword">struct</span> regcache *cache)
<a name="l00348"></a>00348 {
<a name="l00349"></a>00349   <span class="keywordflow">return</span> ((m32c_read_flg (cache) &amp; reg-&gt;n) ? reg-&gt;ry : reg-&gt;rx);
<a name="l00350"></a>00350 }
<a name="l00351"></a>00351 
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <span class="comment">/* Move the value of a banked register from CACHE to BUF.</span>
<a name="l00354"></a>00354 <span class="comment">   If the value of the &#39;flg&#39; register in CACHE has any of the bits</span>
<a name="l00355"></a>00355 <span class="comment">   masked in REG-&gt;n set, then read REG-&gt;ry.  Otherwise, read</span>
<a name="l00356"></a>00356 <span class="comment">   REG-&gt;rx.  */</span>
<a name="l00357"></a>00357 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00358"></a>00358 m32c_banked_read (<span class="keyword">struct</span> m32c_reg *reg, <span class="keyword">struct</span> regcache *cache, <span class="keywordtype">void</span> *buf)
<a name="l00359"></a>00359 {
<a name="l00360"></a>00360   <span class="keyword">struct </span>m32c_reg *bank_reg = m32c_banked_register (reg, cache);
<a name="l00361"></a>00361   <span class="keywordflow">return</span> <a class="code" href="regcache_8c.html#a995b366cfa6f89eaa36c6e88227f3462">regcache_raw_read</a> (cache, bank_reg-&gt;num, buf);
<a name="l00362"></a>00362 }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 <span class="comment">/* Move the value of a banked register from BUF to CACHE.</span>
<a name="l00366"></a>00366 <span class="comment">   If the value of the &#39;flg&#39; register in CACHE has any of the bits</span>
<a name="l00367"></a>00367 <span class="comment">   masked in REG-&gt;n set, then write REG-&gt;ry.  Otherwise, write</span>
<a name="l00368"></a>00368 <span class="comment">   REG-&gt;rx.  */</span>
<a name="l00369"></a>00369 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00370"></a>00370 m32c_banked_write (<span class="keyword">struct</span> m32c_reg *reg, <span class="keyword">struct</span> regcache *cache, <span class="keywordtype">void</span> *buf)
<a name="l00371"></a>00371 {
<a name="l00372"></a>00372   <span class="keyword">struct </span>m32c_reg *bank_reg = m32c_banked_register (reg, cache);
<a name="l00373"></a>00373   <a class="code" href="regcache_8c.html#a1102769bb633fd84087614a3fc5c6e20">regcache_raw_write</a> (cache, bank_reg-&gt;num, (<span class="keyword">const</span> <span class="keywordtype">void</span> *) buf);
<a name="l00374"></a>00374 
<a name="l00375"></a>00375   <span class="keywordflow">return</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>;
<a name="l00376"></a>00376 }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 <span class="comment">/* Move the value of SB from CACHE to BUF.  On bfd_mach_m32c, SB is a</span>
<a name="l00380"></a>00380 <span class="comment">   banked register; on bfd_mach_m16c, it&#39;s not.  */</span>
<a name="l00381"></a>00381 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00382"></a>00382 m32c_sb_read (<span class="keyword">struct</span> m32c_reg *reg, <span class="keyword">struct</span> regcache *cache, <span class="keywordtype">void</span> *buf)
<a name="l00383"></a>00383 {
<a name="l00384"></a>00384   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#a305465885963fbf0fb5a7543594a7bff">gdbarch_bfd_arch_info</a> (reg-&gt;arch)-&gt;mach == bfd_mach_m16c)
<a name="l00385"></a>00385     <span class="keywordflow">return</span> m32c_raw_read (reg-&gt;rx, cache, buf);
<a name="l00386"></a>00386   <span class="keywordflow">else</span>
<a name="l00387"></a>00387     <span class="keywordflow">return</span> m32c_banked_read (reg, cache, buf);
<a name="l00388"></a>00388 }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 <span class="comment">/* Move the value of SB from BUF to CACHE.  On bfd_mach_m32c, SB is a</span>
<a name="l00392"></a>00392 <span class="comment">   banked register; on bfd_mach_m16c, it&#39;s not.  */</span>
<a name="l00393"></a>00393 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00394"></a>00394 m32c_sb_write (<span class="keyword">struct</span> m32c_reg *reg, <span class="keyword">struct</span> regcache *cache, <span class="keywordtype">void</span> *buf)
<a name="l00395"></a>00395 {
<a name="l00396"></a>00396   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#a305465885963fbf0fb5a7543594a7bff">gdbarch_bfd_arch_info</a> (reg-&gt;arch)-&gt;mach == bfd_mach_m16c)
<a name="l00397"></a>00397     m32c_raw_write (reg-&gt;rx, cache, buf);
<a name="l00398"></a>00398   <span class="keywordflow">else</span>
<a name="l00399"></a>00399     m32c_banked_write (reg, cache, buf);
<a name="l00400"></a>00400 
<a name="l00401"></a>00401   <span class="keywordflow">return</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>;
<a name="l00402"></a>00402 }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <span class="comment">/* Assuming REG uses m32c_part_read and m32c_part_write, set *OFFSET_P</span>
<a name="l00406"></a>00406 <span class="comment">   and *LEN_P to the offset and length, in bytes, of the part REG</span>
<a name="l00407"></a>00407 <span class="comment">   occupies in its underlying register.  The offset is from the</span>
<a name="l00408"></a>00408 <span class="comment">   lower-addressed end, regardless of the architecture&#39;s endianness.</span>
<a name="l00409"></a>00409 <span class="comment">   (The M32C family is always little-endian, but let&#39;s keep those</span>
<a name="l00410"></a>00410 <span class="comment">   assumptions out of here.)  */</span>
<a name="l00411"></a>00411 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00412"></a>00412 m32c_find_part (<span class="keyword">struct</span> m32c_reg *reg, <span class="keywordtype">int</span> *offset_p, <span class="keywordtype">int</span> *len_p)
<a name="l00413"></a>00413 {
<a name="l00414"></a>00414   <span class="comment">/* The length of the containing register, of which REG is one part.  */</span>
<a name="l00415"></a>00415   <span class="keywordtype">int</span> containing_len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (reg-&gt;rx-&gt;type);
<a name="l00416"></a>00416 
<a name="l00417"></a>00417   <span class="comment">/* The length of one &quot;element&quot; in our imaginary array.  */</span>
<a name="l00418"></a>00418   <span class="keywordtype">int</span> elt_len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (reg-&gt;type);
<a name="l00419"></a>00419 
<a name="l00420"></a>00420   <span class="comment">/* The offset of REG&#39;s &quot;element&quot; from the least significant end of</span>
<a name="l00421"></a>00421 <span class="comment">     the containing register.  */</span>
<a name="l00422"></a>00422   <span class="keywordtype">int</span> elt_offset = reg-&gt;n * elt_len;
<a name="l00423"></a>00423 
<a name="l00424"></a>00424   <span class="comment">/* If we extend off the end, trim the length of the element.  */</span>
<a name="l00425"></a>00425   <span class="keywordflow">if</span> (elt_offset + elt_len &gt; containing_len)
<a name="l00426"></a>00426     {
<a name="l00427"></a>00427       elt_len = containing_len - elt_offset;
<a name="l00428"></a>00428       <span class="comment">/* We shouldn&#39;t be declaring partial registers that go off the</span>
<a name="l00429"></a>00429 <span class="comment">         end of their containing registers.  */</span>
<a name="l00430"></a>00430       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (elt_len &gt; 0);
<a name="l00431"></a>00431     }
<a name="l00432"></a>00432 
<a name="l00433"></a>00433   <span class="comment">/* Flip the offset around if we&#39;re big-endian.  */</span>
<a name="l00434"></a>00434   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (reg-&gt;arch) == BFD_ENDIAN_BIG)
<a name="l00435"></a>00435     elt_offset = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (reg-&gt;rx-&gt;type) - elt_offset - elt_len;
<a name="l00436"></a>00436 
<a name="l00437"></a>00437   *offset_p = elt_offset;
<a name="l00438"></a>00438   *len_p = elt_len;
<a name="l00439"></a>00439 }
<a name="l00440"></a>00440 
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="comment">/* Move the value of a partial register (r0h, intbl, etc.) from CACHE</span>
<a name="l00443"></a>00443 <span class="comment">   to BUF.  Treating the value of the register REG-&gt;rx as an array of</span>
<a name="l00444"></a>00444 <span class="comment">   REG-&gt;type values, where higher indices refer to more significant</span>
<a name="l00445"></a>00445 <span class="comment">   bits, read the value of the REG-&gt;n&#39;th element.  */</span>
<a name="l00446"></a>00446 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00447"></a>00447 m32c_part_read (<span class="keyword">struct</span> m32c_reg *reg, <span class="keyword">struct</span> regcache *cache, <span class="keywordtype">void</span> *buf)
<a name="l00448"></a>00448 {
<a name="l00449"></a>00449   <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l00450"></a>00450 
<a name="l00451"></a>00451   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (buf, 0, <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (reg-&gt;type));
<a name="l00452"></a>00452   m32c_find_part (reg, &amp;offset, &amp;len);
<a name="l00453"></a>00453   <span class="keywordflow">return</span> <a class="code" href="regcache_8c.html#a0df90ba73f76a25dbbd99903a5b57a27">regcache_cooked_read_part</a> (cache, reg-&gt;rx-&gt;num, offset, len, buf);
<a name="l00454"></a>00454 }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 
<a name="l00457"></a>00457 <span class="comment">/* Move the value of a banked register from BUF to CACHE.</span>
<a name="l00458"></a>00458 <span class="comment">   Treating the value of the register REG-&gt;rx as an array of REG-&gt;type</span>
<a name="l00459"></a>00459 <span class="comment">   values, where higher indices refer to more significant bits, write</span>
<a name="l00460"></a>00460 <span class="comment">   the value of the REG-&gt;n&#39;th element.  */</span>
<a name="l00461"></a>00461 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00462"></a>00462 m32c_part_write (<span class="keyword">struct</span> m32c_reg *reg, <span class="keyword">struct</span> regcache *cache, <span class="keywordtype">void</span> *buf)
<a name="l00463"></a>00463 {
<a name="l00464"></a>00464   <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l00465"></a>00465 
<a name="l00466"></a>00466   m32c_find_part (reg, &amp;offset, &amp;len);
<a name="l00467"></a>00467   <a class="code" href="regcache_8c.html#a722867e06f34f859c10d2c3e175f4519">regcache_cooked_write_part</a> (cache, reg-&gt;rx-&gt;num, offset, len, buf);
<a name="l00468"></a>00468 
<a name="l00469"></a>00469   <span class="keywordflow">return</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>;
<a name="l00470"></a>00470 }
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 <span class="comment">/* Move the value of REG from CACHE to BUF.  REG&#39;s value is the</span>
<a name="l00474"></a>00474 <span class="comment">   concatenation of the values of the registers REG-&gt;rx and REG-&gt;ry,</span>
<a name="l00475"></a>00475 <span class="comment">   with REG-&gt;rx contributing the more significant bits.  */</span>
<a name="l00476"></a>00476 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00477"></a>00477 m32c_cat_read (<span class="keyword">struct</span> m32c_reg *reg, <span class="keyword">struct</span> regcache *cache, <span class="keywordtype">void</span> *buf)
<a name="l00478"></a>00478 {
<a name="l00479"></a>00479   <span class="keywordtype">int</span> high_bytes = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (reg-&gt;rx-&gt;type);
<a name="l00480"></a>00480   <span class="keywordtype">int</span> low_bytes  = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (reg-&gt;ry-&gt;type);
<a name="l00481"></a>00481   <span class="comment">/* For address arithmetic.  */</span>
<a name="l00482"></a>00482   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *cbuf = buf;
<a name="l00483"></a>00483   <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00484"></a>00484 
<a name="l00485"></a>00485   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (reg-&gt;type) == high_bytes + low_bytes);
<a name="l00486"></a>00486 
<a name="l00487"></a>00487   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (reg-&gt;arch) == BFD_ENDIAN_BIG)
<a name="l00488"></a>00488     {
<a name="l00489"></a>00489       status = <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (cache, reg-&gt;rx-&gt;num, cbuf);
<a name="l00490"></a>00490       <span class="keywordflow">if</span> (status == <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>)
<a name="l00491"></a>00491         status = <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (cache, reg-&gt;ry-&gt;num, cbuf + high_bytes);
<a name="l00492"></a>00492     }
<a name="l00493"></a>00493   <span class="keywordflow">else</span>
<a name="l00494"></a>00494     {
<a name="l00495"></a>00495       status = <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (cache, reg-&gt;rx-&gt;num, cbuf + low_bytes);
<a name="l00496"></a>00496       <span class="keywordflow">if</span> (status == <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>)
<a name="l00497"></a>00497         status = <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (cache, reg-&gt;ry-&gt;num, cbuf);
<a name="l00498"></a>00498     }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500   <span class="keywordflow">return</span> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00501"></a>00501 }
<a name="l00502"></a>00502 
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="comment">/* Move the value of REG from CACHE to BUF.  REG&#39;s value is the</span>
<a name="l00505"></a>00505 <span class="comment">   concatenation of the values of the registers REG-&gt;rx and REG-&gt;ry,</span>
<a name="l00506"></a>00506 <span class="comment">   with REG-&gt;rx contributing the more significant bits.  */</span>
<a name="l00507"></a>00507 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00508"></a>00508 m32c_cat_write (<span class="keyword">struct</span> m32c_reg *reg, <span class="keyword">struct</span> regcache *cache, <span class="keywordtype">void</span> *buf)
<a name="l00509"></a>00509 {
<a name="l00510"></a>00510   <span class="keywordtype">int</span> high_bytes = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (reg-&gt;rx-&gt;type);
<a name="l00511"></a>00511   <span class="keywordtype">int</span> low_bytes  = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (reg-&gt;ry-&gt;type);
<a name="l00512"></a>00512   <span class="comment">/* For address arithmetic.  */</span>
<a name="l00513"></a>00513   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *cbuf = buf;
<a name="l00514"></a>00514 
<a name="l00515"></a>00515   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (reg-&gt;type) == high_bytes + low_bytes);
<a name="l00516"></a>00516 
<a name="l00517"></a>00517   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (reg-&gt;arch) == BFD_ENDIAN_BIG)
<a name="l00518"></a>00518     {
<a name="l00519"></a>00519       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (cache, reg-&gt;rx-&gt;num, cbuf);
<a name="l00520"></a>00520       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (cache, reg-&gt;ry-&gt;num, cbuf + high_bytes);
<a name="l00521"></a>00521     }
<a name="l00522"></a>00522   <span class="keywordflow">else</span>
<a name="l00523"></a>00523     {
<a name="l00524"></a>00524       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (cache, reg-&gt;rx-&gt;num, cbuf + low_bytes);
<a name="l00525"></a>00525       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (cache, reg-&gt;ry-&gt;num, cbuf);
<a name="l00526"></a>00526     }
<a name="l00527"></a>00527 
<a name="l00528"></a>00528   <span class="keywordflow">return</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>;
<a name="l00529"></a>00529 }
<a name="l00530"></a>00530 
<a name="l00531"></a>00531 
<a name="l00532"></a>00532 <span class="comment">/* Copy the value of the raw register REG from CACHE to BUF.  REG is</span>
<a name="l00533"></a>00533 <span class="comment">   the concatenation (from most significant to least) of r3, r2, r1,</span>
<a name="l00534"></a>00534 <span class="comment">   and r0.  */</span>
<a name="l00535"></a>00535 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00536"></a>00536 m32c_r3r2r1r0_read (<span class="keyword">struct</span> m32c_reg *reg, <span class="keyword">struct</span> regcache *cache, <span class="keywordtype">void</span> *buf)
<a name="l00537"></a>00537 {
<a name="l00538"></a>00538   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (reg-&gt;arch);
<a name="l00539"></a>00539   <span class="keywordtype">int</span> len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>-&gt;type);
<a name="l00540"></a>00540   <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00541"></a>00541 
<a name="l00542"></a>00542   <span class="comment">/* For address arithmetic.  */</span>
<a name="l00543"></a>00543   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *cbuf = buf;
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (reg-&gt;arch) == BFD_ENDIAN_BIG)
<a name="l00546"></a>00546     {
<a name="l00547"></a>00547       status = <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>-&gt;num, cbuf + len * 3);
<a name="l00548"></a>00548       <span class="keywordflow">if</span> (status == <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>)
<a name="l00549"></a>00549         status = <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ac171978c5c32b113e6b6ab9a920f4edb">r1</a>-&gt;num, cbuf + len * 2);
<a name="l00550"></a>00550       <span class="keywordflow">if</span> (status == <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>)
<a name="l00551"></a>00551         status = <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ada3d7b322cd22af8c0e4da1c427113be">r2</a>-&gt;num, cbuf + len * 1);
<a name="l00552"></a>00552       <span class="keywordflow">if</span> (status == <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>)
<a name="l00553"></a>00553         status = <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6e38b2ae232e49034076dcdbc9e45518">r3</a>-&gt;num, cbuf);
<a name="l00554"></a>00554     }
<a name="l00555"></a>00555   <span class="keywordflow">else</span>
<a name="l00556"></a>00556     {
<a name="l00557"></a>00557       status = <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>-&gt;num, cbuf);
<a name="l00558"></a>00558       <span class="keywordflow">if</span> (status == <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>)
<a name="l00559"></a>00559         status = <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ac171978c5c32b113e6b6ab9a920f4edb">r1</a>-&gt;num, cbuf + len * 1);
<a name="l00560"></a>00560       <span class="keywordflow">if</span> (status == <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>)
<a name="l00561"></a>00561         status = <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ada3d7b322cd22af8c0e4da1c427113be">r2</a>-&gt;num, cbuf + len * 2);
<a name="l00562"></a>00562       <span class="keywordflow">if</span> (status == <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>)
<a name="l00563"></a>00563         status = <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6e38b2ae232e49034076dcdbc9e45518">r3</a>-&gt;num, cbuf + len * 3);
<a name="l00564"></a>00564     }
<a name="l00565"></a>00565 
<a name="l00566"></a>00566   <span class="keywordflow">return</span> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00567"></a>00567 }
<a name="l00568"></a>00568 
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 <span class="comment">/* Copy the value of the raw register REG from BUF to CACHE.  REG is</span>
<a name="l00571"></a>00571 <span class="comment">   the concatenation (from most significant to least) of r3, r2, r1,</span>
<a name="l00572"></a>00572 <span class="comment">   and r0.  */</span>
<a name="l00573"></a>00573 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00574"></a>00574 m32c_r3r2r1r0_write (<span class="keyword">struct</span> m32c_reg *reg, <span class="keyword">struct</span> regcache *cache, <span class="keywordtype">void</span> *buf)
<a name="l00575"></a>00575 {
<a name="l00576"></a>00576   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (reg-&gt;arch);
<a name="l00577"></a>00577   <span class="keywordtype">int</span> len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>-&gt;type);
<a name="l00578"></a>00578 
<a name="l00579"></a>00579   <span class="comment">/* For address arithmetic.  */</span>
<a name="l00580"></a>00580   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *cbuf = buf;
<a name="l00581"></a>00581 
<a name="l00582"></a>00582   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (reg-&gt;arch) == BFD_ENDIAN_BIG)
<a name="l00583"></a>00583     {
<a name="l00584"></a>00584       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>-&gt;num, cbuf + len * 3);
<a name="l00585"></a>00585       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ac171978c5c32b113e6b6ab9a920f4edb">r1</a>-&gt;num, cbuf + len * 2);
<a name="l00586"></a>00586       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ada3d7b322cd22af8c0e4da1c427113be">r2</a>-&gt;num, cbuf + len * 1);
<a name="l00587"></a>00587       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6e38b2ae232e49034076dcdbc9e45518">r3</a>-&gt;num, cbuf);
<a name="l00588"></a>00588     }
<a name="l00589"></a>00589   <span class="keywordflow">else</span>
<a name="l00590"></a>00590     {
<a name="l00591"></a>00591       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>-&gt;num, cbuf);
<a name="l00592"></a>00592       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ac171978c5c32b113e6b6ab9a920f4edb">r1</a>-&gt;num, cbuf + len * 1);
<a name="l00593"></a>00593       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ada3d7b322cd22af8c0e4da1c427113be">r2</a>-&gt;num, cbuf + len * 2);
<a name="l00594"></a>00594       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (cache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6e38b2ae232e49034076dcdbc9e45518">r3</a>-&gt;num, cbuf + len * 3);
<a name="l00595"></a>00595     }
<a name="l00596"></a>00596 
<a name="l00597"></a>00597   <span class="keywordflow">return</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>;
<a name="l00598"></a>00598 }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 
<a name="l00601"></a>00601 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00602"></a>00602 m32c_pseudo_register_read (<span class="keyword">struct</span> gdbarch *arch,
<a name="l00603"></a>00603                            <span class="keyword">struct</span> regcache *cache,
<a name="l00604"></a>00604                            <span class="keywordtype">int</span> cookednum,
<a name="l00605"></a>00605                            <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l00606"></a>00606 {
<a name="l00607"></a>00607   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (arch);
<a name="l00608"></a>00608   <span class="keyword">struct </span>m32c_reg *reg;
<a name="l00609"></a>00609 
<a name="l00610"></a>00610   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (0 &lt;= cookednum &amp;&amp; cookednum &lt; tdep-&gt;num_regs);
<a name="l00611"></a>00611   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (arch == <a class="code" href="regcache_8c.html#ad4f6d0cdf256b1fa45d59a6d71b50659">get_regcache_arch</a> (cache));
<a name="l00612"></a>00612   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (arch == tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a1dafc33980aca4b7214915336ef2c55d">regs</a>[cookednum].arch);
<a name="l00613"></a>00613   reg = &amp;tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a1dafc33980aca4b7214915336ef2c55d">regs</a>[cookednum];
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   <span class="keywordflow">return</span> reg-&gt;read (reg, cache, buf);
<a name="l00616"></a>00616 }
<a name="l00617"></a>00617 
<a name="l00618"></a>00618 
<a name="l00619"></a>00619 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00620"></a>00620 m32c_pseudo_register_write (<span class="keyword">struct</span> gdbarch *arch,
<a name="l00621"></a>00621                             <span class="keyword">struct</span> regcache *cache,
<a name="l00622"></a>00622                             <span class="keywordtype">int</span> cookednum,
<a name="l00623"></a>00623                             <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l00624"></a>00624 {
<a name="l00625"></a>00625   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (arch);
<a name="l00626"></a>00626   <span class="keyword">struct </span>m32c_reg *reg;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (0 &lt;= cookednum &amp;&amp; cookednum &lt; tdep-&gt;num_regs);
<a name="l00629"></a>00629   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (arch == <a class="code" href="regcache_8c.html#ad4f6d0cdf256b1fa45d59a6d71b50659">get_regcache_arch</a> (cache));
<a name="l00630"></a>00630   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (arch == tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a1dafc33980aca4b7214915336ef2c55d">regs</a>[cookednum].arch);
<a name="l00631"></a>00631   reg = &amp;tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a1dafc33980aca4b7214915336ef2c55d">regs</a>[cookednum];
<a name="l00632"></a>00632 
<a name="l00633"></a>00633   reg-&gt;write (reg, cache, (<span class="keywordtype">void</span> *) buf);
<a name="l00634"></a>00634 }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636 
<a name="l00637"></a>00637 <span class="comment">/* Add a register with the given fields to the end of ARCH&#39;s table.</span>
<a name="l00638"></a>00638 <span class="comment">   Return a pointer to the newly added register.  */</span>
<a name="l00639"></a>00639 <span class="keyword">static</span> <span class="keyword">struct </span>m32c_reg *
<a name="l00640"></a>00640 add_reg (<span class="keyword">struct</span> gdbarch *arch,
<a name="l00641"></a>00641          <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>,
<a name="l00642"></a>00642          <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>,
<a name="l00643"></a>00643          <span class="keywordtype">int</span> sim_num,
<a name="l00644"></a>00644          <a class="code" href="m32c-tdep_8c.html#abe597023c760a29c126c4408ee9fbd3f">m32c_move_reg_t</a> *<a class="code" href="expect-read1_8c.html#af32a16ad2dd9e48482f8f790db7dbbd2">read</a>,
<a name="l00645"></a>00645          <a class="code" href="m32c-tdep_8c.html#abe597023c760a29c126c4408ee9fbd3f">m32c_move_reg_t</a> *write,
<a name="l00646"></a>00646          <span class="keyword">struct</span> m32c_reg *rx,
<a name="l00647"></a>00647          <span class="keyword">struct</span> m32c_reg *ry,
<a name="l00648"></a>00648          <span class="keywordtype">int</span> n)
<a name="l00649"></a>00649 {
<a name="l00650"></a>00650   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (arch);
<a name="l00651"></a>00651   <span class="keyword">struct </span>m32c_reg *r = &amp;tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a1dafc33980aca4b7214915336ef2c55d">regs</a>[tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">num_regs</a>];
<a name="l00652"></a>00652 
<a name="l00653"></a>00653   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">num_regs</a> &lt; <a class="code" href="m32c-tdep_8c.html#a861d6bfdd85412bd19ecb0df0742277c">M32C_MAX_NUM_REGS</a>);
<a name="l00654"></a>00654 
<a name="l00655"></a>00655   r-&gt;name           = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l00656"></a>00656   r-&gt;type           = type;
<a name="l00657"></a>00657   r-&gt;arch           = arch;
<a name="l00658"></a>00658   r-&gt;num            = tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">num_regs</a>;
<a name="l00659"></a>00659   r-&gt;sim_num        = sim_num;
<a name="l00660"></a>00660   r-&gt;dwarf_num      = -1;
<a name="l00661"></a>00661   r-&gt;general_p      = 0;
<a name="l00662"></a>00662   r-&gt;dma_p          = 0;
<a name="l00663"></a>00663   r-&gt;system_p       = 0;
<a name="l00664"></a>00664   r-&gt;save_restore_p = 0;
<a name="l00665"></a>00665   r-&gt;read           = <a class="code" href="expect-read1_8c.html#af32a16ad2dd9e48482f8f790db7dbbd2">read</a>;
<a name="l00666"></a>00666   r-&gt;write          = write;
<a name="l00667"></a>00667   r-&gt;rx             = rx;
<a name="l00668"></a>00668   r-&gt;ry             = ry;
<a name="l00669"></a>00669   r-&gt;n              = n;
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">num_regs</a>++;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673   <span class="keywordflow">return</span> r;
<a name="l00674"></a>00674 }
<a name="l00675"></a>00675 
<a name="l00676"></a>00676 
<a name="l00677"></a>00677 <span class="comment">/* Record NUM as REG&#39;s DWARF register number.  */</span>
<a name="l00678"></a>00678 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00679"></a>00679 set_dwarf_regnum (<span class="keyword">struct</span> m32c_reg *reg, <span class="keywordtype">int</span> num)
<a name="l00680"></a>00680 {
<a name="l00681"></a>00681   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (num &lt; <a class="code" href="m32c-tdep_8c.html#a861d6bfdd85412bd19ecb0df0742277c">M32C_MAX_NUM_REGS</a>);
<a name="l00682"></a>00682 
<a name="l00683"></a>00683   <span class="comment">/* Update the reg-&gt;DWARF mapping.  Only count the first number</span>
<a name="l00684"></a>00684 <span class="comment">     assigned to this register.  */</span>
<a name="l00685"></a>00685   <span class="keywordflow">if</span> (reg-&gt;dwarf_num == -1)
<a name="l00686"></a>00686     reg-&gt;dwarf_num = num;
<a name="l00687"></a>00687 
<a name="l00688"></a>00688   <span class="comment">/* Update the DWARF-&gt;reg mapping.  */</span>
<a name="l00689"></a>00689   <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (reg-&gt;arch)-&gt;<a class="code" href="structgdbarch__tdep.html#aa5f0994f6e6048279b423dd2eaf0f11b">dwarf_regs</a>[num] = reg;
<a name="l00690"></a>00690 }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 <span class="comment">/* Mark REG as a general-purpose register, and return it.  */</span>
<a name="l00694"></a>00694 <span class="keyword">static</span> <span class="keyword">struct </span>m32c_reg *
<a name="l00695"></a>00695 mark_general (<span class="keyword">struct</span> m32c_reg *reg)
<a name="l00696"></a>00696 {
<a name="l00697"></a>00697   reg-&gt;general_p = 1;
<a name="l00698"></a>00698   <span class="keywordflow">return</span> reg;
<a name="l00699"></a>00699 }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701 
<a name="l00702"></a>00702 <span class="comment">/* Mark REG as a DMA register, and return it.  */</span>
<a name="l00703"></a>00703 <span class="keyword">static</span> <span class="keyword">struct </span>m32c_reg *
<a name="l00704"></a>00704 mark_dma (<span class="keyword">struct</span> m32c_reg *reg)
<a name="l00705"></a>00705 {
<a name="l00706"></a>00706   reg-&gt;dma_p = 1;
<a name="l00707"></a>00707   <span class="keywordflow">return</span> reg;
<a name="l00708"></a>00708 }
<a name="l00709"></a>00709 
<a name="l00710"></a>00710 
<a name="l00711"></a>00711 <span class="comment">/* Mark REG as a SYSTEM register, and return it.  */</span>
<a name="l00712"></a>00712 <span class="keyword">static</span> <span class="keyword">struct </span>m32c_reg *
<a name="l00713"></a>00713 mark_system (<span class="keyword">struct</span> m32c_reg *reg)
<a name="l00714"></a>00714 {
<a name="l00715"></a>00715   reg-&gt;system_p = 1;
<a name="l00716"></a>00716   <span class="keywordflow">return</span> reg;
<a name="l00717"></a>00717 }
<a name="l00718"></a>00718 
<a name="l00719"></a>00719 
<a name="l00720"></a>00720 <span class="comment">/* Mark REG as a save-restore register, and return it.  */</span>
<a name="l00721"></a>00721 <span class="keyword">static</span> <span class="keyword">struct </span>m32c_reg *
<a name="l00722"></a>00722 mark_save_restore (<span class="keyword">struct</span> m32c_reg *reg)
<a name="l00723"></a>00723 {
<a name="l00724"></a>00724   reg-&gt;save_restore_p = 1;
<a name="l00725"></a>00725   <span class="keywordflow">return</span> reg;
<a name="l00726"></a>00726 }
<a name="l00727"></a>00727 
<a name="l00728"></a>00728 
<a name="l00729"></a><a class="code" href="m32c-tdep_8c.html#a36ffe28f13004159b361254f662798c6">00729</a> <span class="preprocessor">#define FLAGBIT_B       0x0010</span>
<a name="l00730"></a><a class="code" href="m32c-tdep_8c.html#a595116bebefea13916db4e0f3b5a0d5f">00730</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAGBIT_U       0x0080</span>
<a name="l00731"></a>00731 <span class="preprocessor"></span>
<a name="l00732"></a>00732 <span class="comment">/* Handy macros for declaring registers.  These all evaluate to</span>
<a name="l00733"></a>00733 <span class="comment">   pointers to the register declared.  Macros that define two</span>
<a name="l00734"></a>00734 <span class="comment">   registers evaluate to a pointer to the first.  */</span>
<a name="l00735"></a>00735 
<a name="l00736"></a>00736 <span class="comment">/* A raw register named NAME, with type TYPE and sim number SIM_NUM.  */</span>
<a name="l00737"></a><a class="code" href="m32c-tdep_8c.html#abb571ec71ccf602d891a81a32597aaba">00737</a> <span class="preprocessor">#define R(name, type, sim_num)                                  \</span>
<a name="l00738"></a>00738 <span class="preprocessor">  (add_reg (arch, (name), (type), (sim_num),                    \</span>
<a name="l00739"></a>00739 <span class="preprocessor">            m32c_raw_read, m32c_raw_write, NULL, NULL, 0))</span>
<a name="l00740"></a>00740 <span class="preprocessor"></span>
<a name="l00741"></a>00741 <span class="comment">/* The simulator register number for a raw register named NAME.  */</span>
<a name="l00742"></a><a class="code" href="m32c-tdep_8c.html#a5de7bce01db694b4af4c46b6a2de9bf5">00742</a> <span class="preprocessor">#define SIM(name) (m32c_sim_reg_ ## name)</span>
<a name="l00743"></a>00743 <span class="preprocessor"></span>
<a name="l00744"></a>00744 <span class="comment">/* A raw unsigned 16-bit data register named NAME.</span>
<a name="l00745"></a>00745 <span class="comment">   NAME should be an identifier, not a string.  */</span>
<a name="l00746"></a><a class="code" href="m32c-tdep_8c.html#acfaffe49fc45877cd527a2f9c1c01592">00746</a> <span class="preprocessor">#define R16U(name)                                              \</span>
<a name="l00747"></a>00747 <span class="preprocessor">  (R(#name, tdep-&gt;uint16, SIM (name)))</span>
<a name="l00748"></a>00748 <span class="preprocessor"></span>
<a name="l00749"></a>00749 <span class="comment">/* A raw data address register named NAME.</span>
<a name="l00750"></a>00750 <span class="comment">   NAME should be an identifier, not a string.  */</span>
<a name="l00751"></a><a class="code" href="m32c-tdep_8c.html#a493d57755a9d2a0ba8d0231afd35c981">00751</a> <span class="preprocessor">#define RA(name)                                                \</span>
<a name="l00752"></a>00752 <span class="preprocessor">  (R(#name, tdep-&gt;data_addr_reg_type, SIM (name)))</span>
<a name="l00753"></a>00753 <span class="preprocessor"></span>
<a name="l00754"></a>00754 <span class="comment">/* A raw code address register named NAME.  NAME should</span>
<a name="l00755"></a>00755 <span class="comment">   be an identifier, not a string.  */</span>
<a name="l00756"></a><a class="code" href="m32c-tdep_8c.html#a9545a45d7c4bac01c842a741b9741db7">00756</a> <span class="preprocessor">#define RC(name)                                                \</span>
<a name="l00757"></a>00757 <span class="preprocessor">  (R(#name, tdep-&gt;code_addr_reg_type, SIM (name)))</span>
<a name="l00758"></a>00758 <span class="preprocessor"></span>
<a name="l00759"></a>00759 <span class="comment">/* A pair of raw registers named NAME0 and NAME1, with type TYPE.</span>
<a name="l00760"></a>00760 <span class="comment">   NAME should be an identifier, not a string.  */</span>
<a name="l00761"></a><a class="code" href="m32c-tdep_8c.html#afa1ecfc945d399a6d2af33e239aba030">00761</a> <span class="preprocessor">#define RP(name, type)                          \</span>
<a name="l00762"></a>00762 <span class="preprocessor">  (R(#name &quot;0&quot;, (type), SIM (name ## 0)),       \</span>
<a name="l00763"></a>00763 <span class="preprocessor">   R(#name &quot;1&quot;, (type), SIM (name ## 1)) - 1)</span>
<a name="l00764"></a>00764 <span class="preprocessor"></span>
<a name="l00765"></a>00765 <span class="comment">/* A raw banked general-purpose data register named NAME.</span>
<a name="l00766"></a>00766 <span class="comment">   NAME should be an identifier, not a string.  */</span>
<a name="l00767"></a><a class="code" href="m32c-tdep_8c.html#a9a2659e28a58381a4b4b8b7d2e7ab6bf">00767</a> <span class="preprocessor">#define RBD(name)                                               \</span>
<a name="l00768"></a>00768 <span class="preprocessor">  (R(NULL, tdep-&gt;int16, SIM (name ## _bank0)),          \</span>
<a name="l00769"></a>00769 <span class="preprocessor">   R(NULL, tdep-&gt;int16, SIM (name ## _bank1)) - 1)</span>
<a name="l00770"></a>00770 <span class="preprocessor"></span>
<a name="l00771"></a>00771 <span class="comment">/* A raw banked data address register named NAME.</span>
<a name="l00772"></a>00772 <span class="comment">   NAME should be an identifier, not a string.  */</span>
<a name="l00773"></a><a class="code" href="m32c-tdep_8c.html#a7983b4418d7086d312b75cebcb68e275">00773</a> <span class="preprocessor">#define RBA(name)                                               \</span>
<a name="l00774"></a>00774 <span class="preprocessor">  (R(NULL, tdep-&gt;data_addr_reg_type, SIM (name ## _bank0)),     \</span>
<a name="l00775"></a>00775 <span class="preprocessor">   R(NULL, tdep-&gt;data_addr_reg_type, SIM (name ## _bank1)) - 1)</span>
<a name="l00776"></a>00776 <span class="preprocessor"></span>
<a name="l00777"></a>00777 <span class="comment">/* A cooked register named NAME referring to a raw banked register</span>
<a name="l00778"></a>00778 <span class="comment">   from the bank selected by the current value of FLG.  RAW_PAIR</span>
<a name="l00779"></a>00779 <span class="comment">   should be a pointer to the first register in the banked pair.</span>
<a name="l00780"></a>00780 <span class="comment">   NAME must be an identifier, not a string.  */</span>
<a name="l00781"></a><a class="code" href="m32c-tdep_8c.html#a67755e6dd57951aebab5d15f07f05cbe">00781</a> <span class="preprocessor">#define CB(name, raw_pair)                              \</span>
<a name="l00782"></a>00782 <span class="preprocessor">  (add_reg (arch, #name, (raw_pair)-&gt;type, 0,           \</span>
<a name="l00783"></a>00783 <span class="preprocessor">            m32c_banked_read, m32c_banked_write,        \</span>
<a name="l00784"></a>00784 <span class="preprocessor">            (raw_pair), (raw_pair + 1), FLAGBIT_B))</span>
<a name="l00785"></a>00785 <span class="preprocessor"></span>
<a name="l00786"></a>00786 <span class="comment">/* A pair of registers named NAMEH and NAMEL, of type TYPE, that</span>
<a name="l00787"></a>00787 <span class="comment">   access the top and bottom halves of the register pointed to by</span>
<a name="l00788"></a>00788 <span class="comment">   NAME.  NAME should be an identifier.  */</span>
<a name="l00789"></a><a class="code" href="m32c-tdep_8c.html#a1cb63c383d6ad930ac285da71d571e08">00789</a> <span class="preprocessor">#define CHL(name, type)                                                 \</span>
<a name="l00790"></a>00790 <span class="preprocessor">  (add_reg (arch, #name &quot;h&quot;, (type), 0,                                 \</span>
<a name="l00791"></a>00791 <span class="preprocessor">            m32c_part_read, m32c_part_write, name, NULL, 1),            \</span>
<a name="l00792"></a>00792 <span class="preprocessor">   add_reg (arch, #name &quot;l&quot;, (type), 0,                                 \</span>
<a name="l00793"></a>00793 <span class="preprocessor">            m32c_part_read, m32c_part_write, name, NULL, 0) - 1)</span>
<a name="l00794"></a>00794 <span class="preprocessor"></span>
<a name="l00795"></a>00795 <span class="comment">/* A register constructed by concatenating the two registers HIGH and</span>
<a name="l00796"></a>00796 <span class="comment">   LOW, whose name is HIGHLOW and whose type is TYPE.  */</span>
<a name="l00797"></a><a class="code" href="m32c-tdep_8c.html#ae96d61b462c86e78165b4d6a24c1e9cc">00797</a> <span class="preprocessor">#define CCAT(high, low, type)                                   \</span>
<a name="l00798"></a>00798 <span class="preprocessor">  (add_reg (arch, #high #low, (type), 0,                        \</span>
<a name="l00799"></a>00799 <span class="preprocessor">            m32c_cat_read, m32c_cat_write, (high), (low), 0))</span>
<a name="l00800"></a>00800 <span class="preprocessor"></span>
<a name="l00801"></a>00801 <span class="comment">/* Abbreviations for marking register group membership.  */</span>
<a name="l00802"></a><a class="code" href="m32c-tdep_8c.html#afdec5d030373681fb9c0b0ce79e01c0a">00802</a> <span class="preprocessor">#define G(reg)   (mark_general (reg))</span>
<a name="l00803"></a><a class="code" href="m32c-tdep_8c.html#a630614f12683bccfdcd4c99977c871cb">00803</a> <span class="preprocessor"></span><span class="preprocessor">#define S(reg)   (mark_system  (reg))</span>
<a name="l00804"></a><a class="code" href="m32c-tdep_8c.html#a7ed36fdbe20c4586b846da9b7cf92c6e">00804</a> <span class="preprocessor"></span><span class="preprocessor">#define DMA(reg) (mark_dma     (reg))</span>
<a name="l00805"></a>00805 <span class="preprocessor"></span>
<a name="l00806"></a>00806 
<a name="l00807"></a>00807 <span class="comment">/* Construct the register set for ARCH.  */</span>
<a name="l00808"></a>00808 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00809"></a>00809 make_regs (<span class="keyword">struct</span> gdbarch *arch)
<a name="l00810"></a>00810 {
<a name="l00811"></a>00811   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (arch);
<a name="l00812"></a>00812   <span class="keywordtype">int</span> mach = <a class="code" href="gdbarch_8c.html#a305465885963fbf0fb5a7543594a7bff">gdbarch_bfd_arch_info</a> (arch)-&gt;mach;
<a name="l00813"></a>00813   <span class="keywordtype">int</span> num_raw_regs;
<a name="l00814"></a>00814   <span class="keywordtype">int</span> num_cooked_regs;
<a name="l00815"></a>00815 
<a name="l00816"></a>00816   <span class="keyword">struct </span>m32c_reg *r0;
<a name="l00817"></a>00817   <span class="keyword">struct </span>m32c_reg *r1;
<a name="l00818"></a>00818   <span class="keyword">struct </span>m32c_reg *r2;
<a name="l00819"></a>00819   <span class="keyword">struct </span>m32c_reg *r3;
<a name="l00820"></a>00820   <span class="keyword">struct </span>m32c_reg *a0;
<a name="l00821"></a>00821   <span class="keyword">struct </span>m32c_reg *a1;
<a name="l00822"></a>00822   <span class="keyword">struct </span>m32c_reg *fb;
<a name="l00823"></a>00823   <span class="keyword">struct </span>m32c_reg *sb;
<a name="l00824"></a>00824   <span class="keyword">struct </span>m32c_reg *<a class="code" href="windows-nat_8c.html#a8d40798874dab99986478ef00ff3e297">sp</a>;
<a name="l00825"></a>00825   <span class="keyword">struct </span>m32c_reg *r0hl;
<a name="l00826"></a>00826   <span class="keyword">struct </span>m32c_reg *r1hl;
<a name="l00827"></a>00827   <span class="keyword">struct </span>m32c_reg *r2hl;
<a name="l00828"></a>00828   <span class="keyword">struct </span>m32c_reg *r3hl;
<a name="l00829"></a>00829   <span class="keyword">struct </span>m32c_reg *intbhl;
<a name="l00830"></a>00830   <span class="keyword">struct </span>m32c_reg *r2r0;
<a name="l00831"></a>00831   <span class="keyword">struct </span>m32c_reg *r3r1;
<a name="l00832"></a>00832   <span class="keyword">struct </span>m32c_reg *r3r1r2r0;
<a name="l00833"></a>00833   <span class="keyword">struct </span>m32c_reg *r3r2r1r0;
<a name="l00834"></a>00834   <span class="keyword">struct </span>m32c_reg *a1a0;
<a name="l00835"></a>00835 
<a name="l00836"></a>00836   <span class="keyword">struct </span>m32c_reg *raw_r0_pair = <a class="code" href="m32c-tdep_8c.html#a9a2659e28a58381a4b4b8b7d2e7ab6bf">RBD</a> (r0);
<a name="l00837"></a>00837   <span class="keyword">struct </span>m32c_reg *raw_r1_pair = <a class="code" href="m32c-tdep_8c.html#a9a2659e28a58381a4b4b8b7d2e7ab6bf">RBD</a> (r1);
<a name="l00838"></a>00838   <span class="keyword">struct </span>m32c_reg *raw_r2_pair = <a class="code" href="m32c-tdep_8c.html#a9a2659e28a58381a4b4b8b7d2e7ab6bf">RBD</a> (r2);
<a name="l00839"></a>00839   <span class="keyword">struct </span>m32c_reg *raw_r3_pair = <a class="code" href="m32c-tdep_8c.html#a9a2659e28a58381a4b4b8b7d2e7ab6bf">RBD</a> (r3);
<a name="l00840"></a>00840   <span class="keyword">struct </span>m32c_reg *raw_a0_pair = <a class="code" href="m32c-tdep_8c.html#a7983b4418d7086d312b75cebcb68e275">RBA</a> (a0);
<a name="l00841"></a>00841   <span class="keyword">struct </span>m32c_reg *raw_a1_pair = <a class="code" href="m32c-tdep_8c.html#a7983b4418d7086d312b75cebcb68e275">RBA</a> (a1);
<a name="l00842"></a>00842   <span class="keyword">struct </span>m32c_reg *raw_fb_pair = <a class="code" href="m32c-tdep_8c.html#a7983b4418d7086d312b75cebcb68e275">RBA</a> (fb);
<a name="l00843"></a>00843 
<a name="l00844"></a>00844   <span class="comment">/* sb is banked on the bfd_mach_m32c, but not on bfd_mach_m16c.</span>
<a name="l00845"></a>00845 <span class="comment">     We always declare both raw registers, and deal with the distinction</span>
<a name="l00846"></a>00846 <span class="comment">     in the pseudoregister.  */</span>
<a name="l00847"></a>00847   <span class="keyword">struct </span>m32c_reg *raw_sb_pair = <a class="code" href="m32c-tdep_8c.html#a7983b4418d7086d312b75cebcb68e275">RBA</a> (sb);
<a name="l00848"></a>00848 
<a name="l00849"></a>00849   <span class="keyword">struct </span>m32c_reg *usp         = <a class="code" href="m32c-tdep_8c.html#a630614f12683bccfdcd4c99977c871cb">S</a> (<a class="code" href="m32c-tdep_8c.html#a493d57755a9d2a0ba8d0231afd35c981">RA</a> (usp));
<a name="l00850"></a>00850   <span class="keyword">struct </span>m32c_reg *isp         = <a class="code" href="m32c-tdep_8c.html#a630614f12683bccfdcd4c99977c871cb">S</a> (<a class="code" href="m32c-tdep_8c.html#a493d57755a9d2a0ba8d0231afd35c981">RA</a> (isp));
<a name="l00851"></a>00851   <span class="keyword">struct </span>m32c_reg *intb        = <a class="code" href="m32c-tdep_8c.html#a630614f12683bccfdcd4c99977c871cb">S</a> (<a class="code" href="m32c-tdep_8c.html#a9545a45d7c4bac01c842a741b9741db7">RC</a> (intb));
<a name="l00852"></a>00852   <span class="keyword">struct </span>m32c_reg *pc          = <a class="code" href="m32c-tdep_8c.html#afdec5d030373681fb9c0b0ce79e01c0a">G</a> (<a class="code" href="m32c-tdep_8c.html#a9545a45d7c4bac01c842a741b9741db7">RC</a> (pc));
<a name="l00853"></a>00853   <span class="keyword">struct </span>m32c_reg *flg         = <a class="code" href="m32c-tdep_8c.html#afdec5d030373681fb9c0b0ce79e01c0a">G</a> (<a class="code" href="m32c-tdep_8c.html#acfaffe49fc45877cd527a2f9c1c01592">R16U</a> (flg));
<a name="l00854"></a>00854 
<a name="l00855"></a>00855   <span class="keywordflow">if</span> (mach == bfd_mach_m32c)
<a name="l00856"></a>00856     {
<a name="l00857"></a>00857       <span class="keyword">struct </span>m32c_reg *svf     = <a class="code" href="m32c-tdep_8c.html#a630614f12683bccfdcd4c99977c871cb">S</a> (<a class="code" href="m32c-tdep_8c.html#acfaffe49fc45877cd527a2f9c1c01592">R16U</a> (svf));
<a name="l00858"></a>00858       <span class="keyword">struct </span>m32c_reg *svp     = <a class="code" href="m32c-tdep_8c.html#a630614f12683bccfdcd4c99977c871cb">S</a> (<a class="code" href="m32c-tdep_8c.html#a9545a45d7c4bac01c842a741b9741db7">RC</a> (svp));
<a name="l00859"></a>00859       <span class="keyword">struct </span>m32c_reg *vct     = <a class="code" href="m32c-tdep_8c.html#a630614f12683bccfdcd4c99977c871cb">S</a> (<a class="code" href="m32c-tdep_8c.html#a9545a45d7c4bac01c842a741b9741db7">RC</a> (vct));
<a name="l00860"></a>00860 
<a name="l00861"></a>00861       <span class="keyword">struct </span>m32c_reg *dmd01   = <a class="code" href="m32c-tdep_8c.html#a7ed36fdbe20c4586b846da9b7cf92c6e">DMA</a> (<a class="code" href="m32c-tdep_8c.html#afa1ecfc945d399a6d2af33e239aba030">RP</a> (dmd, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#af122527ca5c4d52300d05f523cc165cd">uint8</a>));
<a name="l00862"></a>00862       <span class="keyword">struct </span>m32c_reg *dct01   = <a class="code" href="m32c-tdep_8c.html#a7ed36fdbe20c4586b846da9b7cf92c6e">DMA</a> (<a class="code" href="m32c-tdep_8c.html#afa1ecfc945d399a6d2af33e239aba030">RP</a> (dct, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a2a8060c5ea0633c0790461083b65f805">uint16</a>));
<a name="l00863"></a>00863       <span class="keyword">struct </span>m32c_reg *drc01   = <a class="code" href="m32c-tdep_8c.html#a7ed36fdbe20c4586b846da9b7cf92c6e">DMA</a> (<a class="code" href="m32c-tdep_8c.html#afa1ecfc945d399a6d2af33e239aba030">RP</a> (drc, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a2a8060c5ea0633c0790461083b65f805">uint16</a>));
<a name="l00864"></a>00864       <span class="keyword">struct </span>m32c_reg *dma01   = <a class="code" href="m32c-tdep_8c.html#a7ed36fdbe20c4586b846da9b7cf92c6e">DMA</a> (<a class="code" href="m32c-tdep_8c.html#afa1ecfc945d399a6d2af33e239aba030">RP</a> (dma, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a77153c59067bc16f74c30f814f855b87">data_addr_reg_type</a>));
<a name="l00865"></a>00865       <span class="keyword">struct </span>m32c_reg *dsa01   = <a class="code" href="m32c-tdep_8c.html#a7ed36fdbe20c4586b846da9b7cf92c6e">DMA</a> (<a class="code" href="m32c-tdep_8c.html#afa1ecfc945d399a6d2af33e239aba030">RP</a> (dsa, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a77153c59067bc16f74c30f814f855b87">data_addr_reg_type</a>));
<a name="l00866"></a>00866       <span class="keyword">struct </span>m32c_reg *dra01   = <a class="code" href="m32c-tdep_8c.html#a7ed36fdbe20c4586b846da9b7cf92c6e">DMA</a> (<a class="code" href="m32c-tdep_8c.html#afa1ecfc945d399a6d2af33e239aba030">RP</a> (dra, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a77153c59067bc16f74c30f814f855b87">data_addr_reg_type</a>));
<a name="l00867"></a>00867     }
<a name="l00868"></a>00868 
<a name="l00869"></a>00869   num_raw_regs = tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">num_regs</a>;
<a name="l00870"></a>00870 
<a name="l00871"></a>00871   r0          = <a class="code" href="m32c-tdep_8c.html#afdec5d030373681fb9c0b0ce79e01c0a">G</a> (<a class="code" href="m32c-tdep_8c.html#a67755e6dd57951aebab5d15f07f05cbe">CB</a> (r0, raw_r0_pair));
<a name="l00872"></a>00872   r1          = <a class="code" href="m32c-tdep_8c.html#afdec5d030373681fb9c0b0ce79e01c0a">G</a> (<a class="code" href="m32c-tdep_8c.html#a67755e6dd57951aebab5d15f07f05cbe">CB</a> (r1, raw_r1_pair));
<a name="l00873"></a>00873   r2          = <a class="code" href="m32c-tdep_8c.html#afdec5d030373681fb9c0b0ce79e01c0a">G</a> (<a class="code" href="m32c-tdep_8c.html#a67755e6dd57951aebab5d15f07f05cbe">CB</a> (r2, raw_r2_pair));
<a name="l00874"></a>00874   r3          = <a class="code" href="m32c-tdep_8c.html#afdec5d030373681fb9c0b0ce79e01c0a">G</a> (<a class="code" href="m32c-tdep_8c.html#a67755e6dd57951aebab5d15f07f05cbe">CB</a> (r3, raw_r3_pair));
<a name="l00875"></a>00875   a0          = <a class="code" href="m32c-tdep_8c.html#afdec5d030373681fb9c0b0ce79e01c0a">G</a> (<a class="code" href="m32c-tdep_8c.html#a67755e6dd57951aebab5d15f07f05cbe">CB</a> (a0, raw_a0_pair));
<a name="l00876"></a>00876   a1          = <a class="code" href="m32c-tdep_8c.html#afdec5d030373681fb9c0b0ce79e01c0a">G</a> (<a class="code" href="m32c-tdep_8c.html#a67755e6dd57951aebab5d15f07f05cbe">CB</a> (a1, raw_a1_pair));
<a name="l00877"></a>00877   fb          = <a class="code" href="m32c-tdep_8c.html#afdec5d030373681fb9c0b0ce79e01c0a">G</a> (<a class="code" href="m32c-tdep_8c.html#a67755e6dd57951aebab5d15f07f05cbe">CB</a> (fb, raw_fb_pair));
<a name="l00878"></a>00878 
<a name="l00879"></a>00879   <span class="comment">/* sb is banked on the bfd_mach_m32c, but not on bfd_mach_m16c.</span>
<a name="l00880"></a>00880 <span class="comment">     Specify custom read/write functions that do the right thing.  */</span>
<a name="l00881"></a>00881   sb          = <a class="code" href="m32c-tdep_8c.html#afdec5d030373681fb9c0b0ce79e01c0a">G</a> (add_reg (arch, <span class="stringliteral">&quot;sb&quot;</span>, raw_sb_pair-&gt;type, 0,
<a name="l00882"></a>00882                             m32c_sb_read, m32c_sb_write,
<a name="l00883"></a>00883                             raw_sb_pair, raw_sb_pair + 1, 0));
<a name="l00884"></a>00884 
<a name="l00885"></a>00885   <span class="comment">/* The current sp is either usp or isp, depending on the value of</span>
<a name="l00886"></a>00886 <span class="comment">     the FLG register&#39;s U bit.  */</span>
<a name="l00887"></a>00887   sp          = <a class="code" href="m32c-tdep_8c.html#afdec5d030373681fb9c0b0ce79e01c0a">G</a> (add_reg (arch, <span class="stringliteral">&quot;sp&quot;</span>, usp-&gt;type, 0,
<a name="l00888"></a>00888                             m32c_banked_read, m32c_banked_write,
<a name="l00889"></a>00889                             isp, usp, <a class="code" href="m32c-tdep_8c.html#a595116bebefea13916db4e0f3b5a0d5f">FLAGBIT_U</a>));
<a name="l00890"></a>00890 
<a name="l00891"></a>00891   r0hl        = <a class="code" href="m32c-tdep_8c.html#a1cb63c383d6ad930ac285da71d571e08">CHL</a> (r0, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad1c1365a84197bffdeeff7a2ae5e69fb">int8</a>);
<a name="l00892"></a>00892   r1hl        = <a class="code" href="m32c-tdep_8c.html#a1cb63c383d6ad930ac285da71d571e08">CHL</a> (r1, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad1c1365a84197bffdeeff7a2ae5e69fb">int8</a>);
<a name="l00893"></a>00893   r2hl        = <a class="code" href="m32c-tdep_8c.html#a1cb63c383d6ad930ac285da71d571e08">CHL</a> (r2, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad1c1365a84197bffdeeff7a2ae5e69fb">int8</a>);
<a name="l00894"></a>00894   r3hl        = <a class="code" href="m32c-tdep_8c.html#a1cb63c383d6ad930ac285da71d571e08">CHL</a> (r3, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad1c1365a84197bffdeeff7a2ae5e69fb">int8</a>);
<a name="l00895"></a>00895   intbhl      = <a class="code" href="m32c-tdep_8c.html#a1cb63c383d6ad930ac285da71d571e08">CHL</a> (intb, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#aaaf615d424b9ef0a3696948cd3695233">int16</a>);
<a name="l00896"></a>00896 
<a name="l00897"></a>00897   r2r0        = <a class="code" href="m32c-tdep_8c.html#ae96d61b462c86e78165b4d6a24c1e9cc">CCAT</a> (r2,   r0,   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4c60d0a30f512a7e90bacb0594c1d5c3">int32</a>);
<a name="l00898"></a>00898   r3r1        = <a class="code" href="m32c-tdep_8c.html#ae96d61b462c86e78165b4d6a24c1e9cc">CCAT</a> (r3,   r1,   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4c60d0a30f512a7e90bacb0594c1d5c3">int32</a>);
<a name="l00899"></a>00899   r3r1r2r0    = <a class="code" href="m32c-tdep_8c.html#ae96d61b462c86e78165b4d6a24c1e9cc">CCAT</a> (r3r1, r2r0, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a7c1e0d8113af1aff839c39a1500c0707">int64</a>);
<a name="l00900"></a>00900 
<a name="l00901"></a>00901   r3r2r1r0
<a name="l00902"></a>00902     = add_reg (arch, <span class="stringliteral">&quot;r3r2r1r0&quot;</span>, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a7c1e0d8113af1aff839c39a1500c0707">int64</a>, 0,
<a name="l00903"></a>00903                m32c_r3r2r1r0_read, m32c_r3r2r1r0_write, NULL, NULL, 0);
<a name="l00904"></a>00904 
<a name="l00905"></a>00905   <span class="keywordflow">if</span> (mach == bfd_mach_m16c)
<a name="l00906"></a>00906     a1a0 = <a class="code" href="m32c-tdep_8c.html#ae96d61b462c86e78165b4d6a24c1e9cc">CCAT</a> (a1, a0, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4c60d0a30f512a7e90bacb0594c1d5c3">int32</a>);
<a name="l00907"></a>00907   <span class="keywordflow">else</span>
<a name="l00908"></a>00908     a1a0 = NULL;
<a name="l00909"></a>00909 
<a name="l00910"></a>00910   num_cooked_regs = tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">num_regs</a> - num_raw_regs;
<a name="l00911"></a>00911 
<a name="l00912"></a>00912   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ab7a207d4e85b564c48238283745247b8">pc</a>       = pc;
<a name="l00913"></a>00913   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a275600df025db6499c539773c4e12ed2">flg</a>      = flg;
<a name="l00914"></a>00914   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>       = r0;
<a name="l00915"></a>00915   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ac171978c5c32b113e6b6ab9a920f4edb">r1</a>       = r1;
<a name="l00916"></a>00916   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ada3d7b322cd22af8c0e4da1c427113be">r2</a>       = r2;
<a name="l00917"></a>00917   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6e38b2ae232e49034076dcdbc9e45518">r3</a>       = r3;
<a name="l00918"></a>00918   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#acb65c541d13480f8cf593fb23667016b">r2r0</a>     = r2r0;
<a name="l00919"></a>00919   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ac22aca958ec1e37fef73f78934cae0ef">r3r2r1r0</a> = r3r2r1r0;
<a name="l00920"></a>00920   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#aae98be35ad2f439b8946ab8a1a87a103">r3r1r2r0</a> = r3r1r2r0;
<a name="l00921"></a>00921   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#afe752e13d941f920e6dc32eb30ef4a87">a0</a>       = a0;
<a name="l00922"></a>00922   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a079b5a09de437a19c5e635c50bcef794">a1</a>       = a1;
<a name="l00923"></a>00923   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a3a1da6409e72e5aa257543b183e2d0f1">sb</a>       = sb;
<a name="l00924"></a>00924   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a584c527b4e94c7bf12610034878bd377">fb</a>       = fb;
<a name="l00925"></a>00925   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>       = sp;
<a name="l00926"></a>00926 
<a name="l00927"></a>00927   <span class="comment">/* Set up the DWARF register table.  */</span>
<a name="l00928"></a>00928   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#aa5f0994f6e6048279b423dd2eaf0f11b">dwarf_regs</a>, 0, sizeof (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#aa5f0994f6e6048279b423dd2eaf0f11b">dwarf_regs</a>));
<a name="l00929"></a>00929   set_dwarf_regnum (r0hl + 1, 0x01);
<a name="l00930"></a>00930   set_dwarf_regnum (r0hl + 0, 0x02);
<a name="l00931"></a>00931   set_dwarf_regnum (r1hl + 1, 0x03);
<a name="l00932"></a>00932   set_dwarf_regnum (r1hl + 0, 0x04);
<a name="l00933"></a>00933   set_dwarf_regnum (r0,       0x05);
<a name="l00934"></a>00934   set_dwarf_regnum (r1,       0x06);
<a name="l00935"></a>00935   set_dwarf_regnum (r2,       0x07);
<a name="l00936"></a>00936   set_dwarf_regnum (r3,       0x08);
<a name="l00937"></a>00937   set_dwarf_regnum (a0,       0x09);
<a name="l00938"></a>00938   set_dwarf_regnum (a1,       0x0a);
<a name="l00939"></a>00939   set_dwarf_regnum (fb,       0x0b);
<a name="l00940"></a>00940   set_dwarf_regnum (sp,       0x0c);
<a name="l00941"></a>00941   set_dwarf_regnum (pc,       0x0d); <span class="comment">/* GCC&#39;s invention */</span>
<a name="l00942"></a>00942   set_dwarf_regnum (sb,       0x13);
<a name="l00943"></a>00943   set_dwarf_regnum (r2r0,     0x15);
<a name="l00944"></a>00944   set_dwarf_regnum (r3r1,     0x16);
<a name="l00945"></a>00945   <span class="keywordflow">if</span> (a1a0)
<a name="l00946"></a>00946     set_dwarf_regnum (a1a0,   0x17);
<a name="l00947"></a>00947 
<a name="l00948"></a>00948   <span class="comment">/* Enumerate the save/restore register group.</span>
<a name="l00949"></a>00949 <span class="comment"></span>
<a name="l00950"></a>00950 <span class="comment">     The regcache_save and regcache_restore functions apply their read</span>
<a name="l00951"></a>00951 <span class="comment">     function to each register in this group.</span>
<a name="l00952"></a>00952 <span class="comment"></span>
<a name="l00953"></a>00953 <span class="comment">     Since frame_pop supplies frame_unwind_register as its read</span>
<a name="l00954"></a>00954 <span class="comment">     function, the registers meaningful to the Dwarf unwinder need to</span>
<a name="l00955"></a>00955 <span class="comment">     be in this group.</span>
<a name="l00956"></a>00956 <span class="comment"></span>
<a name="l00957"></a>00957 <span class="comment">     On the other hand, when we make inferior calls, save_inferior_status</span>
<a name="l00958"></a>00958 <span class="comment">     and restore_inferior_status use them to preserve the current register</span>
<a name="l00959"></a>00959 <span class="comment">     values across the inferior call.  For this, you&#39;d kind of like to</span>
<a name="l00960"></a>00960 <span class="comment">     preserve all the raw registers, to protect the interrupted code from</span>
<a name="l00961"></a>00961 <span class="comment">     any sort of bank switching the callee might have done.  But we handle</span>
<a name="l00962"></a>00962 <span class="comment">     those cases so badly anyway --- for example, it matters whether we</span>
<a name="l00963"></a>00963 <span class="comment">     restore FLG before or after we restore the general-purpose registers,</span>
<a name="l00964"></a>00964 <span class="comment">     but there&#39;s no way to express that --- that it isn&#39;t worth worrying</span>
<a name="l00965"></a>00965 <span class="comment">     about.</span>
<a name="l00966"></a>00966 <span class="comment"></span>
<a name="l00967"></a>00967 <span class="comment">     We omit control registers like inthl: if you call a function that</span>
<a name="l00968"></a>00968 <span class="comment">     changes those, it&#39;s probably because you wanted that change to be</span>
<a name="l00969"></a>00969 <span class="comment">     visible to the interrupted code.  */</span>
<a name="l00970"></a>00970   mark_save_restore (r0);
<a name="l00971"></a>00971   mark_save_restore (r1);
<a name="l00972"></a>00972   mark_save_restore (r2);
<a name="l00973"></a>00973   mark_save_restore (r3);
<a name="l00974"></a>00974   mark_save_restore (a0);
<a name="l00975"></a>00975   mark_save_restore (a1);
<a name="l00976"></a>00976   mark_save_restore (sb);
<a name="l00977"></a>00977   mark_save_restore (fb);
<a name="l00978"></a>00978   mark_save_restore (sp);
<a name="l00979"></a>00979   mark_save_restore (pc);
<a name="l00980"></a>00980   mark_save_restore (flg);
<a name="l00981"></a>00981 
<a name="l00982"></a>00982   <a class="code" href="gdbarch_8c.html#ad8417c5d66cf04d0587f58f82de94c48">set_gdbarch_num_regs</a> (arch, num_raw_regs);
<a name="l00983"></a>00983   <a class="code" href="gdbarch_8c.html#aaf72e08f972ba348d5d28f6b6b8db638">set_gdbarch_num_pseudo_regs</a> (arch, num_cooked_regs);
<a name="l00984"></a>00984   <a class="code" href="gdbarch_8c.html#a8852f70e2afc74953a57521ed08a3381">set_gdbarch_pc_regnum</a> (arch, pc-&gt;num);
<a name="l00985"></a>00985   <a class="code" href="gdbarch_8c.html#a81a92a88a67093d18e59fd5650fda352">set_gdbarch_sp_regnum</a> (arch, sp-&gt;num);
<a name="l00986"></a>00986   <a class="code" href="gdbarch_8c.html#a378ba40a6275393e204873c5bba602ad">set_gdbarch_register_name</a> (arch, m32c_register_name);
<a name="l00987"></a>00987   <a class="code" href="gdbarch_8c.html#a21919f6adfae80ed36e69e89cdfea531">set_gdbarch_register_type</a> (arch, m32c_register_type);
<a name="l00988"></a>00988   <a class="code" href="gdbarch_8c.html#a99fd57c1a882cf61c413e64028937a1b">set_gdbarch_pseudo_register_read</a> (arch, m32c_pseudo_register_read);
<a name="l00989"></a>00989   <a class="code" href="gdbarch_8c.html#ae463eca1992acf69ff1bc28ed8ca3aea">set_gdbarch_pseudo_register_write</a> (arch, m32c_pseudo_register_write);
<a name="l00990"></a>00990   <a class="code" href="gdbarch_8c.html#a76132b68159d6b89283516c768e22839">set_gdbarch_register_sim_regno</a> (arch, m32c_register_sim_regno);
<a name="l00991"></a>00991   <a class="code" href="gdbarch_8c.html#abeb6b220ed850a9f2b4a992dfcae9a2b">set_gdbarch_stab_reg_to_regnum</a> (arch, m32c_debug_info_reg_to_regnum);
<a name="l00992"></a>00992   <a class="code" href="gdbarch_8c.html#a43ca55f05fcf599681eb376bbc6c8ece">set_gdbarch_dwarf2_reg_to_regnum</a> (arch, m32c_debug_info_reg_to_regnum);
<a name="l00993"></a>00993   <a class="code" href="gdbarch_8c.html#a17301533b8e9f7002350ed0a2f4b5558">set_gdbarch_register_reggroup_p</a> (arch, m32c_register_reggroup_p);
<a name="l00994"></a>00994 
<a name="l00995"></a>00995   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (arch, <a class="code" href="reggroups_8c.html#a2409cc2e19cc71ae02448af0ec0308fd">general_reggroup</a>);
<a name="l00996"></a>00996   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (arch, <a class="code" href="reggroups_8c.html#a1c7760844f4c40a5fb70e84f76f39676">all_reggroup</a>);
<a name="l00997"></a>00997   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (arch, <a class="code" href="reggroups_8c.html#a9be54927c9d0393a70b8a3f0bc740de3">save_reggroup</a>);
<a name="l00998"></a>00998   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (arch, <a class="code" href="reggroups_8c.html#a627d3b74a917560e7d81d93c472e915c">restore_reggroup</a>);
<a name="l00999"></a>00999   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (arch, <a class="code" href="reggroups_8c.html#a55cfcb5dfb32653c793fa6b402564068">system_reggroup</a>);
<a name="l01000"></a>01000   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (arch, m32c_dma_reggroup);
<a name="l01001"></a>01001 }
<a name="l01002"></a>01002 
<a name="l01003"></a>01003 
<a name="l01004"></a>01004 
<a name="l01005"></a>01005 <span class="comment">/* Breakpoints.  */</span>
<a name="l01006"></a>01006 
<a name="l01007"></a>01007 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *
<a name="l01008"></a>01008 m32c_breakpoint_from_pc (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *pc, <span class="keywordtype">int</span> *len)
<a name="l01009"></a>01009 {
<a name="l01010"></a>01010   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> break_insn[] = { 0x00 }; <span class="comment">/* brk */</span>
<a name="l01011"></a>01011 
<a name="l01012"></a>01012   *len = <span class="keyword">sizeof</span> (break_insn);
<a name="l01013"></a>01013   <span class="keywordflow">return</span> break_insn;
<a name="l01014"></a>01014 }
<a name="l01015"></a>01015 
<a name="l01016"></a>01016 
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 <span class="comment">/* Prologue analysis.  */</span>
<a name="l01019"></a>01019 
<a name="l01020"></a>01020 <span class="keyword">struct </span>m32c_prologue
<a name="l01021"></a>01021 {
<a name="l01022"></a>01022   <span class="comment">/* For consistency with the DWARF 2 .debug_frame info generated by</span>
<a name="l01023"></a>01023 <span class="comment">     GCC, a frame&#39;s CFA is the address immediately after the saved</span>
<a name="l01024"></a>01024 <span class="comment">     return address.  */</span>
<a name="l01025"></a>01025 
<a name="l01026"></a>01026   <span class="comment">/* The architecture for which we generated this prologue info.  */</span>
<a name="l01027"></a>01027   <span class="keyword">struct </span>gdbarch *arch;
<a name="l01028"></a>01028 
<a name="l01029"></a>01029   <span class="keyword">enum</span> {
<a name="l01030"></a>01030     <span class="comment">/* This function uses a frame pointer.  */</span>
<a name="l01031"></a>01031     prologue_with_frame_ptr,
<a name="l01032"></a>01032 
<a name="l01033"></a>01033     <span class="comment">/* This function has no frame pointer.  */</span>
<a name="l01034"></a>01034     prologue_sans_frame_ptr,
<a name="l01035"></a>01035 
<a name="l01036"></a>01036     <span class="comment">/* This function sets up the stack, so its frame is the first</span>
<a name="l01037"></a>01037 <span class="comment">       frame on the stack.  */</span>
<a name="l01038"></a>01038     prologue_first_frame
<a name="l01039"></a>01039 
<a name="l01040"></a>01040   } kind;
<a name="l01041"></a>01041 
<a name="l01042"></a>01042   <span class="comment">/* If KIND is prologue_with_frame_ptr, this is the offset from the</span>
<a name="l01043"></a>01043 <span class="comment">     CFA to where the frame pointer points.  This is always zero or</span>
<a name="l01044"></a>01044 <span class="comment">     negative.  */</span>
<a name="l01045"></a>01045   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> frame_ptr_offset;
<a name="l01046"></a>01046 
<a name="l01047"></a>01047   <span class="comment">/* If KIND is prologue_sans_frame_ptr, the offset from the CFA to</span>
<a name="l01048"></a>01048 <span class="comment">     the stack pointer --- always zero or negative.</span>
<a name="l01049"></a>01049 <span class="comment"></span>
<a name="l01050"></a>01050 <span class="comment">     Calling this a &quot;size&quot; is a bit misleading, but given that the</span>
<a name="l01051"></a>01051 <span class="comment">     stack grows downwards, using offsets for everything keeps one</span>
<a name="l01052"></a>01052 <span class="comment">     from going completely sign-crazy: you never change anything&#39;s</span>
<a name="l01053"></a>01053 <span class="comment">     sign for an ADD instruction; always change the second operand&#39;s</span>
<a name="l01054"></a>01054 <span class="comment">     sign for a SUB instruction; and everything takes care of</span>
<a name="l01055"></a>01055 <span class="comment">     itself.</span>
<a name="l01056"></a>01056 <span class="comment"></span>
<a name="l01057"></a>01057 <span class="comment">     Functions that use alloca don&#39;t have a constant frame size.  But</span>
<a name="l01058"></a>01058 <span class="comment">     they always have frame pointers, so we must use that to find the</span>
<a name="l01059"></a>01059 <span class="comment">     CFA (and perhaps to unwind the stack pointer).  */</span>
<a name="l01060"></a>01060   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> frame_size;
<a name="l01061"></a>01061 
<a name="l01062"></a>01062   <span class="comment">/* The address of the first instruction at which the frame has been</span>
<a name="l01063"></a>01063 <span class="comment">     set up and the arguments are where the debug info says they are</span>
<a name="l01064"></a>01064 <span class="comment">     --- as best as we can tell.  */</span>
<a name="l01065"></a>01065   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> prologue_end;
<a name="l01066"></a>01066 
<a name="l01067"></a>01067   <span class="comment">/* reg_offset[R] is the offset from the CFA at which register R is</span>
<a name="l01068"></a>01068 <span class="comment">     saved, or 1 if register R has not been saved.  (Real values are</span>
<a name="l01069"></a>01069 <span class="comment">     always zero or negative.)  */</span>
<a name="l01070"></a>01070   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> reg_offset[<a class="code" href="m32c-tdep_8c.html#a861d6bfdd85412bd19ecb0df0742277c">M32C_MAX_NUM_REGS</a>];
<a name="l01071"></a>01071 };
<a name="l01072"></a>01072 
<a name="l01073"></a>01073 
<a name="l01074"></a>01074 <span class="comment">/* The longest I&#39;ve seen, anyway.  */</span>
<a name="l01075"></a><a class="code" href="m32c-tdep_8c.html#aa8750e82a94772442cba03b55ce13ae8">01075</a> <span class="preprocessor">#define M32C_MAX_INSN_LEN (9)</span>
<a name="l01076"></a>01076 <span class="preprocessor"></span>
<a name="l01077"></a>01077 <span class="comment">/* Processor state, for the prologue analyzer.  */</span>
<a name="l01078"></a>01078 <span class="keyword">struct </span>m32c_pv_state
<a name="l01079"></a>01079 {
<a name="l01080"></a>01080   <span class="keyword">struct </span>gdbarch *arch;
<a name="l01081"></a>01081   <a class="code" href="structprologue__value.html">pv_t</a> r0, r1, r2, r3;
<a name="l01082"></a>01082   <a class="code" href="structprologue__value.html">pv_t</a> a0, a1;
<a name="l01083"></a>01083   <a class="code" href="structprologue__value.html">pv_t</a> sb, fb, <a class="code" href="windows-nat_8c.html#a8d40798874dab99986478ef00ff3e297">sp</a>;
<a name="l01084"></a>01084   <a class="code" href="structprologue__value.html">pv_t</a> pc;
<a name="l01085"></a>01085   <span class="keyword">struct </span>pv_area *stack;
<a name="l01086"></a>01086 
<a name="l01087"></a>01087   <span class="comment">/* Bytes from the current PC, the address they were read from,</span>
<a name="l01088"></a>01088 <span class="comment">     and the address of the next unconsumed byte.  */</span>
<a name="l01089"></a>01089   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> insn[<a class="code" href="m32c-tdep_8c.html#aa8750e82a94772442cba03b55ce13ae8">M32C_MAX_INSN_LEN</a>];
<a name="l01090"></a>01090   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> scan_pc, next_addr;
<a name="l01091"></a>01091 };
<a name="l01092"></a>01092 
<a name="l01093"></a>01093 
<a name="l01094"></a>01094 <span class="comment">/* Push VALUE on STATE&#39;s stack, occupying SIZE bytes.  Return zero if</span>
<a name="l01095"></a>01095 <span class="comment">   all went well, or non-zero if simulating the action would trash our</span>
<a name="l01096"></a>01096 <span class="comment">   state.  */</span>
<a name="l01097"></a>01097 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01098"></a>01098 m32c_pv_push (<span class="keyword">struct</span> m32c_pv_state *state, <a class="code" href="structprologue__value.html">pv_t</a> value, <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>)
<a name="l01099"></a>01099 {
<a name="l01100"></a>01100   <span class="keywordflow">if</span> (<a class="code" href="prologue-value_8c.html#af16f8e9cb043efd0a97c592f199d4aa7">pv_area_store_would_trash</a> (state-&gt;stack, state-&gt;sp))
<a name="l01101"></a>01101     <span class="keywordflow">return</span> 1;
<a name="l01102"></a>01102 
<a name="l01103"></a>01103   state-&gt;sp = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (state-&gt;sp, -size);
<a name="l01104"></a>01104   <a class="code" href="prologue-value_8c.html#af1c1f51f05db124191cd6bf1a4077f3f">pv_area_store</a> (state-&gt;stack, state-&gt;sp, size, value);
<a name="l01105"></a>01105 
<a name="l01106"></a>01106   <span class="keywordflow">return</span> 0;
<a name="l01107"></a>01107 }
<a name="l01108"></a>01108 
<a name="l01109"></a>01109 
<a name="l01110"></a>01110 <span class="comment">/* A source or destination location for an m16c or m32c</span>
<a name="l01111"></a>01111 <span class="comment">   instruction.  */</span>
<a name="l01112"></a>01112 <span class="keyword">struct </span>srcdest
<a name="l01113"></a>01113 {
<a name="l01114"></a>01114   <span class="comment">/* If srcdest_reg, the location is a register pointed to by REG.</span>
<a name="l01115"></a>01115 <span class="comment">     If srcdest_partial_reg, the location is part of a register pointed</span>
<a name="l01116"></a>01116 <span class="comment">     to by REG.  We don&#39;t try to handle this too well.</span>
<a name="l01117"></a>01117 <span class="comment">     If srcdest_mem, the location is memory whose address is ADDR.  */</span>
<a name="l01118"></a>01118   <span class="keyword">enum</span> { srcdest_reg, srcdest_partial_reg, srcdest_mem } kind;
<a name="l01119"></a>01119   <a class="code" href="structprologue__value.html">pv_t</a> *reg, addr;
<a name="l01120"></a>01120 };
<a name="l01121"></a>01121 
<a name="l01122"></a>01122 
<a name="l01123"></a>01123 <span class="comment">/* Return the SIZE-byte value at LOC in STATE.  */</span>
<a name="l01124"></a>01124 <span class="keyword">static</span> <a class="code" href="structprologue__value.html">pv_t</a>
<a name="l01125"></a>01125 m32c_srcdest_fetch (<span class="keyword">struct</span> m32c_pv_state *state, <span class="keyword">struct</span> srcdest loc, <span class="keywordtype">int</span> size)
<a name="l01126"></a>01126 {
<a name="l01127"></a>01127   <span class="keywordflow">if</span> (loc.kind == srcdest_mem)
<a name="l01128"></a>01128     <span class="keywordflow">return</span> <a class="code" href="prologue-value_8c.html#ab467d5c80e75828bd5889f4c2b16ca48">pv_area_fetch</a> (state-&gt;stack, loc.addr, size);
<a name="l01129"></a>01129   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (loc.kind == srcdest_partial_reg)
<a name="l01130"></a>01130     <span class="keywordflow">return</span> <a class="code" href="prologue-value_8c.html#a33fab5d191479bf6d3f68569c1f2a508">pv_unknown</a> ();
<a name="l01131"></a>01131   <span class="keywordflow">else</span>
<a name="l01132"></a>01132     <span class="keywordflow">return</span> *loc.reg;
<a name="l01133"></a>01133 }
<a name="l01134"></a>01134 
<a name="l01135"></a>01135 
<a name="l01136"></a>01136 <span class="comment">/* Write VALUE, a SIZE-byte value, to LOC in STATE.  Return zero if</span>
<a name="l01137"></a>01137 <span class="comment">   all went well, or non-zero if simulating the store would trash our</span>
<a name="l01138"></a>01138 <span class="comment">   state.  */</span>
<a name="l01139"></a>01139 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01140"></a>01140 m32c_srcdest_store (<span class="keyword">struct</span> m32c_pv_state *state, <span class="keyword">struct</span> srcdest loc,
<a name="l01141"></a>01141                     <a class="code" href="structprologue__value.html">pv_t</a> value, <span class="keywordtype">int</span> size)
<a name="l01142"></a>01142 {
<a name="l01143"></a>01143   <span class="keywordflow">if</span> (loc.kind == srcdest_mem)
<a name="l01144"></a>01144     {
<a name="l01145"></a>01145       <span class="keywordflow">if</span> (<a class="code" href="prologue-value_8c.html#af16f8e9cb043efd0a97c592f199d4aa7">pv_area_store_would_trash</a> (state-&gt;stack, loc.addr))
<a name="l01146"></a>01146         <span class="keywordflow">return</span> 1;
<a name="l01147"></a>01147       <a class="code" href="prologue-value_8c.html#af1c1f51f05db124191cd6bf1a4077f3f">pv_area_store</a> (state-&gt;stack, loc.addr, size, value);
<a name="l01148"></a>01148     }
<a name="l01149"></a>01149   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (loc.kind == srcdest_partial_reg)
<a name="l01150"></a>01150     *loc.reg = <a class="code" href="prologue-value_8c.html#a33fab5d191479bf6d3f68569c1f2a508">pv_unknown</a> ();
<a name="l01151"></a>01151   <span class="keywordflow">else</span>
<a name="l01152"></a>01152     *loc.reg = value;
<a name="l01153"></a>01153 
<a name="l01154"></a>01154   <span class="keywordflow">return</span> 0;
<a name="l01155"></a>01155 }
<a name="l01156"></a>01156 
<a name="l01157"></a>01157 
<a name="l01158"></a>01158 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01159"></a>01159 m32c_sign_ext (<span class="keywordtype">int</span> v, <span class="keywordtype">int</span> <a class="code" href="arm-tdep_8c.html#a6d53921cd0f216408c4aed2806a0cb1f">bits</a>)
<a name="l01160"></a>01160 {
<a name="l01161"></a>01161   <span class="keywordtype">int</span> mask = 1 &lt;&lt; (bits - 1);
<a name="l01162"></a>01162   <span class="keywordflow">return</span> (v ^ mask) - mask;
<a name="l01163"></a>01163 }
<a name="l01164"></a>01164 
<a name="l01165"></a>01165 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l01166"></a>01166 m32c_next_byte (<span class="keyword">struct</span> m32c_pv_state *st)
<a name="l01167"></a>01167 {
<a name="l01168"></a>01168   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (st-&gt;next_addr - st-&gt;scan_pc &lt; sizeof (st-&gt;insn));
<a name="l01169"></a>01169   <span class="keywordflow">return</span> st-&gt;insn[st-&gt;next_addr++ - st-&gt;scan_pc];
<a name="l01170"></a>01170 }
<a name="l01171"></a>01171 
<a name="l01172"></a>01172 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01173"></a>01173 m32c_udisp8 (<span class="keyword">struct</span> m32c_pv_state *st)
<a name="l01174"></a>01174 {
<a name="l01175"></a>01175   <span class="keywordflow">return</span> m32c_next_byte (st);
<a name="l01176"></a>01176 }
<a name="l01177"></a>01177 
<a name="l01178"></a>01178 
<a name="l01179"></a>01179 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01180"></a>01180 m32c_sdisp8 (<span class="keyword">struct</span> m32c_pv_state *st)
<a name="l01181"></a>01181 {
<a name="l01182"></a>01182   <span class="keywordflow">return</span> m32c_sign_ext (m32c_next_byte (st), 8);
<a name="l01183"></a>01183 }
<a name="l01184"></a>01184 
<a name="l01185"></a>01185 
<a name="l01186"></a>01186 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01187"></a>01187 m32c_udisp16 (<span class="keyword">struct</span> m32c_pv_state *st)
<a name="l01188"></a>01188 {
<a name="l01189"></a>01189   <span class="keywordtype">int</span> low  = m32c_next_byte (st);
<a name="l01190"></a>01190   <span class="keywordtype">int</span> high = m32c_next_byte (st);
<a name="l01191"></a>01191 
<a name="l01192"></a>01192   <span class="keywordflow">return</span> low + (high &lt;&lt; 8);
<a name="l01193"></a>01193 }
<a name="l01194"></a>01194 
<a name="l01195"></a>01195 
<a name="l01196"></a>01196 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01197"></a>01197 m32c_sdisp16 (<span class="keyword">struct</span> m32c_pv_state *st)
<a name="l01198"></a>01198 {
<a name="l01199"></a>01199   <span class="keywordtype">int</span> low  = m32c_next_byte (st);
<a name="l01200"></a>01200   <span class="keywordtype">int</span> high = m32c_next_byte (st);
<a name="l01201"></a>01201 
<a name="l01202"></a>01202   <span class="keywordflow">return</span> m32c_sign_ext (low + (high &lt;&lt; 8), 16);
<a name="l01203"></a>01203 }
<a name="l01204"></a>01204 
<a name="l01205"></a>01205 
<a name="l01206"></a>01206 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01207"></a>01207 m32c_udisp24 (<span class="keyword">struct</span> m32c_pv_state *st)
<a name="l01208"></a>01208 {
<a name="l01209"></a>01209   <span class="keywordtype">int</span> low  = m32c_next_byte (st);
<a name="l01210"></a>01210   <span class="keywordtype">int</span> mid  = m32c_next_byte (st);
<a name="l01211"></a>01211   <span class="keywordtype">int</span> high = m32c_next_byte (st);
<a name="l01212"></a>01212 
<a name="l01213"></a>01213   <span class="keywordflow">return</span> low + (mid &lt;&lt; 8) + (high &lt;&lt; 16);
<a name="l01214"></a>01214 }
<a name="l01215"></a>01215 
<a name="l01216"></a>01216 
<a name="l01217"></a>01217 <span class="comment">/* Extract the &#39;source&#39; field from an m32c MOV.size:G-format instruction.  */</span>
<a name="l01218"></a>01218 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01219"></a>01219 m32c_get_src23 (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *i)
<a name="l01220"></a>01220 {
<a name="l01221"></a>01221   <span class="keywordflow">return</span> (((i[0] &amp; 0x70) &gt;&gt; 2)
<a name="l01222"></a>01222           | ((i[1] &amp; 0x30) &gt;&gt; 4));
<a name="l01223"></a>01223 }
<a name="l01224"></a>01224 
<a name="l01225"></a>01225 
<a name="l01226"></a>01226 <span class="comment">/* Extract the &#39;dest&#39; field from an m32c MOV.size:G-format instruction.  */</span>
<a name="l01227"></a>01227 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01228"></a>01228 m32c_get_dest23 (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *i)
<a name="l01229"></a>01229 {
<a name="l01230"></a>01230   <span class="keywordflow">return</span> (((i[0] &amp; 0x0e) &lt;&lt; 1)
<a name="l01231"></a>01231           | ((i[1] &amp; 0xc0) &gt;&gt; 6));
<a name="l01232"></a>01232 }
<a name="l01233"></a>01233 
<a name="l01234"></a>01234 
<a name="l01235"></a>01235 <span class="keyword">static</span> <span class="keyword">struct </span>srcdest
<a name="l01236"></a>01236 m32c_decode_srcdest4 (struct m32c_pv_state *st,
<a name="l01237"></a>01237                       <span class="keywordtype">int</span> <a class="code" href="ser-unix_8c.html#a45a5b7c00a796a23f01673cef1dbe0a9">code</a>, <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>)
<a name="l01238"></a>01238 {
<a name="l01239"></a>01239   <span class="keyword">struct </span>srcdest sd;
<a name="l01240"></a>01240 
<a name="l01241"></a>01241   <span class="keywordflow">if</span> (code &lt; 6)
<a name="l01242"></a>01242     sd.kind = (size == 2 ? srcdest_reg : srcdest_partial_reg);
<a name="l01243"></a>01243   <span class="keywordflow">else</span>
<a name="l01244"></a>01244     sd.kind = srcdest_mem;
<a name="l01245"></a>01245 
<a name="l01246"></a>01246   sd.addr = <a class="code" href="prologue-value_8c.html#a33fab5d191479bf6d3f68569c1f2a508">pv_unknown</a> ();
<a name="l01247"></a>01247   sd.reg = 0;
<a name="l01248"></a>01248 
<a name="l01249"></a>01249   <span class="keywordflow">switch</span> (code)
<a name="l01250"></a>01250     {
<a name="l01251"></a>01251     <span class="keywordflow">case</span> 0x0: sd.reg = (size == 1 ? &amp;st-&gt;r0 : &amp;st-&gt;r0); <span class="keywordflow">break</span>;
<a name="l01252"></a>01252     <span class="keywordflow">case</span> 0x1: sd.reg = (size == 1 ? &amp;st-&gt;r0 : &amp;st-&gt;r1); <span class="keywordflow">break</span>;
<a name="l01253"></a>01253     <span class="keywordflow">case</span> 0x2: sd.reg = (size == 1 ? &amp;st-&gt;r1 : &amp;st-&gt;r2); <span class="keywordflow">break</span>;
<a name="l01254"></a>01254     <span class="keywordflow">case</span> 0x3: sd.reg = (size == 1 ? &amp;st-&gt;r1 : &amp;st-&gt;r3); <span class="keywordflow">break</span>;
<a name="l01255"></a>01255 
<a name="l01256"></a>01256     <span class="keywordflow">case</span> 0x4: sd.reg = &amp;st-&gt;a0; <span class="keywordflow">break</span>;
<a name="l01257"></a>01257     <span class="keywordflow">case</span> 0x5: sd.reg = &amp;st-&gt;a1; <span class="keywordflow">break</span>;
<a name="l01258"></a>01258 
<a name="l01259"></a>01259     <span class="keywordflow">case</span> 0x6: sd.addr = st-&gt;a0; <span class="keywordflow">break</span>;
<a name="l01260"></a>01260     <span class="keywordflow">case</span> 0x7: sd.addr = st-&gt;a1; <span class="keywordflow">break</span>;
<a name="l01261"></a>01261 
<a name="l01262"></a>01262     <span class="keywordflow">case</span> 0x8: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;a0, m32c_udisp8 (st)); <span class="keywordflow">break</span>;
<a name="l01263"></a>01263     <span class="keywordflow">case</span> 0x9: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;a1, m32c_udisp8 (st)); <span class="keywordflow">break</span>;
<a name="l01264"></a>01264     <span class="keywordflow">case</span> 0xa: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;sb, m32c_udisp8 (st)); <span class="keywordflow">break</span>;
<a name="l01265"></a>01265     <span class="keywordflow">case</span> 0xb: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;fb, m32c_sdisp8 (st)); <span class="keywordflow">break</span>;
<a name="l01266"></a>01266 
<a name="l01267"></a>01267     <span class="keywordflow">case</span> 0xc: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;a0, m32c_udisp16 (st)); <span class="keywordflow">break</span>;
<a name="l01268"></a>01268     <span class="keywordflow">case</span> 0xd: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;a1, m32c_udisp16 (st)); <span class="keywordflow">break</span>;
<a name="l01269"></a>01269     <span class="keywordflow">case</span> 0xe: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;sb, m32c_udisp16 (st)); <span class="keywordflow">break</span>;
<a name="l01270"></a>01270     <span class="keywordflow">case</span> 0xf: sd.addr = <a class="code" href="prologue-value_8c.html#a1d35dc4423d652ac8f7cbdfb94df117b">pv_constant</a> (m32c_udisp16 (st)); <span class="keywordflow">break</span>;
<a name="l01271"></a>01271 
<a name="l01272"></a>01272     <span class="keywordflow">default</span>:
<a name="l01273"></a>01273       <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;unexpected srcdest4&quot;</span>);
<a name="l01274"></a>01274     }
<a name="l01275"></a>01275 
<a name="l01276"></a>01276   <span class="keywordflow">return</span> sd;
<a name="l01277"></a>01277 }
<a name="l01278"></a>01278 
<a name="l01279"></a>01279 
<a name="l01280"></a>01280 <span class="keyword">static</span> <span class="keyword">struct </span>srcdest
<a name="l01281"></a>01281 m32c_decode_sd23 (struct m32c_pv_state *st, <span class="keywordtype">int</span> <a class="code" href="ser-unix_8c.html#a45a5b7c00a796a23f01673cef1dbe0a9">code</a>, <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>, <span class="keywordtype">int</span> ind)
<a name="l01282"></a>01282 {
<a name="l01283"></a>01283   <span class="keyword">struct </span>srcdest sd;
<a name="l01284"></a>01284 
<a name="l01285"></a>01285   sd.addr = <a class="code" href="prologue-value_8c.html#a33fab5d191479bf6d3f68569c1f2a508">pv_unknown</a> ();
<a name="l01286"></a>01286   sd.reg = 0;
<a name="l01287"></a>01287 
<a name="l01288"></a>01288   <span class="keywordflow">switch</span> (code)
<a name="l01289"></a>01289     {
<a name="l01290"></a>01290     <span class="keywordflow">case</span> 0x12:
<a name="l01291"></a>01291     <span class="keywordflow">case</span> 0x13:
<a name="l01292"></a>01292     <span class="keywordflow">case</span> 0x10:
<a name="l01293"></a>01293     <span class="keywordflow">case</span> 0x11:
<a name="l01294"></a>01294       sd.kind = (size == 1) ? srcdest_partial_reg : srcdest_reg;
<a name="l01295"></a>01295       <span class="keywordflow">break</span>;
<a name="l01296"></a>01296 
<a name="l01297"></a>01297     <span class="keywordflow">case</span> 0x02:
<a name="l01298"></a>01298     <span class="keywordflow">case</span> 0x03:
<a name="l01299"></a>01299       sd.kind = (size == 4) ? srcdest_reg : srcdest_partial_reg;
<a name="l01300"></a>01300       <span class="keywordflow">break</span>;
<a name="l01301"></a>01301 
<a name="l01302"></a>01302     <span class="keywordflow">default</span>:
<a name="l01303"></a>01303       sd.kind = srcdest_mem;
<a name="l01304"></a>01304       <span class="keywordflow">break</span>;
<a name="l01305"></a>01305 
<a name="l01306"></a>01306     }
<a name="l01307"></a>01307 
<a name="l01308"></a>01308   <span class="keywordflow">switch</span> (code)
<a name="l01309"></a>01309     {
<a name="l01310"></a>01310     <span class="keywordflow">case</span> 0x12: sd.reg = &amp;st-&gt;r0; <span class="keywordflow">break</span>;
<a name="l01311"></a>01311     <span class="keywordflow">case</span> 0x13: sd.reg = &amp;st-&gt;r1; <span class="keywordflow">break</span>;
<a name="l01312"></a>01312     <span class="keywordflow">case</span> 0x10: sd.reg = ((size == 1) ? &amp;st-&gt;r0 : &amp;st-&gt;r2); <span class="keywordflow">break</span>;
<a name="l01313"></a>01313     <span class="keywordflow">case</span> 0x11: sd.reg = ((size == 1) ? &amp;st-&gt;r1 : &amp;st-&gt;r3); <span class="keywordflow">break</span>;
<a name="l01314"></a>01314     <span class="keywordflow">case</span> 0x02: sd.reg = &amp;st-&gt;a0; <span class="keywordflow">break</span>;
<a name="l01315"></a>01315     <span class="keywordflow">case</span> 0x03: sd.reg = &amp;st-&gt;a1; <span class="keywordflow">break</span>;
<a name="l01316"></a>01316 
<a name="l01317"></a>01317     <span class="keywordflow">case</span> 0x00: sd.addr = st-&gt;a0; <span class="keywordflow">break</span>;
<a name="l01318"></a>01318     <span class="keywordflow">case</span> 0x01: sd.addr = st-&gt;a1; <span class="keywordflow">break</span>;
<a name="l01319"></a>01319     <span class="keywordflow">case</span> 0x04: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;a0, m32c_udisp8 (st)); <span class="keywordflow">break</span>;
<a name="l01320"></a>01320     <span class="keywordflow">case</span> 0x05: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;a1, m32c_udisp8 (st)); <span class="keywordflow">break</span>;
<a name="l01321"></a>01321     <span class="keywordflow">case</span> 0x06: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;sb, m32c_udisp8 (st)); <span class="keywordflow">break</span>;
<a name="l01322"></a>01322     <span class="keywordflow">case</span> 0x07: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;fb, m32c_sdisp8 (st)); <span class="keywordflow">break</span>;
<a name="l01323"></a>01323     <span class="keywordflow">case</span> 0x08: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;a0, m32c_udisp16 (st)); <span class="keywordflow">break</span>;
<a name="l01324"></a>01324     <span class="keywordflow">case</span> 0x09: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;a1, m32c_udisp16 (st)); <span class="keywordflow">break</span>;
<a name="l01325"></a>01325     <span class="keywordflow">case</span> 0x0a: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;sb, m32c_udisp16 (st)); <span class="keywordflow">break</span>;
<a name="l01326"></a>01326     <span class="keywordflow">case</span> 0x0b: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;fb, m32c_sdisp16 (st)); <span class="keywordflow">break</span>;
<a name="l01327"></a>01327     <span class="keywordflow">case</span> 0x0c: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;a0, m32c_udisp24 (st)); <span class="keywordflow">break</span>;
<a name="l01328"></a>01328     <span class="keywordflow">case</span> 0x0d: sd.addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (st-&gt;a1, m32c_udisp24 (st)); <span class="keywordflow">break</span>;
<a name="l01329"></a>01329     <span class="keywordflow">case</span> 0x0f: sd.addr = <a class="code" href="prologue-value_8c.html#a1d35dc4423d652ac8f7cbdfb94df117b">pv_constant</a> (m32c_udisp16 (st)); <span class="keywordflow">break</span>;
<a name="l01330"></a>01330     <span class="keywordflow">case</span> 0x0e: sd.addr = <a class="code" href="prologue-value_8c.html#a1d35dc4423d652ac8f7cbdfb94df117b">pv_constant</a> (m32c_udisp24 (st)); <span class="keywordflow">break</span>;
<a name="l01331"></a>01331     <span class="keywordflow">default</span>:
<a name="l01332"></a>01332       <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;unexpected sd23&quot;</span>);
<a name="l01333"></a>01333     }
<a name="l01334"></a>01334 
<a name="l01335"></a>01335   <span class="keywordflow">if</span> (ind)
<a name="l01336"></a>01336     {
<a name="l01337"></a>01337       sd.addr = m32c_srcdest_fetch (st, sd, 4);
<a name="l01338"></a>01338       sd.kind = srcdest_mem;
<a name="l01339"></a>01339     }
<a name="l01340"></a>01340 
<a name="l01341"></a>01341   <span class="keywordflow">return</span> sd;
<a name="l01342"></a>01342 }
<a name="l01343"></a>01343 
<a name="l01344"></a>01344 
<a name="l01345"></a>01345 <span class="comment">/* The r16c and r32c machines have instructions with similar</span>
<a name="l01346"></a>01346 <span class="comment">   semantics, but completely different machine language encodings.  So</span>
<a name="l01347"></a>01347 <span class="comment">   we break out the semantics into their own functions, and leave</span>
<a name="l01348"></a>01348 <span class="comment">   machine-specific decoding in m32c_analyze_prologue.</span>
<a name="l01349"></a>01349 <span class="comment"></span>
<a name="l01350"></a>01350 <span class="comment">   The following functions all expect their arguments already decoded,</span>
<a name="l01351"></a>01351 <span class="comment">   and they all return zero if analysis should continue past this</span>
<a name="l01352"></a>01352 <span class="comment">   instruction, or non-zero if analysis should stop.  */</span>
<a name="l01353"></a>01353 
<a name="l01354"></a>01354 
<a name="l01355"></a>01355 <span class="comment">/* Simulate an &#39;enter SIZE&#39; instruction in STATE.  */</span>
<a name="l01356"></a>01356 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01357"></a>01357 m32c_pv_enter (<span class="keyword">struct</span> m32c_pv_state *state, <span class="keywordtype">int</span> size)
<a name="l01358"></a>01358 {
<a name="l01359"></a>01359   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (state-&gt;arch);
<a name="l01360"></a>01360 
<a name="l01361"></a>01361   <span class="comment">/* If simulating this store would require us to forget</span>
<a name="l01362"></a>01362 <span class="comment">     everything we know about the stack frame in the name of</span>
<a name="l01363"></a>01363 <span class="comment">     accuracy, it would be better to just quit now.  */</span>
<a name="l01364"></a>01364   <span class="keywordflow">if</span> (<a class="code" href="prologue-value_8c.html#af16f8e9cb043efd0a97c592f199d4aa7">pv_area_store_would_trash</a> (state-&gt;stack, state-&gt;sp))
<a name="l01365"></a>01365     <span class="keywordflow">return</span> 1;
<a name="l01366"></a>01366 
<a name="l01367"></a>01367   <span class="keywordflow">if</span> (m32c_pv_push (state, state-&gt;fb, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad29113ae8f09cddcf6315fed264d9490">push_addr_bytes</a>))
<a name="l01368"></a>01368     <span class="keywordflow">return</span> 1;
<a name="l01369"></a>01369   state-&gt;fb = state-&gt;sp;
<a name="l01370"></a>01370   state-&gt;sp = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (state-&gt;sp, -size);
<a name="l01371"></a>01371 
<a name="l01372"></a>01372   <span class="keywordflow">return</span> 0;
<a name="l01373"></a>01373 }
<a name="l01374"></a>01374 
<a name="l01375"></a>01375 
<a name="l01376"></a>01376 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01377"></a>01377 m32c_pv_pushm_one (<span class="keyword">struct</span> m32c_pv_state *state, <a class="code" href="structprologue__value.html">pv_t</a> reg,
<a name="l01378"></a>01378                    <span class="keywordtype">int</span> <a class="code" href="arm-tdep_8c.html#a593c013b6ba3f27fd749b3d831fc53e9">bit</a>, <span class="keywordtype">int</span> src, <span class="keywordtype">int</span> size)
<a name="l01379"></a>01379 {
<a name="l01380"></a>01380   <span class="keywordflow">if</span> (bit &amp; src)
<a name="l01381"></a>01381     {
<a name="l01382"></a>01382       <span class="keywordflow">if</span> (m32c_pv_push (state, reg, size))
<a name="l01383"></a>01383         <span class="keywordflow">return</span> 1;
<a name="l01384"></a>01384     }
<a name="l01385"></a>01385 
<a name="l01386"></a>01386   <span class="keywordflow">return</span> 0;
<a name="l01387"></a>01387 }
<a name="l01388"></a>01388 
<a name="l01389"></a>01389 
<a name="l01390"></a>01390 <span class="comment">/* Simulate a &#39;pushm SRC&#39; instruction in STATE.  */</span>
<a name="l01391"></a>01391 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01392"></a>01392 m32c_pv_pushm (<span class="keyword">struct</span> m32c_pv_state *state, <span class="keywordtype">int</span> src)
<a name="l01393"></a>01393 {
<a name="l01394"></a>01394   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (state-&gt;arch);
<a name="l01395"></a>01395 
<a name="l01396"></a>01396   <span class="comment">/* The bits in SRC indicating which registers to save are:</span>
<a name="l01397"></a>01397 <span class="comment">     r0 r1 r2 r3 a0 a1 sb fb */</span>
<a name="l01398"></a>01398   <span class="keywordflow">return</span>
<a name="l01399"></a>01399     (   m32c_pv_pushm_one (state, state-&gt;fb, 0x01, src, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad29113ae8f09cddcf6315fed264d9490">push_addr_bytes</a>)
<a name="l01400"></a>01400      || m32c_pv_pushm_one (state, state-&gt;sb, 0x02, src, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad29113ae8f09cddcf6315fed264d9490">push_addr_bytes</a>)
<a name="l01401"></a>01401      || m32c_pv_pushm_one (state, state-&gt;a1, 0x04, src, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad29113ae8f09cddcf6315fed264d9490">push_addr_bytes</a>)
<a name="l01402"></a>01402      || m32c_pv_pushm_one (state, state-&gt;a0, 0x08, src, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad29113ae8f09cddcf6315fed264d9490">push_addr_bytes</a>)
<a name="l01403"></a>01403      || m32c_pv_pushm_one (state, state-&gt;r3, 0x10, src, 2)
<a name="l01404"></a>01404      || m32c_pv_pushm_one (state, state-&gt;r2, 0x20, src, 2)
<a name="l01405"></a>01405      || m32c_pv_pushm_one (state, state-&gt;r1, 0x40, src, 2)
<a name="l01406"></a>01406      || m32c_pv_pushm_one (state, state-&gt;r0, 0x80, src, 2));
<a name="l01407"></a>01407 }
<a name="l01408"></a>01408 
<a name="l01409"></a>01409 <span class="comment">/* Return non-zero if VALUE is the first incoming argument register.  */</span>
<a name="l01410"></a>01410 
<a name="l01411"></a>01411 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01412"></a>01412 m32c_is_1st_arg_reg (<span class="keyword">struct</span> m32c_pv_state *state, <a class="code" href="structprologue__value.html">pv_t</a> value)
<a name="l01413"></a>01413 {
<a name="l01414"></a>01414   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (state-&gt;arch);
<a name="l01415"></a>01415   <span class="keywordflow">return</span> (value.<a class="code" href="structprologue__value.html#a6b52b744f67b02d26add61c3e6bf4e7f">kind</a> == pvk_register
<a name="l01416"></a>01416           &amp;&amp; (<a class="code" href="gdbarch_8c.html#a305465885963fbf0fb5a7543594a7bff">gdbarch_bfd_arch_info</a> (state-&gt;arch)-&gt;mach == bfd_mach_m16c
<a name="l01417"></a>01417               ? (value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a> == tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ac171978c5c32b113e6b6ab9a920f4edb">r1</a>-&gt;num)
<a name="l01418"></a>01418               : (value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a> == tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>-&gt;num))
<a name="l01419"></a>01419           &amp;&amp; value.<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a> == 0);
<a name="l01420"></a>01420 }
<a name="l01421"></a>01421 
<a name="l01422"></a>01422 <span class="comment">/* Return non-zero if VALUE is an incoming argument register.  */</span>
<a name="l01423"></a>01423 
<a name="l01424"></a>01424 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01425"></a>01425 m32c_is_arg_reg (<span class="keyword">struct</span> m32c_pv_state *state, <a class="code" href="structprologue__value.html">pv_t</a> value)
<a name="l01426"></a>01426 {
<a name="l01427"></a>01427   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (state-&gt;arch);
<a name="l01428"></a>01428   <span class="keywordflow">return</span> (value.<a class="code" href="structprologue__value.html#a6b52b744f67b02d26add61c3e6bf4e7f">kind</a> == pvk_register
<a name="l01429"></a>01429           &amp;&amp; (<a class="code" href="gdbarch_8c.html#a305465885963fbf0fb5a7543594a7bff">gdbarch_bfd_arch_info</a> (state-&gt;arch)-&gt;mach == bfd_mach_m16c
<a name="l01430"></a>01430               ? (value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a> == tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ac171978c5c32b113e6b6ab9a920f4edb">r1</a>-&gt;num || value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a> == tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ada3d7b322cd22af8c0e4da1c427113be">r2</a>-&gt;num)
<a name="l01431"></a>01431               : (value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a> == tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>-&gt;num))
<a name="l01432"></a>01432           &amp;&amp; value.<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a> == 0);
<a name="l01433"></a>01433 }
<a name="l01434"></a>01434 
<a name="l01435"></a>01435 <span class="comment">/* Return non-zero if a store of VALUE to LOC is probably spilling an</span>
<a name="l01436"></a>01436 <span class="comment">   argument register to its stack slot in STATE.  Such instructions</span>
<a name="l01437"></a>01437 <span class="comment">   should be included in the prologue, if possible.</span>
<a name="l01438"></a>01438 <span class="comment"></span>
<a name="l01439"></a>01439 <span class="comment">   The store is a spill if:</span>
<a name="l01440"></a>01440 <span class="comment">   - the value being stored is the original value of an argument register;</span>
<a name="l01441"></a>01441 <span class="comment">   - the value has not already been stored somewhere in STACK; and</span>
<a name="l01442"></a>01442 <span class="comment">   - LOC is a stack slot (e.g., a memory location whose address is</span>
<a name="l01443"></a>01443 <span class="comment">     relative to the original value of the SP).  */</span>
<a name="l01444"></a>01444 
<a name="l01445"></a>01445 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01446"></a>01446 m32c_is_arg_spill (<span class="keyword">struct</span> m32c_pv_state *st, 
<a name="l01447"></a>01447                    <span class="keyword">struct</span> srcdest loc, 
<a name="l01448"></a>01448                    <a class="code" href="structprologue__value.html">pv_t</a> value)
<a name="l01449"></a>01449 {
<a name="l01450"></a>01450   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (st-&gt;arch);
<a name="l01451"></a>01451 
<a name="l01452"></a>01452   <span class="keywordflow">return</span> (m32c_is_arg_reg (st, value)
<a name="l01453"></a>01453           &amp;&amp; loc.kind == srcdest_mem
<a name="l01454"></a>01454           &amp;&amp; <a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (loc.addr, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>-&gt;num)
<a name="l01455"></a>01455           &amp;&amp; ! <a class="code" href="prologue-value_8c.html#af2ee40cc8963d3782b9a8f95dc0ca7d0">pv_area_find_reg</a> (st-&gt;stack, st-&gt;arch, value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a>, 0));
<a name="l01456"></a>01456 }
<a name="l01457"></a>01457 
<a name="l01458"></a>01458 <span class="comment">/* Return non-zero if a store of VALUE to LOC is probably </span>
<a name="l01459"></a>01459 <span class="comment">   copying the struct return address into an address register</span>
<a name="l01460"></a>01460 <span class="comment">   for immediate use.  This is basically a &quot;spill&quot; into the</span>
<a name="l01461"></a>01461 <span class="comment">   address register, instead of onto the stack. </span>
<a name="l01462"></a>01462 <span class="comment"></span>
<a name="l01463"></a>01463 <span class="comment">   The prerequisites are:</span>
<a name="l01464"></a>01464 <span class="comment">   - value being stored is original value of the FIRST arg register;</span>
<a name="l01465"></a>01465 <span class="comment">   - value has not already been stored on stack; and</span>
<a name="l01466"></a>01466 <span class="comment">   - LOC is an address register (a0 or a1).  */</span>
<a name="l01467"></a>01467 
<a name="l01468"></a>01468 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01469"></a>01469 m32c_is_struct_return (<span class="keyword">struct</span> m32c_pv_state *st,
<a name="l01470"></a>01470                        <span class="keyword">struct</span> srcdest loc, 
<a name="l01471"></a>01471                        <a class="code" href="structprologue__value.html">pv_t</a> value)
<a name="l01472"></a>01472 {
<a name="l01473"></a>01473   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (st-&gt;arch);
<a name="l01474"></a>01474 
<a name="l01475"></a>01475   <span class="keywordflow">return</span> (m32c_is_1st_arg_reg (st, value)
<a name="l01476"></a>01476           &amp;&amp; !<a class="code" href="prologue-value_8c.html#af2ee40cc8963d3782b9a8f95dc0ca7d0">pv_area_find_reg</a> (st-&gt;stack, st-&gt;arch, value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a>, 0)
<a name="l01477"></a>01477           &amp;&amp; loc.kind == srcdest_reg
<a name="l01478"></a>01478           &amp;&amp; (<a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (*loc.reg, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#afe752e13d941f920e6dc32eb30ef4a87">a0</a>-&gt;num)
<a name="l01479"></a>01479               || <a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (*loc.reg, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a079b5a09de437a19c5e635c50bcef794">a1</a>-&gt;num)));
<a name="l01480"></a>01480 }
<a name="l01481"></a>01481 
<a name="l01482"></a>01482 <span class="comment">/* Return non-zero if a &#39;pushm&#39; saving the registers indicated by SRC</span>
<a name="l01483"></a>01483 <span class="comment">   was a register save:</span>
<a name="l01484"></a>01484 <span class="comment">   - all the named registers should have their original values, and</span>
<a name="l01485"></a>01485 <span class="comment">   - the stack pointer should be at a constant offset from the</span>
<a name="l01486"></a>01486 <span class="comment">     original stack pointer.  */</span>
<a name="l01487"></a>01487 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01488"></a>01488 m32c_pushm_is_reg_save (<span class="keyword">struct</span> m32c_pv_state *st, <span class="keywordtype">int</span> src)
<a name="l01489"></a>01489 {
<a name="l01490"></a>01490   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (st-&gt;arch);
<a name="l01491"></a>01491   <span class="comment">/* The bits in SRC indicating which registers to save are:</span>
<a name="l01492"></a>01492 <span class="comment">     r0 r1 r2 r3 a0 a1 sb fb */</span>
<a name="l01493"></a>01493   <span class="keywordflow">return</span>
<a name="l01494"></a>01494     (<a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (st-&gt;sp, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>-&gt;num)
<a name="l01495"></a>01495      &amp;&amp; (! (src &amp; 0x01) || <a class="code" href="prologue-value_8c.html#a2a8f42226ec88b80bd295476a6648df6">pv_is_register_k</a> (st-&gt;fb, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a584c527b4e94c7bf12610034878bd377">fb</a>-&gt;num, 0))
<a name="l01496"></a>01496      &amp;&amp; (! (src &amp; 0x02) || <a class="code" href="prologue-value_8c.html#a2a8f42226ec88b80bd295476a6648df6">pv_is_register_k</a> (st-&gt;sb, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a3a1da6409e72e5aa257543b183e2d0f1">sb</a>-&gt;num, 0))
<a name="l01497"></a>01497      &amp;&amp; (! (src &amp; 0x04) || <a class="code" href="prologue-value_8c.html#a2a8f42226ec88b80bd295476a6648df6">pv_is_register_k</a> (st-&gt;a1, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a079b5a09de437a19c5e635c50bcef794">a1</a>-&gt;num, 0))
<a name="l01498"></a>01498      &amp;&amp; (! (src &amp; 0x08) || <a class="code" href="prologue-value_8c.html#a2a8f42226ec88b80bd295476a6648df6">pv_is_register_k</a> (st-&gt;a0, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#afe752e13d941f920e6dc32eb30ef4a87">a0</a>-&gt;num, 0))
<a name="l01499"></a>01499      &amp;&amp; (! (src &amp; 0x10) || <a class="code" href="prologue-value_8c.html#a2a8f42226ec88b80bd295476a6648df6">pv_is_register_k</a> (st-&gt;r3, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6e38b2ae232e49034076dcdbc9e45518">r3</a>-&gt;num, 0))
<a name="l01500"></a>01500      &amp;&amp; (! (src &amp; 0x20) || <a class="code" href="prologue-value_8c.html#a2a8f42226ec88b80bd295476a6648df6">pv_is_register_k</a> (st-&gt;r2, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ada3d7b322cd22af8c0e4da1c427113be">r2</a>-&gt;num, 0))
<a name="l01501"></a>01501      &amp;&amp; (! (src &amp; 0x40) || <a class="code" href="prologue-value_8c.html#a2a8f42226ec88b80bd295476a6648df6">pv_is_register_k</a> (st-&gt;r1, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ac171978c5c32b113e6b6ab9a920f4edb">r1</a>-&gt;num, 0))
<a name="l01502"></a>01502      &amp;&amp; (! (src &amp; 0x80) || <a class="code" href="prologue-value_8c.html#a2a8f42226ec88b80bd295476a6648df6">pv_is_register_k</a> (st-&gt;r0, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>-&gt;num, 0)));
<a name="l01503"></a>01503 }
<a name="l01504"></a>01504 
<a name="l01505"></a>01505 
<a name="l01506"></a>01506 <span class="comment">/* Function for finding saved registers in a &#39;struct pv_area&#39;; we pass</span>
<a name="l01507"></a>01507 <span class="comment">   this to pv_area_scan.</span>
<a name="l01508"></a>01508 <span class="comment"></span>
<a name="l01509"></a>01509 <span class="comment">   If VALUE is a saved register, ADDR says it was saved at a constant</span>
<a name="l01510"></a>01510 <span class="comment">   offset from the frame base, and SIZE indicates that the whole</span>
<a name="l01511"></a>01511 <span class="comment">   register was saved, record its offset in RESULT_UNTYPED.  */</span>
<a name="l01512"></a>01512 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01513"></a>01513 check_for_saved (<span class="keywordtype">void</span> *prologue_untyped, <a class="code" href="structprologue__value.html">pv_t</a> addr, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> size, <a class="code" href="structprologue__value.html">pv_t</a> value)
<a name="l01514"></a>01514 {
<a name="l01515"></a>01515   <span class="keyword">struct </span>m32c_prologue *prologue = (<span class="keyword">struct </span>m32c_prologue *) prologue_untyped;
<a name="l01516"></a>01516   <span class="keyword">struct </span>gdbarch *arch = prologue-&gt;arch;
<a name="l01517"></a>01517   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (arch);
<a name="l01518"></a>01518 
<a name="l01519"></a>01519   <span class="comment">/* Is this the unchanged value of some register being saved on the</span>
<a name="l01520"></a>01520 <span class="comment">     stack?  */</span>
<a name="l01521"></a>01521   <span class="keywordflow">if</span> (value.<a class="code" href="structprologue__value.html#a6b52b744f67b02d26add61c3e6bf4e7f">kind</a> == pvk_register
<a name="l01522"></a>01522       &amp;&amp; value.<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a> == 0
<a name="l01523"></a>01523       &amp;&amp; <a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (addr, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>-&gt;num))
<a name="l01524"></a>01524     {
<a name="l01525"></a>01525       <span class="comment">/* Some registers require special handling: they&#39;re saved as a</span>
<a name="l01526"></a>01526 <span class="comment">         larger value than the register itself.  */</span>
<a name="l01527"></a>01527       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> saved_size = <a class="code" href="regcache_8c.html#a4c51fa25edb9ce25451b9dc7bd127aac">register_size</a> (arch, value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a>);
<a name="l01528"></a>01528 
<a name="l01529"></a>01529       <span class="keywordflow">if</span> (value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a> == tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ab7a207d4e85b564c48238283745247b8">pc</a>-&gt;num)
<a name="l01530"></a>01530         saved_size = tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4de8ed7c35aeafdd12cb430033dcdebc">ret_addr_bytes</a>;
<a name="l01531"></a>01531       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="regcache_8c.html#a90aec5037b097c4b81dbe63b54f95e96">register_type</a> (arch, value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a>)
<a name="l01532"></a>01532                == tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a77153c59067bc16f74c30f814f855b87">data_addr_reg_type</a>)
<a name="l01533"></a>01533         saved_size = tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ad29113ae8f09cddcf6315fed264d9490">push_addr_bytes</a>;
<a name="l01534"></a>01534 
<a name="l01535"></a>01535       <span class="keywordflow">if</span> (size == saved_size)
<a name="l01536"></a>01536         {
<a name="l01537"></a>01537           <span class="comment">/* Find which end of the saved value corresponds to our</span>
<a name="l01538"></a>01538 <span class="comment">             register.  */</span>
<a name="l01539"></a>01539           <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (arch) == BFD_ENDIAN_BIG)
<a name="l01540"></a>01540             prologue-&gt;reg_offset[value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a>]
<a name="l01541"></a>01541               = (addr.<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a> + saved_size - <a class="code" href="regcache_8c.html#a4c51fa25edb9ce25451b9dc7bd127aac">register_size</a> (arch, value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a>));
<a name="l01542"></a>01542           <span class="keywordflow">else</span>
<a name="l01543"></a>01543             prologue-&gt;reg_offset[value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a>] = addr.<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a>;
<a name="l01544"></a>01544         }
<a name="l01545"></a>01545     }
<a name="l01546"></a>01546 }
<a name="l01547"></a>01547 
<a name="l01548"></a>01548 
<a name="l01549"></a>01549 <span class="comment">/* Analyze the function prologue for ARCH at START, going no further</span>
<a name="l01550"></a>01550 <span class="comment">   than LIMIT, and place a description of what we found in</span>
<a name="l01551"></a>01551 <span class="comment">   PROLOGUE.  */</span>
<a name="l01552"></a>01552 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01553"></a>01553 m32c_analyze_prologue (<span class="keyword">struct</span> gdbarch *arch,
<a name="l01554"></a>01554                        <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> limit,
<a name="l01555"></a>01555                        <span class="keyword">struct</span> m32c_prologue *prologue)
<a name="l01556"></a>01556 {
<a name="l01557"></a>01557   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (arch);
<a name="l01558"></a>01558   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mach = <a class="code" href="gdbarch_8c.html#a305465885963fbf0fb5a7543594a7bff">gdbarch_bfd_arch_info</a> (arch)-&gt;mach;
<a name="l01559"></a>01559   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> after_last_frame_related_insn;
<a name="l01560"></a>01560   <span class="keyword">struct </span>cleanup *back_to;
<a name="l01561"></a>01561   <span class="keyword">struct </span>m32c_pv_state st;
<a name="l01562"></a>01562 
<a name="l01563"></a>01563   st.arch = arch;
<a name="l01564"></a>01564   st.r0 = <a class="code" href="prologue-value_8c.html#a34b5d4a01cdf3fdb23cc9b69a407acc2">pv_register</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>-&gt;num, 0);
<a name="l01565"></a>01565   st.r1 = <a class="code" href="prologue-value_8c.html#a34b5d4a01cdf3fdb23cc9b69a407acc2">pv_register</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ac171978c5c32b113e6b6ab9a920f4edb">r1</a>-&gt;num, 0);
<a name="l01566"></a>01566   st.r2 = <a class="code" href="prologue-value_8c.html#a34b5d4a01cdf3fdb23cc9b69a407acc2">pv_register</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ada3d7b322cd22af8c0e4da1c427113be">r2</a>-&gt;num, 0);
<a name="l01567"></a>01567   st.r3 = <a class="code" href="prologue-value_8c.html#a34b5d4a01cdf3fdb23cc9b69a407acc2">pv_register</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6e38b2ae232e49034076dcdbc9e45518">r3</a>-&gt;num, 0);
<a name="l01568"></a>01568   st.a0 = <a class="code" href="prologue-value_8c.html#a34b5d4a01cdf3fdb23cc9b69a407acc2">pv_register</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#afe752e13d941f920e6dc32eb30ef4a87">a0</a>-&gt;num, 0);
<a name="l01569"></a>01569   st.a1 = <a class="code" href="prologue-value_8c.html#a34b5d4a01cdf3fdb23cc9b69a407acc2">pv_register</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a079b5a09de437a19c5e635c50bcef794">a1</a>-&gt;num, 0);
<a name="l01570"></a>01570   st.sb = <a class="code" href="prologue-value_8c.html#a34b5d4a01cdf3fdb23cc9b69a407acc2">pv_register</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a3a1da6409e72e5aa257543b183e2d0f1">sb</a>-&gt;num, 0);
<a name="l01571"></a>01571   st.fb = <a class="code" href="prologue-value_8c.html#a34b5d4a01cdf3fdb23cc9b69a407acc2">pv_register</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a584c527b4e94c7bf12610034878bd377">fb</a>-&gt;num, 0);
<a name="l01572"></a>01572   st.sp = <a class="code" href="prologue-value_8c.html#a34b5d4a01cdf3fdb23cc9b69a407acc2">pv_register</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>-&gt;num, 0);
<a name="l01573"></a>01573   st.pc = <a class="code" href="prologue-value_8c.html#a34b5d4a01cdf3fdb23cc9b69a407acc2">pv_register</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ab7a207d4e85b564c48238283745247b8">pc</a>-&gt;num, 0);
<a name="l01574"></a>01574   st.stack = <a class="code" href="prologue-value_8c.html#a962e98d46aef2ed10288f8ae28b713f0">make_pv_area</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>-&gt;num, <a class="code" href="gdbarch_8c.html#a3ee335ac98782b6633ab7fc235182cc9">gdbarch_addr_bit</a> (arch));
<a name="l01575"></a>01575   back_to = <a class="code" href="prologue-value_8c.html#aa46c9e6e63a97230bb9be62b15d2cb96">make_cleanup_free_pv_area</a> (st.stack);
<a name="l01576"></a>01576 
<a name="l01577"></a>01577   <span class="comment">/* Record that the call instruction has saved the return address on</span>
<a name="l01578"></a>01578 <span class="comment">     the stack.  */</span>
<a name="l01579"></a>01579   m32c_pv_push (&amp;st, st.pc, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4de8ed7c35aeafdd12cb430033dcdebc">ret_addr_bytes</a>);
<a name="l01580"></a>01580 
<a name="l01581"></a>01581   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (prologue, 0, <span class="keyword">sizeof</span> (*prologue));
<a name="l01582"></a>01582   prologue-&gt;arch = arch;
<a name="l01583"></a>01583   {
<a name="l01584"></a>01584     <span class="keywordtype">int</span> i;
<a name="l01585"></a>01585     <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="m32c-tdep_8c.html#a861d6bfdd85412bd19ecb0df0742277c">M32C_MAX_NUM_REGS</a>; i++)
<a name="l01586"></a>01586       prologue-&gt;reg_offset[i] = 1;
<a name="l01587"></a>01587   }
<a name="l01588"></a>01588 
<a name="l01589"></a>01589   st.scan_pc = after_last_frame_related_insn = start;
<a name="l01590"></a>01590 
<a name="l01591"></a>01591   <span class="keywordflow">while</span> (st.scan_pc &lt; limit)
<a name="l01592"></a>01592     {
<a name="l01593"></a>01593       <a class="code" href="structprologue__value.html">pv_t</a> pre_insn_fb = st.fb;
<a name="l01594"></a>01594       <a class="code" href="structprologue__value.html">pv_t</a> pre_insn_sp = st.sp;
<a name="l01595"></a>01595 
<a name="l01596"></a>01596       <span class="comment">/* In theory we could get in trouble by trying to read ahead</span>
<a name="l01597"></a>01597 <span class="comment">         here, when we only know we&#39;re expecting one byte.  In</span>
<a name="l01598"></a>01598 <span class="comment">         practice I doubt anyone will care, and it makes the rest of</span>
<a name="l01599"></a>01599 <span class="comment">         the code easier.  */</span>
<a name="l01600"></a>01600       <span class="keywordflow">if</span> (<a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (st.scan_pc, st.insn, sizeof (st.insn)))
<a name="l01601"></a>01601         <span class="comment">/* If we can&#39;t fetch the instruction from memory, stop here</span>
<a name="l01602"></a>01602 <span class="comment">           and hope for the best.  */</span>
<a name="l01603"></a>01603         <span class="keywordflow">break</span>;
<a name="l01604"></a>01604       st.next_addr = st.scan_pc;
<a name="l01605"></a>01605 
<a name="l01606"></a>01606       <span class="comment">/* The assembly instructions are written as they appear in the</span>
<a name="l01607"></a>01607 <span class="comment">         section of the processor manuals that describe the</span>
<a name="l01608"></a>01608 <span class="comment">         instruction encodings.</span>
<a name="l01609"></a>01609 <span class="comment"></span>
<a name="l01610"></a>01610 <span class="comment">         When a single assembly language instruction has several</span>
<a name="l01611"></a>01611 <span class="comment">         different machine-language encodings, the manual</span>
<a name="l01612"></a>01612 <span class="comment">         distinguishes them by a number in parens, before the</span>
<a name="l01613"></a>01613 <span class="comment">         mnemonic.  Those numbers are included, as well.</span>
<a name="l01614"></a>01614 <span class="comment"></span>
<a name="l01615"></a>01615 <span class="comment">         The srcdest decoding instructions have the same names as the</span>
<a name="l01616"></a>01616 <span class="comment">         analogous functions in the simulator.  */</span>
<a name="l01617"></a>01617       <span class="keywordflow">if</span> (mach == bfd_mach_m16c)
<a name="l01618"></a>01618         {
<a name="l01619"></a>01619           <span class="comment">/* (1) ENTER #imm8 */</span>
<a name="l01620"></a>01620           <span class="keywordflow">if</span> (st.insn[0] == 0x7c &amp;&amp; st.insn[1] == 0xf2)
<a name="l01621"></a>01621             {
<a name="l01622"></a>01622               <span class="keywordflow">if</span> (m32c_pv_enter (&amp;st, st.insn[2]))
<a name="l01623"></a>01623                 <span class="keywordflow">break</span>;
<a name="l01624"></a>01624               st.next_addr += 3;
<a name="l01625"></a>01625             }
<a name="l01626"></a>01626           <span class="comment">/* (1) PUSHM src */</span>
<a name="l01627"></a>01627           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (st.insn[0] == 0xec)
<a name="l01628"></a>01628             {
<a name="l01629"></a>01629               <span class="keywordtype">int</span> src = st.insn[1];
<a name="l01630"></a>01630               <span class="keywordflow">if</span> (m32c_pv_pushm (&amp;st, src))
<a name="l01631"></a>01631                 <span class="keywordflow">break</span>;
<a name="l01632"></a>01632               st.next_addr += 2;
<a name="l01633"></a>01633 
<a name="l01634"></a>01634               <span class="keywordflow">if</span> (m32c_pushm_is_reg_save (&amp;st, src))
<a name="l01635"></a>01635                 after_last_frame_related_insn = st.next_addr;
<a name="l01636"></a>01636             }
<a name="l01637"></a>01637 
<a name="l01638"></a>01638           <span class="comment">/* (6) MOV.size:G src, dest */</span>
<a name="l01639"></a>01639           <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((st.insn[0] &amp; 0xfe) == 0x72)
<a name="l01640"></a>01640             {
<a name="l01641"></a>01641               <span class="keywordtype">int</span> size = (st.insn[0] &amp; 0x01) ? 2 : 1;
<a name="l01642"></a>01642               <span class="keyword">struct </span>srcdest src;
<a name="l01643"></a>01643               <span class="keyword">struct </span>srcdest dest;
<a name="l01644"></a>01644               <a class="code" href="structprologue__value.html">pv_t</a> src_value;
<a name="l01645"></a>01645               st.next_addr += 2;
<a name="l01646"></a>01646 
<a name="l01647"></a>01647               src
<a name="l01648"></a>01648                 = m32c_decode_srcdest4 (&amp;st, (st.insn[1] &gt;&gt; 4) &amp; 0xf, size);
<a name="l01649"></a>01649               dest
<a name="l01650"></a>01650                 = m32c_decode_srcdest4 (&amp;st, st.insn[1] &amp; 0xf, size);
<a name="l01651"></a>01651               src_value = m32c_srcdest_fetch (&amp;st, src, size);
<a name="l01652"></a>01652 
<a name="l01653"></a>01653               <span class="keywordflow">if</span> (m32c_is_arg_spill (&amp;st, dest, src_value))
<a name="l01654"></a>01654                 after_last_frame_related_insn = st.next_addr;
<a name="l01655"></a>01655               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m32c_is_struct_return (&amp;st, dest, src_value))
<a name="l01656"></a>01656                 after_last_frame_related_insn = st.next_addr;
<a name="l01657"></a>01657 
<a name="l01658"></a>01658               <span class="keywordflow">if</span> (m32c_srcdest_store (&amp;st, dest, src_value, size))
<a name="l01659"></a>01659                 <span class="keywordflow">break</span>;
<a name="l01660"></a>01660             }
<a name="l01661"></a>01661 
<a name="l01662"></a>01662           <span class="comment">/* (1) LDC #IMM16, sp */</span>
<a name="l01663"></a>01663           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (st.insn[0] == 0xeb
<a name="l01664"></a>01664                    &amp;&amp; st.insn[1] == 0x50)
<a name="l01665"></a>01665             {
<a name="l01666"></a>01666               st.next_addr += 2;
<a name="l01667"></a>01667               st.sp = <a class="code" href="prologue-value_8c.html#a1d35dc4423d652ac8f7cbdfb94df117b">pv_constant</a> (m32c_udisp16 (&amp;st));
<a name="l01668"></a>01668             }
<a name="l01669"></a>01669 
<a name="l01670"></a>01670           <span class="keywordflow">else</span>
<a name="l01671"></a>01671             <span class="comment">/* We&#39;ve hit some instruction we don&#39;t know how to simulate.</span>
<a name="l01672"></a>01672 <span class="comment">               Strictly speaking, we should set every value we&#39;re</span>
<a name="l01673"></a>01673 <span class="comment">               tracking to &quot;unknown&quot;.  But we&#39;ll be optimistic, assume</span>
<a name="l01674"></a>01674 <span class="comment">               that we have enough information already, and stop</span>
<a name="l01675"></a>01675 <span class="comment">               analysis here.  */</span>
<a name="l01676"></a>01676             <span class="keywordflow">break</span>;
<a name="l01677"></a>01677         }
<a name="l01678"></a>01678       <span class="keywordflow">else</span>
<a name="l01679"></a>01679         {
<a name="l01680"></a>01680           <span class="keywordtype">int</span> src_indirect = 0;
<a name="l01681"></a>01681           <span class="keywordtype">int</span> dest_indirect = 0;
<a name="l01682"></a>01682           <span class="keywordtype">int</span> i = 0;
<a name="l01683"></a>01683 
<a name="l01684"></a>01684           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (mach == bfd_mach_m32c);
<a name="l01685"></a>01685 
<a name="l01686"></a>01686           <span class="comment">/* Check for prefix bytes indicating indirect addressing.  */</span>
<a name="l01687"></a>01687           <span class="keywordflow">if</span> (st.insn[0] == 0x41)
<a name="l01688"></a>01688             {
<a name="l01689"></a>01689               src_indirect = 1;
<a name="l01690"></a>01690               i++;
<a name="l01691"></a>01691             }
<a name="l01692"></a>01692           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (st.insn[0] == 0x09)
<a name="l01693"></a>01693             {
<a name="l01694"></a>01694               dest_indirect = 1;
<a name="l01695"></a>01695               i++;
<a name="l01696"></a>01696             }
<a name="l01697"></a>01697           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (st.insn[0] == 0x49)
<a name="l01698"></a>01698             {
<a name="l01699"></a>01699               src_indirect = dest_indirect = 1;
<a name="l01700"></a>01700               i++;
<a name="l01701"></a>01701             }
<a name="l01702"></a>01702 
<a name="l01703"></a>01703           <span class="comment">/* (1) ENTER #imm8 */</span>
<a name="l01704"></a>01704           <span class="keywordflow">if</span> (st.insn[i] == 0xec)
<a name="l01705"></a>01705             {
<a name="l01706"></a>01706               <span class="keywordflow">if</span> (m32c_pv_enter (&amp;st, st.insn[i + 1]))
<a name="l01707"></a>01707                 <span class="keywordflow">break</span>;
<a name="l01708"></a>01708               st.next_addr += 2;
<a name="l01709"></a>01709             }
<a name="l01710"></a>01710 
<a name="l01711"></a>01711           <span class="comment">/* (1) PUSHM src */</span>
<a name="l01712"></a>01712           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (st.insn[i] == 0x8f)
<a name="l01713"></a>01713             {
<a name="l01714"></a>01714               <span class="keywordtype">int</span> src = st.insn[i + 1];
<a name="l01715"></a>01715               <span class="keywordflow">if</span> (m32c_pv_pushm (&amp;st, src))
<a name="l01716"></a>01716                 <span class="keywordflow">break</span>;
<a name="l01717"></a>01717               st.next_addr += 2;
<a name="l01718"></a>01718 
<a name="l01719"></a>01719               <span class="keywordflow">if</span> (m32c_pushm_is_reg_save (&amp;st, src))
<a name="l01720"></a>01720                 after_last_frame_related_insn = st.next_addr;
<a name="l01721"></a>01721             }
<a name="l01722"></a>01722 
<a name="l01723"></a>01723           <span class="comment">/* (7) MOV.size:G src, dest */</span>
<a name="l01724"></a>01724           <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((st.insn[i] &amp; 0x80) == 0x80
<a name="l01725"></a>01725                    &amp;&amp; (st.insn[i + 1] &amp; 0x0f) == 0x0b
<a name="l01726"></a>01726                    &amp;&amp; m32c_get_src23 (&amp;st.insn[i]) &lt; 20
<a name="l01727"></a>01727                    &amp;&amp; m32c_get_dest23 (&amp;st.insn[i]) &lt; 20)
<a name="l01728"></a>01728             {
<a name="l01729"></a>01729               <span class="keyword">struct </span>srcdest src;
<a name="l01730"></a>01730               <span class="keyword">struct </span>srcdest dest;
<a name="l01731"></a>01731               <a class="code" href="structprologue__value.html">pv_t</a> src_value;
<a name="l01732"></a>01732               <span class="keywordtype">int</span> bw = st.insn[i] &amp; 0x01;
<a name="l01733"></a>01733               <span class="keywordtype">int</span> size = bw ? 2 : 1;
<a name="l01734"></a>01734               st.next_addr += 2;
<a name="l01735"></a>01735 
<a name="l01736"></a>01736               src
<a name="l01737"></a>01737                 = m32c_decode_sd23 (&amp;st, m32c_get_src23 (&amp;st.insn[i]),
<a name="l01738"></a>01738                                     size, src_indirect);
<a name="l01739"></a>01739               dest
<a name="l01740"></a>01740                 = m32c_decode_sd23 (&amp;st, m32c_get_dest23 (&amp;st.insn[i]),
<a name="l01741"></a>01741                                     size, dest_indirect);
<a name="l01742"></a>01742               src_value = m32c_srcdest_fetch (&amp;st, src, size);
<a name="l01743"></a>01743 
<a name="l01744"></a>01744               <span class="keywordflow">if</span> (m32c_is_arg_spill (&amp;st, dest, src_value))
<a name="l01745"></a>01745                 after_last_frame_related_insn = st.next_addr;
<a name="l01746"></a>01746 
<a name="l01747"></a>01747               <span class="keywordflow">if</span> (m32c_srcdest_store (&amp;st, dest, src_value, size))
<a name="l01748"></a>01748                 <span class="keywordflow">break</span>;
<a name="l01749"></a>01749             }
<a name="l01750"></a>01750           <span class="comment">/* (2) LDC #IMM24, sp */</span>
<a name="l01751"></a>01751           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (st.insn[i] == 0xd5
<a name="l01752"></a>01752                    &amp;&amp; st.insn[i + 1] == 0x29)
<a name="l01753"></a>01753             {
<a name="l01754"></a>01754               st.next_addr += 2;
<a name="l01755"></a>01755               st.sp = <a class="code" href="prologue-value_8c.html#a1d35dc4423d652ac8f7cbdfb94df117b">pv_constant</a> (m32c_udisp24 (&amp;st));
<a name="l01756"></a>01756             }
<a name="l01757"></a>01757           <span class="keywordflow">else</span>
<a name="l01758"></a>01758             <span class="comment">/* We&#39;ve hit some instruction we don&#39;t know how to simulate.</span>
<a name="l01759"></a>01759 <span class="comment">               Strictly speaking, we should set every value we&#39;re</span>
<a name="l01760"></a>01760 <span class="comment">               tracking to &quot;unknown&quot;.  But we&#39;ll be optimistic, assume</span>
<a name="l01761"></a>01761 <span class="comment">               that we have enough information already, and stop</span>
<a name="l01762"></a>01762 <span class="comment">               analysis here.  */</span>
<a name="l01763"></a>01763             <span class="keywordflow">break</span>;
<a name="l01764"></a>01764         }
<a name="l01765"></a>01765 
<a name="l01766"></a>01766       <span class="comment">/* If this instruction changed the FB or decreased the SP (i.e.,</span>
<a name="l01767"></a>01767 <span class="comment">         allocated more stack space), then this may be a good place to</span>
<a name="l01768"></a>01768 <span class="comment">         declare the prologue finished.  However, there are some</span>
<a name="l01769"></a>01769 <span class="comment">         exceptions:</span>
<a name="l01770"></a>01770 <span class="comment"></span>
<a name="l01771"></a>01771 <span class="comment">         - If the instruction just changed the FB back to its original</span>
<a name="l01772"></a>01772 <span class="comment">           value, then that&#39;s probably a restore instruction.  The</span>
<a name="l01773"></a>01773 <span class="comment">           prologue should definitely end before that.</span>
<a name="l01774"></a>01774 <span class="comment"></span>
<a name="l01775"></a>01775 <span class="comment">         - If the instruction increased the value of the SP (that is,</span>
<a name="l01776"></a>01776 <span class="comment">           shrunk the frame), then it&#39;s probably part of a frame</span>
<a name="l01777"></a>01777 <span class="comment">           teardown sequence, and the prologue should end before</span>
<a name="l01778"></a>01778 <span class="comment">           that.  */</span>
<a name="l01779"></a>01779 
<a name="l01780"></a>01780       <span class="keywordflow">if</span> (! <a class="code" href="prologue-value_8c.html#a3c9e13a6dc53cd468eb98e73968f52c9">pv_is_identical</a> (st.fb, pre_insn_fb))
<a name="l01781"></a>01781         {
<a name="l01782"></a>01782           <span class="keywordflow">if</span> (! <a class="code" href="prologue-value_8c.html#a2a8f42226ec88b80bd295476a6648df6">pv_is_register_k</a> (st.fb, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a584c527b4e94c7bf12610034878bd377">fb</a>-&gt;num, 0))
<a name="l01783"></a>01783             after_last_frame_related_insn = st.next_addr;
<a name="l01784"></a>01784         }
<a name="l01785"></a>01785       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (! <a class="code" href="prologue-value_8c.html#a3c9e13a6dc53cd468eb98e73968f52c9">pv_is_identical</a> (st.sp, pre_insn_sp))
<a name="l01786"></a>01786         {
<a name="l01787"></a>01787           <span class="comment">/* The comparison of the constants looks odd, there, because</span>
<a name="l01788"></a>01788 <span class="comment">             .k is unsigned.  All it really means is that the SP is</span>
<a name="l01789"></a>01789 <span class="comment">             lower than it was before the instruction.  */</span>
<a name="l01790"></a>01790           <span class="keywordflow">if</span> (   <a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (pre_insn_sp, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>-&gt;num)
<a name="l01791"></a>01791               &amp;&amp; <a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (st.sp,       tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>-&gt;num)
<a name="l01792"></a>01792               &amp;&amp; ((pre_insn_sp.<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a> - st.sp.k) &lt; (st.sp.k - pre_insn_sp.<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a>)))
<a name="l01793"></a>01793             after_last_frame_related_insn = st.next_addr;
<a name="l01794"></a>01794         }
<a name="l01795"></a>01795 
<a name="l01796"></a>01796       st.scan_pc = st.next_addr;
<a name="l01797"></a>01797     }
<a name="l01798"></a>01798 
<a name="l01799"></a>01799   <span class="comment">/* Did we load a constant value into the stack pointer?  */</span>
<a name="l01800"></a>01800   <span class="keywordflow">if</span> (<a class="code" href="prologue-value_8c.html#ae54ca4de092a4d35d4e583fb7fbd838c">pv_is_constant</a> (st.sp))
<a name="l01801"></a>01801     prologue-&gt;kind = prologue_first_frame;
<a name="l01802"></a>01802 
<a name="l01803"></a>01803   <span class="comment">/* Alternatively, did we initialize the frame pointer?  Remember</span>
<a name="l01804"></a>01804 <span class="comment">     that the CFA is the address after the return address.  */</span>
<a name="l01805"></a>01805   <span class="keywordflow">if</span> (<a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (st.fb, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>-&gt;num))
<a name="l01806"></a>01806     {
<a name="l01807"></a>01807       prologue-&gt;kind = prologue_with_frame_ptr;
<a name="l01808"></a>01808       prologue-&gt;frame_ptr_offset = st.fb.k;
<a name="l01809"></a>01809     }
<a name="l01810"></a>01810 
<a name="l01811"></a>01811   <span class="comment">/* Is the frame size a known constant?  Remember that frame_size is</span>
<a name="l01812"></a>01812 <span class="comment">     actually the offset from the CFA to the SP (i.e., a negative</span>
<a name="l01813"></a>01813 <span class="comment">     value).  */</span>
<a name="l01814"></a>01814   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (st.sp, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>-&gt;num))
<a name="l01815"></a>01815     {
<a name="l01816"></a>01816       prologue-&gt;kind = prologue_sans_frame_ptr;
<a name="l01817"></a>01817       prologue-&gt;frame_size = st.sp.k;
<a name="l01818"></a>01818     }
<a name="l01819"></a>01819 
<a name="l01820"></a>01820   <span class="comment">/* We haven&#39;t been able to make sense of this function&#39;s frame.  Treat</span>
<a name="l01821"></a>01821 <span class="comment">     it as the first frame.  */</span>
<a name="l01822"></a>01822   <span class="keywordflow">else</span>
<a name="l01823"></a>01823     prologue-&gt;kind = prologue_first_frame;
<a name="l01824"></a>01824 
<a name="l01825"></a>01825   <span class="comment">/* Record where all the registers were saved.  */</span>
<a name="l01826"></a>01826   <a class="code" href="prologue-value_8c.html#a4401a7a0b5fb6495e7db332f34e89db4">pv_area_scan</a> (st.stack, check_for_saved, (<span class="keywordtype">void</span> *) prologue);
<a name="l01827"></a>01827 
<a name="l01828"></a>01828   prologue-&gt;prologue_end = after_last_frame_related_insn;
<a name="l01829"></a>01829 
<a name="l01830"></a>01830   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l01831"></a>01831 }
<a name="l01832"></a>01832 
<a name="l01833"></a>01833 
<a name="l01834"></a>01834 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01835"></a>01835 m32c_skip_prologue (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ip)
<a name="l01836"></a>01836 {
<a name="l01837"></a>01837   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01838"></a>01838   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> func_addr, func_end, sal_end;
<a name="l01839"></a>01839   <span class="keyword">struct </span>m32c_prologue <a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>;
<a name="l01840"></a>01840 
<a name="l01841"></a>01841   <span class="comment">/* Try to find the extent of the function that contains IP.  */</span>
<a name="l01842"></a>01842   <span class="keywordflow">if</span> (! <a class="code" href="blockframe_8c.html#a2dae2257ad1417604d2c26f8b9071ca9">find_pc_partial_function</a> (ip, &amp;name, &amp;func_addr, &amp;func_end))
<a name="l01843"></a>01843     <span class="keywordflow">return</span> ip;
<a name="l01844"></a>01844 
<a name="l01845"></a>01845   <span class="comment">/* Find end by prologue analysis.  */</span>
<a name="l01846"></a>01846   m32c_analyze_prologue (gdbarch, ip, func_end, &amp;p);
<a name="l01847"></a>01847   <span class="comment">/* Find end by line info.  */</span>
<a name="l01848"></a>01848   sal_end = <a class="code" href="symtab_8c.html#a5e411a18b63476022fe4b9420138ae44">skip_prologue_using_sal</a> (gdbarch, ip);
<a name="l01849"></a>01849   <span class="comment">/* Return whichever is lower.  */</span>
<a name="l01850"></a>01850   <span class="keywordflow">if</span> (sal_end != 0 &amp;&amp; sal_end != ip &amp;&amp; sal_end &lt; <a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>.prologue_end)
<a name="l01851"></a>01851     <span class="keywordflow">return</span> sal_end;
<a name="l01852"></a>01852   <span class="keywordflow">else</span>
<a name="l01853"></a>01853     <span class="keywordflow">return</span> <a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>.prologue_end;
<a name="l01854"></a>01854 }
<a name="l01855"></a>01855 
<a name="l01856"></a>01856 
<a name="l01857"></a>01857 
<a name="l01858"></a>01858 <span class="comment">/* Stack unwinding.  */</span>
<a name="l01859"></a>01859 
<a name="l01860"></a>01860 <span class="keyword">static</span> <span class="keyword">struct </span>m32c_prologue *
<a name="l01861"></a>01861 m32c_analyze_frame_prologue (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01862"></a>01862                              <span class="keywordtype">void</span> **this_prologue_cache)
<a name="l01863"></a>01863 {
<a name="l01864"></a>01864   <span class="keywordflow">if</span> (! *this_prologue_cache)
<a name="l01865"></a>01865     {
<a name="l01866"></a>01866       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> func_start = <a class="code" href="frame_8c.html#ac64c0ce600cc134b2256c0d507f57cde">get_frame_func</a> (this_frame);
<a name="l01867"></a>01867       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> stop_addr = <a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a> (this_frame);
<a name="l01868"></a>01868 
<a name="l01869"></a>01869       <span class="comment">/* If we couldn&#39;t find any function containing the PC, then</span>
<a name="l01870"></a>01870 <span class="comment">         just initialize the prologue cache, but don&#39;t do anything.  */</span>
<a name="l01871"></a>01871       <span class="keywordflow">if</span> (! func_start)
<a name="l01872"></a>01872         stop_addr = func_start;
<a name="l01873"></a>01873 
<a name="l01874"></a>01874       *this_prologue_cache = <a class="code" href="frame_8h.html#af9f5c3008a0d58374aa310c5c63af552">FRAME_OBSTACK_ZALLOC</a> (<span class="keyword">struct</span> m32c_prologue);
<a name="l01875"></a>01875       m32c_analyze_prologue (<a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame),
<a name="l01876"></a>01876                              func_start, stop_addr, *this_prologue_cache);
<a name="l01877"></a>01877     }
<a name="l01878"></a>01878 
<a name="l01879"></a>01879   <span class="keywordflow">return</span> *this_prologue_cache;
<a name="l01880"></a>01880 }
<a name="l01881"></a>01881 
<a name="l01882"></a>01882 
<a name="l01883"></a>01883 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01884"></a>01884 m32c_frame_base (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01885"></a>01885                 <span class="keywordtype">void</span> **this_prologue_cache)
<a name="l01886"></a>01886 {
<a name="l01887"></a>01887   <span class="keyword">struct </span>m32c_prologue *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>
<a name="l01888"></a>01888     = m32c_analyze_frame_prologue (this_frame, this_prologue_cache);
<a name="l01889"></a>01889   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (<a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame));
<a name="l01890"></a>01890 
<a name="l01891"></a>01891   <span class="comment">/* In functions that use alloca, the distance between the stack</span>
<a name="l01892"></a>01892 <span class="comment">     pointer and the frame base varies dynamically, so we can&#39;t use</span>
<a name="l01893"></a>01893 <span class="comment">     the SP plus static information like prologue analysis to find the</span>
<a name="l01894"></a>01894 <span class="comment">     frame base.  However, such functions must have a frame pointer,</span>
<a name="l01895"></a>01895 <span class="comment">     to be able to restore the SP on exit.  So whenever we do have a</span>
<a name="l01896"></a>01896 <span class="comment">     frame pointer, use that to find the base.  */</span>
<a name="l01897"></a>01897   <span class="keywordflow">switch</span> (p-&gt;kind)
<a name="l01898"></a>01898     {
<a name="l01899"></a>01899     <span class="keywordflow">case</span> prologue_with_frame_ptr:
<a name="l01900"></a>01900       {
<a name="l01901"></a>01901         <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structgdbarch__tdep.html#a584c527b4e94c7bf12610034878bd377">fb</a>
<a name="l01902"></a>01902           = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a584c527b4e94c7bf12610034878bd377">fb</a>-&gt;num);
<a name="l01903"></a>01903         <span class="keywordflow">return</span> fb - p-&gt;frame_ptr_offset;
<a name="l01904"></a>01904       }
<a name="l01905"></a>01905 
<a name="l01906"></a>01906     <span class="keywordflow">case</span> prologue_sans_frame_ptr:
<a name="l01907"></a>01907       {
<a name="l01908"></a>01908         <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>
<a name="l01909"></a>01909           = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>-&gt;num);
<a name="l01910"></a>01910         <span class="keywordflow">return</span> sp - p-&gt;frame_size;
<a name="l01911"></a>01911       }
<a name="l01912"></a>01912 
<a name="l01913"></a>01913     <span class="keywordflow">case</span> prologue_first_frame:
<a name="l01914"></a>01914       <span class="keywordflow">return</span> 0;
<a name="l01915"></a>01915 
<a name="l01916"></a>01916     <span class="keywordflow">default</span>:
<a name="l01917"></a>01917       <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;unexpected prologue kind&quot;</span>);
<a name="l01918"></a>01918     }
<a name="l01919"></a>01919 }
<a name="l01920"></a>01920 
<a name="l01921"></a>01921 
<a name="l01922"></a>01922 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01923"></a>01923 m32c_this_id (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01924"></a>01924               <span class="keywordtype">void</span> **this_prologue_cache,
<a name="l01925"></a>01925               <span class="keyword">struct</span> <a class="code" href="structframe__id.html">frame_id</a> *this_id)
<a name="l01926"></a>01926 {
<a name="l01927"></a>01927   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> base = m32c_frame_base (this_frame, this_prologue_cache);
<a name="l01928"></a>01928 
<a name="l01929"></a>01929   <span class="keywordflow">if</span> (base)
<a name="l01930"></a>01930     *this_id = <a class="code" href="frame_8c.html#a7f32da6ddc275b4684c301448d891f5b">frame_id_build</a> (base, <a class="code" href="frame_8c.html#ac64c0ce600cc134b2256c0d507f57cde">get_frame_func</a> (this_frame));
<a name="l01931"></a>01931   <span class="comment">/* Otherwise, leave it unset, and that will terminate the backtrace.  */</span>
<a name="l01932"></a>01932 }
<a name="l01933"></a>01933 
<a name="l01934"></a>01934 
<a name="l01935"></a>01935 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l01936"></a>01936 m32c_prev_register (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01937"></a>01937                     <span class="keywordtype">void</span> **this_prologue_cache, <span class="keywordtype">int</span> regnum)
<a name="l01938"></a>01938 {
<a name="l01939"></a>01939   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (<a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame));
<a name="l01940"></a>01940   <span class="keyword">struct </span>m32c_prologue *p
<a name="l01941"></a>01941     = m32c_analyze_frame_prologue (this_frame, this_prologue_cache);
<a name="l01942"></a>01942   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structframe__base.html">frame_base</a> = m32c_frame_base (this_frame, this_prologue_cache);
<a name="l01943"></a>01943   <span class="keywordtype">int</span> reg_size = <a class="code" href="regcache_8c.html#a4c51fa25edb9ce25451b9dc7bd127aac">register_size</a> (<a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame), regnum);
<a name="l01944"></a>01944 
<a name="l01945"></a>01945   <span class="keywordflow">if</span> (regnum == tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>-&gt;num)
<a name="l01946"></a>01946     <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#ac7df103c9cdd8847accaa5752e4f52ea">frame_unwind_got_constant</a> (this_frame, regnum, frame_base);
<a name="l01947"></a>01947 
<a name="l01948"></a>01948   <span class="comment">/* If prologue analysis says we saved this register somewhere,</span>
<a name="l01949"></a>01949 <span class="comment">     return a description of the stack slot holding it.  */</span>
<a name="l01950"></a>01950   <span class="keywordflow">if</span> (p-&gt;reg_offset[regnum] != 1)
<a name="l01951"></a>01951     <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#ae7eed0715ca9ef71b626f80e3f026be9">frame_unwind_got_memory</a> (this_frame, regnum,
<a name="l01952"></a>01952                                     frame_base + p-&gt;reg_offset[regnum]);
<a name="l01953"></a>01953 
<a name="l01954"></a>01954   <span class="comment">/* Otherwise, presume we haven&#39;t changed the value of this</span>
<a name="l01955"></a>01955 <span class="comment">     register, and get it from the next frame.  */</span>
<a name="l01956"></a>01956   <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#a07784a5660795d4ca4bb82e05e0bc4f5">frame_unwind_got_register</a> (this_frame, regnum, regnum);
<a name="l01957"></a>01957 }
<a name="l01958"></a>01958 
<a name="l01959"></a>01959 
<a name="l01960"></a>01960 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structframe__unwind.html">frame_unwind</a> m32c_unwind = {
<a name="l01961"></a>01961   <a class="code" href="frame_8h.html#a3ca2c0bc7578bf3d337e34b2c08a6c5faeb4f7fd6d9e397d1141feb133746637a">NORMAL_FRAME</a>,
<a name="l01962"></a>01962   <a class="code" href="frame-unwind_8c.html#aa950afe60921514574c6150f0821f05c">default_frame_unwind_stop_reason</a>,
<a name="l01963"></a>01963   m32c_this_id,
<a name="l01964"></a>01964   m32c_prev_register,
<a name="l01965"></a>01965   NULL,
<a name="l01966"></a>01966   <a class="code" href="frame-unwind_8c.html#ade64a9807fa508622581cc779b10ff9c">default_frame_sniffer</a>
<a name="l01967"></a>01967 };
<a name="l01968"></a>01968 
<a name="l01969"></a>01969 
<a name="l01970"></a>01970 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01971"></a>01971 m32c_unwind_pc (<span class="keyword">struct</span> gdbarch *arch, <span class="keyword">struct</span> frame_info *next_frame)
<a name="l01972"></a>01972 {
<a name="l01973"></a>01973   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (arch);
<a name="l01974"></a>01974   <span class="keywordflow">return</span> <a class="code" href="frame_8c.html#a294f6912118884550787fd59f2a08ff6">frame_unwind_register_unsigned</a> (next_frame, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ab7a207d4e85b564c48238283745247b8">pc</a>-&gt;num);
<a name="l01975"></a>01975 }
<a name="l01976"></a>01976 
<a name="l01977"></a>01977 
<a name="l01978"></a>01978 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01979"></a>01979 m32c_unwind_sp (<span class="keyword">struct</span> gdbarch *arch, <span class="keyword">struct</span> frame_info *next_frame)
<a name="l01980"></a>01980 {
<a name="l01981"></a>01981   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (arch);
<a name="l01982"></a>01982   <span class="keywordflow">return</span> <a class="code" href="frame_8c.html#a294f6912118884550787fd59f2a08ff6">frame_unwind_register_unsigned</a> (next_frame, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>-&gt;num);
<a name="l01983"></a>01983 }
<a name="l01984"></a>01984 
<a name="l01985"></a>01985 
<a name="l01986"></a>01986 <span class="comment">/* Inferior calls.  */</span>
<a name="l01987"></a>01987 
<a name="l01988"></a>01988 <span class="comment">/* The calling conventions, according to GCC:</span>
<a name="l01989"></a>01989 <span class="comment"></span>
<a name="l01990"></a>01990 <span class="comment">   r8c, m16c</span>
<a name="l01991"></a>01991 <span class="comment">   ---------</span>
<a name="l01992"></a>01992 <span class="comment">   First arg may be passed in r1l or r1 if it (1) fits (QImode or</span>
<a name="l01993"></a>01993 <span class="comment">   HImode), (2) is named, and (3) is an integer or pointer type (no</span>
<a name="l01994"></a>01994 <span class="comment">   structs, floats, etc).  Otherwise, it&#39;s passed on the stack.</span>
<a name="l01995"></a>01995 <span class="comment"></span>
<a name="l01996"></a>01996 <span class="comment">   Second arg may be passed in r2, same restrictions (but not QImode),</span>
<a name="l01997"></a>01997 <span class="comment">   even if the first arg is passed on the stack.</span>
<a name="l01998"></a>01998 <span class="comment"></span>
<a name="l01999"></a>01999 <span class="comment">   Third and further args are passed on the stack.  No padding is</span>
<a name="l02000"></a>02000 <span class="comment">   used, stack &quot;alignment&quot; is 8 bits.</span>
<a name="l02001"></a>02001 <span class="comment"></span>
<a name="l02002"></a>02002 <span class="comment">   m32cm, m32c</span>
<a name="l02003"></a>02003 <span class="comment">   -----------</span>
<a name="l02004"></a>02004 <span class="comment"></span>
<a name="l02005"></a>02005 <span class="comment">   First arg may be passed in r0l or r0, same restrictions as above.</span>
<a name="l02006"></a>02006 <span class="comment"></span>
<a name="l02007"></a>02007 <span class="comment">   Second and further args are passed on the stack.  Padding is used</span>
<a name="l02008"></a>02008 <span class="comment">   after QImode parameters (i.e. lower-addressed byte is the value,</span>
<a name="l02009"></a>02009 <span class="comment">   higher-addressed byte is the padding), stack &quot;alignment&quot; is 16</span>
<a name="l02010"></a>02010 <span class="comment">   bits.  */</span>
<a name="l02011"></a>02011 
<a name="l02012"></a>02012 
<a name="l02013"></a>02013 <span class="comment">/* Return true if TYPE is a type that can be passed in registers.  (We</span>
<a name="l02014"></a>02014 <span class="comment">   ignore the size, and pay attention only to the type code;</span>
<a name="l02015"></a>02015 <span class="comment">   acceptable sizes depends on which register is being considered to</span>
<a name="l02016"></a>02016 <span class="comment">   hold it.)  */</span>
<a name="l02017"></a>02017 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02018"></a>02018 m32c_reg_arg_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>)
<a name="l02019"></a>02019 {
<a name="l02020"></a>02020   <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> code = <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type);
<a name="l02021"></a>02021 
<a name="l02022"></a>02022   <span class="keywordflow">return</span> (code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>
<a name="l02023"></a>02023           || code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>
<a name="l02024"></a>02024           || code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l02025"></a>02025           || code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>
<a name="l02026"></a>02026           || code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462afbf0aa0241df408e1017ae7ff8e6798c">TYPE_CODE_BOOL</a>
<a name="l02027"></a>02027           || code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae991dd7ea70631f3e1b67a1a75020b5f">TYPE_CODE_CHAR</a>);
<a name="l02028"></a>02028 }
<a name="l02029"></a>02029 
<a name="l02030"></a>02030 
<a name="l02031"></a>02031 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l02032"></a>02032 m32c_push_dummy_call (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> value *<span class="keyword">function</span>,
<a name="l02033"></a>02033                       <span class="keyword">struct</span> regcache *regcache, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> bp_addr, <span class="keywordtype">int</span> nargs,
<a name="l02034"></a>02034                       <span class="keyword">struct</span> value **args, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>, <span class="keywordtype">int</span> <a class="code" href="arm-tdep_8h.html#aabb639d85dec2f973451bb1e7b6d1be8">struct_return</a>,
<a name="l02035"></a>02035                       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> struct_addr)
<a name="l02036"></a>02036 {
<a name="l02037"></a>02037   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l02038"></a>02038   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l02039"></a>02039   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mach = <a class="code" href="gdbarch_8c.html#a305465885963fbf0fb5a7543594a7bff">gdbarch_bfd_arch_info</a> (gdbarch)-&gt;mach;
<a name="l02040"></a>02040   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> cfa;
<a name="l02041"></a>02041   <span class="keywordtype">int</span> i;
<a name="l02042"></a>02042 
<a name="l02043"></a>02043   <span class="comment">/* The number of arguments given in this function&#39;s prototype, or</span>
<a name="l02044"></a>02044 <span class="comment">     zero if it has a non-prototyped function type.  The m32c ABI</span>
<a name="l02045"></a>02045 <span class="comment">     passes arguments mentioned in the prototype differently from</span>
<a name="l02046"></a>02046 <span class="comment">     those in the ellipsis of a varargs function, or from those passed</span>
<a name="l02047"></a>02047 <span class="comment">     to a non-prototyped function.  */</span>
<a name="l02048"></a>02048   <span class="keywordtype">int</span> num_prototyped_args = 0;
<a name="l02049"></a>02049 
<a name="l02050"></a>02050   {
<a name="l02051"></a>02051     <span class="keyword">struct </span>type *<a class="code" href="structfunc__type.html">func_type</a> = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (<span class="keyword">function</span>);
<a name="l02052"></a>02052 
<a name="l02053"></a>02053     <span class="comment">/* Dereference function pointer types.  */</span>
<a name="l02054"></a>02054     <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (func_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l02055"></a>02055       func_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (func_type);
<a name="l02056"></a>02056 
<a name="l02057"></a>02057     <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (func_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a> ||
<a name="l02058"></a>02058                 <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (func_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a581771a1410949e8b505dd51426949e9">TYPE_CODE_METHOD</a>);
<a name="l02059"></a>02059 
<a name="l02060"></a>02060 <span class="preprocessor">#if 0</span>
<a name="l02061"></a>02061 <span class="preprocessor"></span>    <span class="comment">/* The ABI description in gcc/config/m32c/m32c.abi says that</span>
<a name="l02062"></a>02062 <span class="comment">       we need to handle prototyped and non-prototyped functions</span>
<a name="l02063"></a>02063 <span class="comment">       separately, but the code in GCC doesn&#39;t actually do so.  */</span>
<a name="l02064"></a>02064     <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a5d2347eac0eaeab1f00b01beaeb65d2d">TYPE_PROTOTYPED</a> (func_type))
<a name="l02065"></a>02065 <span class="preprocessor">#endif</span>
<a name="l02066"></a>02066 <span class="preprocessor"></span>      num_prototyped_args = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (func_type);
<a name="l02067"></a>02067   }
<a name="l02068"></a>02068 
<a name="l02069"></a>02069   <span class="comment">/* First, if the function returns an aggregate by value, push a</span>
<a name="l02070"></a>02070 <span class="comment">     pointer to a buffer for it.  This doesn&#39;t affect the way</span>
<a name="l02071"></a>02071 <span class="comment">     subsequent arguments are allocated to registers.  */</span>
<a name="l02072"></a>02072   <span class="keywordflow">if</span> (struct_return)
<a name="l02073"></a>02073     {
<a name="l02074"></a>02074       <span class="keywordtype">int</span> ptr_len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a30e8983da01ed9b3f643e74e6d9b5953">ptr_voyd</a>);
<a name="l02075"></a>02075       sp -= ptr_len;
<a name="l02076"></a>02076       <a class="code" href="corefile_8c.html#a5d984a6b6854bdefc717e88447000790">write_memory_unsigned_integer</a> (sp, ptr_len, byte_order, struct_addr);
<a name="l02077"></a>02077     }
<a name="l02078"></a>02078 
<a name="l02079"></a>02079   <span class="comment">/* Push the arguments.  */</span>
<a name="l02080"></a>02080   <span class="keywordflow">for</span> (i = nargs - 1; i &gt;= 0; i--)
<a name="l02081"></a>02081     {
<a name="l02082"></a>02082       <span class="keyword">struct </span>value *arg = args[i];
<a name="l02083"></a>02083       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *arg_bits = <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (arg);
<a name="l02084"></a>02084       <span class="keyword">struct </span>type *arg_type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg);
<a name="l02085"></a>02085       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> arg_size = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (arg_type);
<a name="l02086"></a>02086 
<a name="l02087"></a>02087       <span class="comment">/* Can it go in r1 or r1l (for m16c) or r0 or r0l (for m32c)?  */</span>
<a name="l02088"></a>02088       <span class="keywordflow">if</span> (i == 0
<a name="l02089"></a>02089           &amp;&amp; arg_size &lt;= 2
<a name="l02090"></a>02090           &amp;&amp; i &lt; num_prototyped_args
<a name="l02091"></a>02091           &amp;&amp; m32c_reg_arg_type (arg_type))
<a name="l02092"></a>02092         {
<a name="l02093"></a>02093           <span class="comment">/* Extract and re-store as an integer as a terse way to make</span>
<a name="l02094"></a>02094 <span class="comment">             sure it ends up in the least significant end of r1.  (GDB</span>
<a name="l02095"></a>02095 <span class="comment">             should avoid assuming endianness, even on uni-endian</span>
<a name="l02096"></a>02096 <span class="comment">             processors.)  */</span>
<a name="l02097"></a>02097           <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> u = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (arg_bits, arg_size,
<a name="l02098"></a>02098                                                  byte_order);
<a name="l02099"></a>02099           <span class="keyword">struct </span>m32c_reg *reg = (mach == bfd_mach_m16c) ? tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ac171978c5c32b113e6b6ab9a920f4edb">r1</a> : tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>;
<a name="l02100"></a>02100           <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a> (regcache, reg-&gt;num, u);
<a name="l02101"></a>02101         }
<a name="l02102"></a>02102 
<a name="l02103"></a>02103       <span class="comment">/* Can it go in r2?  */</span>
<a name="l02104"></a>02104       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mach == bfd_mach_m16c
<a name="l02105"></a>02105                &amp;&amp; i == 1
<a name="l02106"></a>02106                &amp;&amp; arg_size == 2
<a name="l02107"></a>02107                &amp;&amp; i &lt; num_prototyped_args
<a name="l02108"></a>02108                &amp;&amp; m32c_reg_arg_type (arg_type))
<a name="l02109"></a>02109         <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (regcache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ada3d7b322cd22af8c0e4da1c427113be">r2</a>-&gt;num, arg_bits);
<a name="l02110"></a>02110 
<a name="l02111"></a>02111       <span class="comment">/* Everything else goes on the stack.  */</span>
<a name="l02112"></a>02112       <span class="keywordflow">else</span>
<a name="l02113"></a>02113         {
<a name="l02114"></a>02114           sp -= arg_size;
<a name="l02115"></a>02115 
<a name="l02116"></a>02116           <span class="comment">/* Align the stack.  */</span>
<a name="l02117"></a>02117           <span class="keywordflow">if</span> (mach == bfd_mach_m32c)
<a name="l02118"></a>02118             sp &amp;= ~1;
<a name="l02119"></a>02119 
<a name="l02120"></a>02120           <a class="code" href="corefile_8c.html#a05c568c157071d9349667fab589228e5">write_memory</a> (sp, arg_bits, arg_size);
<a name="l02121"></a>02121         }
<a name="l02122"></a>02122     }
<a name="l02123"></a>02123 
<a name="l02124"></a>02124   <span class="comment">/* This is the CFA we use to identify the dummy frame.  */</span>
<a name="l02125"></a>02125   cfa = sp;
<a name="l02126"></a>02126 
<a name="l02127"></a>02127   <span class="comment">/* Push the return address.  */</span>
<a name="l02128"></a>02128   sp -= tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4de8ed7c35aeafdd12cb430033dcdebc">ret_addr_bytes</a>;
<a name="l02129"></a>02129   <a class="code" href="corefile_8c.html#a5d984a6b6854bdefc717e88447000790">write_memory_unsigned_integer</a> (sp, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4de8ed7c35aeafdd12cb430033dcdebc">ret_addr_bytes</a>, byte_order,
<a name="l02130"></a>02130                                  bp_addr);
<a name="l02131"></a>02131 
<a name="l02132"></a>02132   <span class="comment">/* Update the stack pointer.  */</span>
<a name="l02133"></a>02133   <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a> (regcache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>-&gt;num, sp);
<a name="l02134"></a>02134 
<a name="l02135"></a>02135   <span class="comment">/* We need to borrow an odd trick from the i386 target here.</span>
<a name="l02136"></a>02136 <span class="comment"></span>
<a name="l02137"></a>02137 <span class="comment">     The value we return from this function gets used as the stack</span>
<a name="l02138"></a>02138 <span class="comment">     address (the CFA) for the dummy frame&#39;s ID.  The obvious thing is</span>
<a name="l02139"></a>02139 <span class="comment">     to return the new TOS.  However, that points at the return</span>
<a name="l02140"></a>02140 <span class="comment">     address, saved on the stack, which is inconsistent with the CFA&#39;s</span>
<a name="l02141"></a>02141 <span class="comment">     described by GCC&#39;s DWARF 2 .debug_frame information: DWARF 2</span>
<a name="l02142"></a>02142 <span class="comment">     .debug_frame info uses the address immediately after the saved</span>
<a name="l02143"></a>02143 <span class="comment">     return address.  So you end up with a dummy frame whose CFA</span>
<a name="l02144"></a>02144 <span class="comment">     points at the return address, but the frame for the function</span>
<a name="l02145"></a>02145 <span class="comment">     being called has a CFA pointing after the return address: the</span>
<a name="l02146"></a>02146 <span class="comment">     younger CFA is *greater than* the older CFA.  The sanity checks</span>
<a name="l02147"></a>02147 <span class="comment">     in frame.c don&#39;t like that.</span>
<a name="l02148"></a>02148 <span class="comment"></span>
<a name="l02149"></a>02149 <span class="comment">     So we try to be consistent with the CFA&#39;s used by DWARF 2.</span>
<a name="l02150"></a>02150 <span class="comment">     Having a dummy frame and a real frame with the *same* CFA is</span>
<a name="l02151"></a>02151 <span class="comment">     tolerable.  */</span>
<a name="l02152"></a>02152   <span class="keywordflow">return</span> cfa;
<a name="l02153"></a>02153 }
<a name="l02154"></a>02154 
<a name="l02155"></a>02155 
<a name="l02156"></a>02156 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structframe__id.html">frame_id</a>
<a name="l02157"></a>02157 m32c_dummy_id (struct gdbarch *gdbarch, <span class="keyword">struct </span>frame_info *this_frame)
<a name="l02158"></a>02158 {
<a name="l02159"></a>02159   <span class="comment">/* This needs to return a frame ID whose PC is the return address</span>
<a name="l02160"></a>02160 <span class="comment">     passed to m32c_push_dummy_call, and whose stack_addr is the SP</span>
<a name="l02161"></a>02161 <span class="comment">     m32c_push_dummy_call returned.</span>
<a name="l02162"></a>02162 <span class="comment"></span>
<a name="l02163"></a>02163 <span class="comment">     m32c_unwind_sp gives us the CFA, which is the value the SP had</span>
<a name="l02164"></a>02164 <span class="comment">     before the return address was pushed.  */</span>
<a name="l02165"></a>02165   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l02166"></a>02166   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> sp = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>-&gt;num);
<a name="l02167"></a>02167   <span class="keywordflow">return</span> <a class="code" href="frame_8c.html#a7f32da6ddc275b4684c301448d891f5b">frame_id_build</a> (sp, <a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a> (this_frame));
<a name="l02168"></a>02168 }
<a name="l02169"></a>02169 
<a name="l02170"></a>02170 
<a name="l02171"></a>02171 
<a name="l02172"></a>02172 <span class="comment">/* Return values.  */</span>
<a name="l02173"></a>02173 
<a name="l02174"></a>02174 <span class="comment">/* Return value conventions, according to GCC:</span>
<a name="l02175"></a>02175 <span class="comment"></span>
<a name="l02176"></a>02176 <span class="comment">   r8c, m16c</span>
<a name="l02177"></a>02177 <span class="comment">   ---------</span>
<a name="l02178"></a>02178 <span class="comment"></span>
<a name="l02179"></a>02179 <span class="comment">   QImode in r0l</span>
<a name="l02180"></a>02180 <span class="comment">   HImode in r0</span>
<a name="l02181"></a>02181 <span class="comment">   SImode in r2r0</span>
<a name="l02182"></a>02182 <span class="comment">   near pointer in r0</span>
<a name="l02183"></a>02183 <span class="comment">   far pointer in r2r0</span>
<a name="l02184"></a>02184 <span class="comment"></span>
<a name="l02185"></a>02185 <span class="comment">   Aggregate values (regardless of size) are returned by pushing a</span>
<a name="l02186"></a>02186 <span class="comment">   pointer to a temporary area on the stack after the args are pushed.</span>
<a name="l02187"></a>02187 <span class="comment">   The function fills in this area with the value.  Note that this</span>
<a name="l02188"></a>02188 <span class="comment">   pointer on the stack does not affect how register arguments, if any,</span>
<a name="l02189"></a>02189 <span class="comment">   are configured.</span>
<a name="l02190"></a>02190 <span class="comment"></span>
<a name="l02191"></a>02191 <span class="comment">   m32cm, m32c</span>
<a name="l02192"></a>02192 <span class="comment">   -----------</span>
<a name="l02193"></a>02193 <span class="comment">   Same.  */</span>
<a name="l02194"></a>02194 
<a name="l02195"></a>02195 <span class="comment">/* Return non-zero if values of type TYPE are returned by storing them</span>
<a name="l02196"></a>02196 <span class="comment">   in a buffer whose address is passed on the stack, ahead of the</span>
<a name="l02197"></a>02197 <span class="comment">   other arguments.  */</span>
<a name="l02198"></a>02198 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02199"></a>02199 m32c_return_by_passed_buf (<span class="keyword">struct</span> type *type)
<a name="l02200"></a>02200 {
<a name="l02201"></a>02201   <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> code = <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type);
<a name="l02202"></a>02202 
<a name="l02203"></a>02203   <span class="keywordflow">return</span> (code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l02204"></a>02204           || code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>);
<a name="l02205"></a>02205 }
<a name="l02206"></a>02206 
<a name="l02207"></a>02207 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5">return_value_convention</a>
<a name="l02208"></a>02208 m32c_return_value (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l02209"></a>02209                    <span class="keyword">struct</span> value *<span class="keyword">function</span>,
<a name="l02210"></a>02210                    <span class="keyword">struct</span> type *valtype,
<a name="l02211"></a>02211                    <span class="keyword">struct</span> regcache *regcache,
<a name="l02212"></a>02212                    <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *readbuf,
<a name="l02213"></a>02213                    <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *writebuf)
<a name="l02214"></a>02214 {
<a name="l02215"></a>02215   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l02216"></a>02216   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l02217"></a>02217   <span class="keyword">enum</span> <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5">return_value_convention</a> conv;
<a name="l02218"></a>02218   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> valtype_len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (valtype);
<a name="l02219"></a>02219 
<a name="l02220"></a>02220   <span class="keywordflow">if</span> (m32c_return_by_passed_buf (valtype))
<a name="l02221"></a>02221     conv = <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5a1fab6a0bfd44af88ba17a143673dc937">RETURN_VALUE_STRUCT_CONVENTION</a>;
<a name="l02222"></a>02222   <span class="keywordflow">else</span>
<a name="l02223"></a>02223     conv = <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5a0cd14b7546740080384acc0c7e5caf3b">RETURN_VALUE_REGISTER_CONVENTION</a>;
<a name="l02224"></a>02224 
<a name="l02225"></a>02225   <span class="keywordflow">if</span> (readbuf)
<a name="l02226"></a>02226     {
<a name="l02227"></a>02227       <span class="comment">/* We should never be called to find values being returned by</span>
<a name="l02228"></a>02228 <span class="comment">         RETURN_VALUE_STRUCT_CONVENTION.  Those can&#39;t be located,</span>
<a name="l02229"></a>02229 <span class="comment">         unless we made the call ourselves.  */</span>
<a name="l02230"></a>02230       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (conv == <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5a0cd14b7546740080384acc0c7e5caf3b">RETURN_VALUE_REGISTER_CONVENTION</a>);
<a name="l02231"></a>02231 
<a name="l02232"></a>02232       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (valtype_len &lt;= 8);
<a name="l02233"></a>02233 
<a name="l02234"></a>02234       <span class="comment">/* Anything that fits in r0 is returned there.  */</span>
<a name="l02235"></a>02235       <span class="keywordflow">if</span> (valtype_len &lt;= <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>-&gt;type))
<a name="l02236"></a>02236         {
<a name="l02237"></a>02237           <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> u;
<a name="l02238"></a>02238           <a class="code" href="regcache_8c.html#a959a077d769de1641d4f9754cc7b4a1f">regcache_cooked_read_unsigned</a> (regcache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>-&gt;num, &amp;u);
<a name="l02239"></a>02239           <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (readbuf, valtype_len, byte_order, u);
<a name="l02240"></a>02240         }
<a name="l02241"></a>02241       <span class="keywordflow">else</span>
<a name="l02242"></a>02242         {
<a name="l02243"></a>02243           <span class="comment">/* Everything else is passed in mem0, using as many bytes as</span>
<a name="l02244"></a>02244 <span class="comment">             needed.  This is not what the Renesas tools do, but it&#39;s</span>
<a name="l02245"></a>02245 <span class="comment">             what GCC does at the moment.  */</span>
<a name="l02246"></a>02246           <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *mem0
<a name="l02247"></a>02247             = <a class="code" href="minsyms_8c.html#af87f7a894386515074ddd71365bc09b8">lookup_minimal_symbol</a> (<span class="stringliteral">&quot;mem0&quot;</span>, NULL, NULL);
<a name="l02248"></a>02248 
<a name="l02249"></a>02249           <span class="keywordflow">if</span> (! mem0)
<a name="l02250"></a>02250             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;The return value is stored in memory at &#39;mem0&#39;, &quot;</span>
<a name="l02251"></a>02251                      <span class="stringliteral">&quot;but GDB cannot find\n&quot;</span>
<a name="l02252"></a>02252                      <span class="stringliteral">&quot;its address.&quot;</span>));
<a name="l02253"></a>02253           <a class="code" href="corefile_8c.html#a5e0189c6f21f1c9321b379877183b819">read_memory</a> (<a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (mem0), readbuf, valtype_len);
<a name="l02254"></a>02254         }
<a name="l02255"></a>02255     }
<a name="l02256"></a>02256 
<a name="l02257"></a>02257   <span class="keywordflow">if</span> (writebuf)
<a name="l02258"></a>02258     {
<a name="l02259"></a>02259       <span class="comment">/* We should never be called to store values to be returned</span>
<a name="l02260"></a>02260 <span class="comment">         using RETURN_VALUE_STRUCT_CONVENTION.  We have no way of</span>
<a name="l02261"></a>02261 <span class="comment">         finding the buffer, unless we made the call ourselves.  */</span>
<a name="l02262"></a>02262       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (conv == <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5a0cd14b7546740080384acc0c7e5caf3b">RETURN_VALUE_REGISTER_CONVENTION</a>);
<a name="l02263"></a>02263 
<a name="l02264"></a>02264       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (valtype_len &lt;= 8);
<a name="l02265"></a>02265 
<a name="l02266"></a>02266       <span class="comment">/* Anything that fits in r0 is returned there.  */</span>
<a name="l02267"></a>02267       <span class="keywordflow">if</span> (valtype_len &lt;= <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>-&gt;type))
<a name="l02268"></a>02268         {
<a name="l02269"></a>02269           <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> u = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (writebuf, valtype_len,
<a name="l02270"></a>02270                                                  byte_order);
<a name="l02271"></a>02271           <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a> (regcache, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0f7e0e8d9013f2b05a58e7c907e462ac">r0</a>-&gt;num, u);
<a name="l02272"></a>02272         }
<a name="l02273"></a>02273       <span class="keywordflow">else</span>
<a name="l02274"></a>02274         {
<a name="l02275"></a>02275           <span class="comment">/* Everything else is passed in mem0, using as many bytes as</span>
<a name="l02276"></a>02276 <span class="comment">             needed.  This is not what the Renesas tools do, but it&#39;s</span>
<a name="l02277"></a>02277 <span class="comment">             what GCC does at the moment.  */</span>
<a name="l02278"></a>02278           <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *mem0
<a name="l02279"></a>02279             = <a class="code" href="minsyms_8c.html#af87f7a894386515074ddd71365bc09b8">lookup_minimal_symbol</a> (<span class="stringliteral">&quot;mem0&quot;</span>, NULL, NULL);
<a name="l02280"></a>02280 
<a name="l02281"></a>02281           <span class="keywordflow">if</span> (! mem0)
<a name="l02282"></a>02282             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;The return value is stored in memory at &#39;mem0&#39;, &quot;</span>
<a name="l02283"></a>02283                      <span class="stringliteral">&quot;but GDB cannot find\n&quot;</span>
<a name="l02284"></a>02284                      <span class="stringliteral">&quot; its address.&quot;</span>));
<a name="l02285"></a>02285           <a class="code" href="corefile_8c.html#a05c568c157071d9349667fab589228e5">write_memory</a> (<a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (mem0), writebuf, valtype_len);
<a name="l02286"></a>02286         }
<a name="l02287"></a>02287     }
<a name="l02288"></a>02288 
<a name="l02289"></a>02289   <span class="keywordflow">return</span> conv;
<a name="l02290"></a>02290 }
<a name="l02291"></a>02291 
<a name="l02292"></a>02292 
<a name="l02293"></a>02293 
<a name="l02294"></a>02294 <span class="comment">/* Trampolines.  */</span>
<a name="l02295"></a>02295 
<a name="l02296"></a>02296 <span class="comment">/* The m16c and m32c use a trampoline function for indirect function</span>
<a name="l02297"></a>02297 <span class="comment">   calls.  An indirect call looks like this:</span>
<a name="l02298"></a>02298 <span class="comment"></span>
<a name="l02299"></a>02299 <span class="comment">             ... push arguments ...</span>
<a name="l02300"></a>02300 <span class="comment">             ... push target function address ...</span>
<a name="l02301"></a>02301 <span class="comment">             jsr.a m32c_jsri16</span>
<a name="l02302"></a>02302 <span class="comment"></span>
<a name="l02303"></a>02303 <span class="comment">   The code for m32c_jsri16 looks like this:</span>
<a name="l02304"></a>02304 <span class="comment"></span>
<a name="l02305"></a>02305 <span class="comment">     m32c_jsri16:</span>
<a name="l02306"></a>02306 <span class="comment"></span>
<a name="l02307"></a>02307 <span class="comment">             # Save return address.</span>
<a name="l02308"></a>02308 <span class="comment">             pop.w      m32c_jsri_ret</span>
<a name="l02309"></a>02309 <span class="comment">             pop.b      m32c_jsri_ret+2</span>
<a name="l02310"></a>02310 <span class="comment"></span>
<a name="l02311"></a>02311 <span class="comment">             # Store target function address.</span>
<a name="l02312"></a>02312 <span class="comment">             pop.w      m32c_jsri_addr</span>
<a name="l02313"></a>02313 <span class="comment"></span>
<a name="l02314"></a>02314 <span class="comment">             # Re-push return address.</span>
<a name="l02315"></a>02315 <span class="comment">             push.b     m32c_jsri_ret+2</span>
<a name="l02316"></a>02316 <span class="comment">             push.w     m32c_jsri_ret</span>
<a name="l02317"></a>02317 <span class="comment"></span>
<a name="l02318"></a>02318 <span class="comment">             # Call the target function.</span>
<a name="l02319"></a>02319 <span class="comment">             jmpi.a     m32c_jsri_addr</span>
<a name="l02320"></a>02320 <span class="comment"></span>
<a name="l02321"></a>02321 <span class="comment">   Without further information, GDB will treat calls to m32c_jsri16</span>
<a name="l02322"></a>02322 <span class="comment">   like calls to any other function.  Since m32c_jsri16 doesn&#39;t have</span>
<a name="l02323"></a>02323 <span class="comment">   debugging information, that normally means that GDB sets a step-</span>
<a name="l02324"></a>02324 <span class="comment">   resume breakpoint and lets the program continue --- which is not</span>
<a name="l02325"></a>02325 <span class="comment">   what the user wanted.  (Giving the trampoline debugging info</span>
<a name="l02326"></a>02326 <span class="comment">   doesn&#39;t help: the user expects the program to stop in the function</span>
<a name="l02327"></a>02327 <span class="comment">   their program is calling, not in some trampoline code they&#39;ve never</span>
<a name="l02328"></a>02328 <span class="comment">   seen before.)</span>
<a name="l02329"></a>02329 <span class="comment"></span>
<a name="l02330"></a>02330 <span class="comment">   The gdbarch_skip_trampoline_code method tells GDB how to step</span>
<a name="l02331"></a>02331 <span class="comment">   through such trampoline functions transparently to the user.  When</span>
<a name="l02332"></a>02332 <span class="comment">   given the address of a trampoline function&#39;s first instruction,</span>
<a name="l02333"></a>02333 <span class="comment">   gdbarch_skip_trampoline_code should return the address of the first</span>
<a name="l02334"></a>02334 <span class="comment">   instruction of the function really being called.  If GDB decides it</span>
<a name="l02335"></a>02335 <span class="comment">   wants to step into that function, it will set a breakpoint there</span>
<a name="l02336"></a>02336 <span class="comment">   and silently continue to it.</span>
<a name="l02337"></a>02337 <span class="comment"></span>
<a name="l02338"></a>02338 <span class="comment">   We recognize the trampoline by name, and extract the target address</span>
<a name="l02339"></a>02339 <span class="comment">   directly from the stack.  This isn&#39;t great, but recognizing by its</span>
<a name="l02340"></a>02340 <span class="comment">   code sequence seems more fragile.  */</span>
<a name="l02341"></a>02341 
<a name="l02342"></a>02342 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l02343"></a>02343 m32c_skip_trampoline_code (<span class="keyword">struct</span> frame_info *frame, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="infcmd_8c.html#a2ccc36c43036951d612e70e909955a4c">stop_pc</a>)
<a name="l02344"></a>02344 {
<a name="l02345"></a>02345   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (frame);
<a name="l02346"></a>02346   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l02347"></a>02347   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l02348"></a>02348 
<a name="l02349"></a>02349   <span class="comment">/* It would be nicer to simply look up the addresses of known</span>
<a name="l02350"></a>02350 <span class="comment">     trampolines once, and then compare stop_pc with them.  However,</span>
<a name="l02351"></a>02351 <span class="comment">     we&#39;d need to ensure that that cached address got invalidated when</span>
<a name="l02352"></a>02352 <span class="comment">     someone loaded a new executable, and I&#39;m not quite sure of the</span>
<a name="l02353"></a>02353 <span class="comment">     best way to do that.  find_pc_partial_function does do some</span>
<a name="l02354"></a>02354 <span class="comment">     caching, so we&#39;ll see how this goes.  */</span>
<a name="l02355"></a>02355   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l02356"></a>02356   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start, end;
<a name="l02357"></a>02357 
<a name="l02358"></a>02358   <span class="keywordflow">if</span> (<a class="code" href="blockframe_8c.html#a2dae2257ad1417604d2c26f8b9071ca9">find_pc_partial_function</a> (stop_pc, &amp;name, &amp;start, &amp;end))
<a name="l02359"></a>02359     {
<a name="l02360"></a>02360       <span class="comment">/* Are we stopped at the beginning of the trampoline function?  */</span>
<a name="l02361"></a>02361       <span class="keywordflow">if</span> (strcmp (name, <span class="stringliteral">&quot;m32c_jsri16&quot;</span>) == 0
<a name="l02362"></a>02362           &amp;&amp; stop_pc == start)
<a name="l02363"></a>02363         {
<a name="l02364"></a>02364           <span class="comment">/* Get the stack pointer.  The return address is at the top,</span>
<a name="l02365"></a>02365 <span class="comment">             and the target function&#39;s address is just below that.  We</span>
<a name="l02366"></a>02366 <span class="comment">             know it&#39;s a two-byte address, since the trampoline is</span>
<a name="l02367"></a>02367 <span class="comment">             m32c_jsri*16*.  */</span>
<a name="l02368"></a>02368           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> sp = <a class="code" href="frame_8c.html#ae21020772c3938f6952da0e2595232a5">get_frame_sp</a> (<a class="code" href="frame_8c.html#a5ab254510728049878a232ed1b889820">get_current_frame</a> ());
<a name="l02369"></a>02369           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> target
<a name="l02370"></a>02370             = <a class="code" href="corefile_8c.html#a280cf81e766f60b30618ae3011f2cb07">read_memory_unsigned_integer</a> (sp + tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4de8ed7c35aeafdd12cb430033dcdebc">ret_addr_bytes</a>,
<a name="l02371"></a>02371                                             2, byte_order);
<a name="l02372"></a>02372 
<a name="l02373"></a>02373           <span class="comment">/* What we have now is the address of a jump instruction.</span>
<a name="l02374"></a>02374 <span class="comment">             What we need is the destination of that jump.</span>
<a name="l02375"></a>02375 <span class="comment">             The opcode is 1 byte, and the destination is the next 3 bytes.  */</span>
<a name="l02376"></a>02376 
<a name="l02377"></a>02377           target = <a class="code" href="corefile_8c.html#a280cf81e766f60b30618ae3011f2cb07">read_memory_unsigned_integer</a> (target + 1, 3, byte_order);
<a name="l02378"></a>02378           <span class="keywordflow">return</span> target;
<a name="l02379"></a>02379         }
<a name="l02380"></a>02380     }
<a name="l02381"></a>02381 
<a name="l02382"></a>02382   <span class="keywordflow">return</span> 0;
<a name="l02383"></a>02383 }
<a name="l02384"></a>02384 
<a name="l02385"></a>02385 
<a name="l02386"></a>02386 <span class="comment">/* Address/pointer conversions.  */</span>
<a name="l02387"></a>02387 
<a name="l02388"></a>02388 <span class="comment">/* On the m16c, there is a 24-bit address space, but only a very few</span>
<a name="l02389"></a>02389 <span class="comment">   instructions can generate addresses larger than 0xffff: jumps,</span>
<a name="l02390"></a>02390 <span class="comment">   jumps to subroutines, and the lde/std (load/store extended)</span>
<a name="l02391"></a>02391 <span class="comment">   instructions.</span>
<a name="l02392"></a>02392 <span class="comment"></span>
<a name="l02393"></a>02393 <span class="comment">   Since GCC can only support one size of pointer, we can&#39;t have</span>
<a name="l02394"></a>02394 <span class="comment">   distinct &#39;near&#39; and &#39;far&#39; pointer types; we have to pick one size</span>
<a name="l02395"></a>02395 <span class="comment">   for everything.  If we wanted to use 24-bit pointers, then GCC</span>
<a name="l02396"></a>02396 <span class="comment">   would have to use lde and ste for all memory references, which</span>
<a name="l02397"></a>02397 <span class="comment">   would be terrible for performance and code size.  So the GNU</span>
<a name="l02398"></a>02398 <span class="comment">   toolchain uses 16-bit pointers for everything, and gives up the</span>
<a name="l02399"></a>02399 <span class="comment">   ability to have pointers point outside the first 64k of memory.</span>
<a name="l02400"></a>02400 <span class="comment"></span>
<a name="l02401"></a>02401 <span class="comment">   However, as a special hack, we let the linker place functions at</span>
<a name="l02402"></a>02402 <span class="comment">   addresses above 0xffff, as long as it also places a trampoline in</span>
<a name="l02403"></a>02403 <span class="comment">   the low 64k for every function whose address is taken.  Each</span>
<a name="l02404"></a>02404 <span class="comment">   trampoline consists of a single jmp.a instruction that jumps to the</span>
<a name="l02405"></a>02405 <span class="comment">   function&#39;s real entry point.  Pointers to functions can be 16 bits</span>
<a name="l02406"></a>02406 <span class="comment">   long, even though the functions themselves are at higher addresses:</span>
<a name="l02407"></a>02407 <span class="comment">   the pointers refer to the trampolines, not the functions.</span>
<a name="l02408"></a>02408 <span class="comment"></span>
<a name="l02409"></a>02409 <span class="comment">   This complicates things for GDB, however: given the address of a</span>
<a name="l02410"></a>02410 <span class="comment">   function (from debug info or linker symbols, say) which could be</span>
<a name="l02411"></a>02411 <span class="comment">   anywhere in the 24-bit address space, how can we find an</span>
<a name="l02412"></a>02412 <span class="comment">   appropriate 16-bit value to use as a pointer to it?</span>
<a name="l02413"></a>02413 <span class="comment"></span>
<a name="l02414"></a>02414 <span class="comment">   If the linker has not generated a trampoline for the function,</span>
<a name="l02415"></a>02415 <span class="comment">   we&#39;re out of luck.  Well, I guess we could malloc some space and</span>
<a name="l02416"></a>02416 <span class="comment">   write a jmp.a instruction to it, but I&#39;m not going to get into that</span>
<a name="l02417"></a>02417 <span class="comment">   at the moment.</span>
<a name="l02418"></a>02418 <span class="comment"></span>
<a name="l02419"></a>02419 <span class="comment">   If the linker has generated a trampoline for the function, then it</span>
<a name="l02420"></a>02420 <span class="comment">   also emitted a symbol for the trampoline: if the function&#39;s linker</span>
<a name="l02421"></a>02421 <span class="comment">   symbol is named NAME, then the function&#39;s trampoline&#39;s linker</span>
<a name="l02422"></a>02422 <span class="comment">   symbol is named NAME.plt.</span>
<a name="l02423"></a>02423 <span class="comment"></span>
<a name="l02424"></a>02424 <span class="comment">   So, given a code address:</span>
<a name="l02425"></a>02425 <span class="comment">   - We try to find a linker symbol at that address.</span>
<a name="l02426"></a>02426 <span class="comment">   - If we find such a symbol named NAME, we look for a linker symbol</span>
<a name="l02427"></a>02427 <span class="comment">     named NAME.plt.</span>
<a name="l02428"></a>02428 <span class="comment">   - If we find such a symbol, we assume it is a trampoline, and use</span>
<a name="l02429"></a>02429 <span class="comment">     its address as the pointer value.</span>
<a name="l02430"></a>02430 <span class="comment"></span>
<a name="l02431"></a>02431 <span class="comment">   And, given a function pointer:</span>
<a name="l02432"></a>02432 <span class="comment">   - We try to find a linker symbol at that address named NAME.plt.</span>
<a name="l02433"></a>02433 <span class="comment">   - If we find such a symbol, we look for a linker symbol named NAME.</span>
<a name="l02434"></a>02434 <span class="comment">   - If we find that, we provide that as the function&#39;s address.</span>
<a name="l02435"></a>02435 <span class="comment">   - If any of the above steps fail, we return the original address</span>
<a name="l02436"></a>02436 <span class="comment">     unchanged; it might really be a function in the low 64k.</span>
<a name="l02437"></a>02437 <span class="comment"></span>
<a name="l02438"></a>02438 <span class="comment">   See?  You *knew* there was a reason you wanted to be a computer</span>
<a name="l02439"></a>02439 <span class="comment">   programmer!  :)  */</span>
<a name="l02440"></a>02440 
<a name="l02441"></a>02441 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02442"></a>02442 m32c_m16c_address_to_pointer (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l02443"></a>02443                               <span class="keyword">struct</span> type *type, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr)
<a name="l02444"></a>02444 {
<a name="l02445"></a>02445   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l02446"></a>02446   <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> target_code;
<a name="l02447"></a>02447   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a> ||
<a name="l02448"></a>02448               <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>);
<a name="l02449"></a>02449 
<a name="l02450"></a>02450   target_code = <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type));
<a name="l02451"></a>02451 
<a name="l02452"></a>02452   <span class="keywordflow">if</span> (target_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a> || target_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a581771a1410949e8b505dd51426949e9">TYPE_CODE_METHOD</a>)
<a name="l02453"></a>02453     {
<a name="l02454"></a>02454       <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name;
<a name="l02455"></a>02455       <span class="keywordtype">char</span> *tramp_name;
<a name="l02456"></a>02456       <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *tramp_msym;
<a name="l02457"></a>02457 
<a name="l02458"></a>02458       <span class="comment">/* Try to find a linker symbol at this address.  */</span>
<a name="l02459"></a>02459       <span class="keyword">struct </span><a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol</a> func_msym
<a name="l02460"></a>02460         = <a class="code" href="minsyms_8c.html#ad4b48b6ef6c913138a8ac33f8c3cfeb2">lookup_minimal_symbol_by_pc</a> (addr);
<a name="l02461"></a>02461 
<a name="l02462"></a>02462       <span class="keywordflow">if</span> (! func_msym.<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>)
<a name="l02463"></a>02463         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot convert code address %s to function pointer:\n&quot;</span>
<a name="l02464"></a>02464                <span class="stringliteral">&quot;couldn&#39;t find a symbol at that address, to find trampoline.&quot;</span>),
<a name="l02465"></a>02465                <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, addr));
<a name="l02466"></a>02466 
<a name="l02467"></a>02467       func_name = <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (func_msym.<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>);
<a name="l02468"></a>02468       tramp_name = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (strlen (func_name) + 5);
<a name="l02469"></a>02469       strcpy (tramp_name, func_name);
<a name="l02470"></a>02470       strcat (tramp_name, <span class="stringliteral">&quot;.plt&quot;</span>);
<a name="l02471"></a>02471 
<a name="l02472"></a>02472       <span class="comment">/* Try to find a linker symbol for the trampoline.  */</span>
<a name="l02473"></a>02473       tramp_msym = <a class="code" href="minsyms_8c.html#af87f7a894386515074ddd71365bc09b8">lookup_minimal_symbol</a> (tramp_name, NULL, NULL);
<a name="l02474"></a>02474 
<a name="l02475"></a>02475       <span class="comment">/* We&#39;ve either got another copy of the name now, or don&#39;t need</span>
<a name="l02476"></a>02476 <span class="comment">         the name any more.  */</span>
<a name="l02477"></a>02477       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (tramp_name);
<a name="l02478"></a>02478 
<a name="l02479"></a>02479       <span class="keywordflow">if</span> (! tramp_msym)
<a name="l02480"></a>02480         {
<a name="l02481"></a>02481           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ptrval;
<a name="l02482"></a>02482 
<a name="l02483"></a>02483           <span class="comment">/* No PLT entry found.  Mask off the upper bits of the address</span>
<a name="l02484"></a>02484 <span class="comment">             to make a pointer.  As noted in the warning to the user</span>
<a name="l02485"></a>02485 <span class="comment">             below, this value might be useful if converted back into</span>
<a name="l02486"></a>02486 <span class="comment">             an address by GDB, but will otherwise, almost certainly,</span>
<a name="l02487"></a>02487 <span class="comment">             be garbage.</span>
<a name="l02488"></a>02488 <span class="comment">             </span>
<a name="l02489"></a>02489 <span class="comment">             Using this masked result does seem to be useful</span>
<a name="l02490"></a>02490 <span class="comment">             in gdb.cp/cplusfuncs.exp in which ~40 FAILs turn into</span>
<a name="l02491"></a>02491 <span class="comment">             PASSes.  These results appear to be correct as well.</span>
<a name="l02492"></a>02492 <span class="comment">             </span>
<a name="l02493"></a>02493 <span class="comment">             We print a warning here so that the user can make a</span>
<a name="l02494"></a>02494 <span class="comment">             determination about whether the result is useful or not.  */</span>
<a name="l02495"></a>02495           ptrval = addr &amp; 0xffff;
<a name="l02496"></a>02496 
<a name="l02497"></a>02497           <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot convert code address %s to function pointer:\n&quot;</span>
<a name="l02498"></a>02498                    <span class="stringliteral">&quot;couldn&#39;t find trampoline named &#39;%s.plt&#39;.\n&quot;</span>
<a name="l02499"></a>02499                    <span class="stringliteral">&quot;Returning pointer value %s instead; this may produce\n&quot;</span>
<a name="l02500"></a>02500                    <span class="stringliteral">&quot;a useful result if converted back into an address by GDB,\n&quot;</span>
<a name="l02501"></a>02501                    <span class="stringliteral">&quot;but will most likely not be useful otherwise.\n&quot;</span>),
<a name="l02502"></a>02502                    <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, addr), func_name,
<a name="l02503"></a>02503                    <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, ptrval));
<a name="l02504"></a>02504 
<a name="l02505"></a>02505           addr = ptrval;
<a name="l02506"></a>02506 
<a name="l02507"></a>02507         }
<a name="l02508"></a>02508       <span class="keywordflow">else</span>
<a name="l02509"></a>02509         {
<a name="l02510"></a>02510           <span class="comment">/* The trampoline&#39;s address is our pointer.  */</span>
<a name="l02511"></a>02511           addr = <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (tramp_msym);
<a name="l02512"></a>02512         }
<a name="l02513"></a>02513     }
<a name="l02514"></a>02514 
<a name="l02515"></a>02515   <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (buf, <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type), byte_order, addr);
<a name="l02516"></a>02516 }
<a name="l02517"></a>02517 
<a name="l02518"></a>02518 
<a name="l02519"></a>02519 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l02520"></a>02520 m32c_m16c_pointer_to_address (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l02521"></a>02521                               <span class="keyword">struct</span> type *type, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l02522"></a>02522 {
<a name="l02523"></a>02523   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l02524"></a>02524   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ptr;
<a name="l02525"></a>02525   <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> target_code;
<a name="l02526"></a>02526 
<a name="l02527"></a>02527   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a> ||
<a name="l02528"></a>02528               <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>);
<a name="l02529"></a>02529 
<a name="l02530"></a>02530   ptr = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf, <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type), byte_order);
<a name="l02531"></a>02531 
<a name="l02532"></a>02532   target_code = <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type));
<a name="l02533"></a>02533 
<a name="l02534"></a>02534   <span class="keywordflow">if</span> (target_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a> || target_code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a581771a1410949e8b505dd51426949e9">TYPE_CODE_METHOD</a>)
<a name="l02535"></a>02535     {
<a name="l02536"></a>02536       <span class="comment">/* See if there is a minimal symbol at that address whose name is</span>
<a name="l02537"></a>02537 <span class="comment">         &quot;NAME.plt&quot;.  */</span>
<a name="l02538"></a>02538       <span class="keyword">struct </span><a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol</a> ptr_msym = <a class="code" href="minsyms_8c.html#ad4b48b6ef6c913138a8ac33f8c3cfeb2">lookup_minimal_symbol_by_pc</a> (ptr);
<a name="l02539"></a>02539 
<a name="l02540"></a>02540       <span class="keywordflow">if</span> (ptr_msym.<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>)
<a name="l02541"></a>02541         {
<a name="l02542"></a>02542           <span class="keyword">const</span> <span class="keywordtype">char</span> *ptr_msym_name = <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (ptr_msym.<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>);
<a name="l02543"></a>02543           <span class="keywordtype">int</span> len = strlen (ptr_msym_name);
<a name="l02544"></a>02544 
<a name="l02545"></a>02545           <span class="keywordflow">if</span> (len &gt; 4
<a name="l02546"></a>02546               &amp;&amp; strcmp (ptr_msym_name + len - 4, <span class="stringliteral">&quot;.plt&quot;</span>) == 0)
<a name="l02547"></a>02547             {
<a name="l02548"></a>02548               <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *func_msym;
<a name="l02549"></a>02549               <span class="comment">/* We have a .plt symbol; try to find the symbol for the</span>
<a name="l02550"></a>02550 <span class="comment">                 corresponding function.</span>
<a name="l02551"></a>02551 <span class="comment"></span>
<a name="l02552"></a>02552 <span class="comment">                 Since the trampoline contains a jump instruction, we</span>
<a name="l02553"></a>02553 <span class="comment">                 could also just extract the jump&#39;s target address.  I</span>
<a name="l02554"></a>02554 <span class="comment">                 don&#39;t see much advantage one way or the other.  */</span>
<a name="l02555"></a>02555               <span class="keywordtype">char</span> *func_name = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (len - 4 + 1);
<a name="l02556"></a>02556               <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (func_name, ptr_msym_name, len - 4);
<a name="l02557"></a>02557               func_name[len - 4] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l02558"></a>02558               func_msym
<a name="l02559"></a>02559                 = <a class="code" href="minsyms_8c.html#af87f7a894386515074ddd71365bc09b8">lookup_minimal_symbol</a> (func_name, NULL, NULL);
<a name="l02560"></a>02560 
<a name="l02561"></a>02561               <span class="comment">/* If we do have such a symbol, return its value as the</span>
<a name="l02562"></a>02562 <span class="comment">                 function&#39;s true address.  */</span>
<a name="l02563"></a>02563               <span class="keywordflow">if</span> (func_msym)
<a name="l02564"></a>02564                 ptr = <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (func_msym);
<a name="l02565"></a>02565             }
<a name="l02566"></a>02566         }
<a name="l02567"></a>02567       <span class="keywordflow">else</span>
<a name="l02568"></a>02568         {
<a name="l02569"></a>02569           <span class="keywordtype">int</span> aspace;
<a name="l02570"></a>02570 
<a name="l02571"></a>02571           <span class="keywordflow">for</span> (aspace = 1; aspace &lt;= 15; aspace++)
<a name="l02572"></a>02572             {
<a name="l02573"></a>02573               ptr_msym = <a class="code" href="minsyms_8c.html#ad4b48b6ef6c913138a8ac33f8c3cfeb2">lookup_minimal_symbol_by_pc</a> ((aspace &lt;&lt; 16) | ptr);
<a name="l02574"></a>02574               
<a name="l02575"></a>02575               <span class="keywordflow">if</span> (ptr_msym.<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a>)
<a name="l02576"></a>02576                 ptr |= aspace &lt;&lt; 16;
<a name="l02577"></a>02577             }
<a name="l02578"></a>02578         }
<a name="l02579"></a>02579     }
<a name="l02580"></a>02580 
<a name="l02581"></a>02581   <span class="keywordflow">return</span> ptr;
<a name="l02582"></a>02582 }
<a name="l02583"></a>02583 
<a name="l02584"></a>02584 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02585"></a>02585 m32c_virtual_frame_pointer (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc,
<a name="l02586"></a>02586                             <span class="keywordtype">int</span> *frame_regnum,
<a name="l02587"></a>02587                             <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *frame_offset)
<a name="l02588"></a>02588 {
<a name="l02589"></a>02589   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l02590"></a>02590   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> func_addr, func_end;
<a name="l02591"></a>02591   <span class="keyword">struct </span>m32c_prologue p;
<a name="l02592"></a>02592 
<a name="l02593"></a>02593   <span class="keyword">struct </span>regcache *regcache = <a class="code" href="regcache_8c.html#a09a386286dc22d882378f639630fecef">get_current_regcache</a> ();
<a name="l02594"></a>02594   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l02595"></a>02595   
<a name="l02596"></a>02596   <span class="keywordflow">if</span> (!<a class="code" href="blockframe_8c.html#a2dae2257ad1417604d2c26f8b9071ca9">find_pc_partial_function</a> (pc, &amp;name, &amp;func_addr, &amp;func_end))
<a name="l02597"></a>02597     <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l02598"></a>02598                     <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No virtual frame pointer available&quot;</span>));
<a name="l02599"></a>02599 
<a name="l02600"></a>02600   m32c_analyze_prologue (gdbarch, func_addr, pc, &amp;p);
<a name="l02601"></a>02601   <span class="keywordflow">switch</span> (p.kind)
<a name="l02602"></a>02602     {
<a name="l02603"></a>02603     <span class="keywordflow">case</span> prologue_with_frame_ptr:
<a name="l02604"></a>02604       *frame_regnum = m32c_banked_register (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a584c527b4e94c7bf12610034878bd377">fb</a>, regcache)-&gt;num;
<a name="l02605"></a>02605       *frame_offset = p.frame_ptr_offset;
<a name="l02606"></a>02606       <span class="keywordflow">break</span>;
<a name="l02607"></a>02607     <span class="keywordflow">case</span> prologue_sans_frame_ptr:
<a name="l02608"></a>02608       *frame_regnum = m32c_banked_register (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>, regcache)-&gt;num;
<a name="l02609"></a>02609       *frame_offset = p.frame_size;
<a name="l02610"></a>02610       <span class="keywordflow">break</span>;
<a name="l02611"></a>02611     <span class="keywordflow">default</span>:
<a name="l02612"></a>02612       *frame_regnum = m32c_banked_register (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6c9a3fc3be4039b5ccd626c50ebcb2fd">sp</a>, regcache)-&gt;num;
<a name="l02613"></a>02613       *frame_offset = 0;
<a name="l02614"></a>02614       <span class="keywordflow">break</span>;
<a name="l02615"></a>02615     }
<a name="l02616"></a>02616   <span class="comment">/* Sanity check */</span>
<a name="l02617"></a>02617   <span class="keywordflow">if</span> (*frame_regnum &gt; <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (gdbarch))
<a name="l02618"></a>02618     <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l02619"></a>02619                     <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No virtual frame pointer available&quot;</span>));
<a name="l02620"></a>02620 }
<a name="l02621"></a>02621 
<a name="l02622"></a>02622 
<a name="l02623"></a>02623 <span class="comment">/* Initialization.  */</span>
<a name="l02624"></a>02624 
<a name="l02625"></a>02625 <span class="keyword">static</span> <span class="keyword">struct </span>gdbarch *
<a name="l02626"></a>02626 m32c_gdbarch_init (<span class="keyword">struct</span> <a class="code" href="structgdbarch__info.html">gdbarch_info</a> info, <span class="keyword">struct</span> <a class="code" href="structgdbarch__list.html">gdbarch_list</a> *arches)
<a name="l02627"></a>02627 {
<a name="l02628"></a>02628   <span class="keyword">struct </span>gdbarch *arch;
<a name="l02629"></a>02629   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep;
<a name="l02630"></a>02630   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mach = info.<a class="code" href="structgdbarch__info.html#ad42b7b45e0927c2482ba178db64b2fa7">bfd_arch_info</a>-&gt;mach;
<a name="l02631"></a>02631 
<a name="l02632"></a>02632   <span class="comment">/* Find a candidate among the list of architectures we&#39;ve created</span>
<a name="l02633"></a>02633 <span class="comment">     already.  */</span>
<a name="l02634"></a>02634   <span class="keywordflow">for</span> (arches = <a class="code" href="gdbarch_8c.html#aa3ea1c25a21a533dfd0d924a7d9778e4">gdbarch_list_lookup_by_info</a> (arches, &amp;info);
<a name="l02635"></a>02635        arches != NULL;
<a name="l02636"></a>02636        arches = <a class="code" href="gdbarch_8c.html#aa3ea1c25a21a533dfd0d924a7d9778e4">gdbarch_list_lookup_by_info</a> (arches-&gt;<a class="code" href="structgdbarch__list.html#a9da6f84112797b67d5d8e7b8d4e26b14">next</a>, &amp;info))
<a name="l02637"></a>02637     <span class="keywordflow">return</span> arches-&gt;<a class="code" href="structgdbarch__list.html#a6c51da8c4c95249704dfe18394fd08f9">gdbarch</a>;
<a name="l02638"></a>02638 
<a name="l02639"></a>02639   tdep = <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a> (1, <span class="keyword">sizeof</span> (*tdep));
<a name="l02640"></a>02640   arch = <a class="code" href="gdbarch_8c.html#a9e0b0979fa2cb7439f41f66deda8dec5">gdbarch_alloc</a> (&amp;info, tdep);
<a name="l02641"></a>02641 
<a name="l02642"></a>02642   <span class="comment">/* Essential types.  */</span>
<a name="l02643"></a>02643   make_types (arch);
<a name="l02644"></a>02644 
<a name="l02645"></a>02645   <span class="comment">/* Address/pointer conversions.  */</span>
<a name="l02646"></a>02646   <span class="keywordflow">if</span> (mach == bfd_mach_m16c)
<a name="l02647"></a>02647     {
<a name="l02648"></a>02648       <a class="code" href="gdbarch_8c.html#a6c82f1dbe30d9e90f292191a8990a083">set_gdbarch_address_to_pointer</a> (arch, m32c_m16c_address_to_pointer);
<a name="l02649"></a>02649       <a class="code" href="gdbarch_8c.html#a32663d81b453b7b64760943b2e34900f">set_gdbarch_pointer_to_address</a> (arch, m32c_m16c_pointer_to_address);
<a name="l02650"></a>02650     }
<a name="l02651"></a>02651 
<a name="l02652"></a>02652   <span class="comment">/* Register set.  */</span>
<a name="l02653"></a>02653   make_regs (arch);
<a name="l02654"></a>02654 
<a name="l02655"></a>02655   <span class="comment">/* Disassembly.  */</span>
<a name="l02656"></a>02656   <a class="code" href="gdbarch_8c.html#a0c9e9e391e44d476b74debefc407e9bb">set_gdbarch_print_insn</a> (arch, print_insn_m32c);
<a name="l02657"></a>02657 
<a name="l02658"></a>02658   <span class="comment">/* Breakpoints.  */</span>
<a name="l02659"></a>02659   <a class="code" href="gdbarch_8c.html#ad738cdf37fa27f4cf3642107cadf61d3">set_gdbarch_breakpoint_from_pc</a> (arch, m32c_breakpoint_from_pc);
<a name="l02660"></a>02660 
<a name="l02661"></a>02661   <span class="comment">/* Prologue analysis and unwinding.  */</span>
<a name="l02662"></a>02662   <a class="code" href="gdbarch_8c.html#ad66381ed135b13aa5635f0485211ca71">set_gdbarch_inner_than</a> (arch, <a class="code" href="arch-utils_8c.html#aaceae1c07203f3091df647f813b9f20e">core_addr_lessthan</a>);
<a name="l02663"></a>02663   <a class="code" href="gdbarch_8c.html#a841509ae0070f2f12aa9b3b7fd52b92f">set_gdbarch_skip_prologue</a> (arch, m32c_skip_prologue);
<a name="l02664"></a>02664   <a class="code" href="gdbarch_8c.html#a1974f5f26c09a4cd32165286c3769621">set_gdbarch_unwind_pc</a> (arch, m32c_unwind_pc);
<a name="l02665"></a>02665   <a class="code" href="gdbarch_8c.html#ababd871cc4b5fac1831e52f7331d7572">set_gdbarch_unwind_sp</a> (arch, m32c_unwind_sp);
<a name="l02666"></a>02666 <span class="preprocessor">#if 0</span>
<a name="l02667"></a>02667 <span class="preprocessor"></span>  <span class="comment">/* I&#39;m dropping the dwarf2 sniffer because it has a few problems.</span>
<a name="l02668"></a>02668 <span class="comment">     They may be in the dwarf2 cfi code in GDB, or they may be in</span>
<a name="l02669"></a>02669 <span class="comment">     the debug info emitted by the upstream toolchain.  I don&#39;t </span>
<a name="l02670"></a>02670 <span class="comment">     know which, but I do know that the prologue analyzer works better.</span>
<a name="l02671"></a>02671 <span class="comment">     MVS 04/13/06  */</span>
<a name="l02672"></a>02672   dwarf2_append_sniffers (arch);
<a name="l02673"></a>02673 <span class="preprocessor">#endif</span>
<a name="l02674"></a>02674 <span class="preprocessor"></span>  <a class="code" href="frame-unwind_8c.html#afa4de8a130514bfd524d46f32e35a534">frame_unwind_append_unwinder</a> (arch, &amp;m32c_unwind);
<a name="l02675"></a>02675 
<a name="l02676"></a>02676   <span class="comment">/* Inferior calls.  */</span>
<a name="l02677"></a>02677   <a class="code" href="gdbarch_8c.html#a853528dceff46211c1bb8c57b77dca31">set_gdbarch_push_dummy_call</a> (arch, m32c_push_dummy_call);
<a name="l02678"></a>02678   <a class="code" href="gdbarch_8c.html#ad9b13a9323cac027c4b805953b4fff63">set_gdbarch_return_value</a> (arch, m32c_return_value);
<a name="l02679"></a>02679   <a class="code" href="gdbarch_8c.html#a23da982924f904d22d0b58639a48bccf">set_gdbarch_dummy_id</a> (arch, m32c_dummy_id);
<a name="l02680"></a>02680 
<a name="l02681"></a>02681   <span class="comment">/* Trampolines.  */</span>
<a name="l02682"></a>02682   <a class="code" href="gdbarch_8c.html#a07ccbd7ea452da3be3982cf93d7976c7">set_gdbarch_skip_trampoline_code</a> (arch, m32c_skip_trampoline_code);
<a name="l02683"></a>02683 
<a name="l02684"></a>02684   <a class="code" href="gdbarch_8c.html#ac20d66067cb5240cb6c1d8e48c0500e2">set_gdbarch_virtual_frame_pointer</a> (arch, m32c_virtual_frame_pointer);
<a name="l02685"></a>02685 
<a name="l02686"></a>02686   <span class="comment">/* m32c function boundary addresses are not necessarily even.</span>
<a name="l02687"></a>02687 <span class="comment">     Therefore, the `vbit&#39;, which indicates a pointer to a virtual</span>
<a name="l02688"></a>02688 <span class="comment">     member function, is stored in the delta field, rather than as</span>
<a name="l02689"></a>02689 <span class="comment">     the low bit of a function pointer address.</span>
<a name="l02690"></a>02690 <span class="comment"></span>
<a name="l02691"></a>02691 <span class="comment">     In order to verify this, see the definition of</span>
<a name="l02692"></a>02692 <span class="comment">     TARGET_PTRMEMFUNC_VBIT_LOCATION in gcc/defaults.h along with the</span>
<a name="l02693"></a>02693 <span class="comment">     definition of FUNCTION_BOUNDARY in gcc/config/m32c/m32c.h.  */</span>
<a name="l02694"></a>02694   <a class="code" href="gdbarch_8c.html#afb0266d395ca763cef13e8a6b16d0f50">set_gdbarch_vbit_in_delta</a> (arch, 1);
<a name="l02695"></a>02695 
<a name="l02696"></a>02696   <span class="keywordflow">return</span> arch;
<a name="l02697"></a>02697 }
<a name="l02698"></a>02698 
<a name="l02699"></a>02699 <span class="comment">/* Provide a prototype to silence -Wmissing-prototypes.  */</span>
<a name="l02700"></a>02700 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#a686ed07d4fdcdc366f2bc677216ca08d">initialize_file_ftype</a> <a class="code" href="m32c-tdep_8c.html#a0861dd8774ba69659db947f1af1426bb">_initialize_m32c_tdep</a>;
<a name="l02701"></a>02701 
<a name="l02702"></a>02702 <span class="keywordtype">void</span>
<a name="l02703"></a><a class="code" href="m32c-tdep_8c.html#a2a12fb019b6188fc246ab5225eaf2722">02703</a> _initialize_m32c_tdep (<span class="keywordtype">void</span>)
<a name="l02704"></a>02704 {
<a name="l02705"></a>02705   <a class="code" href="gdbarch_8c.html#adb96505b62850783929ff38de0c39062">register_gdbarch_init</a> (bfd_arch_m32c, m32c_gdbarch_init);
<a name="l02706"></a>02706 
<a name="l02707"></a>02707   m32c_dma_reggroup = <a class="code" href="reggroups_8c.html#a3cb3369b5063997a1382cfb8ad240ad6">reggroup_new</a> (<span class="stringliteral">&quot;dma&quot;</span>, <a class="code" href="reggroups_8h.html#a7377a90943c0ba0d23c3b03a07583f22a9ef6d86366eea2f7b79d387752a38be1">USER_REGGROUP</a>);
<a name="l02708"></a>02708 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:12:19 for GDB (API) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
