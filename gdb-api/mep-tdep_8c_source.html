<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (API): /home/stan/gdb/src/gdb/mep-tdep.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (API)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/mep-tdep.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="mep-tdep_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Target-dependent code for the Toshiba MeP for GDB, the GNU debugger.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 2001-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   Contributed by Red Hat, Inc.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This file is part of GDB.</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00010"></a>00010 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00011"></a>00011 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00012"></a>00012 <span class="comment">   (at your option) any later version.</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00015"></a>00015 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00016"></a>00016 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00017"></a>00017 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00020"></a>00020 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="frame_8h.html">frame.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="frame-unwind_8h.html">frame-unwind.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="frame-base_8h.html">frame-base.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="gdbtypes_8h.html">gdbtypes.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="gdbcmd_8h.html">gdbcmd.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="gdbcore_8h.html">gdbcore.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="gdb__string_8h.html">gdb_string.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="value_8h.html">value.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="inferior_8h.html">inferior.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;dis-asm.h&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="symfile_8h.html">symfile.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="objfiles_8h.html">objfiles.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="language_8h.html">language.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="arch-utils_8h.html">arch-utils.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="regcache_8h.html">regcache.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="remote_8h.html">remote.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;floatformat.h&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="sim-regno_8h.html">sim-regno.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="disasm_8h.html">disasm.h</a>&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="trad-frame_8h.html">trad-frame.h</a>&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="reggroups_8h.html">reggroups.h</a>&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;elf-bfd.h&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;elf/mep.h&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="prologue-value_8h.html">prologue-value.h</a>&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;cgen/bitset.h&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;<a class="code" href="infcall_8h.html">infcall.h</a>&quot;</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;<a class="code" href="gdb__assert_8h.html">gdb_assert.h</a>&quot;</span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="comment">/* Get the user&#39;s customized MeP coprocessor register names from</span>
<a name="l00054"></a>00054 <span class="comment">   libopcodes.  */</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;opcodes/mep-desc.h&quot;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &quot;opcodes/mep-opc.h&quot;</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="comment">/* The gdbarch_tdep structure.  */</span>
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 <span class="comment">/* A quick recap for GDB hackers not familiar with the whole Toshiba</span>
<a name="l00062"></a>00062 <span class="comment">   Media Processor story:</span>
<a name="l00063"></a>00063 <span class="comment"></span>
<a name="l00064"></a>00064 <span class="comment">   The MeP media engine is a configureable processor: users can design</span>
<a name="l00065"></a>00065 <span class="comment">   their own coprocessors, implement custom instructions, adjust cache</span>
<a name="l00066"></a>00066 <span class="comment">   sizes, select optional standard facilities like add-and-saturate</span>
<a name="l00067"></a>00067 <span class="comment">   instructions, and so on.  Then, they can build custom versions of</span>
<a name="l00068"></a>00068 <span class="comment">   the GNU toolchain to support their customized chips.  The</span>
<a name="l00069"></a>00069 <span class="comment">   MeP-Integrator program (see utils/mep) takes a GNU toolchain source</span>
<a name="l00070"></a>00070 <span class="comment">   tree, and a config file pointing to various files provided by the</span>
<a name="l00071"></a>00071 <span class="comment">   user describing their customizations, and edits the source tree to</span>
<a name="l00072"></a>00072 <span class="comment">   produce a compiler that can generate their custom instructions, an</span>
<a name="l00073"></a>00073 <span class="comment">   assembler that can assemble them and recognize their custom</span>
<a name="l00074"></a>00074 <span class="comment">   register names, and so on.</span>
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">   Furthermore, the user can actually specify several of these custom</span>
<a name="l00077"></a>00077 <span class="comment">   configurations, called &#39;me_modules&#39;, and get a toolchain which can</span>
<a name="l00078"></a>00078 <span class="comment">   produce code for any of them, given a compiler/assembler switch;</span>
<a name="l00079"></a>00079 <span class="comment">   you say something like &#39;gcc -mconfig=mm_max&#39; to generate code for</span>
<a name="l00080"></a>00080 <span class="comment">   the me_module named &#39;mm_max&#39;.</span>
<a name="l00081"></a>00081 <span class="comment"></span>
<a name="l00082"></a>00082 <span class="comment">   GDB, in particular, needs to:</span>
<a name="l00083"></a>00083 <span class="comment"></span>
<a name="l00084"></a>00084 <span class="comment">   - use the coprocessor control register names provided by the user</span>
<a name="l00085"></a>00085 <span class="comment">     in their hardware description, in expressions, &#39;info register&#39;</span>
<a name="l00086"></a>00086 <span class="comment">     output, and disassembly,</span>
<a name="l00087"></a>00087 <span class="comment"></span>
<a name="l00088"></a>00088 <span class="comment">   - know the number, names, and types of the coprocessor&#39;s</span>
<a name="l00089"></a>00089 <span class="comment">     general-purpose registers, adjust the &#39;info all-registers&#39; output</span>
<a name="l00090"></a>00090 <span class="comment">     accordingly, and print error messages if the user refers to one</span>
<a name="l00091"></a>00091 <span class="comment">     that doesn&#39;t exist</span>
<a name="l00092"></a>00092 <span class="comment"></span>
<a name="l00093"></a>00093 <span class="comment">   - allow access to the control bus space only when the configuration</span>
<a name="l00094"></a>00094 <span class="comment">     actually has a control bus, and recognize which regions of the</span>
<a name="l00095"></a>00095 <span class="comment">     control bus space are actually populated,</span>
<a name="l00096"></a>00096 <span class="comment"></span>
<a name="l00097"></a>00097 <span class="comment">   - disassemble using the user&#39;s provided mnemonics for their custom</span>
<a name="l00098"></a>00098 <span class="comment">     instructions, and</span>
<a name="l00099"></a>00099 <span class="comment"></span>
<a name="l00100"></a>00100 <span class="comment">   - recognize whether the $hi and $lo registers are present, and</span>
<a name="l00101"></a>00101 <span class="comment">     allow access to them only when they are actually there.</span>
<a name="l00102"></a>00102 <span class="comment"></span>
<a name="l00103"></a>00103 <span class="comment">   There are three sources of information about what sort of me_module</span>
<a name="l00104"></a>00104 <span class="comment">   we&#39;re actually dealing with:</span>
<a name="l00105"></a>00105 <span class="comment"></span>
<a name="l00106"></a>00106 <span class="comment">   - A MeP executable file indicates which me_module it was compiled</span>
<a name="l00107"></a>00107 <span class="comment">     for, and libopcodes has tables describing each module.  So, given</span>
<a name="l00108"></a>00108 <span class="comment">     an executable file, we can find out about the processor it was</span>
<a name="l00109"></a>00109 <span class="comment">     compiled for.</span>
<a name="l00110"></a>00110 <span class="comment"></span>
<a name="l00111"></a>00111 <span class="comment">   - There are SID command-line options to select a particular</span>
<a name="l00112"></a>00112 <span class="comment">     me_module, overriding the one specified in the ELF file.  SID</span>
<a name="l00113"></a>00113 <span class="comment">     provides GDB with a fake read-only register, &#39;module&#39;, which</span>
<a name="l00114"></a>00114 <span class="comment">     indicates which me_module GDB is communicating with an instance</span>
<a name="l00115"></a>00115 <span class="comment">     of.</span>
<a name="l00116"></a>00116 <span class="comment"></span>
<a name="l00117"></a>00117 <span class="comment">   - There are SID command-line options to enable or disable certain</span>
<a name="l00118"></a>00118 <span class="comment">     optional processor features, overriding the defaults for the</span>
<a name="l00119"></a>00119 <span class="comment">     selected me_module.  The MeP $OPT register indicates which</span>
<a name="l00120"></a>00120 <span class="comment">     options are present on the current processor.  */</span>
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a>
<a name="l00124"></a>00124 {
<a name="l00125"></a>00125   <span class="comment">/* A CGEN cpu descriptor for this BFD architecture and machine.</span>
<a name="l00126"></a>00126 <span class="comment"></span>
<a name="l00127"></a>00127 <span class="comment">     Note: this is *not* customized for any particular me_module; the</span>
<a name="l00128"></a>00128 <span class="comment">     MeP libopcodes machinery actually puts off module-specific</span>
<a name="l00129"></a>00129 <span class="comment">     customization until the last minute.  So this contains</span>
<a name="l00130"></a>00130 <span class="comment">     information about all supported me_modules.  */</span>
<a name="l00131"></a><a class="code" href="structgdbarch__tdep.html#a14020af34bc3c1abd19ac7183b374864">00131</a>   CGEN_CPU_DESC <a class="code" href="structgdbarch__tdep.html#a14020af34bc3c1abd19ac7183b374864">cpu_desc</a>;
<a name="l00132"></a>00132 
<a name="l00133"></a>00133   <span class="comment">/* The me_module index from the ELF file we used to select this</span>
<a name="l00134"></a>00134 <span class="comment">     architecture, or CONFIG_NONE if there was none.</span>
<a name="l00135"></a>00135 <span class="comment"></span>
<a name="l00136"></a>00136 <span class="comment">     Note that we should prefer to use the me_module number available</span>
<a name="l00137"></a>00137 <span class="comment">     via the &#39;module&#39; register, whenever we&#39;re actually talking to a</span>
<a name="l00138"></a>00138 <span class="comment">     real target.</span>
<a name="l00139"></a>00139 <span class="comment"></span>
<a name="l00140"></a>00140 <span class="comment">     In the absence of live information, we&#39;d like to get the</span>
<a name="l00141"></a>00141 <span class="comment">     me_module number from the ELF file.  But which ELF file: the</span>
<a name="l00142"></a>00142 <span class="comment">     executable file, the core file, ... ?  The answer is, &quot;the last</span>
<a name="l00143"></a>00143 <span class="comment">     ELF file we used to set the current architecture&quot;.  Thus, we</span>
<a name="l00144"></a>00144 <span class="comment">     create a separate instance of the gdbarch structure for each</span>
<a name="l00145"></a>00145 <span class="comment">     me_module value mep_gdbarch_init sees, and store the me_module</span>
<a name="l00146"></a>00146 <span class="comment">     value from the ELF file here.  */</span>
<a name="l00147"></a><a class="code" href="structgdbarch__tdep.html#a19f7f93966ab0c170dce987f0f510ad7">00147</a>   CONFIG_ATTR <a class="code" href="structgdbarch__tdep.html#a19f7f93966ab0c170dce987f0f510ad7">me_module</a>;
<a name="l00148"></a>00148 };
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="comment">/* Getting me_module information from the CGEN tables.  */</span>
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 <span class="comment">/* Find an entry in the DESC&#39;s hardware table whose name begins with</span>
<a name="l00156"></a>00156 <span class="comment">   PREFIX, and whose ISA mask intersects COPRO_ISA_MASK, but does not</span>
<a name="l00157"></a>00157 <span class="comment">   intersect with GENERIC_ISA_MASK.  If there is no matching entry,</span>
<a name="l00158"></a>00158 <span class="comment">   return zero.  */</span>
<a name="l00159"></a>00159 <span class="keyword">static</span> <span class="keyword">const</span> CGEN_HW_ENTRY *
<a name="l00160"></a>00160 find_hw_entry_by_prefix_and_isa (CGEN_CPU_DESC desc,
<a name="l00161"></a>00161                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix,
<a name="l00162"></a>00162                                  CGEN_BITSET *copro_isa_mask,
<a name="l00163"></a>00163                                  CGEN_BITSET *generic_isa_mask)
<a name="l00164"></a>00164 {
<a name="l00165"></a>00165   <span class="keywordtype">int</span> prefix_len = strlen (prefix);
<a name="l00166"></a>00166   <span class="keywordtype">int</span> i;
<a name="l00167"></a>00167 
<a name="l00168"></a>00168   <span class="keywordflow">for</span> (i = 0; i &lt; desc-&gt;hw_table.num_entries; i++)
<a name="l00169"></a>00169     {
<a name="l00170"></a>00170       <span class="keyword">const</span> CGEN_HW_ENTRY *hw = desc-&gt;hw_table.entries[i];
<a name="l00171"></a>00171       <span class="keywordflow">if</span> (strncmp (prefix, hw-&gt;name, prefix_len) == 0)
<a name="l00172"></a>00172         {
<a name="l00173"></a>00173           CGEN_BITSET *hw_isa_mask
<a name="l00174"></a>00174             = ((CGEN_BITSET *)
<a name="l00175"></a>00175                &amp;CGEN_ATTR_CGEN_HW_ISA_VALUE (CGEN_HW_ATTRS (hw)));
<a name="l00176"></a>00176 
<a name="l00177"></a>00177           <span class="keywordflow">if</span> (cgen_bitset_intersect_p (hw_isa_mask, copro_isa_mask)
<a name="l00178"></a>00178               &amp;&amp; ! cgen_bitset_intersect_p (hw_isa_mask, generic_isa_mask))
<a name="l00179"></a>00179             <span class="keywordflow">return</span> hw;
<a name="l00180"></a>00180         }
<a name="l00181"></a>00181     }
<a name="l00182"></a>00182 
<a name="l00183"></a>00183   <span class="keywordflow">return</span> 0;
<a name="l00184"></a>00184 }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="comment">/* Find an entry in DESC&#39;s hardware table whose type is TYPE.  Return</span>
<a name="l00188"></a>00188 <span class="comment">   zero if there is none.  */</span>
<a name="l00189"></a>00189 <span class="keyword">static</span> <span class="keyword">const</span> CGEN_HW_ENTRY *
<a name="l00190"></a>00190 find_hw_entry_by_type (CGEN_CPU_DESC desc, CGEN_HW_TYPE <a class="code" href="structtype.html">type</a>)
<a name="l00191"></a>00191 {
<a name="l00192"></a>00192   <span class="keywordtype">int</span> i;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194   <span class="keywordflow">for</span> (i = 0; i &lt; desc-&gt;hw_table.num_entries; i++)
<a name="l00195"></a>00195     {
<a name="l00196"></a>00196       <span class="keyword">const</span> CGEN_HW_ENTRY *hw = desc-&gt;hw_table.entries[i];
<a name="l00197"></a>00197 
<a name="l00198"></a>00198       <span class="keywordflow">if</span> (hw-&gt;type == type)
<a name="l00199"></a>00199         <span class="keywordflow">return</span> hw;
<a name="l00200"></a>00200     }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202   <span class="keywordflow">return</span> 0;
<a name="l00203"></a>00203 }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 <span class="comment">/* Return the CGEN hardware table entry for the coprocessor register</span>
<a name="l00207"></a>00207 <span class="comment">   set for ME_MODULE, whose name prefix is PREFIX.  If ME_MODULE has</span>
<a name="l00208"></a>00208 <span class="comment">   no such register set, return zero.  If ME_MODULE is the generic</span>
<a name="l00209"></a>00209 <span class="comment">   me_module CONFIG_NONE, return the table entry for the register set</span>
<a name="l00210"></a>00210 <span class="comment">   whose hardware type is GENERIC_TYPE.  */</span>
<a name="l00211"></a>00211 <span class="keyword">static</span> <span class="keyword">const</span> CGEN_HW_ENTRY *
<a name="l00212"></a>00212 me_module_register_set (CONFIG_ATTR me_module,
<a name="l00213"></a>00213                         <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix,
<a name="l00214"></a>00214                         CGEN_HW_TYPE generic_type)
<a name="l00215"></a>00215 {
<a name="l00216"></a>00216   <span class="comment">/* This is kind of tricky, because the hardware table is constructed</span>
<a name="l00217"></a>00217 <span class="comment">     in a way that isn&#39;t very helpful.  Perhaps we can fix that, but</span>
<a name="l00218"></a>00218 <span class="comment">     here&#39;s how it works at the moment:</span>
<a name="l00219"></a>00219 <span class="comment"></span>
<a name="l00220"></a>00220 <span class="comment">     The configuration map, `mep_config_map&#39;, is indexed by me_module</span>
<a name="l00221"></a>00221 <span class="comment">     number, and indicates which coprocessor and core ISAs that</span>
<a name="l00222"></a>00222 <span class="comment">     me_module supports.  The &#39;core_isa&#39; mask includes all the core</span>
<a name="l00223"></a>00223 <span class="comment">     ISAs, and the &#39;cop_isa&#39; mask includes all the coprocessor ISAs.</span>
<a name="l00224"></a>00224 <span class="comment">     The entry for the generic me_module, CONFIG_NONE, has an empty</span>
<a name="l00225"></a>00225 <span class="comment">     &#39;cop_isa&#39;, and its &#39;core_isa&#39; selects only the standard MeP</span>
<a name="l00226"></a>00226 <span class="comment">     instruction set.</span>
<a name="l00227"></a>00227 <span class="comment"></span>
<a name="l00228"></a>00228 <span class="comment">     The CGEN CPU descriptor&#39;s hardware table, desc-&gt;hw_table, has</span>
<a name="l00229"></a>00229 <span class="comment">     entries for all the register sets, for all me_modules.  Each</span>
<a name="l00230"></a>00230 <span class="comment">     entry has a mask indicating which ISAs use that register set.</span>
<a name="l00231"></a>00231 <span class="comment">     So, if an me_module supports some coprocessor ISA, we can find</span>
<a name="l00232"></a>00232 <span class="comment">     applicable register sets by scanning the hardware table for</span>
<a name="l00233"></a>00233 <span class="comment">     register sets whose masks include (at least some of) those ISAs.</span>
<a name="l00234"></a>00234 <span class="comment"></span>
<a name="l00235"></a>00235 <span class="comment">     Each hardware table entry also has a name, whose prefix says</span>
<a name="l00236"></a>00236 <span class="comment">     whether it&#39;s a general-purpose (&quot;h-cr&quot;) or control (&quot;h-ccr&quot;)</span>
<a name="l00237"></a>00237 <span class="comment">     coprocessor register set.  It might be nicer to have an attribute</span>
<a name="l00238"></a>00238 <span class="comment">     indicating what sort of register set it was, that we could use</span>
<a name="l00239"></a>00239 <span class="comment">     instead of pattern-matching on the name.</span>
<a name="l00240"></a>00240 <span class="comment"></span>
<a name="l00241"></a>00241 <span class="comment">     When there is no hardware table entry whose mask includes a</span>
<a name="l00242"></a>00242 <span class="comment">     particular coprocessor ISA and whose name starts with a given</span>
<a name="l00243"></a>00243 <span class="comment">     prefix, then that means that that coprocessor doesn&#39;t have any</span>
<a name="l00244"></a>00244 <span class="comment">     registers of that type.  In such cases, this function must return</span>
<a name="l00245"></a>00245 <span class="comment">     a null pointer.</span>
<a name="l00246"></a>00246 <span class="comment"></span>
<a name="l00247"></a>00247 <span class="comment">     Coprocessor register sets&#39; masks may or may not include the core</span>
<a name="l00248"></a>00248 <span class="comment">     ISA for the me_module they belong to.  Those generated by a2cgen</span>
<a name="l00249"></a>00249 <span class="comment">     do, but the sample me_module included in the unconfigured tree,</span>
<a name="l00250"></a>00250 <span class="comment">     &#39;ccfx&#39;, does not.</span>
<a name="l00251"></a>00251 <span class="comment"></span>
<a name="l00252"></a>00252 <span class="comment">     There are generic coprocessor register sets, intended only for</span>
<a name="l00253"></a>00253 <span class="comment">     use with the generic me_module.  Unfortunately, their masks</span>
<a name="l00254"></a>00254 <span class="comment">     include *all* ISAs --- even those for coprocessors that don&#39;t</span>
<a name="l00255"></a>00255 <span class="comment">     have such register sets.  This makes detecting the case where a</span>
<a name="l00256"></a>00256 <span class="comment">     coprocessor lacks a particular register set more complicated.</span>
<a name="l00257"></a>00257 <span class="comment"></span>
<a name="l00258"></a>00258 <span class="comment">     So, here&#39;s the approach we take:</span>
<a name="l00259"></a>00259 <span class="comment"></span>
<a name="l00260"></a>00260 <span class="comment">     - For CONFIG_NONE, we return the generic coprocessor register set.</span>
<a name="l00261"></a>00261 <span class="comment"></span>
<a name="l00262"></a>00262 <span class="comment">     - For any other me_module, we search for a register set whose</span>
<a name="l00263"></a>00263 <span class="comment">       mask contains any of the me_module&#39;s coprocessor ISAs,</span>
<a name="l00264"></a>00264 <span class="comment">       specifically excluding the generic coprocessor register sets.  */</span>
<a name="l00265"></a>00265 
<a name="l00266"></a>00266   CGEN_CPU_DESC desc = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ())-&gt;<a class="code" href="structgdbarch__tdep.html#a14020af34bc3c1abd19ac7183b374864">cpu_desc</a>;
<a name="l00267"></a>00267   <span class="keyword">const</span> CGEN_HW_ENTRY *hw;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269   <span class="keywordflow">if</span> (me_module == CONFIG_NONE)
<a name="l00270"></a>00270     hw = find_hw_entry_by_type (desc, generic_type);
<a name="l00271"></a>00271   <span class="keywordflow">else</span>
<a name="l00272"></a>00272     {
<a name="l00273"></a>00273       CGEN_BITSET *cop = &amp;mep_config_map[me_module].cop_isa;
<a name="l00274"></a>00274       CGEN_BITSET *core = &amp;mep_config_map[me_module].core_isa;
<a name="l00275"></a>00275       CGEN_BITSET *<span class="keyword">generic</span> = &amp;mep_config_map[CONFIG_NONE].core_isa;
<a name="l00276"></a>00276       CGEN_BITSET *cop_and_core;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278       <span class="comment">/* The coprocessor ISAs include the ISA for the specific core which</span>
<a name="l00279"></a>00279 <span class="comment">         has that coprocessor.  */</span>
<a name="l00280"></a>00280       cop_and_core = cgen_bitset_copy (cop);
<a name="l00281"></a>00281       cgen_bitset_union (cop, core, cop_and_core);
<a name="l00282"></a>00282       hw = find_hw_entry_by_prefix_and_isa (desc, prefix, cop_and_core, <span class="keyword">generic</span>);
<a name="l00283"></a>00283     }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285   <span class="keywordflow">return</span> hw;
<a name="l00286"></a>00286 }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="comment">/* Given a hardware table entry HW representing a register set, return</span>
<a name="l00290"></a>00290 <span class="comment">   a pointer to the keyword table with all the register names.  If HW</span>
<a name="l00291"></a>00291 <span class="comment">   is NULL, return NULL, to propage the &quot;no such register set&quot; info</span>
<a name="l00292"></a>00292 <span class="comment">   along.  */</span>
<a name="l00293"></a>00293 <span class="keyword">static</span> CGEN_KEYWORD *
<a name="l00294"></a>00294 register_set_keyword_table (<span class="keyword">const</span> CGEN_HW_ENTRY *hw)
<a name="l00295"></a>00295 {
<a name="l00296"></a>00296   <span class="keywordflow">if</span> (! hw)
<a name="l00297"></a>00297     <span class="keywordflow">return</span> NULL;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299   <span class="comment">/* Check that HW is actually a keyword table.  */</span>
<a name="l00300"></a>00300   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (hw-&gt;asm_type == CGEN_ASM_KEYWORD);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302   <span class="comment">/* The &#39;asm_data&#39; field of a register set&#39;s hardware table entry</span>
<a name="l00303"></a>00303 <span class="comment">     refers to a keyword table.  */</span>
<a name="l00304"></a>00304   <span class="keywordflow">return</span> (CGEN_KEYWORD *) hw-&gt;asm_data;
<a name="l00305"></a>00305 }
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 <span class="comment">/* Given a keyword table KEYWORD and a register number REGNUM, return</span>
<a name="l00309"></a>00309 <span class="comment">   the name of the register, or &quot;&quot; if KEYWORD contains no register</span>
<a name="l00310"></a>00310 <span class="comment">   whose number is REGNUM.  */</span>
<a name="l00311"></a>00311 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00312"></a>00312 register_name_from_keyword (CGEN_KEYWORD *keyword_table, <span class="keywordtype">int</span> <a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>)
<a name="l00313"></a>00313 {
<a name="l00314"></a>00314   <span class="keyword">const</span> CGEN_KEYWORD_ENTRY *entry
<a name="l00315"></a>00315     = cgen_keyword_lookup_value (keyword_table, regnum);
<a name="l00316"></a>00316 
<a name="l00317"></a>00317   <span class="keywordflow">if</span> (entry)
<a name="l00318"></a>00318     {
<a name="l00319"></a>00319       <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a> = entry-&gt;name;
<a name="l00320"></a>00320 
<a name="l00321"></a>00321       <span class="comment">/* The CGEN keyword entries for register names include the</span>
<a name="l00322"></a>00322 <span class="comment">         leading $, which appears in MeP assembly as well as in GDB.</span>
<a name="l00323"></a>00323 <span class="comment">         But we don&#39;t want to return that; GDB core code adds that</span>
<a name="l00324"></a>00324 <span class="comment">         itself.  */</span>
<a name="l00325"></a>00325       <span class="keywordflow">if</span> (name[0] == <span class="charliteral">&#39;$&#39;</span>)
<a name="l00326"></a>00326         name++;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328       <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l00329"></a>00329     }
<a name="l00330"></a>00330   <span class="keywordflow">else</span>
<a name="l00331"></a>00331     <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00332"></a>00332 }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334   
<a name="l00335"></a>00335 <span class="comment">/* Masks for option bits in the OPT special-purpose register.  */</span>
<a name="l00336"></a>00336 <span class="keyword">enum</span> {
<a name="l00337"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa7fbabd3d2fb9332e7bb9fca83efa76d8">00337</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa7fbabd3d2fb9332e7bb9fca83efa76d8">MEP_OPT_DIV</a> = 1 &lt;&lt; 25,        <span class="comment">/* 32-bit divide instruction option */</span>
<a name="l00338"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa6f7fa9c39a21cafdc26ad75d07d3a643">00338</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa6f7fa9c39a21cafdc26ad75d07d3a643">MEP_OPT_MUL</a> = 1 &lt;&lt; 24,        <span class="comment">/* 32-bit multiply instruction option */</span>
<a name="l00339"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa033f874053739b360a4b8c7a80b10911">00339</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa033f874053739b360a4b8c7a80b10911">MEP_OPT_BIT</a> = 1 &lt;&lt; 23,        <span class="comment">/* bit manipulation instruction option */</span>
<a name="l00340"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa515eb2813522561b49fd85f9eb4e74b3">00340</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa515eb2813522561b49fd85f9eb4e74b3">MEP_OPT_SAT</a> = 1 &lt;&lt; 22,        <span class="comment">/* saturation instruction option */</span>
<a name="l00341"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caab75e2691f11e4350c24da6abc04fcd47">00341</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caab75e2691f11e4350c24da6abc04fcd47">MEP_OPT_CLP</a> = 1 &lt;&lt; 21,        <span class="comment">/* clip instruction option */</span>
<a name="l00342"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caab4fecc5924b1038f143df6c3dc37987f">00342</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caab4fecc5924b1038f143df6c3dc37987f">MEP_OPT_MIN</a> = 1 &lt;&lt; 20,        <span class="comment">/* min/max instruction option */</span>
<a name="l00343"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caac9a129c6c15baedf87eec0c4dda88056">00343</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caac9a129c6c15baedf87eec0c4dda88056">MEP_OPT_AVE</a> = 1 &lt;&lt; 19,        <span class="comment">/* average instruction option */</span>
<a name="l00344"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caae04aa5eef0b80198971c1890cafb5fc2">00344</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caae04aa5eef0b80198971c1890cafb5fc2">MEP_OPT_ABS</a> = 1 &lt;&lt; 18,        <span class="comment">/* absolute difference instruction option */</span>
<a name="l00345"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caafa5555b29095803c75777ff0ba62237d">00345</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caafa5555b29095803c75777ff0ba62237d">MEP_OPT_LDZ</a> = 1 &lt;&lt; 16,        <span class="comment">/* leading zero instruction option */</span>
<a name="l00346"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa526876f942ce4fe9b5e5386e21aeb1ac">00346</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa526876f942ce4fe9b5e5386e21aeb1ac">MEP_OPT_VL64</a> = 1 &lt;&lt; 6,        <span class="comment">/* 64-bit VLIW operation mode option */</span>
<a name="l00347"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa6c2ff802b7f8b83676a3af0c386fb688">00347</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa6c2ff802b7f8b83676a3af0c386fb688">MEP_OPT_VL32</a> = 1 &lt;&lt; 5,        <span class="comment">/* 32-bit VLIW operation mode option */</span>
<a name="l00348"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa0699c634adbc5cbca1769a66adeaebef">00348</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa0699c634adbc5cbca1769a66adeaebef">MEP_OPT_COP</a> = 1 &lt;&lt; 4,         <span class="comment">/* coprocessor option */</span>
<a name="l00349"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa9fb880223d80e79b908c50ce60d9f982">00349</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa9fb880223d80e79b908c50ce60d9f982">MEP_OPT_DSP</a> = 1 &lt;&lt; 2,         <span class="comment">/* DSP option */</span>
<a name="l00350"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa751698c667e36d2ff88b5b3bbbd76938">00350</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa751698c667e36d2ff88b5b3bbbd76938">MEP_OPT_UCI</a> = 1 &lt;&lt; 1,         <span class="comment">/* UCI option */</span>
<a name="l00351"></a><a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caad0375c349f1e1c51d1395285cfcd7979">00351</a>   <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caad0375c349f1e1c51d1395285cfcd7979">MEP_OPT_DBG</a> = 1 &lt;&lt; 0,         <span class="comment">/* DBG function option */</span>
<a name="l00352"></a>00352 };
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 <span class="comment">/* Given the option_mask value for a particular entry in</span>
<a name="l00356"></a>00356 <span class="comment">   mep_config_map, produce the value the processor&#39;s OPT register</span>
<a name="l00357"></a>00357 <span class="comment">   would use to represent the same set of options.  */</span>
<a name="l00358"></a>00358 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00359"></a>00359 opt_from_option_mask (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> option_mask)
<a name="l00360"></a>00360 {
<a name="l00361"></a>00361   <span class="comment">/* A table mapping OPT register bits onto CGEN config map option</span>
<a name="l00362"></a>00362 <span class="comment">     bits.  */</span>
<a name="l00363"></a>00363   <span class="keyword">struct </span>{
<a name="l00364"></a>00364     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> opt_bit, option_mask_bit;
<a name="l00365"></a>00365   } <a class="code" href="arm-tdep_8c.html#a6d53921cd0f216408c4aed2806a0cb1f">bits</a>[] = {
<a name="l00366"></a>00366     { <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa7fbabd3d2fb9332e7bb9fca83efa76d8">MEP_OPT_DIV</a>, 1 &lt;&lt; CGEN_INSN_OPTIONAL_DIV_INSN },
<a name="l00367"></a>00367     { <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa6f7fa9c39a21cafdc26ad75d07d3a643">MEP_OPT_MUL</a>, 1 &lt;&lt; CGEN_INSN_OPTIONAL_MUL_INSN },
<a name="l00368"></a>00368     { <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa7fbabd3d2fb9332e7bb9fca83efa76d8">MEP_OPT_DIV</a>, 1 &lt;&lt; CGEN_INSN_OPTIONAL_DIV_INSN },
<a name="l00369"></a>00369     { <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caad0375c349f1e1c51d1395285cfcd7979">MEP_OPT_DBG</a>, 1 &lt;&lt; CGEN_INSN_OPTIONAL_DEBUG_INSN },
<a name="l00370"></a>00370     { <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caafa5555b29095803c75777ff0ba62237d">MEP_OPT_LDZ</a>, 1 &lt;&lt; CGEN_INSN_OPTIONAL_LDZ_INSN },
<a name="l00371"></a>00371     { <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caae04aa5eef0b80198971c1890cafb5fc2">MEP_OPT_ABS</a>, 1 &lt;&lt; CGEN_INSN_OPTIONAL_ABS_INSN },
<a name="l00372"></a>00372     { <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caac9a129c6c15baedf87eec0c4dda88056">MEP_OPT_AVE</a>, 1 &lt;&lt; CGEN_INSN_OPTIONAL_AVE_INSN },
<a name="l00373"></a>00373     { <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caab4fecc5924b1038f143df6c3dc37987f">MEP_OPT_MIN</a>, 1 &lt;&lt; CGEN_INSN_OPTIONAL_MINMAX_INSN },
<a name="l00374"></a>00374     { <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caab75e2691f11e4350c24da6abc04fcd47">MEP_OPT_CLP</a>, 1 &lt;&lt; CGEN_INSN_OPTIONAL_CLIP_INSN },
<a name="l00375"></a>00375     { <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa515eb2813522561b49fd85f9eb4e74b3">MEP_OPT_SAT</a>, 1 &lt;&lt; CGEN_INSN_OPTIONAL_SAT_INSN },
<a name="l00376"></a>00376     { <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa751698c667e36d2ff88b5b3bbbd76938">MEP_OPT_UCI</a>, 1 &lt;&lt; CGEN_INSN_OPTIONAL_UCI_INSN },
<a name="l00377"></a>00377     { <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa9fb880223d80e79b908c50ce60d9f982">MEP_OPT_DSP</a>, 1 &lt;&lt; CGEN_INSN_OPTIONAL_DSP_INSN },
<a name="l00378"></a>00378     { <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa0699c634adbc5cbca1769a66adeaebef">MEP_OPT_COP</a>, 1 &lt;&lt; CGEN_INSN_OPTIONAL_CP_INSN },
<a name="l00379"></a>00379   };
<a name="l00380"></a>00380 
<a name="l00381"></a>00381   <span class="keywordtype">int</span> i;
<a name="l00382"></a>00382   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> opt = 0;
<a name="l00383"></a>00383 
<a name="l00384"></a>00384   <span class="keywordflow">for</span> (i = 0; i &lt; (<span class="keyword">sizeof</span> (<a class="code" href="arm-tdep_8c.html#a6d53921cd0f216408c4aed2806a0cb1f">bits</a>) / <span class="keyword">sizeof</span> (<a class="code" href="arm-tdep_8c.html#a6d53921cd0f216408c4aed2806a0cb1f">bits</a>[0])); i++)
<a name="l00385"></a>00385     <span class="keywordflow">if</span> (option_mask &amp; <a class="code" href="arm-tdep_8c.html#a6d53921cd0f216408c4aed2806a0cb1f">bits</a>[i].option_mask_bit)
<a name="l00386"></a>00386       opt |= <a class="code" href="arm-tdep_8c.html#a6d53921cd0f216408c4aed2806a0cb1f">bits</a>[i].opt_bit;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388   <span class="keywordflow">return</span> opt;
<a name="l00389"></a>00389 }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 
<a name="l00392"></a>00392 <span class="comment">/* Return the value the $OPT register would use to represent the set</span>
<a name="l00393"></a>00393 <span class="comment">   of options for ME_MODULE.  */</span>
<a name="l00394"></a>00394 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00395"></a>00395 me_module_opt (CONFIG_ATTR me_module)
<a name="l00396"></a>00396 {
<a name="l00397"></a>00397   <span class="keywordflow">return</span> opt_from_option_mask (mep_config_map[me_module].option_mask);
<a name="l00398"></a>00398 }
<a name="l00399"></a>00399 
<a name="l00400"></a>00400 
<a name="l00401"></a>00401 <span class="comment">/* Return the width of ME_MODULE&#39;s coprocessor data bus, in bits.</span>
<a name="l00402"></a>00402 <span class="comment">   This is either 32 or 64.  */</span>
<a name="l00403"></a>00403 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00404"></a>00404 me_module_cop_data_bus_width (CONFIG_ATTR me_module)
<a name="l00405"></a>00405 {
<a name="l00406"></a>00406   <span class="keywordflow">if</span> (mep_config_map[me_module].option_mask
<a name="l00407"></a>00407       &amp; (1 &lt;&lt; CGEN_INSN_OPTIONAL_CP64_INSN))
<a name="l00408"></a>00408     <span class="keywordflow">return</span> 64;
<a name="l00409"></a>00409   <span class="keywordflow">else</span>
<a name="l00410"></a>00410     <span class="keywordflow">return</span> 32;
<a name="l00411"></a>00411 }
<a name="l00412"></a>00412 
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 <span class="comment">/* Return true if ME_MODULE is big-endian, false otherwise.  */</span>
<a name="l00415"></a>00415 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00416"></a>00416 me_module_big_endian (CONFIG_ATTR me_module)
<a name="l00417"></a>00417 {
<a name="l00418"></a>00418   <span class="keywordflow">return</span> mep_config_map[me_module].big_endian;
<a name="l00419"></a>00419 }
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 <span class="comment">/* Return the name of ME_MODULE, or NULL if it has no name.  */</span>
<a name="l00423"></a>00423 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00424"></a>00424 me_module_name (CONFIG_ATTR me_module)
<a name="l00425"></a>00425 {
<a name="l00426"></a>00426   <span class="comment">/* The default me_module has &quot;&quot; as its name, but it&#39;s easier for our</span>
<a name="l00427"></a>00427 <span class="comment">     callers to test for NULL.  */</span>
<a name="l00428"></a>00428   <span class="keywordflow">if</span> (! mep_config_map[me_module].<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>
<a name="l00429"></a>00429       || mep_config_map[me_module].<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>[0] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l00430"></a>00430     <span class="keywordflow">return</span> NULL;
<a name="l00431"></a>00431   <span class="keywordflow">else</span>
<a name="l00432"></a>00432     <span class="keywordflow">return</span> mep_config_map[me_module].name;
<a name="l00433"></a>00433 }
<a name="l00434"></a>00434 
<a name="l00435"></a>00435 <span class="comment">/* Register set.  */</span>
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 
<a name="l00438"></a>00438 <span class="comment">/* The MeP spec defines the following registers:</span>
<a name="l00439"></a>00439 <span class="comment">   16 general purpose registers (r0-r15) </span>
<a name="l00440"></a>00440 <span class="comment">   32 control/special registers (csr0-csr31)</span>
<a name="l00441"></a>00441 <span class="comment">   32 coprocessor general-purpose registers (c0 -- c31)</span>
<a name="l00442"></a>00442 <span class="comment">   64 coprocessor control registers (ccr0 -- ccr63)</span>
<a name="l00443"></a>00443 <span class="comment"></span>
<a name="l00444"></a>00444 <span class="comment">   For the raw registers, we assign numbers here explicitly, instead</span>
<a name="l00445"></a>00445 <span class="comment">   of letting the enum assign them for us; the numbers are a matter of</span>
<a name="l00446"></a>00446 <span class="comment">   external protocol, and shouldn&#39;t shift around as things are edited.</span>
<a name="l00447"></a>00447 <span class="comment"></span>
<a name="l00448"></a>00448 <span class="comment">   We access the control/special registers via pseudoregisters, to</span>
<a name="l00449"></a>00449 <span class="comment">   enforce read-only portions that some registers have.</span>
<a name="l00450"></a>00450 <span class="comment"></span>
<a name="l00451"></a>00451 <span class="comment">   We access the coprocessor general purpose and control registers via</span>
<a name="l00452"></a>00452 <span class="comment">   pseudoregisters, to make sure they appear in the proper order in</span>
<a name="l00453"></a>00453 <span class="comment">   the &#39;info all-registers&#39; command (which uses the register number</span>
<a name="l00454"></a>00454 <span class="comment">   ordering), and also to allow them to be renamed and resized</span>
<a name="l00455"></a>00455 <span class="comment">   depending on the me_module in use.</span>
<a name="l00456"></a>00456 <span class="comment"></span>
<a name="l00457"></a>00457 <span class="comment">   The MeP allows coprocessor general-purpose registers to be either</span>
<a name="l00458"></a>00458 <span class="comment">   32 or 64 bits long, depending on the configuration.  Since we don&#39;t</span>
<a name="l00459"></a>00459 <span class="comment">   want the format of the &#39;g&#39; packet to vary from one core to another,</span>
<a name="l00460"></a>00460 <span class="comment">   the raw coprocessor GPRs are always 64 bits.  GDB doesn&#39;t allow the</span>
<a name="l00461"></a>00461 <span class="comment">   types of registers to change (see the implementation of</span>
<a name="l00462"></a>00462 <span class="comment">   register_type), so we have four banks of pseudoregisters for the</span>
<a name="l00463"></a>00463 <span class="comment">   coprocessor gprs --- 32-bit vs. 64-bit, and integer</span>
<a name="l00464"></a>00464 <span class="comment">   vs. floating-point --- and we show or hide them depending on the</span>
<a name="l00465"></a>00465 <span class="comment">   configuration.  */</span>
<a name="l00466"></a>00466 <span class="keyword">enum</span>
<a name="l00467"></a>00467 {
<a name="l00468"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac4fcee82aa3b8fe78a7ce4cc7954b193">00468</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac4fcee82aa3b8fe78a7ce4cc7954b193">MEP_FIRST_RAW_REGNUM</a> = 0,
<a name="l00469"></a>00469 
<a name="l00470"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a9be3bbf25c57730732e93c8e39db669f">00470</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a9be3bbf25c57730732e93c8e39db669f">MEP_FIRST_GPR_REGNUM</a> = 0,
<a name="l00471"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a1d0cacc10a49c742f19431b8c2eaace6">00471</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a1d0cacc10a49c742f19431b8c2eaace6">MEP_R0_REGNUM</a> = 0,
<a name="l00472"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80acc56f4b49717da58bfc9ffa158dd5015">00472</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80acc56f4b49717da58bfc9ffa158dd5015">MEP_R1_REGNUM</a> = 1,
<a name="l00473"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a4ba750f9e80e2d8e5730e7b7bff1f4b2">00473</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a4ba750f9e80e2d8e5730e7b7bff1f4b2">MEP_R2_REGNUM</a> = 2,
<a name="l00474"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac75a4df7935ed5367362d7bace6c9c75">00474</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac75a4df7935ed5367362d7bace6c9c75">MEP_R3_REGNUM</a> = 3,
<a name="l00475"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a8b5cc0f6cb43b1571bac042b6fa57e2e">00475</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a8b5cc0f6cb43b1571bac042b6fa57e2e">MEP_R4_REGNUM</a> = 4,
<a name="l00476"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a922ab8ee470761ef3d9cb6b4dc3cf9db">00476</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a922ab8ee470761ef3d9cb6b4dc3cf9db">MEP_R5_REGNUM</a> = 5,
<a name="l00477"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aba8a82435259bd58bb1ec7fcf90a7283">00477</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aba8a82435259bd58bb1ec7fcf90a7283">MEP_R6_REGNUM</a> = 6,
<a name="l00478"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a8654d9dbf44cbf1cc69af67b85d5e539">00478</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a8654d9dbf44cbf1cc69af67b85d5e539">MEP_R7_REGNUM</a> = 7,
<a name="l00479"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab842caabd0ff57c29272ced24bb44f62">00479</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab842caabd0ff57c29272ced24bb44f62">MEP_R8_REGNUM</a> = 8,
<a name="l00480"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a109ed9e1f9d4cb6c7dce6cc6d440fb0b">00480</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a109ed9e1f9d4cb6c7dce6cc6d440fb0b">MEP_R9_REGNUM</a> = 9,
<a name="l00481"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ace4a046d31df05c5f26b93742ea854b2">00481</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ace4a046d31df05c5f26b93742ea854b2">MEP_R10_REGNUM</a> = 10,
<a name="l00482"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a61964dba3212a45e820d8d4ab74d0f26">00482</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a61964dba3212a45e820d8d4ab74d0f26">MEP_R11_REGNUM</a> = 11,
<a name="l00483"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a5a28506e6fe4144a2e3bc304f701e72e">00483</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a5a28506e6fe4144a2e3bc304f701e72e">MEP_R12_REGNUM</a> = 12,
<a name="l00484"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab8e40c2c305839597884fb849cff53b4">00484</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab8e40c2c305839597884fb849cff53b4">MEP_FP_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab842caabd0ff57c29272ced24bb44f62">MEP_R8_REGNUM</a>,
<a name="l00485"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0ae3715073c99e5f0bdc2b2b5a991dbd">00485</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0ae3715073c99e5f0bdc2b2b5a991dbd">MEP_R13_REGNUM</a> = 13,
<a name="l00486"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a87104c9af7d4ec051f500b4373e9e5a6">00486</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a87104c9af7d4ec051f500b4373e9e5a6">MEP_TP_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0ae3715073c99e5f0bdc2b2b5a991dbd">MEP_R13_REGNUM</a>,       <span class="comment">/* (r13) Tiny data pointer */</span>
<a name="l00487"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a32c6a2216a9cfda637cd02f433843533">00487</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a32c6a2216a9cfda637cd02f433843533">MEP_R14_REGNUM</a> = 14,
<a name="l00488"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80adb3f4a16b6b0a9321edb9a12ee668082">00488</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80adb3f4a16b6b0a9321edb9a12ee668082">MEP_GP_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a32c6a2216a9cfda637cd02f433843533">MEP_R14_REGNUM</a>,       <span class="comment">/* (r14) Global pointer */</span>
<a name="l00489"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a62ff2a2bd544ce7f5ff7cf545be3d905">00489</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a62ff2a2bd544ce7f5ff7cf545be3d905">MEP_R15_REGNUM</a> = 15,
<a name="l00490"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ad6caa78945d52ae1bfeba530ae2bf72e">00490</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ad6caa78945d52ae1bfeba530ae2bf72e">MEP_SP_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a62ff2a2bd544ce7f5ff7cf545be3d905">MEP_R15_REGNUM</a>,       <span class="comment">/* (r15) Stack pointer */</span>
<a name="l00491"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a747a23862740f276283ac47bb856c121">00491</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a747a23862740f276283ac47bb856c121">MEP_LAST_GPR_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a62ff2a2bd544ce7f5ff7cf545be3d905">MEP_R15_REGNUM</a>,
<a name="l00492"></a>00492 
<a name="l00493"></a>00493   <span class="comment">/* The raw control registers.  These are the values as received via</span>
<a name="l00494"></a>00494 <span class="comment">     the remote protocol, directly from the target; we only let user</span>
<a name="l00495"></a>00495 <span class="comment">     code touch the via the pseudoregisters, which enforce read-only</span>
<a name="l00496"></a>00496 <span class="comment">     bits.  */</span>
<a name="l00497"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80af0e10b2794fb4bf890dc060b6418488e">00497</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80af0e10b2794fb4bf890dc060b6418488e">MEP_FIRST_RAW_CSR_REGNUM</a> = 16,
<a name="l00498"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac93b158625c77fafde384bbc1665746b">00498</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac93b158625c77fafde384bbc1665746b">MEP_RAW_PC_REGNUM</a>    = 16,    <span class="comment">/* Program counter */</span>
<a name="l00499"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a563a5cfb076cc61b2f710543278d7d97">00499</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a563a5cfb076cc61b2f710543278d7d97">MEP_RAW_LP_REGNUM</a>    = 17,    <span class="comment">/* Link pointer */</span>
<a name="l00500"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a65ce581c1145ebea80a2536dde0d54df">00500</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a65ce581c1145ebea80a2536dde0d54df">MEP_RAW_SAR_REGNUM</a>   = 18,    <span class="comment">/* Raw shift amount */</span>
<a name="l00501"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a6cf375a68256085e1fb55dd18420fc7d">00501</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a6cf375a68256085e1fb55dd18420fc7d">MEP_RAW_CSR3_REGNUM</a>  = 19,    <span class="comment">/* csr3: reserved */</span>
<a name="l00502"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a2b72bcd81c130376599708a896030081">00502</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a2b72bcd81c130376599708a896030081">MEP_RAW_RPB_REGNUM</a>   = 20,    <span class="comment">/* Raw repeat begin address */</span>
<a name="l00503"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac4734cc5b3db2166d68355d9b79d3fe0">00503</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac4734cc5b3db2166d68355d9b79d3fe0">MEP_RAW_RPE_REGNUM</a>   = 21,    <span class="comment">/* Repeat end address */</span>
<a name="l00504"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a08a58c143a831504e3e6610be0f90fdf">00504</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a08a58c143a831504e3e6610be0f90fdf">MEP_RAW_RPC_REGNUM</a>   = 22,    <span class="comment">/* Repeat count */</span>
<a name="l00505"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a648f508d10ba5946b4f6525911d00c8c">00505</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a648f508d10ba5946b4f6525911d00c8c">MEP_RAW_HI_REGNUM</a>    = 23, <span class="comment">/* Upper 32 bits of result of 64 bit mult/div */</span>
<a name="l00506"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a23e77164cbe2380fb1097e35650ca671">00506</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a23e77164cbe2380fb1097e35650ca671">MEP_RAW_LO_REGNUM</a>    = 24, <span class="comment">/* Lower 32 bits of result of 64 bit mult/div */</span>
<a name="l00507"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80acf15a389867df230d0069d6d05b70220">00507</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80acf15a389867df230d0069d6d05b70220">MEP_RAW_CSR9_REGNUM</a>  = 25,    <span class="comment">/* csr3: reserved */</span>
<a name="l00508"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a4d403bb2ef72b3047dfe9d188985d2ce">00508</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a4d403bb2ef72b3047dfe9d188985d2ce">MEP_RAW_CSR10_REGNUM</a> = 26,    <span class="comment">/* csr3: reserved */</span>
<a name="l00509"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a68ae50d60d3e34d083dc7e0a69b6dbeb">00509</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a68ae50d60d3e34d083dc7e0a69b6dbeb">MEP_RAW_CSR11_REGNUM</a> = 27,    <span class="comment">/* csr3: reserved */</span>
<a name="l00510"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a3ce9c031737bf6e4cfc2a319a3bdddc0">00510</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a3ce9c031737bf6e4cfc2a319a3bdddc0">MEP_RAW_MB0_REGNUM</a>   = 28,    <span class="comment">/* Raw modulo begin address 0 */</span>
<a name="l00511"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ae0006c60bfd411d75421b623b163167a">00511</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ae0006c60bfd411d75421b623b163167a">MEP_RAW_ME0_REGNUM</a>   = 29,    <span class="comment">/* Raw modulo end address 0 */</span>
<a name="l00512"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a7c287d1ff3f87d3559834ea11700594c">00512</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a7c287d1ff3f87d3559834ea11700594c">MEP_RAW_MB1_REGNUM</a>   = 30,    <span class="comment">/* Raw modulo begin address 1 */</span>
<a name="l00513"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a7413fa9bf6f9f1ee30d514678504770a">00513</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a7413fa9bf6f9f1ee30d514678504770a">MEP_RAW_ME1_REGNUM</a>   = 31,    <span class="comment">/* Raw modulo end address 1 */</span>
<a name="l00514"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a1f5a4dbcdafcef6dbf1fc5fbcc7ecde5">00514</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a1f5a4dbcdafcef6dbf1fc5fbcc7ecde5">MEP_RAW_PSW_REGNUM</a>   = 32,    <span class="comment">/* Raw program status word */</span>
<a name="l00515"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aff5775e9de424e55b1c7f1019285ed1e">00515</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aff5775e9de424e55b1c7f1019285ed1e">MEP_RAW_ID_REGNUM</a>    = 33,    <span class="comment">/* Raw processor ID/revision */</span>
<a name="l00516"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a28badb3260e1316eeea2a6a0a833e17c">00516</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a28badb3260e1316eeea2a6a0a833e17c">MEP_RAW_TMP_REGNUM</a>   = 34,    <span class="comment">/* Temporary */</span>
<a name="l00517"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a06f1670fb821b835a70948420b33b775">00517</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a06f1670fb821b835a70948420b33b775">MEP_RAW_EPC_REGNUM</a>   = 35,    <span class="comment">/* Exception program counter */</span>
<a name="l00518"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0cf814536430db46a11972204310a515">00518</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0cf814536430db46a11972204310a515">MEP_RAW_EXC_REGNUM</a>   = 36,    <span class="comment">/* Raw exception cause */</span>
<a name="l00519"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a14f8407e85445d159c4ed6cff945f836">00519</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a14f8407e85445d159c4ed6cff945f836">MEP_RAW_CFG_REGNUM</a>   = 37,    <span class="comment">/* Raw processor configuration*/</span>
<a name="l00520"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ae8a231776d859a4d20325fea9089ff3a">00520</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ae8a231776d859a4d20325fea9089ff3a">MEP_RAW_CSR22_REGNUM</a> = 38,    <span class="comment">/* csr3: reserved */</span>
<a name="l00521"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0d1809ceaf4e1080350e57190dd6b98b">00521</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0d1809ceaf4e1080350e57190dd6b98b">MEP_RAW_NPC_REGNUM</a>   = 39,    <span class="comment">/* Nonmaskable interrupt PC */</span>
<a name="l00522"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aee56087cc4399c833a266d4842a3fbda">00522</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aee56087cc4399c833a266d4842a3fbda">MEP_RAW_DBG_REGNUM</a>   = 40,    <span class="comment">/* Raw debug */</span>
<a name="l00523"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a1357736bd19557cb7971af711d81cf09">00523</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a1357736bd19557cb7971af711d81cf09">MEP_RAW_DEPC_REGNUM</a>  = 41,    <span class="comment">/* Debug exception PC */</span>
<a name="l00524"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ae7f3b94aed84f1ff251872a17023e9a6">00524</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ae7f3b94aed84f1ff251872a17023e9a6">MEP_RAW_OPT_REGNUM</a>   = 42,    <span class="comment">/* Raw options */</span>
<a name="l00525"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aa264bd08b63193b556352f2c20de3b1e">00525</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aa264bd08b63193b556352f2c20de3b1e">MEP_RAW_RCFG_REGNUM</a>  = 43,    <span class="comment">/* Raw local ram config */</span>
<a name="l00526"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a84b52d15e483b85e4f066e0e405fdf4f">00526</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a84b52d15e483b85e4f066e0e405fdf4f">MEP_RAW_CCFG_REGNUM</a>  = 44,    <span class="comment">/* Raw cache config */</span>
<a name="l00527"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a3b976da15a2931985c0ceffc58b58cc4">00527</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a3b976da15a2931985c0ceffc58b58cc4">MEP_RAW_CSR29_REGNUM</a> = 45,    <span class="comment">/* csr3: reserved */</span>
<a name="l00528"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a9cb69860f69abfba52dff339f8b6fc4e">00528</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a9cb69860f69abfba52dff339f8b6fc4e">MEP_RAW_CSR30_REGNUM</a> = 46,    <span class="comment">/* csr3: reserved */</span>
<a name="l00529"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a3405391e63564f0169a546b98bb6f1ef">00529</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a3405391e63564f0169a546b98bb6f1ef">MEP_RAW_CSR31_REGNUM</a> = 47,    <span class="comment">/* csr3: reserved */</span>
<a name="l00530"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a66879b009e629c1db7b1f8db533264b6">00530</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a66879b009e629c1db7b1f8db533264b6">MEP_LAST_RAW_CSR_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a3405391e63564f0169a546b98bb6f1ef">MEP_RAW_CSR31_REGNUM</a>,
<a name="l00531"></a>00531 
<a name="l00532"></a>00532   <span class="comment">/* The raw coprocessor general-purpose registers.  These are all 64</span>
<a name="l00533"></a>00533 <span class="comment">     bits wide.  */</span>
<a name="l00534"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0f4577a74155a91f6df9204334cfb428">00534</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0f4577a74155a91f6df9204334cfb428">MEP_FIRST_RAW_CR_REGNUM</a> = 48,
<a name="l00535"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a6b022c6a316e01cc6f9e7380fb546ac2">00535</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a6b022c6a316e01cc6f9e7380fb546ac2">MEP_LAST_RAW_CR_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0f4577a74155a91f6df9204334cfb428">MEP_FIRST_RAW_CR_REGNUM</a> + 31,
<a name="l00536"></a>00536 
<a name="l00537"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a9ad9f115bea69d1344d616a0da3b71a2">00537</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a9ad9f115bea69d1344d616a0da3b71a2">MEP_FIRST_RAW_CCR_REGNUM</a> = 80,
<a name="l00538"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a79f55fccd02f526a6b9ff6c2fd5672f5">00538</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a79f55fccd02f526a6b9ff6c2fd5672f5">MEP_LAST_RAW_CCR_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a9ad9f115bea69d1344d616a0da3b71a2">MEP_FIRST_RAW_CCR_REGNUM</a> + 63,
<a name="l00539"></a>00539 
<a name="l00540"></a>00540   <span class="comment">/* The module number register.  This is the index of the me_module</span>
<a name="l00541"></a>00541 <span class="comment">     of which the current target is an instance.  (This is not a real</span>
<a name="l00542"></a>00542 <span class="comment">     MeP-specified register; it&#39;s provided by SID.)  */</span>
<a name="l00543"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a58c0f6955c37a28e6622be3d8bf907bb">00543</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a58c0f6955c37a28e6622be3d8bf907bb">MEP_MODULE_REGNUM</a>,
<a name="l00544"></a>00544 
<a name="l00545"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac2e3f0859c2920bf333544a82db6b92c">00545</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac2e3f0859c2920bf333544a82db6b92c">MEP_LAST_RAW_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a58c0f6955c37a28e6622be3d8bf907bb">MEP_MODULE_REGNUM</a>,
<a name="l00546"></a>00546 
<a name="l00547"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a907f7d5f15b707cc0a695074ff1438ba">00547</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a907f7d5f15b707cc0a695074ff1438ba">MEP_NUM_RAW_REGS</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac2e3f0859c2920bf333544a82db6b92c">MEP_LAST_RAW_REGNUM</a> + 1,
<a name="l00548"></a>00548 
<a name="l00549"></a>00549   <span class="comment">/* Pseudoregisters.  See mep_pseudo_register_read and</span>
<a name="l00550"></a>00550 <span class="comment">     mep_pseudo_register_write.  */</span>
<a name="l00551"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a81058d365c52395c25b2c84ff9ec9a6e">00551</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a81058d365c52395c25b2c84ff9ec9a6e">MEP_FIRST_PSEUDO_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a907f7d5f15b707cc0a695074ff1438ba">MEP_NUM_RAW_REGS</a>,
<a name="l00552"></a>00552 
<a name="l00553"></a>00553   <span class="comment">/* We have a pseudoregister for every control/special register, to</span>
<a name="l00554"></a>00554 <span class="comment">     implement registers with read-only bits.  */</span>
<a name="l00555"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ade498fd65c118ae4e92024132a47e55b">00555</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ade498fd65c118ae4e92024132a47e55b">MEP_FIRST_CSR_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a81058d365c52395c25b2c84ff9ec9a6e">MEP_FIRST_PSEUDO_REGNUM</a>,
<a name="l00556"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a464266bf8621c2383d30dec93302052f">00556</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a464266bf8621c2383d30dec93302052f">MEP_PC_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ade498fd65c118ae4e92024132a47e55b">MEP_FIRST_CSR_REGNUM</a>, <span class="comment">/* Program counter */</span>
<a name="l00557"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aad5bbcbfcd514d1aacf8ac13f37c08e5">00557</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aad5bbcbfcd514d1aacf8ac13f37c08e5">MEP_LP_REGNUM</a>,                <span class="comment">/* Link pointer */</span>
<a name="l00558"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a25e940dd38391bd175c7c47578562225">00558</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a25e940dd38391bd175c7c47578562225">MEP_SAR_REGNUM</a>,               <span class="comment">/* shift amount */</span>
<a name="l00559"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aee6183382c2b10df74909691e892e874">00559</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aee6183382c2b10df74909691e892e874">MEP_CSR3_REGNUM</a>,              <span class="comment">/* csr3: reserved */</span>
<a name="l00560"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a49a953cebbe5d857c179b7b4c823f089">00560</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a49a953cebbe5d857c179b7b4c823f089">MEP_RPB_REGNUM</a>,               <span class="comment">/* repeat begin address */</span>
<a name="l00561"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80adbe47e066488cc0e3dd789bbee1e1f12">00561</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80adbe47e066488cc0e3dd789bbee1e1f12">MEP_RPE_REGNUM</a>,               <span class="comment">/* Repeat end address */</span>
<a name="l00562"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a968bd17da25387ccd7698f6505d9d770">00562</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a968bd17da25387ccd7698f6505d9d770">MEP_RPC_REGNUM</a>,               <span class="comment">/* Repeat count */</span>
<a name="l00563"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a81fe07af141350ccbf98589c7930e1cc">00563</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a81fe07af141350ccbf98589c7930e1cc">MEP_HI_REGNUM</a>,  <span class="comment">/* Upper 32 bits of the result of 64 bit mult/div */</span>
<a name="l00564"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ae573bf1f7426a93d9461a727602ff69c">00564</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ae573bf1f7426a93d9461a727602ff69c">MEP_LO_REGNUM</a>,  <span class="comment">/* Lower 32 bits of the result of 64 bit mult/div */</span>
<a name="l00565"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80af71dbccef0345d9427edcfd736fe78f0">00565</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80af71dbccef0345d9427edcfd736fe78f0">MEP_CSR9_REGNUM</a>,              <span class="comment">/* csr3: reserved */</span>
<a name="l00566"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a2303c1e464ca66980e329e3a55ae17f0">00566</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a2303c1e464ca66980e329e3a55ae17f0">MEP_CSR10_REGNUM</a>,             <span class="comment">/* csr3: reserved */</span>
<a name="l00567"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aaa7ca237d78ea424221bf9196cb3e297">00567</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aaa7ca237d78ea424221bf9196cb3e297">MEP_CSR11_REGNUM</a>,             <span class="comment">/* csr3: reserved */</span>
<a name="l00568"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a4fb2ba7118de4c9815fe2b147085b9f4">00568</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a4fb2ba7118de4c9815fe2b147085b9f4">MEP_MB0_REGNUM</a>,               <span class="comment">/* modulo begin address 0 */</span>
<a name="l00569"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a629435b8b0949d67d414a21c9cc5a916">00569</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a629435b8b0949d67d414a21c9cc5a916">MEP_ME0_REGNUM</a>,               <span class="comment">/* modulo end address 0 */</span>
<a name="l00570"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a59fa894f1f28932d0555cc6f45f5f4d2">00570</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a59fa894f1f28932d0555cc6f45f5f4d2">MEP_MB1_REGNUM</a>,               <span class="comment">/* modulo begin address 1 */</span>
<a name="l00571"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0f45fc4d23a675abe1121f96b3da04dd">00571</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0f45fc4d23a675abe1121f96b3da04dd">MEP_ME1_REGNUM</a>,               <span class="comment">/* modulo end address 1 */</span>
<a name="l00572"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a1669f3815f327efd1cf23f9c5f1d6cc7">00572</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a1669f3815f327efd1cf23f9c5f1d6cc7">MEP_PSW_REGNUM</a>,               <span class="comment">/* program status word */</span>
<a name="l00573"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80adb4bf85cb82de84d85b3df95cbea4d54">00573</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80adb4bf85cb82de84d85b3df95cbea4d54">MEP_ID_REGNUM</a>,                <span class="comment">/* processor ID/revision */</span>
<a name="l00574"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a7c22f81b24c2736720f14c34fd2e6368">00574</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a7c22f81b24c2736720f14c34fd2e6368">MEP_TMP_REGNUM</a>,               <span class="comment">/* Temporary */</span>
<a name="l00575"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a283470050c5cb820a87581dd1a137756">00575</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a283470050c5cb820a87581dd1a137756">MEP_EPC_REGNUM</a>,               <span class="comment">/* Exception program counter */</span>
<a name="l00576"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a5a90dcc4447da2ee19722a8639db5d0d">00576</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a5a90dcc4447da2ee19722a8639db5d0d">MEP_EXC_REGNUM</a>,               <span class="comment">/* exception cause */</span>
<a name="l00577"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a7fcd78138dca62608da1b10fdadc1b64">00577</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a7fcd78138dca62608da1b10fdadc1b64">MEP_CFG_REGNUM</a>,               <span class="comment">/* processor configuration*/</span>
<a name="l00578"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a946213045f7d3cad7172a555e7656ba9">00578</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a946213045f7d3cad7172a555e7656ba9">MEP_CSR22_REGNUM</a>,             <span class="comment">/* csr3: reserved */</span>
<a name="l00579"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a4168b3f866b236ae0c04f273bba84d9c">00579</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a4168b3f866b236ae0c04f273bba84d9c">MEP_NPC_REGNUM</a>,               <span class="comment">/* Nonmaskable interrupt PC */</span>
<a name="l00580"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ae83906f3d1b3a9a72bb4bfb928720a6d">00580</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ae83906f3d1b3a9a72bb4bfb928720a6d">MEP_DBG_REGNUM</a>,               <span class="comment">/* debug */</span>
<a name="l00581"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a504f3073d9638ba6fe8fec798a1abe0b">00581</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a504f3073d9638ba6fe8fec798a1abe0b">MEP_DEPC_REGNUM</a>,              <span class="comment">/* Debug exception PC */</span>
<a name="l00582"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac95e146da011d9a173994ad02766540d">00582</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac95e146da011d9a173994ad02766540d">MEP_OPT_REGNUM</a>,               <span class="comment">/* options */</span>
<a name="l00583"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a443182c67b16862a197247b2f1efa05d">00583</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a443182c67b16862a197247b2f1efa05d">MEP_RCFG_REGNUM</a>,              <span class="comment">/* local ram config */</span>
<a name="l00584"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a2dbaa7ff6b66c868226674c083e20f39">00584</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a2dbaa7ff6b66c868226674c083e20f39">MEP_CCFG_REGNUM</a>,              <span class="comment">/* cache config */</span>
<a name="l00585"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a3b5973b48fd57bfb5ea0e1df93990bf7">00585</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a3b5973b48fd57bfb5ea0e1df93990bf7">MEP_CSR29_REGNUM</a>,             <span class="comment">/* csr3: reserved */</span>
<a name="l00586"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a76068ce378d5c4a6bdd2114bac6dbf45">00586</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a76068ce378d5c4a6bdd2114bac6dbf45">MEP_CSR30_REGNUM</a>,             <span class="comment">/* csr3: reserved */</span>
<a name="l00587"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac369a30b60ae1073bdea79829677af06">00587</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac369a30b60ae1073bdea79829677af06">MEP_CSR31_REGNUM</a>,             <span class="comment">/* csr3: reserved */</span>
<a name="l00588"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80af160048cb9867b6d7f0927caa86e7a34">00588</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80af160048cb9867b6d7f0927caa86e7a34">MEP_LAST_CSR_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac369a30b60ae1073bdea79829677af06">MEP_CSR31_REGNUM</a>,
<a name="l00589"></a>00589 
<a name="l00590"></a>00590   <span class="comment">/* The 32-bit integer view of the coprocessor GPR&#39;s.  */</span>
<a name="l00591"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a40c03e3200a2746793dcba5b161b15af">00591</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a40c03e3200a2746793dcba5b161b15af">MEP_FIRST_CR32_REGNUM</a>,
<a name="l00592"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0c0fa09c18d78738317a2e4a5f54f81c">00592</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0c0fa09c18d78738317a2e4a5f54f81c">MEP_LAST_CR32_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a40c03e3200a2746793dcba5b161b15af">MEP_FIRST_CR32_REGNUM</a> + 31,
<a name="l00593"></a>00593 
<a name="l00594"></a>00594   <span class="comment">/* The 32-bit floating-point view of the coprocessor GPR&#39;s.  */</span>
<a name="l00595"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a190be5d462e67c2e736b81758b618eab">00595</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a190be5d462e67c2e736b81758b618eab">MEP_FIRST_FP_CR32_REGNUM</a>,
<a name="l00596"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab264722aac900cf0fadee2d2d33347e0">00596</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab264722aac900cf0fadee2d2d33347e0">MEP_LAST_FP_CR32_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a190be5d462e67c2e736b81758b618eab">MEP_FIRST_FP_CR32_REGNUM</a> + 31,
<a name="l00597"></a>00597 
<a name="l00598"></a>00598   <span class="comment">/* The 64-bit integer view of the coprocessor GPR&#39;s.  */</span>
<a name="l00599"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a783a43b174ebaa9610e567a4d8505980">00599</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a783a43b174ebaa9610e567a4d8505980">MEP_FIRST_CR64_REGNUM</a>,
<a name="l00600"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a8a88aebeb720dafef4554b73efb77607">00600</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a8a88aebeb720dafef4554b73efb77607">MEP_LAST_CR64_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a783a43b174ebaa9610e567a4d8505980">MEP_FIRST_CR64_REGNUM</a> + 31,
<a name="l00601"></a>00601 
<a name="l00602"></a>00602   <span class="comment">/* The 64-bit floating-point view of the coprocessor GPR&#39;s.  */</span>
<a name="l00603"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80af3e3ed220bc91e8fb8f86982dbad7e61">00603</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80af3e3ed220bc91e8fb8f86982dbad7e61">MEP_FIRST_FP_CR64_REGNUM</a>,
<a name="l00604"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a6aeb94c6efe72ae7afc3cbcf63ca8df0">00604</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a6aeb94c6efe72ae7afc3cbcf63ca8df0">MEP_LAST_FP_CR64_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80af3e3ed220bc91e8fb8f86982dbad7e61">MEP_FIRST_FP_CR64_REGNUM</a> + 31,
<a name="l00605"></a>00605 
<a name="l00606"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a8b7ba3c51b2112d9f900592dc1e4f7e8">00606</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a8b7ba3c51b2112d9f900592dc1e4f7e8">MEP_FIRST_CCR_REGNUM</a>,
<a name="l00607"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a432c7b7c724418b21aea66d3a94d27a7">00607</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a432c7b7c724418b21aea66d3a94d27a7">MEP_LAST_CCR_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a8b7ba3c51b2112d9f900592dc1e4f7e8">MEP_FIRST_CCR_REGNUM</a> + 63,
<a name="l00608"></a>00608 
<a name="l00609"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a3cc49c8d41a34aaa44696b0b6a5e0195">00609</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a3cc49c8d41a34aaa44696b0b6a5e0195">MEP_LAST_PSEUDO_REGNUM</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a432c7b7c724418b21aea66d3a94d27a7">MEP_LAST_CCR_REGNUM</a>,
<a name="l00610"></a>00610 
<a name="l00611"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a64123ddbf37ca51d62c35f38cc089cb0">00611</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a64123ddbf37ca51d62c35f38cc089cb0">MEP_NUM_PSEUDO_REGS</a> = (<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a3cc49c8d41a34aaa44696b0b6a5e0195">MEP_LAST_PSEUDO_REGNUM</a> - <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac2e3f0859c2920bf333544a82db6b92c">MEP_LAST_RAW_REGNUM</a>),
<a name="l00612"></a>00612 
<a name="l00613"></a><a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab1d07718514b4d16d9c10ba999079a32">00613</a>   <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab1d07718514b4d16d9c10ba999079a32">MEP_NUM_REGS</a> = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a907f7d5f15b707cc0a695074ff1438ba">MEP_NUM_RAW_REGS</a> + <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a64123ddbf37ca51d62c35f38cc089cb0">MEP_NUM_PSEUDO_REGS</a>
<a name="l00614"></a>00614 };
<a name="l00615"></a>00615 
<a name="l00616"></a>00616 
<a name="l00617"></a><a class="code" href="mep-tdep_8c.html#afb63e50bae5f2dabb3641df497b4c73c">00617</a> <span class="preprocessor">#define IN_SET(set, n) \</span>
<a name="l00618"></a>00618 <span class="preprocessor">  (MEP_FIRST_ ## set ## _REGNUM &lt;= (n) &amp;&amp; (n) &lt;= MEP_LAST_ ## set ## _REGNUM)</span>
<a name="l00619"></a>00619 <span class="preprocessor"></span>
<a name="l00620"></a><a class="code" href="mep-tdep_8c.html#a0b4f16574ba31805d604f78812173a57">00620</a> <span class="preprocessor">#define IS_GPR_REGNUM(n)     (IN_SET (GPR,     (n)))</span>
<a name="l00621"></a><a class="code" href="mep-tdep_8c.html#a44c6013ef373eff679bfd9ca54de6895">00621</a> <span class="preprocessor"></span><span class="preprocessor">#define IS_RAW_CSR_REGNUM(n) (IN_SET (RAW_CSR, (n)))</span>
<a name="l00622"></a><a class="code" href="mep-tdep_8c.html#aa8df2226b5494967b8613decfd3eb373">00622</a> <span class="preprocessor"></span><span class="preprocessor">#define IS_RAW_CR_REGNUM(n)  (IN_SET (RAW_CR,  (n)))</span>
<a name="l00623"></a><a class="code" href="mep-tdep_8c.html#a998e0ed6ed4c48efca3e0785ae53cc12">00623</a> <span class="preprocessor"></span><span class="preprocessor">#define IS_RAW_CCR_REGNUM(n) (IN_SET (RAW_CCR, (n)))</span>
<a name="l00624"></a>00624 <span class="preprocessor"></span>
<a name="l00625"></a><a class="code" href="mep-tdep_8c.html#a49c56cb0974cffaa97ddb9cb206cdba9">00625</a> <span class="preprocessor">#define IS_CSR_REGNUM(n)     (IN_SET (CSR,     (n)))</span>
<a name="l00626"></a><a class="code" href="mep-tdep_8c.html#ae62bb5a28a432e5f99125f97b33ca2a4">00626</a> <span class="preprocessor"></span><span class="preprocessor">#define IS_CR32_REGNUM(n)    (IN_SET (CR32,    (n)))</span>
<a name="l00627"></a><a class="code" href="mep-tdep_8c.html#a8d47de27906689eb42e07894e143d7e8">00627</a> <span class="preprocessor"></span><span class="preprocessor">#define IS_FP_CR32_REGNUM(n) (IN_SET (FP_CR32, (n)))</span>
<a name="l00628"></a><a class="code" href="mep-tdep_8c.html#ae19ed32de35a70887a2e76e8f004659c">00628</a> <span class="preprocessor"></span><span class="preprocessor">#define IS_CR64_REGNUM(n)    (IN_SET (CR64,    (n)))</span>
<a name="l00629"></a><a class="code" href="mep-tdep_8c.html#ab3bbc739444f88754fe7810ec75e9a89">00629</a> <span class="preprocessor"></span><span class="preprocessor">#define IS_FP_CR64_REGNUM(n) (IN_SET (FP_CR64, (n)))</span>
<a name="l00630"></a><a class="code" href="mep-tdep_8c.html#aa0c91b19537f5b8298a046c6e1de30c4">00630</a> <span class="preprocessor"></span><span class="preprocessor">#define IS_CR_REGNUM(n)      (IS_CR32_REGNUM (n) || IS_FP_CR32_REGNUM (n) \</span>
<a name="l00631"></a>00631 <span class="preprocessor">                              || IS_CR64_REGNUM (n) || IS_FP_CR64_REGNUM (n))</span>
<a name="l00632"></a><a class="code" href="mep-tdep_8c.html#ab573faa92ca127e65a5e3cc3df5ac4fa">00632</a> <span class="preprocessor"></span><span class="preprocessor">#define IS_CCR_REGNUM(n)     (IN_SET (CCR,     (n)))</span>
<a name="l00633"></a>00633 <span class="preprocessor"></span>
<a name="l00634"></a><a class="code" href="mep-tdep_8c.html#a932c81dafddf0bb4d259515623e2b299">00634</a> <span class="preprocessor">#define IS_RAW_REGNUM(n)     (IN_SET (RAW,     (n)))</span>
<a name="l00635"></a><a class="code" href="mep-tdep_8c.html#ab22d195cfb00eeb77d05fd0c2a955ad9">00635</a> <span class="preprocessor"></span><span class="preprocessor">#define IS_PSEUDO_REGNUM(n)  (IN_SET (PSEUDO,  (n)))</span>
<a name="l00636"></a>00636 <span class="preprocessor"></span>
<a name="l00637"></a><a class="code" href="mep-tdep_8c.html#a433cd39d837ffdd4596428963127283d">00637</a> <span class="preprocessor">#define NUM_REGS_IN_SET(set) \</span>
<a name="l00638"></a>00638 <span class="preprocessor">  (MEP_LAST_ ## set ## _REGNUM - MEP_FIRST_ ## set ## _REGNUM + 1)</span>
<a name="l00639"></a>00639 <span class="preprocessor"></span>
<a name="l00640"></a><a class="code" href="mep-tdep_8c.html#aaf5a317de939ca4047f8bdac4501a8df">00640</a> <span class="preprocessor">#define MEP_GPR_SIZE (4)        </span><span class="comment">/* Size of a MeP general-purpose register.  */</span>
<a name="l00641"></a><a class="code" href="mep-tdep_8c.html#a6b7a1d00ff22a10e3867ddf126c3fabe">00641</a> <span class="preprocessor">#define MEP_PSW_SIZE (4)        </span><span class="comment">/* Size of the PSW register.  */</span>
<a name="l00642"></a><a class="code" href="mep-tdep_8c.html#acc8a163836a779e97b0ffa00d9c15ff5">00642</a> <span class="preprocessor">#define MEP_LP_SIZE (4)         </span><span class="comment">/* Size of the LP register.  */</span>
<a name="l00643"></a>00643 
<a name="l00644"></a>00644 
<a name="l00645"></a>00645 <span class="comment">/* Many of the control/special registers contain bits that cannot be</span>
<a name="l00646"></a>00646 <span class="comment">   written to; some are entirely read-only.  So we present them all as</span>
<a name="l00647"></a>00647 <span class="comment">   pseudoregisters.</span>
<a name="l00648"></a>00648 <span class="comment"></span>
<a name="l00649"></a>00649 <span class="comment">   The following table describes the special properties of each CSR.  */</span>
<a name="l00650"></a>00650 <span class="keyword">struct </span>mep_csr_register
<a name="l00651"></a>00651 {
<a name="l00652"></a>00652   <span class="comment">/* The number of this CSR&#39;s raw register.  */</span>
<a name="l00653"></a>00653   <span class="keywordtype">int</span> raw;
<a name="l00654"></a>00654 
<a name="l00655"></a>00655   <span class="comment">/* The number of this CSR&#39;s pseudoregister.  */</span>
<a name="l00656"></a>00656   <span class="keywordtype">int</span> pseudo;
<a name="l00657"></a>00657 
<a name="l00658"></a>00658   <span class="comment">/* A mask of the bits that are writeable: if a bit is set here, then</span>
<a name="l00659"></a>00659 <span class="comment">     it can be modified; if the bit is clear, then it cannot.  */</span>
<a name="l00660"></a>00660   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> writeable_bits;
<a name="l00661"></a>00661 };
<a name="l00662"></a>00662 
<a name="l00663"></a>00663 
<a name="l00664"></a>00664 <span class="comment">/* mep_csr_registers[i] describes the i&#39;th CSR.</span>
<a name="l00665"></a>00665 <span class="comment">   We just list the register numbers here explicitly to help catch</span>
<a name="l00666"></a>00666 <span class="comment">   typos.  */</span>
<a name="l00667"></a><a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">00667</a> <span class="preprocessor">#define CSR(name) MEP_RAW_ ## name ## _REGNUM, MEP_ ## name ## _REGNUM</span>
<a name="l00668"></a><a class="code" href="mep-tdep_8c.html#ab0e3d69392c3559fc7b05493b6ba732a">00668</a> <span class="preprocessor"></span><span class="keyword">struct </span>mep_csr_register <a class="code" href="mep-tdep_8c.html#ab0e3d69392c3559fc7b05493b6ba732a">mep_csr_registers</a>[] = {
<a name="l00669"></a>00669   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(<a class="code" href="mips-linux-tdep_8h.html#a600721f0222b857dc8a3ae59e5077347">PC</a>),    0xffffffff },   <span class="comment">/* manual says r/o, but we can write it */</span>
<a name="l00670"></a>00670   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(LP),    0xffffffff },
<a name="l00671"></a>00671   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(SAR),   0x0000003f },
<a name="l00672"></a>00672   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(CSR3),  0xffffffff },
<a name="l00673"></a>00673   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(RPB),   0xfffffffe },
<a name="l00674"></a>00674   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(RPE),   0xffffffff },
<a name="l00675"></a>00675   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(RPC),   0xffffffff },
<a name="l00676"></a>00676   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(HI),    0xffffffff },
<a name="l00677"></a>00677   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(LO),    0xffffffff },
<a name="l00678"></a>00678   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(CSR9),  0xffffffff },
<a name="l00679"></a>00679   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(CSR10), 0xffffffff },
<a name="l00680"></a>00680   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(CSR11), 0xffffffff },
<a name="l00681"></a>00681   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(MB0),   0x0000ffff },
<a name="l00682"></a>00682   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(ME0),   0x0000ffff },
<a name="l00683"></a>00683   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(MB1),   0x0000ffff },
<a name="l00684"></a>00684   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(ME1),   0x0000ffff },
<a name="l00685"></a>00685   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(PSW),   0x000003ff },
<a name="l00686"></a>00686   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(ID),    0x00000000 },
<a name="l00687"></a>00687   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(TMP),   0xffffffff },
<a name="l00688"></a>00688   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(EPC),   0xffffffff },
<a name="l00689"></a>00689   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(EXC),   0x000030f0 },
<a name="l00690"></a>00690   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(CFG),   0x00c0001b },
<a name="l00691"></a>00691   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(CSR22), 0xffffffff },
<a name="l00692"></a>00692   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(NPC),   0xffffffff },
<a name="l00693"></a>00693   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(DBG),   0x00000580 },
<a name="l00694"></a>00694   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(DEPC),  0xffffffff },
<a name="l00695"></a>00695   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(OPT),   0x00000000 },
<a name="l00696"></a>00696   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(RCFG),  0x00000000 },
<a name="l00697"></a>00697   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(CCFG),  0x00000000 },
<a name="l00698"></a>00698   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(CSR29), 0xffffffff },
<a name="l00699"></a>00699   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(CSR30), 0xffffffff },
<a name="l00700"></a>00700   { <a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>(CSR31), 0xffffffff },
<a name="l00701"></a>00701 };
<a name="l00702"></a>00702 
<a name="l00703"></a>00703 
<a name="l00704"></a>00704 <span class="comment">/* If R is the number of a raw register, then mep_raw_to_pseudo[R] is</span>
<a name="l00705"></a>00705 <span class="comment">   the number of the corresponding pseudoregister.  Otherwise,</span>
<a name="l00706"></a>00706 <span class="comment">   mep_raw_to_pseudo[R] == R.  */</span>
<a name="l00707"></a>00707 <span class="keyword">static</span> <span class="keywordtype">int</span> mep_raw_to_pseudo[<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab1d07718514b4d16d9c10ba999079a32">MEP_NUM_REGS</a>];
<a name="l00708"></a>00708 
<a name="l00709"></a>00709 <span class="comment">/* If R is the number of a pseudoregister, then mep_pseudo_to_raw[R]</span>
<a name="l00710"></a>00710 <span class="comment">   is the number of the underlying raw register.  Otherwise</span>
<a name="l00711"></a>00711 <span class="comment">   mep_pseudo_to_raw[R] == R.  */</span>
<a name="l00712"></a>00712 <span class="keyword">static</span> <span class="keywordtype">int</span> mep_pseudo_to_raw[<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab1d07718514b4d16d9c10ba999079a32">MEP_NUM_REGS</a>];
<a name="l00713"></a>00713 
<a name="l00714"></a>00714 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00715"></a>00715 mep_init_pseudoregister_maps (<span class="keywordtype">void</span>)
<a name="l00716"></a>00716 {
<a name="l00717"></a>00717   <span class="keywordtype">int</span> i;
<a name="l00718"></a>00718 
<a name="l00719"></a>00719   <span class="comment">/* Verify that mep_csr_registers covers all the CSRs, in order.  */</span>
<a name="l00720"></a>00720   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (ARRAY_SIZE (mep_csr_registers) == <a class="code" href="mep-tdep_8c.html#a433cd39d837ffdd4596428963127283d">NUM_REGS_IN_SET</a> (<a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>));
<a name="l00721"></a>00721   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (ARRAY_SIZE (mep_csr_registers) == <a class="code" href="mep-tdep_8c.html#a433cd39d837ffdd4596428963127283d">NUM_REGS_IN_SET</a> (RAW_CSR));
<a name="l00722"></a>00722 
<a name="l00723"></a>00723   <span class="comment">/* Verify that the raw and pseudo ranges have matching sizes.  */</span>
<a name="l00724"></a>00724   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="mep-tdep_8c.html#a433cd39d837ffdd4596428963127283d">NUM_REGS_IN_SET</a> (RAW_CSR) == <a class="code" href="mep-tdep_8c.html#a433cd39d837ffdd4596428963127283d">NUM_REGS_IN_SET</a> (<a class="code" href="mep-tdep_8c.html#aeb103b4fdf6c5d66925c3021c3607d8f">CSR</a>));
<a name="l00725"></a>00725   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="mep-tdep_8c.html#a433cd39d837ffdd4596428963127283d">NUM_REGS_IN_SET</a> (RAW_CR)  == <a class="code" href="mep-tdep_8c.html#a433cd39d837ffdd4596428963127283d">NUM_REGS_IN_SET</a> (CR32));
<a name="l00726"></a>00726   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="mep-tdep_8c.html#a433cd39d837ffdd4596428963127283d">NUM_REGS_IN_SET</a> (RAW_CR)  == <a class="code" href="mep-tdep_8c.html#a433cd39d837ffdd4596428963127283d">NUM_REGS_IN_SET</a> (CR64));
<a name="l00727"></a>00727   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="mep-tdep_8c.html#a433cd39d837ffdd4596428963127283d">NUM_REGS_IN_SET</a> (RAW_CCR) == <a class="code" href="mep-tdep_8c.html#a433cd39d837ffdd4596428963127283d">NUM_REGS_IN_SET</a> (CCR));
<a name="l00728"></a>00728 
<a name="l00729"></a>00729   <span class="keywordflow">for</span> (i = 0; i &lt; ARRAY_SIZE (mep_csr_registers); i++)
<a name="l00730"></a>00730     {
<a name="l00731"></a>00731       <span class="keyword">struct </span>mep_csr_register *r = &amp;mep_csr_registers[i];
<a name="l00732"></a>00732 
<a name="l00733"></a>00733       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (r-&gt;pseudo == <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ade498fd65c118ae4e92024132a47e55b">MEP_FIRST_CSR_REGNUM</a> + i);
<a name="l00734"></a>00734       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (r-&gt;raw    == <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80af0e10b2794fb4bf890dc060b6418488e">MEP_FIRST_RAW_CSR_REGNUM</a> + i);
<a name="l00735"></a>00735     }
<a name="l00736"></a>00736 
<a name="l00737"></a>00737   <span class="comment">/* Set up the initial  raw&lt;-&gt;pseudo mappings.  */</span>
<a name="l00738"></a>00738   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab1d07718514b4d16d9c10ba999079a32">MEP_NUM_REGS</a>; i++)
<a name="l00739"></a>00739     {
<a name="l00740"></a>00740       mep_raw_to_pseudo[i] = i;
<a name="l00741"></a>00741       mep_pseudo_to_raw[i] = i;
<a name="l00742"></a>00742     }
<a name="l00743"></a>00743 
<a name="l00744"></a>00744   <span class="comment">/* Add the CSR raw&lt;-&gt;pseudo mappings.  */</span>
<a name="l00745"></a>00745   <span class="keywordflow">for</span> (i = 0; i &lt; ARRAY_SIZE (mep_csr_registers); i++)
<a name="l00746"></a>00746     {
<a name="l00747"></a>00747       <span class="keyword">struct </span>mep_csr_register *r = &amp;mep_csr_registers[i];
<a name="l00748"></a>00748 
<a name="l00749"></a>00749       mep_raw_to_pseudo[r-&gt;raw] = r-&gt;pseudo;
<a name="l00750"></a>00750       mep_pseudo_to_raw[r-&gt;pseudo] = r-&gt;raw;
<a name="l00751"></a>00751     }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753   <span class="comment">/* Add the CR raw&lt;-&gt;pseudo mappings.  */</span>
<a name="l00754"></a>00754   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="mep-tdep_8c.html#a433cd39d837ffdd4596428963127283d">NUM_REGS_IN_SET</a> (RAW_CR); i++)
<a name="l00755"></a>00755     {
<a name="l00756"></a>00756       <span class="keywordtype">int</span> raw = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a0f4577a74155a91f6df9204334cfb428">MEP_FIRST_RAW_CR_REGNUM</a> + i;
<a name="l00757"></a>00757       <span class="keywordtype">int</span> pseudo32 = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a40c03e3200a2746793dcba5b161b15af">MEP_FIRST_CR32_REGNUM</a> + i;
<a name="l00758"></a>00758       <span class="keywordtype">int</span> pseudofp32 = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a190be5d462e67c2e736b81758b618eab">MEP_FIRST_FP_CR32_REGNUM</a> + i;
<a name="l00759"></a>00759       <span class="keywordtype">int</span> pseudo64 = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a783a43b174ebaa9610e567a4d8505980">MEP_FIRST_CR64_REGNUM</a> + i;
<a name="l00760"></a>00760       <span class="keywordtype">int</span> pseudofp64 = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80af3e3ed220bc91e8fb8f86982dbad7e61">MEP_FIRST_FP_CR64_REGNUM</a> + i;
<a name="l00761"></a>00761 
<a name="l00762"></a>00762       <span class="comment">/* Truly, the raw-&gt;pseudo mapping depends on the current module.</span>
<a name="l00763"></a>00763 <span class="comment">         But we use the raw-&gt;pseudo mapping when we read the debugging</span>
<a name="l00764"></a>00764 <span class="comment">         info; at that point, we don&#39;t know what module we&#39;ll actually</span>
<a name="l00765"></a>00765 <span class="comment">         be running yet.  So, we always supply the 64-bit register</span>
<a name="l00766"></a>00766 <span class="comment">         numbers; GDB knows how to pick a smaller value out of a</span>
<a name="l00767"></a>00767 <span class="comment">         larger register properly.  */</span>
<a name="l00768"></a>00768       mep_raw_to_pseudo[raw] = pseudo64;
<a name="l00769"></a>00769       mep_pseudo_to_raw[pseudo32] = raw;
<a name="l00770"></a>00770       mep_pseudo_to_raw[pseudofp32] = raw;
<a name="l00771"></a>00771       mep_pseudo_to_raw[pseudo64] = raw;
<a name="l00772"></a>00772       mep_pseudo_to_raw[pseudofp64] = raw;
<a name="l00773"></a>00773     }
<a name="l00774"></a>00774 
<a name="l00775"></a>00775   <span class="comment">/* Add the CCR raw&lt;-&gt;pseudo mappings.  */</span>
<a name="l00776"></a>00776   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="mep-tdep_8c.html#a433cd39d837ffdd4596428963127283d">NUM_REGS_IN_SET</a> (CCR); i++)
<a name="l00777"></a>00777     {
<a name="l00778"></a>00778       <span class="keywordtype">int</span> raw = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a9ad9f115bea69d1344d616a0da3b71a2">MEP_FIRST_RAW_CCR_REGNUM</a> + i;
<a name="l00779"></a>00779       <span class="keywordtype">int</span> pseudo = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a8b7ba3c51b2112d9f900592dc1e4f7e8">MEP_FIRST_CCR_REGNUM</a> + i;
<a name="l00780"></a>00780       mep_raw_to_pseudo[raw] = pseudo;
<a name="l00781"></a>00781       mep_pseudo_to_raw[pseudo] = raw;
<a name="l00782"></a>00782     }
<a name="l00783"></a>00783 }
<a name="l00784"></a>00784 
<a name="l00785"></a>00785 
<a name="l00786"></a>00786 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00787"></a>00787 mep_debug_reg_to_regnum (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> debug_reg)
<a name="l00788"></a>00788 {
<a name="l00789"></a>00789   <span class="comment">/* The debug info uses the raw register numbers.  */</span>
<a name="l00790"></a>00790   <span class="keywordflow">return</span> mep_raw_to_pseudo[debug_reg];
<a name="l00791"></a>00791 }
<a name="l00792"></a>00792 
<a name="l00793"></a>00793 
<a name="l00794"></a>00794 <span class="comment">/* Return the size, in bits, of the coprocessor pseudoregister</span>
<a name="l00795"></a>00795 <span class="comment">   numbered PSEUDO.  */</span>
<a name="l00796"></a>00796 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00797"></a>00797 mep_pseudo_cr_size (<span class="keywordtype">int</span> pseudo)
<a name="l00798"></a>00798 {
<a name="l00799"></a>00799   <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#ae62bb5a28a432e5f99125f97b33ca2a4">IS_CR32_REGNUM</a> (pseudo)
<a name="l00800"></a>00800       || <a class="code" href="mep-tdep_8c.html#a8d47de27906689eb42e07894e143d7e8">IS_FP_CR32_REGNUM</a> (pseudo))
<a name="l00801"></a>00801     <span class="keywordflow">return</span> 32;
<a name="l00802"></a>00802   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#ae19ed32de35a70887a2e76e8f004659c">IS_CR64_REGNUM</a> (pseudo)
<a name="l00803"></a>00803            || <a class="code" href="mep-tdep_8c.html#ab3bbc739444f88754fe7810ec75e9a89">IS_FP_CR64_REGNUM</a> (pseudo))
<a name="l00804"></a>00804     <span class="keywordflow">return</span> 64;
<a name="l00805"></a>00805   <span class="keywordflow">else</span>
<a name="l00806"></a>00806     <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;unexpected coprocessor pseudo register&quot;</span>);
<a name="l00807"></a>00807 }
<a name="l00808"></a>00808 
<a name="l00809"></a>00809 
<a name="l00810"></a>00810 <span class="comment">/* If the coprocessor pseudoregister numbered PSEUDO is a</span>
<a name="l00811"></a>00811 <span class="comment">   floating-point register, return non-zero; if it is an integer</span>
<a name="l00812"></a>00812 <span class="comment">   register, return zero.  */</span>
<a name="l00813"></a>00813 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00814"></a>00814 mep_pseudo_cr_is_float (<span class="keywordtype">int</span> pseudo)
<a name="l00815"></a>00815 {
<a name="l00816"></a>00816   <span class="keywordflow">return</span> (<a class="code" href="mep-tdep_8c.html#a8d47de27906689eb42e07894e143d7e8">IS_FP_CR32_REGNUM</a> (pseudo)
<a name="l00817"></a>00817           || <a class="code" href="mep-tdep_8c.html#ab3bbc739444f88754fe7810ec75e9a89">IS_FP_CR64_REGNUM</a> (pseudo));
<a name="l00818"></a>00818 }
<a name="l00819"></a>00819 
<a name="l00820"></a>00820 
<a name="l00821"></a>00821 <span class="comment">/* Given a coprocessor GPR pseudoregister number, return its index</span>
<a name="l00822"></a>00822 <span class="comment">   within that register bank.  */</span>
<a name="l00823"></a>00823 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00824"></a>00824 mep_pseudo_cr_index (<span class="keywordtype">int</span> pseudo)
<a name="l00825"></a>00825 {
<a name="l00826"></a>00826   <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#ae62bb5a28a432e5f99125f97b33ca2a4">IS_CR32_REGNUM</a> (pseudo))
<a name="l00827"></a>00827     <span class="keywordflow">return</span> pseudo - <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a40c03e3200a2746793dcba5b161b15af">MEP_FIRST_CR32_REGNUM</a>;
<a name="l00828"></a>00828   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#a8d47de27906689eb42e07894e143d7e8">IS_FP_CR32_REGNUM</a> (pseudo))
<a name="l00829"></a>00829       <span class="keywordflow">return</span> pseudo - <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a190be5d462e67c2e736b81758b618eab">MEP_FIRST_FP_CR32_REGNUM</a>;
<a name="l00830"></a>00830   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#ae19ed32de35a70887a2e76e8f004659c">IS_CR64_REGNUM</a> (pseudo))
<a name="l00831"></a>00831       <span class="keywordflow">return</span> pseudo - <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a783a43b174ebaa9610e567a4d8505980">MEP_FIRST_CR64_REGNUM</a>;
<a name="l00832"></a>00832   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#ab3bbc739444f88754fe7810ec75e9a89">IS_FP_CR64_REGNUM</a> (pseudo))
<a name="l00833"></a>00833       <span class="keywordflow">return</span> pseudo - <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80af3e3ed220bc91e8fb8f86982dbad7e61">MEP_FIRST_FP_CR64_REGNUM</a>;
<a name="l00834"></a>00834   <span class="keywordflow">else</span>
<a name="l00835"></a>00835     <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;unexpected coprocessor pseudo register&quot;</span>);
<a name="l00836"></a>00836 }
<a name="l00837"></a>00837 
<a name="l00838"></a>00838 
<a name="l00839"></a>00839 <span class="comment">/* Return the me_module index describing the current target.</span>
<a name="l00840"></a>00840 <span class="comment"></span>
<a name="l00841"></a>00841 <span class="comment">   If the current target has registers (e.g., simulator, remote</span>
<a name="l00842"></a>00842 <span class="comment">   target), then this uses the value of the &#39;module&#39; register, raw</span>
<a name="l00843"></a>00843 <span class="comment">   register MEP_MODULE_REGNUM.  Otherwise, this retrieves the value</span>
<a name="l00844"></a>00844 <span class="comment">   from the ELF header&#39;s e_flags field of the current executable</span>
<a name="l00845"></a>00845 <span class="comment">   file.  */</span>
<a name="l00846"></a>00846 <span class="keyword">static</span> CONFIG_ATTR
<a name="l00847"></a>00847 current_me_module (<span class="keywordtype">void</span>)
<a name="l00848"></a>00848 {
<a name="l00849"></a>00849   <span class="keywordflow">if</span> (<a class="code" href="target_8h.html#aa9a1009541e63ce36c030b1bd55d292d">target_has_registers</a>)
<a name="l00850"></a>00850     {
<a name="l00851"></a>00851       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> regval;
<a name="l00852"></a>00852       <a class="code" href="regcache_8c.html#a959a077d769de1641d4f9754cc7b4a1f">regcache_cooked_read_unsigned</a> (<a class="code" href="regcache_8c.html#a09a386286dc22d882378f639630fecef">get_current_regcache</a> (),
<a name="l00853"></a>00853                                      <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a58c0f6955c37a28e6622be3d8bf907bb">MEP_MODULE_REGNUM</a>, &amp;regval);
<a name="l00854"></a>00854       <span class="keywordflow">return</span> regval;
<a name="l00855"></a>00855     }
<a name="l00856"></a>00856   <span class="keywordflow">else</span>
<a name="l00857"></a>00857     <span class="keywordflow">return</span> <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ())-&gt;<a class="code" href="structgdbarch__tdep.html#a19f7f93966ab0c170dce987f0f510ad7">me_module</a>;
<a name="l00858"></a>00858 }
<a name="l00859"></a>00859 
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 <span class="comment">/* Return the set of options for the current target, in the form that</span>
<a name="l00862"></a>00862 <span class="comment">   the OPT register would use.</span>
<a name="l00863"></a>00863 <span class="comment"></span>
<a name="l00864"></a>00864 <span class="comment">   If the current target has registers (e.g., simulator, remote</span>
<a name="l00865"></a>00865 <span class="comment">   target), then this is the actual value of the OPT register.  If the</span>
<a name="l00866"></a>00866 <span class="comment">   current target does not have registers (e.g., an executable file),</span>
<a name="l00867"></a>00867 <span class="comment">   then use the &#39;module_opt&#39; field we computed when we build the</span>
<a name="l00868"></a>00868 <span class="comment">   gdbarch object for this module.  */</span>
<a name="l00869"></a>00869 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l00870"></a>00870 current_options (<span class="keywordtype">void</span>)
<a name="l00871"></a>00871 {
<a name="l00872"></a>00872   <span class="keywordflow">if</span> (<a class="code" href="target_8h.html#aa9a1009541e63ce36c030b1bd55d292d">target_has_registers</a>)
<a name="l00873"></a>00873     {
<a name="l00874"></a>00874       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> regval;
<a name="l00875"></a>00875       <a class="code" href="regcache_8c.html#a959a077d769de1641d4f9754cc7b4a1f">regcache_cooked_read_unsigned</a> (<a class="code" href="regcache_8c.html#a09a386286dc22d882378f639630fecef">get_current_regcache</a> (),
<a name="l00876"></a>00876                                      <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ac95e146da011d9a173994ad02766540d">MEP_OPT_REGNUM</a>, &amp;regval);
<a name="l00877"></a>00877       <span class="keywordflow">return</span> regval;
<a name="l00878"></a>00878     }
<a name="l00879"></a>00879   <span class="keywordflow">else</span>
<a name="l00880"></a>00880     <span class="keywordflow">return</span> me_module_opt (current_me_module ());
<a name="l00881"></a>00881 }
<a name="l00882"></a>00882 
<a name="l00883"></a>00883 
<a name="l00884"></a>00884 <span class="comment">/* Return the width of the current me_module&#39;s coprocessor data bus,</span>
<a name="l00885"></a>00885 <span class="comment">   in bits.  This is either 32 or 64.  */</span>
<a name="l00886"></a>00886 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00887"></a>00887 current_cop_data_bus_width (<span class="keywordtype">void</span>)
<a name="l00888"></a>00888 {
<a name="l00889"></a>00889   <span class="keywordflow">return</span> me_module_cop_data_bus_width (current_me_module ());
<a name="l00890"></a>00890 }
<a name="l00891"></a>00891 
<a name="l00892"></a>00892 
<a name="l00893"></a>00893 <span class="comment">/* Return the keyword table of coprocessor general-purpose register</span>
<a name="l00894"></a>00894 <span class="comment">   names appropriate for the me_module we&#39;re dealing with.  */</span>
<a name="l00895"></a>00895 <span class="keyword">static</span> CGEN_KEYWORD *
<a name="l00896"></a>00896 current_cr_names (<span class="keywordtype">void</span>)
<a name="l00897"></a>00897 {
<a name="l00898"></a>00898   <span class="keyword">const</span> CGEN_HW_ENTRY *hw
<a name="l00899"></a>00899     = me_module_register_set (current_me_module (), <span class="stringliteral">&quot;h-cr-&quot;</span>, HW_H_CR);
<a name="l00900"></a>00900 
<a name="l00901"></a>00901   <span class="keywordflow">return</span> register_set_keyword_table (hw);
<a name="l00902"></a>00902 }
<a name="l00903"></a>00903 
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 <span class="comment">/* Return non-zero if the coprocessor general-purpose registers are</span>
<a name="l00906"></a>00906 <span class="comment">   floating-point values, zero otherwise.  */</span>
<a name="l00907"></a>00907 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00908"></a>00908 current_cr_is_float (<span class="keywordtype">void</span>)
<a name="l00909"></a>00909 {
<a name="l00910"></a>00910   <span class="keyword">const</span> CGEN_HW_ENTRY *hw
<a name="l00911"></a>00911     = me_module_register_set (current_me_module (), <span class="stringliteral">&quot;h-cr-&quot;</span>, HW_H_CR);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913   <span class="keywordflow">return</span> CGEN_ATTR_CGEN_HW_IS_FLOAT_VALUE (CGEN_HW_ATTRS (hw));
<a name="l00914"></a>00914 }
<a name="l00915"></a>00915 
<a name="l00916"></a>00916 
<a name="l00917"></a>00917 <span class="comment">/* Return the keyword table of coprocessor control register names</span>
<a name="l00918"></a>00918 <span class="comment">   appropriate for the me_module we&#39;re dealing with.  */</span>
<a name="l00919"></a>00919 <span class="keyword">static</span> CGEN_KEYWORD *
<a name="l00920"></a>00920 current_ccr_names (<span class="keywordtype">void</span>)
<a name="l00921"></a>00921 {
<a name="l00922"></a>00922   <span class="keyword">const</span> CGEN_HW_ENTRY *hw
<a name="l00923"></a>00923     = me_module_register_set (current_me_module (), <span class="stringliteral">&quot;h-ccr-&quot;</span>, HW_H_CCR);
<a name="l00924"></a>00924 
<a name="l00925"></a>00925   <span class="keywordflow">return</span> register_set_keyword_table (hw);
<a name="l00926"></a>00926 }
<a name="l00927"></a>00927 
<a name="l00928"></a>00928 
<a name="l00929"></a>00929 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00930"></a>00930 mep_register_name (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> regnr)
<a name="l00931"></a>00931 {
<a name="l00932"></a>00932   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);  
<a name="l00933"></a>00933 
<a name="l00934"></a>00934   <span class="comment">/* General-purpose registers.  */</span>
<a name="l00935"></a>00935   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *gpr_names[] = {
<a name="l00936"></a>00936     <span class="stringliteral">&quot;r0&quot;</span>,   <span class="stringliteral">&quot;r1&quot;</span>,   <span class="stringliteral">&quot;r2&quot;</span>,   <span class="stringliteral">&quot;r3&quot;</span>,   <span class="comment">/* 0 */</span>
<a name="l00937"></a>00937     <span class="stringliteral">&quot;r4&quot;</span>,   <span class="stringliteral">&quot;r5&quot;</span>,   <span class="stringliteral">&quot;r6&quot;</span>,   <span class="stringliteral">&quot;r7&quot;</span>,   <span class="comment">/* 4 */</span>
<a name="l00938"></a>00938     <span class="stringliteral">&quot;fp&quot;</span>,   <span class="stringliteral">&quot;r9&quot;</span>,   <span class="stringliteral">&quot;r10&quot;</span>,  <span class="stringliteral">&quot;r11&quot;</span>,  <span class="comment">/* 8 */</span>
<a name="l00939"></a>00939     <span class="stringliteral">&quot;r12&quot;</span>,  <span class="stringliteral">&quot;tp&quot;</span>,   <span class="stringliteral">&quot;gp&quot;</span>,   <span class="stringliteral">&quot;sp&quot;</span>    <span class="comment">/* 12 */</span>
<a name="l00940"></a>00940   };
<a name="l00941"></a>00941 
<a name="l00942"></a>00942   <span class="comment">/* Special-purpose registers.  */</span>
<a name="l00943"></a>00943   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *csr_names[] = {
<a name="l00944"></a>00944     <span class="stringliteral">&quot;pc&quot;</span>,   <span class="stringliteral">&quot;lp&quot;</span>,   <span class="stringliteral">&quot;sar&quot;</span>,  <span class="stringliteral">&quot;&quot;</span>,     <span class="comment">/* 0  csr3: reserved */</span> 
<a name="l00945"></a>00945     <span class="stringliteral">&quot;rpb&quot;</span>,  <span class="stringliteral">&quot;rpe&quot;</span>,  <span class="stringliteral">&quot;rpc&quot;</span>,  <span class="stringliteral">&quot;hi&quot;</span>,   <span class="comment">/* 4 */</span>
<a name="l00946"></a>00946     <span class="stringliteral">&quot;lo&quot;</span>,   <span class="stringliteral">&quot;&quot;</span>,     <span class="stringliteral">&quot;&quot;</span>,     <span class="stringliteral">&quot;&quot;</span>,     <span class="comment">/* 8  csr9-csr11: reserved */</span>
<a name="l00947"></a>00947     <span class="stringliteral">&quot;mb0&quot;</span>,  <span class="stringliteral">&quot;me0&quot;</span>,  <span class="stringliteral">&quot;mb1&quot;</span>,  <span class="stringliteral">&quot;me1&quot;</span>,  <span class="comment">/* 12 */</span>
<a name="l00948"></a>00948 
<a name="l00949"></a>00949     <span class="stringliteral">&quot;psw&quot;</span>,  <span class="stringliteral">&quot;id&quot;</span>,   <span class="stringliteral">&quot;tmp&quot;</span>,  <span class="stringliteral">&quot;epc&quot;</span>,  <span class="comment">/* 16 */</span>
<a name="l00950"></a>00950     <span class="stringliteral">&quot;exc&quot;</span>,  <span class="stringliteral">&quot;cfg&quot;</span>,  <span class="stringliteral">&quot;&quot;</span>,     <span class="stringliteral">&quot;npc&quot;</span>,  <span class="comment">/* 20  csr22: reserved */</span>
<a name="l00951"></a>00951     <span class="stringliteral">&quot;dbg&quot;</span>,  <span class="stringliteral">&quot;depc&quot;</span>, <span class="stringliteral">&quot;opt&quot;</span>,  <span class="stringliteral">&quot;rcfg&quot;</span>, <span class="comment">/* 24 */</span>
<a name="l00952"></a>00952     <span class="stringliteral">&quot;ccfg&quot;</span>, <span class="stringliteral">&quot;&quot;</span>,     <span class="stringliteral">&quot;&quot;</span>,     <span class="stringliteral">&quot;&quot;</span>      <span class="comment">/* 28  csr29-csr31: reserved */</span>
<a name="l00953"></a>00953   };
<a name="l00954"></a>00954 
<a name="l00955"></a>00955   <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#a0b4f16574ba31805d604f78812173a57">IS_GPR_REGNUM</a> (regnr))
<a name="l00956"></a>00956     <span class="keywordflow">return</span> gpr_names[regnr - <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a1d0cacc10a49c742f19431b8c2eaace6">MEP_R0_REGNUM</a>];
<a name="l00957"></a>00957   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#a49c56cb0974cffaa97ddb9cb206cdba9">IS_CSR_REGNUM</a> (regnr))
<a name="l00958"></a>00958     {
<a name="l00959"></a>00959       <span class="comment">/* The &#39;hi&#39; and &#39;lo&#39; registers are only present on processors</span>
<a name="l00960"></a>00960 <span class="comment">         that have the &#39;MUL&#39; or &#39;DIV&#39; instructions enabled.  */</span>
<a name="l00961"></a>00961       <span class="keywordflow">if</span> ((regnr == <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a81fe07af141350ccbf98589c7930e1cc">MEP_HI_REGNUM</a> || regnr == <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ae573bf1f7426a93d9461a727602ff69c">MEP_LO_REGNUM</a>)
<a name="l00962"></a>00962           &amp;&amp; (! (current_options () &amp; (<a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa6f7fa9c39a21cafdc26ad75d07d3a643">MEP_OPT_MUL</a> | <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa7fbabd3d2fb9332e7bb9fca83efa76d8">MEP_OPT_DIV</a>))))
<a name="l00963"></a>00963         <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00964"></a>00964 
<a name="l00965"></a>00965       <span class="keywordflow">return</span> csr_names[regnr - <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ade498fd65c118ae4e92024132a47e55b">MEP_FIRST_CSR_REGNUM</a>];
<a name="l00966"></a>00966     }
<a name="l00967"></a>00967   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#aa0c91b19537f5b8298a046c6e1de30c4">IS_CR_REGNUM</a> (regnr))
<a name="l00968"></a>00968     {
<a name="l00969"></a>00969       CGEN_KEYWORD *names;
<a name="l00970"></a>00970       <span class="keywordtype">int</span> cr_size;
<a name="l00971"></a>00971       <span class="keywordtype">int</span> cr_is_float;
<a name="l00972"></a>00972 
<a name="l00973"></a>00973       <span class="comment">/* Does this module have a coprocessor at all?  */</span>
<a name="l00974"></a>00974       <span class="keywordflow">if</span> (! (current_options () &amp; <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa0699c634adbc5cbca1769a66adeaebef">MEP_OPT_COP</a>))
<a name="l00975"></a>00975         <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00976"></a>00976 
<a name="l00977"></a>00977       names = current_cr_names ();
<a name="l00978"></a>00978       <span class="keywordflow">if</span> (! names)
<a name="l00979"></a>00979         <span class="comment">/* This module&#39;s coprocessor has no general-purpose registers.  */</span>
<a name="l00980"></a>00980         <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00981"></a>00981 
<a name="l00982"></a>00982       cr_size = current_cop_data_bus_width ();
<a name="l00983"></a>00983       <span class="keywordflow">if</span> (cr_size != mep_pseudo_cr_size (regnr))
<a name="l00984"></a>00984         <span class="comment">/* This module&#39;s coprocessor&#39;s GPR&#39;s are of a different size.  */</span>
<a name="l00985"></a>00985         <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00986"></a>00986 
<a name="l00987"></a>00987       cr_is_float = current_cr_is_float ();
<a name="l00988"></a>00988       <span class="comment">/* The extra ! operators ensure we get boolean equality, not</span>
<a name="l00989"></a>00989 <span class="comment">         numeric equality.  */</span>
<a name="l00990"></a>00990       <span class="keywordflow">if</span> (! cr_is_float != ! mep_pseudo_cr_is_float (regnr))
<a name="l00991"></a>00991         <span class="comment">/* This module&#39;s coprocessor&#39;s GPR&#39;s are of a different type.  */</span>
<a name="l00992"></a>00992         <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00993"></a>00993 
<a name="l00994"></a>00994       <span class="keywordflow">return</span> register_name_from_keyword (names, mep_pseudo_cr_index (regnr));
<a name="l00995"></a>00995     }
<a name="l00996"></a>00996   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#ab573faa92ca127e65a5e3cc3df5ac4fa">IS_CCR_REGNUM</a> (regnr))
<a name="l00997"></a>00997     {
<a name="l00998"></a>00998       <span class="comment">/* Does this module have a coprocessor at all?  */</span>
<a name="l00999"></a>00999       <span class="keywordflow">if</span> (! (current_options () &amp; <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa0699c634adbc5cbca1769a66adeaebef">MEP_OPT_COP</a>))
<a name="l01000"></a>01000         <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l01001"></a>01001 
<a name="l01002"></a>01002       {
<a name="l01003"></a>01003         CGEN_KEYWORD *names = current_ccr_names ();
<a name="l01004"></a>01004 
<a name="l01005"></a>01005         <span class="keywordflow">if</span> (! names)
<a name="l01006"></a>01006           <span class="comment">/* This me_module&#39;s coprocessor has no control registers.  */</span>
<a name="l01007"></a>01007           <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l01008"></a>01008 
<a name="l01009"></a>01009         <span class="keywordflow">return</span> register_name_from_keyword (names, regnr-<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a8b7ba3c51b2112d9f900592dc1e4f7e8">MEP_FIRST_CCR_REGNUM</a>);
<a name="l01010"></a>01010       }
<a name="l01011"></a>01011     }
<a name="l01012"></a>01012 
<a name="l01013"></a>01013   <span class="comment">/* It might be nice to give the &#39;module&#39; register a name, but that</span>
<a name="l01014"></a>01014 <span class="comment">     would affect the output of &#39;info all-registers&#39;, which would</span>
<a name="l01015"></a>01015 <span class="comment">     disturb the test suites.  So we leave it invisible.  */</span>
<a name="l01016"></a>01016   <span class="keywordflow">else</span>
<a name="l01017"></a>01017     <span class="keywordflow">return</span> NULL;
<a name="l01018"></a>01018 }
<a name="l01019"></a>01019 
<a name="l01020"></a>01020 
<a name="l01021"></a>01021 <span class="comment">/* Custom register groups for the MeP.  */</span>
<a name="l01022"></a>01022 <span class="keyword">static</span> <span class="keyword">struct </span>reggroup *mep_csr_reggroup; <span class="comment">/* control/special */</span>
<a name="l01023"></a>01023 <span class="keyword">static</span> <span class="keyword">struct </span>reggroup *mep_cr_reggroup;  <span class="comment">/* coprocessor general-purpose */</span>
<a name="l01024"></a>01024 <span class="keyword">static</span> <span class="keyword">struct </span>reggroup *mep_ccr_reggroup; <span class="comment">/* coprocessor control */</span>
<a name="l01025"></a>01025 
<a name="l01026"></a>01026 
<a name="l01027"></a>01027 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01028"></a>01028 mep_register_reggroup_p (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> regnum,
<a name="l01029"></a>01029                          <span class="keyword">struct</span> reggroup *group)
<a name="l01030"></a>01030 {
<a name="l01031"></a>01031   <span class="comment">/* Filter reserved or unused register numbers.  */</span>
<a name="l01032"></a>01032   {
<a name="l01033"></a>01033     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a> = mep_register_name (gdbarch, regnum);
<a name="l01034"></a>01034 
<a name="l01035"></a>01035     <span class="keywordflow">if</span> (! name || name[0] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l01036"></a>01036       <span class="keywordflow">return</span> 0;
<a name="l01037"></a>01037   }
<a name="l01038"></a>01038 
<a name="l01039"></a>01039   <span class="comment">/* We could separate the GPRs and the CSRs.  Toshiba has approved of</span>
<a name="l01040"></a>01040 <span class="comment">     the existing behavior, so we&#39;d want to run that by them.  */</span>
<a name="l01041"></a>01041   <span class="keywordflow">if</span> (group == <a class="code" href="reggroups_8c.html#a2409cc2e19cc71ae02448af0ec0308fd">general_reggroup</a>)
<a name="l01042"></a>01042     <span class="keywordflow">return</span> (<a class="code" href="mep-tdep_8c.html#a0b4f16574ba31805d604f78812173a57">IS_GPR_REGNUM</a> (regnum)
<a name="l01043"></a>01043             || <a class="code" href="mep-tdep_8c.html#a49c56cb0974cffaa97ddb9cb206cdba9">IS_CSR_REGNUM</a> (regnum));
<a name="l01044"></a>01044 
<a name="l01045"></a>01045   <span class="comment">/* Everything is in the &#39;all&#39; reggroup, except for the raw CSR&#39;s.  */</span>
<a name="l01046"></a>01046   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (group == <a class="code" href="reggroups_8c.html#a1c7760844f4c40a5fb70e84f76f39676">all_reggroup</a>)
<a name="l01047"></a>01047     <span class="keywordflow">return</span> (<a class="code" href="mep-tdep_8c.html#a0b4f16574ba31805d604f78812173a57">IS_GPR_REGNUM</a> (regnum)
<a name="l01048"></a>01048             || <a class="code" href="mep-tdep_8c.html#a49c56cb0974cffaa97ddb9cb206cdba9">IS_CSR_REGNUM</a> (regnum)
<a name="l01049"></a>01049             || <a class="code" href="mep-tdep_8c.html#aa0c91b19537f5b8298a046c6e1de30c4">IS_CR_REGNUM</a> (regnum)
<a name="l01050"></a>01050             || <a class="code" href="mep-tdep_8c.html#ab573faa92ca127e65a5e3cc3df5ac4fa">IS_CCR_REGNUM</a> (regnum));
<a name="l01051"></a>01051 
<a name="l01052"></a>01052   <span class="comment">/* All registers should be saved and restored, except for the raw</span>
<a name="l01053"></a>01053 <span class="comment">     CSR&#39;s.</span>
<a name="l01054"></a>01054 <span class="comment"></span>
<a name="l01055"></a>01055 <span class="comment">     This is probably right if the coprocessor is something like a</span>
<a name="l01056"></a>01056 <span class="comment">     floating-point unit, but would be wrong if the coprocessor is</span>
<a name="l01057"></a>01057 <span class="comment">     something that does I/O, where register accesses actually cause</span>
<a name="l01058"></a>01058 <span class="comment">     externally-visible actions.  But I get the impression that the</span>
<a name="l01059"></a>01059 <span class="comment">     coprocessor isn&#39;t supposed to do things like that --- you&#39;d use a</span>
<a name="l01060"></a>01060 <span class="comment">     hardware engine, perhaps.  */</span>
<a name="l01061"></a>01061   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (group == <a class="code" href="reggroups_8c.html#a9be54927c9d0393a70b8a3f0bc740de3">save_reggroup</a> || group == <a class="code" href="reggroups_8c.html#a627d3b74a917560e7d81d93c472e915c">restore_reggroup</a>)
<a name="l01062"></a>01062     <span class="keywordflow">return</span> (<a class="code" href="mep-tdep_8c.html#a0b4f16574ba31805d604f78812173a57">IS_GPR_REGNUM</a> (regnum)
<a name="l01063"></a>01063             || <a class="code" href="mep-tdep_8c.html#a49c56cb0974cffaa97ddb9cb206cdba9">IS_CSR_REGNUM</a> (regnum)
<a name="l01064"></a>01064             || <a class="code" href="mep-tdep_8c.html#aa0c91b19537f5b8298a046c6e1de30c4">IS_CR_REGNUM</a> (regnum)
<a name="l01065"></a>01065             || <a class="code" href="mep-tdep_8c.html#ab573faa92ca127e65a5e3cc3df5ac4fa">IS_CCR_REGNUM</a> (regnum));
<a name="l01066"></a>01066 
<a name="l01067"></a>01067   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (group == mep_csr_reggroup)
<a name="l01068"></a>01068     <span class="keywordflow">return</span> <a class="code" href="mep-tdep_8c.html#a49c56cb0974cffaa97ddb9cb206cdba9">IS_CSR_REGNUM</a> (regnum);
<a name="l01069"></a>01069   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (group == mep_cr_reggroup)
<a name="l01070"></a>01070     <span class="keywordflow">return</span> <a class="code" href="mep-tdep_8c.html#aa0c91b19537f5b8298a046c6e1de30c4">IS_CR_REGNUM</a> (regnum);
<a name="l01071"></a>01071   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (group == mep_ccr_reggroup)
<a name="l01072"></a>01072     <span class="keywordflow">return</span> <a class="code" href="mep-tdep_8c.html#ab573faa92ca127e65a5e3cc3df5ac4fa">IS_CCR_REGNUM</a> (regnum);
<a name="l01073"></a>01073   <span class="keywordflow">else</span>
<a name="l01074"></a>01074     <span class="keywordflow">return</span> 0;
<a name="l01075"></a>01075 }
<a name="l01076"></a>01076 
<a name="l01077"></a>01077 
<a name="l01078"></a>01078 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l01079"></a>01079 mep_register_type (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> reg_nr)
<a name="l01080"></a>01080 {
<a name="l01081"></a>01081   <span class="comment">/* Coprocessor general-purpose registers may be either 32 or 64 bits</span>
<a name="l01082"></a>01082 <span class="comment">     long.  So for them, the raw registers are always 64 bits long (to</span>
<a name="l01083"></a>01083 <span class="comment">     keep the &#39;g&#39; packet format fixed), and the pseudoregisters vary</span>
<a name="l01084"></a>01084 <span class="comment">     in length.  */</span>
<a name="l01085"></a>01085   <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#aa8df2226b5494967b8613decfd3eb373">IS_RAW_CR_REGNUM</a> (reg_nr))
<a name="l01086"></a>01086     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a82b181ebbb2bdb20e94beafeb3497674">builtin_uint64</a>;
<a name="l01087"></a>01087 
<a name="l01088"></a>01088   <span class="comment">/* Since GDB doesn&#39;t allow registers to change type, we have two</span>
<a name="l01089"></a>01089 <span class="comment">     banks of pseudoregisters for the coprocessor general-purpose</span>
<a name="l01090"></a>01090 <span class="comment">     registers: one that gives a 32-bit view, and one that gives a</span>
<a name="l01091"></a>01091 <span class="comment">     64-bit view.  We hide or show one or the other depending on the</span>
<a name="l01092"></a>01092 <span class="comment">     current module.  */</span>
<a name="l01093"></a>01093   <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#aa0c91b19537f5b8298a046c6e1de30c4">IS_CR_REGNUM</a> (reg_nr))
<a name="l01094"></a>01094     {
<a name="l01095"></a>01095       <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> = mep_pseudo_cr_size (reg_nr);
<a name="l01096"></a>01096       <span class="keywordflow">if</span> (size == 32)
<a name="l01097"></a>01097         {
<a name="l01098"></a>01098           <span class="keywordflow">if</span> (mep_pseudo_cr_is_float (reg_nr))
<a name="l01099"></a>01099             <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#af44abaec1868fa0a34efaab02a436d6a">builtin_float</a>;
<a name="l01100"></a>01100           <span class="keywordflow">else</span>
<a name="l01101"></a>01101             <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a7d0cf7d4e93c3cd2f1b744a18fa23b80">builtin_uint32</a>;
<a name="l01102"></a>01102         }
<a name="l01103"></a>01103       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (size == 64)
<a name="l01104"></a>01104         {
<a name="l01105"></a>01105           <span class="keywordflow">if</span> (mep_pseudo_cr_is_float (reg_nr))
<a name="l01106"></a>01106             <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a29f1e28c1aa70321c4c7d4094f672b57">builtin_double</a>;
<a name="l01107"></a>01107           <span class="keywordflow">else</span>
<a name="l01108"></a>01108             <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a82b181ebbb2bdb20e94beafeb3497674">builtin_uint64</a>;
<a name="l01109"></a>01109         }
<a name="l01110"></a>01110       <span class="keywordflow">else</span>
<a name="l01111"></a>01111         <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;unexpected cr size&quot;</span>);
<a name="l01112"></a>01112     }
<a name="l01113"></a>01113 
<a name="l01114"></a>01114   <span class="comment">/* All other registers are 32 bits long.  */</span>
<a name="l01115"></a>01115   <span class="keywordflow">else</span>
<a name="l01116"></a>01116     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a7d0cf7d4e93c3cd2f1b744a18fa23b80">builtin_uint32</a>;
<a name="l01117"></a>01117 }
<a name="l01118"></a>01118 
<a name="l01119"></a>01119 
<a name="l01120"></a>01120 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01121"></a>01121 mep_read_pc (<span class="keyword">struct</span> regcache *regcache)
<a name="l01122"></a>01122 {
<a name="l01123"></a>01123   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> pc;
<a name="l01124"></a>01124   <a class="code" href="regcache_8c.html#a959a077d769de1641d4f9754cc7b4a1f">regcache_cooked_read_unsigned</a> (regcache, <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a464266bf8621c2383d30dec93302052f">MEP_PC_REGNUM</a>, &amp;pc);
<a name="l01125"></a>01125   <span class="keywordflow">return</span> pc;
<a name="l01126"></a>01126 }
<a name="l01127"></a>01127 
<a name="l01128"></a>01128 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l01129"></a>01129 mep_pseudo_cr32_read (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l01130"></a>01130                       <span class="keyword">struct</span> regcache *regcache,
<a name="l01131"></a>01131                       <span class="keywordtype">int</span> cookednum,
<a name="l01132"></a>01132                       <span class="keywordtype">void</span> *buf)
<a name="l01133"></a>01133 {
<a name="l01134"></a>01134   <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l01135"></a>01135   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l01136"></a>01136   <span class="comment">/* Read the raw register into a 64-bit buffer, and then return the</span>
<a name="l01137"></a>01137 <span class="comment">     appropriate end of that buffer.  */</span>
<a name="l01138"></a>01138   <span class="keywordtype">int</span> rawnum = mep_pseudo_to_raw[cookednum];
<a name="l01139"></a>01139   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> buf64[8];
<a name="l01140"></a>01140 
<a name="l01141"></a>01141   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="regcache_8c.html#a90aec5037b097c4b81dbe63b54f95e96">register_type</a> (gdbarch, rawnum)) == <span class="keyword">sizeof</span> (buf64));
<a name="l01142"></a>01142   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="regcache_8c.html#a90aec5037b097c4b81dbe63b54f95e96">register_type</a> (gdbarch, cookednum)) == 4);
<a name="l01143"></a>01143   status = <a class="code" href="regcache_8c.html#a995b366cfa6f89eaa36c6e88227f3462">regcache_raw_read</a> (regcache, rawnum, buf64);
<a name="l01144"></a>01144   <span class="keywordflow">if</span> (status == <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>)
<a name="l01145"></a>01145     {
<a name="l01146"></a>01146       <span class="comment">/* Slow, but legible.  */</span>
<a name="l01147"></a>01147       <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (buf, 4, byte_order,
<a name="l01148"></a>01148                               <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf64, 8, byte_order));
<a name="l01149"></a>01149     }
<a name="l01150"></a>01150   <span class="keywordflow">return</span> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l01151"></a>01151 }
<a name="l01152"></a>01152 
<a name="l01153"></a>01153 
<a name="l01154"></a>01154 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l01155"></a>01155 mep_pseudo_cr64_read (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l01156"></a>01156                       <span class="keyword">struct</span> regcache *regcache,
<a name="l01157"></a>01157                       <span class="keywordtype">int</span> cookednum,
<a name="l01158"></a>01158                       <span class="keywordtype">void</span> *buf)
<a name="l01159"></a>01159 {
<a name="l01160"></a>01160   <span class="keywordflow">return</span> <a class="code" href="regcache_8c.html#a995b366cfa6f89eaa36c6e88227f3462">regcache_raw_read</a> (regcache, mep_pseudo_to_raw[cookednum], buf);
<a name="l01161"></a>01161 }
<a name="l01162"></a>01162 
<a name="l01163"></a>01163 
<a name="l01164"></a>01164 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l01165"></a>01165 mep_pseudo_register_read (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l01166"></a>01166                           <span class="keyword">struct</span> regcache *regcache,
<a name="l01167"></a>01167                           <span class="keywordtype">int</span> cookednum,
<a name="l01168"></a>01168                           <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l01169"></a>01169 {
<a name="l01170"></a>01170   <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#a49c56cb0974cffaa97ddb9cb206cdba9">IS_CSR_REGNUM</a> (cookednum)
<a name="l01171"></a>01171       || <a class="code" href="mep-tdep_8c.html#ab573faa92ca127e65a5e3cc3df5ac4fa">IS_CCR_REGNUM</a> (cookednum))
<a name="l01172"></a>01172     <span class="keywordflow">return</span> <a class="code" href="regcache_8c.html#a995b366cfa6f89eaa36c6e88227f3462">regcache_raw_read</a> (regcache, mep_pseudo_to_raw[cookednum], buf);
<a name="l01173"></a>01173   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#ae62bb5a28a432e5f99125f97b33ca2a4">IS_CR32_REGNUM</a> (cookednum)
<a name="l01174"></a>01174            || <a class="code" href="mep-tdep_8c.html#a8d47de27906689eb42e07894e143d7e8">IS_FP_CR32_REGNUM</a> (cookednum))
<a name="l01175"></a>01175     <span class="keywordflow">return</span> mep_pseudo_cr32_read (gdbarch, regcache, cookednum, buf);
<a name="l01176"></a>01176   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#ae19ed32de35a70887a2e76e8f004659c">IS_CR64_REGNUM</a> (cookednum)
<a name="l01177"></a>01177            || <a class="code" href="mep-tdep_8c.html#ab3bbc739444f88754fe7810ec75e9a89">IS_FP_CR64_REGNUM</a> (cookednum))
<a name="l01178"></a>01178     <span class="keywordflow">return</span> mep_pseudo_cr64_read (gdbarch, regcache, cookednum, buf);
<a name="l01179"></a>01179   <span class="keywordflow">else</span>
<a name="l01180"></a>01180     <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;unexpected pseudo register&quot;</span>);
<a name="l01181"></a>01181 }
<a name="l01182"></a>01182 
<a name="l01183"></a>01183 
<a name="l01184"></a>01184 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01185"></a>01185 mep_pseudo_csr_write (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l01186"></a>01186                       <span class="keyword">struct</span> regcache *regcache,
<a name="l01187"></a>01187                       <span class="keywordtype">int</span> cookednum,
<a name="l01188"></a>01188                       <span class="keyword">const</span> <span class="keywordtype">void</span> *buf)
<a name="l01189"></a>01189 {
<a name="l01190"></a>01190   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l01191"></a>01191   <span class="keywordtype">int</span> size = <a class="code" href="regcache_8c.html#a4c51fa25edb9ce25451b9dc7bd127aac">register_size</a> (gdbarch, cookednum);
<a name="l01192"></a>01192   <span class="keyword">struct </span>mep_csr_register *r
<a name="l01193"></a>01193     = &amp;mep_csr_registers[cookednum - <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ade498fd65c118ae4e92024132a47e55b">MEP_FIRST_CSR_REGNUM</a>];
<a name="l01194"></a>01194 
<a name="l01195"></a>01195   <span class="keywordflow">if</span> (r-&gt;writeable_bits == 0)
<a name="l01196"></a>01196     <span class="comment">/* A completely read-only register; avoid the read-modify-</span>
<a name="l01197"></a>01197 <span class="comment">       write cycle, and juts ignore the entire write.  */</span>
<a name="l01198"></a>01198     ;
<a name="l01199"></a>01199   <span class="keywordflow">else</span>
<a name="l01200"></a>01200     {
<a name="l01201"></a>01201       <span class="comment">/* A partially writeable register; do a read-modify-write cycle.  */</span>
<a name="l01202"></a>01202       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> old_bits;
<a name="l01203"></a>01203       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> new_bits;
<a name="l01204"></a>01204       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> mixed_bits;
<a name="l01205"></a>01205           
<a name="l01206"></a>01206       <a class="code" href="regcache_8c.html#a465c747dfdb94bb985d56e0374eb4481">regcache_raw_read_unsigned</a> (regcache, r-&gt;raw, &amp;old_bits);
<a name="l01207"></a>01207       new_bits = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf, size, byte_order);
<a name="l01208"></a>01208       mixed_bits = ((r-&gt;writeable_bits &amp; new_bits)
<a name="l01209"></a>01209                     | (~r-&gt;writeable_bits &amp; old_bits));
<a name="l01210"></a>01210       <a class="code" href="regcache_8c.html#aabf28852a01dbc9342b054408225d396">regcache_raw_write_unsigned</a> (regcache, r-&gt;raw, mixed_bits);
<a name="l01211"></a>01211     }
<a name="l01212"></a>01212 }
<a name="l01213"></a>01213                       
<a name="l01214"></a>01214 
<a name="l01215"></a>01215 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01216"></a>01216 mep_pseudo_cr32_write (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l01217"></a>01217                        <span class="keyword">struct</span> regcache *regcache,
<a name="l01218"></a>01218                        <span class="keywordtype">int</span> cookednum,
<a name="l01219"></a>01219                        <span class="keyword">const</span> <span class="keywordtype">void</span> *buf)
<a name="l01220"></a>01220 {
<a name="l01221"></a>01221   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l01222"></a>01222   <span class="comment">/* Expand the 32-bit value into a 64-bit value, and write that to</span>
<a name="l01223"></a>01223 <span class="comment">     the pseudoregister.  */</span>
<a name="l01224"></a>01224   <span class="keywordtype">int</span> rawnum = mep_pseudo_to_raw[cookednum];
<a name="l01225"></a>01225   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> buf64[8];
<a name="l01226"></a>01226   
<a name="l01227"></a>01227   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="regcache_8c.html#a90aec5037b097c4b81dbe63b54f95e96">register_type</a> (gdbarch, rawnum)) == <span class="keyword">sizeof</span> (buf64));
<a name="l01228"></a>01228   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="regcache_8c.html#a90aec5037b097c4b81dbe63b54f95e96">register_type</a> (gdbarch, cookednum)) == 4);
<a name="l01229"></a>01229   <span class="comment">/* Slow, but legible.  */</span>
<a name="l01230"></a>01230   <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (buf64, 8, byte_order,
<a name="l01231"></a>01231                           <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf, 4, byte_order));
<a name="l01232"></a>01232   <a class="code" href="regcache_8c.html#a1102769bb633fd84087614a3fc5c6e20">regcache_raw_write</a> (regcache, rawnum, buf64);
<a name="l01233"></a>01233 }
<a name="l01234"></a>01234 
<a name="l01235"></a>01235 
<a name="l01236"></a>01236 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01237"></a>01237 mep_pseudo_cr64_write (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l01238"></a>01238                      <span class="keyword">struct</span> regcache *regcache,
<a name="l01239"></a>01239                      <span class="keywordtype">int</span> cookednum,
<a name="l01240"></a>01240                      <span class="keyword">const</span> <span class="keywordtype">void</span> *buf)
<a name="l01241"></a>01241 {
<a name="l01242"></a>01242   <a class="code" href="regcache_8c.html#a1102769bb633fd84087614a3fc5c6e20">regcache_raw_write</a> (regcache, mep_pseudo_to_raw[cookednum], buf);
<a name="l01243"></a>01243 }
<a name="l01244"></a>01244 
<a name="l01245"></a>01245 
<a name="l01246"></a>01246 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01247"></a>01247 mep_pseudo_register_write (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l01248"></a>01248                            <span class="keyword">struct</span> regcache *regcache,
<a name="l01249"></a>01249                            <span class="keywordtype">int</span> cookednum,
<a name="l01250"></a>01250                            <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf)
<a name="l01251"></a>01251 {
<a name="l01252"></a>01252   <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#a49c56cb0974cffaa97ddb9cb206cdba9">IS_CSR_REGNUM</a> (cookednum))
<a name="l01253"></a>01253     mep_pseudo_csr_write (gdbarch, regcache, cookednum, buf);
<a name="l01254"></a>01254   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#ae62bb5a28a432e5f99125f97b33ca2a4">IS_CR32_REGNUM</a> (cookednum)
<a name="l01255"></a>01255            || <a class="code" href="mep-tdep_8c.html#a8d47de27906689eb42e07894e143d7e8">IS_FP_CR32_REGNUM</a> (cookednum))
<a name="l01256"></a>01256     mep_pseudo_cr32_write (gdbarch, regcache, cookednum, buf);
<a name="l01257"></a>01257   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#ae19ed32de35a70887a2e76e8f004659c">IS_CR64_REGNUM</a> (cookednum)
<a name="l01258"></a>01258            || <a class="code" href="mep-tdep_8c.html#ab3bbc739444f88754fe7810ec75e9a89">IS_FP_CR64_REGNUM</a> (cookednum))
<a name="l01259"></a>01259     mep_pseudo_cr64_write (gdbarch, regcache, cookednum, buf);
<a name="l01260"></a>01260   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#ab573faa92ca127e65a5e3cc3df5ac4fa">IS_CCR_REGNUM</a> (cookednum))
<a name="l01261"></a>01261     <a class="code" href="regcache_8c.html#a1102769bb633fd84087614a3fc5c6e20">regcache_raw_write</a> (regcache, mep_pseudo_to_raw[cookednum], buf);
<a name="l01262"></a>01262   <span class="keywordflow">else</span>
<a name="l01263"></a>01263     <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;unexpected pseudo register&quot;</span>);
<a name="l01264"></a>01264 }
<a name="l01265"></a>01265 
<a name="l01266"></a>01266 
<a name="l01267"></a>01267 
<a name="l01268"></a>01268 <span class="comment">/* Disassembly.  */</span>
<a name="l01269"></a>01269 
<a name="l01270"></a>01270 <span class="comment">/* The mep disassembler needs to know about the section in order to</span>
<a name="l01271"></a>01271 <span class="comment">   work correctly.  */</span>
<a name="l01272"></a>01272 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01273"></a>01273 mep_gdb_print_insn (bfd_vma pc, disassemble_info * info)
<a name="l01274"></a>01274 {
<a name="l01275"></a>01275   <span class="keyword">struct </span><a class="code" href="structobj__section.html">obj_section</a> * s = <a class="code" href="objfiles_8c.html#a458f94deb438e6e7908997a9b496674d">find_pc_section</a> (pc);
<a name="l01276"></a>01276 
<a name="l01277"></a>01277   <span class="keywordflow">if</span> (s)
<a name="l01278"></a>01278     {
<a name="l01279"></a>01279       <span class="comment">/* The libopcodes disassembly code uses the section to find the</span>
<a name="l01280"></a>01280 <span class="comment">         BFD, the BFD to find the ELF header, the ELF header to find</span>
<a name="l01281"></a>01281 <span class="comment">         the me_module index, and the me_module index to select the</span>
<a name="l01282"></a>01282 <span class="comment">         right instructions to print.  */</span>
<a name="l01283"></a>01283       info-&gt;section = s-&gt;<a class="code" href="structobj__section.html#ad233927d4d1037bde66ab9628ae82345">the_bfd_section</a>;
<a name="l01284"></a>01284       info-&gt;arch = bfd_arch_mep;
<a name="l01285"></a>01285         
<a name="l01286"></a>01286       <span class="keywordflow">return</span> print_insn_mep (pc, info);
<a name="l01287"></a>01287     }
<a name="l01288"></a>01288   
<a name="l01289"></a>01289   <span class="keywordflow">return</span> 0;
<a name="l01290"></a>01290 }
<a name="l01291"></a>01291 
<a name="l01292"></a>01292 
<a name="l01293"></a>01293 <span class="comment">/* Prologue analysis.  */</span>
<a name="l01294"></a>01294 
<a name="l01295"></a>01295 
<a name="l01296"></a>01296 <span class="comment">/* The MeP has two classes of instructions: &quot;core&quot; instructions, which</span>
<a name="l01297"></a>01297 <span class="comment">   are pretty normal RISC chip stuff, and &quot;coprocessor&quot; instructions,</span>
<a name="l01298"></a>01298 <span class="comment">   which are mostly concerned with moving data in and out of</span>
<a name="l01299"></a>01299 <span class="comment">   coprocessor registers, and branching on coprocessor condition</span>
<a name="l01300"></a>01300 <span class="comment">   codes.  There&#39;s space in the instruction set for custom coprocessor</span>
<a name="l01301"></a>01301 <span class="comment">   instructions, too.</span>
<a name="l01302"></a>01302 <span class="comment"></span>
<a name="l01303"></a>01303 <span class="comment">   Instructions can be 16 or 32 bits long; the top two bits of the</span>
<a name="l01304"></a>01304 <span class="comment">   first byte indicate the length.  The coprocessor instructions are</span>
<a name="l01305"></a>01305 <span class="comment">   mixed in with the core instructions, and there&#39;s no easy way to</span>
<a name="l01306"></a>01306 <span class="comment">   distinguish them; you have to completely decode them to tell one</span>
<a name="l01307"></a>01307 <span class="comment">   from the other.</span>
<a name="l01308"></a>01308 <span class="comment"></span>
<a name="l01309"></a>01309 <span class="comment">   The MeP also supports a &quot;VLIW&quot; operation mode, where instructions</span>
<a name="l01310"></a>01310 <span class="comment">   always occur in fixed-width bundles.  The bundles are either 32</span>
<a name="l01311"></a>01311 <span class="comment">   bits or 64 bits long, depending on a fixed configuration flag.  You</span>
<a name="l01312"></a>01312 <span class="comment">   decode the first part of the bundle as normal; if it&#39;s a core</span>
<a name="l01313"></a>01313 <span class="comment">   instruction, and there&#39;s any space left in the bundle, the</span>
<a name="l01314"></a>01314 <span class="comment">   remainder of the bundle is a coprocessor instruction, which will</span>
<a name="l01315"></a>01315 <span class="comment">   execute in parallel with the core instruction.  If the first part</span>
<a name="l01316"></a>01316 <span class="comment">   of the bundle is a coprocessor instruction, it occupies the entire</span>
<a name="l01317"></a>01317 <span class="comment">   bundle.</span>
<a name="l01318"></a>01318 <span class="comment"></span>
<a name="l01319"></a>01319 <span class="comment">   So, here are all the cases:</span>
<a name="l01320"></a>01320 <span class="comment"></span>
<a name="l01321"></a>01321 <span class="comment">   - 32-bit VLIW mode:</span>
<a name="l01322"></a>01322 <span class="comment">     Every bundle is four bytes long, and naturally aligned, and can hold</span>
<a name="l01323"></a>01323 <span class="comment">     one or two instructions:</span>
<a name="l01324"></a>01324 <span class="comment">     - 16-bit core instruction; 16-bit coprocessor instruction</span>
<a name="l01325"></a>01325 <span class="comment">       These execute in parallel.</span>
<a name="l01326"></a>01326 <span class="comment">     - 32-bit core instruction</span>
<a name="l01327"></a>01327 <span class="comment">     - 32-bit coprocessor instruction</span>
<a name="l01328"></a>01328 <span class="comment"></span>
<a name="l01329"></a>01329 <span class="comment">   - 64-bit VLIW mode:</span>
<a name="l01330"></a>01330 <span class="comment">     Every bundle is eight bytes long, and naturally aligned, and can hold</span>
<a name="l01331"></a>01331 <span class="comment">     one or two instructions:</span>
<a name="l01332"></a>01332 <span class="comment">     - 16-bit core instruction; 48-bit (!) coprocessor instruction</span>
<a name="l01333"></a>01333 <span class="comment">       These execute in parallel.</span>
<a name="l01334"></a>01334 <span class="comment">     - 32-bit core instruction; 32-bit coprocessor instruction</span>
<a name="l01335"></a>01335 <span class="comment">       These execute in parallel.</span>
<a name="l01336"></a>01336 <span class="comment">     - 64-bit coprocessor instruction</span>
<a name="l01337"></a>01337 <span class="comment"></span>
<a name="l01338"></a>01338 <span class="comment">   Now, the MeP manual doesn&#39;t define any 48- or 64-bit coprocessor</span>
<a name="l01339"></a>01339 <span class="comment">   instruction, so I don&#39;t really know what&#39;s up there; perhaps these</span>
<a name="l01340"></a>01340 <span class="comment">   are always the user-defined coprocessor instructions.  */</span>
<a name="l01341"></a>01341 
<a name="l01342"></a>01342 
<a name="l01343"></a>01343 <span class="comment">/* Return non-zero if PC is in a VLIW code section, zero</span>
<a name="l01344"></a>01344 <span class="comment">   otherwise.  */</span>
<a name="l01345"></a>01345 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01346"></a>01346 mep_pc_in_vliw_section (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc)
<a name="l01347"></a>01347 {
<a name="l01348"></a>01348   <span class="keyword">struct </span><a class="code" href="structobj__section.html">obj_section</a> *s = <a class="code" href="objfiles_8c.html#a458f94deb438e6e7908997a9b496674d">find_pc_section</a> (pc);
<a name="l01349"></a>01349   <span class="keywordflow">if</span> (s)
<a name="l01350"></a>01350     <span class="keywordflow">return</span> (s-&gt;<a class="code" href="structobj__section.html#ad233927d4d1037bde66ab9628ae82345">the_bfd_section</a>-&gt;flags &amp; SEC_MEP_VLIW);
<a name="l01351"></a>01351   <span class="keywordflow">return</span> 0;
<a name="l01352"></a>01352 }
<a name="l01353"></a>01353 
<a name="l01354"></a>01354 
<a name="l01355"></a>01355 <span class="comment">/* Set *INSN to the next core instruction at PC, and return the</span>
<a name="l01356"></a>01356 <span class="comment">   address of the next instruction.</span>
<a name="l01357"></a>01357 <span class="comment"></span>
<a name="l01358"></a>01358 <span class="comment">   The MeP instruction encoding is endian-dependent.  16- and 32-bit</span>
<a name="l01359"></a>01359 <span class="comment">   instructions are encoded as one or two two-byte parts, and each</span>
<a name="l01360"></a>01360 <span class="comment">   part is byte-swapped independently.  Thus:</span>
<a name="l01361"></a>01361 <span class="comment"></span>
<a name="l01362"></a>01362 <span class="comment">      void</span>
<a name="l01363"></a>01363 <span class="comment">      foo (void)</span>
<a name="l01364"></a>01364 <span class="comment">      {</span>
<a name="l01365"></a>01365 <span class="comment">        asm (&quot;movu $1, 0x123456&quot;);</span>
<a name="l01366"></a>01366 <span class="comment">        asm (&quot;sb $1,0x5678($2)&quot;);</span>
<a name="l01367"></a>01367 <span class="comment">        asm (&quot;clip $1, 19&quot;);</span>
<a name="l01368"></a>01368 <span class="comment">      }</span>
<a name="l01369"></a>01369 <span class="comment"></span>
<a name="l01370"></a>01370 <span class="comment">   compiles to this big-endian code:</span>
<a name="l01371"></a>01371 <span class="comment"></span>
<a name="l01372"></a>01372 <span class="comment">       0:       d1 56 12 34     movu $1,0x123456</span>
<a name="l01373"></a>01373 <span class="comment">       4:       c1 28 56 78     sb $1,22136($2)</span>
<a name="l01374"></a>01374 <span class="comment">       8:       f1 01 10 98     clip $1,0x13</span>
<a name="l01375"></a>01375 <span class="comment">       c:       70 02           ret</span>
<a name="l01376"></a>01376 <span class="comment"></span>
<a name="l01377"></a>01377 <span class="comment">   and this little-endian code:</span>
<a name="l01378"></a>01378 <span class="comment"></span>
<a name="l01379"></a>01379 <span class="comment">       0:       56 d1 34 12     movu $1,0x123456</span>
<a name="l01380"></a>01380 <span class="comment">       4:       28 c1 78 56     sb $1,22136($2)</span>
<a name="l01381"></a>01381 <span class="comment">       8:       01 f1 98 10     clip $1,0x13</span>
<a name="l01382"></a>01382 <span class="comment">       c:       02 70           ret</span>
<a name="l01383"></a>01383 <span class="comment"></span>
<a name="l01384"></a>01384 <span class="comment">   Instructions are returned in *INSN in an endian-independent form: a</span>
<a name="l01385"></a>01385 <span class="comment">   given instruction always appears in *INSN the same way, regardless</span>
<a name="l01386"></a>01386 <span class="comment">   of whether the instruction stream is big-endian or little-endian.</span>
<a name="l01387"></a>01387 <span class="comment"></span>
<a name="l01388"></a>01388 <span class="comment">   *INSN&#39;s most significant 16 bits are the first (i.e., at lower</span>
<a name="l01389"></a>01389 <span class="comment">   addresses) 16 bit part of the instruction.  Its least significant</span>
<a name="l01390"></a>01390 <span class="comment">   16 bits are the second (i.e., higher-addressed) 16 bit part of the</span>
<a name="l01391"></a>01391 <span class="comment">   instruction, or zero for a 16-bit instruction.  Both 16-bit parts</span>
<a name="l01392"></a>01392 <span class="comment">   are fetched using the current endianness.</span>
<a name="l01393"></a>01393 <span class="comment"></span>
<a name="l01394"></a>01394 <span class="comment">   So, the *INSN values for the instruction sequence above would be</span>
<a name="l01395"></a>01395 <span class="comment">   the following, in either endianness:</span>
<a name="l01396"></a>01396 <span class="comment"></span>
<a name="l01397"></a>01397 <span class="comment">       0xd1561234       movu $1,0x123456     </span>
<a name="l01398"></a>01398 <span class="comment">       0xc1285678       sb $1,22136($2)</span>
<a name="l01399"></a>01399 <span class="comment">       0xf1011098       clip $1,0x13</span>
<a name="l01400"></a>01400 <span class="comment">       0x70020000       ret</span>
<a name="l01401"></a>01401 <span class="comment"></span>
<a name="l01402"></a>01402 <span class="comment">   (In a sense, it would be more natural to return 16-bit instructions</span>
<a name="l01403"></a>01403 <span class="comment">   in the least significant 16 bits of *INSN, but that would be</span>
<a name="l01404"></a>01404 <span class="comment">   ambiguous.  In order to tell whether you&#39;re looking at a 16- or a</span>
<a name="l01405"></a>01405 <span class="comment">   32-bit instruction, you have to consult the major opcode field ---</span>
<a name="l01406"></a>01406 <span class="comment">   the most significant four bits of the instruction&#39;s first 16-bit</span>
<a name="l01407"></a>01407 <span class="comment">   part.  But if we put 16-bit instructions at the least significant</span>
<a name="l01408"></a>01408 <span class="comment">   end of *INSN, then you don&#39;t know where to find the major opcode</span>
<a name="l01409"></a>01409 <span class="comment">   field until you know if it&#39;s a 16- or a 32-bit instruction ---</span>
<a name="l01410"></a>01410 <span class="comment">   which is where we started.)</span>
<a name="l01411"></a>01411 <span class="comment"></span>
<a name="l01412"></a>01412 <span class="comment">   If PC points to a core / coprocessor bundle in a VLIW section, set</span>
<a name="l01413"></a>01413 <span class="comment">   *INSN to the core instruction, and return the address of the next</span>
<a name="l01414"></a>01414 <span class="comment">   bundle.  This has the effect of skipping the bundled coprocessor</span>
<a name="l01415"></a>01415 <span class="comment">   instruction.  That&#39;s okay, since coprocessor instructions aren&#39;t</span>
<a name="l01416"></a>01416 <span class="comment">   significant to prologue analysis --- for the time being,</span>
<a name="l01417"></a>01417 <span class="comment">   anyway.  */</span>
<a name="l01418"></a>01418 
<a name="l01419"></a>01419 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> 
<a name="l01420"></a>01420 mep_get_insn (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *insn)
<a name="l01421"></a>01421 {
<a name="l01422"></a>01422   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l01423"></a>01423   <span class="keywordtype">int</span> pc_in_vliw_section;
<a name="l01424"></a>01424   <span class="keywordtype">int</span> vliw_mode;
<a name="l01425"></a>01425   <span class="keywordtype">int</span> insn_len;
<a name="l01426"></a>01426   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> buf[2];
<a name="l01427"></a>01427 
<a name="l01428"></a>01428   *insn = 0;
<a name="l01429"></a>01429 
<a name="l01430"></a>01430   <span class="comment">/* Are we in a VLIW section?  */</span>
<a name="l01431"></a>01431   pc_in_vliw_section = mep_pc_in_vliw_section (pc);
<a name="l01432"></a>01432   <span class="keywordflow">if</span> (pc_in_vliw_section)
<a name="l01433"></a>01433     {
<a name="l01434"></a>01434       <span class="comment">/* Yes, find out which bundle size.  */</span>
<a name="l01435"></a>01435       vliw_mode = current_options () &amp; (<a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa6c2ff802b7f8b83676a3af0c386fb688">MEP_OPT_VL32</a> | <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa526876f942ce4fe9b5e5386e21aeb1ac">MEP_OPT_VL64</a>);
<a name="l01436"></a>01436 
<a name="l01437"></a>01437       <span class="comment">/* If PC is in a VLIW section, but the current core doesn&#39;t say</span>
<a name="l01438"></a>01438 <span class="comment">         that it supports either VLIW mode, then we don&#39;t have enough</span>
<a name="l01439"></a>01439 <span class="comment">         information to parse the instruction stream it contains.</span>
<a name="l01440"></a>01440 <span class="comment">         Since the &quot;undifferentiated&quot; standard core doesn&#39;t have</span>
<a name="l01441"></a>01441 <span class="comment">         either VLIW mode bit set, this could happen.</span>
<a name="l01442"></a>01442 <span class="comment"></span>
<a name="l01443"></a>01443 <span class="comment">         But it shouldn&#39;t be an error to (say) set a breakpoint in a</span>
<a name="l01444"></a>01444 <span class="comment">         VLIW section, if you know you&#39;ll never reach it.  (Perhaps</span>
<a name="l01445"></a>01445 <span class="comment">         you have a script that sets a bunch of standard breakpoints.)</span>
<a name="l01446"></a>01446 <span class="comment"></span>
<a name="l01447"></a>01447 <span class="comment">         So we&#39;ll just return zero here, and hope for the best.  */</span>
<a name="l01448"></a>01448       <span class="keywordflow">if</span> (! (vliw_mode &amp; (<a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa6c2ff802b7f8b83676a3af0c386fb688">MEP_OPT_VL32</a> | <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa526876f942ce4fe9b5e5386e21aeb1ac">MEP_OPT_VL64</a>)))
<a name="l01449"></a>01449         <span class="keywordflow">return</span> 0;
<a name="l01450"></a>01450 
<a name="l01451"></a>01451       <span class="comment">/* If both VL32 and VL64 are set, that&#39;s bogus, too.  */</span>
<a name="l01452"></a>01452       <span class="keywordflow">if</span> (vliw_mode == (<a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa6c2ff802b7f8b83676a3af0c386fb688">MEP_OPT_VL32</a> | <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa526876f942ce4fe9b5e5386e21aeb1ac">MEP_OPT_VL64</a>))
<a name="l01453"></a>01453         <span class="keywordflow">return</span> 0;
<a name="l01454"></a>01454     }
<a name="l01455"></a>01455   <span class="keywordflow">else</span>
<a name="l01456"></a>01456     vliw_mode = 0;
<a name="l01457"></a>01457 
<a name="l01458"></a>01458   <a class="code" href="corefile_8c.html#a5e0189c6f21f1c9321b379877183b819">read_memory</a> (pc, buf, <span class="keyword">sizeof</span> (buf));
<a name="l01459"></a>01459   *insn = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf, 2, byte_order) &lt;&lt; 16;
<a name="l01460"></a>01460 
<a name="l01461"></a>01461   <span class="comment">/* The major opcode --- the top four bits of the first 16-bit</span>
<a name="l01462"></a>01462 <span class="comment">     part --- indicates whether this instruction is 16 or 32 bits</span>
<a name="l01463"></a>01463 <span class="comment">     long.  All 32-bit instructions have a major opcode whose top</span>
<a name="l01464"></a>01464 <span class="comment">     two bits are 11; all the rest are 16-bit instructions.  */</span>
<a name="l01465"></a>01465   <span class="keywordflow">if</span> ((*insn &amp; 0xc0000000) == 0xc0000000)
<a name="l01466"></a>01466     {
<a name="l01467"></a>01467       <span class="comment">/* Fetch the second 16-bit part of the instruction.  */</span>
<a name="l01468"></a>01468       <a class="code" href="corefile_8c.html#a5e0189c6f21f1c9321b379877183b819">read_memory</a> (pc + 2, buf, <span class="keyword">sizeof</span> (buf));
<a name="l01469"></a>01469       *insn = *insn | <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf, 2, byte_order);
<a name="l01470"></a>01470     }
<a name="l01471"></a>01471 
<a name="l01472"></a>01472   <span class="comment">/* If we&#39;re in VLIW code, then the VLIW width determines the address</span>
<a name="l01473"></a>01473 <span class="comment">     of the next instruction.  */</span>
<a name="l01474"></a>01474   <span class="keywordflow">if</span> (vliw_mode)
<a name="l01475"></a>01475     {
<a name="l01476"></a>01476       <span class="comment">/* In 32-bit VLIW code, all bundles are 32 bits long.  We ignore the</span>
<a name="l01477"></a>01477 <span class="comment">         coprocessor half of a core / copro bundle.  */</span>
<a name="l01478"></a>01478       <span class="keywordflow">if</span> (vliw_mode == <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa6c2ff802b7f8b83676a3af0c386fb688">MEP_OPT_VL32</a>)
<a name="l01479"></a>01479         insn_len = 4;
<a name="l01480"></a>01480 
<a name="l01481"></a>01481       <span class="comment">/* In 64-bit VLIW code, all bundles are 64 bits long.  We ignore the</span>
<a name="l01482"></a>01482 <span class="comment">         coprocessor half of a core / copro bundle.  */</span>
<a name="l01483"></a>01483       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vliw_mode == <a class="code" href="mep-tdep_8c.html#a70ad55be767ca0a42c9150d24618e4caa526876f942ce4fe9b5e5386e21aeb1ac">MEP_OPT_VL64</a>)
<a name="l01484"></a>01484         insn_len = 8;
<a name="l01485"></a>01485 
<a name="l01486"></a>01486       <span class="comment">/* We&#39;d better be in either core, 32-bit VLIW, or 64-bit VLIW mode.  */</span>
<a name="l01487"></a>01487       <span class="keywordflow">else</span>
<a name="l01488"></a>01488         <a class="code" href="gdb__assert_8h.html#aa0526ecd768317edecf0b46c981cbcc0">gdb_assert_not_reached</a> (<span class="stringliteral">&quot;unexpected vliw mode&quot;</span>);
<a name="l01489"></a>01489     }
<a name="l01490"></a>01490   
<a name="l01491"></a>01491   <span class="comment">/* Otherwise, the top two bits of the major opcode are (again) what</span>
<a name="l01492"></a>01492 <span class="comment">     we need to check.  */</span>
<a name="l01493"></a>01493   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*insn &amp; 0xc0000000) == 0xc0000000)
<a name="l01494"></a>01494     insn_len = 4;
<a name="l01495"></a>01495   <span class="keywordflow">else</span>
<a name="l01496"></a>01496     insn_len = 2;
<a name="l01497"></a>01497 
<a name="l01498"></a>01498   <span class="keywordflow">return</span> pc + insn_len;
<a name="l01499"></a>01499 }
<a name="l01500"></a>01500 
<a name="l01501"></a>01501 
<a name="l01502"></a>01502 <span class="comment">/* Sign-extend the LEN-bit value N.  */</span>
<a name="l01503"></a><a class="code" href="mep-tdep_8c.html#ab8d54951f6d0ab3e094448518e9c2765">01503</a> <span class="preprocessor">#define SEXT(n, len) ((((int) (n)) ^ (1 &lt;&lt; ((len) - 1))) - (1 &lt;&lt; ((len) - 1)))</span>
<a name="l01504"></a>01504 <span class="preprocessor"></span>
<a name="l01505"></a>01505 <span class="comment">/* Return the LEN-bit field at POS from I.  */</span>
<a name="l01506"></a><a class="code" href="mep-tdep_8c.html#ae5b9f1c5985e79013e90b4abd19bbb7d">01506</a> <span class="preprocessor">#define FIELD(i, pos, len) (((i) &gt;&gt; (pos)) &amp; ((1 &lt;&lt; (len)) - 1))</span>
<a name="l01507"></a>01507 <span class="preprocessor"></span>
<a name="l01508"></a>01508 <span class="comment">/* Like FIELD, but sign-extend the field&#39;s value.  */</span>
<a name="l01509"></a><a class="code" href="mep-tdep_8c.html#a1c9c5959b5f88484e16b325f730b381e">01509</a> <span class="preprocessor">#define SFIELD(i, pos, len) (SEXT (FIELD ((i), (pos), (len)), (len)))</span>
<a name="l01510"></a>01510 <span class="preprocessor"></span>
<a name="l01511"></a>01511 
<a name="l01512"></a>01512 <span class="comment">/* Macros for decoding instructions.</span>
<a name="l01513"></a>01513 <span class="comment"></span>
<a name="l01514"></a>01514 <span class="comment">   Remember that 16-bit instructions are placed in bits 16..31 of i,</span>
<a name="l01515"></a>01515 <span class="comment">   not at the least significant end; this means that the major opcode</span>
<a name="l01516"></a>01516 <span class="comment">   field is always in the same place, regardless of the width of the</span>
<a name="l01517"></a>01517 <span class="comment">   instruction.  As a reminder of this, we show the lower 16 bits of a</span>
<a name="l01518"></a>01518 <span class="comment">   16-bit instruction as xxxx_xxxx_xxxx_xxxx.  */</span>
<a name="l01519"></a>01519 
<a name="l01520"></a>01520 <span class="comment">/* SB Rn,(Rm)                 0000_nnnn_mmmm_1000 */</span>
<a name="l01521"></a>01521 <span class="comment">/* SH Rn,(Rm)                 0000_nnnn_mmmm_1001 */</span>
<a name="l01522"></a>01522 <span class="comment">/* SW Rn,(Rm)                 0000_nnnn_mmmm_1010 */</span>
<a name="l01523"></a>01523 
<a name="l01524"></a>01524 <span class="comment">/* SW Rn,disp16(Rm)           1100_nnnn_mmmm_1010 dddd_dddd_dddd_dddd */</span>
<a name="l01525"></a><a class="code" href="mep-tdep_8c.html#aceef6e51b96fd9740241bf8204d27ffd">01525</a> <span class="preprocessor">#define IS_SW(i)              (((i) &amp; 0xf00f0000) == 0xc00a0000)</span>
<a name="l01526"></a>01526 <span class="preprocessor"></span><span class="comment">/* SB Rn,disp16(Rm)           1100_nnnn_mmmm_1000 dddd_dddd_dddd_dddd */</span>
<a name="l01527"></a><a class="code" href="mep-tdep_8c.html#abb3f6234b22b58dd742bde646157b53a">01527</a> <span class="preprocessor">#define IS_SB(i)              (((i) &amp; 0xf00f0000) == 0xc0080000)</span>
<a name="l01528"></a>01528 <span class="preprocessor"></span><span class="comment">/* SH Rn,disp16(Rm)           1100_nnnn_mmmm_1001 dddd_dddd_dddd_dddd */</span>
<a name="l01529"></a><a class="code" href="mep-tdep_8c.html#ae1b8110ef52f2604708a3bbb554f48a9">01529</a> <span class="preprocessor">#define IS_SH(i)              (((i) &amp; 0xf00f0000) == 0xc0090000)</span>
<a name="l01530"></a><a class="code" href="mep-tdep_8c.html#aac4bfb981a20369c9556c69663e5dc68">01530</a> <span class="preprocessor"></span><span class="preprocessor">#define SWBH_32_BASE(i)       (FIELD (i, 20, 4))</span>
<a name="l01531"></a><a class="code" href="mep-tdep_8c.html#a5499849f8cccc45dd540a5043fd600f5">01531</a> <span class="preprocessor"></span><span class="preprocessor">#define SWBH_32_SOURCE(i)     (FIELD (i, 24, 4))</span>
<a name="l01532"></a><a class="code" href="mep-tdep_8c.html#ab4f800e847dd5da61f8a99200f49158c">01532</a> <span class="preprocessor"></span><span class="preprocessor">#define SWBH_32_OFFSET(i)     (SFIELD (i, 0, 16))</span>
<a name="l01533"></a>01533 <span class="preprocessor"></span>
<a name="l01534"></a>01534 <span class="comment">/* SW Rn,disp7.align4(SP)     0100_nnnn_0ddd_dd10 xxxx_xxxx_xxxx_xxxx */</span>
<a name="l01535"></a><a class="code" href="mep-tdep_8c.html#a28ca932a5dd4d4a0870b64e1b97b2c53">01535</a> <span class="preprocessor">#define IS_SW_IMMD(i)         (((i) &amp; 0xf0830000) == 0x40020000)</span>
<a name="l01536"></a><a class="code" href="mep-tdep_8c.html#a2bb9627ddf2d271fd59bffb7129b069c">01536</a> <span class="preprocessor"></span><span class="preprocessor">#define SW_IMMD_SOURCE(i)     (FIELD (i, 24, 4))</span>
<a name="l01537"></a><a class="code" href="mep-tdep_8c.html#acbf06eb2dfb5f9317acdbffb5b9b25af">01537</a> <span class="preprocessor"></span><span class="preprocessor">#define SW_IMMD_OFFSET(i)     (FIELD (i, 18, 5) &lt;&lt; 2)</span>
<a name="l01538"></a>01538 <span class="preprocessor"></span>
<a name="l01539"></a>01539 <span class="comment">/* SW Rn,(Rm)                 0000_nnnn_mmmm_1010 xxxx_xxxx_xxxx_xxxx */</span>
<a name="l01540"></a><a class="code" href="mep-tdep_8c.html#af1f3393e8013590cbfe9ec047bcbbc2a">01540</a> <span class="preprocessor">#define IS_SW_REG(i)          (((i) &amp; 0xf00f0000) == 0x000a0000)</span>
<a name="l01541"></a><a class="code" href="mep-tdep_8c.html#a9b28955343302a92e19c6b5b6f0bcf6c">01541</a> <span class="preprocessor"></span><span class="preprocessor">#define SW_REG_SOURCE(i)      (FIELD (i, 24, 4))</span>
<a name="l01542"></a><a class="code" href="mep-tdep_8c.html#a8fda14438cd011b53c0d3dfab7a4acb4">01542</a> <span class="preprocessor"></span><span class="preprocessor">#define SW_REG_BASE(i)        (FIELD (i, 20, 4))</span>
<a name="l01543"></a>01543 <span class="preprocessor"></span>
<a name="l01544"></a>01544 <span class="comment">/* ADD3 Rl,Rn,Rm              1001_nnnn_mmmm_llll xxxx_xxxx_xxxx_xxxx */</span>
<a name="l01545"></a><a class="code" href="mep-tdep_8c.html#a5ed89db0f71251267cd181a2fac02e1d">01545</a> <span class="preprocessor">#define IS_ADD3_16_REG(i)     (((i) &amp; 0xf0000000) == 0x90000000)</span>
<a name="l01546"></a><a class="code" href="mep-tdep_8c.html#abbf297729733ea3167223645f7cd6fc7">01546</a> <span class="preprocessor"></span><span class="preprocessor">#define ADD3_16_REG_SRC1(i)   (FIELD (i, 20, 4))               </span><span class="comment">/* n */</span>
<a name="l01547"></a><a class="code" href="mep-tdep_8c.html#a65d58526a2bd5a2c747217046b12c6e7">01547</a> <span class="preprocessor">#define ADD3_16_REG_SRC2(i)   (FIELD (i, 24, 4))               </span><span class="comment">/* m */</span>
<a name="l01548"></a>01548 
<a name="l01549"></a>01549 <span class="comment">/* ADD3 Rn,Rm,imm16           1100_nnnn_mmmm_0000 iiii_iiii_iiii_iiii */</span>
<a name="l01550"></a><a class="code" href="mep-tdep_8c.html#abb508c671ec482177278b875b5beabfc">01550</a> <span class="preprocessor">#define IS_ADD3_32(i)         (((i) &amp; 0xf00f0000) == 0xc0000000)</span>
<a name="l01551"></a><a class="code" href="mep-tdep_8c.html#ad1c4e50a035a5c14a32f7360d0b5039c">01551</a> <span class="preprocessor"></span><span class="preprocessor">#define ADD3_32_TARGET(i)     (FIELD (i, 24, 4))</span>
<a name="l01552"></a><a class="code" href="mep-tdep_8c.html#ac9d52717d18d77897c0d7a4d6eee247a">01552</a> <span class="preprocessor"></span><span class="preprocessor">#define ADD3_32_SOURCE(i)     (FIELD (i, 20, 4))</span>
<a name="l01553"></a><a class="code" href="mep-tdep_8c.html#ab2c7dab2fc415e854aab6aed9dddb2d1">01553</a> <span class="preprocessor"></span><span class="preprocessor">#define ADD3_32_OFFSET(i)     (SFIELD (i, 0, 16))</span>
<a name="l01554"></a>01554 <span class="preprocessor"></span>
<a name="l01555"></a>01555 <span class="comment">/* ADD3 Rn,SP,imm7.align4     0100_nnnn_0iii_ii00 xxxx_xxxx_xxxx_xxxx */</span>
<a name="l01556"></a><a class="code" href="mep-tdep_8c.html#a057860f1dc04991679fd0ee3f5493089">01556</a> <span class="preprocessor">#define IS_ADD3_16(i)         (((i) &amp; 0xf0830000) == 0x40000000)</span>
<a name="l01557"></a><a class="code" href="mep-tdep_8c.html#ab68be663881bf326105fcf5a8fe22351">01557</a> <span class="preprocessor"></span><span class="preprocessor">#define ADD3_16_TARGET(i)     (FIELD (i, 24, 4))</span>
<a name="l01558"></a><a class="code" href="mep-tdep_8c.html#aa72ed2cc27ec0bebb1ff3855f1e05c4f">01558</a> <span class="preprocessor"></span><span class="preprocessor">#define ADD3_16_OFFSET(i)     (FIELD (i, 18, 5) &lt;&lt; 2)</span>
<a name="l01559"></a>01559 <span class="preprocessor"></span>
<a name="l01560"></a>01560 <span class="comment">/* ADD Rn,imm6                0110_nnnn_iiii_ii00 xxxx_xxxx_xxxx_xxxx */</span>
<a name="l01561"></a><a class="code" href="mep-tdep_8c.html#a566cd69ef1119e9b5bd15212df5eae68">01561</a> <span class="preprocessor">#define IS_ADD(i)             (((i) &amp; 0xf0030000) == 0x60000000)</span>
<a name="l01562"></a><a class="code" href="mep-tdep_8c.html#ad9d71746189179ae05a0b659169bcb70">01562</a> <span class="preprocessor"></span><span class="preprocessor">#define ADD_TARGET(i)         (FIELD (i, 24, 4))</span>
<a name="l01563"></a><a class="code" href="mep-tdep_8c.html#a8319b15c1ab56848a623a99f140f95b7">01563</a> <span class="preprocessor"></span><span class="preprocessor">#define ADD_OFFSET(i)         (SFIELD (i, 18, 6))</span>
<a name="l01564"></a>01564 <span class="preprocessor"></span>
<a name="l01565"></a>01565 <span class="comment">/* LDC Rn,imm5                0111_nnnn_iiii_101I xxxx_xxxx_xxxx_xxxx</span>
<a name="l01566"></a>01566 <span class="comment">                              imm5 = I||i[7:4] */</span>
<a name="l01567"></a><a class="code" href="mep-tdep_8c.html#af9e3b9b193a51550122dee12c590c634">01567</a> <span class="preprocessor">#define IS_LDC(i)             (((i) &amp; 0xf00e0000) == 0x700a0000)</span>
<a name="l01568"></a><a class="code" href="mep-tdep_8c.html#aa89ab964db673eddf043aca3821417e7">01568</a> <span class="preprocessor"></span><span class="preprocessor">#define LDC_IMM(i)            ((FIELD (i, 16, 1) &lt;&lt; 4) | FIELD (i, 20, 4))</span>
<a name="l01569"></a><a class="code" href="mep-tdep_8c.html#ae30ae0344cdb64a0e23432d180df54bd">01569</a> <span class="preprocessor"></span><span class="preprocessor">#define LDC_TARGET(i)         (FIELD (i, 24, 4))</span>
<a name="l01570"></a>01570 <span class="preprocessor"></span>
<a name="l01571"></a>01571 <span class="comment">/* LW Rn,disp16(Rm)           1100_nnnn_mmmm_1110 dddd_dddd_dddd_dddd  */</span>
<a name="l01572"></a><a class="code" href="mep-tdep_8c.html#a1ecbe5ed0dc0be64324afbc75b34d3ed">01572</a> <span class="preprocessor">#define IS_LW(i)              (((i) &amp; 0xf00f0000) == 0xc00e0000)</span>
<a name="l01573"></a><a class="code" href="mep-tdep_8c.html#a8c20a027274c911845a27e75a9d7c79f">01573</a> <span class="preprocessor"></span><span class="preprocessor">#define LW_TARGET(i)          (FIELD (i, 24, 4))</span>
<a name="l01574"></a><a class="code" href="mep-tdep_8c.html#a0a1ec52a0f2adc060499ce34beed58e1">01574</a> <span class="preprocessor"></span><span class="preprocessor">#define LW_BASE(i)            (FIELD (i, 20, 4))</span>
<a name="l01575"></a><a class="code" href="mep-tdep_8c.html#a42653fbee5e0ee25e87fc19d952db152">01575</a> <span class="preprocessor"></span><span class="preprocessor">#define LW_OFFSET(i)          (SFIELD (i, 0, 16))</span>
<a name="l01576"></a>01576 <span class="preprocessor"></span>
<a name="l01577"></a>01577 <span class="comment">/* MOV Rn,Rm                  0000_nnnn_mmmm_0000 xxxx_xxxx_xxxx_xxxx */</span>
<a name="l01578"></a><a class="code" href="mep-tdep_8c.html#ac85c7abf400b5c6fedf7132a257ce0a4">01578</a> <span class="preprocessor">#define IS_MOV(i)             (((i) &amp; 0xf00f0000) == 0x00000000)</span>
<a name="l01579"></a><a class="code" href="mep-tdep_8c.html#ae64edea77e783564d4468a4e53057ff2">01579</a> <span class="preprocessor"></span><span class="preprocessor">#define MOV_TARGET(i)         (FIELD (i, 24, 4))</span>
<a name="l01580"></a><a class="code" href="mep-tdep_8c.html#a401a3a9285c3648b334aa88e6980cc4f">01580</a> <span class="preprocessor"></span><span class="preprocessor">#define MOV_SOURCE(i)         (FIELD (i, 20, 4))</span>
<a name="l01581"></a>01581 <span class="preprocessor"></span>
<a name="l01582"></a>01582 <span class="comment">/* BRA disp12.align2          1011_dddd_dddd_ddd0 xxxx_xxxx_xxxx_xxxx */</span>
<a name="l01583"></a><a class="code" href="mep-tdep_8c.html#a5e774e179326daf1eb8ee846f28adcee">01583</a> <span class="preprocessor">#define IS_BRA(i)             (((i) &amp; 0xf0010000) == 0xb0000000)</span>
<a name="l01584"></a><a class="code" href="mep-tdep_8c.html#a8b599189dc9af4ca93616fcea4d5f1af">01584</a> <span class="preprocessor"></span><span class="preprocessor">#define BRA_DISP(i)           (SFIELD (i, 17, 11) &lt;&lt; 1)</span>
<a name="l01585"></a>01585 <span class="preprocessor"></span>
<a name="l01586"></a>01586 
<a name="l01587"></a>01587 <span class="comment">/* This structure holds the results of a prologue analysis.  */</span>
<a name="l01588"></a>01588 <span class="keyword">struct </span>mep_prologue
<a name="l01589"></a>01589 {
<a name="l01590"></a>01590   <span class="comment">/* The architecture for which we generated this prologue info.  */</span>
<a name="l01591"></a>01591   <span class="keyword">struct </span>gdbarch *gdbarch;
<a name="l01592"></a>01592 
<a name="l01593"></a>01593   <span class="comment">/* The offset from the frame base to the stack pointer --- always</span>
<a name="l01594"></a>01594 <span class="comment">     zero or negative.</span>
<a name="l01595"></a>01595 <span class="comment"></span>
<a name="l01596"></a>01596 <span class="comment">     Calling this a &quot;size&quot; is a bit misleading, but given that the</span>
<a name="l01597"></a>01597 <span class="comment">     stack grows downwards, using offsets for everything keeps one</span>
<a name="l01598"></a>01598 <span class="comment">     from going completely sign-crazy: you never change anything&#39;s</span>
<a name="l01599"></a>01599 <span class="comment">     sign for an ADD instruction; always change the second operand&#39;s</span>
<a name="l01600"></a>01600 <span class="comment">     sign for a SUB instruction; and everything takes care of</span>
<a name="l01601"></a>01601 <span class="comment">     itself.  */</span>
<a name="l01602"></a>01602   <span class="keywordtype">int</span> frame_size;
<a name="l01603"></a>01603 
<a name="l01604"></a>01604   <span class="comment">/* Non-zero if this function has initialized the frame pointer from</span>
<a name="l01605"></a>01605 <span class="comment">     the stack pointer, zero otherwise.  */</span>
<a name="l01606"></a>01606   <span class="keywordtype">int</span> has_frame_ptr;
<a name="l01607"></a>01607 
<a name="l01608"></a>01608   <span class="comment">/* If has_frame_ptr is non-zero, this is the offset from the frame</span>
<a name="l01609"></a>01609 <span class="comment">     base to where the frame pointer points.  This is always zero or</span>
<a name="l01610"></a>01610 <span class="comment">     negative.  */</span>
<a name="l01611"></a>01611   <span class="keywordtype">int</span> frame_ptr_offset;
<a name="l01612"></a>01612 
<a name="l01613"></a>01613   <span class="comment">/* The address of the first instruction at which the frame has been</span>
<a name="l01614"></a>01614 <span class="comment">     set up and the arguments are where the debug info says they are</span>
<a name="l01615"></a>01615 <span class="comment">     --- as best as we can tell.  */</span>
<a name="l01616"></a>01616   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> prologue_end;
<a name="l01617"></a>01617 
<a name="l01618"></a>01618   <span class="comment">/* reg_offset[R] is the offset from the CFA at which register R is</span>
<a name="l01619"></a>01619 <span class="comment">     saved, or 1 if register R has not been saved.  (Real values are</span>
<a name="l01620"></a>01620 <span class="comment">     always zero or negative.)  */</span>
<a name="l01621"></a>01621   <span class="keywordtype">int</span> reg_offset[<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab1d07718514b4d16d9c10ba999079a32">MEP_NUM_REGS</a>];
<a name="l01622"></a>01622 };
<a name="l01623"></a>01623 
<a name="l01624"></a>01624 <span class="comment">/* Return non-zero if VALUE is an incoming argument register.  */</span>
<a name="l01625"></a>01625 
<a name="l01626"></a>01626 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01627"></a>01627 is_arg_reg (<a class="code" href="structprologue__value.html">pv_t</a> value)
<a name="l01628"></a>01628 {
<a name="l01629"></a>01629   <span class="keywordflow">return</span> (value.<a class="code" href="structprologue__value.html#a6b52b744f67b02d26add61c3e6bf4e7f">kind</a> == pvk_register
<a name="l01630"></a>01630           &amp;&amp; <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80acc56f4b49717da58bfc9ffa158dd5015">MEP_R1_REGNUM</a> &lt;= value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a> &amp;&amp; value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a> &lt;= <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a8b5cc0f6cb43b1571bac042b6fa57e2e">MEP_R4_REGNUM</a>
<a name="l01631"></a>01631           &amp;&amp; value.<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a> == 0);
<a name="l01632"></a>01632 }
<a name="l01633"></a>01633 
<a name="l01634"></a>01634 <span class="comment">/* Return non-zero if a store of REG&#39;s current value VALUE to ADDR is</span>
<a name="l01635"></a>01635 <span class="comment">   probably spilling an argument register to its stack slot in STACK.</span>
<a name="l01636"></a>01636 <span class="comment">   Such instructions should be included in the prologue, if possible.</span>
<a name="l01637"></a>01637 <span class="comment"></span>
<a name="l01638"></a>01638 <span class="comment">   The store is a spill if:</span>
<a name="l01639"></a>01639 <span class="comment">   - the value being stored is REG&#39;s original value;</span>
<a name="l01640"></a>01640 <span class="comment">   - the value has not already been stored somewhere in STACK; and</span>
<a name="l01641"></a>01641 <span class="comment">   - ADDR is a stack slot&#39;s address (e.g., relative to the original</span>
<a name="l01642"></a>01642 <span class="comment">     value of the SP).  */</span>
<a name="l01643"></a>01643 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01644"></a>01644 is_arg_spill (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="structprologue__value.html">pv_t</a> value, <a class="code" href="structprologue__value.html">pv_t</a> addr,
<a name="l01645"></a>01645               <span class="keyword">struct</span> pv_area *stack)
<a name="l01646"></a>01646 {
<a name="l01647"></a>01647   <span class="keywordflow">return</span> (is_arg_reg (value)
<a name="l01648"></a>01648           &amp;&amp; <a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (addr, <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ad6caa78945d52ae1bfeba530ae2bf72e">MEP_SP_REGNUM</a>)
<a name="l01649"></a>01649           &amp;&amp; ! <a class="code" href="prologue-value_8c.html#af2ee40cc8963d3782b9a8f95dc0ca7d0">pv_area_find_reg</a> (stack, gdbarch, value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a>, 0));
<a name="l01650"></a>01650 }
<a name="l01651"></a>01651 
<a name="l01652"></a>01652 
<a name="l01653"></a>01653 <span class="comment">/* Function for finding saved registers in a &#39;struct pv_area&#39;; we pass</span>
<a name="l01654"></a>01654 <span class="comment">   this to pv_area_scan.</span>
<a name="l01655"></a>01655 <span class="comment"></span>
<a name="l01656"></a>01656 <span class="comment">   If VALUE is a saved register, ADDR says it was saved at a constant</span>
<a name="l01657"></a>01657 <span class="comment">   offset from the frame base, and SIZE indicates that the whole</span>
<a name="l01658"></a>01658 <span class="comment">   register was saved, record its offset in RESULT_UNTYPED.  */</span>
<a name="l01659"></a>01659 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01660"></a>01660 check_for_saved (<span class="keywordtype">void</span> *result_untyped, <a class="code" href="structprologue__value.html">pv_t</a> addr, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> size, <a class="code" href="structprologue__value.html">pv_t</a> value)
<a name="l01661"></a>01661 {
<a name="l01662"></a>01662   <span class="keyword">struct </span>mep_prologue *result = (<span class="keyword">struct </span>mep_prologue *) result_untyped;
<a name="l01663"></a>01663 
<a name="l01664"></a>01664   <span class="keywordflow">if</span> (value.<a class="code" href="structprologue__value.html#a6b52b744f67b02d26add61c3e6bf4e7f">kind</a> == pvk_register
<a name="l01665"></a>01665       &amp;&amp; value.<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a> == 0
<a name="l01666"></a>01666       &amp;&amp; <a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (addr, <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ad6caa78945d52ae1bfeba530ae2bf72e">MEP_SP_REGNUM</a>)
<a name="l01667"></a>01667       &amp;&amp; size == <a class="code" href="regcache_8c.html#a4c51fa25edb9ce25451b9dc7bd127aac">register_size</a> (result-&gt;gdbarch, value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a>))
<a name="l01668"></a>01668     result-&gt;reg_offset[value.<a class="code" href="structprologue__value.html#a045cd9d752511573c1130407e0b5be7e">reg</a>] = addr.<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a>;
<a name="l01669"></a>01669 }
<a name="l01670"></a>01670 
<a name="l01671"></a>01671 
<a name="l01672"></a>01672 <span class="comment">/* Analyze a prologue starting at START_PC, going no further than</span>
<a name="l01673"></a>01673 <span class="comment">   LIMIT_PC.  Fill in RESULT as appropriate.  */</span>
<a name="l01674"></a>01674 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01675"></a>01675 mep_analyze_prologue (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l01676"></a>01676                       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_pc, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> limit_pc,
<a name="l01677"></a>01677                       <span class="keyword">struct</span> mep_prologue *result)
<a name="l01678"></a>01678 {
<a name="l01679"></a>01679   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc;
<a name="l01680"></a>01680   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> insn;
<a name="l01681"></a>01681   <span class="keywordtype">int</span> rn;
<a name="l01682"></a>01682   <span class="keywordtype">int</span> found_lp = 0;
<a name="l01683"></a>01683   <a class="code" href="structprologue__value.html">pv_t</a> <a class="code" href="structreg.html">reg</a>[<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab1d07718514b4d16d9c10ba999079a32">MEP_NUM_REGS</a>];
<a name="l01684"></a>01684   <span class="keyword">struct </span>pv_area *stack;
<a name="l01685"></a>01685   <span class="keyword">struct </span>cleanup *back_to;
<a name="l01686"></a>01686   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> after_last_frame_setup_insn = start_pc;
<a name="l01687"></a>01687 
<a name="l01688"></a>01688   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (result, 0, <span class="keyword">sizeof</span> (*result));
<a name="l01689"></a>01689   result-&gt;gdbarch = gdbarch;
<a name="l01690"></a>01690 
<a name="l01691"></a>01691   <span class="keywordflow">for</span> (rn = 0; rn &lt; <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab1d07718514b4d16d9c10ba999079a32">MEP_NUM_REGS</a>; rn++)
<a name="l01692"></a>01692     {
<a name="l01693"></a>01693       reg[rn] = <a class="code" href="prologue-value_8c.html#a34b5d4a01cdf3fdb23cc9b69a407acc2">pv_register</a> (rn, 0);
<a name="l01694"></a>01694       result-&gt;reg_offset[rn] = 1;
<a name="l01695"></a>01695     }
<a name="l01696"></a>01696 
<a name="l01697"></a>01697   stack = <a class="code" href="prologue-value_8c.html#a962e98d46aef2ed10288f8ae28b713f0">make_pv_area</a> (<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ad6caa78945d52ae1bfeba530ae2bf72e">MEP_SP_REGNUM</a>, <a class="code" href="gdbarch_8c.html#a3ee335ac98782b6633ab7fc235182cc9">gdbarch_addr_bit</a> (gdbarch));
<a name="l01698"></a>01698   back_to = <a class="code" href="prologue-value_8c.html#aa46c9e6e63a97230bb9be62b15d2cb96">make_cleanup_free_pv_area</a> (stack);
<a name="l01699"></a>01699 
<a name="l01700"></a>01700   pc = start_pc;
<a name="l01701"></a>01701   <span class="keywordflow">while</span> (pc &lt; limit_pc)
<a name="l01702"></a>01702     {
<a name="l01703"></a>01703       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> next_pc;
<a name="l01704"></a>01704       <a class="code" href="structprologue__value.html">pv_t</a> pre_insn_fp, pre_insn_sp;
<a name="l01705"></a>01705 
<a name="l01706"></a>01706       next_pc = mep_get_insn (gdbarch, pc, &amp;insn);
<a name="l01707"></a>01707 
<a name="l01708"></a>01708       <span class="comment">/* A zero return from mep_get_insn means that either we weren&#39;t</span>
<a name="l01709"></a>01709 <span class="comment">         able to read the instruction from memory, or that we don&#39;t</span>
<a name="l01710"></a>01710 <span class="comment">         have enough information to be able to reliably decode it.  So</span>
<a name="l01711"></a>01711 <span class="comment">         we&#39;ll store here and hope for the best.  */</span>
<a name="l01712"></a>01712       <span class="keywordflow">if</span> (! next_pc)
<a name="l01713"></a>01713         <span class="keywordflow">break</span>;
<a name="l01714"></a>01714 
<a name="l01715"></a>01715       <span class="comment">/* Note the current values of the SP and FP, so we can tell if</span>
<a name="l01716"></a>01716 <span class="comment">         this instruction changed them, below.  */</span>
<a name="l01717"></a>01717       pre_insn_fp = reg[<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab8e40c2c305839597884fb849cff53b4">MEP_FP_REGNUM</a>];
<a name="l01718"></a>01718       pre_insn_sp = reg[<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ad6caa78945d52ae1bfeba530ae2bf72e">MEP_SP_REGNUM</a>];
<a name="l01719"></a>01719 
<a name="l01720"></a>01720       <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#a566cd69ef1119e9b5bd15212df5eae68">IS_ADD</a> (insn))
<a name="l01721"></a>01721         {
<a name="l01722"></a>01722           <span class="keywordtype">int</span> rn = <a class="code" href="mep-tdep_8c.html#ad9d71746189179ae05a0b659169bcb70">ADD_TARGET</a> (insn);
<a name="l01723"></a>01723           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> imm6 = <a class="code" href="mep-tdep_8c.html#a8319b15c1ab56848a623a99f140f95b7">ADD_OFFSET</a> (insn);
<a name="l01724"></a>01724 
<a name="l01725"></a>01725           reg[rn] = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (reg[rn], imm6);
<a name="l01726"></a>01726         }
<a name="l01727"></a>01727       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#a057860f1dc04991679fd0ee3f5493089">IS_ADD3_16</a> (insn))
<a name="l01728"></a>01728         {
<a name="l01729"></a>01729           <span class="keywordtype">int</span> rn = <a class="code" href="mep-tdep_8c.html#ab68be663881bf326105fcf5a8fe22351">ADD3_16_TARGET</a> (insn);
<a name="l01730"></a>01730           <span class="keywordtype">int</span> imm7 = <a class="code" href="mep-tdep_8c.html#aa72ed2cc27ec0bebb1ff3855f1e05c4f">ADD3_16_OFFSET</a> (insn);
<a name="l01731"></a>01731 
<a name="l01732"></a>01732           reg[rn] = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (reg[<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ad6caa78945d52ae1bfeba530ae2bf72e">MEP_SP_REGNUM</a>], imm7);
<a name="l01733"></a>01733         }
<a name="l01734"></a>01734       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#abb508c671ec482177278b875b5beabfc">IS_ADD3_32</a> (insn))
<a name="l01735"></a>01735         {
<a name="l01736"></a>01736           <span class="keywordtype">int</span> rn = <a class="code" href="mep-tdep_8c.html#ad1c4e50a035a5c14a32f7360d0b5039c">ADD3_32_TARGET</a> (insn);
<a name="l01737"></a>01737           <span class="keywordtype">int</span> rm = <a class="code" href="mep-tdep_8c.html#ac9d52717d18d77897c0d7a4d6eee247a">ADD3_32_SOURCE</a> (insn);
<a name="l01738"></a>01738           <span class="keywordtype">int</span> imm16 = <a class="code" href="mep-tdep_8c.html#ab2c7dab2fc415e854aab6aed9dddb2d1">ADD3_32_OFFSET</a> (insn);
<a name="l01739"></a>01739 
<a name="l01740"></a>01740           reg[rn] = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (reg[rm], imm16);
<a name="l01741"></a>01741         }
<a name="l01742"></a>01742       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#af1f3393e8013590cbfe9ec047bcbbc2a">IS_SW_REG</a> (insn))
<a name="l01743"></a>01743         {
<a name="l01744"></a>01744           <span class="keywordtype">int</span> rn = <a class="code" href="mep-tdep_8c.html#a9b28955343302a92e19c6b5b6f0bcf6c">SW_REG_SOURCE</a> (insn);
<a name="l01745"></a>01745           <span class="keywordtype">int</span> rm = <a class="code" href="mep-tdep_8c.html#a8fda14438cd011b53c0d3dfab7a4acb4">SW_REG_BASE</a> (insn);
<a name="l01746"></a>01746 
<a name="l01747"></a>01747           <span class="comment">/* If simulating this store would require us to forget</span>
<a name="l01748"></a>01748 <span class="comment">             everything we know about the stack frame in the name of</span>
<a name="l01749"></a>01749 <span class="comment">             accuracy, it would be better to just quit now.  */</span>
<a name="l01750"></a>01750           <span class="keywordflow">if</span> (<a class="code" href="prologue-value_8c.html#af16f8e9cb043efd0a97c592f199d4aa7">pv_area_store_would_trash</a> (stack, reg[rm]))
<a name="l01751"></a>01751             <span class="keywordflow">break</span>;
<a name="l01752"></a>01752           
<a name="l01753"></a>01753           <span class="keywordflow">if</span> (is_arg_spill (gdbarch, reg[rn], reg[rm], stack))
<a name="l01754"></a>01754             after_last_frame_setup_insn = next_pc;
<a name="l01755"></a>01755 
<a name="l01756"></a>01756           <a class="code" href="prologue-value_8c.html#af1c1f51f05db124191cd6bf1a4077f3f">pv_area_store</a> (stack, reg[rm], 4, reg[rn]);
<a name="l01757"></a>01757         }
<a name="l01758"></a>01758       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#a28ca932a5dd4d4a0870b64e1b97b2c53">IS_SW_IMMD</a> (insn))
<a name="l01759"></a>01759         {
<a name="l01760"></a>01760           <span class="keywordtype">int</span> rn = <a class="code" href="mep-tdep_8c.html#a2bb9627ddf2d271fd59bffb7129b069c">SW_IMMD_SOURCE</a> (insn);
<a name="l01761"></a>01761           <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a> = <a class="code" href="mep-tdep_8c.html#acbf06eb2dfb5f9317acdbffb5b9b25af">SW_IMMD_OFFSET</a> (insn);
<a name="l01762"></a>01762           <a class="code" href="structprologue__value.html">pv_t</a> addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (reg[<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ad6caa78945d52ae1bfeba530ae2bf72e">MEP_SP_REGNUM</a>], offset);
<a name="l01763"></a>01763 
<a name="l01764"></a>01764           <span class="comment">/* If simulating this store would require us to forget</span>
<a name="l01765"></a>01765 <span class="comment">             everything we know about the stack frame in the name of</span>
<a name="l01766"></a>01766 <span class="comment">             accuracy, it would be better to just quit now.  */</span>
<a name="l01767"></a>01767           <span class="keywordflow">if</span> (<a class="code" href="prologue-value_8c.html#af16f8e9cb043efd0a97c592f199d4aa7">pv_area_store_would_trash</a> (stack, addr))
<a name="l01768"></a>01768             <span class="keywordflow">break</span>;
<a name="l01769"></a>01769 
<a name="l01770"></a>01770           <span class="keywordflow">if</span> (is_arg_spill (gdbarch, reg[rn], addr, stack))
<a name="l01771"></a>01771             after_last_frame_setup_insn = next_pc;
<a name="l01772"></a>01772 
<a name="l01773"></a>01773           <a class="code" href="prologue-value_8c.html#af1c1f51f05db124191cd6bf1a4077f3f">pv_area_store</a> (stack, addr, 4, reg[rn]);
<a name="l01774"></a>01774         }
<a name="l01775"></a>01775       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#ac85c7abf400b5c6fedf7132a257ce0a4">IS_MOV</a> (insn))
<a name="l01776"></a>01776         {
<a name="l01777"></a>01777           <span class="keywordtype">int</span> rn = <a class="code" href="mep-tdep_8c.html#ae64edea77e783564d4468a4e53057ff2">MOV_TARGET</a> (insn);
<a name="l01778"></a>01778           <span class="keywordtype">int</span> rm = <a class="code" href="mep-tdep_8c.html#a401a3a9285c3648b334aa88e6980cc4f">MOV_SOURCE</a> (insn);
<a name="l01779"></a>01779 
<a name="l01780"></a>01780           reg[rn] = reg[rm];
<a name="l01781"></a>01781 
<a name="l01782"></a>01782           <span class="keywordflow">if</span> (<a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (reg[rm], rm) &amp;&amp; is_arg_reg (reg[rm]))
<a name="l01783"></a>01783             after_last_frame_setup_insn = next_pc;
<a name="l01784"></a>01784         }
<a name="l01785"></a>01785       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#abb3f6234b22b58dd742bde646157b53a">IS_SB</a> (insn) || <a class="code" href="mep-tdep_8c.html#ae1b8110ef52f2604708a3bbb554f48a9">IS_SH</a> (insn) || <a class="code" href="mep-tdep_8c.html#aceef6e51b96fd9740241bf8204d27ffd">IS_SW</a> (insn))
<a name="l01786"></a>01786         {
<a name="l01787"></a>01787           <span class="keywordtype">int</span> rn = <a class="code" href="mep-tdep_8c.html#a5499849f8cccc45dd540a5043fd600f5">SWBH_32_SOURCE</a> (insn);
<a name="l01788"></a>01788           <span class="keywordtype">int</span> rm = <a class="code" href="mep-tdep_8c.html#aac4bfb981a20369c9556c69663e5dc68">SWBH_32_BASE</a> (insn);
<a name="l01789"></a>01789           <span class="keywordtype">int</span> disp = <a class="code" href="mep-tdep_8c.html#ab4f800e847dd5da61f8a99200f49158c">SWBH_32_OFFSET</a> (insn);
<a name="l01790"></a>01790           <span class="keywordtype">int</span> size = (<a class="code" href="mep-tdep_8c.html#abb3f6234b22b58dd742bde646157b53a">IS_SB</a> (insn) ? 1
<a name="l01791"></a>01791                       : <a class="code" href="mep-tdep_8c.html#ae1b8110ef52f2604708a3bbb554f48a9">IS_SH</a> (insn) ? 2
<a name="l01792"></a>01792                       : (<a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="mep-tdep_8c.html#aceef6e51b96fd9740241bf8204d27ffd">IS_SW</a> (insn)), 4));
<a name="l01793"></a>01793           <a class="code" href="structprologue__value.html">pv_t</a> addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (reg[rm], disp);
<a name="l01794"></a>01794 
<a name="l01795"></a>01795           <span class="keywordflow">if</span> (<a class="code" href="prologue-value_8c.html#af16f8e9cb043efd0a97c592f199d4aa7">pv_area_store_would_trash</a> (stack, addr))
<a name="l01796"></a>01796             <span class="keywordflow">break</span>;
<a name="l01797"></a>01797 
<a name="l01798"></a>01798           <span class="keywordflow">if</span> (is_arg_spill (gdbarch, reg[rn], addr, stack))
<a name="l01799"></a>01799             after_last_frame_setup_insn = next_pc;
<a name="l01800"></a>01800 
<a name="l01801"></a>01801           <a class="code" href="prologue-value_8c.html#af1c1f51f05db124191cd6bf1a4077f3f">pv_area_store</a> (stack, addr, size, reg[rn]);
<a name="l01802"></a>01802         }
<a name="l01803"></a>01803       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#af9e3b9b193a51550122dee12c590c634">IS_LDC</a> (insn))
<a name="l01804"></a>01804         {
<a name="l01805"></a>01805           <span class="keywordtype">int</span> rn = <a class="code" href="mep-tdep_8c.html#ae30ae0344cdb64a0e23432d180df54bd">LDC_TARGET</a> (insn);
<a name="l01806"></a>01806           <span class="keywordtype">int</span> cr = <a class="code" href="mep-tdep_8c.html#aa89ab964db673eddf043aca3821417e7">LDC_IMM</a> (insn) + <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ade498fd65c118ae4e92024132a47e55b">MEP_FIRST_CSR_REGNUM</a>;
<a name="l01807"></a>01807 
<a name="l01808"></a>01808           reg[rn] = reg[cr];
<a name="l01809"></a>01809         }
<a name="l01810"></a>01810       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#a1ecbe5ed0dc0be64324afbc75b34d3ed">IS_LW</a> (insn))
<a name="l01811"></a>01811         {
<a name="l01812"></a>01812           <span class="keywordtype">int</span> rn = <a class="code" href="mep-tdep_8c.html#a8c20a027274c911845a27e75a9d7c79f">LW_TARGET</a> (insn);
<a name="l01813"></a>01813           <span class="keywordtype">int</span> rm = <a class="code" href="mep-tdep_8c.html#a0a1ec52a0f2adc060499ce34beed58e1">LW_BASE</a> (insn);
<a name="l01814"></a>01814           <span class="keywordtype">int</span> offset = <a class="code" href="mep-tdep_8c.html#a42653fbee5e0ee25e87fc19d952db152">LW_OFFSET</a> (insn);
<a name="l01815"></a>01815           <a class="code" href="structprologue__value.html">pv_t</a> addr = <a class="code" href="prologue-value_8c.html#abb868b251953ef345cda781678243e18">pv_add_constant</a> (reg[rm], offset);
<a name="l01816"></a>01816 
<a name="l01817"></a>01817           reg[rn] = <a class="code" href="prologue-value_8c.html#ab467d5c80e75828bd5889f4c2b16ca48">pv_area_fetch</a> (stack, addr, 4);
<a name="l01818"></a>01818         }
<a name="l01819"></a>01819       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="mep-tdep_8c.html#a5e774e179326daf1eb8ee846f28adcee">IS_BRA</a> (insn) &amp;&amp; <a class="code" href="mep-tdep_8c.html#a8b599189dc9af4ca93616fcea4d5f1af">BRA_DISP</a> (insn) &gt; 0)
<a name="l01820"></a>01820         {
<a name="l01821"></a>01821           <span class="comment">/* When a loop appears as the first statement of a function</span>
<a name="l01822"></a>01822 <span class="comment">             body, gcc 4.x will use a BRA instruction to branch to the</span>
<a name="l01823"></a>01823 <span class="comment">             loop condition checking code.  This BRA instruction is</span>
<a name="l01824"></a>01824 <span class="comment">             marked as part of the prologue.  We therefore set next_pc</span>
<a name="l01825"></a>01825 <span class="comment">             to this branch target and also stop the prologue scan.</span>
<a name="l01826"></a>01826 <span class="comment">             The instructions at and beyond the branch target should</span>
<a name="l01827"></a>01827 <span class="comment">             no longer be associated with the prologue.</span>
<a name="l01828"></a>01828 <span class="comment">             </span>
<a name="l01829"></a>01829 <span class="comment">             Note that we only consider forward branches here.  We</span>
<a name="l01830"></a>01830 <span class="comment">             presume that a forward branch is being used to skip over</span>
<a name="l01831"></a>01831 <span class="comment">             a loop body.</span>
<a name="l01832"></a>01832 <span class="comment">             </span>
<a name="l01833"></a>01833 <span class="comment">             A backwards branch is covered by the default case below.</span>
<a name="l01834"></a>01834 <span class="comment">             If we were to encounter a backwards branch, that would</span>
<a name="l01835"></a>01835 <span class="comment">             most likely mean that we&#39;ve scanned through a loop body.</span>
<a name="l01836"></a>01836 <span class="comment">             We definitely want to stop the prologue scan when this</span>
<a name="l01837"></a>01837 <span class="comment">             happens and that is precisely what is done by the default</span>
<a name="l01838"></a>01838 <span class="comment">             case below.  */</span>
<a name="l01839"></a>01839           next_pc = pc + <a class="code" href="mep-tdep_8c.html#a8b599189dc9af4ca93616fcea4d5f1af">BRA_DISP</a> (insn);
<a name="l01840"></a>01840           after_last_frame_setup_insn = next_pc;
<a name="l01841"></a>01841           <span class="keywordflow">break</span>;
<a name="l01842"></a>01842         }
<a name="l01843"></a>01843       <span class="keywordflow">else</span>
<a name="l01844"></a>01844         <span class="comment">/* We&#39;ve hit some instruction we don&#39;t know how to simulate.</span>
<a name="l01845"></a>01845 <span class="comment">           Strictly speaking, we should set every value we&#39;re</span>
<a name="l01846"></a>01846 <span class="comment">           tracking to &quot;unknown&quot;.  But we&#39;ll be optimistic, assume</span>
<a name="l01847"></a>01847 <span class="comment">           that we have enough information already, and stop</span>
<a name="l01848"></a>01848 <span class="comment">           analysis here.  */</span>
<a name="l01849"></a>01849         <span class="keywordflow">break</span>;
<a name="l01850"></a>01850 
<a name="l01851"></a>01851       <span class="comment">/* If this instruction changed the FP or decreased the SP (i.e.,</span>
<a name="l01852"></a>01852 <span class="comment">         allocated more stack space), then this may be a good place to</span>
<a name="l01853"></a>01853 <span class="comment">         declare the prologue finished.  However, there are some</span>
<a name="l01854"></a>01854 <span class="comment">         exceptions:</span>
<a name="l01855"></a>01855 <span class="comment"></span>
<a name="l01856"></a>01856 <span class="comment">         - If the instruction just changed the FP back to its original</span>
<a name="l01857"></a>01857 <span class="comment">           value, then that&#39;s probably a restore instruction.  The</span>
<a name="l01858"></a>01858 <span class="comment">           prologue should definitely end before that.  </span>
<a name="l01859"></a>01859 <span class="comment"></span>
<a name="l01860"></a>01860 <span class="comment">         - If the instruction increased the value of the SP (that is,</span>
<a name="l01861"></a>01861 <span class="comment">           shrunk the frame), then it&#39;s probably part of a frame</span>
<a name="l01862"></a>01862 <span class="comment">           teardown sequence, and the prologue should end before that.  */</span>
<a name="l01863"></a>01863 
<a name="l01864"></a>01864       <span class="keywordflow">if</span> (! <a class="code" href="prologue-value_8c.html#a3c9e13a6dc53cd468eb98e73968f52c9">pv_is_identical</a> (reg[<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab8e40c2c305839597884fb849cff53b4">MEP_FP_REGNUM</a>], pre_insn_fp))
<a name="l01865"></a>01865         {
<a name="l01866"></a>01866           <span class="keywordflow">if</span> (! <a class="code" href="prologue-value_8c.html#a2a8f42226ec88b80bd295476a6648df6">pv_is_register_k</a> (reg[MEP_FP_REGNUM], MEP_FP_REGNUM, 0))
<a name="l01867"></a>01867             after_last_frame_setup_insn = next_pc;
<a name="l01868"></a>01868         }
<a name="l01869"></a>01869       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (! <a class="code" href="prologue-value_8c.html#a3c9e13a6dc53cd468eb98e73968f52c9">pv_is_identical</a> (reg[<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ad6caa78945d52ae1bfeba530ae2bf72e">MEP_SP_REGNUM</a>], pre_insn_sp))
<a name="l01870"></a>01870         {
<a name="l01871"></a>01871           <span class="comment">/* The comparison of constants looks odd, there, because .k</span>
<a name="l01872"></a>01872 <span class="comment">             is unsigned.  All it really means is that the new value</span>
<a name="l01873"></a>01873 <span class="comment">             is lower than it was before the instruction.  */</span>
<a name="l01874"></a>01874           <span class="keywordflow">if</span> (<a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (pre_insn_sp, MEP_SP_REGNUM)
<a name="l01875"></a>01875               &amp;&amp; <a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (reg[MEP_SP_REGNUM], MEP_SP_REGNUM)
<a name="l01876"></a>01876               &amp;&amp; ((pre_insn_sp.<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a> - reg[MEP_SP_REGNUM].<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a>)
<a name="l01877"></a>01877                   &lt; (reg[MEP_SP_REGNUM].<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a> - pre_insn_sp.<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a>)))
<a name="l01878"></a>01878             after_last_frame_setup_insn = next_pc;
<a name="l01879"></a>01879         }
<a name="l01880"></a>01880 
<a name="l01881"></a>01881       pc = next_pc;
<a name="l01882"></a>01882     }
<a name="l01883"></a>01883 
<a name="l01884"></a>01884   <span class="comment">/* Is the frame size (offset, really) a known constant?  */</span>
<a name="l01885"></a>01885   <span class="keywordflow">if</span> (<a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (reg[MEP_SP_REGNUM], MEP_SP_REGNUM))
<a name="l01886"></a>01886     result-&gt;frame_size = reg[<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ad6caa78945d52ae1bfeba530ae2bf72e">MEP_SP_REGNUM</a>].<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a>;
<a name="l01887"></a>01887 
<a name="l01888"></a>01888   <span class="comment">/* Was the frame pointer initialized?  */</span>
<a name="l01889"></a>01889   <span class="keywordflow">if</span> (<a class="code" href="prologue-value_8c.html#acb3cd4d819006186a58efb6243d43a29">pv_is_register</a> (reg[MEP_FP_REGNUM], MEP_SP_REGNUM))
<a name="l01890"></a>01890     {
<a name="l01891"></a>01891       result-&gt;has_frame_ptr = 1;
<a name="l01892"></a>01892       result-&gt;frame_ptr_offset = reg[<a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80ab8e40c2c305839597884fb849cff53b4">MEP_FP_REGNUM</a>].<a class="code" href="structprologue__value.html#a2dd1a03b2edadea2ade3c7d2aec24d22">k</a>;
<a name="l01893"></a>01893     }
<a name="l01894"></a>01894 
<a name="l01895"></a>01895   <span class="comment">/* Record where all the registers were saved.  */</span>
<a name="l01896"></a>01896   <a class="code" href="prologue-value_8c.html#a4401a7a0b5fb6495e7db332f34e89db4">pv_area_scan</a> (stack, check_for_saved, (<span class="keywordtype">void</span> *) result);
<a name="l01897"></a>01897 
<a name="l01898"></a>01898   result-&gt;prologue_end = after_last_frame_setup_insn;
<a name="l01899"></a>01899 
<a name="l01900"></a>01900   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (back_to);
<a name="l01901"></a>01901 }
<a name="l01902"></a>01902 
<a name="l01903"></a>01903 
<a name="l01904"></a>01904 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01905"></a>01905 mep_skip_prologue (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc)
<a name="l01906"></a>01906 {
<a name="l01907"></a>01907   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l01908"></a>01908   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> func_addr, func_end;
<a name="l01909"></a>01909   <span class="keyword">struct </span>mep_prologue <a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>;
<a name="l01910"></a>01910 
<a name="l01911"></a>01911   <span class="comment">/* Try to find the extent of the function that contains PC.  */</span>
<a name="l01912"></a>01912   <span class="keywordflow">if</span> (! <a class="code" href="blockframe_8c.html#a2dae2257ad1417604d2c26f8b9071ca9">find_pc_partial_function</a> (pc, &amp;name, &amp;func_addr, &amp;func_end))
<a name="l01913"></a>01913     <span class="keywordflow">return</span> pc;
<a name="l01914"></a>01914 
<a name="l01915"></a>01915   mep_analyze_prologue (gdbarch, pc, func_end, &amp;p);
<a name="l01916"></a>01916   <span class="keywordflow">return</span> p.prologue_end;
<a name="l01917"></a>01917 }
<a name="l01918"></a>01918 
<a name="l01919"></a>01919 
<a name="l01920"></a>01920 
<a name="l01921"></a>01921 <span class="comment">/* Breakpoints.  */</span>
<a name="l01922"></a>01922 
<a name="l01923"></a>01923 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *
<a name="l01924"></a>01924 mep_breakpoint_from_pc (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> * pcptr, <span class="keywordtype">int</span> *lenptr)
<a name="l01925"></a>01925 {
<a name="l01926"></a>01926   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structbreakpoint.html">breakpoint</a>[] = { 0x70, 0x32 };
<a name="l01927"></a>01927   *lenptr = <span class="keyword">sizeof</span> (breakpoint);
<a name="l01928"></a>01928   <span class="keywordflow">return</span> breakpoint;
<a name="l01929"></a>01929 }
<a name="l01930"></a>01930 
<a name="l01931"></a>01931 
<a name="l01932"></a>01932 
<a name="l01933"></a>01933 <span class="comment">/* Frames and frame unwinding.  */</span>
<a name="l01934"></a>01934 
<a name="l01935"></a>01935 
<a name="l01936"></a>01936 <span class="keyword">static</span> <span class="keyword">struct </span>mep_prologue *
<a name="l01937"></a>01937 mep_analyze_frame_prologue (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01938"></a>01938                             <span class="keywordtype">void</span> **this_prologue_cache)
<a name="l01939"></a>01939 {
<a name="l01940"></a>01940   <span class="keywordflow">if</span> (! *this_prologue_cache)
<a name="l01941"></a>01941     {
<a name="l01942"></a>01942       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> func_start, stop_addr;
<a name="l01943"></a>01943 
<a name="l01944"></a>01944       *this_prologue_cache 
<a name="l01945"></a>01945         = <a class="code" href="frame_8h.html#af9f5c3008a0d58374aa310c5c63af552">FRAME_OBSTACK_ZALLOC</a> (<span class="keyword">struct</span> mep_prologue);
<a name="l01946"></a>01946 
<a name="l01947"></a>01947       func_start = <a class="code" href="frame_8c.html#ac64c0ce600cc134b2256c0d507f57cde">get_frame_func</a> (this_frame);
<a name="l01948"></a>01948       stop_addr = <a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a> (this_frame);
<a name="l01949"></a>01949 
<a name="l01950"></a>01950       <span class="comment">/* If we couldn&#39;t find any function containing the PC, then</span>
<a name="l01951"></a>01951 <span class="comment">         just initialize the prologue cache, but don&#39;t do anything.  */</span>
<a name="l01952"></a>01952       <span class="keywordflow">if</span> (! func_start)
<a name="l01953"></a>01953         stop_addr = func_start;
<a name="l01954"></a>01954 
<a name="l01955"></a>01955       mep_analyze_prologue (<a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame),
<a name="l01956"></a>01956                             func_start, stop_addr, *this_prologue_cache);
<a name="l01957"></a>01957     }
<a name="l01958"></a>01958 
<a name="l01959"></a>01959   <span class="keywordflow">return</span> *this_prologue_cache;
<a name="l01960"></a>01960 }
<a name="l01961"></a>01961 
<a name="l01962"></a>01962 
<a name="l01963"></a>01963 <span class="comment">/* Given the next frame and a prologue cache, return this frame&#39;s</span>
<a name="l01964"></a>01964 <span class="comment">   base.  */</span>
<a name="l01965"></a>01965 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01966"></a>01966 mep_frame_base (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01967"></a>01967                 <span class="keywordtype">void</span> **this_prologue_cache)
<a name="l01968"></a>01968 {
<a name="l01969"></a>01969   <span class="keyword">struct </span>mep_prologue *p
<a name="l01970"></a>01970     = mep_analyze_frame_prologue (this_frame, this_prologue_cache);
<a name="l01971"></a>01971 
<a name="l01972"></a>01972   <span class="comment">/* In functions that use alloca, the distance between the stack</span>
<a name="l01973"></a>01973 <span class="comment">     pointer and the frame base varies dynamically, so we can&#39;t use</span>
<a name="l01974"></a>01974 <span class="comment">     the SP plus static information like prologue analysis to find the</span>
<a name="l01975"></a>01975 <span class="comment">     frame base.  However, such functions must have a frame pointer,</span>
<a name="l01976"></a>01976 <span class="comment">     to be able to restore the SP on exit.  So whenever we do have a</span>
<a name="l01977"></a>01977 <span class="comment">     frame pointer, use that to find the base.  */</span>
<a name="l01978"></a>01978   <span class="keywordflow">if</span> (p-&gt;has_frame_ptr)
<a name="l01979"></a>01979     {
<a name="l01980"></a>01980       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> fp
<a name="l01981"></a>01981         = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, MEP_FP_REGNUM);
<a name="l01982"></a>01982       <span class="keywordflow">return</span> fp - p-&gt;frame_ptr_offset;
<a name="l01983"></a>01983     }
<a name="l01984"></a>01984   <span class="keywordflow">else</span>
<a name="l01985"></a>01985     {
<a name="l01986"></a>01986       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="windows-nat_8c.html#a8d40798874dab99986478ef00ff3e297">sp</a>
<a name="l01987"></a>01987         = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, MEP_SP_REGNUM);
<a name="l01988"></a>01988       <span class="keywordflow">return</span> sp - p-&gt;frame_size;
<a name="l01989"></a>01989     }
<a name="l01990"></a>01990 }
<a name="l01991"></a>01991 
<a name="l01992"></a>01992 
<a name="l01993"></a>01993 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01994"></a>01994 mep_frame_this_id (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01995"></a>01995                    <span class="keywordtype">void</span> **this_prologue_cache,
<a name="l01996"></a>01996                    <span class="keyword">struct</span> <a class="code" href="structframe__id.html">frame_id</a> *this_id)
<a name="l01997"></a>01997 {
<a name="l01998"></a>01998   *this_id = <a class="code" href="frame_8c.html#a7f32da6ddc275b4684c301448d891f5b">frame_id_build</a> (mep_frame_base (this_frame, this_prologue_cache),
<a name="l01999"></a>01999                              <a class="code" href="frame_8c.html#ac64c0ce600cc134b2256c0d507f57cde">get_frame_func</a> (this_frame));
<a name="l02000"></a>02000 }
<a name="l02001"></a>02001 
<a name="l02002"></a>02002 
<a name="l02003"></a>02003 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l02004"></a>02004 mep_frame_prev_register (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l02005"></a>02005                          <span class="keywordtype">void</span> **this_prologue_cache, <span class="keywordtype">int</span> regnum)
<a name="l02006"></a>02006 {
<a name="l02007"></a>02007   <span class="keyword">struct </span>mep_prologue *p
<a name="l02008"></a>02008     = mep_analyze_frame_prologue (this_frame, this_prologue_cache);
<a name="l02009"></a>02009 
<a name="l02010"></a>02010   <span class="comment">/* There are a number of complications in unwinding registers on the</span>
<a name="l02011"></a>02011 <span class="comment">     MeP, having to do with core functions calling VLIW functions and</span>
<a name="l02012"></a>02012 <span class="comment">     vice versa.</span>
<a name="l02013"></a>02013 <span class="comment"></span>
<a name="l02014"></a>02014 <span class="comment">     The least significant bit of the link register, LP.LTOM, is the</span>
<a name="l02015"></a>02015 <span class="comment">     VLIW mode toggle bit: it&#39;s set if a core function called a VLIW</span>
<a name="l02016"></a>02016 <span class="comment">     function, or vice versa, and clear when the caller and callee</span>
<a name="l02017"></a>02017 <span class="comment">     were both in the same mode.</span>
<a name="l02018"></a>02018 <span class="comment"></span>
<a name="l02019"></a>02019 <span class="comment">     So, if we&#39;re asked to unwind the PC, then we really want to</span>
<a name="l02020"></a>02020 <span class="comment">     unwind the LP and clear the least significant bit.  (Real return</span>
<a name="l02021"></a>02021 <span class="comment">     addresses are always even.)  And if we want to unwind the program</span>
<a name="l02022"></a>02022 <span class="comment">     status word (PSW), we need to toggle PSW.OM if LP.LTOM is set.</span>
<a name="l02023"></a>02023 <span class="comment"></span>
<a name="l02024"></a>02024 <span class="comment">     Tweaking the register values we return in this way means that the</span>
<a name="l02025"></a>02025 <span class="comment">     bits in BUFFERP[] are not the same as the bits you&#39;d find at</span>
<a name="l02026"></a>02026 <span class="comment">     ADDRP in the inferior, so we make sure lvalp is not_lval when we</span>
<a name="l02027"></a>02027 <span class="comment">     do this.  */</span>
<a name="l02028"></a>02028   <span class="keywordflow">if</span> (regnum == <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a464266bf8621c2383d30dec93302052f">MEP_PC_REGNUM</a>)
<a name="l02029"></a>02029     {
<a name="l02030"></a>02030       <span class="keyword">struct </span>value *value;
<a name="l02031"></a>02031       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> lp;
<a name="l02032"></a>02032       value = mep_frame_prev_register (this_frame, this_prologue_cache,
<a name="l02033"></a>02033                                        <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aad5bbcbfcd514d1aacf8ac13f37c08e5">MEP_LP_REGNUM</a>);
<a name="l02034"></a>02034       lp = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (value);
<a name="l02035"></a>02035       <a class="code" href="value_8c.html#a5a9662fcdbefec2edef0b912ba593914">release_value</a> (value);
<a name="l02036"></a>02036       <a class="code" href="value_8c.html#a1f9b3ee232ece65ddc75c2407b97a50d">value_free</a> (value);
<a name="l02037"></a>02037 
<a name="l02038"></a>02038       <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#ac7df103c9cdd8847accaa5752e4f52ea">frame_unwind_got_constant</a> (this_frame, regnum, lp &amp; ~1);
<a name="l02039"></a>02039     }
<a name="l02040"></a>02040   <span class="keywordflow">else</span>
<a name="l02041"></a>02041     {
<a name="l02042"></a>02042       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structframe__base.html">frame_base</a> = mep_frame_base (this_frame, this_prologue_cache);
<a name="l02043"></a>02043       <span class="keyword">struct </span>value *value;
<a name="l02044"></a>02044 
<a name="l02045"></a>02045       <span class="comment">/* Our caller&#39;s SP is our frame base.  */</span>
<a name="l02046"></a>02046       <span class="keywordflow">if</span> (regnum == MEP_SP_REGNUM)
<a name="l02047"></a>02047         <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#ac7df103c9cdd8847accaa5752e4f52ea">frame_unwind_got_constant</a> (this_frame, regnum, frame_base);
<a name="l02048"></a>02048 
<a name="l02049"></a>02049       <span class="comment">/* If prologue analysis says we saved this register somewhere,</span>
<a name="l02050"></a>02050 <span class="comment">         return a description of the stack slot holding it.  */</span>
<a name="l02051"></a>02051       <span class="keywordflow">if</span> (p-&gt;reg_offset[regnum] != 1)
<a name="l02052"></a>02052         value = <a class="code" href="frame-unwind_8c.html#ae7eed0715ca9ef71b626f80e3f026be9">frame_unwind_got_memory</a> (this_frame, regnum,
<a name="l02053"></a>02053                                          frame_base + p-&gt;reg_offset[regnum]);
<a name="l02054"></a>02054 
<a name="l02055"></a>02055       <span class="comment">/* Otherwise, presume we haven&#39;t changed the value of this</span>
<a name="l02056"></a>02056 <span class="comment">         register, and get it from the next frame.  */</span>
<a name="l02057"></a>02057       <span class="keywordflow">else</span>
<a name="l02058"></a>02058         value = <a class="code" href="frame-unwind_8c.html#a07784a5660795d4ca4bb82e05e0bc4f5">frame_unwind_got_register</a> (this_frame, regnum, regnum);
<a name="l02059"></a>02059 
<a name="l02060"></a>02060       <span class="comment">/* If we need to toggle the operating mode, do so.  */</span>
<a name="l02061"></a>02061       <span class="keywordflow">if</span> (regnum == <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a1669f3815f327efd1cf23f9c5f1d6cc7">MEP_PSW_REGNUM</a>)
<a name="l02062"></a>02062         {
<a name="l02063"></a>02063           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> psw, lp;
<a name="l02064"></a>02064 
<a name="l02065"></a>02065           psw = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (value);
<a name="l02066"></a>02066           <a class="code" href="value_8c.html#a5a9662fcdbefec2edef0b912ba593914">release_value</a> (value);
<a name="l02067"></a>02067           <a class="code" href="value_8c.html#a1f9b3ee232ece65ddc75c2407b97a50d">value_free</a> (value);
<a name="l02068"></a>02068 
<a name="l02069"></a>02069           <span class="comment">/* Get the LP&#39;s value, too.  */</span>
<a name="l02070"></a>02070           value = <a class="code" href="frame_8c.html#a9248987fa3f2eca38f734e66139fbbcd">get_frame_register_value</a> (this_frame, <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aad5bbcbfcd514d1aacf8ac13f37c08e5">MEP_LP_REGNUM</a>);
<a name="l02071"></a>02071           lp = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (value);
<a name="l02072"></a>02072           <a class="code" href="value_8c.html#a5a9662fcdbefec2edef0b912ba593914">release_value</a> (value);
<a name="l02073"></a>02073           <a class="code" href="value_8c.html#a1f9b3ee232ece65ddc75c2407b97a50d">value_free</a> (value);
<a name="l02074"></a>02074 
<a name="l02075"></a>02075           <span class="comment">/* If LP.LTOM is set, then toggle PSW.OM.  */</span>
<a name="l02076"></a>02076           <span class="keywordflow">if</span> (lp &amp; 0x1)
<a name="l02077"></a>02077             psw ^= 0x1000;
<a name="l02078"></a>02078 
<a name="l02079"></a>02079           <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#ac7df103c9cdd8847accaa5752e4f52ea">frame_unwind_got_constant</a> (this_frame, regnum, psw);
<a name="l02080"></a>02080         }
<a name="l02081"></a>02081 
<a name="l02082"></a>02082       <span class="keywordflow">return</span> value;
<a name="l02083"></a>02083     }
<a name="l02084"></a>02084 }
<a name="l02085"></a>02085 
<a name="l02086"></a>02086 
<a name="l02087"></a>02087 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structframe__unwind.html">frame_unwind</a> mep_frame_unwind = {
<a name="l02088"></a>02088   <a class="code" href="frame_8h.html#a3ca2c0bc7578bf3d337e34b2c08a6c5faeb4f7fd6d9e397d1141feb133746637a">NORMAL_FRAME</a>,
<a name="l02089"></a>02089   <a class="code" href="frame-unwind_8c.html#aa950afe60921514574c6150f0821f05c">default_frame_unwind_stop_reason</a>,
<a name="l02090"></a>02090   mep_frame_this_id,
<a name="l02091"></a>02091   mep_frame_prev_register,
<a name="l02092"></a>02092   NULL,
<a name="l02093"></a>02093   <a class="code" href="frame-unwind_8c.html#ade64a9807fa508622581cc779b10ff9c">default_frame_sniffer</a>
<a name="l02094"></a>02094 };
<a name="l02095"></a>02095 
<a name="l02096"></a>02096 
<a name="l02097"></a>02097 <span class="comment">/* Our general unwinding function can handle unwinding the PC.  */</span>
<a name="l02098"></a>02098 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l02099"></a>02099 mep_unwind_pc (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> frame_info *next_frame)
<a name="l02100"></a>02100 {
<a name="l02101"></a>02101   <span class="keywordflow">return</span> <a class="code" href="frame_8c.html#a294f6912118884550787fd59f2a08ff6">frame_unwind_register_unsigned</a> (next_frame, <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a464266bf8621c2383d30dec93302052f">MEP_PC_REGNUM</a>);
<a name="l02102"></a>02102 }
<a name="l02103"></a>02103 
<a name="l02104"></a>02104 
<a name="l02105"></a>02105 <span class="comment">/* Our general unwinding function can handle unwinding the SP.  */</span>
<a name="l02106"></a>02106 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l02107"></a>02107 mep_unwind_sp (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> frame_info *next_frame)
<a name="l02108"></a>02108 {
<a name="l02109"></a>02109   <span class="keywordflow">return</span> <a class="code" href="frame_8c.html#a294f6912118884550787fd59f2a08ff6">frame_unwind_register_unsigned</a> (next_frame, MEP_SP_REGNUM);
<a name="l02110"></a>02110 }
<a name="l02111"></a>02111 
<a name="l02112"></a>02112 
<a name="l02113"></a>02113 
<a name="l02114"></a>02114 <span class="comment">/* Return values.  */</span>
<a name="l02115"></a>02115 
<a name="l02116"></a>02116 
<a name="l02117"></a>02117 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02118"></a>02118 mep_use_struct_convention (<span class="keyword">struct</span> type *type)
<a name="l02119"></a>02119 {
<a name="l02120"></a>02120   <span class="keywordflow">return</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) &gt; <a class="code" href="mep-tdep_8c.html#aaf5a317de939ca4047f8bdac4501a8df">MEP_GPR_SIZE</a>);
<a name="l02121"></a>02121 }
<a name="l02122"></a>02122 
<a name="l02123"></a>02123 
<a name="l02124"></a>02124 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02125"></a>02125 mep_extract_return_value (<span class="keyword">struct</span> gdbarch *arch,
<a name="l02126"></a>02126                           <span class="keyword">struct</span> type *type,
<a name="l02127"></a>02127                           <span class="keyword">struct</span> regcache *regcache,
<a name="l02128"></a>02128                           <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valbuf)
<a name="l02129"></a>02129 {
<a name="l02130"></a>02130   <span class="keywordtype">int</span> byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (arch);
<a name="l02131"></a>02131 
<a name="l02132"></a>02132   <span class="comment">/* Values that don&#39;t occupy a full register appear at the less</span>
<a name="l02133"></a>02133 <span class="comment">     significant end of the value.  This is the offset to where the</span>
<a name="l02134"></a>02134 <span class="comment">     value starts.  */</span>
<a name="l02135"></a>02135   <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l02136"></a>02136 
<a name="l02137"></a>02137   <span class="comment">/* Return values &gt; MEP_GPR_SIZE bytes are returned in memory,</span>
<a name="l02138"></a>02138 <span class="comment">     pointed to by R0.  */</span>
<a name="l02139"></a>02139   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) &lt;= <a class="code" href="mep-tdep_8c.html#aaf5a317de939ca4047f8bdac4501a8df">MEP_GPR_SIZE</a>);
<a name="l02140"></a>02140 
<a name="l02141"></a>02141   <span class="keywordflow">if</span> (byte_order == BFD_ENDIAN_BIG)
<a name="l02142"></a>02142     offset = <a class="code" href="mep-tdep_8c.html#aaf5a317de939ca4047f8bdac4501a8df">MEP_GPR_SIZE</a> - <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type);
<a name="l02143"></a>02143   <span class="keywordflow">else</span>
<a name="l02144"></a>02144     offset = 0;
<a name="l02145"></a>02145 
<a name="l02146"></a>02146   <span class="comment">/* Return values that do fit in a single register are returned in R0.  */</span>
<a name="l02147"></a>02147   <a class="code" href="regcache_8c.html#a0df90ba73f76a25dbbd99903a5b57a27">regcache_cooked_read_part</a> (regcache, <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a1d0cacc10a49c742f19431b8c2eaace6">MEP_R0_REGNUM</a>,
<a name="l02148"></a>02148                              offset, <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type),
<a name="l02149"></a>02149                              valbuf);
<a name="l02150"></a>02150 }
<a name="l02151"></a>02151 
<a name="l02152"></a>02152 
<a name="l02153"></a>02153 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02154"></a>02154 mep_store_return_value (<span class="keyword">struct</span> gdbarch *arch,
<a name="l02155"></a>02155                         <span class="keyword">struct</span> type *type,
<a name="l02156"></a>02156                         <span class="keyword">struct</span> regcache *regcache,
<a name="l02157"></a>02157                         <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valbuf)
<a name="l02158"></a>02158 {
<a name="l02159"></a>02159   <span class="keywordtype">int</span> byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (arch);
<a name="l02160"></a>02160 
<a name="l02161"></a>02161   <span class="comment">/* Values that fit in a single register go in R0.  */</span>
<a name="l02162"></a>02162   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) &lt;= <a class="code" href="mep-tdep_8c.html#aaf5a317de939ca4047f8bdac4501a8df">MEP_GPR_SIZE</a>)
<a name="l02163"></a>02163     {
<a name="l02164"></a>02164       <span class="comment">/* Values that don&#39;t occupy a full register appear at the least</span>
<a name="l02165"></a>02165 <span class="comment">         significant end of the value.  This is the offset to where the</span>
<a name="l02166"></a>02166 <span class="comment">         value starts.  */</span>
<a name="l02167"></a>02167       <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l02168"></a>02168 
<a name="l02169"></a>02169       <span class="keywordflow">if</span> (byte_order == BFD_ENDIAN_BIG)
<a name="l02170"></a>02170         offset = <a class="code" href="mep-tdep_8c.html#aaf5a317de939ca4047f8bdac4501a8df">MEP_GPR_SIZE</a> - <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type);
<a name="l02171"></a>02171       <span class="keywordflow">else</span>
<a name="l02172"></a>02172         offset = 0;
<a name="l02173"></a>02173 
<a name="l02174"></a>02174       <a class="code" href="regcache_8c.html#a722867e06f34f859c10d2c3e175f4519">regcache_cooked_write_part</a> (regcache, <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a1d0cacc10a49c742f19431b8c2eaace6">MEP_R0_REGNUM</a>,
<a name="l02175"></a>02175                                   offset, <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type),
<a name="l02176"></a>02176                                   valbuf);
<a name="l02177"></a>02177     }
<a name="l02178"></a>02178 
<a name="l02179"></a>02179   <span class="comment">/* Return values larger than a single register are returned in</span>
<a name="l02180"></a>02180 <span class="comment">     memory, pointed to by R0.  Unfortunately, we can&#39;t count on R0</span>
<a name="l02181"></a>02181 <span class="comment">     pointing to the return buffer, so we raise an error here.  */</span>
<a name="l02182"></a>02182   <span class="keywordflow">else</span>
<a name="l02183"></a>02183     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l02184"></a>02184 <span class="stringliteral">GDB cannot set return values larger than four bytes; the Media Processor&#39;s\n\</span>
<a name="l02185"></a>02185 <span class="stringliteral">calling conventions do not provide enough information to do this.\n\</span>
<a name="l02186"></a>02186 <span class="stringliteral">Try using the &#39;return&#39; command with no argument.&quot;</span>));
<a name="l02187"></a>02187 }
<a name="l02188"></a>02188 
<a name="l02189"></a>02189 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5">return_value_convention</a>
<a name="l02190"></a>02190 mep_return_value (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> value *<span class="keyword">function</span>,
<a name="l02191"></a>02191                   <span class="keyword">struct</span> type *type, <span class="keyword">struct</span> regcache *regcache,
<a name="l02192"></a>02192                   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *readbuf, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *writebuf)
<a name="l02193"></a>02193 {
<a name="l02194"></a>02194   <span class="keywordflow">if</span> (mep_use_struct_convention (type))
<a name="l02195"></a>02195     {
<a name="l02196"></a>02196       <span class="keywordflow">if</span> (readbuf)
<a name="l02197"></a>02197         {
<a name="l02198"></a>02198           <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> addr;
<a name="l02199"></a>02199           <span class="comment">/* Although the address of the struct buffer gets passed in R1, it&#39;s</span>
<a name="l02200"></a>02200 <span class="comment">             returned in R0.  Fetch R0&#39;s value and then read the memory</span>
<a name="l02201"></a>02201 <span class="comment">             at that address.  */</span>
<a name="l02202"></a>02202           <a class="code" href="regcache_8c.html#a465c747dfdb94bb985d56e0374eb4481">regcache_raw_read_unsigned</a> (regcache, <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a1d0cacc10a49c742f19431b8c2eaace6">MEP_R0_REGNUM</a>, &amp;addr);
<a name="l02203"></a>02203           <a class="code" href="corefile_8c.html#a5e0189c6f21f1c9321b379877183b819">read_memory</a> (addr, readbuf, <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type));
<a name="l02204"></a>02204         }
<a name="l02205"></a>02205       <span class="keywordflow">if</span> (writebuf)
<a name="l02206"></a>02206         {
<a name="l02207"></a>02207           <span class="comment">/* Return values larger than a single register are returned in</span>
<a name="l02208"></a>02208 <span class="comment">             memory, pointed to by R0.  Unfortunately, we can&#39;t count on R0</span>
<a name="l02209"></a>02209 <span class="comment">             pointing to the return buffer, so we raise an error here.  */</span>
<a name="l02210"></a>02210           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l02211"></a>02211 <span class="stringliteral">GDB cannot set return values larger than four bytes; the Media Processor&#39;s\n\</span>
<a name="l02212"></a>02212 <span class="stringliteral">calling conventions do not provide enough information to do this.\n\</span>
<a name="l02213"></a>02213 <span class="stringliteral">Try using the &#39;return&#39; command with no argument.&quot;</span>));
<a name="l02214"></a>02214         }
<a name="l02215"></a>02215       <span class="keywordflow">return</span> <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5a00f278d54cd655da91166f8b58133f7e">RETURN_VALUE_ABI_RETURNS_ADDRESS</a>;
<a name="l02216"></a>02216     }
<a name="l02217"></a>02217 
<a name="l02218"></a>02218   <span class="keywordflow">if</span> (readbuf)
<a name="l02219"></a>02219     mep_extract_return_value (gdbarch, type, regcache, readbuf);
<a name="l02220"></a>02220   <span class="keywordflow">if</span> (writebuf)
<a name="l02221"></a>02221     mep_store_return_value (gdbarch, type, regcache, writebuf);
<a name="l02222"></a>02222 
<a name="l02223"></a>02223   <span class="keywordflow">return</span> <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5a0cd14b7546740080384acc0c7e5caf3b">RETURN_VALUE_REGISTER_CONVENTION</a>;
<a name="l02224"></a>02224 }
<a name="l02225"></a>02225 
<a name="l02226"></a>02226 
<a name="l02227"></a>02227 <span class="comment">/* Inferior calls.  */</span>
<a name="l02228"></a>02228 
<a name="l02229"></a>02229 
<a name="l02230"></a>02230 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l02231"></a>02231 mep_frame_align (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> sp)
<a name="l02232"></a>02232 {
<a name="l02233"></a>02233   <span class="comment">/* Require word alignment.  */</span>
<a name="l02234"></a>02234   <span class="keywordflow">return</span> sp &amp; -4;
<a name="l02235"></a>02235 }
<a name="l02236"></a>02236 
<a name="l02237"></a>02237 
<a name="l02238"></a>02238 <span class="comment">/* From &quot;lang_spec2.txt&quot;:</span>
<a name="l02239"></a>02239 <span class="comment"></span>
<a name="l02240"></a>02240 <span class="comment">   4.2 Calling conventions</span>
<a name="l02241"></a>02241 <span class="comment"></span>
<a name="l02242"></a>02242 <span class="comment">   4.2.1 Core register conventions</span>
<a name="l02243"></a>02243 <span class="comment"></span>
<a name="l02244"></a>02244 <span class="comment">   - Parameters should be evaluated from left to right, and they</span>
<a name="l02245"></a>02245 <span class="comment">     should be held in $1,$2,$3,$4 in order.  The fifth parameter or</span>
<a name="l02246"></a>02246 <span class="comment">     after should be held in the stack.  If the size is larger than 4</span>
<a name="l02247"></a>02247 <span class="comment">     bytes in the first four parameters, the pointer should be held in</span>
<a name="l02248"></a>02248 <span class="comment">     the registers instead.  If the size is larger than 4 bytes in the</span>
<a name="l02249"></a>02249 <span class="comment">     fifth parameter or after, the pointer should be held in the stack.</span>
<a name="l02250"></a>02250 <span class="comment"></span>
<a name="l02251"></a>02251 <span class="comment">   - Return value of a function should be held in register $0.  If the</span>
<a name="l02252"></a>02252 <span class="comment">     size of return value is larger than 4 bytes, $1 should hold the</span>
<a name="l02253"></a>02253 <span class="comment">     pointer pointing memory that would hold the return value.  In this</span>
<a name="l02254"></a>02254 <span class="comment">     case, the first parameter should be held in $2, the second one in</span>
<a name="l02255"></a>02255 <span class="comment">     $3, and the third one in $4, and the forth parameter or after</span>
<a name="l02256"></a>02256 <span class="comment">     should be held in the stack.</span>
<a name="l02257"></a>02257 <span class="comment"></span>
<a name="l02258"></a>02258 <span class="comment">   [This doesn&#39;t say so, but arguments shorter than four bytes are</span>
<a name="l02259"></a>02259 <span class="comment">   passed in the least significant end of a four-byte word when</span>
<a name="l02260"></a>02260 <span class="comment">   they&#39;re passed on the stack.]  */</span>
<a name="l02261"></a>02261 
<a name="l02262"></a>02262 
<a name="l02263"></a>02263 <span class="comment">/* Traverse the list of ARGC arguments ARGV; for every ARGV[i] too</span>
<a name="l02264"></a>02264 <span class="comment">   large to fit in a register, save it on the stack, and place its</span>
<a name="l02265"></a>02265 <span class="comment">   address in COPY[i].  SP is the initial stack pointer; return the</span>
<a name="l02266"></a>02266 <span class="comment">   new stack pointer.  */</span>
<a name="l02267"></a>02267 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l02268"></a>02268 push_large_arguments (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> sp, <span class="keywordtype">int</span> argc, <span class="keyword">struct</span> value **argv,
<a name="l02269"></a>02269                       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> copy[])
<a name="l02270"></a>02270 {
<a name="l02271"></a>02271   <span class="keywordtype">int</span> i;
<a name="l02272"></a>02272 
<a name="l02273"></a>02273   <span class="keywordflow">for</span> (i = 0; i &lt; argc; i++)
<a name="l02274"></a>02274     {
<a name="l02275"></a>02275       <span class="keywordtype">unsigned</span> arg_len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (argv[i]));
<a name="l02276"></a>02276 
<a name="l02277"></a>02277       <span class="keywordflow">if</span> (arg_len &gt; <a class="code" href="mep-tdep_8c.html#aaf5a317de939ca4047f8bdac4501a8df">MEP_GPR_SIZE</a>)
<a name="l02278"></a>02278         {
<a name="l02279"></a>02279           <span class="comment">/* Reserve space for the copy, and then round the SP down, to</span>
<a name="l02280"></a>02280 <span class="comment">             make sure it&#39;s all aligned properly.  */</span>
<a name="l02281"></a>02281           sp = (sp - arg_len) &amp; -4;
<a name="l02282"></a>02282           <a class="code" href="corefile_8c.html#a05c568c157071d9349667fab589228e5">write_memory</a> (sp, <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (argv[i]), arg_len);
<a name="l02283"></a>02283           copy[i] = sp;
<a name="l02284"></a>02284         }
<a name="l02285"></a>02285     }
<a name="l02286"></a>02286 
<a name="l02287"></a>02287   <span class="keywordflow">return</span> sp;
<a name="l02288"></a>02288 }
<a name="l02289"></a>02289 
<a name="l02290"></a>02290 
<a name="l02291"></a>02291 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l02292"></a>02292 mep_push_dummy_call (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> value *<span class="keyword">function</span>,
<a name="l02293"></a>02293                      <span class="keyword">struct</span> regcache *regcache, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> bp_addr,
<a name="l02294"></a>02294                      <span class="keywordtype">int</span> argc, <span class="keyword">struct</span> value **argv, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> sp,
<a name="l02295"></a>02295                      <span class="keywordtype">int</span> <a class="code" href="arm-tdep_8h.html#aabb639d85dec2f973451bb1e7b6d1be8">struct_return</a>,
<a name="l02296"></a>02296                      <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> struct_addr)
<a name="l02297"></a>02297 {
<a name="l02298"></a>02298   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l02299"></a>02299   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *copy = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *) alloca (argc * <span class="keyword">sizeof</span> (copy[0]));
<a name="l02300"></a>02300   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> func_addr = <a class="code" href="infcall_8c.html#a68f258349aa77867901ff0b0ba2815a9">find_function_addr</a> (<span class="keyword">function</span>, NULL);
<a name="l02301"></a>02301   <span class="keywordtype">int</span> i;
<a name="l02302"></a>02302 
<a name="l02303"></a>02303   <span class="comment">/* The number of the next register available to hold an argument.  */</span>
<a name="l02304"></a>02304   <span class="keywordtype">int</span> arg_reg;
<a name="l02305"></a>02305 
<a name="l02306"></a>02306   <span class="comment">/* The address of the next stack slot available to hold an argument.  */</span>
<a name="l02307"></a>02307   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> arg_stack;
<a name="l02308"></a>02308 
<a name="l02309"></a>02309   <span class="comment">/* The address of the end of the stack area for arguments.  This is</span>
<a name="l02310"></a>02310 <span class="comment">     just for error checking.  */</span>
<a name="l02311"></a>02311   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> arg_stack_end;
<a name="l02312"></a>02312   
<a name="l02313"></a>02313   sp = push_large_arguments (sp, argc, argv, copy);
<a name="l02314"></a>02314 
<a name="l02315"></a>02315   <span class="comment">/* Reserve space for the stack arguments, if any.  */</span>
<a name="l02316"></a>02316   arg_stack_end = sp;
<a name="l02317"></a>02317   <span class="keywordflow">if</span> (argc + (struct_addr ? 1 : 0) &gt; 4)
<a name="l02318"></a>02318     sp -= ((argc + (struct_addr ? 1 : 0)) - 4) * <a class="code" href="mep-tdep_8c.html#aaf5a317de939ca4047f8bdac4501a8df">MEP_GPR_SIZE</a>;
<a name="l02319"></a>02319 
<a name="l02320"></a>02320   arg_reg = <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80acc56f4b49717da58bfc9ffa158dd5015">MEP_R1_REGNUM</a>;
<a name="l02321"></a>02321   arg_stack = sp;
<a name="l02322"></a>02322 
<a name="l02323"></a>02323   <span class="comment">/* If we&#39;re returning a structure by value, push the pointer to the</span>
<a name="l02324"></a>02324 <span class="comment">     buffer as the first argument.  */</span>
<a name="l02325"></a>02325   <span class="keywordflow">if</span> (struct_return)
<a name="l02326"></a>02326     {
<a name="l02327"></a>02327       <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a> (regcache, arg_reg, struct_addr);
<a name="l02328"></a>02328       arg_reg++;
<a name="l02329"></a>02329     }
<a name="l02330"></a>02330 
<a name="l02331"></a>02331   <span class="keywordflow">for</span> (i = 0; i &lt; argc; i++)
<a name="l02332"></a>02332     {
<a name="l02333"></a>02333       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> value;
<a name="l02334"></a>02334 
<a name="l02335"></a>02335       <span class="comment">/* Arguments that fit in a GPR get expanded to fill the GPR.  */</span>
<a name="l02336"></a>02336       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (argv[i])) &lt;= <a class="code" href="mep-tdep_8c.html#aaf5a317de939ca4047f8bdac4501a8df">MEP_GPR_SIZE</a>)
<a name="l02337"></a>02337         value = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (<a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (argv[i]),
<a name="l02338"></a>02338                                           <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (argv[i])),
<a name="l02339"></a>02339                                           byte_order);
<a name="l02340"></a>02340 
<a name="l02341"></a>02341       <span class="comment">/* Arguments too large to fit in a GPR get copied to the stack,</span>
<a name="l02342"></a>02342 <span class="comment">         and we pass a pointer to the copy.  */</span>
<a name="l02343"></a>02343       <span class="keywordflow">else</span>
<a name="l02344"></a>02344         value = copy[i];
<a name="l02345"></a>02345 
<a name="l02346"></a>02346       <span class="comment">/* We use $1 -- $4 for passing arguments, then use the stack.  */</span>
<a name="l02347"></a>02347       <span class="keywordflow">if</span> (arg_reg &lt;= <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a8b5cc0f6cb43b1571bac042b6fa57e2e">MEP_R4_REGNUM</a>)
<a name="l02348"></a>02348         {
<a name="l02349"></a>02349           <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a> (regcache, arg_reg, value);
<a name="l02350"></a>02350           arg_reg++;
<a name="l02351"></a>02351         }
<a name="l02352"></a>02352       <span class="keywordflow">else</span>
<a name="l02353"></a>02353         {
<a name="l02354"></a>02354           <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> buf[<a class="code" href="mep-tdep_8c.html#aaf5a317de939ca4047f8bdac4501a8df">MEP_GPR_SIZE</a>];
<a name="l02355"></a>02355           <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (buf, <a class="code" href="mep-tdep_8c.html#aaf5a317de939ca4047f8bdac4501a8df">MEP_GPR_SIZE</a>, byte_order, value);
<a name="l02356"></a>02356           <a class="code" href="corefile_8c.html#a05c568c157071d9349667fab589228e5">write_memory</a> (arg_stack, buf, <a class="code" href="mep-tdep_8c.html#aaf5a317de939ca4047f8bdac4501a8df">MEP_GPR_SIZE</a>);
<a name="l02357"></a>02357           arg_stack += <a class="code" href="mep-tdep_8c.html#aaf5a317de939ca4047f8bdac4501a8df">MEP_GPR_SIZE</a>;
<a name="l02358"></a>02358         }
<a name="l02359"></a>02359     }
<a name="l02360"></a>02360 
<a name="l02361"></a>02361   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (arg_stack &lt;= arg_stack_end);
<a name="l02362"></a>02362 
<a name="l02363"></a>02363   <span class="comment">/* Set the return address.  */</span>
<a name="l02364"></a>02364   <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a> (regcache, <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80aad5bbcbfcd514d1aacf8ac13f37c08e5">MEP_LP_REGNUM</a>, bp_addr);
<a name="l02365"></a>02365 
<a name="l02366"></a>02366   <span class="comment">/* Update the stack pointer.  */</span>
<a name="l02367"></a>02367   <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a> (regcache, MEP_SP_REGNUM, sp);
<a name="l02368"></a>02368   
<a name="l02369"></a>02369   <span class="keywordflow">return</span> sp;
<a name="l02370"></a>02370 }
<a name="l02371"></a>02371 
<a name="l02372"></a>02372 
<a name="l02373"></a>02373 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structframe__id.html">frame_id</a>
<a name="l02374"></a>02374 mep_dummy_id (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> frame_info *this_frame)
<a name="l02375"></a>02375 {
<a name="l02376"></a>02376   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> sp = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, MEP_SP_REGNUM);
<a name="l02377"></a>02377   <span class="keywordflow">return</span> <a class="code" href="frame_8c.html#a7f32da6ddc275b4684c301448d891f5b">frame_id_build</a> (sp, <a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a> (this_frame));
<a name="l02378"></a>02378 }
<a name="l02379"></a>02379 
<a name="l02380"></a>02380 
<a name="l02381"></a>02381 
<a name="l02382"></a>02382 <span class="comment">/* Initialization.  */</span>
<a name="l02383"></a>02383 
<a name="l02384"></a>02384 
<a name="l02385"></a>02385 <span class="keyword">static</span> <span class="keyword">struct </span>gdbarch *
<a name="l02386"></a>02386 mep_gdbarch_init (<span class="keyword">struct</span> <a class="code" href="structgdbarch__info.html">gdbarch_info</a> info, <span class="keyword">struct</span> <a class="code" href="structgdbarch__list.html">gdbarch_list</a> *arches)
<a name="l02387"></a>02387 {
<a name="l02388"></a>02388   <span class="keyword">struct </span>gdbarch *gdbarch;
<a name="l02389"></a>02389   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep;
<a name="l02390"></a>02390 
<a name="l02391"></a>02391   <span class="comment">/* Which me_module are we building a gdbarch object for?  */</span>
<a name="l02392"></a>02392   CONFIG_ATTR me_module;
<a name="l02393"></a>02393 
<a name="l02394"></a>02394   <span class="comment">/* If we have a BFD in hand, figure out which me_module it was built</span>
<a name="l02395"></a>02395 <span class="comment">     for.  Otherwise, use the no-particular-me_module code.  */</span>
<a name="l02396"></a>02396   <span class="keywordflow">if</span> (info.<a class="code" href="structgdbarch__info.html#a3c4162054156176568f3b6aab88c2d58">abfd</a>)
<a name="l02397"></a>02397     {
<a name="l02398"></a>02398       <span class="comment">/* The way to get the me_module code depends on the object file</span>
<a name="l02399"></a>02399 <span class="comment">         format.  At the moment, we only know how to handle ELF.  */</span>
<a name="l02400"></a>02400       <span class="keywordflow">if</span> (bfd_get_flavour (info.<a class="code" href="structgdbarch__info.html#a3c4162054156176568f3b6aab88c2d58">abfd</a>) == bfd_target_elf_flavour)
<a name="l02401"></a>02401         me_module = elf_elfheader (info.<a class="code" href="structgdbarch__info.html#a3c4162054156176568f3b6aab88c2d58">abfd</a>)-&gt;<a class="code" href="structgdbarch__tdep.html#a097fb7cabd279bdb1775a087ccbb8bfe">e_flags</a> &amp; EF_MEP_INDEX_MASK;
<a name="l02402"></a>02402       <span class="keywordflow">else</span>
<a name="l02403"></a>02403         me_module = CONFIG_NONE;
<a name="l02404"></a>02404     }
<a name="l02405"></a>02405   <span class="keywordflow">else</span>
<a name="l02406"></a>02406     me_module = CONFIG_NONE;
<a name="l02407"></a>02407 
<a name="l02408"></a>02408   <span class="comment">/* If we&#39;re setting the architecture from a file, check the</span>
<a name="l02409"></a>02409 <span class="comment">     endianness of the file against that of the me_module.  */</span>
<a name="l02410"></a>02410   <span class="keywordflow">if</span> (info.<a class="code" href="structgdbarch__info.html#a3c4162054156176568f3b6aab88c2d58">abfd</a>)
<a name="l02411"></a>02411     {
<a name="l02412"></a>02412       <span class="comment">/* The negations on either side make the comparison treat all</span>
<a name="l02413"></a>02413 <span class="comment">         non-zero (true) values as equal.  */</span>
<a name="l02414"></a>02414       <span class="keywordflow">if</span> (! bfd_big_endian (info.<a class="code" href="structgdbarch__info.html#a3c4162054156176568f3b6aab88c2d58">abfd</a>) != ! me_module_big_endian (me_module))
<a name="l02415"></a>02415         {
<a name="l02416"></a>02416           <span class="keyword">const</span> <span class="keywordtype">char</span> *module_name = me_module_name (me_module);
<a name="l02417"></a>02417           <span class="keyword">const</span> <span class="keywordtype">char</span> *module_endianness
<a name="l02418"></a>02418             = me_module_big_endian (me_module) ? <span class="stringliteral">&quot;big&quot;</span> : <span class="stringliteral">&quot;little&quot;</span>;
<a name="l02419"></a>02419           <span class="keyword">const</span> <span class="keywordtype">char</span> *file_name = bfd_get_filename (info.<a class="code" href="structgdbarch__info.html#a3c4162054156176568f3b6aab88c2d58">abfd</a>);
<a name="l02420"></a>02420           <span class="keyword">const</span> <span class="keywordtype">char</span> *file_endianness
<a name="l02421"></a>02421             = bfd_big_endian (info.<a class="code" href="structgdbarch__info.html#a3c4162054156176568f3b6aab88c2d58">abfd</a>) ? <span class="stringliteral">&quot;big&quot;</span> : <span class="stringliteral">&quot;little&quot;</span>;
<a name="l02422"></a>02422           
<a name="l02423"></a>02423           <a class="code" href="utils_8c.html#ad68fe4a88bf7dc2738de79643ce8f927">fputc_unfiltered</a> (<span class="charliteral">&#39;\n&#39;</span>, <a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>);
<a name="l02424"></a>02424           <span class="keywordflow">if</span> (module_name)
<a name="l02425"></a>02425             <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;the MeP module &#39;%s&#39; is %s-endian, but the executable\n&quot;</span>
<a name="l02426"></a>02426                        <span class="stringliteral">&quot;%s is %s-endian.&quot;</span>),
<a name="l02427"></a>02427                      module_name, module_endianness,
<a name="l02428"></a>02428                      file_name, file_endianness);
<a name="l02429"></a>02429           <span class="keywordflow">else</span>
<a name="l02430"></a>02430             <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;the selected MeP module is %s-endian, but the &quot;</span>
<a name="l02431"></a>02431                        <span class="stringliteral">&quot;executable\n&quot;</span>
<a name="l02432"></a>02432                        <span class="stringliteral">&quot;%s is %s-endian.&quot;</span>),
<a name="l02433"></a>02433                      module_endianness, file_name, file_endianness);
<a name="l02434"></a>02434         }
<a name="l02435"></a>02435     }
<a name="l02436"></a>02436 
<a name="l02437"></a>02437   <span class="comment">/* Find a candidate among the list of architectures we&#39;ve created</span>
<a name="l02438"></a>02438 <span class="comment">     already.  info-&gt;bfd_arch_info needs to match, but we also want</span>
<a name="l02439"></a>02439 <span class="comment">     the right me_module: the ELF header&#39;s e_flags field needs to</span>
<a name="l02440"></a>02440 <span class="comment">     match as well.  */</span>
<a name="l02441"></a>02441   <span class="keywordflow">for</span> (arches = <a class="code" href="gdbarch_8c.html#aa3ea1c25a21a533dfd0d924a7d9778e4">gdbarch_list_lookup_by_info</a> (arches, &amp;info); 
<a name="l02442"></a>02442        arches != NULL;
<a name="l02443"></a>02443        arches = <a class="code" href="gdbarch_8c.html#aa3ea1c25a21a533dfd0d924a7d9778e4">gdbarch_list_lookup_by_info</a> (arches-&gt;<a class="code" href="structgdbarch__list.html#a9da6f84112797b67d5d8e7b8d4e26b14">next</a>, &amp;info))
<a name="l02444"></a>02444     <span class="keywordflow">if</span> (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (arches-&gt;<a class="code" href="structgdbarch__list.html#a6c51da8c4c95249704dfe18394fd08f9">gdbarch</a>)-&gt;<a class="code" href="structgdbarch__tdep.html#a19f7f93966ab0c170dce987f0f510ad7">me_module</a> == me_module)
<a name="l02445"></a>02445       <span class="keywordflow">return</span> arches-&gt;<a class="code" href="structgdbarch__list.html#a6c51da8c4c95249704dfe18394fd08f9">gdbarch</a>;
<a name="l02446"></a>02446 
<a name="l02447"></a>02447   tdep = (<span class="keyword">struct</span> <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *) <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a>));
<a name="l02448"></a>02448   gdbarch = <a class="code" href="gdbarch_8c.html#a9e0b0979fa2cb7439f41f66deda8dec5">gdbarch_alloc</a> (&amp;info, tdep);
<a name="l02449"></a>02449 
<a name="l02450"></a>02450   <span class="comment">/* Get a CGEN CPU descriptor for this architecture.  */</span>
<a name="l02451"></a>02451   {
<a name="l02452"></a>02452     <span class="keyword">const</span> <span class="keywordtype">char</span> *mach_name = info.<a class="code" href="structgdbarch__info.html#ad42b7b45e0927c2482ba178db64b2fa7">bfd_arch_info</a>-&gt;printable_name;
<a name="l02453"></a>02453     <span class="keyword">enum</span> cgen_endian endian = (info.<a class="code" href="structgdbarch__info.html#a3e00b4a4262051d8be65696b48662225">byte_order</a> == BFD_ENDIAN_BIG
<a name="l02454"></a>02454                                ? CGEN_ENDIAN_BIG
<a name="l02455"></a>02455                                : CGEN_ENDIAN_LITTLE);
<a name="l02456"></a>02456 
<a name="l02457"></a>02457     tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a14020af34bc3c1abd19ac7183b374864">cpu_desc</a> = mep_cgen_cpu_open (CGEN_CPU_OPEN_BFDMACH, mach_name,
<a name="l02458"></a>02458                                         CGEN_CPU_OPEN_ENDIAN, endian,
<a name="l02459"></a>02459                                         CGEN_CPU_OPEN_END);
<a name="l02460"></a>02460   }
<a name="l02461"></a>02461 
<a name="l02462"></a>02462   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a19f7f93966ab0c170dce987f0f510ad7">me_module</a> = me_module;
<a name="l02463"></a>02463 
<a name="l02464"></a>02464   <span class="comment">/* Register set.  */</span>
<a name="l02465"></a>02465   <a class="code" href="gdbarch_8c.html#ab63f129c7af7d29dcea12aabd9048c1f">set_gdbarch_read_pc</a> (gdbarch, mep_read_pc);
<a name="l02466"></a>02466   <a class="code" href="gdbarch_8c.html#ad8417c5d66cf04d0587f58f82de94c48">set_gdbarch_num_regs</a> (gdbarch, <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a907f7d5f15b707cc0a695074ff1438ba">MEP_NUM_RAW_REGS</a>);
<a name="l02467"></a>02467   <a class="code" href="gdbarch_8c.html#a8852f70e2afc74953a57521ed08a3381">set_gdbarch_pc_regnum</a> (gdbarch, <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a464266bf8621c2383d30dec93302052f">MEP_PC_REGNUM</a>);
<a name="l02468"></a>02468   <a class="code" href="gdbarch_8c.html#a81a92a88a67093d18e59fd5650fda352">set_gdbarch_sp_regnum</a> (gdbarch, MEP_SP_REGNUM);
<a name="l02469"></a>02469   <a class="code" href="gdbarch_8c.html#a378ba40a6275393e204873c5bba602ad">set_gdbarch_register_name</a> (gdbarch, mep_register_name);
<a name="l02470"></a>02470   <a class="code" href="gdbarch_8c.html#a21919f6adfae80ed36e69e89cdfea531">set_gdbarch_register_type</a> (gdbarch, mep_register_type);
<a name="l02471"></a>02471   <a class="code" href="gdbarch_8c.html#aaf72e08f972ba348d5d28f6b6b8db638">set_gdbarch_num_pseudo_regs</a> (gdbarch, <a class="code" href="mep-tdep_8c.html#a4b4213b1f9d54da7c7e36bde32fc7c80a64123ddbf37ca51d62c35f38cc089cb0">MEP_NUM_PSEUDO_REGS</a>);
<a name="l02472"></a>02472   <a class="code" href="gdbarch_8c.html#a99fd57c1a882cf61c413e64028937a1b">set_gdbarch_pseudo_register_read</a> (gdbarch, mep_pseudo_register_read);
<a name="l02473"></a>02473   <a class="code" href="gdbarch_8c.html#ae463eca1992acf69ff1bc28ed8ca3aea">set_gdbarch_pseudo_register_write</a> (gdbarch, mep_pseudo_register_write);
<a name="l02474"></a>02474   <a class="code" href="gdbarch_8c.html#a43ca55f05fcf599681eb376bbc6c8ece">set_gdbarch_dwarf2_reg_to_regnum</a> (gdbarch, mep_debug_reg_to_regnum);
<a name="l02475"></a>02475   <a class="code" href="gdbarch_8c.html#abeb6b220ed850a9f2b4a992dfcae9a2b">set_gdbarch_stab_reg_to_regnum</a> (gdbarch, mep_debug_reg_to_regnum);
<a name="l02476"></a>02476 
<a name="l02477"></a>02477   <a class="code" href="gdbarch_8c.html#a17301533b8e9f7002350ed0a2f4b5558">set_gdbarch_register_reggroup_p</a> (gdbarch, mep_register_reggroup_p);
<a name="l02478"></a>02478   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, <a class="code" href="reggroups_8c.html#a1c7760844f4c40a5fb70e84f76f39676">all_reggroup</a>);
<a name="l02479"></a>02479   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, <a class="code" href="reggroups_8c.html#a2409cc2e19cc71ae02448af0ec0308fd">general_reggroup</a>);
<a name="l02480"></a>02480   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, <a class="code" href="reggroups_8c.html#a9be54927c9d0393a70b8a3f0bc740de3">save_reggroup</a>);
<a name="l02481"></a>02481   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, <a class="code" href="reggroups_8c.html#a627d3b74a917560e7d81d93c472e915c">restore_reggroup</a>);
<a name="l02482"></a>02482   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, mep_csr_reggroup);
<a name="l02483"></a>02483   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, mep_cr_reggroup);
<a name="l02484"></a>02484   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, mep_ccr_reggroup);
<a name="l02485"></a>02485 
<a name="l02486"></a>02486   <span class="comment">/* Disassembly.  */</span>
<a name="l02487"></a>02487   <a class="code" href="gdbarch_8c.html#a0c9e9e391e44d476b74debefc407e9bb">set_gdbarch_print_insn</a> (gdbarch, mep_gdb_print_insn); 
<a name="l02488"></a>02488 
<a name="l02489"></a>02489   <span class="comment">/* Breakpoints.  */</span>
<a name="l02490"></a>02490   <a class="code" href="gdbarch_8c.html#ad738cdf37fa27f4cf3642107cadf61d3">set_gdbarch_breakpoint_from_pc</a> (gdbarch, mep_breakpoint_from_pc);
<a name="l02491"></a>02491   <a class="code" href="gdbarch_8c.html#a59e0f429a0c89806415bb5e1b7367bb8">set_gdbarch_decr_pc_after_break</a> (gdbarch, 0);
<a name="l02492"></a>02492   <a class="code" href="gdbarch_8c.html#a841509ae0070f2f12aa9b3b7fd52b92f">set_gdbarch_skip_prologue</a> (gdbarch, mep_skip_prologue);
<a name="l02493"></a>02493 
<a name="l02494"></a>02494   <span class="comment">/* Frames and frame unwinding.  */</span>
<a name="l02495"></a>02495   <a class="code" href="frame-unwind_8c.html#afa4de8a130514bfd524d46f32e35a534">frame_unwind_append_unwinder</a> (gdbarch, &amp;mep_frame_unwind);
<a name="l02496"></a>02496   <a class="code" href="gdbarch_8c.html#a1974f5f26c09a4cd32165286c3769621">set_gdbarch_unwind_pc</a> (gdbarch, mep_unwind_pc);
<a name="l02497"></a>02497   <a class="code" href="gdbarch_8c.html#ababd871cc4b5fac1831e52f7331d7572">set_gdbarch_unwind_sp</a> (gdbarch, mep_unwind_sp);
<a name="l02498"></a>02498   <a class="code" href="gdbarch_8c.html#ad66381ed135b13aa5635f0485211ca71">set_gdbarch_inner_than</a> (gdbarch, <a class="code" href="arch-utils_8c.html#aaceae1c07203f3091df647f813b9f20e">core_addr_lessthan</a>);
<a name="l02499"></a>02499   <a class="code" href="gdbarch_8c.html#affeacd014397bbaf442f32de0cb4b86c">set_gdbarch_frame_args_skip</a> (gdbarch, 0);
<a name="l02500"></a>02500 
<a name="l02501"></a>02501   <span class="comment">/* Return values.  */</span>
<a name="l02502"></a>02502   <a class="code" href="gdbarch_8c.html#ad9b13a9323cac027c4b805953b4fff63">set_gdbarch_return_value</a> (gdbarch, mep_return_value);
<a name="l02503"></a>02503   
<a name="l02504"></a>02504   <span class="comment">/* Inferior function calls.  */</span>
<a name="l02505"></a>02505   <a class="code" href="gdbarch_8c.html#aff48f6a8b2982831522fc7b3af596654">set_gdbarch_frame_align</a> (gdbarch, mep_frame_align);
<a name="l02506"></a>02506   <a class="code" href="gdbarch_8c.html#a853528dceff46211c1bb8c57b77dca31">set_gdbarch_push_dummy_call</a> (gdbarch, mep_push_dummy_call);
<a name="l02507"></a>02507   <a class="code" href="gdbarch_8c.html#a23da982924f904d22d0b58639a48bccf">set_gdbarch_dummy_id</a> (gdbarch, mep_dummy_id);
<a name="l02508"></a>02508 
<a name="l02509"></a>02509   <span class="keywordflow">return</span> gdbarch;
<a name="l02510"></a>02510 }
<a name="l02511"></a>02511 
<a name="l02512"></a>02512 <span class="comment">/* Provide a prototype to silence -Wmissing-prototypes.  */</span>
<a name="l02513"></a>02513 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#a686ed07d4fdcdc366f2bc677216ca08d">initialize_file_ftype</a> <a class="code" href="mep-tdep_8c.html#a7081a02510a3615572d0aea290929e2f">_initialize_mep_tdep</a>;
<a name="l02514"></a>02514 
<a name="l02515"></a>02515 <span class="keywordtype">void</span>
<a name="l02516"></a><a class="code" href="mep-tdep_8c.html#a707d9548e0a33970f79b0e78c29df198">02516</a> _initialize_mep_tdep (<span class="keywordtype">void</span>)
<a name="l02517"></a>02517 {
<a name="l02518"></a>02518   mep_csr_reggroup = <a class="code" href="reggroups_8c.html#a3cb3369b5063997a1382cfb8ad240ad6">reggroup_new</a> (<span class="stringliteral">&quot;csr&quot;</span>, <a class="code" href="reggroups_8h.html#a7377a90943c0ba0d23c3b03a07583f22a9ef6d86366eea2f7b79d387752a38be1">USER_REGGROUP</a>);
<a name="l02519"></a>02519   mep_cr_reggroup  = <a class="code" href="reggroups_8c.html#a3cb3369b5063997a1382cfb8ad240ad6">reggroup_new</a> (<span class="stringliteral">&quot;cr&quot;</span>, <a class="code" href="reggroups_8h.html#a7377a90943c0ba0d23c3b03a07583f22a9ef6d86366eea2f7b79d387752a38be1">USER_REGGROUP</a>); 
<a name="l02520"></a>02520   mep_ccr_reggroup = <a class="code" href="reggroups_8c.html#a3cb3369b5063997a1382cfb8ad240ad6">reggroup_new</a> (<span class="stringliteral">&quot;ccr&quot;</span>, <a class="code" href="reggroups_8h.html#a7377a90943c0ba0d23c3b03a07583f22a9ef6d86366eea2f7b79d387752a38be1">USER_REGGROUP</a>);
<a name="l02521"></a>02521 
<a name="l02522"></a>02522   <a class="code" href="gdbarch_8c.html#adb96505b62850783929ff38de0c39062">register_gdbarch_init</a> (bfd_arch_mep, mep_gdbarch_init);
<a name="l02523"></a>02523 
<a name="l02524"></a>02524   mep_init_pseudoregister_maps ();
<a name="l02525"></a>02525 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:12:20 for GDB (API) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
