<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (API): /home/stan/gdb/src/gdb/nios2-tdep.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (API)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/nios2-tdep.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="nios2-tdep_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Target-machine dependent code for Nios II, for GDB.</span>
<a name="l00002"></a>00002 <span class="comment">   Copyright (C) 2012-2013 Free Software Foundation, Inc.</span>
<a name="l00003"></a>00003 <span class="comment">   Contributed by Peter Brookes (pbrookes@altera.com)</span>
<a name="l00004"></a>00004 <span class="comment">   and Andrew Draper (adraper@altera.com).</span>
<a name="l00005"></a>00005 <span class="comment">   Contributed by Mentor Graphics, Inc.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This file is part of GDB.</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00010"></a>00010 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00011"></a>00011 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00012"></a>00012 <span class="comment">   (at your option) any later version.</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00015"></a>00015 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00016"></a>00016 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00017"></a>00017 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00020"></a>00020 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="frame_8h.html">frame.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="frame-unwind_8h.html">frame-unwind.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="frame-base_8h.html">frame-base.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="trad-frame_8h.html">trad-frame.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="dwarf2-frame_8h.html">dwarf2-frame.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="inferior_8h.html">inferior.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="gdbtypes_8h.html">gdbtypes.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="gdbcore_8h.html">gdbcore.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="gdbcmd_8h.html">gdbcmd.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="osabi_8h.html">osabi.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="target_8h.html">target.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;dis-asm.h&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="regcache_8h.html">regcache.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="value_8h.html">value.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="symfile_8h.html">symfile.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="arch-utils_8h.html">arch-utils.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;floatformat.h&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="gdb__assert_8h.html">gdb_assert.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="infcall_8h.html">infcall.h</a>&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="regset_8h.html">regset.h</a>&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="target-descriptions_8h.html">target-descriptions.h</a>&quot;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="comment">/* To get entry_point_address.  */</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="objfiles_8h.html">objfiles.h</a>&quot;</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="comment">/* Nios II ISA specific encodings and macros.  */</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;opcode/nios2.h&quot;</span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">/* Nios II specific header.  */</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;<a class="code" href="nios2-tdep_8h.html">nios2-tdep.h</a>&quot;</span>
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;<a class="code" href="nios2_8c.html">features/nios2.c</a>&quot;</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="comment">/* Control debugging information emitted in this file.  */</span>
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="keyword">static</span> <span class="keywordtype">int</span> nios2_debug = 0;
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 <span class="comment">/* The following structures are used in the cache for prologue</span>
<a name="l00062"></a>00062 <span class="comment">   analysis; see the reg_value and reg_saved tables in</span>
<a name="l00063"></a>00063 <span class="comment">   struct nios2_unwind_cache, respectively.  */</span>
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="comment">/* struct reg_value is used to record that a register has the same value</span>
<a name="l00066"></a>00066 <span class="comment">   as reg at the given offset from the start of a function.  */</span>
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="keyword">struct </span>reg_value
<a name="l00069"></a>00069 {
<a name="l00070"></a>00070   <span class="keywordtype">int</span> <a class="code" href="structreg.html">reg</a>;
<a name="l00071"></a>00071   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l00072"></a>00072 };
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="comment">/* struct reg_saved is used to record that a register value has been saved at</span>
<a name="l00075"></a>00075 <span class="comment">   basereg + addr, for basereg &gt;= 0.  If basereg &lt; 0, that indicates</span>
<a name="l00076"></a>00076 <span class="comment">   that the register is not known to have been saved.  Note that when</span>
<a name="l00077"></a>00077 <span class="comment">   basereg == NIOS2_Z_REGNUM (that is, r0, which holds value 0),</span>
<a name="l00078"></a>00078 <span class="comment">   addr is an absolute address.  */</span>
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="keyword">struct </span>reg_saved
<a name="l00081"></a>00081 {
<a name="l00082"></a>00082   <span class="keywordtype">int</span> basereg;
<a name="l00083"></a>00083   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr;
<a name="l00084"></a>00084 };
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="keyword">struct </span>nios2_unwind_cache
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088   <span class="comment">/* The frame&#39;s base, optionally used by the high-level debug info.  */</span>
<a name="l00089"></a>00089   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> base;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091   <span class="comment">/* The previous frame&#39;s inner most stack address.  Used as this</span>
<a name="l00092"></a>00092 <span class="comment">     frame ID&#39;s stack_addr.  */</span>
<a name="l00093"></a>00093   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> cfa;
<a name="l00094"></a>00094 
<a name="l00095"></a>00095   <span class="comment">/* The address of the first instruction in this function.  */</span>
<a name="l00096"></a>00096   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098   <span class="comment">/* Which register holds the return address for the frame.  */</span>
<a name="l00099"></a>00099   <span class="keywordtype">int</span> return_regnum;
<a name="l00100"></a>00100 
<a name="l00101"></a>00101   <span class="comment">/* Table indicating what changes have been made to each register.  */</span>
<a name="l00102"></a>00102   <span class="keyword">struct </span>reg_value reg_value[<a class="code" href="nios2-tdep_8h.html#ae913e9c123638347d36317e8b4ac30b6">NIOS2_NUM_REGS</a>];
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   <span class="comment">/* Table indicating where each register has been saved.  */</span>
<a name="l00105"></a>00105   <span class="keyword">struct </span>reg_saved reg_saved[<a class="code" href="nios2-tdep_8h.html#ae913e9c123638347d36317e8b4ac30b6">NIOS2_NUM_REGS</a>];
<a name="l00106"></a>00106 };
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="comment">/* This array is a mapping from Dwarf-2 register numbering to GDB&#39;s.  */</span>
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="keyword">static</span> <span class="keywordtype">int</span> nios2_dwarf2gdb_regno_map[] =
<a name="l00112"></a>00112 {
<a name="l00113"></a>00113   0, 1, 2, 3,
<a name="l00114"></a>00114   4, 5, 6, 7,
<a name="l00115"></a>00115   8, 9, 10, 11,
<a name="l00116"></a>00116   12, 13, 14, 15,
<a name="l00117"></a>00117   16, 17, 18, 19,
<a name="l00118"></a>00118   20, 21, 22, 23,
<a name="l00119"></a>00119   24, 25,
<a name="l00120"></a>00120   <a class="code" href="nios2-tdep_8h.html#ae5db260a626846c3d5b5109ed76733b3">NIOS2_GP_REGNUM</a>,        <span class="comment">/* 26 */</span>
<a name="l00121"></a>00121   <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>,        <span class="comment">/* 27 */</span>
<a name="l00122"></a>00122   <a class="code" href="nios2-tdep_8h.html#a4b5ed12c478cd03646c67169468da353">NIOS2_FP_REGNUM</a>,        <span class="comment">/* 28 */</span>
<a name="l00123"></a>00123   <a class="code" href="nios2-tdep_8h.html#aba9a2cf08fb40cca31f975ebde0e837e">NIOS2_EA_REGNUM</a>,        <span class="comment">/* 29 */</span>
<a name="l00124"></a>00124   <a class="code" href="nios2-tdep_8h.html#ab7cc1d04882afb724402bd81c9297f4e">NIOS2_BA_REGNUM</a>,        <span class="comment">/* 30 */</span>
<a name="l00125"></a>00125   <a class="code" href="nios2-tdep_8h.html#a8e532c6ea2657f3072e6ef7f31e65aa4">NIOS2_RA_REGNUM</a>,        <span class="comment">/* 31 */</span>
<a name="l00126"></a>00126   <a class="code" href="nios2-tdep_8h.html#ac374f770ebf073bfdb22cfce666f8a3f">NIOS2_PC_REGNUM</a>,        <span class="comment">/* 32 */</span>
<a name="l00127"></a>00127   <a class="code" href="nios2-tdep_8h.html#a59ba01e551a4b1c25486b12e82957841">NIOS2_STATUS_REGNUM</a>,    <span class="comment">/* 33 */</span>
<a name="l00128"></a>00128   <a class="code" href="nios2-tdep_8h.html#a6e2413c1e1d729bf3199a1e82df43401">NIOS2_ESTATUS_REGNUM</a>,   <span class="comment">/* 34 */</span>
<a name="l00129"></a>00129   <a class="code" href="nios2-tdep_8h.html#ac0c3dfc598ee531710eddb7af7c58040">NIOS2_BSTATUS_REGNUM</a>,   <span class="comment">/* 35 */</span>
<a name="l00130"></a>00130   <a class="code" href="nios2-tdep_8h.html#a66d1bbc6c302f7e93aa935726f3e39c3">NIOS2_IENABLE_REGNUM</a>,   <span class="comment">/* 36 */</span>
<a name="l00131"></a>00131   <a class="code" href="nios2-tdep_8h.html#ab9bc5591ef56dbf74b4a861a31ceeb04">NIOS2_IPENDING_REGNUM</a>,  <span class="comment">/* 37 */</span>
<a name="l00132"></a>00132   <a class="code" href="nios2-tdep_8h.html#a182f73998de80eb9a88b2ca804e1e75c">NIOS2_CPUID_REGNUM</a>,     <span class="comment">/* 38 */</span>
<a name="l00133"></a>00133   39, <span class="comment">/* CTL6 */</span>          <span class="comment">/* 39 */</span>
<a name="l00134"></a>00134   <a class="code" href="nios2-tdep_8h.html#ae6b6f98c5ab98fb6c76e7428240a0438">NIOS2_EXCEPTION_REGNUM</a>, <span class="comment">/* 40 */</span>
<a name="l00135"></a>00135   <a class="code" href="nios2-tdep_8h.html#af73e185c480b3635a168ea3760e24385">NIOS2_PTEADDR_REGNUM</a>,   <span class="comment">/* 41 */</span>
<a name="l00136"></a>00136   <a class="code" href="nios2-tdep_8h.html#a1177a04142deb8e3af72b79dc14a5723">NIOS2_TLBACC_REGNUM</a>,    <span class="comment">/* 42 */</span>
<a name="l00137"></a>00137   <a class="code" href="nios2-tdep_8h.html#a3eae95f05175e5772074d0e75e474468">NIOS2_TLBMISC_REGNUM</a>,   <span class="comment">/* 43 */</span>
<a name="l00138"></a>00138   <a class="code" href="nios2-tdep_8h.html#a14f65aa8e84fe414b5d5c8496e112b40">NIOS2_ECCINJ_REGNUM</a>,    <span class="comment">/* 44 */</span>
<a name="l00139"></a>00139   <a class="code" href="nios2-tdep_8h.html#a6a94d9988a91d6ef487e8a197fd54548">NIOS2_BADADDR_REGNUM</a>,   <span class="comment">/* 45 */</span>
<a name="l00140"></a>00140   <a class="code" href="nios2-tdep_8h.html#a6d5a2dc748aebac925c4b0daa82d83e6">NIOS2_CONFIG_REGNUM</a>,    <span class="comment">/* 46 */</span>
<a name="l00141"></a>00141   <a class="code" href="nios2-tdep_8h.html#a7ae9cd476daa09e2d57609331ed450bb">NIOS2_MPUBASE_REGNUM</a>,   <span class="comment">/* 47 */</span>
<a name="l00142"></a>00142   <a class="code" href="nios2-tdep_8h.html#a3eb08a7461a0139feaac0d521c74e833">NIOS2_MPUACC_REGNUM</a>     <span class="comment">/* 48 */</span>
<a name="l00143"></a>00143 };
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="comment">/* Implement the dwarf2_reg_to_regnum gdbarch method.  */</span>
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00149"></a>00149 nios2_dwarf_reg_to_regnum (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> dw_reg)
<a name="l00150"></a>00150 {
<a name="l00151"></a>00151   <span class="keywordflow">if</span> (dw_reg &lt; 0 || dw_reg &gt; <a class="code" href="nios2-tdep_8h.html#ae913e9c123638347d36317e8b4ac30b6">NIOS2_NUM_REGS</a>)
<a name="l00152"></a>00152     {
<a name="l00153"></a>00153       <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Dwarf-2 uses unmapped register #%d&quot;</span>), dw_reg);
<a name="l00154"></a>00154       <span class="keywordflow">return</span> dw_reg;
<a name="l00155"></a>00155     }
<a name="l00156"></a>00156 
<a name="l00157"></a>00157   <span class="keywordflow">return</span> nios2_dwarf2gdb_regno_map[dw_reg];
<a name="l00158"></a>00158 }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 <span class="comment">/* Canonical names for the 49 registers.  */</span>
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> nios2_reg_names[<a class="code" href="nios2-tdep_8h.html#ae913e9c123638347d36317e8b4ac30b6">NIOS2_NUM_REGS</a>] =
<a name="l00163"></a>00163 {
<a name="l00164"></a>00164   <span class="stringliteral">&quot;zero&quot;</span>, <span class="stringliteral">&quot;at&quot;</span>, <span class="stringliteral">&quot;r2&quot;</span>, <span class="stringliteral">&quot;r3&quot;</span>, <span class="stringliteral">&quot;r4&quot;</span>, <span class="stringliteral">&quot;r5&quot;</span>, <span class="stringliteral">&quot;r6&quot;</span>, <span class="stringliteral">&quot;r7&quot;</span>,
<a name="l00165"></a>00165   <span class="stringliteral">&quot;r8&quot;</span>, <span class="stringliteral">&quot;r9&quot;</span>, <span class="stringliteral">&quot;r10&quot;</span>, <span class="stringliteral">&quot;r11&quot;</span>, <span class="stringliteral">&quot;r12&quot;</span>, <span class="stringliteral">&quot;r13&quot;</span>, <span class="stringliteral">&quot;r14&quot;</span>, <span class="stringliteral">&quot;r15&quot;</span>,
<a name="l00166"></a>00166   <span class="stringliteral">&quot;r16&quot;</span>, <span class="stringliteral">&quot;r17&quot;</span>, <span class="stringliteral">&quot;r18&quot;</span>, <span class="stringliteral">&quot;r19&quot;</span>, <span class="stringliteral">&quot;r20&quot;</span>, <span class="stringliteral">&quot;r21&quot;</span>, <span class="stringliteral">&quot;r22&quot;</span>, <span class="stringliteral">&quot;r23&quot;</span>,
<a name="l00167"></a>00167   <span class="stringliteral">&quot;et&quot;</span>, <span class="stringliteral">&quot;bt&quot;</span>, <span class="stringliteral">&quot;gp&quot;</span>, <span class="stringliteral">&quot;sp&quot;</span>, <span class="stringliteral">&quot;fp&quot;</span>, <span class="stringliteral">&quot;ea&quot;</span>, <span class="stringliteral">&quot;ba&quot;</span>, <span class="stringliteral">&quot;ra&quot;</span>,
<a name="l00168"></a>00168   <span class="stringliteral">&quot;pc&quot;</span>,
<a name="l00169"></a>00169   <span class="stringliteral">&quot;status&quot;</span>, <span class="stringliteral">&quot;estatus&quot;</span>, <span class="stringliteral">&quot;bstatus&quot;</span>, <span class="stringliteral">&quot;ienable&quot;</span>,
<a name="l00170"></a>00170   <span class="stringliteral">&quot;ipending&quot;</span>, <span class="stringliteral">&quot;cpuid&quot;</span>, <span class="stringliteral">&quot;ctl6&quot;</span>, <span class="stringliteral">&quot;exception&quot;</span>,
<a name="l00171"></a>00171   <span class="stringliteral">&quot;pteaddr&quot;</span>, <span class="stringliteral">&quot;tlbacc&quot;</span>, <span class="stringliteral">&quot;tlbmisc&quot;</span>, <span class="stringliteral">&quot;eccinj&quot;</span>,
<a name="l00172"></a>00172   <span class="stringliteral">&quot;badaddr&quot;</span>, <span class="stringliteral">&quot;config&quot;</span>, <span class="stringliteral">&quot;mpubase&quot;</span>, <span class="stringliteral">&quot;mpuacc&quot;</span>
<a name="l00173"></a>00173 };
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="comment">/* Implement the register_name gdbarch method.  */</span>
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00178"></a>00178 nios2_register_name (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> regno)
<a name="l00179"></a>00179 {
<a name="l00180"></a>00180   <span class="comment">/* Use mnemonic aliases for GPRs.  */</span>
<a name="l00181"></a>00181   <span class="keywordflow">if</span> (regno &gt;= 0 &amp;&amp; regno &lt; NIOS2_NUM_REGS)
<a name="l00182"></a>00182     <span class="keywordflow">return</span> nios2_reg_names[regno];
<a name="l00183"></a>00183   <span class="keywordflow">else</span>
<a name="l00184"></a>00184     <span class="keywordflow">return</span> <a class="code" href="target-descriptions_8c.html#a716bc159e6ca1ac43edf39191e252820">tdesc_register_name</a> (gdbarch, regno);
<a name="l00185"></a>00185 }
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="comment">/* Implement the register_type gdbarch method.  */</span>
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l00190"></a>00190 nios2_register_type (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> regno)
<a name="l00191"></a>00191 {
<a name="l00192"></a>00192   <span class="comment">/* If the XML description has register information, use that to</span>
<a name="l00193"></a>00193 <span class="comment">     determine the register type.  */</span>
<a name="l00194"></a>00194   <span class="keywordflow">if</span> (<a class="code" href="target-descriptions_8c.html#a54a8994f193cc0a0cf6dbb6d771becf2">tdesc_has_registers</a> (<a class="code" href="gdbarch_8c.html#a6c19d10a220639cc8f9751ad2235a9f1">gdbarch_target_desc</a> (gdbarch)))
<a name="l00195"></a>00195     <span class="keywordflow">return</span> <a class="code" href="target-descriptions_8c.html#a8c7f6fd323d2ea7f3a1d45d8084c1268">tdesc_register_type</a> (gdbarch, regno);
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   <span class="keywordflow">if</span> (regno == <a class="code" href="nios2-tdep_8h.html#ac374f770ebf073bfdb22cfce666f8a3f">NIOS2_PC_REGNUM</a>)
<a name="l00198"></a>00198     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a3db2ea73bd0003f6e6103bd031ba7cb1">builtin_func_ptr</a>;
<a name="l00199"></a>00199   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (regno == <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>)
<a name="l00200"></a>00200     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a55f6f9ff7436431777683d8ba62f662a">builtin_data_ptr</a>;
<a name="l00201"></a>00201   <span class="keywordflow">else</span>
<a name="l00202"></a>00202     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a7d0cf7d4e93c3cd2f1b744a18fa23b80">builtin_uint32</a>;
<a name="l00203"></a>00203 }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="comment">/* Given a return value in REGCACHE with a type VALTYPE,</span>
<a name="l00206"></a>00206 <span class="comment">   extract and copy its value into VALBUF.  */</span>
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00209"></a>00209 nios2_extract_return_value (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *valtype,
<a name="l00210"></a>00210                             <span class="keyword">struct</span> regcache *regcache, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valbuf)
<a name="l00211"></a>00211 {
<a name="l00212"></a>00212   <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a> = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (valtype);
<a name="l00213"></a>00213 
<a name="l00214"></a>00214   <span class="comment">/* Return values of up to 8 bytes are returned in $r2 $r3.  */</span>
<a name="l00215"></a>00215   <span class="keywordflow">if</span> (len &lt;= <a class="code" href="regcache_8c.html#a4c51fa25edb9ce25451b9dc7bd127aac">register_size</a> (gdbarch, <a class="code" href="nios2-tdep_8h.html#aaea14846b8d31fd415daa837abe4a40d">NIOS2_R2_REGNUM</a>))
<a name="l00216"></a>00216     <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (regcache, <a class="code" href="nios2-tdep_8h.html#aaea14846b8d31fd415daa837abe4a40d">NIOS2_R2_REGNUM</a>, valbuf);
<a name="l00217"></a>00217   <span class="keywordflow">else</span>
<a name="l00218"></a>00218     {
<a name="l00219"></a>00219       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (len &lt;= (<a class="code" href="regcache_8c.html#a4c51fa25edb9ce25451b9dc7bd127aac">register_size</a> (gdbarch, <a class="code" href="nios2-tdep_8h.html#aaea14846b8d31fd415daa837abe4a40d">NIOS2_R2_REGNUM</a>)
<a name="l00220"></a>00220                           + <a class="code" href="regcache_8c.html#a4c51fa25edb9ce25451b9dc7bd127aac">register_size</a> (gdbarch, <a class="code" href="nios2-tdep_8h.html#a8bee01ef2f64a18f3b3b7d2bb38131fd">NIOS2_R3_REGNUM</a>)));
<a name="l00221"></a>00221       <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (regcache, <a class="code" href="nios2-tdep_8h.html#aaea14846b8d31fd415daa837abe4a40d">NIOS2_R2_REGNUM</a>, valbuf);
<a name="l00222"></a>00222       <a class="code" href="regcache_8c.html#a7056a5ea585aa0938893952f52d95e2e">regcache_cooked_read</a> (regcache, <a class="code" href="nios2-tdep_8h.html#a8bee01ef2f64a18f3b3b7d2bb38131fd">NIOS2_R3_REGNUM</a>, valbuf + 4);
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224 }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="comment">/* Write into appropriate registers a function return value</span>
<a name="l00227"></a>00227 <span class="comment">   of type TYPE, given in virtual format.  */</span>
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00230"></a>00230 nios2_store_return_value (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *valtype,
<a name="l00231"></a>00231                           <span class="keyword">struct</span> regcache *regcache, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valbuf)
<a name="l00232"></a>00232 {
<a name="l00233"></a>00233   <span class="keywordtype">int</span> len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (valtype);
<a name="l00234"></a>00234 
<a name="l00235"></a>00235   <span class="comment">/* Return values of up to 8 bytes are returned in $r2 $r3.  */</span>
<a name="l00236"></a>00236   <span class="keywordflow">if</span> (len &lt;= <a class="code" href="regcache_8c.html#a4c51fa25edb9ce25451b9dc7bd127aac">register_size</a> (gdbarch, <a class="code" href="nios2-tdep_8h.html#aaea14846b8d31fd415daa837abe4a40d">NIOS2_R2_REGNUM</a>))
<a name="l00237"></a>00237     <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (regcache, <a class="code" href="nios2-tdep_8h.html#aaea14846b8d31fd415daa837abe4a40d">NIOS2_R2_REGNUM</a>, valbuf);
<a name="l00238"></a>00238   <span class="keywordflow">else</span>
<a name="l00239"></a>00239     {
<a name="l00240"></a>00240       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (len &lt;= (<a class="code" href="regcache_8c.html#a4c51fa25edb9ce25451b9dc7bd127aac">register_size</a> (gdbarch, <a class="code" href="nios2-tdep_8h.html#aaea14846b8d31fd415daa837abe4a40d">NIOS2_R2_REGNUM</a>)
<a name="l00241"></a>00241                           + <a class="code" href="regcache_8c.html#a4c51fa25edb9ce25451b9dc7bd127aac">register_size</a> (gdbarch, <a class="code" href="nios2-tdep_8h.html#a8bee01ef2f64a18f3b3b7d2bb38131fd">NIOS2_R3_REGNUM</a>)));
<a name="l00242"></a>00242       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (regcache, <a class="code" href="nios2-tdep_8h.html#aaea14846b8d31fd415daa837abe4a40d">NIOS2_R2_REGNUM</a>, valbuf);
<a name="l00243"></a>00243       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (regcache, <a class="code" href="nios2-tdep_8h.html#a8bee01ef2f64a18f3b3b7d2bb38131fd">NIOS2_R3_REGNUM</a>, valbuf + 4);
<a name="l00244"></a>00244     }
<a name="l00245"></a>00245 }
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="comment">/* Set up the default values of the registers.  */</span>
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00251"></a>00251 nios2_setup_default (<span class="keyword">struct</span> nios2_unwind_cache *cache)
<a name="l00252"></a>00252 {
<a name="l00253"></a>00253   <span class="keywordtype">int</span> i;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="nios2-tdep_8h.html#ae913e9c123638347d36317e8b4ac30b6">NIOS2_NUM_REGS</a>; i++)
<a name="l00256"></a>00256   {
<a name="l00257"></a>00257     <span class="comment">/* All registers start off holding their previous values.  */</span>
<a name="l00258"></a>00258     cache-&gt;reg_value[i].reg    = i;
<a name="l00259"></a>00259     cache-&gt;reg_value[i].offset = 0;
<a name="l00260"></a>00260 
<a name="l00261"></a>00261     <span class="comment">/* All registers start off not saved.  */</span>
<a name="l00262"></a>00262     cache-&gt;reg_saved[i].basereg = -1;
<a name="l00263"></a>00263     cache-&gt;reg_saved[i].addr    = 0;
<a name="l00264"></a>00264   }
<a name="l00265"></a>00265 }
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 <span class="comment">/* Initialize the unwind cache.  */</span>
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00270"></a>00270 nios2_init_cache (<span class="keyword">struct</span> nios2_unwind_cache *cache, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc)
<a name="l00271"></a>00271 {
<a name="l00272"></a>00272   cache-&gt;base = 0;
<a name="l00273"></a>00273   cache-&gt;cfa = 0;
<a name="l00274"></a>00274   cache-&gt;pc = pc;
<a name="l00275"></a>00275   cache-&gt;return_regnum = <a class="code" href="nios2-tdep_8h.html#a8e532c6ea2657f3072e6ef7f31e65aa4">NIOS2_RA_REGNUM</a>;
<a name="l00276"></a>00276   nios2_setup_default (cache);
<a name="l00277"></a>00277 }
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="comment">/* Helper function to identify when we&#39;re in a function epilogue;</span>
<a name="l00280"></a>00280 <span class="comment">   that is, the part of the function from the point at which the</span>
<a name="l00281"></a>00281 <span class="comment">   stack adjustment is made, to the return or sibcall.  On Nios II,</span>
<a name="l00282"></a>00282 <span class="comment">   we want to check that the CURRENT_PC is a return-type instruction</span>
<a name="l00283"></a>00283 <span class="comment">   and that the previous instruction is a stack adjustment.</span>
<a name="l00284"></a>00284 <span class="comment">   START_PC is the beginning of the function in question.  */</span>
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00287"></a>00287 nios2_in_epilogue_p (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l00288"></a>00288                      <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> current_pc,
<a name="l00289"></a>00289                      <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_pc)
<a name="l00290"></a>00290 {
<a name="l00291"></a>00291   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293   <span class="comment">/* There has to be a previous instruction in the function.  */</span>
<a name="l00294"></a>00294   <span class="keywordflow">if</span> (current_pc &gt; start_pc)
<a name="l00295"></a>00295     {
<a name="l00296"></a>00296 
<a name="l00297"></a>00297       <span class="comment">/* Check whether the previous instruction was a stack</span>
<a name="l00298"></a>00298 <span class="comment">         adjustment.  */</span>
<a name="l00299"></a>00299       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> insn
<a name="l00300"></a>00300         = <a class="code" href="corefile_8c.html#a280cf81e766f60b30618ae3011f2cb07">read_memory_unsigned_integer</a> (current_pc - <a class="code" href="nios2-tdep_8h.html#aec6b07e53f3a751e302ab6779d7c1d1a">NIOS2_OPCODE_SIZE</a>,
<a name="l00301"></a>00301                                         <a class="code" href="nios2-tdep_8h.html#aec6b07e53f3a751e302ab6779d7c1d1a">NIOS2_OPCODE_SIZE</a>, byte_order);
<a name="l00302"></a>00302 
<a name="l00303"></a>00303       <span class="keywordflow">if</span> ((insn &amp; 0xffc0003c) == 0xdec00004     <span class="comment">/* ADDI sp, sp, */</span>
<a name="l00304"></a>00304           || (insn &amp; 0xffc1ffff) == 0xdec1883a  <span class="comment">/* ADD  sp, sp, */</span>
<a name="l00305"></a>00305           || (insn &amp; 0xffc0003f) == 0xdec00017) <span class="comment">/* LDW  sp, constant(sp) */</span>
<a name="l00306"></a>00306         {
<a name="l00307"></a>00307           <span class="comment">/* Then check if it&#39;s followed by a return or a tail</span>
<a name="l00308"></a>00308 <span class="comment">             call.  */</span>
<a name="l00309"></a>00309           insn = <a class="code" href="corefile_8c.html#a280cf81e766f60b30618ae3011f2cb07">read_memory_unsigned_integer</a> (current_pc, <a class="code" href="nios2-tdep_8h.html#aec6b07e53f3a751e302ab6779d7c1d1a">NIOS2_OPCODE_SIZE</a>,
<a name="l00310"></a>00310                                                byte_order);
<a name="l00311"></a>00311 
<a name="l00312"></a>00312           <span class="keywordflow">if</span> (insn == 0xf800283a                        <span class="comment">/* RET */</span>
<a name="l00313"></a>00313               || insn == 0xe800083a                     <span class="comment">/* ERET */</span>
<a name="l00314"></a>00314               || (insn &amp; 0x07ffffff) == 0x0000683a      <span class="comment">/* JMP */</span>
<a name="l00315"></a>00315               || (insn &amp; 0xffc0003f) == 6)              <span class="comment">/* BR */</span>
<a name="l00316"></a>00316             <span class="keywordflow">return</span> 1;
<a name="l00317"></a>00317         }
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319   <span class="keywordflow">return</span> 0;
<a name="l00320"></a>00320 }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322 <span class="comment">/* Implement the in_function_epilogue_p gdbarch method.  */</span>
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00325"></a>00325 nios2_in_function_epilogue_p (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc)
<a name="l00326"></a>00326 {
<a name="l00327"></a>00327   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> func_addr;
<a name="l00328"></a>00328 
<a name="l00329"></a>00329   <span class="keywordflow">if</span> (<a class="code" href="blockframe_8c.html#a2dae2257ad1417604d2c26f8b9071ca9">find_pc_partial_function</a> (pc, NULL, &amp;func_addr, NULL))
<a name="l00330"></a>00330     <span class="keywordflow">return</span> nios2_in_epilogue_p (gdbarch, pc, func_addr);
<a name="l00331"></a>00331 
<a name="l00332"></a>00332   <span class="keywordflow">return</span> 0;
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="comment">/* Define some instruction patterns supporting wildcard bits via a</span>
<a name="l00336"></a>00336 <span class="comment">   mask.  */</span>
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00339"></a>00339 {
<a name="l00340"></a>00340   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> insn;
<a name="l00341"></a>00341   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mask;
<a name="l00342"></a>00342 } wild_insn;
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="keyword">static</span> <span class="keyword">const</span> wild_insn profiler_insn[] =
<a name="l00345"></a>00345 {
<a name="l00346"></a>00346   { 0x0010e03a, 0x00000000 }, <span class="comment">/* nextpc r8 */</span>
<a name="l00347"></a>00347   { 0xf813883a, 0x00000000 }, <span class="comment">/* mov    r9,ra */</span>
<a name="l00348"></a>00348   { 0x02800034, 0x003fffc0 }, <span class="comment">/* movhi  r10,257 */</span>
<a name="l00349"></a>00349   { 0x52800004, 0x003fffc0 }, <span class="comment">/* addi   r10,r10,-31992 */</span>
<a name="l00350"></a>00350   { 0x00000000, 0xffffffc0 }, <span class="comment">/* call   &lt;mcount&gt; */</span>
<a name="l00351"></a>00351   { 0x483f883a, 0x00000000 }  <span class="comment">/* mov    ra,r9 */</span>
<a name="l00352"></a>00352 };
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 <span class="keyword">static</span> <span class="keyword">const</span> wild_insn irqentry_insn[] =
<a name="l00355"></a>00355 {
<a name="l00356"></a>00356   { 0x0031307a, 0x00000000 }, <span class="comment">/* rdctl  et,estatus */</span>
<a name="l00357"></a>00357   { 0xc600004c, 0x00000000 }, <span class="comment">/* andi   et,et,1 */</span>
<a name="l00358"></a>00358   { 0xc0000026, 0x003fffc0 }, <span class="comment">/* beq    et,zero, &lt;software_exception&gt; */</span>
<a name="l00359"></a>00359   { 0x0031313a, 0x00000000 }, <span class="comment">/* rdctl  et,ipending */</span>
<a name="l00360"></a>00360   { 0xc0000026, 0x003fffc0 }  <span class="comment">/* beq    et,zero, &lt;software_exception&gt; */</span>
<a name="l00361"></a>00361 };
<a name="l00362"></a>00362 
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 <span class="comment">/* Attempt to match SEQUENCE, which is COUNT insns long, at START_PC.  */</span>
<a name="l00365"></a>00365 
<a name="l00366"></a>00366 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00367"></a>00367 nios2_match_sequence (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_pc,
<a name="l00368"></a>00368                       <span class="keyword">const</span> wild_insn *sequence, <span class="keywordtype">int</span> count)
<a name="l00369"></a>00369 {
<a name="l00370"></a>00370   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc = start_pc;
<a name="l00371"></a>00371   <span class="keywordtype">int</span> i;
<a name="l00372"></a>00372   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> insn;
<a name="l00373"></a>00373   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l00374"></a>00374 
<a name="l00375"></a>00375   <span class="keywordflow">for</span> (i = 0 ; i &lt; count ; i++)
<a name="l00376"></a>00376     {
<a name="l00377"></a>00377       insn = <a class="code" href="corefile_8c.html#a280cf81e766f60b30618ae3011f2cb07">read_memory_unsigned_integer</a> (pc, <a class="code" href="nios2-tdep_8h.html#aec6b07e53f3a751e302ab6779d7c1d1a">NIOS2_OPCODE_SIZE</a>, byte_order);
<a name="l00378"></a>00378       <span class="keywordflow">if</span> ((insn &amp; ~sequence[i].mask) != sequence[i].insn)
<a name="l00379"></a>00379         <span class="keywordflow">return</span> 0;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381       pc += <a class="code" href="nios2-tdep_8h.html#aec6b07e53f3a751e302ab6779d7c1d1a">NIOS2_OPCODE_SIZE</a>;
<a name="l00382"></a>00382     }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384   <span class="keywordflow">return</span> 1;
<a name="l00385"></a>00385 }
<a name="l00386"></a>00386 
<a name="l00387"></a>00387 <span class="comment">/* Do prologue analysis, returning the PC of the first instruction</span>
<a name="l00388"></a>00388 <span class="comment">   after the function prologue.  Assumes CACHE has already been</span>
<a name="l00389"></a>00389 <span class="comment">   initialized.  THIS_FRAME can be null, in which case we are only</span>
<a name="l00390"></a>00390 <span class="comment">   interested in skipping the prologue.  Otherwise CACHE is filled in</span>
<a name="l00391"></a>00391 <span class="comment">   from the frame information.</span>
<a name="l00392"></a>00392 <span class="comment"></span>
<a name="l00393"></a>00393 <span class="comment">   The prologue will consist of the following parts:</span>
<a name="l00394"></a>00394 <span class="comment">     1) Optional profiling instrumentation.  The old version uses six</span>
<a name="l00395"></a>00395 <span class="comment">        instructions.  We step over this if there is an exact match.</span>
<a name="l00396"></a>00396 <span class="comment">          nextpc r8</span>
<a name="l00397"></a>00397 <span class="comment">          mov    r9, ra</span>
<a name="l00398"></a>00398 <span class="comment">          movhi  r10, %hiadj(.LP2)</span>
<a name="l00399"></a>00399 <span class="comment">          addi   r10, r10, %lo(.LP2)</span>
<a name="l00400"></a>00400 <span class="comment">          call   mcount</span>
<a name="l00401"></a>00401 <span class="comment">          mov    ra, r9</span>
<a name="l00402"></a>00402 <span class="comment">        The new version uses two or three instructions (the last of</span>
<a name="l00403"></a>00403 <span class="comment">        these might get merged in with the STW which saves RA to the</span>
<a name="l00404"></a>00404 <span class="comment">        stack).  We interpret these.</span>
<a name="l00405"></a>00405 <span class="comment">          mov    r8, ra</span>
<a name="l00406"></a>00406 <span class="comment">          call   mcount</span>
<a name="l00407"></a>00407 <span class="comment">          mov    ra, r8</span>
<a name="l00408"></a>00408 <span class="comment"></span>
<a name="l00409"></a>00409 <span class="comment">     2) Optional interrupt entry decision.  Again, we step over</span>
<a name="l00410"></a>00410 <span class="comment">        this if there is an exact match.</span>
<a name="l00411"></a>00411 <span class="comment">          rdctl  et,estatus</span>
<a name="l00412"></a>00412 <span class="comment">          andi   et,et,1</span>
<a name="l00413"></a>00413 <span class="comment">          beq    et,zero, &lt;software_exception&gt;</span>
<a name="l00414"></a>00414 <span class="comment">          rdctl  et,ipending</span>
<a name="l00415"></a>00415 <span class="comment">          beq    et,zero, &lt;software_exception&gt;</span>
<a name="l00416"></a>00416 <span class="comment"></span>
<a name="l00417"></a>00417 <span class="comment">     3) A stack adjustment or stack which, which will be one of:</span>
<a name="l00418"></a>00418 <span class="comment">          addi   sp, sp, -constant</span>
<a name="l00419"></a>00419 <span class="comment">        or:</span>
<a name="l00420"></a>00420 <span class="comment">          movi   r8, constant</span>
<a name="l00421"></a>00421 <span class="comment">          sub    sp, sp, r8</span>
<a name="l00422"></a>00422 <span class="comment">        or</span>
<a name="l00423"></a>00423 <span class="comment">          movhi  r8, constant</span>
<a name="l00424"></a>00424 <span class="comment">          addi   r8, r8, constant</span>
<a name="l00425"></a>00425 <span class="comment">          sub    sp, sp, r8</span>
<a name="l00426"></a>00426 <span class="comment">        or</span>
<a name="l00427"></a>00427 <span class="comment">          movhi  rx, %hiadj(newstack)</span>
<a name="l00428"></a>00428 <span class="comment">          addhi  rx, rx, %lo(newstack)</span>
<a name="l00429"></a>00429 <span class="comment">          stw    sp, constant(rx)</span>
<a name="l00430"></a>00430 <span class="comment">          mov    sp, rx</span>
<a name="l00431"></a>00431 <span class="comment"></span>
<a name="l00432"></a>00432 <span class="comment">     4) An optional stack check, which can take either of these forms:</span>
<a name="l00433"></a>00433 <span class="comment">          bgeu   sp, rx, +8</span>
<a name="l00434"></a>00434 <span class="comment">          break  3</span>
<a name="l00435"></a>00435 <span class="comment">        or</span>
<a name="l00436"></a>00436 <span class="comment">          bltu   sp, rx, .Lstack_overflow</span>
<a name="l00437"></a>00437 <span class="comment">          ...</span>
<a name="l00438"></a>00438 <span class="comment">        .Lstack_overflow:</span>
<a name="l00439"></a>00439 <span class="comment">          break  3</span>
<a name="l00440"></a>00440 <span class="comment"></span>
<a name="l00441"></a>00441 <span class="comment">     5) Saving any registers which need to be saved.  These will</span>
<a name="l00442"></a>00442 <span class="comment">        normally just be stored onto the stack:</span>
<a name="l00443"></a>00443 <span class="comment">          stw    rx, constant(sp)</span>
<a name="l00444"></a>00444 <span class="comment">        but in the large frame case will use r8 as an offset back</span>
<a name="l00445"></a>00445 <span class="comment">        to the cfa:</span>
<a name="l00446"></a>00446 <span class="comment">          add    r8, r8, sp</span>
<a name="l00447"></a>00447 <span class="comment">          stw    rx, -constant(r8)</span>
<a name="l00448"></a>00448 <span class="comment"></span>
<a name="l00449"></a>00449 <span class="comment">        Saving control registers looks slightly different:</span>
<a name="l00450"></a>00450 <span class="comment">          rdctl  rx, ctlN</span>
<a name="l00451"></a>00451 <span class="comment">          stw    rx, constant(sp)</span>
<a name="l00452"></a>00452 <span class="comment"></span>
<a name="l00453"></a>00453 <span class="comment">     6) An optional FP setup, either if the user has requested a</span>
<a name="l00454"></a>00454 <span class="comment">        frame pointer or if the function calls alloca.</span>
<a name="l00455"></a>00455 <span class="comment">        This is always:</span>
<a name="l00456"></a>00456 <span class="comment">          mov    fp, sp</span>
<a name="l00457"></a>00457 <span class="comment"></span>
<a name="l00458"></a>00458 <span class="comment">    The prologue instructions may be interleaved, and the register</span>
<a name="l00459"></a>00459 <span class="comment">    saves and FP setup can occur in either order.</span>
<a name="l00460"></a>00460 <span class="comment"></span>
<a name="l00461"></a>00461 <span class="comment">    To cope with all this variability we decode all the instructions</span>
<a name="l00462"></a>00462 <span class="comment">    from the start of the prologue until we hit a branch, call or</span>
<a name="l00463"></a>00463 <span class="comment">    return.  For each of the instructions mentioned in 3, 4 and 5 we</span>
<a name="l00464"></a>00464 <span class="comment">    handle the limited cases of stores to the stack and operations</span>
<a name="l00465"></a>00465 <span class="comment">    on constant values.  */</span>
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l00468"></a>00468 nios2_analyze_prologue (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">const</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_pc,
<a name="l00469"></a>00469                         <span class="keyword">const</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> current_pc,
<a name="l00470"></a>00470                         <span class="keyword">struct</span> nios2_unwind_cache *cache,
<a name="l00471"></a>00471                         <span class="keyword">struct</span> frame_info *this_frame)
<a name="l00472"></a>00472 {
<a name="l00473"></a>00473   <span class="comment">/* Maximum lines of prologue to check.</span>
<a name="l00474"></a>00474 <span class="comment">     Note that this number should not be too large, else we can</span>
<a name="l00475"></a>00475 <span class="comment">     potentially end up iterating through unmapped memory.  */</span>
<a name="l00476"></a>00476   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> limit_pc = start_pc + 200;
<a name="l00477"></a>00477   <span class="keywordtype">int</span> regno;
<a name="l00478"></a>00478   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l00479"></a>00479 
<a name="l00480"></a>00480   <span class="comment">/* Does the frame set up the FP register?  */</span>
<a name="l00481"></a>00481   <span class="keywordtype">int</span> base_reg = 0;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483   <span class="keyword">struct </span>reg_value *value = cache-&gt;reg_value;
<a name="l00484"></a>00484   <span class="keyword">struct </span>reg_value temp_value[NIOS2_NUM_REGS];
<a name="l00485"></a>00485 
<a name="l00486"></a>00486   <span class="keywordtype">int</span> i;
<a name="l00487"></a>00487 
<a name="l00488"></a>00488   <span class="comment">/* Save the starting PC so we can correct the pc after running</span>
<a name="l00489"></a>00489 <span class="comment">     through the prolog, using symbol info.  */</span>
<a name="l00490"></a>00490   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc = start_pc;
<a name="l00491"></a>00491 
<a name="l00492"></a>00492   <span class="comment">/* Is this an exception handler?  */</span>
<a name="l00493"></a>00493   <span class="keywordtype">int</span> exception_handler = 0;
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   <span class="comment">/* What was the original value of SP (or fake original value for</span>
<a name="l00496"></a>00496 <span class="comment">     functions which switch stacks?  */</span>
<a name="l00497"></a>00497   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> frame_high;
<a name="l00498"></a>00498 
<a name="l00499"></a>00499   <span class="comment">/* Is this the end of the prologue?  */</span>
<a name="l00500"></a>00500   <span class="keywordtype">int</span> within_prologue = 1;
<a name="l00501"></a>00501 
<a name="l00502"></a>00502   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> prologue_end;
<a name="l00503"></a>00503 
<a name="l00504"></a>00504   <span class="comment">/* Is this the innermost function?  */</span>
<a name="l00505"></a>00505   <span class="keywordtype">int</span> innermost = (this_frame ? (<a class="code" href="frame_8c.html#aa543a3af3a0507905c26e22142dabe59">frame_relative_level</a> (this_frame) == 0) : 1);
<a name="l00506"></a>00506 
<a name="l00507"></a>00507   <span class="keywordflow">if</span> (nios2_debug)
<a name="l00508"></a>00508     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l00509"></a>00509                         <span class="stringliteral">&quot;{ nios2_analyze_prologue start=%s, current=%s &quot;</span>,
<a name="l00510"></a>00510                         <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, start_pc),
<a name="l00511"></a>00511                         <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, current_pc));
<a name="l00512"></a>00512 
<a name="l00513"></a>00513   <span class="comment">/* Set up the default values of the registers.  */</span>
<a name="l00514"></a>00514   nios2_setup_default (cache);
<a name="l00515"></a>00515 
<a name="l00516"></a>00516   <span class="comment">/* If the first few instructions are the profile entry, then skip</span>
<a name="l00517"></a>00517 <span class="comment">     over them.  Newer versions of the compiler use more efficient</span>
<a name="l00518"></a>00518 <span class="comment">     profiling code.  */</span>
<a name="l00519"></a>00519   <span class="keywordflow">if</span> (nios2_match_sequence (gdbarch, pc, profiler_insn,
<a name="l00520"></a>00520                             ARRAY_SIZE (profiler_insn)))
<a name="l00521"></a>00521     pc += ARRAY_SIZE (profiler_insn) * <a class="code" href="nios2-tdep_8h.html#aec6b07e53f3a751e302ab6779d7c1d1a">NIOS2_OPCODE_SIZE</a>;
<a name="l00522"></a>00522 
<a name="l00523"></a>00523   <span class="comment">/* If the first few instructions are an interrupt entry, then skip</span>
<a name="l00524"></a>00524 <span class="comment">     over them too.  */</span>
<a name="l00525"></a>00525   <span class="keywordflow">if</span> (nios2_match_sequence (gdbarch, pc, irqentry_insn,
<a name="l00526"></a>00526                             ARRAY_SIZE (irqentry_insn)))
<a name="l00527"></a>00527     {
<a name="l00528"></a>00528       pc += ARRAY_SIZE (irqentry_insn) * <a class="code" href="nios2-tdep_8h.html#aec6b07e53f3a751e302ab6779d7c1d1a">NIOS2_OPCODE_SIZE</a>;
<a name="l00529"></a>00529       exception_handler = 1;
<a name="l00530"></a>00530     }
<a name="l00531"></a>00531 
<a name="l00532"></a>00532   prologue_end = start_pc;
<a name="l00533"></a>00533 
<a name="l00534"></a>00534   <span class="comment">/* Find the prologue instructions.  */</span>
<a name="l00535"></a>00535   <span class="keywordflow">while</span> (pc &lt; limit_pc &amp;&amp; within_prologue)
<a name="l00536"></a>00536     {
<a name="l00537"></a>00537       <span class="comment">/* Present instruction.  */</span>
<a name="l00538"></a>00538       uint32_t insn;
<a name="l00539"></a>00539 
<a name="l00540"></a>00540       <span class="keywordtype">int</span> prologue_insn = 0;
<a name="l00541"></a>00541 
<a name="l00542"></a>00542       <span class="keywordflow">if</span> (pc == current_pc)
<a name="l00543"></a>00543       {
<a name="l00544"></a>00544         <span class="comment">/* When we reach the current PC we must save the current</span>
<a name="l00545"></a>00545 <span class="comment">           register state (for the backtrace) but keep analysing</span>
<a name="l00546"></a>00546 <span class="comment">           because there might be more to find out (eg. is this an</span>
<a name="l00547"></a>00547 <span class="comment">           exception handler).  */</span>
<a name="l00548"></a>00548         <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (temp_value, value, <span class="keyword">sizeof</span> (temp_value));
<a name="l00549"></a>00549         value = temp_value;
<a name="l00550"></a>00550         <span class="keywordflow">if</span> (nios2_debug)
<a name="l00551"></a>00551           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;*&quot;</span>);
<a name="l00552"></a>00552       }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554       insn = <a class="code" href="corefile_8c.html#a280cf81e766f60b30618ae3011f2cb07">read_memory_unsigned_integer</a> (pc, <a class="code" href="nios2-tdep_8h.html#aec6b07e53f3a751e302ab6779d7c1d1a">NIOS2_OPCODE_SIZE</a>, byte_order);
<a name="l00555"></a>00555       pc += <a class="code" href="nios2-tdep_8h.html#aec6b07e53f3a751e302ab6779d7c1d1a">NIOS2_OPCODE_SIZE</a>;
<a name="l00556"></a>00556 
<a name="l00557"></a>00557       <span class="keywordflow">if</span> (nios2_debug)
<a name="l00558"></a>00558         <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;[%08X]&quot;</span>, insn);
<a name="l00559"></a>00559 
<a name="l00560"></a>00560       <span class="comment">/* The following instructions can appear in the prologue.  */</span>
<a name="l00561"></a>00561 
<a name="l00562"></a>00562       <span class="keywordflow">if</span> ((insn &amp; 0x0001ffff) == 0x0001883a)
<a name="l00563"></a>00563         {
<a name="l00564"></a>00564           <span class="comment">/* ADD   rc, ra, rb  (also used for MOV) */</span>
<a name="l00565"></a>00565 
<a name="l00566"></a>00566           <span class="keywordtype">int</span> ra = GET_IW_A (insn);
<a name="l00567"></a>00567           <span class="keywordtype">int</span> rb = GET_IW_B (insn);
<a name="l00568"></a>00568           <span class="keywordtype">int</span> rc = GET_IW_C (insn);
<a name="l00569"></a>00569 
<a name="l00570"></a>00570           <span class="keywordflow">if</span> (rc == <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>
<a name="l00571"></a>00571               &amp;&amp; rb == 0
<a name="l00572"></a>00572               &amp;&amp; value[ra].<a class="code" href="structreg.html">reg</a> == cache-&gt;reg_saved[<a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>].basereg)
<a name="l00573"></a>00573             {
<a name="l00574"></a>00574               <span class="comment">/* If the previous value of SP is available somewhere</span>
<a name="l00575"></a>00575 <span class="comment">                 near the new stack pointer value then this is a</span>
<a name="l00576"></a>00576 <span class="comment">                 stack switch.  */</span>
<a name="l00577"></a>00577 
<a name="l00578"></a>00578               <span class="comment">/* If any registers were saved on the stack before then</span>
<a name="l00579"></a>00579 <span class="comment">                 we can&#39;t backtrace into them now.  */</span>
<a name="l00580"></a>00580               <span class="keywordflow">for</span> (i = 0 ; i &lt; <a class="code" href="nios2-tdep_8h.html#ae913e9c123638347d36317e8b4ac30b6">NIOS2_NUM_REGS</a> ; i++)
<a name="l00581"></a>00581                 {
<a name="l00582"></a>00582                   <span class="keywordflow">if</span> (cache-&gt;reg_saved[i].basereg == <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>)
<a name="l00583"></a>00583                     cache-&gt;reg_saved[i].basereg = -1;
<a name="l00584"></a>00584                   <span class="keywordflow">if</span> (value[i].<a class="code" href="structreg.html">reg</a> == <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>)
<a name="l00585"></a>00585                     value[i].reg = -1;
<a name="l00586"></a>00586                 }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588               <span class="comment">/* Create a fake &quot;high water mark&quot; 4 bytes above where SP</span>
<a name="l00589"></a>00589 <span class="comment">                 was stored and fake up the registers to be consistent</span>
<a name="l00590"></a>00590 <span class="comment">                 with that.  */</span>
<a name="l00591"></a>00591               value[<a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>].reg = <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>;
<a name="l00592"></a>00592               value[<a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>].offset
<a name="l00593"></a>00593                 = (value[ra].offset
<a name="l00594"></a>00594                    - cache-&gt;reg_saved[<a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>].addr
<a name="l00595"></a>00595                    - 4);
<a name="l00596"></a>00596               cache-&gt;reg_saved[<a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>].basereg = <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>;
<a name="l00597"></a>00597               cache-&gt;reg_saved[<a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>].addr = -4;
<a name="l00598"></a>00598             }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != 0)
<a name="l00601"></a>00601             {
<a name="l00602"></a>00602               <span class="keywordflow">if</span> (value[rb].<a class="code" href="structreg.html">reg</a> == 0)
<a name="l00603"></a>00603                 value[rc].reg = value[ra].reg;
<a name="l00604"></a>00604               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value[ra].<a class="code" href="structreg.html">reg</a> == 0)
<a name="l00605"></a>00605                 value[rc].reg = value[rb].reg;
<a name="l00606"></a>00606               <span class="keywordflow">else</span>
<a name="l00607"></a>00607                 value[rc].reg = -1;
<a name="l00608"></a>00608               value[rc].offset = value[ra].offset + value[rb].offset;
<a name="l00609"></a>00609             }
<a name="l00610"></a>00610           prologue_insn = 1;
<a name="l00611"></a>00611         }
<a name="l00612"></a>00612 
<a name="l00613"></a>00613       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((insn &amp; 0x0001ffff) == 0x0001983a)
<a name="l00614"></a>00614         {
<a name="l00615"></a>00615           <span class="comment">/* SUB   rc, ra, rb */</span>
<a name="l00616"></a>00616 
<a name="l00617"></a>00617           <span class="keywordtype">int</span> ra = GET_IW_A (insn);
<a name="l00618"></a>00618           <span class="keywordtype">int</span> rb = GET_IW_B (insn);
<a name="l00619"></a>00619           <span class="keywordtype">int</span> rc = GET_IW_C (insn);
<a name="l00620"></a>00620 
<a name="l00621"></a>00621           <span class="keywordflow">if</span> (rc != 0)
<a name="l00622"></a>00622             {
<a name="l00623"></a>00623               <span class="keywordflow">if</span> (value[rb].<a class="code" href="structreg.html">reg</a> == 0)
<a name="l00624"></a>00624                 value[rc].reg = value[ra].reg;
<a name="l00625"></a>00625               <span class="keywordflow">else</span>
<a name="l00626"></a>00626                 value[rc].reg = -1;
<a name="l00627"></a>00627               value[rc].offset = value[ra].offset - value[rb].offset;
<a name="l00628"></a>00628             }
<a name="l00629"></a>00629         }
<a name="l00630"></a>00630 
<a name="l00631"></a>00631       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((insn &amp; 0x0000003f) == 0x00000004)
<a name="l00632"></a>00632         {
<a name="l00633"></a>00633           <span class="comment">/* ADDI  rb, ra, immed   (also used for MOVI) */</span>
<a name="l00634"></a>00634           <span class="keywordtype">short</span> immed = GET_IW_IMM16 (insn);
<a name="l00635"></a>00635           <span class="keywordtype">int</span> ra = GET_IW_A (insn);
<a name="l00636"></a>00636           <span class="keywordtype">int</span> rb = GET_IW_B (insn);
<a name="l00637"></a>00637 
<a name="l00638"></a>00638           <span class="comment">/* The first stack adjustment is part of the prologue.</span>
<a name="l00639"></a>00639 <span class="comment">             Any subsequent stack adjustments are either down to</span>
<a name="l00640"></a>00640 <span class="comment">             alloca or the epilogue so stop analysing when we hit</span>
<a name="l00641"></a>00641 <span class="comment">             them.  */</span>
<a name="l00642"></a>00642           <span class="keywordflow">if</span> (rb == <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>
<a name="l00643"></a>00643               &amp;&amp; (value[rb].<a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a> != 0 || value[ra].<a class="code" href="structreg.html">reg</a> != <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>))
<a name="l00644"></a>00644             <span class="keywordflow">break</span>;
<a name="l00645"></a>00645 
<a name="l00646"></a>00646           <span class="keywordflow">if</span> (rb != 0)
<a name="l00647"></a>00647             {
<a name="l00648"></a>00648               value[rb].reg    = value[ra].reg;
<a name="l00649"></a>00649               value[rb].offset = value[ra].offset + immed;
<a name="l00650"></a>00650             }
<a name="l00651"></a>00651 
<a name="l00652"></a>00652           prologue_insn = 1;
<a name="l00653"></a>00653         }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((insn &amp; 0x0000003f) == 0x00000034)
<a name="l00656"></a>00656         {
<a name="l00657"></a>00657           <span class="comment">/* ORHI  rb, ra, immed   (also used for MOVHI) */</span>
<a name="l00658"></a>00658           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> immed = GET_IW_IMM16 (insn);
<a name="l00659"></a>00659           <span class="keywordtype">int</span> ra = GET_IW_A (insn);
<a name="l00660"></a>00660           <span class="keywordtype">int</span> rb = GET_IW_B (insn);
<a name="l00661"></a>00661 
<a name="l00662"></a>00662           <span class="keywordflow">if</span> (rb != 0)
<a name="l00663"></a>00663             {
<a name="l00664"></a>00664               value[rb].reg    = (value[ra].reg == 0) ? 0 : -1;
<a name="l00665"></a>00665               value[rb].offset = value[ra].offset | (immed &lt;&lt; 16);
<a name="l00666"></a>00666             }
<a name="l00667"></a>00667         }
<a name="l00668"></a>00668 
<a name="l00669"></a>00669       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((insn &amp; IW_OP_MASK) == OP_STW
<a name="l00670"></a>00670                || (insn &amp; IW_OP_MASK) == OP_STWIO)
<a name="l00671"></a>00671         {
<a name="l00672"></a>00672           <span class="comment">/* STW rb, immediate(ra) */</span>
<a name="l00673"></a>00673 
<a name="l00674"></a>00674           <span class="keywordtype">short</span> immed16 = GET_IW_IMM16 (insn);
<a name="l00675"></a>00675           <span class="keywordtype">int</span> ra = GET_IW_A (insn);
<a name="l00676"></a>00676           <span class="keywordtype">int</span> rb = GET_IW_B (insn);
<a name="l00677"></a>00677 
<a name="l00678"></a>00678           <span class="comment">/* Are we storing the original value of a register?</span>
<a name="l00679"></a>00679 <span class="comment">             For exception handlers the value of EA-4 (return</span>
<a name="l00680"></a>00680 <span class="comment">             address from interrupts etc) is sometimes stored.  */</span>
<a name="l00681"></a>00681           <span class="keywordtype">int</span> orig = value[rb].reg;
<a name="l00682"></a>00682           <span class="keywordflow">if</span> (orig &gt; 0
<a name="l00683"></a>00683               &amp;&amp; (value[rb].<a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a> == 0
<a name="l00684"></a>00684                   || (orig == <a class="code" href="nios2-tdep_8h.html#aba9a2cf08fb40cca31f975ebde0e837e">NIOS2_EA_REGNUM</a> &amp;&amp; value[rb].<a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a> == -4)))
<a name="l00685"></a>00685             {
<a name="l00686"></a>00686               <span class="comment">/* We are most interested in stores to the stack, but</span>
<a name="l00687"></a>00687 <span class="comment">                 also take note of stores to other places as they</span>
<a name="l00688"></a>00688 <span class="comment">                 might be useful later.  */</span>
<a name="l00689"></a>00689               <span class="keywordflow">if</span> ((value[ra].<a class="code" href="structreg.html">reg</a> == <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>
<a name="l00690"></a>00690                    &amp;&amp; cache-&gt;reg_saved[orig].basereg != <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>)
<a name="l00691"></a>00691                   || cache-&gt;reg_saved[orig].basereg == -1)
<a name="l00692"></a>00692                 {
<a name="l00693"></a>00693                   <span class="keywordflow">if</span> (pc &lt; current_pc)
<a name="l00694"></a>00694                     {
<a name="l00695"></a>00695                       <span class="comment">/* Save off callee saved registers.  */</span>
<a name="l00696"></a>00696                       cache-&gt;reg_saved[orig].basereg = value[ra].reg;
<a name="l00697"></a>00697                       cache-&gt;reg_saved[orig].addr
<a name="l00698"></a>00698                         = value[ra].offset + GET_IW_IMM16 (insn);
<a name="l00699"></a>00699                     }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701                   prologue_insn = 1;
<a name="l00702"></a>00702 
<a name="l00703"></a>00703                   <span class="keywordflow">if</span> (orig == <a class="code" href="nios2-tdep_8h.html#aba9a2cf08fb40cca31f975ebde0e837e">NIOS2_EA_REGNUM</a> || orig == <a class="code" href="nios2-tdep_8h.html#a6e2413c1e1d729bf3199a1e82df43401">NIOS2_ESTATUS_REGNUM</a>)
<a name="l00704"></a>00704                     exception_handler = 1;
<a name="l00705"></a>00705                 }
<a name="l00706"></a>00706             }
<a name="l00707"></a>00707           <span class="keywordflow">else</span>
<a name="l00708"></a>00708             <span class="comment">/* Non-stack memory writes are not part of the</span>
<a name="l00709"></a>00709 <span class="comment">               prologue.  */</span>
<a name="l00710"></a>00710             within_prologue = 0;
<a name="l00711"></a>00711         }
<a name="l00712"></a>00712 
<a name="l00713"></a>00713       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((insn &amp; 0xffc1f83f) == 0x0001303a)
<a name="l00714"></a>00714         {
<a name="l00715"></a>00715           <span class="comment">/* RDCTL rC, ctlN */</span>
<a name="l00716"></a>00716           <span class="keywordtype">int</span> rc = GET_IW_C (insn);
<a name="l00717"></a>00717           <span class="keywordtype">int</span> n = GET_IW_CONTROL_REGNUM (insn);
<a name="l00718"></a>00718 
<a name="l00719"></a>00719           <span class="keywordflow">if</span> (rc != 0)
<a name="l00720"></a>00720             {
<a name="l00721"></a>00721               value[rc].reg    = <a class="code" href="nios2-tdep_8h.html#a59ba01e551a4b1c25486b12e82957841">NIOS2_STATUS_REGNUM</a> + n;
<a name="l00722"></a>00722               value[rc].offset = 0;
<a name="l00723"></a>00723             }
<a name="l00724"></a>00724 
<a name="l00725"></a>00725           prologue_insn = 1;
<a name="l00726"></a>00726         }
<a name="l00727"></a>00727 
<a name="l00728"></a>00728       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((insn &amp; 0x0000003f) == 0
<a name="l00729"></a>00729                &amp;&amp; value[8].<a class="code" href="structreg.html">reg</a> == <a class="code" href="nios2-tdep_8h.html#a8e532c6ea2657f3072e6ef7f31e65aa4">NIOS2_RA_REGNUM</a>
<a name="l00730"></a>00730                &amp;&amp; value[8].<a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a> == 0
<a name="l00731"></a>00731                &amp;&amp; value[<a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>].<a class="code" href="structreg.html">reg</a> == <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>
<a name="l00732"></a>00732                &amp;&amp; value[<a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>].<a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a> == 0)
<a name="l00733"></a>00733         {
<a name="l00734"></a>00734           <span class="comment">/* A CALL instruction.  This is treated as a call to mcount</span>
<a name="l00735"></a>00735 <span class="comment">             if ra has been stored into r8 beforehand and if it&#39;s</span>
<a name="l00736"></a>00736 <span class="comment">             before the stack adjust.</span>
<a name="l00737"></a>00737 <span class="comment">             Note mcount corrupts r2-r3, r9-r15 &amp; ra.  */</span>
<a name="l00738"></a>00738           <span class="keywordflow">for</span> (i = 2 ; i &lt;= 3 ; i++)
<a name="l00739"></a>00739             value[i].<a class="code" href="structreg.html">reg</a> = -1;
<a name="l00740"></a>00740           <span class="keywordflow">for</span> (i = 9 ; i &lt;= 15 ; i++)
<a name="l00741"></a>00741             value[i].<a class="code" href="structreg.html">reg</a> = -1;
<a name="l00742"></a>00742           value[<a class="code" href="nios2-tdep_8h.html#a8e532c6ea2657f3072e6ef7f31e65aa4">NIOS2_RA_REGNUM</a>].reg = -1;
<a name="l00743"></a>00743 
<a name="l00744"></a>00744           prologue_insn = 1;
<a name="l00745"></a>00745         }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((insn &amp; 0xf83fffff) == 0xd800012e)
<a name="l00748"></a>00748         {
<a name="l00749"></a>00749            <span class="comment">/* BGEU sp, rx, +8</span>
<a name="l00750"></a>00750 <span class="comment">              BREAK 3</span>
<a name="l00751"></a>00751 <span class="comment">              This instruction sequence is used in stack checking;</span>
<a name="l00752"></a>00752 <span class="comment">              we can ignore it.  */</span>
<a name="l00753"></a>00753           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> next_insn
<a name="l00754"></a>00754             = <a class="code" href="corefile_8c.html#a280cf81e766f60b30618ae3011f2cb07">read_memory_unsigned_integer</a> (pc, <a class="code" href="nios2-tdep_8h.html#aec6b07e53f3a751e302ab6779d7c1d1a">NIOS2_OPCODE_SIZE</a>, byte_order);
<a name="l00755"></a>00755 
<a name="l00756"></a>00756           <span class="keywordflow">if</span> (next_insn != 0x003da0fa)
<a name="l00757"></a>00757             within_prologue = 0;
<a name="l00758"></a>00758           <span class="keywordflow">else</span>
<a name="l00759"></a>00759             pc += <a class="code" href="nios2-tdep_8h.html#aec6b07e53f3a751e302ab6779d7c1d1a">NIOS2_OPCODE_SIZE</a>;
<a name="l00760"></a>00760         }
<a name="l00761"></a>00761 
<a name="l00762"></a>00762       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((insn &amp; 0xf800003f) == 0xd8000036)
<a name="l00763"></a>00763         {
<a name="l00764"></a>00764            <span class="comment">/* BLTU sp, rx, .Lstackoverflow</span>
<a name="l00765"></a>00765 <span class="comment">              If the location branched to holds a BREAK 3 instruction</span>
<a name="l00766"></a>00766 <span class="comment">              then this is also stack overflow detection.  We can</span>
<a name="l00767"></a>00767 <span class="comment">              ignore it.  */</span>
<a name="l00768"></a>00768           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> target_pc = pc + ((insn &amp; 0x3fffc0) &gt;&gt; 6);
<a name="l00769"></a>00769           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> target_insn
<a name="l00770"></a>00770             = <a class="code" href="corefile_8c.html#a280cf81e766f60b30618ae3011f2cb07">read_memory_unsigned_integer</a> (target_pc, <a class="code" href="nios2-tdep_8h.html#aec6b07e53f3a751e302ab6779d7c1d1a">NIOS2_OPCODE_SIZE</a>,
<a name="l00771"></a>00771                                             byte_order);
<a name="l00772"></a>00772 
<a name="l00773"></a>00773           <span class="keywordflow">if</span> (target_insn != 0x003da0fa)
<a name="l00774"></a>00774             within_prologue = 0;
<a name="l00775"></a>00775         }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777       <span class="comment">/* Any other instructions are allowed to be moved up into the</span>
<a name="l00778"></a>00778 <span class="comment">         prologue.  If we reach a branch, call or return then the</span>
<a name="l00779"></a>00779 <span class="comment">         prologue is considered over.  We also consider a second stack</span>
<a name="l00780"></a>00780 <span class="comment">         adjustment as terminating the prologue (see above).  */</span>
<a name="l00781"></a>00781       <span class="keywordflow">else</span>
<a name="l00782"></a>00782         {
<a name="l00783"></a>00783           <span class="keywordflow">switch</span> (GET_IW_OP (insn))
<a name="l00784"></a>00784             {
<a name="l00785"></a>00785             <span class="keywordflow">case</span> OP_BEQ:
<a name="l00786"></a>00786             <span class="keywordflow">case</span> OP_BGE:
<a name="l00787"></a>00787             <span class="keywordflow">case</span> OP_BGEU:
<a name="l00788"></a>00788             <span class="keywordflow">case</span> OP_BLT:
<a name="l00789"></a>00789             <span class="keywordflow">case</span> OP_BLTU:
<a name="l00790"></a>00790             <span class="keywordflow">case</span> OP_BNE:
<a name="l00791"></a>00791             <span class="keywordflow">case</span> OP_BR:
<a name="l00792"></a>00792             <span class="keywordflow">case</span> OP_CALL:
<a name="l00793"></a>00793               within_prologue = 0;
<a name="l00794"></a>00794               <span class="keywordflow">break</span>;
<a name="l00795"></a>00795             <span class="keywordflow">case</span> OP_OPX:
<a name="l00796"></a>00796               <span class="keywordflow">if</span> (GET_IW_OPX (insn) == OPX_RET
<a name="l00797"></a>00797                   || GET_IW_OPX (insn) == OPX_ERET
<a name="l00798"></a>00798                   || GET_IW_OPX (insn) == OPX_BRET
<a name="l00799"></a>00799                   || GET_IW_OPX (insn) == OPX_CALLR
<a name="l00800"></a>00800                   || GET_IW_OPX (insn) == OPX_JMP)
<a name="l00801"></a>00801                 within_prologue = 0;
<a name="l00802"></a>00802               <span class="keywordflow">break</span>;
<a name="l00803"></a>00803             <span class="keywordflow">default</span>:
<a name="l00804"></a>00804               <span class="keywordflow">break</span>;
<a name="l00805"></a>00805             }
<a name="l00806"></a>00806         }
<a name="l00807"></a>00807 
<a name="l00808"></a>00808       <span class="keywordflow">if</span> (prologue_insn)
<a name="l00809"></a>00809         prologue_end = pc;
<a name="l00810"></a>00810     }
<a name="l00811"></a>00811 
<a name="l00812"></a>00812   <span class="comment">/* If THIS_FRAME is NULL, we are being called from skip_prologue</span>
<a name="l00813"></a>00813 <span class="comment">     and are only interested in the PROLOGUE_END value, so just</span>
<a name="l00814"></a>00814 <span class="comment">     return that now and skip over the cache updates, which depend</span>
<a name="l00815"></a>00815 <span class="comment">     on having frame information.  */</span>
<a name="l00816"></a>00816   <span class="keywordflow">if</span> (this_frame == NULL)
<a name="l00817"></a>00817     <span class="keywordflow">return</span> prologue_end;
<a name="l00818"></a>00818 
<a name="l00819"></a>00819   <span class="comment">/* If we are in the function epilogue and have already popped</span>
<a name="l00820"></a>00820 <span class="comment">     registers off the stack in preparation for returning, then we</span>
<a name="l00821"></a>00821 <span class="comment">     want to go back to the original register values.  */</span>
<a name="l00822"></a>00822   <span class="keywordflow">if</span> (innermost &amp;&amp; nios2_in_epilogue_p (gdbarch, current_pc, start_pc))
<a name="l00823"></a>00823     nios2_setup_default (cache);
<a name="l00824"></a>00824 
<a name="l00825"></a>00825   <span class="comment">/* Exception handlers use a different return address register.  */</span>
<a name="l00826"></a>00826   <span class="keywordflow">if</span> (exception_handler)
<a name="l00827"></a>00827     cache-&gt;return_regnum = <a class="code" href="nios2-tdep_8h.html#aba9a2cf08fb40cca31f975ebde0e837e">NIOS2_EA_REGNUM</a>;
<a name="l00828"></a>00828 
<a name="l00829"></a>00829   <span class="keywordflow">if</span> (nios2_debug)
<a name="l00830"></a>00830     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;\n-&gt; retreg=%d, &quot;</span>, cache-&gt;return_regnum);
<a name="l00831"></a>00831 
<a name="l00832"></a>00832   <span class="keywordflow">if</span> (cache-&gt;reg_value[<a class="code" href="nios2-tdep_8h.html#a4b5ed12c478cd03646c67169468da353">NIOS2_FP_REGNUM</a>].reg == <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>)
<a name="l00833"></a>00833     <span class="comment">/* If the FP now holds an offset from the CFA then this is a</span>
<a name="l00834"></a>00834 <span class="comment">       normal frame which uses the frame pointer.  */</span>
<a name="l00835"></a>00835     base_reg = <a class="code" href="nios2-tdep_8h.html#a4b5ed12c478cd03646c67169468da353">NIOS2_FP_REGNUM</a>;
<a name="l00836"></a>00836   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cache-&gt;reg_value[<a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>].reg == <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>)
<a name="l00837"></a>00837     <span class="comment">/* FP doesn&#39;t hold an offset from the CFA.  If SP still holds an</span>
<a name="l00838"></a>00838 <span class="comment">       offset from the CFA then we might be in a function which omits</span>
<a name="l00839"></a>00839 <span class="comment">       the frame pointer, or we might be partway through the prologue.</span>
<a name="l00840"></a>00840 <span class="comment">       In both cases we can find the CFA using SP.  */</span>
<a name="l00841"></a>00841     base_reg = <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>;
<a name="l00842"></a>00842   <span class="keywordflow">else</span>
<a name="l00843"></a>00843     {
<a name="l00844"></a>00844       <span class="comment">/* Somehow the stack pointer has been corrupted.</span>
<a name="l00845"></a>00845 <span class="comment">         We can&#39;t return.  */</span>
<a name="l00846"></a>00846       <span class="keywordflow">if</span> (nios2_debug)
<a name="l00847"></a>00847         <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;&lt;can&#39;t reach cfa&gt; }\n&quot;</span>);
<a name="l00848"></a>00848       <span class="keywordflow">return</span> 0;
<a name="l00849"></a>00849     }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851   <span class="keywordflow">if</span> (cache-&gt;reg_value[base_reg].offset == 0
<a name="l00852"></a>00852       || cache-&gt;reg_saved[<a class="code" href="nios2-tdep_8h.html#a8e532c6ea2657f3072e6ef7f31e65aa4">NIOS2_RA_REGNUM</a>].basereg != <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>
<a name="l00853"></a>00853       || cache-&gt;reg_saved[cache-&gt;return_regnum].basereg != <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>)
<a name="l00854"></a>00854     {
<a name="l00855"></a>00855       <span class="comment">/* If the frame didn&#39;t adjust the stack, didn&#39;t save RA or</span>
<a name="l00856"></a>00856 <span class="comment">         didn&#39;t save EA in an exception handler then it must either</span>
<a name="l00857"></a>00857 <span class="comment">         be a leaf function (doesn&#39;t call any other functions) or it</span>
<a name="l00858"></a>00858 <span class="comment">         can&#39;t return.  If it has called another function then it</span>
<a name="l00859"></a>00859 <span class="comment">         can&#39;t be a leaf, so set base == 0 to indicate that we can&#39;t</span>
<a name="l00860"></a>00860 <span class="comment">         backtrace past it.  */</span>
<a name="l00861"></a>00861 
<a name="l00862"></a>00862       <span class="keywordflow">if</span> (!innermost)
<a name="l00863"></a>00863         {
<a name="l00864"></a>00864           <span class="comment">/* If it isn&#39;t the innermost function then it can&#39;t be a</span>
<a name="l00865"></a>00865 <span class="comment">             leaf, unless it was interrupted.  Check whether RA for</span>
<a name="l00866"></a>00866 <span class="comment">             this frame is the same as PC.  If so then it probably</span>
<a name="l00867"></a>00867 <span class="comment">             wasn&#39;t interrupted.  */</span>
<a name="l00868"></a>00868           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ra
<a name="l00869"></a>00869             = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, <a class="code" href="nios2-tdep_8h.html#a8e532c6ea2657f3072e6ef7f31e65aa4">NIOS2_RA_REGNUM</a>);
<a name="l00870"></a>00870 
<a name="l00871"></a>00871           <span class="keywordflow">if</span> (ra == current_pc)
<a name="l00872"></a>00872             {
<a name="l00873"></a>00873               <span class="keywordflow">if</span> (nios2_debug)
<a name="l00874"></a>00874                 <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a>
<a name="l00875"></a>00875                   (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l00876"></a>00876                    <span class="stringliteral">&quot;&lt;noreturn ADJUST %s, r31@r%d+?&gt;, r%d@r%d+?&gt; }\n&quot;</span>,
<a name="l00877"></a>00877                    <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, cache-&gt;reg_value[base_reg].offset),
<a name="l00878"></a>00878                    cache-&gt;reg_saved[<a class="code" href="nios2-tdep_8h.html#a8e532c6ea2657f3072e6ef7f31e65aa4">NIOS2_RA_REGNUM</a>].basereg,
<a name="l00879"></a>00879                    cache-&gt;return_regnum,
<a name="l00880"></a>00880                    cache-&gt;reg_saved[cache-&gt;return_regnum].basereg);
<a name="l00881"></a>00881               <span class="keywordflow">return</span> 0;
<a name="l00882"></a>00882             }
<a name="l00883"></a>00883         }
<a name="l00884"></a>00884     }
<a name="l00885"></a>00885 
<a name="l00886"></a>00886   <span class="comment">/* Get the value of whichever register we are using for the</span>
<a name="l00887"></a>00887 <span class="comment">     base.  */</span>
<a name="l00888"></a>00888   cache-&gt;base = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, base_reg);
<a name="l00889"></a>00889 
<a name="l00890"></a>00890   <span class="comment">/* What was the value of SP at the start of this function (or just</span>
<a name="l00891"></a>00891 <span class="comment">     after the stack switch).  */</span>
<a name="l00892"></a>00892   frame_high = cache-&gt;base - cache-&gt;reg_value[base_reg].offset;
<a name="l00893"></a>00893 
<a name="l00894"></a>00894   <span class="comment">/* Adjust all the saved registers such that they contain addresses</span>
<a name="l00895"></a>00895 <span class="comment">     instead of offsets.  */</span>
<a name="l00896"></a>00896   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="nios2-tdep_8h.html#ae913e9c123638347d36317e8b4ac30b6">NIOS2_NUM_REGS</a>; i++)
<a name="l00897"></a>00897     <span class="keywordflow">if</span> (cache-&gt;reg_saved[i].basereg == <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>)
<a name="l00898"></a>00898       {
<a name="l00899"></a>00899         cache-&gt;reg_saved[i].basereg = <a class="code" href="nios2-tdep_8h.html#a584c83ab11802fc1ba5a902b5296a420">NIOS2_Z_REGNUM</a>;
<a name="l00900"></a>00900         cache-&gt;reg_saved[i].addr += frame_high;
<a name="l00901"></a>00901       }
<a name="l00902"></a>00902 
<a name="l00903"></a>00903   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="nios2-tdep_8h.html#ae913e9c123638347d36317e8b4ac30b6">NIOS2_NUM_REGS</a>; i++)
<a name="l00904"></a>00904     <span class="keywordflow">if</span> (cache-&gt;reg_saved[i].basereg == <a class="code" href="nios2-tdep_8h.html#ae5db260a626846c3d5b5109ed76733b3">NIOS2_GP_REGNUM</a>)
<a name="l00905"></a>00905       {
<a name="l00906"></a>00906         <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> gp = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame,
<a name="l00907"></a>00907                                                     <a class="code" href="nios2-tdep_8h.html#ae5db260a626846c3d5b5109ed76733b3">NIOS2_GP_REGNUM</a>);
<a name="l00908"></a>00908 
<a name="l00909"></a>00909         <span class="keywordflow">for</span> ( ; i &lt; <a class="code" href="nios2-tdep_8h.html#ae913e9c123638347d36317e8b4ac30b6">NIOS2_NUM_REGS</a>; i++)
<a name="l00910"></a>00910           <span class="keywordflow">if</span> (cache-&gt;reg_saved[i].basereg == <a class="code" href="nios2-tdep_8h.html#ae5db260a626846c3d5b5109ed76733b3">NIOS2_GP_REGNUM</a>)
<a name="l00911"></a>00911             {
<a name="l00912"></a>00912               cache-&gt;reg_saved[i].basereg = <a class="code" href="nios2-tdep_8h.html#a584c83ab11802fc1ba5a902b5296a420">NIOS2_Z_REGNUM</a>;
<a name="l00913"></a>00913               cache-&gt;reg_saved[i].addr += gp;
<a name="l00914"></a>00914             }
<a name="l00915"></a>00915       }
<a name="l00916"></a>00916 
<a name="l00917"></a>00917   <span class="comment">/* Work out what the value of SP was on the first instruction of</span>
<a name="l00918"></a>00918 <span class="comment">     this function.  If we didn&#39;t switch stacks then this can be</span>
<a name="l00919"></a>00919 <span class="comment">     trivially computed from the base address.  */</span>
<a name="l00920"></a>00920   <span class="keywordflow">if</span> (cache-&gt;reg_saved[<a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>].basereg == <a class="code" href="nios2-tdep_8h.html#a584c83ab11802fc1ba5a902b5296a420">NIOS2_Z_REGNUM</a>)
<a name="l00921"></a>00921     cache-&gt;cfa
<a name="l00922"></a>00922       = <a class="code" href="corefile_8c.html#a280cf81e766f60b30618ae3011f2cb07">read_memory_unsigned_integer</a> (cache-&gt;reg_saved[<a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>].addr,
<a name="l00923"></a>00923                                       4, byte_order);
<a name="l00924"></a>00924   <span class="keywordflow">else</span>
<a name="l00925"></a>00925     cache-&gt;cfa = frame_high;
<a name="l00926"></a>00926 
<a name="l00927"></a>00927   <span class="comment">/* Exception handlers restore ESTATUS into STATUS.  */</span>
<a name="l00928"></a>00928   <span class="keywordflow">if</span> (exception_handler)
<a name="l00929"></a>00929     {
<a name="l00930"></a>00930       cache-&gt;reg_saved[<a class="code" href="nios2-tdep_8h.html#a59ba01e551a4b1c25486b12e82957841">NIOS2_STATUS_REGNUM</a>]
<a name="l00931"></a>00931         = cache-&gt;reg_saved[<a class="code" href="nios2-tdep_8h.html#a6e2413c1e1d729bf3199a1e82df43401">NIOS2_ESTATUS_REGNUM</a>];
<a name="l00932"></a>00932       cache-&gt;reg_saved[<a class="code" href="nios2-tdep_8h.html#a6e2413c1e1d729bf3199a1e82df43401">NIOS2_ESTATUS_REGNUM</a>].basereg = -1;
<a name="l00933"></a>00933     }
<a name="l00934"></a>00934 
<a name="l00935"></a>00935   <span class="keywordflow">if</span> (nios2_debug)
<a name="l00936"></a>00936     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;cfa=%s }\n&quot;</span>,
<a name="l00937"></a>00937                         <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, cache-&gt;cfa));
<a name="l00938"></a>00938 
<a name="l00939"></a>00939   <span class="keywordflow">return</span> prologue_end;
<a name="l00940"></a>00940 }
<a name="l00941"></a>00941 
<a name="l00942"></a>00942 <span class="comment">/* Implement the skip_prologue gdbarch hook.  */</span>
<a name="l00943"></a>00943 
<a name="l00944"></a>00944 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l00945"></a>00945 nios2_skip_prologue (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_pc)
<a name="l00946"></a>00946 {
<a name="l00947"></a>00947   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> limit_pc;
<a name="l00948"></a>00948   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> func_addr;
<a name="l00949"></a>00949 
<a name="l00950"></a>00950   <span class="keyword">struct </span>nios2_unwind_cache cache;
<a name="l00951"></a>00951 
<a name="l00952"></a>00952   <span class="comment">/* See if we can determine the end of the prologue via the symbol</span>
<a name="l00953"></a>00953 <span class="comment">     table.  If so, then return either PC, or the PC after the</span>
<a name="l00954"></a>00954 <span class="comment">     prologue, whichever is greater.  */</span>
<a name="l00955"></a>00955   <span class="keywordflow">if</span> (<a class="code" href="blockframe_8c.html#a2dae2257ad1417604d2c26f8b9071ca9">find_pc_partial_function</a> (start_pc, NULL, &amp;func_addr, NULL))
<a name="l00956"></a>00956     {
<a name="l00957"></a>00957       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> post_prologue_pc
<a name="l00958"></a>00958         = <a class="code" href="symtab_8c.html#a5e411a18b63476022fe4b9420138ae44">skip_prologue_using_sal</a> (gdbarch, func_addr);
<a name="l00959"></a>00959 
<a name="l00960"></a>00960       <span class="keywordflow">if</span> (post_prologue_pc != 0)
<a name="l00961"></a>00961         <span class="keywordflow">return</span> <a class="code" href="environ_8c.html#affe776513b24d84b39af8ab0930fef7f">max</a> (start_pc, post_prologue_pc);
<a name="l00962"></a>00962     }
<a name="l00963"></a>00963 
<a name="l00964"></a>00964   <span class="comment">/* Prologue analysis does the rest....  */</span>
<a name="l00965"></a>00965   nios2_init_cache (&amp;cache, start_pc);
<a name="l00966"></a>00966   <span class="keywordflow">return</span> nios2_analyze_prologue (gdbarch, start_pc, start_pc, &amp;cache, NULL);
<a name="l00967"></a>00967 }
<a name="l00968"></a>00968 
<a name="l00969"></a>00969 <span class="comment">/* Implement the breakpoint_from_pc gdbarch hook.  */</span>
<a name="l00970"></a>00970 
<a name="l00971"></a>00971 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a>*
<a name="l00972"></a>00972 nios2_breakpoint_from_pc (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *bp_addr,
<a name="l00973"></a>00973                           <span class="keywordtype">int</span> *bp_size)
<a name="l00974"></a>00974 {
<a name="l00975"></a>00975   <span class="comment">/* break encoding: 31-&gt;27  26-&gt;22  21-&gt;17  16-&gt;11 10-&gt;6 5-&gt;0 */</span>
<a name="l00976"></a>00976   <span class="comment">/*                 00000   00000   0x1d    0x2d   11111 0x3a */</span>
<a name="l00977"></a>00977   <span class="comment">/*                 00000   00000   11101   101101 11111 111010 */</span>
<a name="l00978"></a>00978   <span class="comment">/* In bytes:       00000000 00111011 01101111 11111010 */</span>
<a name="l00979"></a>00979   <span class="comment">/*                 0x0       0x3b    0x6f     0xfa */</span>
<a name="l00980"></a>00980   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> breakpoint_le[] = {0xfa, 0x6f, 0x3b, 0x0};
<a name="l00981"></a>00981   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> breakpoint_be[] = {0x0, 0x3b, 0x6f, 0xfa};
<a name="l00982"></a>00982 
<a name="l00983"></a>00983   <span class="keyword">enum</span> bfd_endian byte_order_for_code = <a class="code" href="gdbarch_8c.html#a1d2f84f99f58964411955a36571f6783">gdbarch_byte_order_for_code</a> (gdbarch);
<a name="l00984"></a>00984 
<a name="l00985"></a>00985   *bp_size = 4;
<a name="l00986"></a>00986   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#a1d2f84f99f58964411955a36571f6783">gdbarch_byte_order_for_code</a> (gdbarch) == BFD_ENDIAN_BIG)
<a name="l00987"></a>00987     <span class="keywordflow">return</span> breakpoint_be;
<a name="l00988"></a>00988   <span class="keywordflow">else</span>
<a name="l00989"></a>00989     <span class="keywordflow">return</span> breakpoint_le;
<a name="l00990"></a>00990 }
<a name="l00991"></a>00991 
<a name="l00992"></a>00992 <span class="comment">/* Implement the print_insn gdbarch method.  */</span>
<a name="l00993"></a>00993 
<a name="l00994"></a>00994 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00995"></a>00995 nios2_print_insn (bfd_vma <a class="code" href="exec_8h.html#ab268c3184bf49615e16de006a296a542">memaddr</a>, disassemble_info *info)
<a name="l00996"></a>00996 {
<a name="l00997"></a>00997   <span class="keywordflow">if</span> (info-&gt;endian == BFD_ENDIAN_BIG)
<a name="l00998"></a>00998     <span class="keywordflow">return</span> print_insn_big_nios2 (memaddr, info);
<a name="l00999"></a>00999   <span class="keywordflow">else</span>
<a name="l01000"></a>01000     <span class="keywordflow">return</span> print_insn_little_nios2 (memaddr, info);
<a name="l01001"></a>01001 }
<a name="l01002"></a>01002 
<a name="l01003"></a>01003 
<a name="l01004"></a>01004 <span class="comment">/* Implement the frame_align gdbarch method.  */</span>
<a name="l01005"></a>01005 
<a name="l01006"></a>01006 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01007"></a>01007 nios2_frame_align (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr)
<a name="l01008"></a>01008 {
<a name="l01009"></a>01009   <span class="keywordflow">return</span> <a class="code" href="utils_8c.html#a2333cae8a4809e09f8e851c83838ecaf">align_down</a> (addr, 4);
<a name="l01010"></a>01010 }
<a name="l01011"></a>01011 
<a name="l01012"></a>01012 
<a name="l01013"></a>01013 <span class="comment">/* Implement the return_value gdbarch method.  */</span>
<a name="l01014"></a>01014 
<a name="l01015"></a>01015 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5">return_value_convention</a>
<a name="l01016"></a>01016 nios2_return_value (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> value *<span class="keyword">function</span>,
<a name="l01017"></a>01017                     <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>, <span class="keyword">struct</span> regcache *regcache,
<a name="l01018"></a>01018                     <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *readbuf, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *writebuf)
<a name="l01019"></a>01019 {
<a name="l01020"></a>01020   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) &gt; 8)
<a name="l01021"></a>01021     <span class="keywordflow">return</span> <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5a1fab6a0bfd44af88ba17a143673dc937">RETURN_VALUE_STRUCT_CONVENTION</a>;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023   <span class="keywordflow">if</span> (readbuf)
<a name="l01024"></a>01024     nios2_extract_return_value (gdbarch, type, regcache, readbuf);
<a name="l01025"></a>01025   <span class="keywordflow">if</span> (writebuf)
<a name="l01026"></a>01026     nios2_store_return_value (gdbarch, type, regcache, writebuf);
<a name="l01027"></a>01027 
<a name="l01028"></a>01028   <span class="keywordflow">return</span> <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5a0cd14b7546740080384acc0c7e5caf3b">RETURN_VALUE_REGISTER_CONVENTION</a>;
<a name="l01029"></a>01029 }
<a name="l01030"></a>01030 
<a name="l01031"></a>01031 <span class="comment">/* Implement the dummy_id gdbarch method.  */</span>
<a name="l01032"></a>01032 
<a name="l01033"></a>01033 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structframe__id.html">frame_id</a>
<a name="l01034"></a>01034 nios2_dummy_id (struct gdbarch *gdbarch, <span class="keyword">struct </span>frame_info *this_frame)
<a name="l01035"></a>01035 {
<a name="l01036"></a>01036   <span class="keywordflow">return</span> <a class="code" href="frame_8c.html#a7f32da6ddc275b4684c301448d891f5b">frame_id_build</a>
<a name="l01037"></a>01037     (<a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>),
<a name="l01038"></a>01038      <a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a> (this_frame));
<a name="l01039"></a>01039 }
<a name="l01040"></a>01040 
<a name="l01041"></a>01041 <span class="comment">/* Implement the push_dummy_call gdbarch method.  */</span>
<a name="l01042"></a>01042 
<a name="l01043"></a>01043 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01044"></a>01044 nios2_push_dummy_call (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> value *<span class="keyword">function</span>,
<a name="l01045"></a>01045                        <span class="keyword">struct</span> regcache *regcache, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> bp_addr,
<a name="l01046"></a>01046                        <span class="keywordtype">int</span> nargs, <span class="keyword">struct</span> value **args, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> sp,
<a name="l01047"></a>01047                        <span class="keywordtype">int</span> <a class="code" href="arm-tdep_8h.html#aabb639d85dec2f973451bb1e7b6d1be8">struct_return</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> struct_addr)
<a name="l01048"></a>01048 {
<a name="l01049"></a>01049   <span class="keywordtype">int</span> argreg;
<a name="l01050"></a>01050   <span class="keywordtype">int</span> float_argreg;
<a name="l01051"></a>01051   <span class="keywordtype">int</span> argnum;
<a name="l01052"></a>01052   <span class="keywordtype">int</span> len = 0;
<a name="l01053"></a>01053   <span class="keywordtype">int</span> stack_offset = 0;
<a name="l01054"></a>01054   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> func_addr = <a class="code" href="infcall_8c.html#a68f258349aa77867901ff0b0ba2815a9">find_function_addr</a> (<span class="keyword">function</span>, NULL);
<a name="l01055"></a>01055   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l01056"></a>01056 
<a name="l01057"></a>01057   <span class="comment">/* Set the return address register to point to the entry point of</span>
<a name="l01058"></a>01058 <span class="comment">     the program, where a breakpoint lies in wait.  */</span>
<a name="l01059"></a>01059   <a class="code" href="regcache_8c.html#a81b7aed5cdcbde3896b0522e932d251a">regcache_cooked_write_signed</a> (regcache, <a class="code" href="nios2-tdep_8h.html#a8e532c6ea2657f3072e6ef7f31e65aa4">NIOS2_RA_REGNUM</a>, bp_addr);
<a name="l01060"></a>01060 
<a name="l01061"></a>01061   <span class="comment">/* Now make space on the stack for the args.  */</span>
<a name="l01062"></a>01062   <span class="keywordflow">for</span> (argnum = 0; argnum &lt; nargs; argnum++)
<a name="l01063"></a>01063     len += <a class="code" href="utils_8c.html#a1597f2e569978430feec3d64b5e4caa6">align_up</a> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (args[argnum])), 4);
<a name="l01064"></a>01064   sp -= <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l01065"></a>01065 
<a name="l01066"></a>01066   <span class="comment">/* Initialize the register pointer.  */</span>
<a name="l01067"></a>01067   argreg = <a class="code" href="nios2-tdep_8h.html#a19e9a655161c9aa6e9ee0bdd40a82742">NIOS2_FIRST_ARGREG</a>;
<a name="l01068"></a>01068 
<a name="l01069"></a>01069   <span class="comment">/* The struct_return pointer occupies the first parameter-passing</span>
<a name="l01070"></a>01070 <span class="comment">     register.  */</span>
<a name="l01071"></a>01071   <span class="keywordflow">if</span> (struct_return)
<a name="l01072"></a>01072     <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a> (regcache, argreg++, struct_addr);
<a name="l01073"></a>01073 
<a name="l01074"></a>01074   <span class="comment">/* Now load as many as possible of the first arguments into</span>
<a name="l01075"></a>01075 <span class="comment">     registers, and push the rest onto the stack.  Loop through args</span>
<a name="l01076"></a>01076 <span class="comment">     from first to last.  */</span>
<a name="l01077"></a>01077   <span class="keywordflow">for</span> (argnum = 0; argnum &lt; nargs; argnum++)
<a name="l01078"></a>01078     {
<a name="l01079"></a>01079       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *val;
<a name="l01080"></a>01080       <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> valbuf[<a class="code" href="defs_8h.html#a1f9aebf1de3ebbf4283a4dcf73308562a4f3d67bb99ae292178850a8930ab8252">MAX_REGISTER_SIZE</a>];
<a name="l01081"></a>01081       <span class="keyword">struct </span>value *arg = args[argnum];
<a name="l01082"></a>01082       <span class="keyword">struct </span>type *arg_type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg));
<a name="l01083"></a>01083       <span class="keywordtype">int</span> len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (arg_type);
<a name="l01084"></a>01084       <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> typecode = <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (arg_type);
<a name="l01085"></a>01085 
<a name="l01086"></a>01086       val = <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (arg);
<a name="l01087"></a>01087 
<a name="l01088"></a>01088       <span class="comment">/* Copy the argument to general registers or the stack in</span>
<a name="l01089"></a>01089 <span class="comment">         register-sized pieces.  Large arguments are split between</span>
<a name="l01090"></a>01090 <span class="comment">         registers and stack.  */</span>
<a name="l01091"></a>01091       <span class="keywordflow">while</span> (len &gt; 0)
<a name="l01092"></a>01092         {
<a name="l01093"></a>01093           <span class="keywordtype">int</span> partial_len = (len &lt; 4 ? len : 4);
<a name="l01094"></a>01094 
<a name="l01095"></a>01095           <span class="keywordflow">if</span> (argreg &lt;= <a class="code" href="nios2-tdep_8h.html#aa5c1db5ab2da2d9eaa056a5724b45507">NIOS2_LAST_ARGREG</a>)
<a name="l01096"></a>01096             {
<a name="l01097"></a>01097               <span class="comment">/* The argument is being passed in a register.  */</span>
<a name="l01098"></a>01098               <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> regval = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (val, partial_len,
<a name="l01099"></a>01099                                                            byte_order);
<a name="l01100"></a>01100 
<a name="l01101"></a>01101               <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a> (regcache, argreg, regval);
<a name="l01102"></a>01102               argreg++;
<a name="l01103"></a>01103             }
<a name="l01104"></a>01104           <span class="keywordflow">else</span>
<a name="l01105"></a>01105             {
<a name="l01106"></a>01106               <span class="comment">/* The argument is being passed on the stack.  */</span>
<a name="l01107"></a>01107               <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr = sp + stack_offset;
<a name="l01108"></a>01108 
<a name="l01109"></a>01109               <a class="code" href="corefile_8c.html#a05c568c157071d9349667fab589228e5">write_memory</a> (addr, val, partial_len);
<a name="l01110"></a>01110               stack_offset += <a class="code" href="utils_8c.html#a1597f2e569978430feec3d64b5e4caa6">align_up</a> (partial_len, 4);
<a name="l01111"></a>01111             }
<a name="l01112"></a>01112 
<a name="l01113"></a>01113           len -= partial_len;
<a name="l01114"></a>01114           val += partial_len;
<a name="l01115"></a>01115         }
<a name="l01116"></a>01116     }
<a name="l01117"></a>01117 
<a name="l01118"></a>01118   <a class="code" href="regcache_8c.html#a81b7aed5cdcbde3896b0522e932d251a">regcache_cooked_write_signed</a> (regcache, <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>, sp);
<a name="l01119"></a>01119 
<a name="l01120"></a>01120   <span class="comment">/* Return adjusted stack pointer.  */</span>
<a name="l01121"></a>01121   <span class="keywordflow">return</span> sp;
<a name="l01122"></a>01122 }
<a name="l01123"></a>01123 
<a name="l01124"></a>01124 <span class="comment">/* Implement the unwind_pc gdbarch method.  */</span>
<a name="l01125"></a>01125 
<a name="l01126"></a>01126 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01127"></a>01127 nios2_unwind_pc (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> frame_info *next_frame)
<a name="l01128"></a>01128 {
<a name="l01129"></a>01129   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> buf[4];
<a name="l01130"></a>01130 
<a name="l01131"></a>01131   <a class="code" href="frame_8c.html#af11d8d673027d53c4420da4895abc230">frame_unwind_register</a> (next_frame, <a class="code" href="nios2-tdep_8h.html#ac374f770ebf073bfdb22cfce666f8a3f">NIOS2_PC_REGNUM</a>, buf);
<a name="l01132"></a>01132   <span class="keywordflow">return</span> <a class="code" href="defs_8h.html#a8a619d8cb1c6d12c6354da6e663dbd95">extract_typed_address</a> (buf, <a class="code" href="structbuiltin__type.html">builtin_type</a> (gdbarch)-&gt;builtin_func_ptr);
<a name="l01133"></a>01133 }
<a name="l01134"></a>01134 
<a name="l01135"></a>01135 <span class="comment">/* Implement the unwind_sp gdbarch method.  */</span>
<a name="l01136"></a>01136 
<a name="l01137"></a>01137 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01138"></a>01138 nios2_unwind_sp (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> frame_info *this_frame)
<a name="l01139"></a>01139 {
<a name="l01140"></a>01140   <span class="keywordflow">return</span> <a class="code" href="frame_8c.html#a294f6912118884550787fd59f2a08ff6">frame_unwind_register_unsigned</a> (this_frame, <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>);
<a name="l01141"></a>01141 }
<a name="l01142"></a>01142 
<a name="l01143"></a>01143 <span class="comment">/* Use prologue analysis to fill in the register cache</span>
<a name="l01144"></a>01144 <span class="comment">   *THIS_PROLOGUE_CACHE for THIS_FRAME.  This function initializes</span>
<a name="l01145"></a>01145 <span class="comment">   *THIS_PROLOGUE_CACHE first.  */</span>
<a name="l01146"></a>01146 
<a name="l01147"></a>01147 <span class="keyword">static</span> <span class="keyword">struct </span>nios2_unwind_cache *
<a name="l01148"></a>01148 nios2_frame_unwind_cache (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01149"></a>01149                           <span class="keywordtype">void</span> **this_prologue_cache)
<a name="l01150"></a>01150 {
<a name="l01151"></a>01151   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame);
<a name="l01152"></a>01152   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> current_pc;
<a name="l01153"></a>01153   <span class="keyword">struct </span>nios2_unwind_cache *cache;
<a name="l01154"></a>01154   <span class="keywordtype">int</span> i;
<a name="l01155"></a>01155 
<a name="l01156"></a>01156   <span class="keywordflow">if</span> (*this_prologue_cache)
<a name="l01157"></a>01157     <span class="keywordflow">return</span> *this_prologue_cache;
<a name="l01158"></a>01158 
<a name="l01159"></a>01159   cache = <a class="code" href="frame_8h.html#af9f5c3008a0d58374aa310c5c63af552">FRAME_OBSTACK_ZALLOC</a> (<span class="keyword">struct</span> nios2_unwind_cache);
<a name="l01160"></a>01160   *this_prologue_cache = cache;
<a name="l01161"></a>01161 
<a name="l01162"></a>01162   <span class="comment">/* Zero all fields.  */</span>
<a name="l01163"></a>01163   nios2_init_cache (cache, <a class="code" href="frame_8c.html#ac64c0ce600cc134b2256c0d507f57cde">get_frame_func</a> (this_frame));
<a name="l01164"></a>01164 
<a name="l01165"></a>01165   <span class="comment">/* Prologue analysis does the rest...  */</span>
<a name="l01166"></a>01166   current_pc = <a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a> (this_frame);
<a name="l01167"></a>01167   <span class="keywordflow">if</span> (cache-&gt;pc != 0)
<a name="l01168"></a>01168     nios2_analyze_prologue (gdbarch, cache-&gt;pc, current_pc, cache, this_frame);
<a name="l01169"></a>01169 
<a name="l01170"></a>01170   <span class="keywordflow">return</span> cache;
<a name="l01171"></a>01171 }
<a name="l01172"></a>01172 
<a name="l01173"></a>01173 <span class="comment">/* Implement the this_id function for the normal unwinder.  */</span>
<a name="l01174"></a>01174 
<a name="l01175"></a>01175 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01176"></a>01176 nios2_frame_this_id (<span class="keyword">struct</span> frame_info *this_frame, <span class="keywordtype">void</span> **this_cache,
<a name="l01177"></a>01177                      <span class="keyword">struct</span> <a class="code" href="structframe__id.html">frame_id</a> *this_id)
<a name="l01178"></a>01178 {
<a name="l01179"></a>01179   <span class="keyword">struct </span>nios2_unwind_cache *cache =
<a name="l01180"></a>01180     nios2_frame_unwind_cache (this_frame, this_cache);
<a name="l01181"></a>01181 
<a name="l01182"></a>01182   <span class="comment">/* This marks the outermost frame.  */</span>
<a name="l01183"></a>01183   <span class="keywordflow">if</span> (cache-&gt;base == 0)
<a name="l01184"></a>01184     <span class="keywordflow">return</span>;
<a name="l01185"></a>01185 
<a name="l01186"></a>01186   *this_id = <a class="code" href="frame_8c.html#a7f32da6ddc275b4684c301448d891f5b">frame_id_build</a> (cache-&gt;cfa, cache-&gt;pc);
<a name="l01187"></a>01187 }
<a name="l01188"></a>01188 
<a name="l01189"></a>01189 <span class="comment">/* Implement the prev_register function for the normal unwinder.  */</span>
<a name="l01190"></a>01190 
<a name="l01191"></a>01191 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l01192"></a>01192 nios2_frame_prev_register (<span class="keyword">struct</span> frame_info *this_frame, <span class="keywordtype">void</span> **this_cache,
<a name="l01193"></a>01193                            <span class="keywordtype">int</span> <a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>)
<a name="l01194"></a>01194 {
<a name="l01195"></a>01195   <span class="keyword">struct </span>nios2_unwind_cache *cache =
<a name="l01196"></a>01196     nios2_frame_unwind_cache (this_frame, this_cache);
<a name="l01197"></a>01197 
<a name="l01198"></a>01198   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (regnum &gt;= 0 &amp;&amp; regnum &lt; NIOS2_NUM_REGS);
<a name="l01199"></a>01199 
<a name="l01200"></a>01200   <span class="comment">/* The PC of the previous frame is stored in the RA register of</span>
<a name="l01201"></a>01201 <span class="comment">     the current frame.  Frob regnum so that we pull the value from</span>
<a name="l01202"></a>01202 <span class="comment">     the correct place.  */</span>
<a name="l01203"></a>01203   <span class="keywordflow">if</span> (regnum == <a class="code" href="nios2-tdep_8h.html#ac374f770ebf073bfdb22cfce666f8a3f">NIOS2_PC_REGNUM</a>)
<a name="l01204"></a>01204     regnum = cache-&gt;return_regnum;
<a name="l01205"></a>01205 
<a name="l01206"></a>01206   <span class="keywordflow">if</span> (regnum == <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a> &amp;&amp; cache-&gt;cfa)
<a name="l01207"></a>01207     <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#ac7df103c9cdd8847accaa5752e4f52ea">frame_unwind_got_constant</a> (this_frame, regnum, cache-&gt;cfa);
<a name="l01208"></a>01208 
<a name="l01209"></a>01209   <span class="comment">/* If we&#39;ve worked out where a register is stored then load it from</span>
<a name="l01210"></a>01210 <span class="comment">     there.  */</span>
<a name="l01211"></a>01211   <span class="keywordflow">if</span> (cache-&gt;reg_saved[regnum].basereg == <a class="code" href="nios2-tdep_8h.html#a584c83ab11802fc1ba5a902b5296a420">NIOS2_Z_REGNUM</a>)
<a name="l01212"></a>01212     <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#ae7eed0715ca9ef71b626f80e3f026be9">frame_unwind_got_memory</a> (this_frame, regnum,
<a name="l01213"></a>01213                                     cache-&gt;reg_saved[regnum].addr);
<a name="l01214"></a>01214 
<a name="l01215"></a>01215   <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#a07784a5660795d4ca4bb82e05e0bc4f5">frame_unwind_got_register</a> (this_frame, regnum, regnum);
<a name="l01216"></a>01216 }
<a name="l01217"></a>01217 
<a name="l01218"></a>01218 <span class="comment">/* Implement the this_base, this_locals, and this_args hooks</span>
<a name="l01219"></a>01219 <span class="comment">   for the normal unwinder.  */</span>
<a name="l01220"></a>01220 
<a name="l01221"></a>01221 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01222"></a>01222 nios2_frame_base_address (<span class="keyword">struct</span> frame_info *this_frame, <span class="keywordtype">void</span> **this_cache)
<a name="l01223"></a>01223 {
<a name="l01224"></a>01224   <span class="keyword">struct </span>nios2_unwind_cache *info
<a name="l01225"></a>01225     = nios2_frame_unwind_cache (this_frame, this_cache);
<a name="l01226"></a>01226 
<a name="l01227"></a>01227   <span class="keywordflow">return</span> info-&gt;base;
<a name="l01228"></a>01228 }
<a name="l01229"></a>01229 
<a name="l01230"></a>01230 <span class="comment">/* Data structures for the normal prologue-analysis-based</span>
<a name="l01231"></a>01231 <span class="comment">   unwinder.  */</span>
<a name="l01232"></a>01232 
<a name="l01233"></a>01233 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structframe__unwind.html">frame_unwind</a> nios2_frame_unwind =
<a name="l01234"></a>01234 {
<a name="l01235"></a>01235   <a class="code" href="frame_8h.html#a3ca2c0bc7578bf3d337e34b2c08a6c5faeb4f7fd6d9e397d1141feb133746637a">NORMAL_FRAME</a>,
<a name="l01236"></a>01236   <a class="code" href="frame-unwind_8c.html#aa950afe60921514574c6150f0821f05c">default_frame_unwind_stop_reason</a>,
<a name="l01237"></a>01237   nios2_frame_this_id,
<a name="l01238"></a>01238   nios2_frame_prev_register,
<a name="l01239"></a>01239   NULL,
<a name="l01240"></a>01240   <a class="code" href="frame-unwind_8c.html#ade64a9807fa508622581cc779b10ff9c">default_frame_sniffer</a>
<a name="l01241"></a>01241 };
<a name="l01242"></a>01242 
<a name="l01243"></a>01243 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structframe__base.html">frame_base</a> nios2_frame_base =
<a name="l01244"></a>01244 {
<a name="l01245"></a>01245   &amp;nios2_frame_unwind,
<a name="l01246"></a>01246   nios2_frame_base_address,
<a name="l01247"></a>01247   nios2_frame_base_address,
<a name="l01248"></a>01248   nios2_frame_base_address
<a name="l01249"></a>01249 };
<a name="l01250"></a>01250 
<a name="l01251"></a>01251 <span class="comment">/* Fill in the register cache *THIS_CACHE for THIS_FRAME for use</span>
<a name="l01252"></a>01252 <span class="comment">   in the stub unwinder.  */</span>
<a name="l01253"></a>01253 
<a name="l01254"></a>01254 <span class="keyword">static</span> <span class="keyword">struct </span>trad_frame_cache *
<a name="l01255"></a>01255 nios2_stub_frame_cache (<span class="keyword">struct</span> frame_info *this_frame, <span class="keywordtype">void</span> **this_cache)
<a name="l01256"></a>01256 {
<a name="l01257"></a>01257   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc;
<a name="l01258"></a>01258   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_addr;
<a name="l01259"></a>01259   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> stack_addr;
<a name="l01260"></a>01260   <span class="keyword">struct </span>trad_frame_cache *this_trad_cache;
<a name="l01261"></a>01261   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame);
<a name="l01262"></a>01262   <span class="keywordtype">int</span> num_regs = <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (gdbarch);
<a name="l01263"></a>01263 
<a name="l01264"></a>01264   <span class="keywordflow">if</span> (*this_cache != NULL)
<a name="l01265"></a>01265     <span class="keywordflow">return</span> *this_cache;
<a name="l01266"></a>01266   this_trad_cache = <a class="code" href="trad-frame_8c.html#a4b27a42ad1c22232139d02f7cf9c9552">trad_frame_cache_zalloc</a> (this_frame);
<a name="l01267"></a>01267   *this_cache = this_trad_cache;
<a name="l01268"></a>01268 
<a name="l01269"></a>01269   <span class="comment">/* The return address is in the link register.  */</span>
<a name="l01270"></a>01270   <a class="code" href="trad-frame_8c.html#a151478432f0acef2675bbf5b9bb3c991">trad_frame_set_reg_realreg</a> (this_trad_cache,
<a name="l01271"></a>01271                               <a class="code" href="gdbarch_8c.html#a07a162ebafea1269eb8f341db44e53e7">gdbarch_pc_regnum</a> (gdbarch),
<a name="l01272"></a>01272                               <a class="code" href="nios2-tdep_8h.html#a8e532c6ea2657f3072e6ef7f31e65aa4">NIOS2_RA_REGNUM</a>);
<a name="l01273"></a>01273 
<a name="l01274"></a>01274   <span class="comment">/* Frame ID, since it&#39;s a frameless / stackless function, no stack</span>
<a name="l01275"></a>01275 <span class="comment">     space is allocated and SP on entry is the current SP.  */</span>
<a name="l01276"></a>01276   pc = <a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a> (this_frame);
<a name="l01277"></a>01277   <a class="code" href="blockframe_8c.html#a2dae2257ad1417604d2c26f8b9071ca9">find_pc_partial_function</a> (pc, NULL, &amp;start_addr, NULL);
<a name="l01278"></a>01278   stack_addr = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>);
<a name="l01279"></a>01279   <a class="code" href="trad-frame_8c.html#a96ff545f27ad7cd1863225128555bb81">trad_frame_set_id</a> (this_trad_cache, <a class="code" href="frame_8c.html#a7f32da6ddc275b4684c301448d891f5b">frame_id_build</a> (start_addr, stack_addr));
<a name="l01280"></a>01280   <span class="comment">/* Assume that the frame&#39;s base is the same as the stack pointer.  */</span>
<a name="l01281"></a>01281   <a class="code" href="trad-frame_8c.html#abec087efdabd96831ba01c1bea7d38bb">trad_frame_set_this_base</a> (this_trad_cache, stack_addr);
<a name="l01282"></a>01282 
<a name="l01283"></a>01283   <span class="keywordflow">return</span> this_trad_cache;
<a name="l01284"></a>01284 }
<a name="l01285"></a>01285 
<a name="l01286"></a>01286 <span class="comment">/* Implement the this_id function for the stub unwinder.  */</span>
<a name="l01287"></a>01287 
<a name="l01288"></a>01288 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01289"></a>01289 nios2_stub_frame_this_id (<span class="keyword">struct</span> frame_info *this_frame, <span class="keywordtype">void</span> **this_cache,
<a name="l01290"></a>01290                           <span class="keyword">struct</span> <a class="code" href="structframe__id.html">frame_id</a> *this_id)
<a name="l01291"></a>01291 {
<a name="l01292"></a>01292   <span class="keyword">struct </span>trad_frame_cache *this_trad_cache
<a name="l01293"></a>01293     = nios2_stub_frame_cache (this_frame, this_cache);
<a name="l01294"></a>01294 
<a name="l01295"></a>01295   <a class="code" href="trad-frame_8c.html#a8e079717a29c677d23f6e83d7ef32b17">trad_frame_get_id</a> (this_trad_cache, this_id);
<a name="l01296"></a>01296 }
<a name="l01297"></a>01297 
<a name="l01298"></a>01298 <span class="comment">/* Implement the prev_register function for the stub unwinder.  */</span>
<a name="l01299"></a>01299 
<a name="l01300"></a>01300 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l01301"></a>01301 nios2_stub_frame_prev_register (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01302"></a>01302                                 <span class="keywordtype">void</span> **this_cache, <span class="keywordtype">int</span> regnum)
<a name="l01303"></a>01303 {
<a name="l01304"></a>01304   <span class="keyword">struct </span>trad_frame_cache *this_trad_cache
<a name="l01305"></a>01305     = nios2_stub_frame_cache (this_frame, this_cache);
<a name="l01306"></a>01306 
<a name="l01307"></a>01307   <span class="keywordflow">return</span> <a class="code" href="trad-frame_8c.html#ae03aa8cc0e6f3aa7e6672581d3c65bae">trad_frame_get_register</a> (this_trad_cache, this_frame, regnum);
<a name="l01308"></a>01308 }
<a name="l01309"></a>01309 
<a name="l01310"></a>01310 <span class="comment">/* Implement the sniffer function for the stub unwinder.</span>
<a name="l01311"></a>01311 <span class="comment">   This unwinder is used for cases where the normal</span>
<a name="l01312"></a>01312 <span class="comment">   prologue-analysis-based unwinder can&#39;t work,</span>
<a name="l01313"></a>01313 <span class="comment">   such as PLT stubs.  */</span>
<a name="l01314"></a>01314 
<a name="l01315"></a>01315 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01316"></a>01316 nios2_stub_frame_sniffer (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structframe__unwind.html">frame_unwind</a> *<span class="keyword">self</span>,
<a name="l01317"></a>01317                           <span class="keyword">struct</span> frame_info *this_frame, <span class="keywordtype">void</span> **cache)
<a name="l01318"></a>01318 {
<a name="l01319"></a>01319   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> <a class="code" href="go32-nat_8c.html#a36fb645a916cd19d79712e75c47b8d03">dummy</a>[4];
<a name="l01320"></a>01320   <span class="keyword">struct </span><a class="code" href="structobj__section.html">obj_section</a> *s;
<a name="l01321"></a>01321   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc = <a class="code" href="frame_8c.html#a9035a35b7470b669f9bafee9c3961559">get_frame_address_in_block</a> (this_frame);
<a name="l01322"></a>01322 
<a name="l01323"></a>01323   <span class="comment">/* Use the stub unwinder for unreadable code.  */</span>
<a name="l01324"></a>01324   <span class="keywordflow">if</span> (<a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (<a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a> (this_frame), dummy, 4) != 0)
<a name="l01325"></a>01325     <span class="keywordflow">return</span> 1;
<a name="l01326"></a>01326 
<a name="l01327"></a>01327   <span class="keywordflow">if</span> (in_plt_section (pc))
<a name="l01328"></a>01328     <span class="keywordflow">return</span> 1;
<a name="l01329"></a>01329 
<a name="l01330"></a>01330   <span class="keywordflow">return</span> 0;
<a name="l01331"></a>01331 }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333 <span class="comment">/* Implement the this_base, this_locals, and this_args hooks</span>
<a name="l01334"></a>01334 <span class="comment">   for the stub unwinder.  */</span>
<a name="l01335"></a>01335 
<a name="l01336"></a>01336 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01337"></a>01337 nios2_stub_frame_base_address (<span class="keyword">struct</span> frame_info *this_frame, <span class="keywordtype">void</span> **this_cache)
<a name="l01338"></a>01338 {
<a name="l01339"></a>01339   <span class="keyword">struct </span>trad_frame_cache *this_trad_cache
<a name="l01340"></a>01340     = nios2_stub_frame_cache (this_frame, this_cache);
<a name="l01341"></a>01341 
<a name="l01342"></a>01342   <span class="keywordflow">return</span> <a class="code" href="trad-frame_8c.html#aa7a88f3abb44958a10f492d99ef33b43">trad_frame_get_this_base</a> (this_trad_cache);
<a name="l01343"></a>01343 }
<a name="l01344"></a>01344 
<a name="l01345"></a>01345 <span class="comment">/* Define the data structures for the stub unwinder.  */</span>
<a name="l01346"></a>01346 
<a name="l01347"></a>01347 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structframe__unwind.html">frame_unwind</a> nios2_stub_frame_unwind =
<a name="l01348"></a>01348 {
<a name="l01349"></a>01349   <a class="code" href="frame_8h.html#a3ca2c0bc7578bf3d337e34b2c08a6c5faeb4f7fd6d9e397d1141feb133746637a">NORMAL_FRAME</a>,
<a name="l01350"></a>01350   <a class="code" href="frame-unwind_8c.html#aa950afe60921514574c6150f0821f05c">default_frame_unwind_stop_reason</a>,
<a name="l01351"></a>01351   nios2_stub_frame_this_id,
<a name="l01352"></a>01352   nios2_stub_frame_prev_register,
<a name="l01353"></a>01353   NULL,
<a name="l01354"></a>01354   nios2_stub_frame_sniffer
<a name="l01355"></a>01355 };
<a name="l01356"></a>01356 
<a name="l01357"></a>01357 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structframe__base.html">frame_base</a> nios2_stub_frame_base =
<a name="l01358"></a>01358 {
<a name="l01359"></a>01359   &amp;nios2_stub_frame_unwind,
<a name="l01360"></a>01360   nios2_stub_frame_base_address,
<a name="l01361"></a>01361   nios2_stub_frame_base_address,
<a name="l01362"></a>01362   nios2_stub_frame_base_address
<a name="l01363"></a>01363 };
<a name="l01364"></a>01364 
<a name="l01365"></a>01365 <span class="comment">/* Helper function to read an instruction at PC.  */</span>
<a name="l01366"></a>01366 
<a name="l01367"></a>01367 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>
<a name="l01368"></a>01368 nios2_fetch_instruction (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc)
<a name="l01369"></a>01369 {
<a name="l01370"></a>01370   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l01371"></a>01371 
<a name="l01372"></a>01372   <span class="keywordflow">return</span> <a class="code" href="corefile_8c.html#a280cf81e766f60b30618ae3011f2cb07">read_memory_unsigned_integer</a> (pc, <a class="code" href="nios2-tdep_8h.html#aec6b07e53f3a751e302ab6779d7c1d1a">NIOS2_OPCODE_SIZE</a>, byte_order);
<a name="l01373"></a>01373 }
<a name="l01374"></a>01374 
<a name="l01375"></a>01375 <span class="comment">/* Determine where to set a single step breakpoint while considering</span>
<a name="l01376"></a>01376 <span class="comment">   branch prediction.  */</span>
<a name="l01377"></a>01377 
<a name="l01378"></a>01378 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01379"></a>01379 nios2_get_next_pc (<span class="keyword">struct</span> frame_info *frame, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc)
<a name="l01380"></a>01380 {
<a name="l01381"></a>01381   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (frame);
<a name="l01382"></a>01382   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l01383"></a>01383   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> inst;
<a name="l01384"></a>01384   <span class="keywordtype">int</span> op;
<a name="l01385"></a>01385   <span class="keywordtype">int</span> imm16;
<a name="l01386"></a>01386   <span class="keywordtype">int</span> ra;
<a name="l01387"></a>01387   <span class="keywordtype">int</span> rb;
<a name="l01388"></a>01388   <span class="keywordtype">int</span> ras;
<a name="l01389"></a>01389   <span class="keywordtype">int</span> rbs;
<a name="l01390"></a>01390   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rau;
<a name="l01391"></a>01391   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rbu;
<a name="l01392"></a>01392 
<a name="l01393"></a>01393   inst = nios2_fetch_instruction (gdbarch, pc);
<a name="l01394"></a>01394   pc += <a class="code" href="nios2-tdep_8h.html#aec6b07e53f3a751e302ab6779d7c1d1a">NIOS2_OPCODE_SIZE</a>;
<a name="l01395"></a>01395 
<a name="l01396"></a>01396   imm16 = (short) GET_IW_IMM16 (inst);
<a name="l01397"></a>01397   ra = GET_IW_A (inst);
<a name="l01398"></a>01398   rb = GET_IW_B (inst);
<a name="l01399"></a>01399   ras = <a class="code" href="frame_8c.html#abd9e6d8ee95caae2621108bbbb44bd2f">get_frame_register_signed</a> (frame, ra);
<a name="l01400"></a>01400   rbs = <a class="code" href="frame_8c.html#abd9e6d8ee95caae2621108bbbb44bd2f">get_frame_register_signed</a> (frame, rb);
<a name="l01401"></a>01401   rau = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (frame, ra);
<a name="l01402"></a>01402   rbu = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (frame, rb);
<a name="l01403"></a>01403 
<a name="l01404"></a>01404   <span class="keywordflow">switch</span> (GET_IW_OP (inst))
<a name="l01405"></a>01405     {
<a name="l01406"></a>01406     <span class="keywordflow">case</span> OP_BEQ:
<a name="l01407"></a>01407       <span class="keywordflow">if</span> (ras == rbs)
<a name="l01408"></a>01408         pc += imm16;
<a name="l01409"></a>01409       <span class="keywordflow">break</span>;
<a name="l01410"></a>01410 
<a name="l01411"></a>01411     <span class="keywordflow">case</span> OP_BGE:
<a name="l01412"></a>01412       <span class="keywordflow">if</span> (ras &gt;= rbs)
<a name="l01413"></a>01413         pc += imm16;
<a name="l01414"></a>01414       <span class="keywordflow">break</span>;
<a name="l01415"></a>01415 
<a name="l01416"></a>01416     <span class="keywordflow">case</span> OP_BGEU:
<a name="l01417"></a>01417       <span class="keywordflow">if</span> (rau &gt;= rbu)
<a name="l01418"></a>01418         pc += imm16;
<a name="l01419"></a>01419       <span class="keywordflow">break</span>;
<a name="l01420"></a>01420 
<a name="l01421"></a>01421     <span class="keywordflow">case</span> OP_BLT:
<a name="l01422"></a>01422       <span class="keywordflow">if</span> (ras &lt; rbs)
<a name="l01423"></a>01423         pc += imm16;
<a name="l01424"></a>01424       <span class="keywordflow">break</span>;
<a name="l01425"></a>01425 
<a name="l01426"></a>01426     <span class="keywordflow">case</span> OP_BLTU:
<a name="l01427"></a>01427       <span class="keywordflow">if</span> (rau &lt; rbu)
<a name="l01428"></a>01428         pc += imm16;
<a name="l01429"></a>01429       <span class="keywordflow">break</span>;
<a name="l01430"></a>01430 
<a name="l01431"></a>01431     <span class="keywordflow">case</span> OP_BNE:
<a name="l01432"></a>01432       <span class="keywordflow">if</span> (ras != rbs)
<a name="l01433"></a>01433         pc += imm16;
<a name="l01434"></a>01434       <span class="keywordflow">break</span>;
<a name="l01435"></a>01435 
<a name="l01436"></a>01436     <span class="keywordflow">case</span> OP_BR:
<a name="l01437"></a>01437       pc += imm16;
<a name="l01438"></a>01438       <span class="keywordflow">break</span>;
<a name="l01439"></a>01439 
<a name="l01440"></a>01440     <span class="keywordflow">case</span> OP_JMPI:
<a name="l01441"></a>01441     <span class="keywordflow">case</span> OP_CALL:
<a name="l01442"></a>01442       pc = (pc &amp; 0xf0000000) | (GET_IW_IMM26 (inst) &lt;&lt; 2);
<a name="l01443"></a>01443       <span class="keywordflow">break</span>;
<a name="l01444"></a>01444 
<a name="l01445"></a>01445     <span class="keywordflow">case</span> OP_OPX:
<a name="l01446"></a>01446       <span class="keywordflow">switch</span> (GET_IW_OPX (inst))
<a name="l01447"></a>01447         {
<a name="l01448"></a>01448         <span class="keywordflow">case</span> OPX_JMP:
<a name="l01449"></a>01449         <span class="keywordflow">case</span> OPX_CALLR:
<a name="l01450"></a>01450         <span class="keywordflow">case</span> OPX_RET:
<a name="l01451"></a>01451           pc = ras;
<a name="l01452"></a>01452           <span class="keywordflow">break</span>;
<a name="l01453"></a>01453 
<a name="l01454"></a>01454         <span class="keywordflow">case</span> OPX_TRAP:
<a name="l01455"></a>01455           <span class="keywordflow">if</span> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#adfdc65c6f29d29cb45503679732c8d21">syscall_next_pc</a> != NULL)
<a name="l01456"></a>01456             <span class="keywordflow">return</span> tdep-&gt;<a class="code" href="structgdbarch__tdep.html#adfdc65c6f29d29cb45503679732c8d21">syscall_next_pc</a> (frame);
<a name="l01457"></a>01457 
<a name="l01458"></a>01458         <span class="keywordflow">default</span>:
<a name="l01459"></a>01459           <span class="keywordflow">break</span>;
<a name="l01460"></a>01460         }
<a name="l01461"></a>01461       <span class="keywordflow">break</span>;
<a name="l01462"></a>01462     <span class="keywordflow">default</span>:
<a name="l01463"></a>01463       <span class="keywordflow">break</span>;
<a name="l01464"></a>01464     }
<a name="l01465"></a>01465   <span class="keywordflow">return</span> <a class="code" href="structgdbarch__tdep.html#ab7a207d4e85b564c48238283745247b8">pc</a>;
<a name="l01466"></a>01466 }
<a name="l01467"></a>01467 
<a name="l01468"></a>01468 <span class="comment">/* Implement the software_single_step gdbarch method.  */</span>
<a name="l01469"></a>01469 
<a name="l01470"></a>01470 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01471"></a>01471 nios2_software_single_step (<span class="keyword">struct</span> frame_info *frame)
<a name="l01472"></a>01472 {
<a name="l01473"></a>01473   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (frame);
<a name="l01474"></a>01474   <span class="keyword">struct </span>address_space *aspace = <a class="code" href="frame_8c.html#abdf9824b7a32ae3a71b8de560a16bfe8">get_frame_address_space</a> (frame);
<a name="l01475"></a>01475   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> next_pc = nios2_get_next_pc (frame, <a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a> (frame));
<a name="l01476"></a>01476 
<a name="l01477"></a>01477   <a class="code" href="breakpoint_8c.html#a8decd828f1a0042e3e40a1ed86940140">insert_single_step_breakpoint</a> (gdbarch, aspace, next_pc);
<a name="l01478"></a>01478 
<a name="l01479"></a>01479   <span class="keywordflow">return</span> 1;
<a name="l01480"></a>01480 }
<a name="l01481"></a>01481 
<a name="l01482"></a>01482 <span class="comment">/* Implement the get_longjump_target gdbarch method.  */</span>
<a name="l01483"></a>01483 
<a name="l01484"></a>01484 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01485"></a>01485 nios2_get_longjmp_target (<span class="keyword">struct</span> frame_info *frame, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *pc)
<a name="l01486"></a>01486 {
<a name="l01487"></a>01487   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (frame);
<a name="l01488"></a>01488   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l01489"></a>01489   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l01490"></a>01490   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> jb_addr = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (frame, <a class="code" href="nios2-tdep_8h.html#ae931972bd766e088652b73cec656c5ce">NIOS2_R4_REGNUM</a>);
<a name="l01491"></a>01491   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> buf[4];
<a name="l01492"></a>01492 
<a name="l01493"></a>01493   <span class="keywordflow">if</span> (<a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (jb_addr + (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ab239cee5e4f9c98642ba75a9609f1122">jb_pc</a> * 4), buf, 4))
<a name="l01494"></a>01494     <span class="keywordflow">return</span> 0;
<a name="l01495"></a>01495 
<a name="l01496"></a>01496   *pc = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf, 4, byte_order);
<a name="l01497"></a>01497   <span class="keywordflow">return</span> 1;
<a name="l01498"></a>01498 }
<a name="l01499"></a>01499 
<a name="l01500"></a>01500 <span class="comment">/* Initialize the Nios II gdbarch.  */</span>
<a name="l01501"></a>01501 
<a name="l01502"></a>01502 <span class="keyword">static</span> <span class="keyword">struct </span>gdbarch *
<a name="l01503"></a>01503 nios2_gdbarch_init (<span class="keyword">struct</span> <a class="code" href="structgdbarch__info.html">gdbarch_info</a> info, <span class="keyword">struct</span> <a class="code" href="structgdbarch__list.html">gdbarch_list</a> *arches)
<a name="l01504"></a>01504 {
<a name="l01505"></a>01505   <span class="keyword">struct </span>gdbarch *gdbarch;
<a name="l01506"></a>01506   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep;
<a name="l01507"></a>01507   <span class="keywordtype">int</span> register_bytes, i;
<a name="l01508"></a>01508   <span class="keyword">struct </span>tdesc_arch_data *tdesc_data = NULL;
<a name="l01509"></a>01509   <span class="keyword">const</span> <span class="keyword">struct </span>target_desc *tdesc = info.<a class="code" href="structgdbarch__info.html#ac92a2218499c8147be64826e303d688e">target_desc</a>;
<a name="l01510"></a>01510 
<a name="l01511"></a>01511   <span class="keywordflow">if</span> (!<a class="code" href="target-descriptions_8c.html#a54a8994f193cc0a0cf6dbb6d771becf2">tdesc_has_registers</a> (tdesc))
<a name="l01512"></a>01512     <span class="comment">/* Pick a default target description.  */</span>
<a name="l01513"></a>01513     tdesc = <a class="code" href="nios2_8c.html#a4f67bc80d943ee9c5e02eda54c1ca645">tdesc_nios2</a>;
<a name="l01514"></a>01514 
<a name="l01515"></a>01515   <span class="comment">/* Check any target description for validity.  */</span>
<a name="l01516"></a>01516   <span class="keywordflow">if</span> (<a class="code" href="target-descriptions_8c.html#a54a8994f193cc0a0cf6dbb6d771becf2">tdesc_has_registers</a> (tdesc))
<a name="l01517"></a>01517     {
<a name="l01518"></a>01518       <span class="keyword">const</span> <span class="keyword">struct </span>tdesc_feature *feature;
<a name="l01519"></a>01519       <span class="keywordtype">int</span> valid_p;
<a name="l01520"></a>01520 
<a name="l01521"></a>01521       feature = <a class="code" href="target-descriptions_8c.html#abc4d5a3eeb4bfc94bd14ac763516e938">tdesc_find_feature</a> (tdesc, <span class="stringliteral">&quot;org.gnu.gdb.nios2.cpu&quot;</span>);
<a name="l01522"></a>01522       <span class="keywordflow">if</span> (feature == NULL)
<a name="l01523"></a>01523         <span class="keywordflow">return</span> NULL;
<a name="l01524"></a>01524 
<a name="l01525"></a>01525       tdesc_data = <a class="code" href="target-descriptions_8c.html#ae51f8476cf65c9be4b3ed6a83aff1671">tdesc_data_alloc</a> ();
<a name="l01526"></a>01526 
<a name="l01527"></a>01527       valid_p = 1;
<a name="l01528"></a>01528       
<a name="l01529"></a>01529       <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="nios2-tdep_8h.html#ae913e9c123638347d36317e8b4ac30b6">NIOS2_NUM_REGS</a>; i++)
<a name="l01530"></a>01530         valid_p &amp;= <a class="code" href="target-descriptions_8c.html#a32eadffa81e6bfdd019d344e218f0e65">tdesc_numbered_register</a> (feature, tdesc_data, i,
<a name="l01531"></a>01531                                             nios2_reg_names[i]);
<a name="l01532"></a>01532 
<a name="l01533"></a>01533       <span class="keywordflow">if</span> (!valid_p)
<a name="l01534"></a>01534         {
<a name="l01535"></a>01535           <a class="code" href="target-descriptions_8c.html#a873586b621fb2a8ab911f5506cfd9bc7">tdesc_data_cleanup</a> (tdesc_data);
<a name="l01536"></a>01536           <span class="keywordflow">return</span> NULL;
<a name="l01537"></a>01537         }
<a name="l01538"></a>01538     }
<a name="l01539"></a>01539 
<a name="l01540"></a>01540   <span class="comment">/* Find a candidate among the list of pre-declared architectures.  */</span>
<a name="l01541"></a>01541   arches = <a class="code" href="gdbarch_8c.html#aa3ea1c25a21a533dfd0d924a7d9778e4">gdbarch_list_lookup_by_info</a> (arches, &amp;info);
<a name="l01542"></a>01542   <span class="keywordflow">if</span> (arches != NULL)
<a name="l01543"></a>01543     <span class="keywordflow">return</span> arches-&gt;<a class="code" href="structgdbarch__list.html#a6c51da8c4c95249704dfe18394fd08f9">gdbarch</a>;
<a name="l01544"></a>01544 
<a name="l01545"></a>01545   <span class="comment">/* None found, create a new architecture from the information</span>
<a name="l01546"></a>01546 <span class="comment">     provided.  */</span>
<a name="l01547"></a>01547   tdep = <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a> (1, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a>));
<a name="l01548"></a>01548   gdbarch = <a class="code" href="gdbarch_8c.html#a9e0b0979fa2cb7439f41f66deda8dec5">gdbarch_alloc</a> (&amp;info, tdep);
<a name="l01549"></a>01549 
<a name="l01550"></a>01550   <span class="comment">/* longjmp support not enabled by default.  */</span>
<a name="l01551"></a>01551   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ab239cee5e4f9c98642ba75a9609f1122">jb_pc</a> = -1;
<a name="l01552"></a>01552 
<a name="l01553"></a>01553   <span class="comment">/* Data type sizes.  */</span>
<a name="l01554"></a>01554   <a class="code" href="gdbarch_8c.html#abaaa21a756f3f8a689513c6df8b47ced">set_gdbarch_ptr_bit</a> (gdbarch, 32);
<a name="l01555"></a>01555   <a class="code" href="gdbarch_8c.html#a028fd40e003f89fcf02d7c2f9335b6ad">set_gdbarch_addr_bit</a> (gdbarch, 32);
<a name="l01556"></a>01556   <a class="code" href="gdbarch_8c.html#aa8ab344aebdb71839678ff3d3e248f9b">set_gdbarch_short_bit</a> (gdbarch, 16);
<a name="l01557"></a>01557   <a class="code" href="gdbarch_8c.html#a4dbde89c15b9ee9f1808a4e01f2a758d">set_gdbarch_int_bit</a> (gdbarch, 32);
<a name="l01558"></a>01558   <a class="code" href="gdbarch_8c.html#ab661d4332c2357c6242d5f3f57f1bc44">set_gdbarch_long_bit</a> (gdbarch, 32);
<a name="l01559"></a>01559   <a class="code" href="gdbarch_8c.html#a00b33f93ffedea6960d0ed4a9d7e1fba">set_gdbarch_long_long_bit</a> (gdbarch, 64);
<a name="l01560"></a>01560   <a class="code" href="gdbarch_8c.html#aa04e7a5715ca0c94652f8d35f44411f7">set_gdbarch_float_bit</a> (gdbarch, 32);
<a name="l01561"></a>01561   <a class="code" href="gdbarch_8c.html#a6dde6fbd6439a96136e99bed4a7d98cd">set_gdbarch_double_bit</a> (gdbarch, 64);
<a name="l01562"></a>01562 
<a name="l01563"></a>01563   <a class="code" href="gdbarch_8c.html#af3d3823011ac395f80e7f616ba59d252">set_gdbarch_float_format</a> (gdbarch, <a class="code" href="gdbtypes_8c.html#a2fcc5f34f85af43cce0eb78225fd2a11">floatformats_ieee_single</a>);
<a name="l01564"></a>01564   <a class="code" href="gdbarch_8c.html#aeda072f3599a56ad1fdfe82f4c99f1f8">set_gdbarch_double_format</a> (gdbarch, <a class="code" href="gdbtypes_8c.html#ab5eaf32f7eeeb57f880c28ff0d7544ae">floatformats_ieee_double</a>);
<a name="l01565"></a>01565 
<a name="l01566"></a>01566   <span class="comment">/* The register set.  */</span>
<a name="l01567"></a>01567   <a class="code" href="gdbarch_8c.html#ad8417c5d66cf04d0587f58f82de94c48">set_gdbarch_num_regs</a> (gdbarch, NIOS2_NUM_REGS);
<a name="l01568"></a>01568   <a class="code" href="gdbarch_8c.html#a81a92a88a67093d18e59fd5650fda352">set_gdbarch_sp_regnum</a> (gdbarch, <a class="code" href="nios2-tdep_8h.html#ad95feda12fc6466aa66e653c11f9437f">NIOS2_SP_REGNUM</a>);
<a name="l01569"></a>01569   <a class="code" href="gdbarch_8c.html#a8852f70e2afc74953a57521ed08a3381">set_gdbarch_pc_regnum</a> (gdbarch, <a class="code" href="nios2-tdep_8h.html#ac374f770ebf073bfdb22cfce666f8a3f">NIOS2_PC_REGNUM</a>);     <span class="comment">/* Pseudo register PC */</span>
<a name="l01570"></a>01570 
<a name="l01571"></a>01571   <a class="code" href="gdbarch_8c.html#a378ba40a6275393e204873c5bba602ad">set_gdbarch_register_name</a> (gdbarch, nios2_register_name);
<a name="l01572"></a>01572   <a class="code" href="gdbarch_8c.html#a21919f6adfae80ed36e69e89cdfea531">set_gdbarch_register_type</a> (gdbarch, nios2_register_type);
<a name="l01573"></a>01573 
<a name="l01574"></a>01574   <span class="comment">/* Provide register mappings for stabs and dwarf2.  */</span>
<a name="l01575"></a>01575   <a class="code" href="gdbarch_8c.html#abeb6b220ed850a9f2b4a992dfcae9a2b">set_gdbarch_stab_reg_to_regnum</a> (gdbarch, nios2_dwarf_reg_to_regnum);
<a name="l01576"></a>01576   <a class="code" href="gdbarch_8c.html#a43ca55f05fcf599681eb376bbc6c8ece">set_gdbarch_dwarf2_reg_to_regnum</a> (gdbarch, nios2_dwarf_reg_to_regnum);
<a name="l01577"></a>01577 
<a name="l01578"></a>01578   <a class="code" href="gdbarch_8c.html#ad66381ed135b13aa5635f0485211ca71">set_gdbarch_inner_than</a> (gdbarch, <a class="code" href="arch-utils_8c.html#aaceae1c07203f3091df647f813b9f20e">core_addr_lessthan</a>);
<a name="l01579"></a>01579 
<a name="l01580"></a>01580   <span class="comment">/* Call dummy code.  */</span>
<a name="l01581"></a>01581   <a class="code" href="gdbarch_8c.html#aff48f6a8b2982831522fc7b3af596654">set_gdbarch_frame_align</a> (gdbarch, nios2_frame_align);
<a name="l01582"></a>01582 
<a name="l01583"></a>01583   <a class="code" href="gdbarch_8c.html#ad9b13a9323cac027c4b805953b4fff63">set_gdbarch_return_value</a> (gdbarch, nios2_return_value);
<a name="l01584"></a>01584 
<a name="l01585"></a>01585   <a class="code" href="gdbarch_8c.html#a841509ae0070f2f12aa9b3b7fd52b92f">set_gdbarch_skip_prologue</a> (gdbarch, nios2_skip_prologue);
<a name="l01586"></a>01586   <a class="code" href="gdbarch_8c.html#ab1ffbc0d23252e88823c50139b8464fb">set_gdbarch_in_function_epilogue_p</a> (gdbarch, nios2_in_function_epilogue_p);
<a name="l01587"></a>01587   <a class="code" href="gdbarch_8c.html#ad738cdf37fa27f4cf3642107cadf61d3">set_gdbarch_breakpoint_from_pc</a> (gdbarch, nios2_breakpoint_from_pc);
<a name="l01588"></a>01588 
<a name="l01589"></a>01589   <a class="code" href="gdbarch_8c.html#a23da982924f904d22d0b58639a48bccf">set_gdbarch_dummy_id</a> (gdbarch, nios2_dummy_id);
<a name="l01590"></a>01590   <a class="code" href="gdbarch_8c.html#a1974f5f26c09a4cd32165286c3769621">set_gdbarch_unwind_pc</a> (gdbarch, nios2_unwind_pc);
<a name="l01591"></a>01591   <a class="code" href="gdbarch_8c.html#ababd871cc4b5fac1831e52f7331d7572">set_gdbarch_unwind_sp</a> (gdbarch, nios2_unwind_sp);
<a name="l01592"></a>01592 
<a name="l01593"></a>01593   <span class="comment">/* The dwarf2 unwinder will normally produce the best results if</span>
<a name="l01594"></a>01594 <span class="comment">     the debug information is available, so register it first.  */</span>
<a name="l01595"></a>01595   <a class="code" href="dwarf2-frame_8c.html#ab2a0a14bba7f1db72907039eb3356975">dwarf2_append_unwinders</a> (gdbarch);
<a name="l01596"></a>01596   <a class="code" href="frame-unwind_8c.html#afa4de8a130514bfd524d46f32e35a534">frame_unwind_append_unwinder</a> (gdbarch, &amp;nios2_stub_frame_unwind);
<a name="l01597"></a>01597   <a class="code" href="frame-unwind_8c.html#afa4de8a130514bfd524d46f32e35a534">frame_unwind_append_unwinder</a> (gdbarch, &amp;nios2_frame_unwind);
<a name="l01598"></a>01598 
<a name="l01599"></a>01599   <span class="comment">/* Single stepping.  */</span>
<a name="l01600"></a>01600   <a class="code" href="gdbarch_8c.html#a3ef5204e360b0a4ef1d162945911c403">set_gdbarch_software_single_step</a> (gdbarch, nios2_software_single_step);
<a name="l01601"></a>01601 
<a name="l01602"></a>01602   <span class="comment">/* Hook in ABI-specific overrides, if they have been registered.  */</span>
<a name="l01603"></a>01603   <a class="code" href="osabi_8c.html#a38a6d312b216043e2dc48d1ada09035b">gdbarch_init_osabi</a> (info, gdbarch);
<a name="l01604"></a>01604 
<a name="l01605"></a>01605   <span class="keywordflow">if</span> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ab239cee5e4f9c98642ba75a9609f1122">jb_pc</a> &gt;= 0)
<a name="l01606"></a>01606     <a class="code" href="gdbarch_8c.html#ae8e313db3a0bf29bc29ab4173b6d4418">set_gdbarch_get_longjmp_target</a> (gdbarch, nios2_get_longjmp_target);
<a name="l01607"></a>01607 
<a name="l01608"></a>01608   <a class="code" href="frame-base_8c.html#afc9e209b41e14278fb1ab72c1d3c6e5d">frame_base_set_default</a> (gdbarch, &amp;nios2_frame_base);
<a name="l01609"></a>01609 
<a name="l01610"></a>01610   <a class="code" href="gdbarch_8c.html#a0c9e9e391e44d476b74debefc407e9bb">set_gdbarch_print_insn</a> (gdbarch, nios2_print_insn);
<a name="l01611"></a>01611 
<a name="l01612"></a>01612   <span class="comment">/* Enable inferior call support.  */</span>
<a name="l01613"></a>01613   <a class="code" href="gdbarch_8c.html#a853528dceff46211c1bb8c57b77dca31">set_gdbarch_push_dummy_call</a> (gdbarch, nios2_push_dummy_call);
<a name="l01614"></a>01614 
<a name="l01615"></a>01615   <span class="keywordflow">if</span> (tdesc_data)
<a name="l01616"></a>01616     <a class="code" href="target-descriptions_8c.html#a6e7158d012f081cc038d2b5b1b0830ee">tdesc_use_registers</a> (gdbarch, tdesc, tdesc_data);
<a name="l01617"></a>01617 
<a name="l01618"></a>01618   <span class="keywordflow">return</span> gdbarch;
<a name="l01619"></a>01619 }
<a name="l01620"></a>01620 
<a name="l01621"></a>01621 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#a686ed07d4fdcdc366f2bc677216ca08d">initialize_file_ftype</a> <a class="code" href="nios2-tdep_8c.html#a73aa304144db59ea1761b7e86dca0d53">_initialize_nios2_tdep</a>; <span class="comment">/* -Wmissing-prototypes */</span>
<a name="l01622"></a>01622 
<a name="l01623"></a>01623 <span class="keywordtype">void</span>
<a name="l01624"></a><a class="code" href="nios2-tdep_8c.html#a48966eaba011ed9f9b5c07511b171d35">01624</a> _initialize_nios2_tdep (<span class="keywordtype">void</span>)
<a name="l01625"></a>01625 {
<a name="l01626"></a>01626   <a class="code" href="gdbarch_8c.html#a7583cf6ebd6f4484dec544d7d1af38a1">gdbarch_register</a> (bfd_arch_nios2, nios2_gdbarch_init, NULL);
<a name="l01627"></a>01627   initialize_tdesc_nios2 ();
<a name="l01628"></a>01628 
<a name="l01629"></a>01629   <span class="comment">/* Allow debugging this file&#39;s internals.  */</span>
<a name="l01630"></a>01630   <a class="code" href="cli-decode_8c.html#ad86a0f135b6c546ae7ffbb41fd72e14f">add_setshow_boolean_cmd</a> (<span class="stringliteral">&quot;nios2&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a502c7b57c7172ac88ef735f68070bb59">class_maintenance</a>, &amp;nios2_debug,
<a name="l01631"></a>01631                            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Set Nios II debugging.&quot;</span>),
<a name="l01632"></a>01632                            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Show Nios II debugging.&quot;</span>),
<a name="l01633"></a>01633                            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;When on, Nios II specific debugging is enabled.&quot;</span>),
<a name="l01634"></a>01634                            NULL,
<a name="l01635"></a>01635                            NULL,
<a name="l01636"></a>01636                            &amp;<a class="code" href="cli-cmds_8c.html#ae5f16c782e4a29124f3175f4a6285244">setdebuglist</a>, &amp;<a class="code" href="cli-cmds_8c.html#a7e2eed475764f70df1e9c0f5d2476a11">showdebuglist</a>);
<a name="l01637"></a>01637 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:12:21 for GDB (API) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
