<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (API): /home/stan/gdb/src/gdb/target.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (API)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/target.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="target_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Interface between GDB and target environments, including files and processes</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 1990-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   Contributed by Cygnus Support.  Written by John Gilmore.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This file is part of GDB.</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00010"></a>00010 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00011"></a>00011 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00012"></a>00012 <span class="comment">   (at your option) any later version.</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00015"></a>00015 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00016"></a>00016 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00017"></a>00017 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00020"></a>00020 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#if !defined (TARGET_H)</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#define TARGET_H</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span>
<a name="l00025"></a>00025 <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a>;
<a name="l00026"></a>00026 <span class="keyword">struct </span>ui_file;
<a name="l00027"></a>00027 <span class="keyword">struct </span><a class="code" href="structmem__attrib.html">mem_attrib</a>;
<a name="l00028"></a>00028 <span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a>;
<a name="l00029"></a>00029 <span class="keyword">struct </span><a class="code" href="structbp__location.html">bp_location</a>;
<a name="l00030"></a>00030 <span class="keyword">struct </span><a class="code" href="structbp__target__info.html">bp_target_info</a>;
<a name="l00031"></a>00031 <span class="keyword">struct </span>regcache;
<a name="l00032"></a>00032 <span class="keyword">struct </span><a class="code" href="structtarget__section__table.html">target_section_table</a>;
<a name="l00033"></a>00033 <span class="keyword">struct </span><a class="code" href="structtrace__state__variable.html">trace_state_variable</a>;
<a name="l00034"></a>00034 <span class="keyword">struct </span><a class="code" href="structtrace__status.html">trace_status</a>;
<a name="l00035"></a>00035 <span class="keyword">struct </span><a class="code" href="structuploaded__tsv.html">uploaded_tsv</a>;
<a name="l00036"></a>00036 <span class="keyword">struct </span><a class="code" href="structuploaded__tp.html">uploaded_tp</a>;
<a name="l00037"></a>00037 <span class="keyword">struct </span><a class="code" href="structstatic__tracepoint__marker.html">static_tracepoint_marker</a>;
<a name="l00038"></a>00038 <span class="keyword">struct </span><a class="code" href="structtraceframe__info.html">traceframe_info</a>;
<a name="l00039"></a>00039 <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a>;
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="comment">/* This include file defines the interface between the main part</span>
<a name="l00042"></a>00042 <span class="comment">   of the debugger, and the part which is target-specific, or</span>
<a name="l00043"></a>00043 <span class="comment">   specific to the communications interface between us and the</span>
<a name="l00044"></a>00044 <span class="comment">   target.</span>
<a name="l00045"></a>00045 <span class="comment"></span>
<a name="l00046"></a>00046 <span class="comment">   A TARGET is an interface between the debugger and a particular</span>
<a name="l00047"></a>00047 <span class="comment">   kind of file or process.  Targets can be STACKED in STRATA,</span>
<a name="l00048"></a>00048 <span class="comment">   so that more than one target can potentially respond to a request.</span>
<a name="l00049"></a>00049 <span class="comment">   In particular, memory accesses will walk down the stack of targets</span>
<a name="l00050"></a>00050 <span class="comment">   until they find a target that is interested in handling that particular</span>
<a name="l00051"></a>00051 <span class="comment">   address.  STRATA are artificial boundaries on the stack, within</span>
<a name="l00052"></a>00052 <span class="comment">   which particular kinds of targets live.  Strata exist so that</span>
<a name="l00053"></a>00053 <span class="comment">   people don&#39;t get confused by pushing e.g. a process target and then</span>
<a name="l00054"></a>00054 <span class="comment">   a file target, and wondering why they can&#39;t see the current values</span>
<a name="l00055"></a>00055 <span class="comment">   of variables any more (the file target is handling them and they</span>
<a name="l00056"></a>00056 <span class="comment">   never get to the process target).  So when you push a file target,</span>
<a name="l00057"></a>00057 <span class="comment">   it goes into the file stratum, which is always below the process</span>
<a name="l00058"></a>00058 <span class="comment">   stratum.  */</span>
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="preprocessor">#include &quot;<a class="code" href="resume_8h.html">target/resume.h</a>&quot;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &quot;<a class="code" href="wait_8h.html">target/wait.h</a>&quot;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &quot;<a class="code" href="waitstatus_8h.html">target/waitstatus.h</a>&quot;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &quot;bfd.h&quot;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &quot;<a class="code" href="memattr_8h.html">memattr.h</a>&quot;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &quot;<a class="code" href="vec_8h.html">vec.h</a>&quot;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &quot;<a class="code" href="gdb__signals_8h.html">gdb_signals.h</a>&quot;</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &quot;<a class="code" href="btrace_8h.html">btrace.h</a>&quot;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &quot;<a class="code" href="command_8h.html">command.h</a>&quot;</span>
<a name="l00070"></a>00070 
<a name="l00071"></a><a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00">00071</a> <span class="keyword">enum</span> <a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00">strata</a>
<a name="l00072"></a>00072   {
<a name="l00073"></a><a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00ab09c2369cad853395aca887dfbe4c1ed">00073</a>     <a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00ab09c2369cad853395aca887dfbe4c1ed">dummy_stratum</a>,              <span class="comment">/* The lowest of the low */</span>
<a name="l00074"></a><a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00a1a5df386f026b924290fe4f78348b610">00074</a>     <a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00a1a5df386f026b924290fe4f78348b610">file_stratum</a>,               <span class="comment">/* Executable files, etc */</span>
<a name="l00075"></a><a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00a4178bf9e6b076f5d0e36cc5727f9e168">00075</a>     <a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00a4178bf9e6b076f5d0e36cc5727f9e168">process_stratum</a>,            <span class="comment">/* Executing processes or core dump files */</span>
<a name="l00076"></a><a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00acb67d325de9eee5f1a42ffc81d9efedf">00076</a>     <a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00acb67d325de9eee5f1a42ffc81d9efedf">thread_stratum</a>,             <span class="comment">/* Executing threads */</span>
<a name="l00077"></a><a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00a4c0a809adb05f4b46657965e4e596458">00077</a>     <a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00a4c0a809adb05f4b46657965e4e596458">record_stratum</a>,             <span class="comment">/* Support record debugging */</span>
<a name="l00078"></a><a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00ad9452e2e5a34e1f55b343c6116cb7d88">00078</a>     <a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00ad9452e2e5a34e1f55b343c6116cb7d88">arch_stratum</a>                <span class="comment">/* Architecture overrides */</span>
<a name="l00079"></a>00079   };
<a name="l00080"></a>00080 
<a name="l00081"></a><a class="code" href="target_8h.html#ac23f2139b89f6319b6afa125b437bf79">00081</a> <span class="keyword">enum</span> <a class="code" href="target_8h.html#ac23f2139b89f6319b6afa125b437bf79">thread_control_capabilities</a>
<a name="l00082"></a>00082   {
<a name="l00083"></a><a class="code" href="target_8h.html#ac23f2139b89f6319b6afa125b437bf79a3ce32589cb27ce0d8a3aa9488bce7374">00083</a>     <a class="code" href="target_8h.html#ac23f2139b89f6319b6afa125b437bf79a3ce32589cb27ce0d8a3aa9488bce7374">tc_none</a> = 0,                <span class="comment">/* Default: can&#39;t control thread execution.  */</span>
<a name="l00084"></a><a class="code" href="target_8h.html#ac23f2139b89f6319b6afa125b437bf79a1b420215532dd7eb22a269c35e569d58">00084</a>     <a class="code" href="target_8h.html#ac23f2139b89f6319b6afa125b437bf79a1b420215532dd7eb22a269c35e569d58">tc_schedlock</a> = 1,           <span class="comment">/* Can lock the thread scheduler.  */</span>
<a name="l00085"></a>00085   };
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="comment">/* The structure below stores information about a system call.</span>
<a name="l00088"></a>00088 <span class="comment">   It is basically used in the &quot;catch syscall&quot; command, and in</span>
<a name="l00089"></a>00089 <span class="comment">   every function that gives information about a system call.</span>
<a name="l00090"></a>00090 <span class="comment">   </span>
<a name="l00091"></a>00091 <span class="comment">   It&#39;s also good to mention that its fields represent everything</span>
<a name="l00092"></a>00092 <span class="comment">   that we currently know about a syscall in GDB.  */</span>
<a name="l00093"></a><a class="code" href="structsyscall.html">00093</a> <span class="keyword">struct </span><a class="code" href="structsyscall.html">syscall</a>
<a name="l00094"></a>00094   {
<a name="l00095"></a>00095     <span class="comment">/* The syscall number.  */</span>
<a name="l00096"></a><a class="code" href="structsyscall.html#a7feaf365d46c934f4fcc90e7f242b8a6">00096</a>     <span class="keywordtype">int</span> <a class="code" href="structsyscall.html#a7feaf365d46c934f4fcc90e7f242b8a6">number</a>;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098     <span class="comment">/* The syscall name.  */</span>
<a name="l00099"></a><a class="code" href="structsyscall.html#a09163a3feed03345a4e2e1c581f80d17">00099</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structsyscall.html#a09163a3feed03345a4e2e1c581f80d17">name</a>;
<a name="l00100"></a>00100   };
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="comment">/* Return a pretty printed form of target_waitstatus.</span>
<a name="l00103"></a>00103 <span class="comment">   Space for the result is malloc&#39;d, caller must free.  */</span>
<a name="l00104"></a>00104 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="waitstatus_8c.html#a0000ec5bea29996cd969e951c7e91422">target_waitstatus_to_string</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtarget__waitstatus.html">target_waitstatus</a> *);
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="comment">/* Return a pretty printed form of TARGET_OPTIONS.</span>
<a name="l00107"></a>00107 <span class="comment">   Space for the result is malloc&#39;d, caller must free.  */</span>
<a name="l00108"></a>00108 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="target_8c.html#ab3fe71eed1dec0f3af342a27a1377de7">target_options_to_string</a> (<span class="keywordtype">int</span> target_options);
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="comment">/* Possible types of events that the inferior handler will have to</span>
<a name="l00111"></a>00111 <span class="comment">   deal with.  */</span>
<a name="l00112"></a><a class="code" href="target_8h.html#a1eebd9e5ab38f563a98578b0e6e47068">00112</a> <span class="keyword">enum</span> <a class="code" href="target_8h.html#a1eebd9e5ab38f563a98578b0e6e47068">inferior_event_type</a>
<a name="l00113"></a>00113   {
<a name="l00114"></a>00114     <span class="comment">/* Process a normal inferior event which will result in target_wait</span>
<a name="l00115"></a>00115 <span class="comment">       being called.  */</span>
<a name="l00116"></a><a class="code" href="target_8h.html#a1eebd9e5ab38f563a98578b0e6e47068a61da0eae8584aa6c43317748a38becbd">00116</a>     <a class="code" href="target_8h.html#a1eebd9e5ab38f563a98578b0e6e47068a61da0eae8584aa6c43317748a38becbd">INF_REG_EVENT</a>,
<a name="l00117"></a>00117     <span class="comment">/* We are called because a timer went off.  */</span>
<a name="l00118"></a><a class="code" href="target_8h.html#a1eebd9e5ab38f563a98578b0e6e47068a39b89682ab7dde98d87f1420624d4192">00118</a>     <a class="code" href="target_8h.html#a1eebd9e5ab38f563a98578b0e6e47068a39b89682ab7dde98d87f1420624d4192">INF_TIMER</a>,
<a name="l00119"></a>00119     <span class="comment">/* We are called to do stuff after the inferior stops.  */</span>
<a name="l00120"></a><a class="code" href="target_8h.html#a1eebd9e5ab38f563a98578b0e6e47068a9fab7de152cd1880be5c3c5ddf3e7aed">00120</a>     <a class="code" href="target_8h.html#a1eebd9e5ab38f563a98578b0e6e47068a9fab7de152cd1880be5c3c5ddf3e7aed">INF_EXEC_COMPLETE</a>,
<a name="l00121"></a>00121     <span class="comment">/* We are called to do some stuff after the inferior stops, but we</span>
<a name="l00122"></a>00122 <span class="comment">       are expected to reenter the proceed() and</span>
<a name="l00123"></a>00123 <span class="comment">       handle_inferior_event() functions.  This is used only in case of</span>
<a name="l00124"></a>00124 <span class="comment">       &#39;step n&#39; like commands.  */</span>
<a name="l00125"></a><a class="code" href="target_8h.html#a1eebd9e5ab38f563a98578b0e6e47068a5fe60a8ffde43008b31d286b136cbac4">00125</a>     <a class="code" href="target_8h.html#a1eebd9e5ab38f563a98578b0e6e47068a5fe60a8ffde43008b31d286b136cbac4">INF_EXEC_CONTINUE</a>
<a name="l00126"></a>00126   };
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 <span class="comment">/* Target objects which can be transfered using target_read,</span>
<a name="l00129"></a>00129 <span class="comment">   target_write, et cetera.  */</span>
<a name="l00130"></a>00130 
<a name="l00131"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2">00131</a> <span class="keyword">enum</span> <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2">target_object</a>
<a name="l00132"></a>00132 {
<a name="l00133"></a>00133   <span class="comment">/* AVR target specific transfer.  See &quot;avr-tdep.c&quot; and &quot;remote.c&quot;.  */</span>
<a name="l00134"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a074051087c9979ebe807137f66a84445">00134</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a074051087c9979ebe807137f66a84445">TARGET_OBJECT_AVR</a>,
<a name="l00135"></a>00135   <span class="comment">/* SPU target specific transfer.  See &quot;spu-tdep.c&quot;.  */</span>
<a name="l00136"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a09790d59558546bb5ab8aa15ae6fbc74">00136</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a09790d59558546bb5ab8aa15ae6fbc74">TARGET_OBJECT_SPU</a>,
<a name="l00137"></a>00137   <span class="comment">/* Transfer up-to LEN bytes of memory starting at OFFSET.  */</span>
<a name="l00138"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a8d0adeab7f35c7245692a63b5a2a9f3a">00138</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a8d0adeab7f35c7245692a63b5a2a9f3a">TARGET_OBJECT_MEMORY</a>,
<a name="l00139"></a>00139   <span class="comment">/* Memory, avoiding GDB&#39;s data cache and trusting the executable.</span>
<a name="l00140"></a>00140 <span class="comment">     Target implementations of to_xfer_partial never need to handle</span>
<a name="l00141"></a>00141 <span class="comment">     this object, and most callers should not use it.  */</span>
<a name="l00142"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a4b37c4e8ea759f020f04e2b5ef32fd75">00142</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a4b37c4e8ea759f020f04e2b5ef32fd75">TARGET_OBJECT_RAW_MEMORY</a>,
<a name="l00143"></a>00143   <span class="comment">/* Memory known to be part of the target&#39;s stack.  This is cached even</span>
<a name="l00144"></a>00144 <span class="comment">     if it is not in a region marked as such, since it is known to be</span>
<a name="l00145"></a>00145 <span class="comment">     &quot;normal&quot; RAM.  */</span>
<a name="l00146"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a678c98ce7055522557e83cd7cf39e626">00146</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a678c98ce7055522557e83cd7cf39e626">TARGET_OBJECT_STACK_MEMORY</a>,
<a name="l00147"></a>00147   <span class="comment">/* Kernel Unwind Table.  See &quot;ia64-tdep.c&quot;.  */</span>
<a name="l00148"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a0e67a00d86f5ebc7b3a0cd02c5cd0066">00148</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a0e67a00d86f5ebc7b3a0cd02c5cd0066">TARGET_OBJECT_UNWIND_TABLE</a>,
<a name="l00149"></a>00149   <span class="comment">/* Transfer auxilliary vector.  */</span>
<a name="l00150"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a5d6f5f222b30d70fed32596fb55d50b1">00150</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a5d6f5f222b30d70fed32596fb55d50b1">TARGET_OBJECT_AUXV</a>,
<a name="l00151"></a>00151   <span class="comment">/* StackGhost cookie.  See &quot;sparc-tdep.c&quot;.  */</span>
<a name="l00152"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2aea9a8dfd0ece8c4bfa9ffd3e2c1354eb">00152</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2aea9a8dfd0ece8c4bfa9ffd3e2c1354eb">TARGET_OBJECT_WCOOKIE</a>,
<a name="l00153"></a>00153   <span class="comment">/* Target memory map in XML format.  */</span>
<a name="l00154"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2ada7c6f3ac762aa35058bc6c6336eb62a">00154</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2ada7c6f3ac762aa35058bc6c6336eb62a">TARGET_OBJECT_MEMORY_MAP</a>,
<a name="l00155"></a>00155   <span class="comment">/* Flash memory.  This object can be used to write contents to</span>
<a name="l00156"></a>00156 <span class="comment">     a previously erased flash memory.  Using it without erasing</span>
<a name="l00157"></a>00157 <span class="comment">     flash can have unexpected results.  Addresses are physical</span>
<a name="l00158"></a>00158 <span class="comment">     address on target, and not relative to flash start.  */</span>
<a name="l00159"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2af1a8dae7dad4ec96655a926c25e10dfc">00159</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2af1a8dae7dad4ec96655a926c25e10dfc">TARGET_OBJECT_FLASH</a>,
<a name="l00160"></a>00160   <span class="comment">/* Available target-specific features, e.g. registers and coprocessors.</span>
<a name="l00161"></a>00161 <span class="comment">     See &quot;target-descriptions.c&quot;.  ANNEX should never be empty.  */</span>
<a name="l00162"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a0e99b8263bb68b067cf52786a81e8864">00162</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a0e99b8263bb68b067cf52786a81e8864">TARGET_OBJECT_AVAILABLE_FEATURES</a>,
<a name="l00163"></a>00163   <span class="comment">/* Currently loaded libraries, in XML format.  */</span>
<a name="l00164"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2aeda253a3a433b111ffaed11d0f4cce63">00164</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2aeda253a3a433b111ffaed11d0f4cce63">TARGET_OBJECT_LIBRARIES</a>,
<a name="l00165"></a>00165   <span class="comment">/* Currently loaded libraries specific for SVR4 systems, in XML format.  */</span>
<a name="l00166"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a18dae2618436e1cfde3f481242776ae8">00166</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a18dae2618436e1cfde3f481242776ae8">TARGET_OBJECT_LIBRARIES_SVR4</a>,
<a name="l00167"></a>00167   <span class="comment">/* Currently loaded libraries specific to AIX systems, in XML format.  */</span>
<a name="l00168"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a34f9e1a1d948f66722c62985e17b9708">00168</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a34f9e1a1d948f66722c62985e17b9708">TARGET_OBJECT_LIBRARIES_AIX</a>,
<a name="l00169"></a>00169   <span class="comment">/* Get OS specific data.  The ANNEX specifies the type (running</span>
<a name="l00170"></a>00170 <span class="comment">     processes, etc.).  The data being transfered is expected to follow</span>
<a name="l00171"></a>00171 <span class="comment">     the DTD specified in features/osdata.dtd.  */</span>
<a name="l00172"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a77583420c84bd24371318ac58005bf0c">00172</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a77583420c84bd24371318ac58005bf0c">TARGET_OBJECT_OSDATA</a>,
<a name="l00173"></a>00173   <span class="comment">/* Extra signal info.  Usually the contents of `siginfo_t&#39; on unix</span>
<a name="l00174"></a>00174 <span class="comment">     platforms.  */</span>
<a name="l00175"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a85236f062c989bf492b43cdbf80347b7">00175</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a85236f062c989bf492b43cdbf80347b7">TARGET_OBJECT_SIGNAL_INFO</a>,
<a name="l00176"></a>00176   <span class="comment">/* The list of threads that are being debugged.  */</span>
<a name="l00177"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a0cd4044551038d2f56f68c9f2d6e8759">00177</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a0cd4044551038d2f56f68c9f2d6e8759">TARGET_OBJECT_THREADS</a>,
<a name="l00178"></a>00178   <span class="comment">/* Collected static trace data.  */</span>
<a name="l00179"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2af9172e2048fe0b4903136ca6168fb8c9">00179</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2af9172e2048fe0b4903136ca6168fb8c9">TARGET_OBJECT_STATIC_TRACE_DATA</a>,
<a name="l00180"></a>00180   <span class="comment">/* The HP-UX registers (those that can be obtained or modified by using</span>
<a name="l00181"></a>00181 <span class="comment">     the TT_LWP_RUREGS/TT_LWP_WUREGS ttrace requests).  */</span>
<a name="l00182"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2aefadf9c3188ed69eff50fe2bdcf7319a">00182</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2aefadf9c3188ed69eff50fe2bdcf7319a">TARGET_OBJECT_HPUX_UREGS</a>,
<a name="l00183"></a>00183   <span class="comment">/* The HP-UX shared library linkage pointer.  ANNEX should be a string</span>
<a name="l00184"></a>00184 <span class="comment">     image of the code address whose linkage pointer we are looking for.</span>
<a name="l00185"></a>00185 <span class="comment"></span>
<a name="l00186"></a>00186 <span class="comment">     The size of the data transfered is always 8 bytes (the size of an</span>
<a name="l00187"></a>00187 <span class="comment">     address on ia64).  */</span>
<a name="l00188"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a8ae06829f2476b1c13731df6b3a4277c">00188</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a8ae06829f2476b1c13731df6b3a4277c">TARGET_OBJECT_HPUX_SOLIB_GOT</a>,
<a name="l00189"></a>00189   <span class="comment">/* Traceframe info, in XML format.  */</span>
<a name="l00190"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a47d333e4324307f7ca008b3d9c9aa6f6">00190</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a47d333e4324307f7ca008b3d9c9aa6f6">TARGET_OBJECT_TRACEFRAME_INFO</a>,
<a name="l00191"></a>00191   <span class="comment">/* Load maps for FDPIC systems.  */</span>
<a name="l00192"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a16607b4c1ed21874451c1da297b496bd">00192</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a16607b4c1ed21874451c1da297b496bd">TARGET_OBJECT_FDPIC</a>,
<a name="l00193"></a>00193   <span class="comment">/* Darwin dynamic linker info data.  */</span>
<a name="l00194"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a5580e4588308b421cf85eeca736be443">00194</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a5580e4588308b421cf85eeca736be443">TARGET_OBJECT_DARWIN_DYLD_INFO</a>,
<a name="l00195"></a>00195   <span class="comment">/* OpenVMS Unwind Information Block.  */</span>
<a name="l00196"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a86f6c954b7b49c8f7887f6b1b04a4871">00196</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a86f6c954b7b49c8f7887f6b1b04a4871">TARGET_OBJECT_OPENVMS_UIB</a>,
<a name="l00197"></a>00197   <span class="comment">/* Branch trace data, in XML format.  */</span>
<a name="l00198"></a><a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a16915a77591f192dae2f0d4116bc79c1">00198</a>   <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2a16915a77591f192dae2f0d4116bc79c1">TARGET_OBJECT_BTRACE</a>
<a name="l00199"></a>00199   <span class="comment">/* Possible future objects: TARGET_OBJECT_FILE, ...  */</span>
<a name="l00200"></a>00200 };
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 <span class="comment">/* Possible error codes returned by target_xfer_partial, etc.  */</span>
<a name="l00203"></a>00203 
<a name="l00204"></a><a class="code" href="target_8h.html#abb2b4914eed57f72aa554a606ec7a6a8">00204</a> <span class="keyword">enum</span> <a class="code" href="target_8h.html#abb2b4914eed57f72aa554a606ec7a6a8">target_xfer_error</a>
<a name="l00205"></a>00205 {
<a name="l00206"></a>00206   <span class="comment">/* Generic I/O error.  Note that it&#39;s important that this is &#39;-1&#39;,</span>
<a name="l00207"></a>00207 <span class="comment">     as we still have target_xfer-related code returning hardcoded</span>
<a name="l00208"></a>00208 <span class="comment">     &#39;-1&#39; on error.  */</span>
<a name="l00209"></a><a class="code" href="target_8h.html#abb2b4914eed57f72aa554a606ec7a6a8a0acd1eebf730af465bb2f90e781420a8">00209</a>   <a class="code" href="target_8h.html#abb2b4914eed57f72aa554a606ec7a6a8a0acd1eebf730af465bb2f90e781420a8">TARGET_XFER_E_IO</a> = -1,
<a name="l00210"></a>00210 
<a name="l00211"></a>00211   <span class="comment">/* Transfer failed because the piece of the object requested is</span>
<a name="l00212"></a>00212 <span class="comment">     unavailable.  */</span>
<a name="l00213"></a><a class="code" href="target_8h.html#abb2b4914eed57f72aa554a606ec7a6a8a2beea0572197b8fadfdb566f23fad6fb">00213</a>   <a class="code" href="target_8h.html#abb2b4914eed57f72aa554a606ec7a6a8a2beea0572197b8fadfdb566f23fad6fb">TARGET_XFER_E_UNAVAILABLE</a> = -2,
<a name="l00214"></a>00214 
<a name="l00215"></a>00215   <span class="comment">/* Keep list in sync with target_xfer_error_to_string.  */</span>
<a name="l00216"></a>00216 };
<a name="l00217"></a>00217 
<a name="l00218"></a>00218 <span class="comment">/* Return the string form of ERR.  */</span>
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="target_8c.html#abe77f289737b826c6c3965de6b804cbf">target_xfer_error_to_string</a> (<span class="keyword">enum</span> <a class="code" href="target_8h.html#abb2b4914eed57f72aa554a606ec7a6a8">target_xfer_error</a> err);
<a name="l00221"></a>00221 
<a name="l00222"></a>00222 <span class="comment">/* Enumeration of the kinds of traceframe searches that a target may</span>
<a name="l00223"></a>00223 <span class="comment">   be able to perform.  */</span>
<a name="l00224"></a>00224 
<a name="l00225"></a><a class="code" href="target_8h.html#a78f5afcdc128cdd336383668a0f296d7">00225</a> <span class="keyword">enum</span> <a class="code" href="target_8h.html#a78f5afcdc128cdd336383668a0f296d7">trace_find_type</a>
<a name="l00226"></a>00226   {
<a name="l00227"></a><a class="code" href="target_8h.html#a78f5afcdc128cdd336383668a0f296d7a6c059c3daad01c8165dc1a73498408e7">00227</a>     <a class="code" href="target_8h.html#a78f5afcdc128cdd336383668a0f296d7a6c059c3daad01c8165dc1a73498408e7">tfind_number</a>,
<a name="l00228"></a><a class="code" href="target_8h.html#a78f5afcdc128cdd336383668a0f296d7a4bb077c323c7395699b412e2c73b9855">00228</a>     <a class="code" href="target_8h.html#a78f5afcdc128cdd336383668a0f296d7a4bb077c323c7395699b412e2c73b9855">tfind_pc</a>,
<a name="l00229"></a><a class="code" href="target_8h.html#a78f5afcdc128cdd336383668a0f296d7adec7c45210c9adaf5b4bff37cf713de2">00229</a>     <a class="code" href="target_8h.html#a78f5afcdc128cdd336383668a0f296d7adec7c45210c9adaf5b4bff37cf713de2">tfind_tp</a>,
<a name="l00230"></a><a class="code" href="target_8h.html#a78f5afcdc128cdd336383668a0f296d7a8bb5fb54065004f1abad4a8278288c6d">00230</a>     <a class="code" href="target_8h.html#a78f5afcdc128cdd336383668a0f296d7a8bb5fb54065004f1abad4a8278288c6d">tfind_range</a>,
<a name="l00231"></a><a class="code" href="target_8h.html#a78f5afcdc128cdd336383668a0f296d7a173984a815b231ae8aff2e0d5c3374d2">00231</a>     <a class="code" href="target_8h.html#a78f5afcdc128cdd336383668a0f296d7a173984a815b231ae8aff2e0d5c3374d2">tfind_outside</a>,
<a name="l00232"></a>00232   };
<a name="l00233"></a>00233 
<a name="l00234"></a><a class="code" href="target_8h.html#a2c45ecd5a27f2d9de44dcf667c620392">00234</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structstatic__tracepoint__marker.html">static_tracepoint_marker</a> *<a class="code" href="target_8h.html#a2c45ecd5a27f2d9de44dcf667c620392">static_tracepoint_marker_p</a>;
<a name="l00235"></a>00235 <a class="code" href="vec_8h.html#af9d77557e51db07808428f28a3559803">DEF_VEC_P</a>(static_tracepoint_marker_p);
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 <span class="comment">/* Request that OPS transfer up to LEN 8-bit bytes of the target&#39;s</span>
<a name="l00238"></a>00238 <span class="comment">   OBJECT.  The OFFSET, for a seekable object, specifies the</span>
<a name="l00239"></a>00239 <span class="comment">   starting point.  The ANNEX can be used to provide additional</span>
<a name="l00240"></a>00240 <span class="comment">   data-specific information to the target.</span>
<a name="l00241"></a>00241 <span class="comment"></span>
<a name="l00242"></a>00242 <span class="comment">   Return the number of bytes actually transfered, or a negative error</span>
<a name="l00243"></a>00243 <span class="comment">   code (an &#39;enum target_xfer_error&#39; value) if the transfer is not</span>
<a name="l00244"></a>00244 <span class="comment">   supported or otherwise fails.  Return of a positive value less than</span>
<a name="l00245"></a>00245 <span class="comment">   LEN indicates that no further transfer is possible.  Unlike the raw</span>
<a name="l00246"></a>00246 <span class="comment">   to_xfer_partial interface, callers of these functions do not need</span>
<a name="l00247"></a>00247 <span class="comment">   to retry partial transfers.  */</span>
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="target_8c.html#aac7df8f3a1d061c97c45219ed0cace6c">target_read</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l00250"></a>00250                             <span class="keyword">enum</span> <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2">target_object</a> <span class="keywordtype">object</span>,
<a name="l00251"></a>00251                             <span class="keyword">const</span> <span class="keywordtype">char</span> *annex, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf,
<a name="l00252"></a>00252                             <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>);
<a name="l00253"></a>00253 
<a name="l00254"></a><a class="code" href="structmemory__read__result.html">00254</a> <span class="keyword">struct </span><a class="code" href="structmemory__read__result.html">memory_read_result</a>
<a name="l00255"></a>00255   {
<a name="l00256"></a>00256     <span class="comment">/* First address that was read.  */</span>
<a name="l00257"></a><a class="code" href="structmemory__read__result.html#adadeb5f2f283c5c1ab5aa2bcf4939009">00257</a>     <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structmemory__read__result.html#adadeb5f2f283c5c1ab5aa2bcf4939009">begin</a>;
<a name="l00258"></a>00258     <span class="comment">/* Past-the-end address.  */</span>
<a name="l00259"></a><a class="code" href="structmemory__read__result.html#aafabc84f972ba2ade634094f25f4f87a">00259</a>     <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structmemory__read__result.html#aafabc84f972ba2ade634094f25f4f87a">end</a>;
<a name="l00260"></a>00260     <span class="comment">/* The data.  */</span>
<a name="l00261"></a><a class="code" href="structmemory__read__result.html#ae5a522187d5a2adc2adfefec0a0e2220">00261</a>     <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structmemory__read__result.html#ae5a522187d5a2adc2adfefec0a0e2220">data</a>;
<a name="l00262"></a>00262 };
<a name="l00263"></a><a class="code" href="target_8h.html#a6510e75201b8a1d1adc1911961ce1430">00263</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structmemory__read__result.html">memory_read_result</a> <a class="code" href="structmemory__read__result.html">memory_read_result_s</a>;
<a name="l00264"></a>00264 <a class="code" href="vec_8h.html#abc2d38563a8b5bed340654cf06060f11">DEF_VEC_O</a>(<a class="code" href="structmemory__read__result.html">memory_read_result_s</a>);
<a name="l00265"></a>00265 
<a name="l00266"></a>00266 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#ace14b59a83987779313984dadc7b781a">free_memory_read_result_vector</a> (<span class="keywordtype">void</span> *);
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 <span class="keyword">extern</span> <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a>(<a class="code" href="structmemory__read__result.html">memory_read_result_s</a>)* read_memory_robust (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l00269"></a><a class="code" href="target_8h.html#abc831d189f7669eeb2bbf8a202146a3d">00269</a>                                                       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>,
<a name="l00270"></a>00270                                                       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>);
<a name="l00271"></a>00271   
<a name="l00272"></a>00272 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="target_8c.html#ad865b9b4803919e5eae9df26437e0a59">target_write</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l00273"></a>00273                              <span class="keyword">enum</span> <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2">target_object</a> <span class="keywordtype">object</span>,
<a name="l00274"></a>00274                              <span class="keyword">const</span> <span class="keywordtype">char</span> *annex, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf,
<a name="l00275"></a>00275                              <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="comment">/* Similar to target_write, except that it also calls PROGRESS with</span>
<a name="l00278"></a>00278 <span class="comment">   the number of bytes written and the opaque BATON after every</span>
<a name="l00279"></a>00279 <span class="comment">   successful partial write (and before the first write).  This is</span>
<a name="l00280"></a>00280 <span class="comment">   useful for progress reporting and user interaction while writing</span>
<a name="l00281"></a>00281 <span class="comment">   data.  To abort the transfer, the progress callback can throw an</span>
<a name="l00282"></a>00282 <span class="comment">   exception.  */</span>
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="target_8c.html#ac10bfb9ded19b1ebd6f0d6ce8f719d8d">target_write_with_progress</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l00285"></a>00285                                     <span class="keyword">enum</span> <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2">target_object</a> <span class="keywordtype">object</span>,
<a name="l00286"></a>00286                                     <span class="keyword">const</span> <span class="keywordtype">char</span> *annex, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf,
<a name="l00287"></a>00287                                     <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>,
<a name="l00288"></a>00288                                     <span class="keywordtype">void</span> (*progress) (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a>, <span class="keywordtype">void</span> *),
<a name="l00289"></a>00289                                     <span class="keywordtype">void</span> *baton);
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 <span class="comment">/* Wrapper to perform a full read of unknown size.  OBJECT/ANNEX will</span>
<a name="l00292"></a>00292 <span class="comment">   be read using OPS.  The return value will be -1 if the transfer</span>
<a name="l00293"></a>00293 <span class="comment">   fails or is not supported; 0 if the object is empty; or the length</span>
<a name="l00294"></a>00294 <span class="comment">   of the object otherwise.  If a positive value is returned, a</span>
<a name="l00295"></a>00295 <span class="comment">   sufficiently large buffer will be allocated using xmalloc and</span>
<a name="l00296"></a>00296 <span class="comment">   returned in *BUF_P containing the contents of the object.</span>
<a name="l00297"></a>00297 <span class="comment"></span>
<a name="l00298"></a>00298 <span class="comment">   This method should be used for objects sufficiently small to store</span>
<a name="l00299"></a>00299 <span class="comment">   in a single xmalloc&#39;d buffer, when no fixed bound on the object&#39;s</span>
<a name="l00300"></a>00300 <span class="comment">   size is known in advance.  Don&#39;t try to read TARGET_OBJECT_MEMORY</span>
<a name="l00301"></a>00301 <span class="comment">   through this function.  */</span>
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="target_8c.html#a3fa3cddea970cd3b7fb5a5ecfb62eeac">target_read_alloc</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l00304"></a>00304                                   <span class="keyword">enum</span> <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2">target_object</a> <span class="keywordtype">object</span>,
<a name="l00305"></a>00305                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *annex, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **buf_p);
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 <span class="comment">/* Read OBJECT/ANNEX using OPS.  The result is NUL-terminated and</span>
<a name="l00308"></a>00308 <span class="comment">   returned as a string, allocated using xmalloc.  If an error occurs</span>
<a name="l00309"></a>00309 <span class="comment">   or the transfer is unsupported, NULL is returned.  Empty objects</span>
<a name="l00310"></a>00310 <span class="comment">   are returned as allocated but empty strings.  A warning is issued</span>
<a name="l00311"></a>00311 <span class="comment">   if the result contains any embedded NUL bytes.  */</span>
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="target_8c.html#abfac713fcdac24bd007fed0ebf82907d">target_read_stralloc</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l00314"></a>00314                                    <span class="keyword">enum</span> <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2">target_object</a> <span class="keywordtype">object</span>,
<a name="l00315"></a>00315                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *annex);
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 <span class="comment">/* See target_ops-&gt;to_xfer_partial.  */</span>
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="target_8c.html#ad1642053eb28e339b8d9e24fbead9335">target_xfer_partial</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l00320"></a>00320                                     <span class="keyword">enum</span> <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2">target_object</a> <span class="keywordtype">object</span>,
<a name="l00321"></a>00321                                     <span class="keyword">const</span> <span class="keywordtype">char</span> *annex,
<a name="l00322"></a>00322                                     <span class="keywordtype">void</span> *readbuf, <span class="keyword">const</span> <span class="keywordtype">void</span> *writebuf,
<a name="l00323"></a>00323                                     <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> offset, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> len);
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="comment">/* Wrappers to target read/write that perform memory transfers.  They</span>
<a name="l00326"></a>00326 <span class="comment">   throw an error if the memory transfer fails.</span>
<a name="l00327"></a>00327 <span class="comment"></span>
<a name="l00328"></a>00328 <span class="comment">   NOTE: cagney/2003-10-23: The naming schema is lifted from</span>
<a name="l00329"></a>00329 <span class="comment">   &quot;frame.h&quot;.  The parameter order is lifted from get_frame_memory,</span>
<a name="l00330"></a>00330 <span class="comment">   which in turn lifted it from read_memory.  */</span>
<a name="l00331"></a>00331 
<a name="l00332"></a>00332 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a169b3c9ca5779f3f684425587ae69523">get_target_memory</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr,
<a name="l00333"></a>00333                                <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> len);
<a name="l00334"></a>00334 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="target_8c.html#ad9dee5616617b3da92370f07fad92d54">get_target_memory_unsigned</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l00335"></a>00335                                             <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr, <span class="keywordtype">int</span> len,
<a name="l00336"></a>00336                                             <span class="keyword">enum</span> bfd_endian byte_order);
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="keyword">struct </span><a class="code" href="structthread__info.html">thread_info</a>;             <span class="comment">/* fwd decl for parameter list below: */</span>
<a name="l00339"></a>00339 
<a name="l00340"></a><a class="code" href="structtarget__ops.html">00340</a> <span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a>
<a name="l00341"></a>00341   {
<a name="l00342"></a><a class="code" href="structtarget__ops.html#a1b180ccb4db2afccf46e691862bf2ddf">00342</a>     <span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *<a class="code" href="structtarget__ops.html#a1b180ccb4db2afccf46e691862bf2ddf">beneath</a>; <span class="comment">/* To the target under this one.  */</span>
<a name="l00343"></a><a class="code" href="structtarget__ops.html#a9326c3129ee116786b1ca1a95713f125">00343</a>     <span class="keywordtype">char</span> *<a class="code" href="structtarget__ops.html#a9326c3129ee116786b1ca1a95713f125">to_shortname</a>;         <span class="comment">/* Name this target type */</span>
<a name="l00344"></a><a class="code" href="structtarget__ops.html#a184ee9aa071d32ec535cf7394aba0bd1">00344</a>     <span class="keywordtype">char</span> *<a class="code" href="structtarget__ops.html#a184ee9aa071d32ec535cf7394aba0bd1">to_longname</a>;          <span class="comment">/* Name for printing */</span>
<a name="l00345"></a><a class="code" href="structtarget__ops.html#a1b0c848329708688e3816263b16fe664">00345</a>     <span class="keywordtype">char</span> *<a class="code" href="structtarget__ops.html#a1b0c848329708688e3816263b16fe664">to_doc</a>;               <span class="comment">/* Documentation.  Does not include trailing</span>
<a name="l00346"></a>00346 <span class="comment">                                   newline, and starts with a one-line descrip-</span>
<a name="l00347"></a>00347 <span class="comment">                                   tion (probably similar to to_longname).  */</span>
<a name="l00348"></a>00348     <span class="comment">/* Per-target scratch pad.  */</span>
<a name="l00349"></a><a class="code" href="structtarget__ops.html#a32bf3ab27d8d91e1ff3bd222a09b4d64">00349</a>     <span class="keywordtype">void</span> *<a class="code" href="structtarget__ops.html#a32bf3ab27d8d91e1ff3bd222a09b4d64">to_data</a>;
<a name="l00350"></a>00350     <span class="comment">/* The open routine takes the rest of the parameters from the</span>
<a name="l00351"></a>00351 <span class="comment">       command, and (if successful) pushes a new target onto the</span>
<a name="l00352"></a>00352 <span class="comment">       stack.  Targets should supply this routine, if only to provide</span>
<a name="l00353"></a>00353 <span class="comment">       an error message.  */</span>
<a name="l00354"></a><a class="code" href="structtarget__ops.html#a5a0cfeca4b463ea49d8c2f5913a93eae">00354</a>     void (*<a class="code" href="structtarget__ops.html#a5a0cfeca4b463ea49d8c2f5913a93eae">to_open</a>) (<span class="keywordtype">char</span> *, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00355"></a>00355     <span class="comment">/* Old targets with a static target vector provide &quot;to_close&quot;.</span>
<a name="l00356"></a>00356 <span class="comment">       New re-entrant targets provide &quot;to_xclose&quot; and that is expected</span>
<a name="l00357"></a>00357 <span class="comment">       to xfree everything (including the &quot;struct target_ops&quot;).  */</span>
<a name="l00358"></a><a class="code" href="structtarget__ops.html#a59e283dbbf790f67942a1382e6777b6d">00358</a>     void (*<a class="code" href="structtarget__ops.html#a59e283dbbf790f67942a1382e6777b6d">to_xclose</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *targ);
<a name="l00359"></a><a class="code" href="structtarget__ops.html#a3a192fb4ed386bc561179111e53b5ccb">00359</a>     void (*<a class="code" href="structtarget__ops.html#a3a192fb4ed386bc561179111e53b5ccb">to_close</a>) (void);
<a name="l00360"></a><a class="code" href="structtarget__ops.html#a12f470dd0a49e7b2e57f6876fca97530">00360</a>     void (*<a class="code" href="structtarget__ops.html#a12f470dd0a49e7b2e57f6876fca97530">to_attach</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *ops, <span class="keywordtype">char</span> *, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00361"></a><a class="code" href="structtarget__ops.html#aa995f124d4363d2da51fe4f52816f06b">00361</a>     void (*<a class="code" href="structtarget__ops.html#aa995f124d4363d2da51fe4f52816f06b">to_post_attach</a>) (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00362"></a><a class="code" href="structtarget__ops.html#a2749c09156c21e635d6860af415b7a52">00362</a>     void (*<a class="code" href="structtarget__ops.html#a2749c09156c21e635d6860af415b7a52">to_detach</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *ops, <span class="keywordtype">char</span> *, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00363"></a><a class="code" href="structtarget__ops.html#a318d292f13de0a764ceebf110d1d7763">00363</a>     void (*<a class="code" href="structtarget__ops.html#a318d292f13de0a764ceebf110d1d7763">to_disconnect</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *, <span class="keywordtype">char</span> *, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00364"></a><a class="code" href="structtarget__ops.html#a969e77ba44f2d253e041d3b24dde8c87">00364</a>     void (*<a class="code" href="structtarget__ops.html#a969e77ba44f2d253e041d3b24dde8c87">to_resume</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *, <a class="code" href="ptid_8h.html#aafdcd92f9f083a6e3233884cb3cc0653">ptid_t</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <span class="keyword">enum</span> <a class="code" href="signals_8h.html#a1169a44d7b94bdcf747c3f69138dafe7">gdb_signal</a>);
<a name="l00365"></a><a class="code" href="structtarget__ops.html#ae8e22dbcc8522f0daac3fc8ed2661ca1">00365</a>     <a class="code" href="ptid_8h.html#aafdcd92f9f083a6e3233884cb3cc0653">ptid_t</a> (*<a class="code" href="structtarget__ops.html#ae8e22dbcc8522f0daac3fc8ed2661ca1">to_wait</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *,
<a name="l00366"></a>00366                        <a class="code" href="ptid_8h.html#aafdcd92f9f083a6e3233884cb3cc0653">ptid_t</a>, <span class="keyword">struct </span><a class="code" href="structtarget__waitstatus.html">target_waitstatus</a> *, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00367"></a><a class="code" href="structtarget__ops.html#a117d2a74c4c794d5b309b106a413ef10">00367</a>     void (*<a class="code" href="structtarget__ops.html#a117d2a74c4c794d5b309b106a413ef10">to_fetch_registers</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *, <span class="keyword">struct </span>regcache *, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00368"></a><a class="code" href="structtarget__ops.html#a755da40b533b1467a0583a5c8e91a400">00368</a>     void (*<a class="code" href="structtarget__ops.html#a755da40b533b1467a0583a5c8e91a400">to_store_registers</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *, <span class="keyword">struct </span>regcache *, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00369"></a><a class="code" href="structtarget__ops.html#abdb55efb6b0e0ad9c481f99da56b26a9">00369</a>     void (*<a class="code" href="structtarget__ops.html#abdb55efb6b0e0ad9c481f99da56b26a9">to_prepare_to_store</a>) (<span class="keyword">struct </span>regcache *);
<a name="l00370"></a>00370 
<a name="l00371"></a>00371     <span class="comment">/* Transfer LEN bytes of memory between GDB address MYADDR and</span>
<a name="l00372"></a>00372 <span class="comment">       target address MEMADDR.  If WRITE, transfer them to the target, else</span>
<a name="l00373"></a>00373 <span class="comment">       transfer them from the target.  TARGET is the target from which we</span>
<a name="l00374"></a>00374 <span class="comment">       get this function.</span>
<a name="l00375"></a>00375 <span class="comment"></span>
<a name="l00376"></a>00376 <span class="comment">       Return value, N, is one of the following:</span>
<a name="l00377"></a>00377 <span class="comment"></span>
<a name="l00378"></a>00378 <span class="comment">       0 means that we can&#39;t handle this.  If errno has been set, it is the</span>
<a name="l00379"></a>00379 <span class="comment">       error which prevented us from doing it (FIXME: What about bfd_error?).</span>
<a name="l00380"></a>00380 <span class="comment"></span>
<a name="l00381"></a>00381 <span class="comment">       positive (call it N) means that we have transferred N bytes</span>
<a name="l00382"></a>00382 <span class="comment">       starting at MEMADDR.  We might be able to handle more bytes</span>
<a name="l00383"></a>00383 <span class="comment">       beyond this length, but no promises.</span>
<a name="l00384"></a>00384 <span class="comment"></span>
<a name="l00385"></a>00385 <span class="comment">       negative (call its absolute value N) means that we cannot</span>
<a name="l00386"></a>00386 <span class="comment">       transfer right at MEMADDR, but we could transfer at least</span>
<a name="l00387"></a>00387 <span class="comment">       something at MEMADDR + N.</span>
<a name="l00388"></a>00388 <span class="comment"></span>
<a name="l00389"></a>00389 <span class="comment">       NOTE: cagney/2004-10-01: This has been entirely superseeded by</span>
<a name="l00390"></a>00390 <span class="comment">       to_xfer_partial and inferior inheritance.  */</span>
<a name="l00391"></a>00391 
<a name="l00392"></a><a class="code" href="structtarget__ops.html#a64b004350c177cdbdde9b311226f397b">00392</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a64b004350c177cdbdde9b311226f397b">deprecated_xfer_memory</a>) (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="exec_8h.html#ab268c3184bf49615e16de006a296a542">memaddr</a>, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *myaddr,
<a name="l00393"></a>00393                                    <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>, <span class="keywordtype">int</span> write,
<a name="l00394"></a>00394                                    <span class="keyword">struct </span><a class="code" href="structmem__attrib.html">mem_attrib</a> *attrib,
<a name="l00395"></a>00395                                    <span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *target);
<a name="l00396"></a>00396 
<a name="l00397"></a><a class="code" href="structtarget__ops.html#a2cb65189c2ab4edb8dbe4f18adcaaf78">00397</a>     void (*<a class="code" href="structtarget__ops.html#a2cb65189c2ab4edb8dbe4f18adcaaf78">to_files_info</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l00398"></a><a class="code" href="structtarget__ops.html#a5dc36c9743ec74fedbd285cbb4e55c57">00398</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a5dc36c9743ec74fedbd285cbb4e55c57">to_insert_breakpoint</a>) (<span class="keyword">struct </span>gdbarch *, <span class="keyword">struct </span><a class="code" href="structbp__target__info.html">bp_target_info</a> *);
<a name="l00399"></a><a class="code" href="structtarget__ops.html#a16e49fec6924ab7dc500d3343fc90e33">00399</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a16e49fec6924ab7dc500d3343fc90e33">to_remove_breakpoint</a>) (<span class="keyword">struct </span>gdbarch *, <span class="keyword">struct </span><a class="code" href="structbp__target__info.html">bp_target_info</a> *);
<a name="l00400"></a><a class="code" href="structtarget__ops.html#a7a1a220e1eb3c600f820ce09b1763a26">00400</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a7a1a220e1eb3c600f820ce09b1763a26">to_can_use_hw_breakpoint</a>) (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00401"></a><a class="code" href="structtarget__ops.html#a181caee9ad64d68fb3d331cb65bf94fb">00401</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a181caee9ad64d68fb3d331cb65bf94fb">to_ranged_break_num_registers</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l00402"></a><a class="code" href="structtarget__ops.html#a3e4e8200857ed4d8c230602134fae05e">00402</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a3e4e8200857ed4d8c230602134fae05e">to_insert_hw_breakpoint</a>) (<span class="keyword">struct </span>gdbarch *, <span class="keyword">struct </span><a class="code" href="structbp__target__info.html">bp_target_info</a> *);
<a name="l00403"></a><a class="code" href="structtarget__ops.html#a435b3d41c7cd2cda8cf52dec4b7b74fc">00403</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a435b3d41c7cd2cda8cf52dec4b7b74fc">to_remove_hw_breakpoint</a>) (<span class="keyword">struct </span>gdbarch *, <span class="keyword">struct </span><a class="code" href="structbp__target__info.html">bp_target_info</a> *);
<a name="l00404"></a>00404 
<a name="l00405"></a>00405     <span class="comment">/* Documentation of what the two routines below are expected to do is</span>
<a name="l00406"></a>00406 <span class="comment">       provided with the corresponding target_* macros.  */</span>
<a name="l00407"></a><a class="code" href="structtarget__ops.html#a310e5f59e27544ae28803274e2aa8338">00407</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a310e5f59e27544ae28803274e2aa8338">to_remove_watchpoint</a>) (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *);
<a name="l00408"></a><a class="code" href="structtarget__ops.html#a11a089e0b00d79a77ad0cb247de34949">00408</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a11a089e0b00d79a77ad0cb247de34949">to_insert_watchpoint</a>) (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *);
<a name="l00409"></a>00409 
<a name="l00410"></a><a class="code" href="structtarget__ops.html#a94b7afd00a97ca5d070dbcbb036ca061">00410</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a94b7afd00a97ca5d070dbcbb036ca061">to_insert_mask_watchpoint</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *,
<a name="l00411"></a>00411                                       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00412"></a><a class="code" href="structtarget__ops.html#a0c71f4d0da7943e88eb9f11f46bd2d86">00412</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a0c71f4d0da7943e88eb9f11f46bd2d86">to_remove_mask_watchpoint</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *,
<a name="l00413"></a>00413                                       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00414"></a><a class="code" href="structtarget__ops.html#aed96211f2a6c49e995e790caa2fb83b4">00414</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#aed96211f2a6c49e995e790caa2fb83b4">to_stopped_by_watchpoint</a>) (void);
<a name="l00415"></a><a class="code" href="structtarget__ops.html#a36aa55d0e179d499e5e119e7fe9879c4">00415</a>     <span class="keywordtype">int</span> <a class="code" href="structtarget__ops.html#a36aa55d0e179d499e5e119e7fe9879c4">to_have_steppable_watchpoint</a>;
<a name="l00416"></a><a class="code" href="structtarget__ops.html#a9ef97687ad44689014742512145b250e">00416</a>     <span class="keywordtype">int</span> <a class="code" href="structtarget__ops.html#a9ef97687ad44689014742512145b250e">to_have_continuable_watchpoint</a>;
<a name="l00417"></a><a class="code" href="structtarget__ops.html#a89a0d3c90763c2307c5c17b99003a20b">00417</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a89a0d3c90763c2307c5c17b99003a20b">to_stopped_data_address</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *);
<a name="l00418"></a><a class="code" href="structtarget__ops.html#ac1fcc3dfd63375999fa25c2bfa1d411e">00418</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#ac1fcc3dfd63375999fa25c2bfa1d411e">to_watchpoint_addr_within_range</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *,
<a name="l00419"></a>00419                                             <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00420"></a>00420 
<a name="l00421"></a>00421     <span class="comment">/* Documentation of this routine is provided with the corresponding</span>
<a name="l00422"></a>00422 <span class="comment">       target_* macro.  */</span>
<a name="l00423"></a><a class="code" href="structtarget__ops.html#ab2d8932fdc3bd9188d18f117b488b12b">00423</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#ab2d8932fdc3bd9188d18f117b488b12b">to_region_ok_for_hw_watchpoint</a>) (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00424"></a>00424 
<a name="l00425"></a><a class="code" href="structtarget__ops.html#a09a267966bcad9930e053e9abb0008ab">00425</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a09a267966bcad9930e053e9abb0008ab">to_can_accel_watchpoint_condition</a>) (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>,
<a name="l00426"></a>00426                                               <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *);
<a name="l00427"></a><a class="code" href="structtarget__ops.html#a29e4318d7f995af9f3ba8a66151b3949">00427</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a29e4318d7f995af9f3ba8a66151b3949">to_masked_watch_num_registers</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *,
<a name="l00428"></a>00428                                           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>);
<a name="l00429"></a><a class="code" href="structtarget__ops.html#a8345107a041ba210b957f743463cfbfb">00429</a>     void (*<a class="code" href="structtarget__ops.html#a8345107a041ba210b957f743463cfbfb">to_terminal_init</a>) (void);
<a name="l00430"></a><a class="code" href="structtarget__ops.html#a284e42deabafe0d8e974cced889abc99">00430</a>     void (*<a class="code" href="structtarget__ops.html#a284e42deabafe0d8e974cced889abc99">to_terminal_inferior</a>) (void);
<a name="l00431"></a><a class="code" href="structtarget__ops.html#a32b0c35f4fb8de9f207afd8b5da4c06d">00431</a>     void (*<a class="code" href="structtarget__ops.html#a32b0c35f4fb8de9f207afd8b5da4c06d">to_terminal_ours_for_output</a>) (void);
<a name="l00432"></a><a class="code" href="structtarget__ops.html#a5140e62f0d121e459177a0276ce1fb2f">00432</a>     void (*<a class="code" href="structtarget__ops.html#a5140e62f0d121e459177a0276ce1fb2f">to_terminal_ours</a>) (void);
<a name="l00433"></a><a class="code" href="structtarget__ops.html#a92922946340386c0efa3d43b8e262945">00433</a>     void (*<a class="code" href="structtarget__ops.html#a92922946340386c0efa3d43b8e262945">to_terminal_save_ours</a>) (void);
<a name="l00434"></a><a class="code" href="structtarget__ops.html#a640131ea1b6f41e7bd2e2f330feaa141">00434</a>     void (*<a class="code" href="structtarget__ops.html#a640131ea1b6f41e7bd2e2f330feaa141">to_terminal_info</a>) (<span class="keyword">const</span> <span class="keywordtype">char</span> *, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00435"></a><a class="code" href="structtarget__ops.html#ad7479d77480dfc6097829ae4eb694e97">00435</a>     void (*<a class="code" href="structtarget__ops.html#ad7479d77480dfc6097829ae4eb694e97">to_kill</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l00436"></a><a class="code" href="structtarget__ops.html#aadbd5f1631198a381b5422adc6653e29">00436</a>     void (*<a class="code" href="structtarget__ops.html#aadbd5f1631198a381b5422adc6653e29">to_load</a>) (<span class="keywordtype">char</span> *, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00437"></a><a class="code" href="structtarget__ops.html#ac137c7edca115afb65715c6aecc093a8">00437</a>     void (*<a class="code" href="structtarget__ops.html#ac137c7edca115afb65715c6aecc093a8">to_create_inferior</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *, 
<a name="l00438"></a>00438                                 <span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *, <span class="keywordtype">char</span> **, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00439"></a><a class="code" href="structtarget__ops.html#a648c885a1b58067c71517d41e66a7c5a">00439</a>     void (*<a class="code" href="structtarget__ops.html#a648c885a1b58067c71517d41e66a7c5a">to_post_startup_inferior</a>) (<a class="code" href="ptid_8h.html#aafdcd92f9f083a6e3233884cb3cc0653">ptid_t</a>);
<a name="l00440"></a><a class="code" href="structtarget__ops.html#a2a76082c02564aa4e2213e63fe6228e2">00440</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a2a76082c02564aa4e2213e63fe6228e2">to_insert_fork_catchpoint</a>) (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00441"></a><a class="code" href="structtarget__ops.html#a7df3e819d62528432bf8035b6003af64">00441</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a7df3e819d62528432bf8035b6003af64">to_remove_fork_catchpoint</a>) (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00442"></a><a class="code" href="structtarget__ops.html#af631eb518405e8b89f9d8b542ac55448">00442</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#af631eb518405e8b89f9d8b542ac55448">to_insert_vfork_catchpoint</a>) (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00443"></a><a class="code" href="structtarget__ops.html#a66478a7ffd52e88bb7aaa0114caef8fe">00443</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a66478a7ffd52e88bb7aaa0114caef8fe">to_remove_vfork_catchpoint</a>) (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00444"></a><a class="code" href="structtarget__ops.html#af2b76aabbe00d8f9029edacab5ea1bf4">00444</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#af2b76aabbe00d8f9029edacab5ea1bf4">to_follow_fork</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00445"></a><a class="code" href="structtarget__ops.html#a1ff2553c079cf0560bbb9d08dc3ffadb">00445</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a1ff2553c079cf0560bbb9d08dc3ffadb">to_insert_exec_catchpoint</a>) (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00446"></a><a class="code" href="structtarget__ops.html#aee4731710ba7881709e5526ebab09bd1">00446</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#aee4731710ba7881709e5526ebab09bd1">to_remove_exec_catchpoint</a>) (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00447"></a><a class="code" href="structtarget__ops.html#a26a34048cb1765c45fc5915961b6d08e">00447</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a26a34048cb1765c45fc5915961b6d08e">to_set_syscall_catchpoint</a>) (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <span class="keywordtype">int</span> *);
<a name="l00448"></a><a class="code" href="structtarget__ops.html#aa61fe7b04fe824d15f5b1cfb1779be38">00448</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#aa61fe7b04fe824d15f5b1cfb1779be38">to_has_exited</a>) (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <span class="keywordtype">int</span> *);
<a name="l00449"></a><a class="code" href="structtarget__ops.html#aa636723dd143fcd0c3c78af97f7358a5">00449</a>     void (*<a class="code" href="structtarget__ops.html#aa636723dd143fcd0c3c78af97f7358a5">to_mourn_inferior</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l00450"></a><a class="code" href="structtarget__ops.html#a0cbb0569244a461dcf20418dfdee3f60">00450</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a0cbb0569244a461dcf20418dfdee3f60">to_can_run</a>) (void);
<a name="l00451"></a>00451 
<a name="l00452"></a>00452     <span class="comment">/* Documentation of this routine is provided with the corresponding</span>
<a name="l00453"></a>00453 <span class="comment">       target_* macro.  */</span>
<a name="l00454"></a><a class="code" href="structtarget__ops.html#a6f07fb0af7d393f28540af828500aa61">00454</a>     void (*<a class="code" href="structtarget__ops.html#a6f07fb0af7d393f28540af828500aa61">to_pass_signals</a>) (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *);
<a name="l00455"></a>00455 
<a name="l00456"></a>00456     <span class="comment">/* Documentation of this routine is provided with the</span>
<a name="l00457"></a>00457 <span class="comment">       corresponding target_* function.  */</span>
<a name="l00458"></a><a class="code" href="structtarget__ops.html#a40565e76010920b9d24b9c49c6fc63ec">00458</a>     void (*<a class="code" href="structtarget__ops.html#a40565e76010920b9d24b9c49c6fc63ec">to_program_signals</a>) (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *);
<a name="l00459"></a>00459 
<a name="l00460"></a><a class="code" href="structtarget__ops.html#a01589152a8f74d8c236c1fab3c2838e9">00460</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a01589152a8f74d8c236c1fab3c2838e9">to_thread_alive</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *, <a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a>);
<a name="l00461"></a><a class="code" href="structtarget__ops.html#a6af5d37da6d3dd1ef3b2beb4cd9fdd81">00461</a>     void (*<a class="code" href="structtarget__ops.html#a6af5d37da6d3dd1ef3b2beb4cd9fdd81">to_find_new_threads</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l00462"></a><a class="code" href="structtarget__ops.html#a5259fe0b12fd9dd4e269ed44fee00603">00462</a>     <span class="keywordtype">char</span> *(*to_pid_to_str) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *, <a class="code" href="ptid_8h.html#aafdcd92f9f083a6e3233884cb3cc0653">ptid_t</a>);
<a name="l00463"></a><a class="code" href="structtarget__ops.html#a601c298daee0b6af36e202490680ccf6">00463</a>     <span class="keywordtype">char</span> *(*to_extra_thread_info) (<span class="keyword">struct </span><a class="code" href="structthread__info.html">thread_info</a> *);
<a name="l00464"></a><a class="code" href="structtarget__ops.html#a52f476a7b3fc59f27bf02ef0fce4d388">00464</a>     <span class="keywordtype">char</span> *(*to_thread_name) (<span class="keyword">struct </span><a class="code" href="structthread__info.html">thread_info</a> *);
<a name="l00465"></a><a class="code" href="structtarget__ops.html#a83d943a3006b96ec7821e5d65eed8b5e">00465</a>     void (*<a class="code" href="structtarget__ops.html#a83d943a3006b96ec7821e5d65eed8b5e">to_stop</a>) (<a class="code" href="ptid_8h.html#aafdcd92f9f083a6e3233884cb3cc0653">ptid_t</a>);
<a name="l00466"></a><a class="code" href="structtarget__ops.html#a3d8ebe5674ff4b8a827903f047e099c2">00466</a>     void (*<a class="code" href="structtarget__ops.html#a3d8ebe5674ff4b8a827903f047e099c2">to_rcmd</a>) (<span class="keywordtype">char</span> *command, <span class="keyword">struct </span>ui_file *output);
<a name="l00467"></a><a class="code" href="structtarget__ops.html#aaf3bf60e87d4afabe67af77185a2fb69">00467</a>     <span class="keywordtype">char</span> *(*to_pid_to_exec_file) (<span class="keywordtype">int</span> pid);
<a name="l00468"></a><a class="code" href="structtarget__ops.html#a6f9daded6ff01b15f8ee5142a8c9da65">00468</a>     void (*<a class="code" href="structtarget__ops.html#a6f9daded6ff01b15f8ee5142a8c9da65">to_log_command</a>) (<span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l00469"></a><a class="code" href="structtarget__ops.html#a5d6d476f704324058a4825144e6d4970">00469</a>     <span class="keyword">struct </span><a class="code" href="structtarget__section__table.html">target_section_table</a> *(*to_get_section_table) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l00470"></a><a class="code" href="structtarget__ops.html#aaf1f75f86ec2b948e5df3548198aae4b">00470</a>     <span class="keyword">enum</span> <a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00">strata</a> <a class="code" href="structtarget__ops.html#aaf1f75f86ec2b948e5df3548198aae4b">to_stratum</a>;
<a name="l00471"></a><a class="code" href="structtarget__ops.html#ad625bdaf8afca492722a20deb7f120c3">00471</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#ad625bdaf8afca492722a20deb7f120c3">to_has_all_memory</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l00472"></a><a class="code" href="structtarget__ops.html#aa672926e3d72e596d67efde607d13b86">00472</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#aa672926e3d72e596d67efde607d13b86">to_has_memory</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l00473"></a><a class="code" href="structtarget__ops.html#aded338ce92e6ae64169ece3b6666ff6a">00473</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#aded338ce92e6ae64169ece3b6666ff6a">to_has_stack</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l00474"></a><a class="code" href="structtarget__ops.html#a6392e322d5a0b45f5fd487cf8d94caaf">00474</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a6392e322d5a0b45f5fd487cf8d94caaf">to_has_registers</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l00475"></a><a class="code" href="structtarget__ops.html#ac83decb629de59475995bb0a100dc82a">00475</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#ac83decb629de59475995bb0a100dc82a">to_has_execution</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *, <a class="code" href="ptid_8h.html#aafdcd92f9f083a6e3233884cb3cc0653">ptid_t</a>);
<a name="l00476"></a><a class="code" href="structtarget__ops.html#ab9754d27b0891e21710e712ce572b2f5">00476</a>     <span class="keywordtype">int</span> <a class="code" href="structtarget__ops.html#ab9754d27b0891e21710e712ce572b2f5">to_has_thread_control</a>;  <span class="comment">/* control thread execution */</span>
<a name="l00477"></a><a class="code" href="structtarget__ops.html#add2dc3a83e9943b31b9a03367035bb25">00477</a>     <span class="keywordtype">int</span> <a class="code" href="structtarget__ops.html#add2dc3a83e9943b31b9a03367035bb25">to_attach_no_wait</a>;
<a name="l00478"></a>00478     <span class="comment">/* ASYNC target controls */</span>
<a name="l00479"></a><a class="code" href="structtarget__ops.html#ae4b587febec1f1681c7ca31aae07b1bb">00479</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#ae4b587febec1f1681c7ca31aae07b1bb">to_can_async_p</a>) (void);
<a name="l00480"></a><a class="code" href="structtarget__ops.html#a76b320a98c64464628d540b6176fb102">00480</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a76b320a98c64464628d540b6176fb102">to_is_async_p</a>) (void);
<a name="l00481"></a><a class="code" href="structtarget__ops.html#a98ab67014db4d9ebf1f17179a35ef916">00481</a>     void (*<a class="code" href="structtarget__ops.html#a98ab67014db4d9ebf1f17179a35ef916">to_async</a>) (void (*) (<span class="keyword">enum</span> <a class="code" href="target_8h.html#a1eebd9e5ab38f563a98578b0e6e47068">inferior_event_type</a>, <span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *);
<a name="l00482"></a><a class="code" href="structtarget__ops.html#aeeae8225c1e1d660217abdbe7960c1df">00482</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#aeeae8225c1e1d660217abdbe7960c1df">to_supports_non_stop</a>) (void);
<a name="l00483"></a>00483     <span class="comment">/* find_memory_regions support method for gcore */</span>
<a name="l00484"></a><a class="code" href="structtarget__ops.html#a4b6372b89b3b2153e3ba3b8061e9bf0a">00484</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a4b6372b89b3b2153e3ba3b8061e9bf0a">to_find_memory_regions</a>) (<a class="code" href="defs_8h.html#a9d6528d2f701ee8e47c35c038752ac99">find_memory_region_ftype</a> <a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>, <span class="keywordtype">void</span> *data);
<a name="l00485"></a>00485     <span class="comment">/* make_corefile_notes support method for gcore */</span>
<a name="l00486"></a><a class="code" href="structtarget__ops.html#ae431748d938974e0518fb9f4defd67a7">00486</a>     <span class="keywordtype">char</span> * (*to_make_corefile_notes) (bfd *, <span class="keywordtype">int</span> *);
<a name="l00487"></a>00487     <span class="comment">/* get_bookmark support method for bookmarks */</span>
<a name="l00488"></a><a class="code" href="structtarget__ops.html#ac91e1c7ceb6c9325b92c80845e7b28a1">00488</a>     <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> * (*to_get_bookmark) (<span class="keywordtype">char</span> *, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00489"></a>00489     <span class="comment">/* goto_bookmark support method for bookmarks */</span>
<a name="l00490"></a><a class="code" href="structtarget__ops.html#a2af176ddaf4009cd247918bbf2ef5e1f">00490</a>     void (*<a class="code" href="structtarget__ops.html#a2af176ddaf4009cd247918bbf2ef5e1f">to_goto_bookmark</a>) (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>);
<a name="l00491"></a>00491     <span class="comment">/* Return the thread-local address at OFFSET in the</span>
<a name="l00492"></a>00492 <span class="comment">       thread-local storage for the thread PTID and the shared library</span>
<a name="l00493"></a>00493 <span class="comment">       or executable file given by OBJFILE.  If that block of</span>
<a name="l00494"></a>00494 <span class="comment">       thread-local storage hasn&#39;t been allocated yet, this function</span>
<a name="l00495"></a>00495 <span class="comment">       may return an error.  */</span>
<a name="l00496"></a><a class="code" href="structtarget__ops.html#a076aa3a1e1e1d6bb90656222d790b243">00496</a>     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> (*<a class="code" href="structtarget__ops.html#a076aa3a1e1e1d6bb90656222d790b243">to_get_thread_local_address</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l00497"></a>00497                                               <a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a>,
<a name="l00498"></a>00498                                               <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> load_module_addr,
<a name="l00499"></a>00499                                               <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>);
<a name="l00500"></a>00500 
<a name="l00501"></a>00501     <span class="comment">/* Request that OPS transfer up to LEN 8-bit bytes of the target&#39;s</span>
<a name="l00502"></a>00502 <span class="comment">       OBJECT.  The OFFSET, for a seekable object, specifies the</span>
<a name="l00503"></a>00503 <span class="comment">       starting point.  The ANNEX can be used to provide additional</span>
<a name="l00504"></a>00504 <span class="comment">       data-specific information to the target.</span>
<a name="l00505"></a>00505 <span class="comment"></span>
<a name="l00506"></a>00506 <span class="comment">       Return the number of bytes actually transfered, zero when no</span>
<a name="l00507"></a>00507 <span class="comment">       further transfer is possible, and a negative error code (really</span>
<a name="l00508"></a>00508 <span class="comment">       an &#39;enum target_xfer_error&#39; value) when the transfer is not</span>
<a name="l00509"></a>00509 <span class="comment">       supported.  Return of a positive value smaller than LEN does</span>
<a name="l00510"></a>00510 <span class="comment">       not indicate the end of the object, only the end of the</span>
<a name="l00511"></a>00511 <span class="comment">       transfer; higher level code should continue transferring if</span>
<a name="l00512"></a>00512 <span class="comment">       desired.  This is handled in target.c.</span>
<a name="l00513"></a>00513 <span class="comment"></span>
<a name="l00514"></a>00514 <span class="comment">       The interface does not support a &quot;retry&quot; mechanism.  Instead it</span>
<a name="l00515"></a>00515 <span class="comment">       assumes that at least one byte will be transfered on each</span>
<a name="l00516"></a>00516 <span class="comment">       successful call.</span>
<a name="l00517"></a>00517 <span class="comment"></span>
<a name="l00518"></a>00518 <span class="comment">       NOTE: cagney/2003-10-17: The current interface can lead to</span>
<a name="l00519"></a>00519 <span class="comment">       fragmented transfers.  Lower target levels should not implement</span>
<a name="l00520"></a>00520 <span class="comment">       hacks, such as enlarging the transfer, in an attempt to</span>
<a name="l00521"></a>00521 <span class="comment">       compensate for this.  Instead, the target stack should be</span>
<a name="l00522"></a>00522 <span class="comment">       extended so that it implements supply/collect methods and a</span>
<a name="l00523"></a>00523 <span class="comment">       look-aside object cache.  With that available, the lowest</span>
<a name="l00524"></a>00524 <span class="comment">       target can safely and freely &quot;push&quot; data up the stack.</span>
<a name="l00525"></a>00525 <span class="comment"></span>
<a name="l00526"></a>00526 <span class="comment">       See target_read and target_write for more information.  One,</span>
<a name="l00527"></a>00527 <span class="comment">       and only one, of readbuf or writebuf must be non-NULL.  */</span>
<a name="l00528"></a>00528 
<a name="l00529"></a><a class="code" href="structtarget__ops.html#a095389eb9862ff7550e8286c54e33ad3">00529</a>     <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> (*<a class="code" href="structtarget__ops.html#a095389eb9862ff7550e8286c54e33ad3">to_xfer_partial</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l00530"></a>00530                                 <span class="keyword">enum</span> <a class="code" href="target_8h.html#aa5a3e4ceb377c9f5822cdc68c6f138e2">target_object</a> object, <span class="keyword">const</span> <span class="keywordtype">char</span> *annex,
<a name="l00531"></a>00531                                 <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *readbuf, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *writebuf,
<a name="l00532"></a>00532                                 <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>);
<a name="l00533"></a>00533 
<a name="l00534"></a>00534     <span class="comment">/* Returns the memory map for the target.  A return value of NULL</span>
<a name="l00535"></a>00535 <span class="comment">       means that no memory map is available.  If a memory address</span>
<a name="l00536"></a>00536 <span class="comment">       does not fall within any returned regions, it&#39;s assumed to be</span>
<a name="l00537"></a>00537 <span class="comment">       RAM.  The returned memory regions should not overlap.</span>
<a name="l00538"></a>00538 <span class="comment"></span>
<a name="l00539"></a>00539 <span class="comment">       The order of regions does not matter; target_memory_map will</span>
<a name="l00540"></a>00540 <span class="comment">       sort regions by starting address.  For that reason, this</span>
<a name="l00541"></a>00541 <span class="comment">       function should not be called directly except via</span>
<a name="l00542"></a>00542 <span class="comment">       target_memory_map.</span>
<a name="l00543"></a>00543 <span class="comment"></span>
<a name="l00544"></a>00544 <span class="comment">       This method should not cache data; if the memory map could</span>
<a name="l00545"></a>00545 <span class="comment">       change unexpectedly, it should be invalidated, and higher</span>
<a name="l00546"></a>00546 <span class="comment">       layers will re-fetch it.  */</span>
<a name="l00547"></a>00547     <a class="code" href="structtarget__ops.html#a4af7b10a3af1d12dc6ee20c9dd6d6bc7">VEC</a>(<a class="code" href="structmem__region.html">mem_region_s</a>) *(*to_memory_map) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549     <span class="comment">/* Erases the region of flash memory starting at ADDRESS, of</span>
<a name="l00550"></a>00550 <span class="comment">       length LENGTH.</span>
<a name="l00551"></a>00551 <span class="comment"></span>
<a name="l00552"></a>00552 <span class="comment">       Precondition: both ADDRESS and ADDRESS+LENGTH should be aligned</span>
<a name="l00553"></a>00553 <span class="comment">       on flash block boundaries, as reported by &#39;to_memory_map&#39;.  */</span>
<a name="l00554"></a><a class="code" href="structtarget__ops.html#aae458ca2c6198c32f5c4a375026011e2">00554</a>     void (*<a class="code" href="structtarget__ops.html#aae458ca2c6198c32f5c4a375026011e2">to_flash_erase</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *,
<a name="l00555"></a>00555                            <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> address, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> length);
<a name="l00556"></a>00556 
<a name="l00557"></a>00557     <span class="comment">/* Finishes a flash memory write sequence.  After this operation</span>
<a name="l00558"></a>00558 <span class="comment">       all flash memory should be available for writing and the result</span>
<a name="l00559"></a>00559 <span class="comment">       of reading from areas written by &#39;to_flash_write&#39; should be</span>
<a name="l00560"></a>00560 <span class="comment">       equal to what was written.  */</span>
<a name="l00561"></a><a class="code" href="structtarget__ops.html#a4ee289a6dc3e8b9550012f99c288e082">00561</a>     void (*<a class="code" href="structtarget__ops.html#a4ee289a6dc3e8b9550012f99c288e082">to_flash_done</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l00562"></a>00562 
<a name="l00563"></a>00563     <span class="comment">/* Describe the architecture-specific features of this target.</span>
<a name="l00564"></a>00564 <span class="comment">       Returns the description found, or NULL if no description</span>
<a name="l00565"></a>00565 <span class="comment">       was available.  */</span>
<a name="l00566"></a><a class="code" href="structtarget__ops.html#ad68ca23fd9f64e5a0c37f279c0e781a3">00566</a>     <span class="keyword">const</span> <span class="keyword">struct </span>target_desc *(*to_read_description) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *ops);
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     <span class="comment">/* Build the PTID of the thread on which a given task is running,</span>
<a name="l00569"></a>00569 <span class="comment">       based on LWP and THREAD.  These values are extracted from the</span>
<a name="l00570"></a>00570 <span class="comment">       task Private_Data section of the Ada Task Control Block, and</span>
<a name="l00571"></a>00571 <span class="comment">       their interpretation depends on the target.  */</span>
<a name="l00572"></a><a class="code" href="structtarget__ops.html#a1d246b305b808ee45e23eba2afcd796a">00572</a>     <a class="code" href="ptid_8h.html#aafdcd92f9f083a6e3233884cb3cc0653">ptid_t</a> (*<a class="code" href="structtarget__ops.html#a1d246b305b808ee45e23eba2afcd796a">to_get_ada_task_ptid</a>) (<span class="keywordtype">long</span> lwp, <span class="keywordtype">long</span> thread);
<a name="l00573"></a>00573 
<a name="l00574"></a>00574     <span class="comment">/* Read one auxv entry from *READPTR, not reading locations &gt;= ENDPTR.</span>
<a name="l00575"></a>00575 <span class="comment">       Return 0 if *READPTR is already at the end of the buffer.</span>
<a name="l00576"></a>00576 <span class="comment">       Return -1 if there is insufficient buffer for a whole entry.</span>
<a name="l00577"></a>00577 <span class="comment">       Return 1 if an entry was read into *TYPEP and *VALP.  */</span>
<a name="l00578"></a><a class="code" href="structtarget__ops.html#a85f748c93e031195ff943077e63fd1c8">00578</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a85f748c93e031195ff943077e63fd1c8">to_auxv_parse</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *ops, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **readptr,
<a name="l00579"></a>00579                          <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *endptr, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *<a class="code" href="linespec_8c.html#ab7f8c61060c5d5b2dc20d2aa601b9b69">typep</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *valp);
<a name="l00580"></a>00580 
<a name="l00581"></a>00581     <span class="comment">/* Search SEARCH_SPACE_LEN bytes beginning at START_ADDR for the</span>
<a name="l00582"></a>00582 <span class="comment">       sequence of bytes in PATTERN with length PATTERN_LEN.</span>
<a name="l00583"></a>00583 <span class="comment"></span>
<a name="l00584"></a>00584 <span class="comment">       The result is 1 if found, 0 if not found, and -1 if there was an error</span>
<a name="l00585"></a>00585 <span class="comment">       requiring halting of the search (e.g. memory read error).</span>
<a name="l00586"></a>00586 <span class="comment">       If the pattern is found the address is recorded in FOUND_ADDRP.  */</span>
<a name="l00587"></a><a class="code" href="structtarget__ops.html#ae4f7ba923b128f52c196b0e527a05818">00587</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#ae4f7ba923b128f52c196b0e527a05818">to_search_memory</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l00588"></a>00588                              <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_addr, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> search_space_len,
<a name="l00589"></a>00589                              <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *pattern, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> pattern_len,
<a name="l00590"></a>00590                              <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *found_addrp);
<a name="l00591"></a>00591 
<a name="l00592"></a>00592     <span class="comment">/* Can target execute in reverse?  */</span>
<a name="l00593"></a><a class="code" href="structtarget__ops.html#abc40d38dd6b5a62262d617b93014231a">00593</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#abc40d38dd6b5a62262d617b93014231a">to_can_execute_reverse</a>) (void);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595     <span class="comment">/* The direction the target is currently executing.  Must be</span>
<a name="l00596"></a>00596 <span class="comment">       implemented on targets that support reverse execution and async</span>
<a name="l00597"></a>00597 <span class="comment">       mode.  The default simply returns forward execution.  */</span>
<a name="l00598"></a><a class="code" href="structtarget__ops.html#aa80ce996b6e03898eddda1bec057a6fc">00598</a>     <span class="keyword">enum</span> <a class="code" href="inferior_8h.html#a48ab4325cf8e590f251b859335443e86">exec_direction_kind</a> (*<a class="code" href="structtarget__ops.html#aa80ce996b6e03898eddda1bec057a6fc">to_execution_direction</a>) (void);
<a name="l00599"></a>00599 
<a name="l00600"></a>00600     <span class="comment">/* Does this target support debugging multiple processes</span>
<a name="l00601"></a>00601 <span class="comment">       simultaneously?  */</span>
<a name="l00602"></a><a class="code" href="structtarget__ops.html#a754b223775c2376e871e5757a6eb7149">00602</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a754b223775c2376e871e5757a6eb7149">to_supports_multi_process</a>) (void);
<a name="l00603"></a>00603 
<a name="l00604"></a>00604     <span class="comment">/* Does this target support enabling and disabling tracepoints while a trace</span>
<a name="l00605"></a>00605 <span class="comment">       experiment is running?  */</span>
<a name="l00606"></a><a class="code" href="structtarget__ops.html#a440663c1ee5df4d60dfa85a30dfb276f">00606</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a440663c1ee5df4d60dfa85a30dfb276f">to_supports_enable_disable_tracepoint</a>) (void);
<a name="l00607"></a>00607 
<a name="l00608"></a>00608     <span class="comment">/* Does this target support disabling address space randomization?  */</span>
<a name="l00609"></a><a class="code" href="structtarget__ops.html#aef9ebdb13f44a88cd2ebc21eded7cc5f">00609</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#aef9ebdb13f44a88cd2ebc21eded7cc5f">to_supports_disable_randomization</a>) (void);
<a name="l00610"></a>00610 
<a name="l00611"></a>00611     <span class="comment">/* Does this target support the tracenz bytecode for string collection?  */</span>
<a name="l00612"></a><a class="code" href="structtarget__ops.html#ad3f9aa8d6c2b74929d90562ca30c4e14">00612</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#ad3f9aa8d6c2b74929d90562ca30c4e14">to_supports_string_tracing</a>) (void);
<a name="l00613"></a>00613 
<a name="l00614"></a>00614     <span class="comment">/* Does this target support evaluation of breakpoint conditions on its</span>
<a name="l00615"></a>00615 <span class="comment">       end?  */</span>
<a name="l00616"></a><a class="code" href="structtarget__ops.html#a9b7da8871d9d577e5488794875242d13">00616</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a9b7da8871d9d577e5488794875242d13">to_supports_evaluation_of_breakpoint_conditions</a>) (void);
<a name="l00617"></a>00617 
<a name="l00618"></a>00618     <span class="comment">/* Does this target support evaluation of breakpoint commands on its</span>
<a name="l00619"></a>00619 <span class="comment">       end?  */</span>
<a name="l00620"></a><a class="code" href="structtarget__ops.html#a713d8a1e0ae94129a032862197e98ef7">00620</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a713d8a1e0ae94129a032862197e98ef7">to_can_run_breakpoint_commands</a>) (void);
<a name="l00621"></a>00621 
<a name="l00622"></a>00622     <span class="comment">/* Determine current architecture of thread PTID.</span>
<a name="l00623"></a>00623 <span class="comment"></span>
<a name="l00624"></a>00624 <span class="comment">       The target is supposed to determine the architecture of the code where</span>
<a name="l00625"></a>00625 <span class="comment">       the target is currently stopped at (on Cell, if a target is in spu_run,</span>
<a name="l00626"></a>00626 <span class="comment">       to_thread_architecture would return SPU, otherwise PPC32 or PPC64).</span>
<a name="l00627"></a>00627 <span class="comment">       This is architecture used to perform decr_pc_after_break adjustment,</span>
<a name="l00628"></a>00628 <span class="comment">       and also determines the frame architecture of the innermost frame.</span>
<a name="l00629"></a>00629 <span class="comment">       ptrace operations need to operate according to target_gdbarch ().</span>
<a name="l00630"></a>00630 <span class="comment"></span>
<a name="l00631"></a>00631 <span class="comment">       The default implementation always returns target_gdbarch ().  */</span>
<a name="l00632"></a><a class="code" href="structtarget__ops.html#a4c3e86229b3d0cb007c5221d80614114">00632</a>     <span class="keyword">struct </span>gdbarch *(*to_thread_architecture) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *, <a class="code" href="ptid_8h.html#aafdcd92f9f083a6e3233884cb3cc0653">ptid_t</a>);
<a name="l00633"></a>00633 
<a name="l00634"></a>00634     <span class="comment">/* Determine current address space of thread PTID.</span>
<a name="l00635"></a>00635 <span class="comment"></span>
<a name="l00636"></a>00636 <span class="comment">       The default implementation always returns the inferior&#39;s</span>
<a name="l00637"></a>00637 <span class="comment">       address space.  */</span>
<a name="l00638"></a><a class="code" href="structtarget__ops.html#a69777c6da482979344bde387d287dbec">00638</a>     <span class="keyword">struct </span>address_space *(*to_thread_address_space) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *,
<a name="l00639"></a>00639                                                       <a class="code" href="ptid_8h.html#aafdcd92f9f083a6e3233884cb3cc0653">ptid_t</a>);
<a name="l00640"></a>00640 
<a name="l00641"></a>00641     <span class="comment">/* Target file operations.  */</span>
<a name="l00642"></a>00642 
<a name="l00643"></a>00643     <span class="comment">/* Open FILENAME on the target, using FLAGS and MODE.  Return a</span>
<a name="l00644"></a>00644 <span class="comment">       target file descriptor, or -1 if an error occurs (and set</span>
<a name="l00645"></a>00645 <span class="comment">       *TARGET_ERRNO).  */</span>
<a name="l00646"></a><a class="code" href="structtarget__ops.html#a3b9cf27dfa01fb3341cf3cbf6574f830">00646</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a3b9cf27dfa01fb3341cf3cbf6574f830">to_fileio_open</a>) (<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>, <span class="keywordtype">int</span> mode,
<a name="l00647"></a>00647                            <span class="keywordtype">int</span> *target_errno);
<a name="l00648"></a>00648 
<a name="l00649"></a>00649     <span class="comment">/* Write up to LEN bytes from WRITE_BUF to FD on the target.</span>
<a name="l00650"></a>00650 <span class="comment">       Return the number of bytes written, or -1 if an error occurs</span>
<a name="l00651"></a>00651 <span class="comment">       (and set *TARGET_ERRNO).  */</span>
<a name="l00652"></a><a class="code" href="structtarget__ops.html#a17f6dc57b2b752db80f12f26def8e3c7">00652</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a17f6dc57b2b752db80f12f26def8e3c7">to_fileio_pwrite</a>) (<span class="keywordtype">int</span> fd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *write_buf, <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>,
<a name="l00653"></a>00653                              <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <span class="keywordtype">int</span> *target_errno);
<a name="l00654"></a>00654 
<a name="l00655"></a>00655     <span class="comment">/* Read up to LEN bytes FD on the target into READ_BUF.</span>
<a name="l00656"></a>00656 <span class="comment">       Return the number of bytes read, or -1 if an error occurs</span>
<a name="l00657"></a>00657 <span class="comment">       (and set *TARGET_ERRNO).  */</span>
<a name="l00658"></a><a class="code" href="structtarget__ops.html#af489ee704a8e7c226fb05901bc7999ce">00658</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#af489ee704a8e7c226fb05901bc7999ce">to_fileio_pread</a>) (<span class="keywordtype">int</span> fd, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *read_buf, <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>,
<a name="l00659"></a>00659                             <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <span class="keywordtype">int</span> *target_errno);
<a name="l00660"></a>00660 
<a name="l00661"></a>00661     <span class="comment">/* Close FD on the target.  Return 0, or -1 if an error occurs</span>
<a name="l00662"></a>00662 <span class="comment">       (and set *TARGET_ERRNO).  */</span>
<a name="l00663"></a><a class="code" href="structtarget__ops.html#a10df172a4bff197dbeb2ca91b426a9b3">00663</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a10df172a4bff197dbeb2ca91b426a9b3">to_fileio_close</a>) (<span class="keywordtype">int</span> fd, <span class="keywordtype">int</span> *target_errno);
<a name="l00664"></a>00664 
<a name="l00665"></a>00665     <span class="comment">/* Unlink FILENAME on the target.  Return 0, or -1 if an error</span>
<a name="l00666"></a>00666 <span class="comment">       occurs (and set *TARGET_ERRNO).  */</span>
<a name="l00667"></a><a class="code" href="structtarget__ops.html#accf8187dd5060d585ec2645aa611286b">00667</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#accf8187dd5060d585ec2645aa611286b">to_fileio_unlink</a>) (<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keywordtype">int</span> *target_errno);
<a name="l00668"></a>00668 
<a name="l00669"></a>00669     <span class="comment">/* Read value of symbolic link FILENAME on the target.  Return a</span>
<a name="l00670"></a>00670 <span class="comment">       null-terminated string allocated via xmalloc, or NULL if an error</span>
<a name="l00671"></a>00671 <span class="comment">       occurs (and set *TARGET_ERRNO).  */</span>
<a name="l00672"></a><a class="code" href="structtarget__ops.html#ae53b19ec7afb32f71331f1f1baafe5a1">00672</a>     <span class="keywordtype">char</span> *(*to_fileio_readlink) (<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keywordtype">int</span> *target_errno);
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 
<a name="l00675"></a>00675     <span class="comment">/* Implement the &quot;info proc&quot; command.  */</span>
<a name="l00676"></a><a class="code" href="structtarget__ops.html#acc93524a70e11a8c06df012657234482">00676</a>     void (*<a class="code" href="structtarget__ops.html#acc93524a70e11a8c06df012657234482">to_info_proc</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *, <span class="keywordtype">char</span> *, <span class="keyword">enum</span> <a class="code" href="defs_8h.html#a766e85723d7470eb8519ed31b1ef8bf4">info_proc_what</a>);
<a name="l00677"></a>00677 
<a name="l00678"></a>00678     <span class="comment">/* Tracepoint-related operations.  */</span>
<a name="l00679"></a>00679 
<a name="l00680"></a>00680     <span class="comment">/* Prepare the target for a tracing run.  */</span>
<a name="l00681"></a><a class="code" href="structtarget__ops.html#a6f48401d86dc30e1861887733f229dcd">00681</a>     void (*<a class="code" href="structtarget__ops.html#a6f48401d86dc30e1861887733f229dcd">to_trace_init</a>) (void);
<a name="l00682"></a>00682 
<a name="l00683"></a>00683     <span class="comment">/* Send full details of a tracepoint location to the target.  */</span>
<a name="l00684"></a><a class="code" href="structtarget__ops.html#ad95a8d612fd079a0caeb08745fa615de">00684</a>     void (*<a class="code" href="structtarget__ops.html#ad95a8d612fd079a0caeb08745fa615de">to_download_tracepoint</a>) (<span class="keyword">struct </span><a class="code" href="structbp__location.html">bp_location</a> *location);
<a name="l00685"></a>00685 
<a name="l00686"></a>00686     <span class="comment">/* Is the target able to download tracepoint locations in current</span>
<a name="l00687"></a>00687 <span class="comment">       state?  */</span>
<a name="l00688"></a><a class="code" href="structtarget__ops.html#afb38c2f12080fb3426f9c345a1f852f3">00688</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#afb38c2f12080fb3426f9c345a1f852f3">to_can_download_tracepoint</a>) (void);
<a name="l00689"></a>00689 
<a name="l00690"></a>00690     <span class="comment">/* Send full details of a trace state variable to the target.  */</span>
<a name="l00691"></a><a class="code" href="structtarget__ops.html#a8753fe4591dbc4df5b7bf24fd50eede6">00691</a>     void (*<a class="code" href="structtarget__ops.html#a8753fe4591dbc4df5b7bf24fd50eede6">to_download_trace_state_variable</a>) (<span class="keyword">struct </span><a class="code" href="structtrace__state__variable.html">trace_state_variable</a> *tsv);
<a name="l00692"></a>00692 
<a name="l00693"></a>00693     <span class="comment">/* Enable a tracepoint on the target.  */</span>
<a name="l00694"></a><a class="code" href="structtarget__ops.html#ad8e102f714a5e5de833d4b0a566370e1">00694</a>     void (*<a class="code" href="structtarget__ops.html#ad8e102f714a5e5de833d4b0a566370e1">to_enable_tracepoint</a>) (<span class="keyword">struct </span><a class="code" href="structbp__location.html">bp_location</a> *location);
<a name="l00695"></a>00695 
<a name="l00696"></a>00696     <span class="comment">/* Disable a tracepoint on the target.  */</span>
<a name="l00697"></a><a class="code" href="structtarget__ops.html#a9124b4372983b182fa83c3245e5e800f">00697</a>     void (*<a class="code" href="structtarget__ops.html#a9124b4372983b182fa83c3245e5e800f">to_disable_tracepoint</a>) (<span class="keyword">struct </span><a class="code" href="structbp__location.html">bp_location</a> *location);
<a name="l00698"></a>00698 
<a name="l00699"></a>00699     <span class="comment">/* Inform the target info of memory regions that are readonly</span>
<a name="l00700"></a>00700 <span class="comment">       (such as text sections), and so it should return data from</span>
<a name="l00701"></a>00701 <span class="comment">       those rather than look in the trace buffer.  */</span>
<a name="l00702"></a><a class="code" href="structtarget__ops.html#a785bd35438ee56cb3a9d341dd80a5749">00702</a>     void (*<a class="code" href="structtarget__ops.html#a785bd35438ee56cb3a9d341dd80a5749">to_trace_set_readonly_regions</a>) (void);
<a name="l00703"></a>00703 
<a name="l00704"></a>00704     <span class="comment">/* Start a trace run.  */</span>
<a name="l00705"></a><a class="code" href="structtarget__ops.html#a36e60d1c2cb92a00054e4cf965a36282">00705</a>     void (*<a class="code" href="structtarget__ops.html#a36e60d1c2cb92a00054e4cf965a36282">to_trace_start</a>) (void);
<a name="l00706"></a>00706 
<a name="l00707"></a>00707     <span class="comment">/* Get the current status of a tracing run.  */</span>
<a name="l00708"></a><a class="code" href="structtarget__ops.html#ab177785f2ae3f4bcd6b1b7063a0270ee">00708</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#ab177785f2ae3f4bcd6b1b7063a0270ee">to_get_trace_status</a>) (<span class="keyword">struct </span><a class="code" href="structtrace__status.html">trace_status</a> *ts);
<a name="l00709"></a>00709 
<a name="l00710"></a><a class="code" href="structtarget__ops.html#abba80ea854cdc12d7b7c862ca28a7d03">00710</a>     void (*<a class="code" href="structtarget__ops.html#abba80ea854cdc12d7b7c862ca28a7d03">to_get_tracepoint_status</a>) (<span class="keyword">struct </span><a class="code" href="structbreakpoint.html">breakpoint</a> *tp,
<a name="l00711"></a>00711                                       <span class="keyword">struct </span><a class="code" href="structuploaded__tp.html">uploaded_tp</a> *utp);
<a name="l00712"></a>00712 
<a name="l00713"></a>00713     <span class="comment">/* Stop a trace run.  */</span>
<a name="l00714"></a><a class="code" href="structtarget__ops.html#a871003a82ea7880dd98cf233e5194599">00714</a>     void (*<a class="code" href="structtarget__ops.html#a871003a82ea7880dd98cf233e5194599">to_trace_stop</a>) (void);
<a name="l00715"></a>00715 
<a name="l00716"></a>00716    <span class="comment">/* Ask the target to find a trace frame of the given type TYPE,</span>
<a name="l00717"></a>00717 <span class="comment">      using NUM, ADDR1, and ADDR2 as search parameters.  Returns the</span>
<a name="l00718"></a>00718 <span class="comment">      number of the trace frame, and also the tracepoint number at</span>
<a name="l00719"></a>00719 <span class="comment">      TPP.  If no trace frame matches, return -1.  May throw if the</span>
<a name="l00720"></a>00720 <span class="comment">      operation fails.  */</span>
<a name="l00721"></a><a class="code" href="structtarget__ops.html#ab7c0848931d3d01ec0a1575f57ea5152">00721</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#ab7c0848931d3d01ec0a1575f57ea5152">to_trace_find</a>) (<span class="keyword">enum</span> <a class="code" href="target_8h.html#a78f5afcdc128cdd336383668a0f296d7">trace_find_type</a> <a class="code" href="structuploaded__tp.html#a3e983c135ec77bcb96798d08c683869d">type</a>, <span class="keywordtype">int</span> num,
<a name="l00722"></a>00722                           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr1, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr2, <span class="keywordtype">int</span> *tpp);
<a name="l00723"></a>00723 
<a name="l00724"></a>00724     <span class="comment">/* Get the value of the trace state variable number TSV, returning</span>
<a name="l00725"></a>00725 <span class="comment">       1 if the value is known and writing the value itself into the</span>
<a name="l00726"></a>00726 <span class="comment">       location pointed to by VAL, else returning 0.  */</span>
<a name="l00727"></a><a class="code" href="structtarget__ops.html#a956c3ec3cdd59ec4a00b92bb753a6601">00727</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a956c3ec3cdd59ec4a00b92bb753a6601">to_get_trace_state_variable_value</a>) (<span class="keywordtype">int</span> tsv, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *val);
<a name="l00728"></a>00728 
<a name="l00729"></a><a class="code" href="structtarget__ops.html#a8e088a487b8b37ca9538316e629a965c">00729</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a8e088a487b8b37ca9538316e629a965c">to_save_trace_data</a>) (<span class="keyword">const</span> <span class="keywordtype">char</span> *filename);
<a name="l00730"></a>00730 
<a name="l00731"></a><a class="code" href="structtarget__ops.html#ae822d9d6aca27d89b2700dc98d314108">00731</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#ae822d9d6aca27d89b2700dc98d314108">to_upload_tracepoints</a>) (<span class="keyword">struct </span><a class="code" href="structuploaded__tp.html">uploaded_tp</a> **utpp);
<a name="l00732"></a>00732 
<a name="l00733"></a><a class="code" href="structtarget__ops.html#a7686252718ba481b97d6284575f05cb2">00733</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a7686252718ba481b97d6284575f05cb2">to_upload_trace_state_variables</a>) (<span class="keyword">struct </span><a class="code" href="structuploaded__tsv.html">uploaded_tsv</a> **utsvp);
<a name="l00734"></a>00734 
<a name="l00735"></a><a class="code" href="structtarget__ops.html#a43c717fd587e55e5e9a46e0987d80e0a">00735</a>     <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> (*<a class="code" href="structtarget__ops.html#a43c717fd587e55e5e9a46e0987d80e0a">to_get_raw_trace_data</a>) (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf,
<a name="l00736"></a>00736                                       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738     <span class="comment">/* Get the minimum length of instruction on which a fast tracepoint</span>
<a name="l00739"></a>00739 <span class="comment">       may be set on the target.  If this operation is unsupported,</span>
<a name="l00740"></a>00740 <span class="comment">       return -1.  If for some reason the minimum length cannot be</span>
<a name="l00741"></a>00741 <span class="comment">       determined, return 0.  */</span>
<a name="l00742"></a><a class="code" href="structtarget__ops.html#a0da456f1202044f67ae980065da8c1e6">00742</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a0da456f1202044f67ae980065da8c1e6">to_get_min_fast_tracepoint_insn_len</a>) (void);
<a name="l00743"></a>00743 
<a name="l00744"></a>00744     <span class="comment">/* Set the target&#39;s tracing behavior in response to unexpected</span>
<a name="l00745"></a>00745 <span class="comment">       disconnection - set VAL to 1 to keep tracing, 0 to stop.  */</span>
<a name="l00746"></a><a class="code" href="structtarget__ops.html#ae3c2b44086350a14b2788bda3c475873">00746</a>     void (*<a class="code" href="structtarget__ops.html#ae3c2b44086350a14b2788bda3c475873">to_set_disconnected_tracing</a>) (<span class="keywordtype">int</span> val);
<a name="l00747"></a><a class="code" href="structtarget__ops.html#a0a0e88c5e2b9909e83b7cdf7b5ab0f27">00747</a>     void (*<a class="code" href="structtarget__ops.html#a0a0e88c5e2b9909e83b7cdf7b5ab0f27">to_set_circular_trace_buffer</a>) (<span class="keywordtype">int</span> val);
<a name="l00748"></a>00748     <span class="comment">/* Set the size of trace buffer in the target.  */</span>
<a name="l00749"></a><a class="code" href="structtarget__ops.html#a81a15057127e9d51fa48aaf6e86aee53">00749</a>     void (*<a class="code" href="structtarget__ops.html#a81a15057127e9d51fa48aaf6e86aee53">to_set_trace_buffer_size</a>) (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> val);
<a name="l00750"></a>00750 
<a name="l00751"></a>00751     <span class="comment">/* Add/change textual notes about the trace run, returning 1 if</span>
<a name="l00752"></a>00752 <span class="comment">       successful, 0 otherwise.  */</span>
<a name="l00753"></a><a class="code" href="structtarget__ops.html#a4817aa7a9dc37637b0514eb3bcd42abf">00753</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a4817aa7a9dc37637b0514eb3bcd42abf">to_set_trace_notes</a>) (<span class="keyword">const</span> <span class="keywordtype">char</span> *user, <span class="keyword">const</span> <span class="keywordtype">char</span> *notes,
<a name="l00754"></a>00754                                <span class="keyword">const</span> <span class="keywordtype">char</span> *stopnotes);
<a name="l00755"></a>00755 
<a name="l00756"></a>00756     <span class="comment">/* Return the processor core that thread PTID was last seen on.</span>
<a name="l00757"></a>00757 <span class="comment">       This information is updated only when:</span>
<a name="l00758"></a>00758 <span class="comment">       - update_thread_list is called</span>
<a name="l00759"></a>00759 <span class="comment">       - thread stops</span>
<a name="l00760"></a>00760 <span class="comment">       If the core cannot be determined -- either for the specified</span>
<a name="l00761"></a>00761 <span class="comment">       thread, or right now, or in this debug session, or for this</span>
<a name="l00762"></a>00762 <span class="comment">       target -- return -1.  */</span>
<a name="l00763"></a><a class="code" href="structtarget__ops.html#a78632c470f2bfe563b1e2fbf6e2f9d36">00763</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a78632c470f2bfe563b1e2fbf6e2f9d36">to_core_of_thread</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *, <a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a>);
<a name="l00764"></a>00764 
<a name="l00765"></a>00765     <span class="comment">/* Verify that the memory in the [MEMADDR, MEMADDR+SIZE) range</span>
<a name="l00766"></a>00766 <span class="comment">       matches the contents of [DATA,DATA+SIZE).  Returns 1 if there&#39;s</span>
<a name="l00767"></a>00767 <span class="comment">       a match, 0 if there&#39;s a mismatch, and -1 if an error is</span>
<a name="l00768"></a>00768 <span class="comment">       encountered while reading memory.  */</span>
<a name="l00769"></a><a class="code" href="structtarget__ops.html#acbe47044097032bd6b48d7660a65718e">00769</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#acbe47044097032bd6b48d7660a65718e">to_verify_memory</a>) (<span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> *, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *data,
<a name="l00770"></a>00770                              <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="exec_8h.html#ab268c3184bf49615e16de006a296a542">memaddr</a>, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>);
<a name="l00771"></a>00771 
<a name="l00772"></a>00772     <span class="comment">/* Return the address of the start of the Thread Information Block</span>
<a name="l00773"></a>00773 <span class="comment">       a Windows OS specific feature.  */</span>
<a name="l00774"></a><a class="code" href="structtarget__ops.html#afaf103a2e75d712b4796df23ce6ba1fe">00774</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#afaf103a2e75d712b4796df23ce6ba1fe">to_get_tib_address</a>) (<a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *addr);
<a name="l00775"></a>00775 
<a name="l00776"></a>00776     <span class="comment">/* Send the new settings of write permission variables.  */</span>
<a name="l00777"></a><a class="code" href="structtarget__ops.html#a00954220cfb0bfc4c997d7a0a1d8d0db">00777</a>     void (*<a class="code" href="structtarget__ops.html#a00954220cfb0bfc4c997d7a0a1d8d0db">to_set_permissions</a>) (void);
<a name="l00778"></a>00778 
<a name="l00779"></a>00779     <span class="comment">/* Look for a static tracepoint marker at ADDR, and fill in MARKER</span>
<a name="l00780"></a>00780 <span class="comment">       with its details.  Return 1 on success, 0 on failure.  */</span>
<a name="l00781"></a><a class="code" href="structtarget__ops.html#aed0a25ca70838c431b62c03d4658d451">00781</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#aed0a25ca70838c431b62c03d4658d451">to_static_tracepoint_marker_at</a>) (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>,
<a name="l00782"></a>00782                                            <span class="keyword">struct </span><a class="code" href="structstatic__tracepoint__marker.html">static_tracepoint_marker</a> *marker);
<a name="l00783"></a>00783 
<a name="l00784"></a>00784     <span class="comment">/* Return a vector of all tracepoints markers string id ID, or all</span>
<a name="l00785"></a>00785 <span class="comment">       markers if ID is NULL.  */</span>
<a name="l00786"></a>00786     <a class="code" href="structtarget__ops.html#a4af7b10a3af1d12dc6ee20c9dd6d6bc7">VEC</a>(static_tracepoint_marker_p) *(*to_static_tracepoint_markers_by_strid)
<a name="l00787"></a>00787       (<span class="keyword">const</span> <span class="keywordtype">char</span> *id);
<a name="l00788"></a>00788 
<a name="l00789"></a>00789     <span class="comment">/* Return a traceframe info object describing the current</span>
<a name="l00790"></a>00790 <span class="comment">       traceframe&#39;s contents.  If the target doesn&#39;t support</span>
<a name="l00791"></a>00791 <span class="comment">       traceframe info, return NULL.  If the current traceframe is not</span>
<a name="l00792"></a>00792 <span class="comment">       selected (the current traceframe number is -1), the target can</span>
<a name="l00793"></a>00793 <span class="comment">       choose to return either NULL or an empty traceframe info.  If</span>
<a name="l00794"></a>00794 <span class="comment">       NULL is returned, for example in remote target, GDB will read</span>
<a name="l00795"></a>00795 <span class="comment">       from the live inferior.  If an empty traceframe info is</span>
<a name="l00796"></a>00796 <span class="comment">       returned, for example in tfile target, which means the</span>
<a name="l00797"></a>00797 <span class="comment">       traceframe info is available, but the requested memory is not</span>
<a name="l00798"></a>00798 <span class="comment">       available in it.  GDB will try to see if the requested memory</span>
<a name="l00799"></a>00799 <span class="comment">       is available in the read-only sections.  This method should not</span>
<a name="l00800"></a>00800 <span class="comment">       cache data; higher layers take care of caching, invalidating,</span>
<a name="l00801"></a>00801 <span class="comment">       and re-fetching when necessary.  */</span>
<a name="l00802"></a><a class="code" href="structtarget__ops.html#a5ce8851a7f7b70bc7d2d8a45c51672e9">00802</a>     <span class="keyword">struct </span><a class="code" href="structtraceframe__info.html">traceframe_info</a> *(*to_traceframe_info) (void);
<a name="l00803"></a>00803 
<a name="l00804"></a>00804     <span class="comment">/* Ask the target to use or not to use agent according to USE.  Return 1</span>
<a name="l00805"></a>00805 <span class="comment">       successful, 0 otherwise.  */</span>
<a name="l00806"></a><a class="code" href="structtarget__ops.html#a868a33481eaa66091869377a6daffe5e">00806</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a868a33481eaa66091869377a6daffe5e">to_use_agent</a>) (<span class="keywordtype">int</span> use);
<a name="l00807"></a>00807 
<a name="l00808"></a>00808     <span class="comment">/* Is the target able to use agent in current state?  */</span>
<a name="l00809"></a><a class="code" href="structtarget__ops.html#a201371ea5746521d848ab29dce593634">00809</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a201371ea5746521d848ab29dce593634">to_can_use_agent</a>) (void);
<a name="l00810"></a>00810 
<a name="l00811"></a>00811     <span class="comment">/* Check whether the target supports branch tracing.  */</span>
<a name="l00812"></a><a class="code" href="structtarget__ops.html#a0416b96f2882fdf2c1253bc353dfa5de">00812</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a0416b96f2882fdf2c1253bc353dfa5de">to_supports_btrace</a>) (void);
<a name="l00813"></a>00813 
<a name="l00814"></a>00814     <span class="comment">/* Enable branch tracing for PTID and allocate a branch trace target</span>
<a name="l00815"></a>00815 <span class="comment">       information struct for reading and for disabling branch trace.  */</span>
<a name="l00816"></a><a class="code" href="structtarget__ops.html#af2a10b0c92985dba5b5c14e38ce75019">00816</a>     <span class="keyword">struct </span><a class="code" href="structbtrace__target__info.html">btrace_target_info</a> *(*to_enable_btrace) (<a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structbtrace__target__info.html#a3100c7bf9cf76fa641a7b68c96328199">ptid</a>);
<a name="l00817"></a>00817 
<a name="l00818"></a>00818     <span class="comment">/* Disable branch tracing and deallocate TINFO.  */</span>
<a name="l00819"></a><a class="code" href="structtarget__ops.html#abba94b5bab83c35f2ea991b6beff447a">00819</a>     void (*<a class="code" href="structtarget__ops.html#abba94b5bab83c35f2ea991b6beff447a">to_disable_btrace</a>) (<span class="keyword">struct </span><a class="code" href="structbtrace__target__info.html">btrace_target_info</a> *tinfo);
<a name="l00820"></a>00820 
<a name="l00821"></a>00821     <span class="comment">/* Disable branch tracing and deallocate TINFO.  This function is similar</span>
<a name="l00822"></a>00822 <span class="comment">       to to_disable_btrace, except that it is called during teardown and is</span>
<a name="l00823"></a>00823 <span class="comment">       only allowed to perform actions that are safe.  A counter-example would</span>
<a name="l00824"></a>00824 <span class="comment">       be attempting to talk to a remote target.  */</span>
<a name="l00825"></a><a class="code" href="structtarget__ops.html#abf1f5102b2fdb7288bedfddc928ebba2">00825</a>     void (*<a class="code" href="structtarget__ops.html#abf1f5102b2fdb7288bedfddc928ebba2">to_teardown_btrace</a>) (<span class="keyword">struct </span><a class="code" href="structbtrace__target__info.html">btrace_target_info</a> *tinfo);
<a name="l00826"></a>00826 
<a name="l00827"></a>00827     <span class="comment">/* Read branch trace data.  */</span>
<a name="l00828"></a>00828     <a class="code" href="structtarget__ops.html#a4af7b10a3af1d12dc6ee20c9dd6d6bc7">VEC</a> (<a class="code" href="structbtrace__block.html">btrace_block_s</a>) *(*to_read_btrace) (<span class="keyword">struct </span><a class="code" href="structbtrace__target__info.html">btrace_target_info</a> *,
<a name="l00829"></a>00829                                              <span class="keyword">enum</span> <a class="code" href="btrace-common_8h.html#ab46be743c225007393dcf7650de682bc">btrace_read_type</a>);
<a name="l00830"></a>00830 
<a name="l00831"></a>00831     <span class="comment">/* Stop trace recording.  */</span>
<a name="l00832"></a><a class="code" href="structtarget__ops.html#ae81c19620ac76a39000bb5fd12a4a3ff">00832</a>     void (*<a class="code" href="structtarget__ops.html#ae81c19620ac76a39000bb5fd12a4a3ff">to_stop_recording</a>) (void);
<a name="l00833"></a>00833 
<a name="l00834"></a>00834     <span class="comment">/* Print information about the recording.  */</span>
<a name="l00835"></a><a class="code" href="structtarget__ops.html#a0f13a8148ecc5fc489e4b319e3437838">00835</a>     void (*<a class="code" href="structtarget__ops.html#a0f13a8148ecc5fc489e4b319e3437838">to_info_record</a>) (void);
<a name="l00836"></a>00836 
<a name="l00837"></a>00837     <span class="comment">/* Save the recorded execution trace into a file.  */</span>
<a name="l00838"></a><a class="code" href="structtarget__ops.html#a1462a8f5199af2d0ffc27d1b10169146">00838</a>     void (*<a class="code" href="structtarget__ops.html#a1462a8f5199af2d0ffc27d1b10169146">to_save_record</a>) (<span class="keyword">const</span> <span class="keywordtype">char</span> *filename);
<a name="l00839"></a>00839 
<a name="l00840"></a>00840     <span class="comment">/* Delete the recorded execution trace from the current position onwards.  */</span>
<a name="l00841"></a><a class="code" href="structtarget__ops.html#a382619286ddcda2fbb562fdf40bb8a4a">00841</a>     void (*<a class="code" href="structtarget__ops.html#a382619286ddcda2fbb562fdf40bb8a4a">to_delete_record</a>) (void);
<a name="l00842"></a>00842 
<a name="l00843"></a>00843     <span class="comment">/* Query if the record target is currently replaying.  */</span>
<a name="l00844"></a><a class="code" href="structtarget__ops.html#a9873075e93fe26d0bae379479cd6ba7d">00844</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#a9873075e93fe26d0bae379479cd6ba7d">to_record_is_replaying</a>) (void);
<a name="l00845"></a>00845 
<a name="l00846"></a>00846     <span class="comment">/* Go to the begin of the execution trace.  */</span>
<a name="l00847"></a><a class="code" href="structtarget__ops.html#a935fc1b4af5b35850234560effb6c2b9">00847</a>     void (*<a class="code" href="structtarget__ops.html#a935fc1b4af5b35850234560effb6c2b9">to_goto_record_begin</a>) (void);
<a name="l00848"></a>00848 
<a name="l00849"></a>00849     <span class="comment">/* Go to the end of the execution trace.  */</span>
<a name="l00850"></a><a class="code" href="structtarget__ops.html#ab4fdfbcf46929bc1e567ad5dd39b2c62">00850</a>     void (*<a class="code" href="structtarget__ops.html#ab4fdfbcf46929bc1e567ad5dd39b2c62">to_goto_record_end</a>) (void);
<a name="l00851"></a>00851 
<a name="l00852"></a>00852     <span class="comment">/* Go to a specific location in the recorded execution trace.  */</span>
<a name="l00853"></a><a class="code" href="structtarget__ops.html#a13cac1631668b85ee18f5ec9b26e7ab8">00853</a>     void (*<a class="code" href="structtarget__ops.html#a13cac1631668b85ee18f5ec9b26e7ab8">to_goto_record</a>) (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> insn);
<a name="l00854"></a>00854 
<a name="l00855"></a>00855     <span class="comment">/* Disassemble SIZE instructions in the recorded execution trace from</span>
<a name="l00856"></a>00856 <span class="comment">       the current position.</span>
<a name="l00857"></a>00857 <span class="comment">       If SIZE &lt; 0, disassemble abs (SIZE) preceding instructions; otherwise,</span>
<a name="l00858"></a>00858 <span class="comment">       disassemble SIZE succeeding instructions.  */</span>
<a name="l00859"></a><a class="code" href="structtarget__ops.html#ad347ba55b6e8e027dab4ee85bfc882c1">00859</a>     void (*<a class="code" href="structtarget__ops.html#ad347ba55b6e8e027dab4ee85bfc882c1">to_insn_history</a>) (<span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>, <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>);
<a name="l00860"></a>00860 
<a name="l00861"></a>00861     <span class="comment">/* Disassemble SIZE instructions in the recorded execution trace around</span>
<a name="l00862"></a>00862 <span class="comment">       FROM.</span>
<a name="l00863"></a>00863 <span class="comment">       If SIZE &lt; 0, disassemble abs (SIZE) instructions before FROM; otherwise,</span>
<a name="l00864"></a>00864 <span class="comment">       disassemble SIZE instructions after FROM.  */</span>
<a name="l00865"></a><a class="code" href="structtarget__ops.html#a9c7984b8345ce62a6703837f36a5d816">00865</a>     void (*<a class="code" href="structtarget__ops.html#a9c7984b8345ce62a6703837f36a5d816">to_insn_history_from</a>) (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="varobj_8h.html#a43396decd62b46fa01cc6c66a84cbba1">from</a>, <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>, <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>);
<a name="l00866"></a>00866 
<a name="l00867"></a>00867     <span class="comment">/* Disassemble a section of the recorded execution trace from instruction</span>
<a name="l00868"></a>00868 <span class="comment">       BEGIN (inclusive) to instruction END (exclusive).  */</span>
<a name="l00869"></a><a class="code" href="structtarget__ops.html#a83f3e2c97b718af30735ba7d05fbf76b">00869</a>     void (*<a class="code" href="structtarget__ops.html#a83f3e2c97b718af30735ba7d05fbf76b">to_insn_history_range</a>) (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> begin, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> end, <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>);
<a name="l00870"></a>00870 
<a name="l00871"></a>00871     <span class="comment">/* Print a function trace of the recorded execution trace.</span>
<a name="l00872"></a>00872 <span class="comment">       If SIZE &lt; 0, print abs (SIZE) preceding functions; otherwise, print SIZE</span>
<a name="l00873"></a>00873 <span class="comment">       succeeding functions.  */</span>
<a name="l00874"></a><a class="code" href="structtarget__ops.html#abc8f8ce5c4c503702de43991b2c038b8">00874</a>     void (*<a class="code" href="structtarget__ops.html#abc8f8ce5c4c503702de43991b2c038b8">to_call_history</a>) (<span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>, <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>);
<a name="l00875"></a>00875 
<a name="l00876"></a>00876     <span class="comment">/* Print a function trace of the recorded execution trace starting</span>
<a name="l00877"></a>00877 <span class="comment">       at function FROM.</span>
<a name="l00878"></a>00878 <span class="comment">       If SIZE &lt; 0, print abs (SIZE) functions before FROM; otherwise, print</span>
<a name="l00879"></a>00879 <span class="comment">       SIZE functions after FROM.  */</span>
<a name="l00880"></a><a class="code" href="structtarget__ops.html#a3456aa5ff82906774a0eafd5a01cb66c">00880</a>     void (*<a class="code" href="structtarget__ops.html#a3456aa5ff82906774a0eafd5a01cb66c">to_call_history_from</a>) (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> begin, <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>, <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>);
<a name="l00881"></a>00881 
<a name="l00882"></a>00882     <span class="comment">/* Print a function trace of an execution trace section from function BEGIN</span>
<a name="l00883"></a>00883 <span class="comment">       (inclusive) to function END (exclusive).  */</span>
<a name="l00884"></a><a class="code" href="structtarget__ops.html#a6b8edb1d47fc8e60eb212dcd6f84570d">00884</a>     void (*<a class="code" href="structtarget__ops.html#a6b8edb1d47fc8e60eb212dcd6f84570d">to_call_history_range</a>) (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> begin, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> end, <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>);
<a name="l00885"></a>00885 
<a name="l00886"></a>00886     <span class="comment">/* Nonzero if TARGET_OBJECT_LIBRARIES_SVR4 may be read with a</span>
<a name="l00887"></a>00887 <span class="comment">       non-empty annex.  */</span>
<a name="l00888"></a><a class="code" href="structtarget__ops.html#acd0367d9ee2d33ff3d28921f550f9afe">00888</a>     <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a> (*<a class="code" href="structtarget__ops.html#acd0367d9ee2d33ff3d28921f550f9afe">to_augmented_libraries_svr4_read</a>) (void);
<a name="l00889"></a>00889 
<a name="l00890"></a><a class="code" href="structtarget__ops.html#a97a3b404ed5a64b8f6229fdaf43d30fb">00890</a>     <span class="keywordtype">int</span> <a class="code" href="structtarget__ops.html#a97a3b404ed5a64b8f6229fdaf43d30fb">to_magic</a>;
<a name="l00891"></a>00891     <span class="comment">/* Need sub-structure for target machine related rather than comm related?</span>
<a name="l00892"></a>00892 <span class="comment">     */</span>
<a name="l00893"></a>00893   };
<a name="l00894"></a>00894 
<a name="l00895"></a>00895 <span class="comment">/* Magic number for checking ops size.  If a struct doesn&#39;t end with this</span>
<a name="l00896"></a>00896 <span class="comment">   number, somebody changed the declaration but didn&#39;t change all the</span>
<a name="l00897"></a>00897 <span class="comment">   places that initialize one.  */</span>
<a name="l00898"></a>00898 
<a name="l00899"></a><a class="code" href="target_8h.html#a52de2938b46ac35e4a8c50fead44fd4d">00899</a> <span class="preprocessor">#define OPS_MAGIC       3840</span>
<a name="l00900"></a>00900 <span class="preprocessor"></span>
<a name="l00901"></a>00901 <span class="comment">/* The ops structure for our &quot;current&quot; target process.  This should</span>
<a name="l00902"></a>00902 <span class="comment">   never be NULL.  If there is no target, it points to the dummy_target.  */</span>
<a name="l00903"></a>00903 
<a name="l00904"></a>00904 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtarget__ops.html">target_ops</a> <a class="code" href="target_8h.html#a2d8640b030266b58d3821eb5cfd112b9">current_target</a>;
<a name="l00905"></a>00905 
<a name="l00906"></a>00906 <span class="comment">/* Define easy words for doing these operations on our current target.  */</span>
<a name="l00907"></a>00907 
<a name="l00908"></a><a class="code" href="target_8h.html#a82f16780537e85ac9b42873b0008108c">00908</a> <span class="preprocessor">#define target_shortname        (current_target.to_shortname)</span>
<a name="l00909"></a><a class="code" href="target_8h.html#a3de229e94f265d5ba7f821bf007c44a9">00909</a> <span class="preprocessor"></span><span class="preprocessor">#define target_longname         (current_target.to_longname)</span>
<a name="l00910"></a>00910 <span class="preprocessor"></span>
<a name="l00911"></a>00911 <span class="comment">/* Does whatever cleanup is required for a target that we are no</span>
<a name="l00912"></a>00912 <span class="comment">   longer going to be calling.  This routine is automatically always</span>
<a name="l00913"></a>00913 <span class="comment">   called after popping the target off the target stack - the target&#39;s</span>
<a name="l00914"></a>00914 <span class="comment">   own methods are no longer available through the target vector.</span>
<a name="l00915"></a>00915 <span class="comment">   Closing file descriptors and freeing all memory allocated memory are</span>
<a name="l00916"></a>00916 <span class="comment">   typical things it should do.  */</span>
<a name="l00917"></a>00917 
<a name="l00918"></a>00918 <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a160432ebbe12b7c57f9e2ec82a56e9cd">target_close</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *targ);
<a name="l00919"></a>00919 
<a name="l00920"></a>00920 <span class="comment">/* Attaches to a process on the target side.  Arguments are as passed</span>
<a name="l00921"></a>00921 <span class="comment">   to the `attach&#39; command by the user.  This routine can be called</span>
<a name="l00922"></a>00922 <span class="comment">   when the target is not on the target-stack, if the target_can_run</span>
<a name="l00923"></a>00923 <span class="comment">   routine returns 1; in that case, it must push itself onto the stack.</span>
<a name="l00924"></a>00924 <span class="comment">   Upon exit, the target should be ready for normal operations, and</span>
<a name="l00925"></a>00925 <span class="comment">   should be ready to deliver the status of the process immediately</span>
<a name="l00926"></a>00926 <span class="comment">   (without waiting) to an upcoming target_wait call.  */</span>
<a name="l00927"></a>00927 
<a name="l00928"></a>00928 <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a84a590ed94779a46e642a5ff2f995c8a">target_attach</a> (<span class="keywordtype">char</span> *, <span class="keywordtype">int</span>);
<a name="l00929"></a>00929 
<a name="l00930"></a>00930 <span class="comment">/* Some targets don&#39;t generate traps when attaching to the inferior,</span>
<a name="l00931"></a>00931 <span class="comment">   or their target_attach implementation takes care of the waiting.</span>
<a name="l00932"></a>00932 <span class="comment">   These targets must set to_attach_no_wait.  */</span>
<a name="l00933"></a>00933 
<a name="l00934"></a><a class="code" href="target_8h.html#a9d31e1fd5dbc0edbdfaa9af7fb74252c">00934</a> <span class="preprocessor">#define target_attach_no_wait \</span>
<a name="l00935"></a>00935 <span class="preprocessor">     (current_target.to_attach_no_wait)</span>
<a name="l00936"></a>00936 <span class="preprocessor"></span>
<a name="l00937"></a>00937 <span class="comment">/* The target_attach operation places a process under debugger control,</span>
<a name="l00938"></a>00938 <span class="comment">   and stops the process.</span>
<a name="l00939"></a>00939 <span class="comment"></span>
<a name="l00940"></a>00940 <span class="comment">   This operation provides a target-specific hook that allows the</span>
<a name="l00941"></a>00941 <span class="comment">   necessary bookkeeping to be performed after an attach completes.  */</span>
<a name="l00942"></a><a class="code" href="target_8h.html#a172fb1ea99d218ca1287ed73ea13760a">00942</a> <span class="preprocessor">#define target_post_attach(pid) \</span>
<a name="l00943"></a>00943 <span class="preprocessor">     (*current_target.to_post_attach) (pid)</span>
<a name="l00944"></a>00944 <span class="preprocessor"></span>
<a name="l00945"></a>00945 <span class="comment">/* Takes a program previously attached to and detaches it.</span>
<a name="l00946"></a>00946 <span class="comment">   The program may resume execution (some targets do, some don&#39;t) and will</span>
<a name="l00947"></a>00947 <span class="comment">   no longer stop on signals, etc.  We better not have left any breakpoints</span>
<a name="l00948"></a>00948 <span class="comment">   in the program or it&#39;ll die when it hits one.  ARGS is arguments</span>
<a name="l00949"></a>00949 <span class="comment">   typed by the user (e.g. a signal to send the process).  FROM_TTY</span>
<a name="l00950"></a>00950 <span class="comment">   says whether to be verbose or not.  */</span>
<a name="l00951"></a>00951 
<a name="l00952"></a>00952 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#af9461c4f474acfaf3d139ffb68adc0ec">target_detach</a> (<span class="keywordtype">char</span> *, <span class="keywordtype">int</span>);
<a name="l00953"></a>00953 
<a name="l00954"></a>00954 <span class="comment">/* Disconnect from the current target without resuming it (leaving it</span>
<a name="l00955"></a>00955 <span class="comment">   waiting for a debugger).  */</span>
<a name="l00956"></a>00956 
<a name="l00957"></a>00957 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#aeb631f9c30325a96570c8b7c2864c06b">target_disconnect</a> (<span class="keywordtype">char</span> *, <span class="keywordtype">int</span>);
<a name="l00958"></a>00958 
<a name="l00959"></a>00959 <span class="comment">/* Resume execution of the target process PTID (or a group of</span>
<a name="l00960"></a>00960 <span class="comment">   threads).  STEP says whether to single-step or to run free; SIGGNAL</span>
<a name="l00961"></a>00961 <span class="comment">   is the signal to be given to the target, or GDB_SIGNAL_0 for no</span>
<a name="l00962"></a>00962 <span class="comment">   signal.  The caller may not pass GDB_SIGNAL_DEFAULT.  A specific</span>
<a name="l00963"></a>00963 <span class="comment">   PTID means `step/resume only this process id&#39;.  A wildcard PTID</span>
<a name="l00964"></a>00964 <span class="comment">   (all threads, or all threads of process) means `step/resume</span>
<a name="l00965"></a>00965 <span class="comment">   INFERIOR_PTID, and let other threads (for which the wildcard PTID</span>
<a name="l00966"></a>00966 <span class="comment">   matches) resume with their &#39;thread-&gt;suspend.stop_signal&#39; signal</span>
<a name="l00967"></a>00967 <span class="comment">   (usually GDB_SIGNAL_0) if it is in &quot;pass&quot; state, or with no signal</span>
<a name="l00968"></a>00968 <span class="comment">   if in &quot;no pass&quot; state.  */</span>
<a name="l00969"></a>00969 
<a name="l00970"></a>00970 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a10cefb24ce83949fae9ba2756d0bf476">target_resume</a> (<a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a>, <span class="keywordtype">int</span> step, <span class="keyword">enum</span> <a class="code" href="signals_8h.html#a1169a44d7b94bdcf747c3f69138dafe7">gdb_signal</a> signal);
<a name="l00971"></a>00971 
<a name="l00972"></a>00972 <span class="comment">/* Wait for process pid to do something.  PTID = -1 to wait for any</span>
<a name="l00973"></a>00973 <span class="comment">   pid to do something.  Return pid of child, or -1 in case of error;</span>
<a name="l00974"></a>00974 <span class="comment">   store status through argument pointer STATUS.  Note that it is</span>
<a name="l00975"></a>00975 <span class="comment">   _NOT_ OK to throw_exception() out of target_wait() without popping</span>
<a name="l00976"></a>00976 <span class="comment">   the debugging target from the stack; GDB isn&#39;t prepared to get back</span>
<a name="l00977"></a>00977 <span class="comment">   to the prompt with a debugging target but without the frame cache,</span>
<a name="l00978"></a>00978 <span class="comment">   stop_pc, etc., set up.  OPTIONS is a bitwise OR of TARGET_W*</span>
<a name="l00979"></a>00979 <span class="comment">   options.  */</span>
<a name="l00980"></a>00980 
<a name="l00981"></a>00981 <span class="keyword">extern</span> <a class="code" href="structptid.html">ptid_t</a> <a class="code" href="target_8c.html#a0b3c864fc80f441532a0c3f9dad5eb3b">target_wait</a> (<a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a>, <span class="keyword">struct</span> <a class="code" href="structtarget__waitstatus.html">target_waitstatus</a> *<a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>,
<a name="l00982"></a>00982                            <span class="keywordtype">int</span> options);
<a name="l00983"></a>00983 
<a name="l00984"></a>00984 <span class="comment">/* Fetch at least register REGNO, or all regs if regno == -1.  No result.  */</span>
<a name="l00985"></a>00985 
<a name="l00986"></a>00986 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a5e70515af98ce168933d973817e91a01">target_fetch_registers</a> (<span class="keyword">struct</span> regcache *regcache, <span class="keywordtype">int</span> regno);
<a name="l00987"></a>00987 
<a name="l00988"></a>00988 <span class="comment">/* Store at least register REGNO, or all regs if REGNO == -1.</span>
<a name="l00989"></a>00989 <span class="comment">   It can store as many registers as it wants to, so target_prepare_to_store</span>
<a name="l00990"></a>00990 <span class="comment">   must have been previously called.  Calls error() if there are problems.  */</span>
<a name="l00991"></a>00991 
<a name="l00992"></a>00992 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#aff289e616f842c7a41461b455a23affa">target_store_registers</a> (<span class="keyword">struct</span> regcache *regcache, <span class="keywordtype">int</span> regs);
<a name="l00993"></a>00993 
<a name="l00994"></a>00994 <span class="comment">/* Get ready to modify the registers array.  On machines which store</span>
<a name="l00995"></a>00995 <span class="comment">   individual registers, this doesn&#39;t need to do anything.  On machines</span>
<a name="l00996"></a>00996 <span class="comment">   which store all the registers in one fell swoop, this makes sure</span>
<a name="l00997"></a>00997 <span class="comment">   that REGISTERS contains all the registers from the program being</span>
<a name="l00998"></a>00998 <span class="comment">   debugged.  */</span>
<a name="l00999"></a>00999 
<a name="l01000"></a><a class="code" href="target_8h.html#a32338483d0da2e4b96ebf3c408f9845e">01000</a> <span class="preprocessor">#define target_prepare_to_store(regcache)       \</span>
<a name="l01001"></a>01001 <span class="preprocessor">     (*current_target.to_prepare_to_store) (regcache)</span>
<a name="l01002"></a>01002 <span class="preprocessor"></span>
<a name="l01003"></a>01003 <span class="comment">/* Determine current address space of thread PTID.  */</span>
<a name="l01004"></a>01004 
<a name="l01005"></a>01005 <span class="keyword">struct </span>address_space *<a class="code" href="target_8c.html#a6401e4fc730df516607be550c4ecae7c">target_thread_address_space</a> (<a class="code" href="structptid.html">ptid_t</a>);
<a name="l01006"></a>01006 
<a name="l01007"></a>01007 <span class="comment">/* Implement the &quot;info proc&quot; command.  This returns one if the request</span>
<a name="l01008"></a>01008 <span class="comment">   was handled, and zero otherwise.  It can also throw an exception if</span>
<a name="l01009"></a>01009 <span class="comment">   an error was encountered while attempting to handle the</span>
<a name="l01010"></a>01010 <span class="comment">   request.  */</span>
<a name="l01011"></a>01011 
<a name="l01012"></a>01012 <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a568fa4b85be9cc666ccd51e66ae909c8">target_info_proc</a> (<span class="keywordtype">char</span> *, <span class="keyword">enum</span> <a class="code" href="defs_8h.html#a766e85723d7470eb8519ed31b1ef8bf4">info_proc_what</a>);
<a name="l01013"></a>01013 
<a name="l01014"></a>01014 <span class="comment">/* Returns true if this target can debug multiple processes</span>
<a name="l01015"></a>01015 <span class="comment">   simultaneously.  */</span>
<a name="l01016"></a>01016 
<a name="l01017"></a><a class="code" href="target_8h.html#ae36b29adf28de151d08955619a8de788">01017</a> <span class="preprocessor">#define target_supports_multi_process() \</span>
<a name="l01018"></a>01018 <span class="preprocessor">     (*current_target.to_supports_multi_process) ()</span>
<a name="l01019"></a>01019 <span class="preprocessor"></span>
<a name="l01020"></a>01020 <span class="comment">/* Returns true if this target can disable address space randomization.  */</span>
<a name="l01021"></a>01021 
<a name="l01022"></a>01022 <span class="keywordtype">int</span> <a class="code" href="target_8c.html#af84c02db65f3c8c1a988ca5ee8179248">target_supports_disable_randomization</a> (<span class="keywordtype">void</span>);
<a name="l01023"></a>01023 
<a name="l01024"></a>01024 <span class="comment">/* Returns true if this target can enable and disable tracepoints</span>
<a name="l01025"></a>01025 <span class="comment">   while a trace experiment is running.  */</span>
<a name="l01026"></a>01026 
<a name="l01027"></a><a class="code" href="target_8h.html#ab7943bd804233ce9d742037eb6398579">01027</a> <span class="preprocessor">#define target_supports_enable_disable_tracepoint() \</span>
<a name="l01028"></a>01028 <span class="preprocessor">  (*current_target.to_supports_enable_disable_tracepoint) ()</span>
<a name="l01029"></a>01029 <span class="preprocessor"></span>
<a name="l01030"></a><a class="code" href="target_8h.html#adc9a80e2e8bac1505844111ab9d2cb58">01030</a> <span class="preprocessor">#define target_supports_string_tracing() \</span>
<a name="l01031"></a>01031 <span class="preprocessor">  (*current_target.to_supports_string_tracing) ()</span>
<a name="l01032"></a>01032 <span class="preprocessor"></span>
<a name="l01033"></a>01033 <span class="comment">/* Returns true if this target can handle breakpoint conditions</span>
<a name="l01034"></a>01034 <span class="comment">   on its end.  */</span>
<a name="l01035"></a>01035 
<a name="l01036"></a><a class="code" href="target_8h.html#a029407c9baebfcab86e0488e2d75a2a0">01036</a> <span class="preprocessor">#define target_supports_evaluation_of_breakpoint_conditions() \</span>
<a name="l01037"></a>01037 <span class="preprocessor">  (*current_target.to_supports_evaluation_of_breakpoint_conditions) ()</span>
<a name="l01038"></a>01038 <span class="preprocessor"></span>
<a name="l01039"></a>01039 <span class="comment">/* Returns true if this target can handle breakpoint commands</span>
<a name="l01040"></a>01040 <span class="comment">   on its end.  */</span>
<a name="l01041"></a>01041 
<a name="l01042"></a><a class="code" href="target_8h.html#a0f238e36b27ab62c468bef80dd432273">01042</a> <span class="preprocessor">#define target_can_run_breakpoint_commands() \</span>
<a name="l01043"></a>01043 <span class="preprocessor">  (*current_target.to_can_run_breakpoint_commands) ()</span>
<a name="l01044"></a>01044 <span class="preprocessor"></span>
<a name="l01045"></a>01045 <span class="comment">/* Invalidate all target dcaches.  */</span>
<a name="l01046"></a>01046 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a819a6668299ae51c85ee5971a480b410">target_dcache_invalidate</a> (<span class="keywordtype">void</span>);
<a name="l01047"></a>01047 
<a name="l01048"></a>01048 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a394bfbed99bddd14b28ca9b6538292c2">target_read_string</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <span class="keywordtype">char</span> **, <span class="keywordtype">int</span>, <span class="keywordtype">int</span> *);
<a name="l01049"></a>01049 
<a name="l01050"></a>01050 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="exec_8h.html#ab268c3184bf49615e16de006a296a542">memaddr</a>, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *myaddr,
<a name="l01051"></a>01051                                ssize_t len);
<a name="l01052"></a>01052 
<a name="l01053"></a>01053 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a70ef9710e2d6f3ce33f4a776ce534423">target_read_stack</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="exec_8h.html#ab268c3184bf49615e16de006a296a542">memaddr</a>, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *myaddr, ssize_t len);
<a name="l01054"></a>01054 
<a name="l01055"></a>01055 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a7bd38b77fbf87c003396742f775dd2d4">target_write_memory</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="exec_8h.html#ab268c3184bf49615e16de006a296a542">memaddr</a>, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *myaddr,
<a name="l01056"></a>01056                                 ssize_t len);
<a name="l01057"></a>01057 
<a name="l01058"></a>01058 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#ad80d04b1968202e2a24951cf5e471397">target_write_raw_memory</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="exec_8h.html#ab268c3184bf49615e16de006a296a542">memaddr</a>, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *myaddr,
<a name="l01059"></a>01059                                     ssize_t len);
<a name="l01060"></a>01060 
<a name="l01061"></a>01061 <span class="comment">/* Fetches the target&#39;s memory map.  If one is found it is sorted</span>
<a name="l01062"></a>01062 <span class="comment">   and returned, after some consistency checking.  Otherwise, NULL</span>
<a name="l01063"></a>01063 <span class="comment">   is returned.  */</span>
<a name="l01064"></a>01064 <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a>(<a class="code" href="structmem__region.html">mem_region_s</a>) *target_memory_map (<span class="keywordtype">void</span>);
<a name="l01065"></a>01065 
<a name="l01066"></a>01066 <span class="comment">/* Erase the specified flash region.  */</span>
<a name="l01067"></a>01067 <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a9354f42361ca829d3dfdbca3d28c3059">target_flash_erase</a> (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> address, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> length);
<a name="l01068"></a>01068 
<a name="l01069"></a>01069 <span class="comment">/* Finish a sequence of flash operations.  */</span>
<a name="l01070"></a>01070 <span class="keywordtype">void</span> <a class="code" href="target_8c.html#ab76db9faabf2433f0d6cc645d25577c1">target_flash_done</a> (<span class="keywordtype">void</span>);
<a name="l01071"></a>01071 
<a name="l01072"></a>01072 <span class="comment">/* Describes a request for a memory write operation.  */</span>
<a name="l01073"></a><a class="code" href="structmemory__write__request.html">01073</a> <span class="keyword">struct </span><a class="code" href="structmemory__write__request.html">memory_write_request</a>
<a name="l01074"></a>01074   {
<a name="l01075"></a>01075     <span class="comment">/* Begining address that must be written.  */</span>
<a name="l01076"></a><a class="code" href="structmemory__write__request.html#a93e3e8f0902b14697813fb9695b1804f">01076</a>     <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structmemory__write__request.html#a93e3e8f0902b14697813fb9695b1804f">begin</a>;
<a name="l01077"></a>01077     <span class="comment">/* Past-the-end address.  */</span>
<a name="l01078"></a><a class="code" href="structmemory__write__request.html#a63fecef822eaec1a806020c27d719d5b">01078</a>     <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="structmemory__write__request.html#a63fecef822eaec1a806020c27d719d5b">end</a>;
<a name="l01079"></a>01079     <span class="comment">/* The data to write.  */</span>
<a name="l01080"></a><a class="code" href="structmemory__write__request.html#ac77d0cbd255d9ef6e5b40d9ce683b323">01080</a>     <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structmemory__write__request.html#ac77d0cbd255d9ef6e5b40d9ce683b323">data</a>;
<a name="l01081"></a>01081     <span class="comment">/* A callback baton for progress reporting for this request.  */</span>
<a name="l01082"></a><a class="code" href="structmemory__write__request.html#a2915ebcb50ff443e1affc914ef83b330">01082</a>     <span class="keywordtype">void</span> *<a class="code" href="structmemory__write__request.html#a2915ebcb50ff443e1affc914ef83b330">baton</a>;
<a name="l01083"></a>01083   };
<a name="l01084"></a><a class="code" href="target_8h.html#acd7e02caaa9f8bdbf2e7bf62025ca2f0">01084</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structmemory__write__request.html">memory_write_request</a> <a class="code" href="structmemory__write__request.html">memory_write_request_s</a>;
<a name="l01085"></a>01085 <a class="code" href="vec_8h.html#abc2d38563a8b5bed340654cf06060f11">DEF_VEC_O</a>(<a class="code" href="structmemory__write__request.html">memory_write_request_s</a>);
<a name="l01086"></a>01086 
<a name="l01087"></a>01087 <span class="comment">/* Enumeration specifying different flash preservation behaviour.  */</span>
<a name="l01088"></a><a class="code" href="target_8h.html#afbd923e79e880cf30b60385e1d99ad19">01088</a> <span class="keyword">enum</span> <a class="code" href="target_8h.html#afbd923e79e880cf30b60385e1d99ad19">flash_preserve_mode</a>
<a name="l01089"></a>01089   {
<a name="l01090"></a><a class="code" href="target_8h.html#afbd923e79e880cf30b60385e1d99ad19a0530e6006daf5a8a646f36bb06f9ee40">01090</a>     <a class="code" href="target_8h.html#afbd923e79e880cf30b60385e1d99ad19a0530e6006daf5a8a646f36bb06f9ee40">flash_preserve</a>,
<a name="l01091"></a><a class="code" href="target_8h.html#afbd923e79e880cf30b60385e1d99ad19a5ed9c2a2f8069935f28c5a6a1ed80e02">01091</a>     <a class="code" href="target_8h.html#afbd923e79e880cf30b60385e1d99ad19a5ed9c2a2f8069935f28c5a6a1ed80e02">flash_discard</a>
<a name="l01092"></a>01092   };
<a name="l01093"></a>01093 
<a name="l01094"></a>01094 <span class="comment">/* Write several memory blocks at once.  This version can be more</span>
<a name="l01095"></a>01095 <span class="comment">   efficient than making several calls to target_write_memory, in</span>
<a name="l01096"></a>01096 <span class="comment">   particular because it can optimize accesses to flash memory.</span>
<a name="l01097"></a>01097 <span class="comment"></span>
<a name="l01098"></a>01098 <span class="comment">   Moreover, this is currently the only memory access function in gdb</span>
<a name="l01099"></a>01099 <span class="comment">   that supports writing to flash memory, and it should be used for</span>
<a name="l01100"></a>01100 <span class="comment">   all cases where access to flash memory is desirable.</span>
<a name="l01101"></a>01101 <span class="comment"></span>
<a name="l01102"></a>01102 <span class="comment">   REQUESTS is the vector (see vec.h) of memory_write_request.</span>
<a name="l01103"></a>01103 <span class="comment">   PRESERVE_FLASH_P indicates what to do with blocks which must be</span>
<a name="l01104"></a>01104 <span class="comment">     erased, but not completely rewritten.</span>
<a name="l01105"></a>01105 <span class="comment">   PROGRESS_CB is a function that will be periodically called to provide</span>
<a name="l01106"></a>01106 <span class="comment">     feedback to user.  It will be called with the baton corresponding</span>
<a name="l01107"></a>01107 <span class="comment">     to the request currently being written.  It may also be called</span>
<a name="l01108"></a>01108 <span class="comment">     with a NULL baton, when preserved flash sectors are being rewritten.</span>
<a name="l01109"></a>01109 <span class="comment"></span>
<a name="l01110"></a>01110 <span class="comment">   The function returns 0 on success, and error otherwise.  */</span>
<a name="l01111"></a>01111 <span class="keywordtype">int</span> <a class="code" href="target-memory_8c.html#a638abfa5d30a19e9879ba8ccff803304">target_write_memory_blocks</a> (<a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a>(<a class="code" href="structmemory__write__request.html">memory_write_request_s</a>) *requests,
<a name="l01112"></a>01112                                 <span class="keyword">enum</span> <a class="code" href="target_8h.html#afbd923e79e880cf30b60385e1d99ad19">flash_preserve_mode</a> preserve_flash_p,
<a name="l01113"></a>01113                                 <span class="keywordtype">void</span> (*progress_cb) (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a>, <span class="keywordtype">void</span> *));
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 <span class="comment">/* Print a line about the current target.  */</span>
<a name="l01116"></a>01116 
<a name="l01117"></a><a class="code" href="target_8h.html#a2d47f1f2af854b3401805706e8d0aae7">01117</a> <span class="preprocessor">#define target_files_info()     \</span>
<a name="l01118"></a>01118 <span class="preprocessor">     (*current_target.to_files_info) (&amp;current_target)</span>
<a name="l01119"></a>01119 <span class="preprocessor"></span>
<a name="l01120"></a>01120 <span class="comment">/* Insert a breakpoint at address BP_TGT-&gt;placed_address in the target</span>
<a name="l01121"></a>01121 <span class="comment">   machine.  Result is 0 for success, non-zero for error.  */</span>
<a name="l01122"></a>01122 
<a name="l01123"></a>01123 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a4a288f6e92a74cf83fdae9d6ac05cd80">target_insert_breakpoint</a> (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l01124"></a>01124                                      <span class="keyword">struct</span> <a class="code" href="structbp__target__info.html">bp_target_info</a> *bp_tgt);
<a name="l01125"></a>01125 
<a name="l01126"></a>01126 <span class="comment">/* Remove a breakpoint at address BP_TGT-&gt;placed_address in the target</span>
<a name="l01127"></a>01127 <span class="comment">   machine.  Result is 0 for success, non-zero for error.  */</span>
<a name="l01128"></a>01128 
<a name="l01129"></a>01129 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a9c2f1e0aacdecef04948e3714a934b70">target_remove_breakpoint</a> (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l01130"></a>01130                                      <span class="keyword">struct</span> <a class="code" href="structbp__target__info.html">bp_target_info</a> *bp_tgt);
<a name="l01131"></a>01131 
<a name="l01132"></a>01132 <span class="comment">/* Initialize the terminal settings we record for the inferior,</span>
<a name="l01133"></a>01133 <span class="comment">   before we actually run the inferior.  */</span>
<a name="l01134"></a>01134 
<a name="l01135"></a><a class="code" href="target_8h.html#abc203d114dec4f2b057c8e9f7a960461">01135</a> <span class="preprocessor">#define target_terminal_init() \</span>
<a name="l01136"></a>01136 <span class="preprocessor">     (*current_target.to_terminal_init) ()</span>
<a name="l01137"></a>01137 <span class="preprocessor"></span>
<a name="l01138"></a>01138 <span class="comment">/* Put the inferior&#39;s terminal settings into effect.</span>
<a name="l01139"></a>01139 <span class="comment">   This is preparation for starting or resuming the inferior.  */</span>
<a name="l01140"></a>01140 
<a name="l01141"></a>01141 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#aab397975a1893898dcd07c8ed9aca04c">target_terminal_inferior</a> (<span class="keywordtype">void</span>);
<a name="l01142"></a>01142 
<a name="l01143"></a>01143 <span class="comment">/* Put some of our terminal settings into effect,</span>
<a name="l01144"></a>01144 <span class="comment">   enough to get proper results from our output,</span>
<a name="l01145"></a>01145 <span class="comment">   but do not change into or out of RAW mode</span>
<a name="l01146"></a>01146 <span class="comment">   so that no input is discarded.</span>
<a name="l01147"></a>01147 <span class="comment"></span>
<a name="l01148"></a>01148 <span class="comment">   After doing this, either terminal_ours or terminal_inferior</span>
<a name="l01149"></a>01149 <span class="comment">   should be called to get back to a normal state of affairs.  */</span>
<a name="l01150"></a>01150 
<a name="l01151"></a><a class="code" href="target_8h.html#a7369fcccf2537d98bda58de2a655e1d2">01151</a> <span class="preprocessor">#define target_terminal_ours_for_output() \</span>
<a name="l01152"></a>01152 <span class="preprocessor">     (*current_target.to_terminal_ours_for_output) ()</span>
<a name="l01153"></a>01153 <span class="preprocessor"></span>
<a name="l01154"></a>01154 <span class="comment">/* Put our terminal settings into effect.</span>
<a name="l01155"></a>01155 <span class="comment">   First record the inferior&#39;s terminal settings</span>
<a name="l01156"></a>01156 <span class="comment">   so they can be restored properly later.  */</span>
<a name="l01157"></a>01157 
<a name="l01158"></a><a class="code" href="target_8h.html#a7128a26aa3c50e663201b4a6633636fe">01158</a> <span class="preprocessor">#define target_terminal_ours() \</span>
<a name="l01159"></a>01159 <span class="preprocessor">     (*current_target.to_terminal_ours) ()</span>
<a name="l01160"></a>01160 <span class="preprocessor"></span>
<a name="l01161"></a>01161 <span class="comment">/* Save our terminal settings.</span>
<a name="l01162"></a>01162 <span class="comment">   This is called from TUI after entering or leaving the curses</span>
<a name="l01163"></a>01163 <span class="comment">   mode.  Since curses modifies our terminal this call is here</span>
<a name="l01164"></a>01164 <span class="comment">   to take this change into account.  */</span>
<a name="l01165"></a>01165 
<a name="l01166"></a><a class="code" href="target_8h.html#a2595608836281f69815d9493f8660f93">01166</a> <span class="preprocessor">#define target_terminal_save_ours() \</span>
<a name="l01167"></a>01167 <span class="preprocessor">     (*current_target.to_terminal_save_ours) ()</span>
<a name="l01168"></a>01168 <span class="preprocessor"></span>
<a name="l01169"></a>01169 <span class="comment">/* Print useful information about our terminal status, if such a thing</span>
<a name="l01170"></a>01170 <span class="comment">   exists.  */</span>
<a name="l01171"></a>01171 
<a name="l01172"></a><a class="code" href="target_8h.html#a3fa293f39df0b6104e5e7b496d7a1907">01172</a> <span class="preprocessor">#define target_terminal_info(arg, from_tty) \</span>
<a name="l01173"></a>01173 <span class="preprocessor">     (*current_target.to_terminal_info) (arg, from_tty)</span>
<a name="l01174"></a>01174 <span class="preprocessor"></span>
<a name="l01175"></a>01175 <span class="comment">/* Kill the inferior process.   Make it go away.  */</span>
<a name="l01176"></a>01176 
<a name="l01177"></a>01177 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a637ca4b8e71c3f9696c1e744c7ee0978">target_kill</a> (<span class="keywordtype">void</span>);
<a name="l01178"></a>01178 
<a name="l01179"></a>01179 <span class="comment">/* Load an executable file into the target process.  This is expected</span>
<a name="l01180"></a>01180 <span class="comment">   to not only bring new code into the target process, but also to</span>
<a name="l01181"></a>01181 <span class="comment">   update GDB&#39;s symbol tables to match.</span>
<a name="l01182"></a>01182 <span class="comment"></span>
<a name="l01183"></a>01183 <span class="comment">   ARG contains command-line arguments, to be broken down with</span>
<a name="l01184"></a>01184 <span class="comment">   buildargv ().  The first non-switch argument is the filename to</span>
<a name="l01185"></a>01185 <span class="comment">   load, FILE; the second is a number (as parsed by strtoul (..., ...,</span>
<a name="l01186"></a>01186 <span class="comment">   0)), which is an offset to apply to the load addresses of FILE&#39;s</span>
<a name="l01187"></a>01187 <span class="comment">   sections.  The target may define switches, or other non-switch</span>
<a name="l01188"></a>01188 <span class="comment">   arguments, as it pleases.  */</span>
<a name="l01189"></a>01189 
<a name="l01190"></a>01190 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a1883d1a763cd21cbe88a637890c1f7d6">target_load</a> (<span class="keywordtype">char</span> *arg, <span class="keywordtype">int</span> from_tty);
<a name="l01191"></a>01191 
<a name="l01192"></a>01192 <span class="comment">/* Start an inferior process and set inferior_ptid to its pid.</span>
<a name="l01193"></a>01193 <span class="comment">   EXEC_FILE is the file to run.</span>
<a name="l01194"></a>01194 <span class="comment">   ALLARGS is a string containing the arguments to the program.</span>
<a name="l01195"></a>01195 <span class="comment">   ENV is the environment vector to pass.  Errors reported with error().</span>
<a name="l01196"></a>01196 <span class="comment">   On VxWorks and various standalone systems, we ignore exec_file.  */</span>
<a name="l01197"></a>01197 
<a name="l01198"></a>01198 <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a0651e9cd6e56c16d36a13ed2868e897f">target_create_inferior</a> (<span class="keywordtype">char</span> *exec_file, <span class="keywordtype">char</span> *args,
<a name="l01199"></a>01199                              <span class="keywordtype">char</span> **env, <span class="keywordtype">int</span> from_tty);
<a name="l01200"></a>01200 
<a name="l01201"></a>01201 <span class="comment">/* Some targets (such as ttrace-based HPUX) don&#39;t allow us to request</span>
<a name="l01202"></a>01202 <span class="comment">   notification of inferior events such as fork and vork immediately</span>
<a name="l01203"></a>01203 <span class="comment">   after the inferior is created.  (This because of how gdb gets an</span>
<a name="l01204"></a>01204 <span class="comment">   inferior created via invoking a shell to do it.  In such a scenario,</span>
<a name="l01205"></a>01205 <span class="comment">   if the shell init file has commands in it, the shell will fork and</span>
<a name="l01206"></a>01206 <span class="comment">   exec for each of those commands, and we will see each such fork</span>
<a name="l01207"></a>01207 <span class="comment">   event.  Very bad.)</span>
<a name="l01208"></a>01208 <span class="comment"></span>
<a name="l01209"></a>01209 <span class="comment">   Such targets will supply an appropriate definition for this function.  */</span>
<a name="l01210"></a>01210 
<a name="l01211"></a><a class="code" href="target_8h.html#ad62e80b0284c2a2eba328d5c3930c27d">01211</a> <span class="preprocessor">#define target_post_startup_inferior(ptid) \</span>
<a name="l01212"></a>01212 <span class="preprocessor">     (*current_target.to_post_startup_inferior) (ptid)</span>
<a name="l01213"></a>01213 <span class="preprocessor"></span>
<a name="l01214"></a>01214 <span class="comment">/* On some targets, we can catch an inferior fork or vfork event when</span>
<a name="l01215"></a>01215 <span class="comment">   it occurs.  These functions insert/remove an already-created</span>
<a name="l01216"></a>01216 <span class="comment">   catchpoint for such events.  They return  0 for success, 1 if the</span>
<a name="l01217"></a>01217 <span class="comment">   catchpoint type is not supported and -1 for failure.  */</span>
<a name="l01218"></a>01218 
<a name="l01219"></a><a class="code" href="target_8h.html#a9782e351c10752c82ce8b3722be2e320">01219</a> <span class="preprocessor">#define target_insert_fork_catchpoint(pid) \</span>
<a name="l01220"></a>01220 <span class="preprocessor">     (*current_target.to_insert_fork_catchpoint) (pid)</span>
<a name="l01221"></a>01221 <span class="preprocessor"></span>
<a name="l01222"></a><a class="code" href="target_8h.html#a9d60f2a2f608581ce9389d3965153e66">01222</a> <span class="preprocessor">#define target_remove_fork_catchpoint(pid) \</span>
<a name="l01223"></a>01223 <span class="preprocessor">     (*current_target.to_remove_fork_catchpoint) (pid)</span>
<a name="l01224"></a>01224 <span class="preprocessor"></span>
<a name="l01225"></a><a class="code" href="target_8h.html#ad70644ac4dd1c9aa3966af86488a2b77">01225</a> <span class="preprocessor">#define target_insert_vfork_catchpoint(pid) \</span>
<a name="l01226"></a>01226 <span class="preprocessor">     (*current_target.to_insert_vfork_catchpoint) (pid)</span>
<a name="l01227"></a>01227 <span class="preprocessor"></span>
<a name="l01228"></a><a class="code" href="target_8h.html#a0097bd16d085097d4a564e51e2a5954e">01228</a> <span class="preprocessor">#define target_remove_vfork_catchpoint(pid) \</span>
<a name="l01229"></a>01229 <span class="preprocessor">     (*current_target.to_remove_vfork_catchpoint) (pid)</span>
<a name="l01230"></a>01230 <span class="preprocessor"></span>
<a name="l01231"></a>01231 <span class="comment">/* If the inferior forks or vforks, this function will be called at</span>
<a name="l01232"></a>01232 <span class="comment">   the next resume in order to perform any bookkeeping and fiddling</span>
<a name="l01233"></a>01233 <span class="comment">   necessary to continue debugging either the parent or child, as</span>
<a name="l01234"></a>01234 <span class="comment">   requested, and releasing the other.  Information about the fork</span>
<a name="l01235"></a>01235 <span class="comment">   or vfork event is available via get_last_target_status ().</span>
<a name="l01236"></a>01236 <span class="comment">   This function returns 1 if the inferior should not be resumed</span>
<a name="l01237"></a>01237 <span class="comment">   (i.e. there is another event pending).  */</span>
<a name="l01238"></a>01238 
<a name="l01239"></a>01239 <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a3d12f4895bf6696a90cc2115c3e198b6">target_follow_fork</a> (<span class="keywordtype">int</span> follow_child, <span class="keywordtype">int</span> detach_fork);
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 <span class="comment">/* On some targets, we can catch an inferior exec event when it</span>
<a name="l01242"></a>01242 <span class="comment">   occurs.  These functions insert/remove an already-created</span>
<a name="l01243"></a>01243 <span class="comment">   catchpoint for such events.  They return  0 for success, 1 if the</span>
<a name="l01244"></a>01244 <span class="comment">   catchpoint type is not supported and -1 for failure.  */</span>
<a name="l01245"></a>01245 
<a name="l01246"></a><a class="code" href="target_8h.html#a39ad77523ddc4bcbebd04595a594e7b8">01246</a> <span class="preprocessor">#define target_insert_exec_catchpoint(pid) \</span>
<a name="l01247"></a>01247 <span class="preprocessor">     (*current_target.to_insert_exec_catchpoint) (pid)</span>
<a name="l01248"></a>01248 <span class="preprocessor"></span>
<a name="l01249"></a><a class="code" href="target_8h.html#ab49f8066cb9e08271f3af036cdf06ea5">01249</a> <span class="preprocessor">#define target_remove_exec_catchpoint(pid) \</span>
<a name="l01250"></a>01250 <span class="preprocessor">     (*current_target.to_remove_exec_catchpoint) (pid)</span>
<a name="l01251"></a>01251 <span class="preprocessor"></span>
<a name="l01252"></a>01252 <span class="comment">/* Syscall catch.</span>
<a name="l01253"></a>01253 <span class="comment"></span>
<a name="l01254"></a>01254 <span class="comment">   NEEDED is nonzero if any syscall catch (of any kind) is requested.</span>
<a name="l01255"></a>01255 <span class="comment">   If NEEDED is zero, it means the target can disable the mechanism to</span>
<a name="l01256"></a>01256 <span class="comment">   catch system calls because there are no more catchpoints of this type.</span>
<a name="l01257"></a>01257 <span class="comment"></span>
<a name="l01258"></a>01258 <span class="comment">   ANY_COUNT is nonzero if a generic (filter-less) syscall catch is</span>
<a name="l01259"></a>01259 <span class="comment">   being requested.  In this case, both TABLE_SIZE and TABLE should</span>
<a name="l01260"></a>01260 <span class="comment">   be ignored.</span>
<a name="l01261"></a>01261 <span class="comment"></span>
<a name="l01262"></a>01262 <span class="comment">   TABLE_SIZE is the number of elements in TABLE.  It only matters if</span>
<a name="l01263"></a>01263 <span class="comment">   ANY_COUNT is zero.</span>
<a name="l01264"></a>01264 <span class="comment"></span>
<a name="l01265"></a>01265 <span class="comment">   TABLE is an array of ints, indexed by syscall number.  An element in</span>
<a name="l01266"></a>01266 <span class="comment">   this array is nonzero if that syscall should be caught.  This argument</span>
<a name="l01267"></a>01267 <span class="comment">   only matters if ANY_COUNT is zero.</span>
<a name="l01268"></a>01268 <span class="comment"></span>
<a name="l01269"></a>01269 <span class="comment">   Return 0 for success, 1 if syscall catchpoints are not supported or -1</span>
<a name="l01270"></a>01270 <span class="comment">   for failure.  */</span>
<a name="l01271"></a>01271 
<a name="l01272"></a><a class="code" href="target_8h.html#a1cf997cc6a54628fd3d4e3e9a5174268">01272</a> <span class="preprocessor">#define target_set_syscall_catchpoint(pid, needed, any_count, table_size, table) \</span>
<a name="l01273"></a>01273 <span class="preprocessor">     (*current_target.to_set_syscall_catchpoint) (pid, needed, any_count, \</span>
<a name="l01274"></a>01274 <span class="preprocessor">                                                  table_size, table)</span>
<a name="l01275"></a>01275 <span class="preprocessor"></span>
<a name="l01276"></a>01276 <span class="comment">/* Returns TRUE if PID has exited.  And, also sets EXIT_STATUS to the</span>
<a name="l01277"></a>01277 <span class="comment">   exit code of PID, if any.  */</span>
<a name="l01278"></a>01278 
<a name="l01279"></a><a class="code" href="target_8h.html#ac4773574fbbf08a0b6a95c920af3d671">01279</a> <span class="preprocessor">#define target_has_exited(pid,wait_status,exit_status) \</span>
<a name="l01280"></a>01280 <span class="preprocessor">     (*current_target.to_has_exited) (pid,wait_status,exit_status)</span>
<a name="l01281"></a>01281 <span class="preprocessor"></span>
<a name="l01282"></a>01282 <span class="comment">/* The debugger has completed a blocking wait() call.  There is now</span>
<a name="l01283"></a>01283 <span class="comment">   some process event that must be processed.  This function should</span>
<a name="l01284"></a>01284 <span class="comment">   be defined by those targets that require the debugger to perform</span>
<a name="l01285"></a>01285 <span class="comment">   cleanup or internal state changes in response to the process event.  */</span>
<a name="l01286"></a>01286 
<a name="l01287"></a>01287 <span class="comment">/* The inferior process has died.  Do what is right.  */</span>
<a name="l01288"></a>01288 
<a name="l01289"></a>01289 <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a431ec8acf68f0b609e306fea2297a08f">target_mourn_inferior</a> (<span class="keywordtype">void</span>);
<a name="l01290"></a>01290 
<a name="l01291"></a>01291 <span class="comment">/* Does target have enough data to do a run or attach command? */</span>
<a name="l01292"></a>01292 
<a name="l01293"></a><a class="code" href="target_8h.html#a3c4e5f34cf395eb36ae58b0c47fd1c53">01293</a> <span class="preprocessor">#define target_can_run(t) \</span>
<a name="l01294"></a>01294 <span class="preprocessor">     ((t)-&gt;to_can_run) ()</span>
<a name="l01295"></a>01295 <span class="preprocessor"></span>
<a name="l01296"></a>01296 <span class="comment">/* Set list of signals to be handled in the target.</span>
<a name="l01297"></a>01297 <span class="comment"></span>
<a name="l01298"></a>01298 <span class="comment">   PASS_SIGNALS is an array of size NSIG, indexed by target signal number</span>
<a name="l01299"></a>01299 <span class="comment">   (enum gdb_signal).  For every signal whose entry in this array is</span>
<a name="l01300"></a>01300 <span class="comment">   non-zero, the target is allowed -but not required- to skip reporting</span>
<a name="l01301"></a>01301 <span class="comment">   arrival of the signal to the GDB core by returning from target_wait,</span>
<a name="l01302"></a>01302 <span class="comment">   and to pass the signal directly to the inferior instead.</span>
<a name="l01303"></a>01303 <span class="comment"></span>
<a name="l01304"></a>01304 <span class="comment">   However, if the target is hardware single-stepping a thread that is</span>
<a name="l01305"></a>01305 <span class="comment">   about to receive a signal, it needs to be reported in any case, even</span>
<a name="l01306"></a>01306 <span class="comment">   if mentioned in a previous target_pass_signals call.   */</span>
<a name="l01307"></a>01307 
<a name="l01308"></a>01308 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#ad2cfd8380fdc99314418e46e23c4d31e">target_pass_signals</a> (<span class="keywordtype">int</span> nsig, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pass_signals);
<a name="l01309"></a>01309 
<a name="l01310"></a>01310 <span class="comment">/* Set list of signals the target may pass to the inferior.  This</span>
<a name="l01311"></a>01311 <span class="comment">   directly maps to the &quot;handle SIGNAL pass/nopass&quot; setting.</span>
<a name="l01312"></a>01312 <span class="comment"></span>
<a name="l01313"></a>01313 <span class="comment">   PROGRAM_SIGNALS is an array of size NSIG, indexed by target signal</span>
<a name="l01314"></a>01314 <span class="comment">   number (enum gdb_signal).  For every signal whose entry in this</span>
<a name="l01315"></a>01315 <span class="comment">   array is non-zero, the target is allowed to pass the signal to the</span>
<a name="l01316"></a>01316 <span class="comment">   inferior.  Signals not present in the array shall be silently</span>
<a name="l01317"></a>01317 <span class="comment">   discarded.  This does not influence whether to pass signals to the</span>
<a name="l01318"></a>01318 <span class="comment">   inferior as a result of a target_resume call.  This is useful in</span>
<a name="l01319"></a>01319 <span class="comment">   scenarios where the target needs to decide whether to pass or not a</span>
<a name="l01320"></a>01320 <span class="comment">   signal to the inferior without GDB core involvement, such as for</span>
<a name="l01321"></a>01321 <span class="comment">   example, when detaching (as threads may have been suspended with</span>
<a name="l01322"></a>01322 <span class="comment">   pending signals not reported to GDB).  */</span>
<a name="l01323"></a>01323 
<a name="l01324"></a>01324 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#acd3b4089471faa7cda9210303da650cb">target_program_signals</a> (<span class="keywordtype">int</span> nsig, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *program_signals);
<a name="l01325"></a>01325 
<a name="l01326"></a>01326 <span class="comment">/* Check to see if a thread is still alive.  */</span>
<a name="l01327"></a>01327 
<a name="l01328"></a>01328 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#af6aa67c48ec6acc60972d699fee886a2">target_thread_alive</a> (<a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a>);
<a name="l01329"></a>01329 
<a name="l01330"></a>01330 <span class="comment">/* Query for new threads and add them to the thread list.  */</span>
<a name="l01331"></a>01331 
<a name="l01332"></a>01332 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#af3c6bd72cdea7610b1894fff87e1be22">target_find_new_threads</a> (<span class="keywordtype">void</span>);
<a name="l01333"></a>01333 
<a name="l01334"></a>01334 <span class="comment">/* Make target stop in a continuable fashion.  (For instance, under</span>
<a name="l01335"></a>01335 <span class="comment">   Unix, this should act like SIGSTOP).  This function is normally</span>
<a name="l01336"></a>01336 <span class="comment">   used by GUIs to implement a stop button.  */</span>
<a name="l01337"></a>01337 
<a name="l01338"></a>01338 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#aa853c4b246e9b51f98345775fc29163a">target_stop</a> (<a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a>);
<a name="l01339"></a>01339 
<a name="l01340"></a>01340 <span class="comment">/* Send the specified COMMAND to the target&#39;s monitor</span>
<a name="l01341"></a>01341 <span class="comment">   (shell,interpreter) for execution.  The result of the query is</span>
<a name="l01342"></a>01342 <span class="comment">   placed in OUTBUF.  */</span>
<a name="l01343"></a>01343 
<a name="l01344"></a><a class="code" href="target_8h.html#a4921f3aa7ab133b17d7ba523d77f4a40">01344</a> <span class="preprocessor">#define target_rcmd(command, outbuf) \</span>
<a name="l01345"></a>01345 <span class="preprocessor">     (*current_target.to_rcmd) (command, outbuf)</span>
<a name="l01346"></a>01346 <span class="preprocessor"></span>
<a name="l01347"></a>01347 
<a name="l01348"></a>01348 <span class="comment">/* Does the target include all of memory, or only part of it?  This</span>
<a name="l01349"></a>01349 <span class="comment">   determines whether we look up the target chain for other parts of</span>
<a name="l01350"></a>01350 <span class="comment">   memory if this target can&#39;t satisfy a request.  */</span>
<a name="l01351"></a>01351 
<a name="l01352"></a>01352 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#acc50cecfe50c5da8615aaca21c91d469">target_has_all_memory_1</a> (<span class="keywordtype">void</span>);
<a name="l01353"></a><a class="code" href="target_8h.html#a73f65908622417cc9121803187765c56">01353</a> <span class="preprocessor">#define target_has_all_memory target_has_all_memory_1 ()</span>
<a name="l01354"></a>01354 <span class="preprocessor"></span>
<a name="l01355"></a>01355 <span class="comment">/* Does the target include memory?  (Dummy targets don&#39;t.)  */</span>
<a name="l01356"></a>01356 
<a name="l01357"></a>01357 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a60b5643306bf12f5fc90837ed3b0d4d9">target_has_memory_1</a> (<span class="keywordtype">void</span>);
<a name="l01358"></a><a class="code" href="target_8h.html#a11594fd2ccf6b8e01c756c78335185ee">01358</a> <span class="preprocessor">#define target_has_memory target_has_memory_1 ()</span>
<a name="l01359"></a>01359 <span class="preprocessor"></span>
<a name="l01360"></a>01360 <span class="comment">/* Does the target have a stack?  (Exec files don&#39;t, VxWorks doesn&#39;t, until</span>
<a name="l01361"></a>01361 <span class="comment">   we start a process.)  */</span>
<a name="l01362"></a>01362 
<a name="l01363"></a>01363 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a22b4848c02f06f45008df8a761a21e0b">target_has_stack_1</a> (<span class="keywordtype">void</span>);
<a name="l01364"></a><a class="code" href="target_8h.html#a3ca2aede43425f44535225aa4a2c2724">01364</a> <span class="preprocessor">#define target_has_stack target_has_stack_1 ()</span>
<a name="l01365"></a>01365 <span class="preprocessor"></span>
<a name="l01366"></a>01366 <span class="comment">/* Does the target have registers?  (Exec files don&#39;t.)  */</span>
<a name="l01367"></a>01367 
<a name="l01368"></a>01368 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#ad1bdb9144ad0e76ea335eaf4244177e3">target_has_registers_1</a> (<span class="keywordtype">void</span>);
<a name="l01369"></a><a class="code" href="target_8h.html#aa9a1009541e63ce36c030b1bd55d292d">01369</a> <span class="preprocessor">#define target_has_registers target_has_registers_1 ()</span>
<a name="l01370"></a>01370 <span class="preprocessor"></span>
<a name="l01371"></a>01371 <span class="comment">/* Does the target have execution?  Can we make it jump (through</span>
<a name="l01372"></a>01372 <span class="comment">   hoops), or pop its stack a few times?  This means that the current</span>
<a name="l01373"></a>01373 <span class="comment">   target is currently executing; for some targets, that&#39;s the same as</span>
<a name="l01374"></a>01374 <span class="comment">   whether or not the target is capable of execution, but there are</span>
<a name="l01375"></a>01375 <span class="comment">   also targets which can be current while not executing.  In that</span>
<a name="l01376"></a>01376 <span class="comment">   case this will become true after target_create_inferior or</span>
<a name="l01377"></a>01377 <span class="comment">   target_attach.  */</span>
<a name="l01378"></a>01378 
<a name="l01379"></a>01379 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#abe50ab9e32c2ce3df938a4ff595f000a">target_has_execution_1</a> (<a class="code" href="structptid.html">ptid_t</a>);
<a name="l01380"></a>01380 
<a name="l01381"></a>01381 <span class="comment">/* Like target_has_execution_1, but always passes inferior_ptid.  */</span>
<a name="l01382"></a>01382 
<a name="l01383"></a>01383 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a3448dd8048051829048ed4607e1997bd">target_has_execution_current</a> (<span class="keywordtype">void</span>);
<a name="l01384"></a>01384 
<a name="l01385"></a><a class="code" href="target_8h.html#a85885df22f7c1304269eaba1e1d618b7">01385</a> <span class="preprocessor">#define target_has_execution target_has_execution_current ()</span>
<a name="l01386"></a>01386 <span class="preprocessor"></span>
<a name="l01387"></a>01387 <span class="comment">/* Default implementations for process_stratum targets.  Return true</span>
<a name="l01388"></a>01388 <span class="comment">   if there&#39;s a selected inferior, false otherwise.  */</span>
<a name="l01389"></a>01389 
<a name="l01390"></a>01390 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a10da99f8e069b99c494f815e1810949d">default_child_has_all_memory</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops);
<a name="l01391"></a>01391 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#aaf12ba7615214b0307655baede5fd077">default_child_has_memory</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops);
<a name="l01392"></a>01392 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a72b1831a9207951779fa14b3341fc7da">default_child_has_stack</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops);
<a name="l01393"></a>01393 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a9caf934828f8d8e58c0a7d9608a3d26b">default_child_has_registers</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops);
<a name="l01394"></a>01394 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#ada0387938d543483e0417f498370d88d">default_child_has_execution</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *ops,
<a name="l01395"></a>01395                                         <a class="code" href="structptid.html">ptid_t</a> the_ptid);
<a name="l01396"></a>01396 
<a name="l01397"></a>01397 <span class="comment">/* Can the target support the debugger control of thread execution?</span>
<a name="l01398"></a>01398 <span class="comment">   Can it lock the thread scheduler?  */</span>
<a name="l01399"></a>01399 
<a name="l01400"></a><a class="code" href="target_8h.html#adf9ae5f3934f575b315ea7528be25ff2">01400</a> <span class="preprocessor">#define target_can_lock_scheduler \</span>
<a name="l01401"></a>01401 <span class="preprocessor">     (current_target.to_has_thread_control &amp; tc_schedlock)</span>
<a name="l01402"></a>01402 <span class="preprocessor"></span>
<a name="l01403"></a>01403 <span class="comment">/* Should the target enable async mode if it is supported?  Temporary</span>
<a name="l01404"></a>01404 <span class="comment">   cludge until async mode is a strict superset of sync mode.  */</span>
<a name="l01405"></a>01405 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#ac7fe303ce615185d54578ce37612da91">target_async_permitted</a>;
<a name="l01406"></a>01406 
<a name="l01407"></a>01407 <span class="comment">/* Can the target support asynchronous execution?  */</span>
<a name="l01408"></a><a class="code" href="target_8h.html#a2b6015c90130096b2e9757013e49c1e9">01408</a> <span class="preprocessor">#define target_can_async_p() (current_target.to_can_async_p ())</span>
<a name="l01409"></a>01409 <span class="preprocessor"></span>
<a name="l01410"></a>01410 <span class="comment">/* Is the target in asynchronous execution mode?  */</span>
<a name="l01411"></a><a class="code" href="target_8h.html#a9024f679a83bd653c5b0183e2d1177e9">01411</a> <span class="preprocessor">#define target_is_async_p() (current_target.to_is_async_p ())</span>
<a name="l01412"></a>01412 <span class="preprocessor"></span>
<a name="l01413"></a>01413 <span class="keywordtype">int</span> <a class="code" href="target_8c.html#ad5b023f462398607f97d5ef4f0cbb964">target_supports_non_stop</a> (<span class="keywordtype">void</span>);
<a name="l01414"></a>01414 
<a name="l01415"></a>01415 <span class="comment">/* Put the target in async mode with the specified callback function.  */</span>
<a name="l01416"></a><a class="code" href="target_8h.html#acf7fa05a2613fe628f2b1b82c85b0719">01416</a> <span class="preprocessor">#define target_async(CALLBACK,CONTEXT) \</span>
<a name="l01417"></a>01417 <span class="preprocessor">     (current_target.to_async ((CALLBACK), (CONTEXT)))</span>
<a name="l01418"></a>01418 <span class="preprocessor"></span>
<a name="l01419"></a><a class="code" href="target_8h.html#ac99668403d884c63c58e3927696c3a47">01419</a> <span class="preprocessor">#define target_execution_direction() \</span>
<a name="l01420"></a>01420 <span class="preprocessor">  (current_target.to_execution_direction ())</span>
<a name="l01421"></a>01421 <span class="preprocessor"></span>
<a name="l01422"></a>01422 <span class="comment">/* Converts a process id to a string.  Usually, the string just contains</span>
<a name="l01423"></a>01423 <span class="comment">   `process xyz&#39;, but on some systems it may contain</span>
<a name="l01424"></a>01424 <span class="comment">   `process xyz thread abc&#39;.  */</span>
<a name="l01425"></a>01425 
<a name="l01426"></a>01426 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="target_8c.html#a25ebd5fbc0b84bf9b914f7a21bfa6f7b">target_pid_to_str</a> (<a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a>);
<a name="l01427"></a>01427 
<a name="l01428"></a>01428 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="target_8c.html#aa0e232d9b9de56e922b988294faa05d6">normal_pid_to_str</a> (<a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a>);
<a name="l01429"></a>01429 
<a name="l01430"></a>01430 <span class="comment">/* Return a short string describing extra information about PID,</span>
<a name="l01431"></a>01431 <span class="comment">   e.g. &quot;sleeping&quot;, &quot;runnable&quot;, &quot;running on LWP 3&quot;.  Null return value</span>
<a name="l01432"></a>01432 <span class="comment">   is okay.  */</span>
<a name="l01433"></a>01433 
<a name="l01434"></a><a class="code" href="target_8h.html#a1b6b05a6033946b1ad64a9ff1996fe63">01434</a> <span class="preprocessor">#define target_extra_thread_info(TP) \</span>
<a name="l01435"></a>01435 <span class="preprocessor">     (current_target.to_extra_thread_info (TP))</span>
<a name="l01436"></a>01436 <span class="preprocessor"></span>
<a name="l01437"></a>01437 <span class="comment">/* Return the thread&#39;s name.  A NULL result means that the target</span>
<a name="l01438"></a>01438 <span class="comment">   could not determine this thread&#39;s name.  */</span>
<a name="l01439"></a>01439 
<a name="l01440"></a>01440 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="target_8c.html#a6f2b5f1ed04bfefd8366bcc34d378aba">target_thread_name</a> (<span class="keyword">struct</span> <a class="code" href="structthread__info.html">thread_info</a> *);
<a name="l01441"></a>01441 
<a name="l01442"></a>01442 <span class="comment">/* Attempts to find the pathname of the executable file</span>
<a name="l01443"></a>01443 <span class="comment">   that was run to create a specified process.</span>
<a name="l01444"></a>01444 <span class="comment"></span>
<a name="l01445"></a>01445 <span class="comment">   The process PID must be stopped when this operation is used.</span>
<a name="l01446"></a>01446 <span class="comment"></span>
<a name="l01447"></a>01447 <span class="comment">   If the executable file cannot be determined, NULL is returned.</span>
<a name="l01448"></a>01448 <span class="comment"></span>
<a name="l01449"></a>01449 <span class="comment">   Else, a pointer to a character string containing the pathname</span>
<a name="l01450"></a>01450 <span class="comment">   is returned.  This string should be copied into a buffer by</span>
<a name="l01451"></a>01451 <span class="comment">   the client if the string will not be immediately used, or if</span>
<a name="l01452"></a>01452 <span class="comment">   it must persist.  */</span>
<a name="l01453"></a>01453 
<a name="l01454"></a><a class="code" href="target_8h.html#a407915372929d9a648b1be661cd91493">01454</a> <span class="preprocessor">#define target_pid_to_exec_file(pid) \</span>
<a name="l01455"></a>01455 <span class="preprocessor">     (current_target.to_pid_to_exec_file) (pid)</span>
<a name="l01456"></a>01456 <span class="preprocessor"></span>
<a name="l01457"></a>01457 <span class="comment">/* See the to_thread_architecture description in struct target_ops.  */</span>
<a name="l01458"></a>01458 
<a name="l01459"></a><a class="code" href="target_8h.html#a7b002f8f29b4d6b40d151e7aa1e92763">01459</a> <span class="preprocessor">#define target_thread_architecture(ptid) \</span>
<a name="l01460"></a>01460 <span class="preprocessor">     (current_target.to_thread_architecture (&amp;current_target, ptid))</span>
<a name="l01461"></a>01461 <span class="preprocessor"></span>
<a name="l01462"></a>01462 <span class="comment">/*</span>
<a name="l01463"></a>01463 <span class="comment"> * Iterator function for target memory regions.</span>
<a name="l01464"></a>01464 <span class="comment"> * Calls a callback function once for each memory region &#39;mapped&#39;</span>
<a name="l01465"></a>01465 <span class="comment"> * in the child process.  Defined as a simple macro rather than</span>
<a name="l01466"></a>01466 <span class="comment"> * as a function macro so that it can be tested for nullity.</span>
<a name="l01467"></a>01467 <span class="comment"> */</span>
<a name="l01468"></a>01468 
<a name="l01469"></a><a class="code" href="target_8h.html#a13b3d4cc2f1bfa8ed676a79c3939c3a2">01469</a> <span class="preprocessor">#define target_find_memory_regions(FUNC, DATA) \</span>
<a name="l01470"></a>01470 <span class="preprocessor">     (current_target.to_find_memory_regions) (FUNC, DATA)</span>
<a name="l01471"></a>01471 <span class="preprocessor"></span>
<a name="l01472"></a>01472 <span class="comment">/*</span>
<a name="l01473"></a>01473 <span class="comment"> * Compose corefile .note section.</span>
<a name="l01474"></a>01474 <span class="comment"> */</span>
<a name="l01475"></a>01475 
<a name="l01476"></a><a class="code" href="target_8h.html#a1b14f1557c4407974000595cefaaf5f3">01476</a> <span class="preprocessor">#define target_make_corefile_notes(BFD, SIZE_P) \</span>
<a name="l01477"></a>01477 <span class="preprocessor">     (current_target.to_make_corefile_notes) (BFD, SIZE_P)</span>
<a name="l01478"></a>01478 <span class="preprocessor"></span>
<a name="l01479"></a>01479 <span class="comment">/* Bookmark interfaces.  */</span>
<a name="l01480"></a><a class="code" href="target_8h.html#ab8448dcf7ea8b16ca3df084d31aa4b1a">01480</a> <span class="preprocessor">#define target_get_bookmark(ARGS, FROM_TTY) \</span>
<a name="l01481"></a>01481 <span class="preprocessor">     (current_target.to_get_bookmark) (ARGS, FROM_TTY)</span>
<a name="l01482"></a>01482 <span class="preprocessor"></span>
<a name="l01483"></a><a class="code" href="target_8h.html#a7cf6563c6093d88e3184a716608604f4">01483</a> <span class="preprocessor">#define target_goto_bookmark(ARG, FROM_TTY) \</span>
<a name="l01484"></a>01484 <span class="preprocessor">     (current_target.to_goto_bookmark) (ARG, FROM_TTY)</span>
<a name="l01485"></a>01485 <span class="preprocessor"></span>
<a name="l01486"></a>01486 <span class="comment">/* Hardware watchpoint interfaces.  */</span>
<a name="l01487"></a>01487 
<a name="l01488"></a>01488 <span class="comment">/* Returns non-zero if we were stopped by a hardware watchpoint (memory read or</span>
<a name="l01489"></a>01489 <span class="comment">   write).  Only the INFERIOR_PTID task is being queried.  */</span>
<a name="l01490"></a>01490 
<a name="l01491"></a><a class="code" href="target_8h.html#a11018e2c860bb03c890cce86024a9823">01491</a> <span class="preprocessor">#define target_stopped_by_watchpoint \</span>
<a name="l01492"></a>01492 <span class="preprocessor">   (*current_target.to_stopped_by_watchpoint)</span>
<a name="l01493"></a>01493 <span class="preprocessor"></span>
<a name="l01494"></a>01494 <span class="comment">/* Non-zero if we have steppable watchpoints  */</span>
<a name="l01495"></a>01495 
<a name="l01496"></a><a class="code" href="target_8h.html#a28c375398cbc64f9732438cf03643042">01496</a> <span class="preprocessor">#define target_have_steppable_watchpoint \</span>
<a name="l01497"></a>01497 <span class="preprocessor">   (current_target.to_have_steppable_watchpoint)</span>
<a name="l01498"></a>01498 <span class="preprocessor"></span>
<a name="l01499"></a>01499 <span class="comment">/* Non-zero if we have continuable watchpoints  */</span>
<a name="l01500"></a>01500 
<a name="l01501"></a><a class="code" href="target_8h.html#a72116316c4f61ff552c88714dfc3740a">01501</a> <span class="preprocessor">#define target_have_continuable_watchpoint \</span>
<a name="l01502"></a>01502 <span class="preprocessor">   (current_target.to_have_continuable_watchpoint)</span>
<a name="l01503"></a>01503 <span class="preprocessor"></span>
<a name="l01504"></a>01504 <span class="comment">/* Provide defaults for hardware watchpoint functions.  */</span>
<a name="l01505"></a>01505 
<a name="l01506"></a>01506 <span class="comment">/* If the *_hw_beakpoint functions have not been defined</span>
<a name="l01507"></a>01507 <span class="comment">   elsewhere use the definitions in the target vector.  */</span>
<a name="l01508"></a>01508 
<a name="l01509"></a>01509 <span class="comment">/* Returns non-zero if we can set a hardware watchpoint of type TYPE.  TYPE is</span>
<a name="l01510"></a>01510 <span class="comment">   one of bp_hardware_watchpoint, bp_read_watchpoint, bp_write_watchpoint, or</span>
<a name="l01511"></a>01511 <span class="comment">   bp_hardware_breakpoint.  CNT is the number of such watchpoints used so far</span>
<a name="l01512"></a>01512 <span class="comment">   (including this one?).  OTHERTYPE is who knows what...  */</span>
<a name="l01513"></a>01513 
<a name="l01514"></a><a class="code" href="target_8h.html#a426728386dc9c2a6d50a7a20e90fe13b">01514</a> <span class="preprocessor">#define target_can_use_hardware_watchpoint(TYPE,CNT,OTHERTYPE) \</span>
<a name="l01515"></a>01515 <span class="preprocessor"> (*current_target.to_can_use_hw_breakpoint) (TYPE, CNT, OTHERTYPE);</span>
<a name="l01516"></a>01516 <span class="preprocessor"></span>
<a name="l01517"></a>01517 <span class="comment">/* Returns the number of debug registers needed to watch the given</span>
<a name="l01518"></a>01518 <span class="comment">   memory region, or zero if not supported.  */</span>
<a name="l01519"></a>01519 
<a name="l01520"></a><a class="code" href="target_8h.html#a3c3f8624352b0e6674a4eb1ddeae1a2f">01520</a> <span class="preprocessor">#define target_region_ok_for_hw_watchpoint(addr, len) \</span>
<a name="l01521"></a>01521 <span class="preprocessor">    (*current_target.to_region_ok_for_hw_watchpoint) (addr, len)</span>
<a name="l01522"></a>01522 <span class="preprocessor"></span>
<a name="l01523"></a>01523 
<a name="l01524"></a>01524 <span class="comment">/* Set/clear a hardware watchpoint starting at ADDR, for LEN bytes.</span>
<a name="l01525"></a>01525 <span class="comment">   TYPE is 0 for write, 1 for read, and 2 for read/write accesses.</span>
<a name="l01526"></a>01526 <span class="comment">   COND is the expression for its condition, or NULL if there&#39;s none.</span>
<a name="l01527"></a>01527 <span class="comment">   Returns 0 for success, 1 if the watchpoint type is not supported,</span>
<a name="l01528"></a>01528 <span class="comment">   -1 for failure.  */</span>
<a name="l01529"></a>01529 
<a name="l01530"></a><a class="code" href="target_8h.html#a1152278135f165459d5d9cbbd96ee789">01530</a> <span class="preprocessor">#define target_insert_watchpoint(addr, len, type, cond) \</span>
<a name="l01531"></a>01531 <span class="preprocessor">     (*current_target.to_insert_watchpoint) (addr, len, type, cond)</span>
<a name="l01532"></a>01532 <span class="preprocessor"></span>
<a name="l01533"></a><a class="code" href="target_8h.html#acf13215db3791a1060edbccedf812fbc">01533</a> <span class="preprocessor">#define target_remove_watchpoint(addr, len, type, cond) \</span>
<a name="l01534"></a>01534 <span class="preprocessor">     (*current_target.to_remove_watchpoint) (addr, len, type, cond)</span>
<a name="l01535"></a>01535 <span class="preprocessor"></span>
<a name="l01536"></a>01536 <span class="comment">/* Insert a new masked watchpoint at ADDR using the mask MASK.</span>
<a name="l01537"></a>01537 <span class="comment">   RW may be hw_read for a read watchpoint, hw_write for a write watchpoint</span>
<a name="l01538"></a>01538 <span class="comment">   or hw_access for an access watchpoint.  Returns 0 for success, 1 if</span>
<a name="l01539"></a>01539 <span class="comment">   masked watchpoints are not supported, -1 for failure.  */</span>
<a name="l01540"></a>01540 
<a name="l01541"></a>01541 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a9d5ee306e205fd68ad1b0c07d298fbe7">target_insert_mask_watchpoint</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <span class="keywordtype">int</span>);
<a name="l01542"></a>01542 
<a name="l01543"></a>01543 <span class="comment">/* Remove a masked watchpoint at ADDR with the mask MASK.</span>
<a name="l01544"></a>01544 <span class="comment">   RW may be hw_read for a read watchpoint, hw_write for a write watchpoint</span>
<a name="l01545"></a>01545 <span class="comment">   or hw_access for an access watchpoint.  Returns 0 for success, non-zero</span>
<a name="l01546"></a>01546 <span class="comment">   for failure.  */</span>
<a name="l01547"></a>01547 
<a name="l01548"></a>01548 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a2921ea1fbdea7900197763eb813d3225">target_remove_mask_watchpoint</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <span class="keywordtype">int</span>);
<a name="l01549"></a>01549 
<a name="l01550"></a><a class="code" href="target_8h.html#aa87a3bd797a738bd9a12df0732781013">01550</a> <span class="preprocessor">#define target_insert_hw_breakpoint(gdbarch, bp_tgt) \</span>
<a name="l01551"></a>01551 <span class="preprocessor">     (*current_target.to_insert_hw_breakpoint) (gdbarch, bp_tgt)</span>
<a name="l01552"></a>01552 <span class="preprocessor"></span>
<a name="l01553"></a><a class="code" href="target_8h.html#a8cb43153c60123ceebd4597888b2d8bf">01553</a> <span class="preprocessor">#define target_remove_hw_breakpoint(gdbarch, bp_tgt) \</span>
<a name="l01554"></a>01554 <span class="preprocessor">     (*current_target.to_remove_hw_breakpoint) (gdbarch, bp_tgt)</span>
<a name="l01555"></a>01555 <span class="preprocessor"></span>
<a name="l01556"></a>01556 <span class="comment">/* Return number of debug registers needed for a ranged breakpoint,</span>
<a name="l01557"></a>01557 <span class="comment">   or -1 if ranged breakpoints are not supported.  */</span>
<a name="l01558"></a>01558 
<a name="l01559"></a>01559 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#ac5e3b4226d66a0cfdc0f039077e36178">target_ranged_break_num_registers</a> (<span class="keywordtype">void</span>);
<a name="l01560"></a>01560 
<a name="l01561"></a>01561 <span class="comment">/* Return non-zero if target knows the data address which triggered this</span>
<a name="l01562"></a>01562 <span class="comment">   target_stopped_by_watchpoint, in such case place it to *ADDR_P.  Only the</span>
<a name="l01563"></a>01563 <span class="comment">   INFERIOR_PTID task is being queried.  */</span>
<a name="l01564"></a><a class="code" href="target_8h.html#a05417aa04fe57e215fb1b5fdc87f92fa">01564</a> <span class="preprocessor">#define target_stopped_data_address(target, addr_p) \</span>
<a name="l01565"></a>01565 <span class="preprocessor">    (*target.to_stopped_data_address) (target, addr_p)</span>
<a name="l01566"></a>01566 <span class="preprocessor"></span>
<a name="l01567"></a>01567 <span class="comment">/* Return non-zero if ADDR is within the range of a watchpoint spanning</span>
<a name="l01568"></a>01568 <span class="comment">   LENGTH bytes beginning at START.  */</span>
<a name="l01569"></a><a class="code" href="target_8h.html#ac7234bfc83cdfd95e29ce2fb3462ead3">01569</a> <span class="preprocessor">#define target_watchpoint_addr_within_range(target, addr, start, length) \</span>
<a name="l01570"></a>01570 <span class="preprocessor">  (*target.to_watchpoint_addr_within_range) (target, addr, start, length)</span>
<a name="l01571"></a>01571 <span class="preprocessor"></span>
<a name="l01572"></a>01572 <span class="comment">/* Return non-zero if the target is capable of using hardware to evaluate</span>
<a name="l01573"></a>01573 <span class="comment">   the condition expression.  In this case, if the condition is false when</span>
<a name="l01574"></a>01574 <span class="comment">   the watched memory location changes, execution may continue without the</span>
<a name="l01575"></a>01575 <span class="comment">   debugger being notified.</span>
<a name="l01576"></a>01576 <span class="comment"></span>
<a name="l01577"></a>01577 <span class="comment">   Due to limitations in the hardware implementation, it may be capable of</span>
<a name="l01578"></a>01578 <span class="comment">   avoiding triggering the watchpoint in some cases where the condition</span>
<a name="l01579"></a>01579 <span class="comment">   expression is false, but may report some false positives as well.</span>
<a name="l01580"></a>01580 <span class="comment">   For this reason, GDB will still evaluate the condition expression when</span>
<a name="l01581"></a>01581 <span class="comment">   the watchpoint triggers.  */</span>
<a name="l01582"></a><a class="code" href="target_8h.html#ac08fe91380ca72adfa3e4cdb9e7ca770">01582</a> <span class="preprocessor">#define target_can_accel_watchpoint_condition(addr, len, type, cond) \</span>
<a name="l01583"></a>01583 <span class="preprocessor">  (*current_target.to_can_accel_watchpoint_condition) (addr, len, type, cond)</span>
<a name="l01584"></a>01584 <span class="preprocessor"></span>
<a name="l01585"></a>01585 <span class="comment">/* Return number of debug registers needed for a masked watchpoint,</span>
<a name="l01586"></a>01586 <span class="comment">   -1 if masked watchpoints are not supported or -2 if the given address</span>
<a name="l01587"></a>01587 <span class="comment">   and mask combination cannot be used.  */</span>
<a name="l01588"></a>01588 
<a name="l01589"></a>01589 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a944308b624c22754954470cf8c974e0d">target_masked_watch_num_registers</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> mask);
<a name="l01590"></a>01590 
<a name="l01591"></a>01591 <span class="comment">/* Target can execute in reverse?  */</span>
<a name="l01592"></a><a class="code" href="target_8h.html#a9d505a2eeddd080948e3f40957b7b264">01592</a> <span class="preprocessor">#define target_can_execute_reverse \</span>
<a name="l01593"></a>01593 <span class="preprocessor">     (current_target.to_can_execute_reverse ? \</span>
<a name="l01594"></a>01594 <span class="preprocessor">      current_target.to_can_execute_reverse () : 0)</span>
<a name="l01595"></a>01595 <span class="preprocessor"></span>
<a name="l01596"></a>01596 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct </span>target_desc *<a class="code" href="target_8c.html#a642460c6789b103a35be7611189414fc">target_read_description</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l01597"></a>01597 
<a name="l01598"></a><a class="code" href="target_8h.html#adb707124589925b5348683dc8db2e1b2">01598</a> <span class="preprocessor">#define target_get_ada_task_ptid(lwp, tid) \</span>
<a name="l01599"></a>01599 <span class="preprocessor">     (*current_target.to_get_ada_task_ptid) (lwp,tid)</span>
<a name="l01600"></a>01600 <span class="preprocessor"></span>
<a name="l01601"></a>01601 <span class="comment">/* Utility implementation of searching memory.  */</span>
<a name="l01602"></a>01602 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a10b296c1901be06eca570381eae2ffe3">simple_search_memory</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a>* ops,
<a name="l01603"></a>01603                                  <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_addr,
<a name="l01604"></a>01604                                  <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> search_space_len,
<a name="l01605"></a>01605                                  <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *pattern,
<a name="l01606"></a>01606                                  <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> pattern_len,
<a name="l01607"></a>01607                                  <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *found_addrp);
<a name="l01608"></a>01608 
<a name="l01609"></a>01609 <span class="comment">/* Main entry point for searching memory.  */</span>
<a name="l01610"></a>01610 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#ad0d703cf78608e2ad9a1c449a6af4e5e">target_search_memory</a> (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_addr,
<a name="l01611"></a>01611                                  <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> search_space_len,
<a name="l01612"></a>01612                                  <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *pattern,
<a name="l01613"></a>01613                                  <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> pattern_len,
<a name="l01614"></a>01614                                  <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *found_addrp);
<a name="l01615"></a>01615 
<a name="l01616"></a>01616 <span class="comment">/* Target file operations.  */</span>
<a name="l01617"></a>01617 
<a name="l01618"></a>01618 <span class="comment">/* Open FILENAME on the target, using FLAGS and MODE.  Return a</span>
<a name="l01619"></a>01619 <span class="comment">   target file descriptor, or -1 if an error occurs (and set</span>
<a name="l01620"></a>01620 <span class="comment">   *TARGET_ERRNO).  */</span>
<a name="l01621"></a>01621 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a332b56a4725be98d2f74b927f710ab3c">target_fileio_open</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>, <span class="keywordtype">int</span> mode,
<a name="l01622"></a>01622                                <span class="keywordtype">int</span> *target_errno);
<a name="l01623"></a>01623 
<a name="l01624"></a>01624 <span class="comment">/* Write up to LEN bytes from WRITE_BUF to FD on the target.</span>
<a name="l01625"></a>01625 <span class="comment">   Return the number of bytes written, or -1 if an error occurs</span>
<a name="l01626"></a>01626 <span class="comment">   (and set *TARGET_ERRNO).  */</span>
<a name="l01627"></a>01627 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#ac1039e3f7100a3583bdf29516a84f9f3">target_fileio_pwrite</a> (<span class="keywordtype">int</span> fd, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *write_buf, <span class="keywordtype">int</span> len,
<a name="l01628"></a>01628                                  <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> offset, <span class="keywordtype">int</span> *target_errno);
<a name="l01629"></a>01629 
<a name="l01630"></a>01630 <span class="comment">/* Read up to LEN bytes FD on the target into READ_BUF.</span>
<a name="l01631"></a>01631 <span class="comment">   Return the number of bytes read, or -1 if an error occurs</span>
<a name="l01632"></a>01632 <span class="comment">   (and set *TARGET_ERRNO).  */</span>
<a name="l01633"></a>01633 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a0e8dd213c99d1b18e2d06c6fce8c83e7">target_fileio_pread</a> (<span class="keywordtype">int</span> fd, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *read_buf, <span class="keywordtype">int</span> len,
<a name="l01634"></a>01634                                 <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> offset, <span class="keywordtype">int</span> *target_errno);
<a name="l01635"></a>01635 
<a name="l01636"></a>01636 <span class="comment">/* Close FD on the target.  Return 0, or -1 if an error occurs</span>
<a name="l01637"></a>01637 <span class="comment">   (and set *TARGET_ERRNO).  */</span>
<a name="l01638"></a>01638 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a033333f4ae99c426a60e2703c0db2de4">target_fileio_close</a> (<span class="keywordtype">int</span> fd, <span class="keywordtype">int</span> *target_errno);
<a name="l01639"></a>01639 
<a name="l01640"></a>01640 <span class="comment">/* Unlink FILENAME on the target.  Return 0, or -1 if an error</span>
<a name="l01641"></a>01641 <span class="comment">   occurs (and set *TARGET_ERRNO).  */</span>
<a name="l01642"></a>01642 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a9632684619f8f39672d4e902c4231407">target_fileio_unlink</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keywordtype">int</span> *target_errno);
<a name="l01643"></a>01643 
<a name="l01644"></a>01644 <span class="comment">/* Read value of symbolic link FILENAME on the target.  Return a</span>
<a name="l01645"></a>01645 <span class="comment">   null-terminated string allocated via xmalloc, or NULL if an error</span>
<a name="l01646"></a>01646 <span class="comment">   occurs (and set *TARGET_ERRNO).  */</span>
<a name="l01647"></a>01647 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="target_8c.html#a8a10cd8d1bbb71d7485c65a7889a3b85">target_fileio_readlink</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keywordtype">int</span> *target_errno);
<a name="l01648"></a>01648 
<a name="l01649"></a>01649 <span class="comment">/* Read target file FILENAME.  The return value will be -1 if the transfer</span>
<a name="l01650"></a>01650 <span class="comment">   fails or is not supported; 0 if the object is empty; or the length</span>
<a name="l01651"></a>01651 <span class="comment">   of the object otherwise.  If a positive value is returned, a</span>
<a name="l01652"></a>01652 <span class="comment">   sufficiently large buffer will be allocated using xmalloc and</span>
<a name="l01653"></a>01653 <span class="comment">   returned in *BUF_P containing the contents of the object.</span>
<a name="l01654"></a>01654 <span class="comment"></span>
<a name="l01655"></a>01655 <span class="comment">   This method should be used for objects sufficiently small to store</span>
<a name="l01656"></a>01656 <span class="comment">   in a single xmalloc&#39;d buffer, when no fixed bound on the object&#39;s</span>
<a name="l01657"></a>01657 <span class="comment">   size is known in advance.  */</span>
<a name="l01658"></a>01658 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="target_8c.html#ae6bdcd93b20cfdccb9e15c404d9d93e7">target_fileio_read_alloc</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *filename,
<a name="l01659"></a>01659                                          <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> **buf_p);
<a name="l01660"></a>01660 
<a name="l01661"></a>01661 <span class="comment">/* Read target file FILENAME.  The result is NUL-terminated and</span>
<a name="l01662"></a>01662 <span class="comment">   returned as a string, allocated using xmalloc.  If an error occurs</span>
<a name="l01663"></a>01663 <span class="comment">   or the transfer is unsupported, NULL is returned.  Empty objects</span>
<a name="l01664"></a>01664 <span class="comment">   are returned as allocated but empty strings.  A warning is issued</span>
<a name="l01665"></a>01665 <span class="comment">   if the result contains any embedded NUL bytes.  */</span>
<a name="l01666"></a>01666 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="target_8c.html#ade36983dc72486df1b8d12a7b26a9994">target_fileio_read_stralloc</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *filename);
<a name="l01667"></a>01667 
<a name="l01668"></a>01668 
<a name="l01669"></a>01669 <span class="comment">/* Tracepoint-related operations.  */</span>
<a name="l01670"></a>01670 
<a name="l01671"></a><a class="code" href="target_8h.html#a67dd9a54140003e478b853beaff9d3b7">01671</a> <span class="preprocessor">#define target_trace_init() \</span>
<a name="l01672"></a>01672 <span class="preprocessor">  (*current_target.to_trace_init) ()</span>
<a name="l01673"></a>01673 <span class="preprocessor"></span>
<a name="l01674"></a><a class="code" href="target_8h.html#a7fd80fa7dbdf49fbf15e93f98e9480ef">01674</a> <span class="preprocessor">#define target_download_tracepoint(t) \</span>
<a name="l01675"></a>01675 <span class="preprocessor">  (*current_target.to_download_tracepoint) (t)</span>
<a name="l01676"></a>01676 <span class="preprocessor"></span>
<a name="l01677"></a><a class="code" href="target_8h.html#a307fbed0d495eff4ce917dc3555a15d7">01677</a> <span class="preprocessor">#define target_can_download_tracepoint() \</span>
<a name="l01678"></a>01678 <span class="preprocessor">  (*current_target.to_can_download_tracepoint) ()</span>
<a name="l01679"></a>01679 <span class="preprocessor"></span>
<a name="l01680"></a><a class="code" href="target_8h.html#a3dc571d0a43cede3920ba48cc9be4609">01680</a> <span class="preprocessor">#define target_download_trace_state_variable(tsv) \</span>
<a name="l01681"></a>01681 <span class="preprocessor">  (*current_target.to_download_trace_state_variable) (tsv)</span>
<a name="l01682"></a>01682 <span class="preprocessor"></span>
<a name="l01683"></a><a class="code" href="target_8h.html#a4eea3933763ac18e46f7adeee5c02c7c">01683</a> <span class="preprocessor">#define target_enable_tracepoint(loc) \</span>
<a name="l01684"></a>01684 <span class="preprocessor">  (*current_target.to_enable_tracepoint) (loc)</span>
<a name="l01685"></a>01685 <span class="preprocessor"></span>
<a name="l01686"></a><a class="code" href="target_8h.html#a1cea3310d44ec81d08890ad35f2c0868">01686</a> <span class="preprocessor">#define target_disable_tracepoint(loc) \</span>
<a name="l01687"></a>01687 <span class="preprocessor">  (*current_target.to_disable_tracepoint) (loc)</span>
<a name="l01688"></a>01688 <span class="preprocessor"></span>
<a name="l01689"></a><a class="code" href="target_8h.html#af6ee06798069a51157d94d519ba240ed">01689</a> <span class="preprocessor">#define target_trace_start() \</span>
<a name="l01690"></a>01690 <span class="preprocessor">  (*current_target.to_trace_start) ()</span>
<a name="l01691"></a>01691 <span class="preprocessor"></span>
<a name="l01692"></a><a class="code" href="target_8h.html#abe4f81251ab45522b4cb64938e06d3a8">01692</a> <span class="preprocessor">#define target_trace_set_readonly_regions() \</span>
<a name="l01693"></a>01693 <span class="preprocessor">  (*current_target.to_trace_set_readonly_regions) ()</span>
<a name="l01694"></a>01694 <span class="preprocessor"></span>
<a name="l01695"></a><a class="code" href="target_8h.html#ad3a877c0f56ac304d3ddb3b8a19fc4d3">01695</a> <span class="preprocessor">#define target_get_trace_status(ts) \</span>
<a name="l01696"></a>01696 <span class="preprocessor">  (*current_target.to_get_trace_status) (ts)</span>
<a name="l01697"></a>01697 <span class="preprocessor"></span>
<a name="l01698"></a><a class="code" href="target_8h.html#a4e32144454bcabb9bf5911a6d6e67a10">01698</a> <span class="preprocessor">#define target_get_tracepoint_status(tp,utp)            \</span>
<a name="l01699"></a>01699 <span class="preprocessor">  (*current_target.to_get_tracepoint_status) (tp, utp)</span>
<a name="l01700"></a>01700 <span class="preprocessor"></span>
<a name="l01701"></a><a class="code" href="target_8h.html#aa7ed1d64f4d32b9c0ed2683fa1b48186">01701</a> <span class="preprocessor">#define target_trace_stop() \</span>
<a name="l01702"></a>01702 <span class="preprocessor">  (*current_target.to_trace_stop) ()</span>
<a name="l01703"></a>01703 <span class="preprocessor"></span>
<a name="l01704"></a><a class="code" href="target_8h.html#a9f5b31eeb53ce0049febf03485540f46">01704</a> <span class="preprocessor">#define target_trace_find(type,num,addr1,addr2,tpp) \</span>
<a name="l01705"></a>01705 <span class="preprocessor">  (*current_target.to_trace_find) ((type), (num), (addr1), (addr2), (tpp))</span>
<a name="l01706"></a>01706 <span class="preprocessor"></span>
<a name="l01707"></a><a class="code" href="target_8h.html#a8628c39fd21979c3a0382fa374343872">01707</a> <span class="preprocessor">#define target_get_trace_state_variable_value(tsv,val) \</span>
<a name="l01708"></a>01708 <span class="preprocessor">  (*current_target.to_get_trace_state_variable_value) ((tsv), (val))</span>
<a name="l01709"></a>01709 <span class="preprocessor"></span>
<a name="l01710"></a><a class="code" href="target_8h.html#adf4241102ca28a091302396997adcf99">01710</a> <span class="preprocessor">#define target_save_trace_data(filename) \</span>
<a name="l01711"></a>01711 <span class="preprocessor">  (*current_target.to_save_trace_data) (filename)</span>
<a name="l01712"></a>01712 <span class="preprocessor"></span>
<a name="l01713"></a><a class="code" href="target_8h.html#ab4f3bb125925d8d70e5c552709cb7a2c">01713</a> <span class="preprocessor">#define target_upload_tracepoints(utpp) \</span>
<a name="l01714"></a>01714 <span class="preprocessor">  (*current_target.to_upload_tracepoints) (utpp)</span>
<a name="l01715"></a>01715 <span class="preprocessor"></span>
<a name="l01716"></a><a class="code" href="target_8h.html#a54efebe82a97cf1b2c10f64347dc1950">01716</a> <span class="preprocessor">#define target_upload_trace_state_variables(utsvp) \</span>
<a name="l01717"></a>01717 <span class="preprocessor">  (*current_target.to_upload_trace_state_variables) (utsvp)</span>
<a name="l01718"></a>01718 <span class="preprocessor"></span>
<a name="l01719"></a><a class="code" href="target_8h.html#a0fc1199a86c59ca0141a1c39fa4baee2">01719</a> <span class="preprocessor">#define target_get_raw_trace_data(buf,offset,len) \</span>
<a name="l01720"></a>01720 <span class="preprocessor">  (*current_target.to_get_raw_trace_data) ((buf), (offset), (len))</span>
<a name="l01721"></a>01721 <span class="preprocessor"></span>
<a name="l01722"></a><a class="code" href="target_8h.html#a5cf41ecf8487d3bdf6aae168d3f63b30">01722</a> <span class="preprocessor">#define target_get_min_fast_tracepoint_insn_len() \</span>
<a name="l01723"></a>01723 <span class="preprocessor">  (*current_target.to_get_min_fast_tracepoint_insn_len) ()</span>
<a name="l01724"></a>01724 <span class="preprocessor"></span>
<a name="l01725"></a><a class="code" href="target_8h.html#afdb0a947ae5efc979edeea4585bd09ad">01725</a> <span class="preprocessor">#define target_set_disconnected_tracing(val) \</span>
<a name="l01726"></a>01726 <span class="preprocessor">  (*current_target.to_set_disconnected_tracing) (val)</span>
<a name="l01727"></a>01727 <span class="preprocessor"></span>
<a name="l01728"></a><a class="code" href="target_8h.html#ad01c945e577448f4295956185ae7efba">01728</a> <span class="preprocessor">#define target_set_circular_trace_buffer(val)   \</span>
<a name="l01729"></a>01729 <span class="preprocessor">  (*current_target.to_set_circular_trace_buffer) (val)</span>
<a name="l01730"></a>01730 <span class="preprocessor"></span>
<a name="l01731"></a><a class="code" href="target_8h.html#a384639dc9b25a1caed3311bf193f7274">01731</a> <span class="preprocessor">#define target_set_trace_buffer_size(val)       \</span>
<a name="l01732"></a>01732 <span class="preprocessor">  (*current_target.to_set_trace_buffer_size) (val)</span>
<a name="l01733"></a>01733 <span class="preprocessor"></span>
<a name="l01734"></a><a class="code" href="target_8h.html#ad4847e47bef87ffacdd66828f2596439">01734</a> <span class="preprocessor">#define target_set_trace_notes(user,notes,stopnotes)            \</span>
<a name="l01735"></a>01735 <span class="preprocessor">  (*current_target.to_set_trace_notes) ((user), (notes), (stopnotes))</span>
<a name="l01736"></a>01736 <span class="preprocessor"></span>
<a name="l01737"></a><a class="code" href="target_8h.html#a9c338493b163008b3157098d3c620fd1">01737</a> <span class="preprocessor">#define target_get_tib_address(ptid, addr) \</span>
<a name="l01738"></a>01738 <span class="preprocessor">  (*current_target.to_get_tib_address) ((ptid), (addr))</span>
<a name="l01739"></a>01739 <span class="preprocessor"></span>
<a name="l01740"></a><a class="code" href="target_8h.html#a24b44b32e2b583b5ccade1fd7ebdf2f4">01740</a> <span class="preprocessor">#define target_set_permissions() \</span>
<a name="l01741"></a>01741 <span class="preprocessor">  (*current_target.to_set_permissions) ()</span>
<a name="l01742"></a>01742 <span class="preprocessor"></span>
<a name="l01743"></a><a class="code" href="target_8h.html#ae08c5fc84179c507e7eb68640f32a5f4">01743</a> <span class="preprocessor">#define target_static_tracepoint_marker_at(addr, marker) \</span>
<a name="l01744"></a>01744 <span class="preprocessor">  (*current_target.to_static_tracepoint_marker_at) (addr, marker)</span>
<a name="l01745"></a>01745 <span class="preprocessor"></span>
<a name="l01746"></a><a class="code" href="target_8h.html#a0a86c51b45e40100c97b3dd4540455e8">01746</a> <span class="preprocessor">#define target_static_tracepoint_markers_by_strid(marker_id) \</span>
<a name="l01747"></a>01747 <span class="preprocessor">  (*current_target.to_static_tracepoint_markers_by_strid) (marker_id)</span>
<a name="l01748"></a>01748 <span class="preprocessor"></span>
<a name="l01749"></a><a class="code" href="target_8h.html#a04b719c1438b72f8495748a2551384d1">01749</a> <span class="preprocessor">#define target_traceframe_info() \</span>
<a name="l01750"></a>01750 <span class="preprocessor">  (*current_target.to_traceframe_info) ()</span>
<a name="l01751"></a>01751 <span class="preprocessor"></span>
<a name="l01752"></a><a class="code" href="target_8h.html#a9e260af182aac8b2530d880b2207c051">01752</a> <span class="preprocessor">#define target_use_agent(use) \</span>
<a name="l01753"></a>01753 <span class="preprocessor">  (*current_target.to_use_agent) (use)</span>
<a name="l01754"></a>01754 <span class="preprocessor"></span>
<a name="l01755"></a><a class="code" href="target_8h.html#acf0aa2c06f94140613da4f28e076e628">01755</a> <span class="preprocessor">#define target_can_use_agent() \</span>
<a name="l01756"></a>01756 <span class="preprocessor">  (*current_target.to_can_use_agent) ()</span>
<a name="l01757"></a>01757 <span class="preprocessor"></span>
<a name="l01758"></a><a class="code" href="target_8h.html#a233c7e02762a686a72ebc2c75dcd7af4">01758</a> <span class="preprocessor">#define target_augmented_libraries_svr4_read() \</span>
<a name="l01759"></a>01759 <span class="preprocessor">  (*current_target.to_augmented_libraries_svr4_read) ()</span>
<a name="l01760"></a>01760 <span class="preprocessor"></span>
<a name="l01761"></a>01761 <span class="comment">/* Command logging facility.  */</span>
<a name="l01762"></a>01762 
<a name="l01763"></a><a class="code" href="target_8h.html#ab4547ca4a306cdcf484e863f56f8d210">01763</a> <span class="preprocessor">#define target_log_command(p)                                           \</span>
<a name="l01764"></a>01764 <span class="preprocessor">  do                                                                    \</span>
<a name="l01765"></a>01765 <span class="preprocessor">    if (current_target.to_log_command)                                  \</span>
<a name="l01766"></a>01766 <span class="preprocessor">      (*current_target.to_log_command) (p);                             \</span>
<a name="l01767"></a>01767 <span class="preprocessor">  while (0)</span>
<a name="l01768"></a>01768 <span class="preprocessor"></span>
<a name="l01769"></a>01769 
<a name="l01770"></a>01770 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a71e29bd9cb12824ec46394190d8b08c7">target_core_of_thread</a> (<a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a>);
<a name="l01771"></a>01771 
<a name="l01772"></a>01772 <span class="comment">/* Verify that the memory in the [MEMADDR, MEMADDR+SIZE) range matches</span>
<a name="l01773"></a>01773 <span class="comment">   the contents of [DATA,DATA+SIZE).  Returns 1 if there&#39;s a match, 0</span>
<a name="l01774"></a>01774 <span class="comment">   if there&#39;s a mismatch, and -1 if an error is encountered while</span>
<a name="l01775"></a>01775 <span class="comment">   reading memory.  Throws an error if the functionality is found not</span>
<a name="l01776"></a>01776 <span class="comment">   to be supported by the current target.  */</span>
<a name="l01777"></a>01777 <span class="keywordtype">int</span> <a class="code" href="target_8c.html#afce7d49eca4714b1dce92ce2229260c4">target_verify_memory</a> (<span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *data,
<a name="l01778"></a>01778                           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="exec_8h.html#ab268c3184bf49615e16de006a296a542">memaddr</a>, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>);
<a name="l01779"></a>01779 
<a name="l01780"></a>01780 <span class="comment">/* Routines for maintenance of the target structures...</span>
<a name="l01781"></a>01781 <span class="comment"></span>
<a name="l01782"></a>01782 <span class="comment">   complete_target_initialization: Finalize a target_ops by filling in</span>
<a name="l01783"></a>01783 <span class="comment">   any fields needed by the target implementation.</span>
<a name="l01784"></a>01784 <span class="comment"></span>
<a name="l01785"></a>01785 <span class="comment">   add_target:   Add a target to the list of all possible targets.</span>
<a name="l01786"></a>01786 <span class="comment"></span>
<a name="l01787"></a>01787 <span class="comment">   push_target:  Make this target the top of the stack of currently used</span>
<a name="l01788"></a>01788 <span class="comment">   targets, within its particular stratum of the stack.  Result</span>
<a name="l01789"></a>01789 <span class="comment">   is 0 if now atop the stack, nonzero if not on top (maybe</span>
<a name="l01790"></a>01790 <span class="comment">   should warn user).</span>
<a name="l01791"></a>01791 <span class="comment"></span>
<a name="l01792"></a>01792 <span class="comment">   unpush_target: Remove this from the stack of currently used targets,</span>
<a name="l01793"></a>01793 <span class="comment">   no matter where it is on the list.  Returns 0 if no</span>
<a name="l01794"></a>01794 <span class="comment">   change, 1 if removed from stack.  */</span>
<a name="l01795"></a>01795 
<a name="l01796"></a>01796 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#ac7643c290e176b1e1ccfdb03ebacf421">add_target</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l01797"></a>01797 
<a name="l01798"></a>01798 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a7ca52d89a2cdf56c2c9fef612d6f2674">add_target_with_completer</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *t,
<a name="l01799"></a>01799                                        completer_ftype *completer);
<a name="l01800"></a>01800 
<a name="l01801"></a>01801 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a1cdc1b41e34c193ca58094f37746bb65">complete_target_initialization</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *t);
<a name="l01802"></a>01802 
<a name="l01803"></a>01803 <span class="comment">/* Adds a command ALIAS for target T and marks it deprecated.  This is useful</span>
<a name="l01804"></a>01804 <span class="comment">   for maintaining backwards compatibility when renaming targets.  */</span>
<a name="l01805"></a>01805 
<a name="l01806"></a>01806 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a5097a6dc83a8f1eefc09fc289abe44f7">add_deprecated_target_alias</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *t, <span class="keywordtype">char</span> *alias);
<a name="l01807"></a>01807 
<a name="l01808"></a>01808 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#ada1b9dc1eeb0546d39b86ba7ac645e67">push_target</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l01809"></a>01809 
<a name="l01810"></a>01810 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a9599d37847d1388531abb3f2aeba6616">unpush_target</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *);
<a name="l01811"></a>01811 
<a name="l01812"></a>01812 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a2adccbe673b1847dc0867b4369ad855b">target_pre_inferior</a> (<span class="keywordtype">int</span>);
<a name="l01813"></a>01813 
<a name="l01814"></a>01814 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#acc9e6257009bd3dd81f0577b44f924d9">target_preopen</a> (<span class="keywordtype">int</span>);
<a name="l01815"></a>01815 
<a name="l01816"></a>01816 <span class="comment">/* Does whatever cleanup is required to get rid of all pushed targets.  */</span>
<a name="l01817"></a>01817 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a2541fbf3f0f67c7b931ed4643bf99d27">pop_all_targets</a> (<span class="keywordtype">void</span>);
<a name="l01818"></a>01818 
<a name="l01819"></a>01819 <span class="comment">/* Like pop_all_targets, but pops only targets whose stratum is</span>
<a name="l01820"></a>01820 <span class="comment">   strictly above ABOVE_STRATUM.  */</span>
<a name="l01821"></a>01821 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a1e6a689d309da4051bd323a27ef31bd4">pop_all_targets_above</a> (<span class="keyword">enum</span> <a class="code" href="target_8h.html#abf9ea8b4aa7bddf6a8aa3882d0dadd00">strata</a> above_stratum);
<a name="l01822"></a>01822 
<a name="l01823"></a>01823 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a28aea16dca2e9a83e72153afbfee9586">target_is_pushed</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *t);
<a name="l01824"></a>01824 
<a name="l01825"></a>01825 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="target_8c.html#adc154ed54792c33bfed5b643fa257e2f">target_translate_tls_address</a> (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>,
<a name="l01826"></a>01826                                                <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> offset);
<a name="l01827"></a>01827 
<a name="l01828"></a>01828 <span class="comment">/* Struct target_section maps address ranges to file sections.  It is</span>
<a name="l01829"></a>01829 <span class="comment">   mostly used with BFD files, but can be used without (e.g. for handling</span>
<a name="l01830"></a>01830 <span class="comment">   raw disks, or files not in formats handled by BFD).  */</span>
<a name="l01831"></a>01831 
<a name="l01832"></a><a class="code" href="structtarget__section.html">01832</a> <span class="keyword">struct </span><a class="code" href="structtarget__section.html">target_section</a>
<a name="l01833"></a>01833   {
<a name="l01834"></a><a class="code" href="structtarget__section.html#a3e4564d6ceb39f962f70bb7afdd3b260">01834</a>     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structtarget__section.html#a3e4564d6ceb39f962f70bb7afdd3b260">addr</a>;             <span class="comment">/* Lowest address in section */</span>
<a name="l01835"></a><a class="code" href="structtarget__section.html#a2c1890ede65bfce986a3e16682e76072">01835</a>     <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structtarget__section.html#a2c1890ede65bfce986a3e16682e76072">endaddr</a>;          <span class="comment">/* 1+highest address in section */</span>
<a name="l01836"></a>01836 
<a name="l01837"></a><a class="code" href="structtarget__section.html#a3eeadf384747cb6a6e8cbb07db089723">01837</a>     <span class="keyword">struct </span>bfd_section *<a class="code" href="structtarget__section.html#a3eeadf384747cb6a6e8cbb07db089723">the_bfd_section</a>;
<a name="l01838"></a>01838 
<a name="l01839"></a>01839     <span class="comment">/* The &quot;owner&quot; of the section.</span>
<a name="l01840"></a>01840 <span class="comment">       It can be any unique value.  It is set by add_target_sections</span>
<a name="l01841"></a>01841 <span class="comment">       and used by remove_target_sections.</span>
<a name="l01842"></a>01842 <span class="comment">       For example, for executables it is a pointer to exec_bfd and</span>
<a name="l01843"></a>01843 <span class="comment">       for shlibs it is the so_list pointer.  */</span>
<a name="l01844"></a><a class="code" href="structtarget__section.html#a0636b20183e2753a8bb202663e26edfe">01844</a>     <span class="keywordtype">void</span> *<a class="code" href="structtarget__section.html#a0636b20183e2753a8bb202663e26edfe">owner</a>;
<a name="l01845"></a>01845   };
<a name="l01846"></a>01846 
<a name="l01847"></a>01847 <span class="comment">/* Holds an array of target sections.  Defined by [SECTIONS..SECTIONS_END[.  */</span>
<a name="l01848"></a>01848 
<a name="l01849"></a><a class="code" href="structtarget__section__table.html">01849</a> <span class="keyword">struct </span><a class="code" href="structtarget__section__table.html">target_section_table</a>
<a name="l01850"></a>01850 {
<a name="l01851"></a><a class="code" href="structtarget__section__table.html#a432fe15b9d6b7650e3a8a9ca9ed58322">01851</a>   <span class="keyword">struct </span><a class="code" href="structtarget__section.html">target_section</a> *<a class="code" href="structtarget__section__table.html#a432fe15b9d6b7650e3a8a9ca9ed58322">sections</a>;
<a name="l01852"></a><a class="code" href="structtarget__section__table.html#a4240d8815c53d6b388b0440f03175043">01852</a>   <span class="keyword">struct </span><a class="code" href="structtarget__section.html">target_section</a> *<a class="code" href="structtarget__section__table.html#a4240d8815c53d6b388b0440f03175043">sections_end</a>;
<a name="l01853"></a>01853 };
<a name="l01854"></a>01854 
<a name="l01855"></a>01855 <span class="comment">/* Return the &quot;section&quot; containing the specified address.  */</span>
<a name="l01856"></a>01856 <span class="keyword">struct </span><a class="code" href="structtarget__section.html">target_section</a> *<a class="code" href="target_8c.html#a196ba145eb2ad5a85d02157bba8ee50d">target_section_by_addr</a> (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *target,
<a name="l01857"></a>01857                                                <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structtarget__section.html#a3e4564d6ceb39f962f70bb7afdd3b260">addr</a>);
<a name="l01858"></a>01858 
<a name="l01859"></a>01859 <span class="comment">/* Return the target section table this target (or the targets</span>
<a name="l01860"></a>01860 <span class="comment">   beneath) currently manipulate.  */</span>
<a name="l01861"></a>01861 
<a name="l01862"></a>01862 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtarget__section__table.html">target_section_table</a> *<a class="code" href="target_8c.html#a24748d3564c354de182ba340a381e9e7">target_get_section_table</a>
<a name="l01863"></a>01863   (<span class="keyword">struct</span> <a class="code" href="structtarget__ops.html">target_ops</a> *target);
<a name="l01864"></a>01864 
<a name="l01865"></a>01865 <span class="comment">/* From mem-break.c */</span>
<a name="l01866"></a>01866 
<a name="l01867"></a>01867 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mem-break_8c.html#a06361fffc1bb3f74e5dc923eae5f2357">memory_remove_breakpoint</a> (<span class="keyword">struct</span> gdbarch *,
<a name="l01868"></a>01868                                      <span class="keyword">struct</span> <a class="code" href="structbp__target__info.html">bp_target_info</a> *);
<a name="l01869"></a>01869 
<a name="l01870"></a>01870 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mem-break_8c.html#a37c088d98822c2f32fe0e632e7ffbc2d">memory_insert_breakpoint</a> (<span class="keyword">struct</span> gdbarch *,
<a name="l01871"></a>01871                                      <span class="keyword">struct</span> <a class="code" href="structbp__target__info.html">bp_target_info</a> *);
<a name="l01872"></a>01872 
<a name="l01873"></a>01873 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mem-break_8c.html#a7f59ba4c2b9e2eb77476352267fdffc8">default_memory_remove_breakpoint</a> (<span class="keyword">struct</span> gdbarch *,
<a name="l01874"></a>01874                                              <span class="keyword">struct</span> <a class="code" href="structbp__target__info.html">bp_target_info</a> *);
<a name="l01875"></a>01875 
<a name="l01876"></a>01876 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="mem-break_8c.html#a6be8b1601e0d183d11630a3cc3017852">default_memory_insert_breakpoint</a> (<span class="keyword">struct</span> gdbarch *,
<a name="l01877"></a>01877                                              <span class="keyword">struct</span> <a class="code" href="structbp__target__info.html">bp_target_info</a> *);
<a name="l01878"></a>01878 
<a name="l01879"></a>01879 
<a name="l01880"></a>01880 <span class="comment">/* From target.c */</span>
<a name="l01881"></a>01881 
<a name="l01882"></a>01882 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#ab8db364b1065076629008c145d7dc62c">initialize_targets</a> (<span class="keywordtype">void</span>);
<a name="l01883"></a>01883 
<a name="l01884"></a>01884 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a5b9ff5a22e5113e99e46f2dac0b38271">noprocess</a> (<span class="keywordtype">void</span>) ATTRIBUTE_NORETURN;
<a name="l01885"></a>01885 
<a name="l01886"></a>01886 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a087a9ed5e0960789e5c57e519d81ed35">target_require_runnable</a> (<span class="keywordtype">void</span>);
<a name="l01887"></a>01887 
<a name="l01888"></a>01888 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a667bb14714d7385a3a79da155cc84426">find_default_attach</a> (struct <a class="code" href="structtarget__ops.html">target_ops</a> *, <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>);
<a name="l01889"></a>01889 
<a name="l01890"></a>01890 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#aef495fe5384efb71f5361eace68a6c00">find_default_create_inferior</a> (struct target_ops *,
<a name="l01891"></a>01891                                           <span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *, <span class="keywordtype">char</span> **, <span class="keywordtype">int</span>);
<a name="l01892"></a>01892 
<a name="l01893"></a>01893 extern struct target_ops *<a class="code" href="target_8c.html#afa1a2fb00f3ea15f9394f5b8afe14818">find_target_beneath</a> (struct target_ops *);
<a name="l01894"></a>01894 
<a name="l01895"></a>01895 <span class="comment">/* Read OS data object of type TYPE from the target, and return it in</span>
<a name="l01896"></a>01896 <span class="comment">   XML format.  The result is NUL-terminated and returned as a string,</span>
<a name="l01897"></a>01897 <span class="comment">   allocated using xmalloc.  If an error occurs or the transfer is</span>
<a name="l01898"></a>01898 <span class="comment">   unsupported, NULL is returned.  Empty objects are returned as</span>
<a name="l01899"></a>01899 <span class="comment">   allocated but empty strings.  */</span>
<a name="l01900"></a>01900 
<a name="l01901"></a>01901 extern <span class="keywordtype">char</span> *<a class="code" href="target_8c.html#a1a4fd4a1fe872d768a68cdd99c2c34e9">target_get_osdata</a> (<a class="code" href="p-lang_8h.html#a21296fc6f36ba2fc4d9780fdd126acb5">const</a> <span class="keywordtype">char</span> *<a class="code" href="structtype.html">type</a>);
<a name="l01902"></a>01902 
<a name="l01903"></a>01903 
<a name="l01904"></a>01904 <span class="comment">/* Stuff that should be shared among the various remote targets.  */</span>
<a name="l01905"></a>01905 
<a name="l01906"></a>01906 <span class="comment">/* Debugging level.  0 is off, and non-zero values mean to print some debug</span>
<a name="l01907"></a>01907 <span class="comment">   information (higher values, more information).  */</span>
<a name="l01908"></a>01908 extern <span class="keywordtype">int</span> <a class="code" href="dsrec_8c.html#ab222915c90ee61978f3519f8fdd922c7">remote_debug</a>;
<a name="l01909"></a>01909 
<a name="l01910"></a>01910 <span class="comment">/* Speed in bits per second, or -1 which means don&#39;t mess with the speed.  */</span>
<a name="l01911"></a>01911 extern <span class="keywordtype">int</span> <a class="code" href="serial_8c.html#a784e73e1ce3f90fbcbb0a78d72a053ff">baud_rate</a>;
<a name="l01912"></a>01912 <span class="comment">/* Timeout limit for response from target.  */</span>
<a name="l01913"></a>01913 extern <span class="keywordtype">int</span> <a class="code" href="target_8h.html#ac6decadce663ff98c95196919273e194">remote_timeout</a>;
<a name="l01914"></a>01914 
<a name="l01915"></a>01915 
<a name="l01916"></a>01916 
<a name="l01917"></a>01917 <span class="comment">/* Set the show memory breakpoints mode to show, and installs a cleanup</span>
<a name="l01918"></a>01918 <span class="comment">   to restore it back to the current value.  */</span>
<a name="l01919"></a>01919 extern struct cleanup *<a class="code" href="target_8c.html#afd34ddac7a36904417e6526601cf516a">make_show_memory_breakpoints_cleanup</a> (<span class="keywordtype">int</span> show);
<a name="l01920"></a>01920 
<a name="l01921"></a>01921 extern <span class="keywordtype">int</span> may_write_registers;
<a name="l01922"></a>01922 extern <span class="keywordtype">int</span> may_write_memory;
<a name="l01923"></a>01923 extern <span class="keywordtype">int</span> may_insert_breakpoints;
<a name="l01924"></a>01924 extern <span class="keywordtype">int</span> may_insert_tracepoints;
<a name="l01925"></a>01925 extern <span class="keywordtype">int</span> may_insert_fast_tracepoints;
<a name="l01926"></a>01926 extern <span class="keywordtype">int</span> may_stop;
<a name="l01927"></a>01927 
<a name="l01928"></a>01928 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#afcd226131a0de802df162bf822e87d76">update_target_permissions</a> (<span class="keywordtype">void</span>);
<a name="l01929"></a>01929 
<a name="l01930"></a>01930 
<a name="l01931"></a>01931 <span class="comment">/* Imported from machine dependent code.  */</span>
<a name="l01932"></a>01932 
<a name="l01933"></a>01933 <span class="comment">/* Blank target vector entries are initialized to target_ignore.  */</span>
<a name="l01934"></a>01934 <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a119eb2041a8896f0551d5ace75b5d4be">target_ignore</a> (<span class="keywordtype">void</span>);
<a name="l01935"></a>01935 
<a name="l01936"></a>01936 <span class="comment">/* See to_supports_btrace in struct target_ops.  */</span>
<a name="l01937"></a>01937 extern <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a33821057382151a8dc67bee9e1ce0970">target_supports_btrace</a> (<span class="keywordtype">void</span>);
<a name="l01938"></a>01938 
<a name="l01939"></a>01939 <span class="comment">/* See to_enable_btrace in struct target_ops.  */</span>
<a name="l01940"></a>01940 extern struct <a class="code" href="structbtrace__target__info.html">btrace_target_info</a> *<a class="code" href="target_8c.html#aded1bcaffb12ed864a71ce4a4dd98fc1">target_enable_btrace</a> (<a class="code" href="structptid.html">ptid_t</a> <a class="code" href="structptid.html">ptid</a>);
<a name="l01941"></a>01941 
<a name="l01942"></a>01942 <span class="comment">/* See to_disable_btrace in struct target_ops.  */</span>
<a name="l01943"></a>01943 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a63ca0a08ff74602ad280e1d92a0b2fc6">target_disable_btrace</a> (struct <a class="code" href="structbtrace__target__info.html">btrace_target_info</a> *btinfo);
<a name="l01944"></a>01944 
<a name="l01945"></a>01945 <span class="comment">/* See to_teardown_btrace in struct target_ops.  */</span>
<a name="l01946"></a>01946 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#aaaefe7e0bc728f0a8dccf823bf8db9f3">target_teardown_btrace</a> (struct <a class="code" href="structbtrace__target__info.html">btrace_target_info</a> *btinfo);
<a name="l01947"></a>01947 
<a name="l01948"></a>01948 <span class="comment">/* See to_read_btrace in struct target_ops.  */</span>
<a name="l01949"></a>01949 extern <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="structbtrace__block.html">btrace_block_s</a>) *target_read_btrace (struct <a class="code" href="structbtrace__target__info.html">btrace_target_info</a> *,
<a name="l01950"></a>01950                                                  enum <a class="code" href="btrace-common_8h.html#ab46be743c225007393dcf7650de682bc">btrace_read_type</a>);
<a name="l01951"></a>01951 
<a name="l01952"></a>01952 <span class="comment">/* See to_stop_recording in struct target_ops.  */</span>
<a name="l01953"></a>01953 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a3c0e7a989379c662716cfe2dbcb20228">target_stop_recording</a> (<span class="keywordtype">void</span>);
<a name="l01954"></a>01954 
<a name="l01955"></a>01955 <span class="comment">/* See to_info_record in struct target_ops.  */</span>
<a name="l01956"></a>01956 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a41b62d4c8e0f5badd9ffe00d684ca5ed">target_info_record</a> (<span class="keywordtype">void</span>);
<a name="l01957"></a>01957 
<a name="l01958"></a>01958 <span class="comment">/* See to_save_record in struct target_ops.  */</span>
<a name="l01959"></a>01959 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a919dae4413472f48888735f149dedb93">target_save_record</a> (<a class="code" href="p-lang_8h.html#a21296fc6f36ba2fc4d9780fdd126acb5">const</a> <span class="keywordtype">char</span> *filename);
<a name="l01960"></a>01960 
<a name="l01961"></a>01961 <span class="comment">/* Query if the target supports deleting the execution log.  */</span>
<a name="l01962"></a>01962 extern <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a733bbdf95a6514e6da9ee329fb1123eb">target_supports_delete_record</a> (<span class="keywordtype">void</span>);
<a name="l01963"></a>01963 
<a name="l01964"></a>01964 <span class="comment">/* See to_delete_record in struct target_ops.  */</span>
<a name="l01965"></a>01965 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#aea367eb54937aba4d676ac05cca8f597">target_delete_record</a> (<span class="keywordtype">void</span>);
<a name="l01966"></a>01966 
<a name="l01967"></a>01967 <span class="comment">/* See to_record_is_replaying in struct target_ops.  */</span>
<a name="l01968"></a>01968 extern <span class="keywordtype">int</span> <a class="code" href="target_8c.html#a8777ac691d1328a7d5a2e47bdb9843a6">target_record_is_replaying</a> (<span class="keywordtype">void</span>);
<a name="l01969"></a>01969 
<a name="l01970"></a>01970 <span class="comment">/* See to_goto_record_begin in struct target_ops.  */</span>
<a name="l01971"></a>01971 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#ad11fc9198bcac3191dae427b4db648f8">target_goto_record_begin</a> (<span class="keywordtype">void</span>);
<a name="l01972"></a>01972 
<a name="l01973"></a>01973 <span class="comment">/* See to_goto_record_end in struct target_ops.  */</span>
<a name="l01974"></a>01974 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a3f0b071578d460c28ff741153106a3aa">target_goto_record_end</a> (<span class="keywordtype">void</span>);
<a name="l01975"></a>01975 
<a name="l01976"></a>01976 <span class="comment">/* See to_goto_record in struct target_ops.  */</span>
<a name="l01977"></a>01977 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a0a23d0206bd5c0c2be6a7e05f7a0a842">target_goto_record</a> (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> insn);
<a name="l01978"></a>01978 
<a name="l01979"></a>01979 <span class="comment">/* See to_insn_history.  */</span>
<a name="l01980"></a>01980 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a7b06761cdee3744cd14b4d115d043372">target_insn_history</a> (<span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>, <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a>);
<a name="l01981"></a>01981 
<a name="l01982"></a>01982 <span class="comment">/* See to_insn_history_from.  */</span>
<a name="l01983"></a>01983 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a162f23e1c2faefa4fea4086b25866ab4">target_insn_history_from</a> (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="varobj_8h.html#a43396decd62b46fa01cc6c66a84cbba1">from</a>, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> flags);
<a name="l01984"></a>01984 
<a name="l01985"></a>01985 <span class="comment">/* See to_insn_history_range.  */</span>
<a name="l01986"></a>01986 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#acdd6d7bd871599282018dcd22c0d3025">target_insn_history_range</a> (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> begin, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> end, <span class="keywordtype">int</span> flags);
<a name="l01987"></a>01987 
<a name="l01988"></a>01988 <span class="comment">/* See to_call_history.  */</span>
<a name="l01989"></a>01989 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a8dd298bddb8afd59e0b0d25ef4d35762">target_call_history</a> (<span class="keywordtype">int</span> size, <span class="keywordtype">int</span> flags);
<a name="l01990"></a>01990 
<a name="l01991"></a>01991 <span class="comment">/* See to_call_history_from.  */</span>
<a name="l01992"></a>01992 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a25f15b2fbcf68535644a719a7756ed31">target_call_history_from</a> (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> begin, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> flags);
<a name="l01993"></a>01993 
<a name="l01994"></a>01994 <span class="comment">/* See to_call_history_range.  */</span>
<a name="l01995"></a>01995 extern <span class="keywordtype">void</span> <a class="code" href="target_8c.html#a71057ee1da022f42a2e4a23e5e69744c">target_call_history_range</a> (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> begin, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> end, <span class="keywordtype">int</span> flags);
<a name="l01996"></a>01996 
<a name="l01997"></a>01997 <span class="preprocessor">#endif </span><span class="comment">/* !defined (TARGET_H) */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:12:26 for GDB (API) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
