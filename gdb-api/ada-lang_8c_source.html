<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (API): /home/stan/gdb/src/gdb/ada-lang.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (API)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/ada-lang.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="ada-lang_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Ada language support routines for GDB, the GNU debugger.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 1992-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   This file is part of GDB.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00010"></a>00010 <span class="comment">   (at your option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00018"></a>00018 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="gdb__string_8h.html">gdb_string.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;demangle.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="gdb__regex_8h.html">gdb_regex.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="frame_8h.html">frame.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="gdbtypes_8h.html">gdbtypes.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="gdbcmd_8h.html">gdbcmd.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="expression_8h.html">expression.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="parser-defs_8h.html">parser-defs.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="language_8h.html">language.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="c-lang_8h.html">c-lang.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="inferior_8h.html">inferior.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="symfile_8h.html">symfile.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="objfiles_8h.html">objfiles.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="breakpoint_8h.html">breakpoint.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="gdbcore_8h.html">gdbcore.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;hashtab.h&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="gdb__obstack_8h.html">gdb_obstack.h</a>&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;<a class="code" href="ada-lang_8h.html">ada-lang.h</a>&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="completer_8h.html">completer.h</a>&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="gdb__stat_8h.html">gdb_stat.h</a>&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#ifdef UI_OUT</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="ui-out_8h.html">ui-out.h</a>&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#endif</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="block_8h.html">block.h</a>&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;<a class="code" href="infcall_8h.html">infcall.h</a>&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;<a class="code" href="dictionary_8h.html">dictionary.h</a>&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;<a class="code" href="exceptions_8h.html">exceptions.h</a>&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;<a class="code" href="annotate_8h.html">annotate.h</a>&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;<a class="code" href="valprint_8h.html">valprint.h</a>&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;<a class="code" href="source_8h.html">source.h</a>&quot;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &quot;<a class="code" href="observer_8h.html">observer.h</a>&quot;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &quot;<a class="code" href="vec_8h.html">vec.h</a>&quot;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &quot;<a class="code" href="stack_8h.html">stack.h</a>&quot;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &quot;<a class="code" href="gdb__vecs_8h.html">gdb_vecs.h</a>&quot;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &quot;<a class="code" href="typeprint_8h.html">typeprint.h</a>&quot;</span>
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="preprocessor">#include &quot;<a class="code" href="psymtab_8h.html">psymtab.h</a>&quot;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &quot;<a class="code" href="value_8h.html">value.h</a>&quot;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &quot;<a class="code" href="mi-common_8h.html">mi/mi-common.h</a>&quot;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &quot;<a class="code" href="arch-utils_8h.html">arch-utils.h</a>&quot;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &quot;<a class="code" href="exceptions_8h.html">exceptions.h</a>&quot;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &quot;<a class="code" href="cli-utils_8h.html">cli/cli-utils.h</a>&quot;</span>
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">/* Define whether or not the C operator &#39;/&#39; truncates towards zero for</span>
<a name="l00070"></a>00070 <span class="comment">   differently signed operands (truncation direction is undefined in C).</span>
<a name="l00071"></a>00071 <span class="comment">   Copied from valarith.c.  */</span>
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="preprocessor">#ifndef TRUNCATION_TOWARDS_ZERO</span>
<a name="l00074"></a><a class="code" href="ada-lang_8c.html#a57a219b3331c740472bbd7ed4124598c">00074</a> <span class="preprocessor"></span><span class="preprocessor">#define TRUNCATION_TOWARDS_ZERO ((-5 / 2) == -2)</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span>
<a name="l00077"></a>00077 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *desc_base_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *desc_bounds_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="keyword">static</span> <span class="keyword">struct </span>value *desc_bounds (<span class="keyword">struct</span> value *);
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="keyword">static</span> <span class="keywordtype">int</span> fat_pntr_bounds_bitpos (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="keyword">static</span> <span class="keywordtype">int</span> fat_pntr_bounds_bitsize (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *desc_data_target_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="keyword">static</span> <span class="keyword">struct </span>value *desc_data (<span class="keyword">struct</span> value *);
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="keyword">static</span> <span class="keywordtype">int</span> fat_pntr_data_bitpos (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="keyword">static</span> <span class="keywordtype">int</span> fat_pntr_data_bitsize (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="keyword">static</span> <span class="keyword">struct </span>value *desc_one_bound (<span class="keyword">struct</span> value *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="keyword">static</span> <span class="keywordtype">int</span> desc_bound_bitpos (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="keyword">static</span> <span class="keywordtype">int</span> desc_bound_bitsize (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *desc_index_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keywordtype">int</span>);
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="keyword">static</span> <span class="keywordtype">int</span> desc_arity (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 <span class="keyword">static</span> <span class="keywordtype">int</span> ada_type_match (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keywordtype">int</span>);
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="keyword">static</span> <span class="keywordtype">int</span> ada_args_match (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *, <span class="keyword">struct</span> value **, <span class="keywordtype">int</span>);
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="keyword">static</span> <span class="keywordtype">int</span> full_match (<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="keyword">static</span> <span class="keyword">struct </span>value *make_array_descriptor (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> value *);
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 <span class="keyword">static</span> <span class="keywordtype">void</span> ada_add_block_symbols (<span class="keyword">struct</span> obstack *,
<a name="l00114"></a>00114                                    <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *,
<a name="l00115"></a>00115                                    <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a>, <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *, <span class="keywordtype">int</span>);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 <span class="keyword">static</span> <span class="keywordtype">int</span> is_nonfunction (<span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *, <span class="keywordtype">int</span>);
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="keyword">static</span> <span class="keywordtype">void</span> add_defn_to_vec (<span class="keyword">struct</span> obstack *, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *,
<a name="l00120"></a>00120                              <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *);
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keyword">static</span> <span class="keywordtype">int</span> num_defns_collected (<span class="keyword">struct</span> obstack *);
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *defns_collected (<span class="keyword">struct</span> obstack *, <span class="keywordtype">int</span>);
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="keyword">static</span> <span class="keyword">struct </span>value *resolve_subexp (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> **, <span class="keywordtype">int</span> *, <span class="keywordtype">int</span>,
<a name="l00127"></a>00127                                      <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 <span class="keyword">static</span> <span class="keywordtype">void</span> replace_operator_with_call (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> **, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>,
<a name="l00130"></a>00130                                         <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *);
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 <span class="keyword">static</span> <span class="keywordtype">int</span> possible_user_operator_p (<span class="keyword">enum</span> <a class="code" href="expression_8h.html#a13f8bfc7b2a183fe56716508bfddae41">exp_opcode</a>, <span class="keyword">struct</span> value **);
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="keyword">static</span> <span class="keywordtype">char</span> *ada_op_name (<span class="keyword">enum</span> <a class="code" href="expression_8h.html#a13f8bfc7b2a183fe56716508bfddae41">exp_opcode</a>);
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *ada_decoded_op_name (<span class="keyword">enum</span> <a class="code" href="expression_8h.html#a13f8bfc7b2a183fe56716508bfddae41">exp_opcode</a>);
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 <span class="keyword">static</span> <span class="keywordtype">int</span> numeric_type_p (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="keyword">static</span> <span class="keywordtype">int</span> integer_type_p (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="keyword">static</span> <span class="keywordtype">int</span> scalar_type_p (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="keyword">static</span> <span class="keywordtype">int</span> discrete_type_p (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5dec">ada_renaming_category</a> parse_old_style_renaming (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l00147"></a>00147                                                             <span class="keyword">const</span> <span class="keywordtype">char</span> **,
<a name="l00148"></a>00148                                                             <span class="keywordtype">int</span> *,
<a name="l00149"></a>00149                                                             <span class="keyword">const</span> <span class="keywordtype">char</span> **);
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *find_old_style_renaming_symbol (<span class="keyword">const</span> <span class="keywordtype">char</span> *,
<a name="l00152"></a>00152                                                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *);
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *ada_lookup_struct_elt_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keywordtype">char</span> *,
<a name="l00155"></a>00155                                                 <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span> *);
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <span class="keyword">static</span> <span class="keyword">struct </span>value *evaluate_subexp_type (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *, <span class="keywordtype">int</span> *);
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *ada_find_parallel_type_with_name (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l00160"></a>00160                                                       <span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 <span class="keyword">static</span> <span class="keywordtype">int</span> is_dynamic_field (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keywordtype">int</span>);
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *to_fixed_variant_branch_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *,
<a name="l00165"></a>00165                                                   <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *,
<a name="l00166"></a>00166                                                   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>, <span class="keyword">struct</span> value *);
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *to_fixed_array_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> value *, <span class="keywordtype">int</span>);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *to_fixed_range_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> value *);
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *to_static_fixed_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00173"></a>00173 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *static_unwrap_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>);
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="keyword">static</span> <span class="keyword">struct </span>value *unwrap_value (<span class="keyword">struct</span> value *);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *constrained_packed_array_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keywordtype">long</span> *);
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *decode_constrained_packed_array_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 <span class="keyword">static</span> <span class="keywordtype">long</span> decode_packed_array_bitsize (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="keyword">static</span> <span class="keyword">struct </span>value *decode_constrained_packed_array (<span class="keyword">struct</span> value *);
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 <span class="keyword">static</span> <span class="keywordtype">int</span> ada_is_packed_array_type  (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="keyword">static</span> <span class="keywordtype">int</span> ada_is_unconstrained_packed_array_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="keyword">static</span> <span class="keyword">struct </span>value *value_subscript_packed (<span class="keyword">struct</span> value *, <span class="keywordtype">int</span>,
<a name="l00190"></a>00190                                              <span class="keyword">struct</span> value **);
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 <span class="keyword">static</span> <span class="keywordtype">void</span> move_bits (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *, <span class="keywordtype">int</span>, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 <span class="keyword">static</span> <span class="keyword">struct </span>value *coerce_unspec_val_to_type (<span class="keyword">struct</span> value *,
<a name="l00195"></a>00195                                                 <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="keyword">static</span> <span class="keyword">struct </span>value *get_var_value (<span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *);
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="keyword">static</span> <span class="keywordtype">int</span> lesseq_defined_than (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *);
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 <span class="keyword">static</span> <span class="keywordtype">int</span> equiv_types (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00202"></a>00202 
<a name="l00203"></a>00203 <span class="keyword">static</span> <span class="keywordtype">int</span> is_name_suffix (<span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="keyword">static</span> <span class="keywordtype">int</span> advance_wild_match (<span class="keyword">const</span> <span class="keywordtype">char</span> **, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>);
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 <span class="keyword">static</span> <span class="keywordtype">int</span> wild_match (<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="keyword">static</span> <span class="keyword">struct </span>value *ada_coerce_ref (<span class="keyword">struct</span> value *);
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> pos_atr (<span class="keyword">struct</span> value *);
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="keyword">static</span> <span class="keyword">struct </span>value *value_pos_atr (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> value *);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 <span class="keyword">static</span> <span class="keyword">struct </span>value *value_val_atr (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> value *);
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *standard_lookup (<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *,
<a name="l00218"></a>00218                                        <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a>);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 <span class="keyword">static</span> <span class="keyword">struct </span>value *ada_search_struct_field (<span class="keywordtype">char</span> *, <span class="keyword">struct</span> value *, <span class="keywordtype">int</span>,
<a name="l00221"></a>00221                                               <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00222"></a>00222 
<a name="l00223"></a>00223 <span class="keyword">static</span> <span class="keyword">struct </span>value *ada_value_primitive_field (<span class="keyword">struct</span> value *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>,
<a name="l00224"></a>00224                                                 <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="keyword">static</span> <span class="keywordtype">int</span> find_struct_field (<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keywordtype">int</span>,
<a name="l00227"></a>00227                               <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> **, <span class="keywordtype">int</span> *, <span class="keywordtype">int</span> *, <span class="keywordtype">int</span> *, <span class="keywordtype">int</span> *);
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="keyword">static</span> <span class="keyword">struct </span>value *ada_to_fixed_value_create (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>,
<a name="l00230"></a>00230                                                 <span class="keyword">struct</span> value *);
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="keyword">static</span> <span class="keywordtype">int</span> ada_resolve_function (<span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *, <span class="keywordtype">int</span>,
<a name="l00233"></a>00233                                  <span class="keyword">struct</span> value **, <span class="keywordtype">int</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *,
<a name="l00234"></a>00234                                  <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="keyword">static</span> <span class="keywordtype">int</span> ada_is_direct_array_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="keyword">static</span> <span class="keywordtype">void</span> ada_language_arch_info (<span class="keyword">struct</span> gdbarch *,
<a name="l00239"></a>00239                                     <span class="keyword">struct</span> <a class="code" href="structlanguage__arch__info.html">language_arch_info</a> *);
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="keyword">static</span> <span class="keywordtype">void</span> check_size (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="keyword">static</span> <span class="keyword">struct </span>value *ada_index_struct_field (<span class="keywordtype">int</span>, <span class="keyword">struct</span> value *, <span class="keywordtype">int</span>,
<a name="l00244"></a>00244                                              <span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *);
<a name="l00245"></a>00245 
<a name="l00246"></a>00246 <span class="keyword">static</span> <span class="keyword">struct </span>value *assign_aggregate (<span class="keyword">struct</span> value *, <span class="keyword">struct</span> value *, 
<a name="l00247"></a>00247                                        <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *,
<a name="l00248"></a>00248                                        <span class="keywordtype">int</span> *, <span class="keyword">enum</span> <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73">noside</a>);
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 <span class="keyword">static</span> <span class="keywordtype">void</span> aggregate_assign_from_choices (<span class="keyword">struct</span> value *, <span class="keyword">struct</span> value *, 
<a name="l00251"></a>00251                                            <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *,
<a name="l00252"></a>00252                                            <span class="keywordtype">int</span> *, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *, <span class="keywordtype">int</span> *,
<a name="l00253"></a>00253                                            <span class="keywordtype">int</span>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>);
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 <span class="keyword">static</span> <span class="keywordtype">void</span> aggregate_assign_positional (<span class="keyword">struct</span> value *, <span class="keyword">struct</span> value *,
<a name="l00256"></a>00256                                          <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *,
<a name="l00257"></a>00257                                          <span class="keywordtype">int</span> *, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *, <span class="keywordtype">int</span> *, <span class="keywordtype">int</span>,
<a name="l00258"></a>00258                                          <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>);
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 <span class="keyword">static</span> <span class="keywordtype">void</span> aggregate_assign_others (<span class="keyword">struct</span> value *, <span class="keyword">struct</span> value *,
<a name="l00262"></a>00262                                      <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *,
<a name="l00263"></a>00263                                      <span class="keywordtype">int</span> *, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *, <span class="keywordtype">int</span>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 
<a name="l00266"></a>00266 <span class="keyword">static</span> <span class="keywordtype">void</span> add_component_interval (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *, <span class="keywordtype">int</span> *, <span class="keywordtype">int</span>);
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 <span class="keyword">static</span> <span class="keyword">struct </span>value *ada_evaluate_subexp (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *, <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *,
<a name="l00270"></a>00270                                           <span class="keywordtype">int</span> *, <span class="keyword">enum</span> <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73">noside</a>);
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 <span class="keyword">static</span> <span class="keywordtype">void</span> ada_forward_operator_length (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span> *,
<a name="l00273"></a>00273                                          <span class="keywordtype">int</span> *);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *ada_find_any_type (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="comment">/* Maximum-sized dynamic type.  */</span>
<a name="l00280"></a>00280 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> varsize_limit;
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 <span class="comment">/* FIXME: brobecker/2003-09-17: No longer a const because it is</span>
<a name="l00283"></a>00283 <span class="comment">   returned by a function that does not return a const char *.  */</span>
<a name="l00284"></a>00284 <span class="keyword">static</span> <span class="keywordtype">char</span> *ada_completer_word_break_characters =
<a name="l00285"></a>00285 <span class="preprocessor">#ifdef VMS</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span>  <span class="stringliteral">&quot; \t\n!@#%^&amp;*()+=|~`}{[]\&quot;;:?/,-&quot;</span>;
<a name="l00287"></a>00287 <span class="preprocessor">#else</span>
<a name="l00288"></a>00288 <span class="preprocessor"></span>  <span class="stringliteral">&quot; \t\n!@#$%^&amp;*()+=|~`}{[]\&quot;;:?/,-&quot;</span>;
<a name="l00289"></a>00289 <span class="preprocessor">#endif</span>
<a name="l00290"></a>00290 <span class="preprocessor"></span>
<a name="l00291"></a>00291 <span class="comment">/* The name of the symbol to use to get the name of the main subprogram.  */</span>
<a name="l00292"></a>00292 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> ADA_MAIN_PROGRAM_SYMBOL_NAME[]
<a name="l00293"></a>00293   = <span class="stringliteral">&quot;__gnat_ada_main_program_name&quot;</span>;
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="comment">/* Limit on the number of warnings to raise per expression evaluation.  */</span>
<a name="l00296"></a>00296 <span class="keyword">static</span> <span class="keywordtype">int</span> warning_limit = 2;
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="comment">/* Number of warning messages issued; reset to 0 by cleanups after</span>
<a name="l00299"></a>00299 <span class="comment">   expression evaluation.  */</span>
<a name="l00300"></a>00300 <span class="keyword">static</span> <span class="keywordtype">int</span> warnings_issued = 0;
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *known_runtime_file_name_patterns[] = {
<a name="l00303"></a>00303   ADA_KNOWN_RUNTIME_FILE_NAME_PATTERNS NULL
<a name="l00304"></a>00304 };
<a name="l00305"></a>00305 
<a name="l00306"></a>00306 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *known_auxiliary_function_name_patterns[] = {
<a name="l00307"></a>00307   <a class="code" href="ada-lang_8h.html#aa52d79d5b04803859bf3423df58dc390">ADA_KNOWN_AUXILIARY_FUNCTION_NAME_PATTERNS</a> NULL
<a name="l00308"></a>00308 };
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 <span class="comment">/* Space for allocating results of ada_lookup_symbol_list.  */</span>
<a name="l00311"></a>00311 <span class="keyword">static</span> <span class="keyword">struct </span>obstack symbol_list_obstack;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313                         <span class="comment">/* Inferior-specific data.  */</span>
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 <span class="comment">/* Per-inferior data for this module.  */</span>
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 <span class="keyword">struct </span>ada_inferior_data
<a name="l00318"></a>00318 {
<a name="l00319"></a>00319   <span class="comment">/* The ada__tags__type_specific_data type, which is used when decoding</span>
<a name="l00320"></a>00320 <span class="comment">     tagged types.  With older versions of GNAT, this type was directly</span>
<a name="l00321"></a>00321 <span class="comment">     accessible through a component (&quot;tsd&quot;) in the object tag.  But this</span>
<a name="l00322"></a>00322 <span class="comment">     is no longer the case, so we cache it for each inferior.  */</span>
<a name="l00323"></a>00323   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *tsd_type;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325   <span class="comment">/* The exception_support_info data.  This data is used to determine</span>
<a name="l00326"></a>00326 <span class="comment">     how to implement support for Ada exception catchpoints in a given</span>
<a name="l00327"></a>00327 <span class="comment">     inferior.  */</span>
<a name="l00328"></a>00328   <span class="keyword">const</span> <span class="keyword">struct </span>exception_support_info *exception_info;
<a name="l00329"></a>00329 };
<a name="l00330"></a>00330 
<a name="l00331"></a>00331 <span class="comment">/* Our key to this module&#39;s inferior data.  */</span>
<a name="l00332"></a>00332 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>inferior_data *ada_inferior_data;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 <span class="comment">/* A cleanup routine for our inferior data.  */</span>
<a name="l00335"></a>00335 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00336"></a>00336 ada_inferior_data_cleanup (<span class="keyword">struct</span> <a class="code" href="structinferior.html">inferior</a> *<a class="code" href="namespacearm-linux.html#aaf6bae53545ee96f24d7ba560ed0a205">inf</a>, <span class="keywordtype">void</span> *arg)
<a name="l00337"></a>00337 {
<a name="l00338"></a>00338   <span class="keyword">struct </span>ada_inferior_data *data;
<a name="l00339"></a>00339 
<a name="l00340"></a>00340   data = inferior_data (inf, ada_inferior_data);
<a name="l00341"></a>00341   <span class="keywordflow">if</span> (data != NULL)
<a name="l00342"></a>00342     <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (data);
<a name="l00343"></a>00343 }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 <span class="comment">/* Return our inferior data for the given inferior (INF).</span>
<a name="l00346"></a>00346 <span class="comment"></span>
<a name="l00347"></a>00347 <span class="comment">   This function always returns a valid pointer to an allocated</span>
<a name="l00348"></a>00348 <span class="comment">   ada_inferior_data structure.  If INF&#39;s inferior data has not</span>
<a name="l00349"></a>00349 <span class="comment">   been previously set, this functions creates a new one with all</span>
<a name="l00350"></a>00350 <span class="comment">   fields set to zero, sets INF&#39;s inferior to it, and then returns</span>
<a name="l00351"></a>00351 <span class="comment">   a pointer to that newly allocated ada_inferior_data.  */</span>
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <span class="keyword">static</span> <span class="keyword">struct </span>ada_inferior_data *
<a name="l00354"></a>00354 get_ada_inferior_data (<span class="keyword">struct</span> <a class="code" href="structinferior.html">inferior</a> *inf)
<a name="l00355"></a>00355 {
<a name="l00356"></a>00356   <span class="keyword">struct </span>ada_inferior_data *data;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358   data = inferior_data (inf, ada_inferior_data);
<a name="l00359"></a>00359   <span class="keywordflow">if</span> (data == NULL)
<a name="l00360"></a>00360     {
<a name="l00361"></a>00361       data = <a class="code" href="defs_8h.html#ab004b072c2eba9eb35ffb7b86a72b8c0">XZALLOC</a> (<span class="keyword">struct</span> ada_inferior_data);
<a name="l00362"></a>00362       set_inferior_data (inf, ada_inferior_data, data);
<a name="l00363"></a>00363     }
<a name="l00364"></a>00364 
<a name="l00365"></a>00365   <span class="keywordflow">return</span> data;
<a name="l00366"></a>00366 }
<a name="l00367"></a>00367 
<a name="l00368"></a>00368 <span class="comment">/* Perform all necessary cleanups regarding our module&#39;s inferior data</span>
<a name="l00369"></a>00369 <span class="comment">   that is required after the inferior INF just exited.  */</span>
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00372"></a>00372 ada_inferior_exit (<span class="keyword">struct</span> <a class="code" href="structinferior.html">inferior</a> *inf)
<a name="l00373"></a>00373 {
<a name="l00374"></a>00374   ada_inferior_data_cleanup (inf, NULL);
<a name="l00375"></a>00375   set_inferior_data (inf, ada_inferior_data, NULL);
<a name="l00376"></a>00376 }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378                         <span class="comment">/* Utilities */</span>
<a name="l00379"></a>00379 
<a name="l00380"></a>00380 <span class="comment">/* If TYPE is a TYPE_CODE_TYPEDEF type, return the target type after</span>
<a name="l00381"></a>00381 <span class="comment">   all typedef layers have been peeled.  Otherwise, return TYPE.</span>
<a name="l00382"></a>00382 <span class="comment"></span>
<a name="l00383"></a>00383 <span class="comment">   Normally, we really expect a typedef type to only have 1 typedef layer.</span>
<a name="l00384"></a>00384 <span class="comment">   In other words, we really expect the target type of a typedef type to be</span>
<a name="l00385"></a>00385 <span class="comment">   a non-typedef type.  This is particularly true for Ada units, because</span>
<a name="l00386"></a>00386 <span class="comment">   the language does not have a typedef vs not-typedef distinction.</span>
<a name="l00387"></a>00387 <span class="comment">   In that respect, the Ada compiler has been trying to eliminate as many</span>
<a name="l00388"></a>00388 <span class="comment">   typedef definitions in the debugging information, since they generally</span>
<a name="l00389"></a>00389 <span class="comment">   do not bring any extra information (we still use typedef under certain</span>
<a name="l00390"></a>00390 <span class="comment">   circumstances related mostly to the GNAT encoding).</span>
<a name="l00391"></a>00391 <span class="comment"></span>
<a name="l00392"></a>00392 <span class="comment">   Unfortunately, we have seen situations where the debugging information</span>
<a name="l00393"></a>00393 <span class="comment">   generated by the compiler leads to such multiple typedef layers.  For</span>
<a name="l00394"></a>00394 <span class="comment">   instance, consider the following example with stabs:</span>
<a name="l00395"></a>00395 <span class="comment"></span>
<a name="l00396"></a>00396 <span class="comment">     .stabs  &quot;pck__float_array___XUP:Tt(0,46)=s16P_ARRAY:(0,47)=[...]&quot;[...]</span>
<a name="l00397"></a>00397 <span class="comment">     .stabs  &quot;pck__float_array___XUP:t(0,36)=(0,46)&quot;,128,0,6,0</span>
<a name="l00398"></a>00398 <span class="comment"></span>
<a name="l00399"></a>00399 <span class="comment">   This is an error in the debugging information which causes type</span>
<a name="l00400"></a>00400 <span class="comment">   pck__float_array___XUP to be defined twice, and the second time,</span>
<a name="l00401"></a>00401 <span class="comment">   it is defined as a typedef of a typedef.</span>
<a name="l00402"></a>00402 <span class="comment"></span>
<a name="l00403"></a>00403 <span class="comment">   This is on the fringe of legality as far as debugging information is</span>
<a name="l00404"></a>00404 <span class="comment">   concerned, and certainly unexpected.  But it is easy to handle these</span>
<a name="l00405"></a>00405 <span class="comment">   situations correctly, so we can afford to be lenient in this case.  */</span>
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l00408"></a>00408 ada_typedef_target_type (<span class="keyword">struct</span> <a class="code" href="structtype.html">type</a> *<a class="code" href="structtype.html">type</a>)
<a name="l00409"></a>00409 {
<a name="l00410"></a>00410   <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>)
<a name="l00411"></a>00411     type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l00412"></a>00412   <span class="keywordflow">return</span> type;
<a name="l00413"></a>00413 }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415 <span class="comment">/* Given DECODED_NAME a string holding a symbol name in its</span>
<a name="l00416"></a>00416 <span class="comment">   decoded form (ie using the Ada dotted notation), returns</span>
<a name="l00417"></a>00417 <span class="comment">   its unqualified name.  */</span>
<a name="l00418"></a>00418 
<a name="l00419"></a>00419 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00420"></a>00420 ada_unqualified_name (<span class="keyword">const</span> <span class="keywordtype">char</span> *decoded_name)
<a name="l00421"></a>00421 {
<a name="l00422"></a>00422   <span class="keyword">const</span> <span class="keywordtype">char</span> *result = <a class="code" href="gdb__string_8h.html#a5cbb8bbfc7174d9468b1853f1031efb3">strrchr</a> (decoded_name, <span class="charliteral">&#39;.&#39;</span>);
<a name="l00423"></a>00423 
<a name="l00424"></a>00424   <span class="keywordflow">if</span> (result != NULL)
<a name="l00425"></a>00425     result++;                   <span class="comment">/* Skip the dot...  */</span>
<a name="l00426"></a>00426   <span class="keywordflow">else</span>
<a name="l00427"></a>00427     result = decoded_name;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="keywordflow">return</span> result;
<a name="l00430"></a>00430 }
<a name="l00431"></a>00431 
<a name="l00432"></a>00432 <span class="comment">/* Return a string starting with &#39;&lt;&#39;, followed by STR, and &#39;&gt;&#39;.</span>
<a name="l00433"></a>00433 <span class="comment">   The result is good until the next call.  */</span>
<a name="l00434"></a>00434 
<a name="l00435"></a>00435 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00436"></a>00436 add_angle_brackets (<span class="keyword">const</span> <span class="keywordtype">char</span> *str)
<a name="l00437"></a>00437 {
<a name="l00438"></a>00438   <span class="keyword">static</span> <span class="keywordtype">char</span> *result = NULL;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (result);
<a name="l00441"></a>00441   result = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;&lt;%s&gt;&quot;</span>, str);
<a name="l00442"></a>00442   <span class="keywordflow">return</span> result;
<a name="l00443"></a>00443 }
<a name="l00444"></a>00444 
<a name="l00445"></a>00445 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00446"></a>00446 ada_get_gdb_completer_word_break_characters (<span class="keywordtype">void</span>)
<a name="l00447"></a>00447 {
<a name="l00448"></a>00448   <span class="keywordflow">return</span> ada_completer_word_break_characters;
<a name="l00449"></a>00449 }
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 <span class="comment">/* Print an array element index using the Ada syntax.  */</span>
<a name="l00452"></a>00452 
<a name="l00453"></a>00453 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00454"></a>00454 ada_print_array_index (<span class="keyword">struct</span> value *index_value, <span class="keyword">struct</span> ui_file *stream,
<a name="l00455"></a>00455                        <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structvalue__print__options.html">value_print_options</a> *options)
<a name="l00456"></a>00456 {
<a name="l00457"></a>00457   <a class="code" href="language_8h.html#ac0685c2a7d84d3597db524688d69b387">LA_VALUE_PRINT</a> (index_value, stream, options);
<a name="l00458"></a>00458   <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (stream, <span class="stringliteral">&quot; =&gt; &quot;</span>);
<a name="l00459"></a>00459 }
<a name="l00460"></a>00460 
<a name="l00461"></a>00461 <span class="comment">/* Assuming VECT points to an array of *SIZE objects of size</span>
<a name="l00462"></a>00462 <span class="comment">   ELEMENT_SIZE, grow it to contain at least MIN_SIZE objects,</span>
<a name="l00463"></a>00463 <span class="comment">   updating *SIZE as necessary and returning the (new) array.  */</span>
<a name="l00464"></a>00464 
<a name="l00465"></a>00465 <span class="keywordtype">void</span> *
<a name="l00466"></a><a class="code" href="ada-lang_8h.html#af3261fa03110009eaaa0241cacc54d5d">00466</a> <a class="code" href="ada-lang_8c.html#a022eaac75d1cbe8dfaaff7c59bb6c9f8">grow_vect</a> (<span class="keywordtype">void</span> *vect, <span class="keywordtype">size_t</span> *<a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>, <span class="keywordtype">size_t</span> min_size, <span class="keywordtype">int</span> element_size)
<a name="l00467"></a>00467 {
<a name="l00468"></a>00468   <span class="keywordflow">if</span> (*size &lt; min_size)
<a name="l00469"></a>00469     {
<a name="l00470"></a>00470       *size *= 2;
<a name="l00471"></a>00471       <span class="keywordflow">if</span> (*size &lt; min_size)
<a name="l00472"></a>00472         *size = min_size;
<a name="l00473"></a>00473       vect = <a class="code" href="common-utils_8c.html#af404b7244f442ce8c3069f31af566eae">xrealloc</a> (vect, *size * element_size);
<a name="l00474"></a>00474     }
<a name="l00475"></a>00475   <span class="keywordflow">return</span> vect;
<a name="l00476"></a>00476 }
<a name="l00477"></a>00477 
<a name="l00478"></a>00478 <span class="comment">/* True (non-zero) iff TARGET matches FIELD_NAME up to any trailing</span>
<a name="l00479"></a>00479 <span class="comment">   suffix of FIELD_NAME beginning &quot;___&quot;.  */</span>
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00482"></a>00482 field_name_match (<span class="keyword">const</span> <span class="keywordtype">char</span> *field_name, <span class="keyword">const</span> <span class="keywordtype">char</span> *target)
<a name="l00483"></a>00483 {
<a name="l00484"></a>00484   <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a> = strlen (target);
<a name="l00485"></a>00485 
<a name="l00486"></a>00486   <span class="keywordflow">return</span>
<a name="l00487"></a>00487     (strncmp (field_name, target, len) == 0
<a name="l00488"></a>00488      &amp;&amp; (field_name[len] == <span class="charliteral">&#39;\0&#39;</span>
<a name="l00489"></a>00489          || (strncmp (field_name + len, <span class="stringliteral">&quot;___&quot;</span>, 3) == 0
<a name="l00490"></a>00490              &amp;&amp; strcmp (field_name + strlen (field_name) - 6,
<a name="l00491"></a>00491                         <span class="stringliteral">&quot;___XVN&quot;</span>) != 0)));
<a name="l00492"></a>00492 }
<a name="l00493"></a>00493 
<a name="l00494"></a>00494 
<a name="l00495"></a>00495 <span class="comment">/* Assuming TYPE is a TYPE_CODE_STRUCT or a TYPE_CODE_TYPDEF to</span>
<a name="l00496"></a>00496 <span class="comment">   a TYPE_CODE_STRUCT, find the field whose name matches FIELD_NAME,</span>
<a name="l00497"></a>00497 <span class="comment">   and return its index.  This function also handles fields whose name</span>
<a name="l00498"></a>00498 <span class="comment">   have ___ suffixes because the compiler sometimes alters their name</span>
<a name="l00499"></a>00499 <span class="comment">   by adding such a suffix to represent fields with certain constraints.</span>
<a name="l00500"></a>00500 <span class="comment">   If the field could not be found, return a negative number if</span>
<a name="l00501"></a>00501 <span class="comment">   MAYBE_MISSING is set.  Otherwise raise an error.  */</span>
<a name="l00502"></a>00502 
<a name="l00503"></a>00503 <span class="keywordtype">int</span>
<a name="l00504"></a><a class="code" href="ada-lang_8h.html#ad08ecb4f1114c5be687d6fb2ec6d9b60">00504</a> <a class="code" href="ada-lang_8c.html#ad08ecb4f1114c5be687d6fb2ec6d9b60">ada_get_field_index</a> (<span class="keyword">const</span> <span class="keyword">struct</span> type *type, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name,
<a name="l00505"></a>00505                      <span class="keywordtype">int</span> maybe_missing)
<a name="l00506"></a>00506 {
<a name="l00507"></a>00507   <span class="keywordtype">int</span> fieldno;
<a name="l00508"></a>00508   <span class="keyword">struct </span>type *struct_type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> ((<span class="keyword">struct</span> type *) type);
<a name="l00509"></a>00509 
<a name="l00510"></a>00510   <span class="keywordflow">for</span> (fieldno = 0; fieldno &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (struct_type); fieldno++)
<a name="l00511"></a>00511     <span class="keywordflow">if</span> (field_name_match (<a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (struct_type, fieldno), field_name))
<a name="l00512"></a>00512       <span class="keywordflow">return</span> fieldno;
<a name="l00513"></a>00513 
<a name="l00514"></a>00514   <span class="keywordflow">if</span> (!maybe_missing)
<a name="l00515"></a>00515     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unable to find field %s in struct %s.  Aborting&quot;</span>),
<a name="l00516"></a>00516            field_name, <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (struct_type));
<a name="l00517"></a>00517 
<a name="l00518"></a>00518   <span class="keywordflow">return</span> -1;
<a name="l00519"></a>00519 }
<a name="l00520"></a>00520 
<a name="l00521"></a>00521 <span class="comment">/* The length of the prefix of NAME prior to any &quot;___&quot; suffix.  */</span>
<a name="l00522"></a>00522 
<a name="l00523"></a>00523 <span class="keywordtype">int</span>
<a name="l00524"></a><a class="code" href="ada-lang_8h.html#a6ebcb2d43537cca25b9828d6bad4a7de">00524</a> <a class="code" href="ada-lang_8c.html#aa5624d1411eb736cbb8426496fadcf45">ada_name_prefix_len</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>)
<a name="l00525"></a>00525 {
<a name="l00526"></a>00526   <span class="keywordflow">if</span> (name == NULL)
<a name="l00527"></a>00527     <span class="keywordflow">return</span> 0;
<a name="l00528"></a>00528   <span class="keywordflow">else</span>
<a name="l00529"></a>00529     {
<a name="l00530"></a>00530       <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a> = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (name, <span class="stringliteral">&quot;___&quot;</span>);
<a name="l00531"></a>00531 
<a name="l00532"></a>00532       <span class="keywordflow">if</span> (p == NULL)
<a name="l00533"></a>00533         <span class="keywordflow">return</span> strlen (name);
<a name="l00534"></a>00534       <span class="keywordflow">else</span>
<a name="l00535"></a>00535         <span class="keywordflow">return</span> p - <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l00536"></a>00536     }
<a name="l00537"></a>00537 }
<a name="l00538"></a>00538 
<a name="l00539"></a>00539 <span class="comment">/* Return non-zero if SUFFIX is a suffix of STR.</span>
<a name="l00540"></a>00540 <span class="comment">   Return zero if STR is null.  */</span>
<a name="l00541"></a>00541 
<a name="l00542"></a>00542 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00543"></a>00543 is_suffix (<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keyword">const</span> <span class="keywordtype">char</span> *suffix)
<a name="l00544"></a>00544 {
<a name="l00545"></a>00545   <span class="keywordtype">int</span> len1, len2;
<a name="l00546"></a>00546 
<a name="l00547"></a>00547   <span class="keywordflow">if</span> (str == NULL)
<a name="l00548"></a>00548     <span class="keywordflow">return</span> 0;
<a name="l00549"></a>00549   len1 = strlen (str);
<a name="l00550"></a>00550   len2 = strlen (suffix);
<a name="l00551"></a>00551   <span class="keywordflow">return</span> (len1 &gt;= len2 &amp;&amp; strcmp (str + len1 - len2, suffix) == 0);
<a name="l00552"></a>00552 }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="comment">/* The contents of value VAL, treated as a value of type TYPE.  The</span>
<a name="l00555"></a>00555 <span class="comment">   result is an lval in memory if VAL is.  */</span>
<a name="l00556"></a>00556 
<a name="l00557"></a>00557 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l00558"></a>00558 coerce_unspec_val_to_type (<span class="keyword">struct</span> value *val, <span class="keyword">struct</span> type *type)
<a name="l00559"></a>00559 {
<a name="l00560"></a>00560   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l00561"></a>00561   <span class="keywordflow">if</span> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val) == type)
<a name="l00562"></a>00562     <span class="keywordflow">return</span> val;
<a name="l00563"></a>00563   <span class="keywordflow">else</span>
<a name="l00564"></a>00564     {
<a name="l00565"></a>00565       <span class="keyword">struct </span>value *result;
<a name="l00566"></a>00566 
<a name="l00567"></a>00567       <span class="comment">/* Make sure that the object size is not unreasonable before</span>
<a name="l00568"></a>00568 <span class="comment">         trying to allocate some memory for it.  */</span>
<a name="l00569"></a>00569       check_size (type);
<a name="l00570"></a>00570 
<a name="l00571"></a>00571       <span class="keywordflow">if</span> (<a class="code" href="value_8c.html#aa60bc8ecf77867a2d16bec57a4ccf983">value_lazy</a> (val)
<a name="l00572"></a>00572           || <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) &gt; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val)))
<a name="l00573"></a>00573         result = <a class="code" href="value_8c.html#a8421b27c5fb4ce6e2c972ecce4265d1b">allocate_value_lazy</a> (type);
<a name="l00574"></a>00574       <span class="keywordflow">else</span>
<a name="l00575"></a>00575         {
<a name="l00576"></a>00576           result = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (type);
<a name="l00577"></a>00577           <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="value_8c.html#a9f59e572fabef6e1905632fb81cc00e1">value_contents_raw</a> (result), <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (val),
<a name="l00578"></a>00578                   <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type));
<a name="l00579"></a>00579         }
<a name="l00580"></a>00580       <a class="code" href="value_8c.html#a3b68f85fbdfad03a038292fef7520e53">set_value_component_location</a> (result, val);
<a name="l00581"></a>00581       <a class="code" href="value_8c.html#a81ff3b095a88c76df6444a8394e72664">set_value_bitsize</a> (result, <a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (val));
<a name="l00582"></a>00582       <a class="code" href="value_8c.html#a21e0ad85da358983672e7b0420686067">set_value_bitpos</a> (result, <a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (val));
<a name="l00583"></a>00583       <a class="code" href="value_8c.html#a33ecd4bc76c6629df42dafee1158307d">set_value_address</a> (result, <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (val));
<a name="l00584"></a>00584       <a class="code" href="value_8c.html#ac01061d4f7eed5a816d4913070b5d851">set_value_optimized_out</a> (result, <a class="code" href="value_8c.html#ae144edbe3a243ae748cd758621c5d16d">value_optimized_out_const</a> (val));
<a name="l00585"></a>00585       <span class="keywordflow">return</span> result;
<a name="l00586"></a>00586     }
<a name="l00587"></a>00587 }
<a name="l00588"></a>00588 
<a name="l00589"></a>00589 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l00590"></a>00590 cond_offset_host (<span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valaddr, <span class="keywordtype">long</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>)
<a name="l00591"></a>00591 {
<a name="l00592"></a>00592   <span class="keywordflow">if</span> (valaddr == NULL)
<a name="l00593"></a>00593     <span class="keywordflow">return</span> NULL;
<a name="l00594"></a>00594   <span class="keywordflow">else</span>
<a name="l00595"></a>00595     <span class="keywordflow">return</span> valaddr + <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l00596"></a>00596 }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l00599"></a>00599 cond_offset_target (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address, <span class="keywordtype">long</span> offset)
<a name="l00600"></a>00600 {
<a name="l00601"></a>00601   <span class="keywordflow">if</span> (address == 0)
<a name="l00602"></a>00602     <span class="keywordflow">return</span> 0;
<a name="l00603"></a>00603   <span class="keywordflow">else</span>
<a name="l00604"></a>00604     <span class="keywordflow">return</span> address + <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l00605"></a>00605 }
<a name="l00606"></a>00606 
<a name="l00607"></a>00607 <span class="comment">/* Issue a warning (as for the definition of warning in utils.c, but</span>
<a name="l00608"></a>00608 <span class="comment">   with exactly one argument rather than ...), unless the limit on the</span>
<a name="l00609"></a>00609 <span class="comment">   number of warnings has passed during the evaluation of the current</span>
<a name="l00610"></a>00610 <span class="comment">   expression.  */</span>
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 <span class="comment">/* FIXME: cagney/2004-10-10: This function is mimicking the behavior</span>
<a name="l00613"></a>00613 <span class="comment">   provided by &quot;complaint&quot;.  */</span>
<a name="l00614"></a>00614 <span class="keyword">static</span> <span class="keywordtype">void</span> lim_warning (<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...) ATTRIBUTE_PRINTF (1, 2);
<a name="l00615"></a>00615 
<a name="l00616"></a>00616 static <span class="keywordtype">void</span>
<a name="l00617"></a>00617 lim_warning (<a class="code" href="p-lang_8h.html#a21296fc6f36ba2fc4d9780fdd126acb5">const</a> <span class="keywordtype">char</span> *format, ...)
<a name="l00618"></a>00618 {
<a name="l00619"></a>00619   va_list args;
<a name="l00620"></a>00620 
<a name="l00621"></a>00621   va_start (args, format);
<a name="l00622"></a>00622   warnings_issued += 1;
<a name="l00623"></a>00623   <span class="keywordflow">if</span> (warnings_issued &lt;= warning_limit)
<a name="l00624"></a>00624     <a class="code" href="utils_8c.html#ad7cc20b16f769f3cdc711c5f71aedba4">vwarning</a> (format, args);
<a name="l00625"></a>00625 
<a name="l00626"></a>00626   va_end (args);
<a name="l00627"></a>00627 }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629 <span class="comment">/* Issue an error if the size of an object of type T is unreasonable,</span>
<a name="l00630"></a>00630 <span class="comment">   i.e. if it would be a bad idea to allocate a value of this type in</span>
<a name="l00631"></a>00631 <span class="comment">   GDB.  */</span>
<a name="l00632"></a>00632 
<a name="l00633"></a>00633 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00634"></a>00634 check_size (<span class="keyword">const</span> <span class="keyword">struct</span> type *type)
<a name="l00635"></a>00635 {
<a name="l00636"></a>00636   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) &gt; varsize_limit)
<a name="l00637"></a>00637     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;object size is larger than varsize-limit&quot;</span>));
<a name="l00638"></a>00638 }
<a name="l00639"></a>00639 
<a name="l00640"></a>00640 <span class="comment">/* Maximum value of a SIZE-byte signed integer type.  */</span>
<a name="l00641"></a>00641 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l00642"></a>00642 max_of_size (<span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>)
<a name="l00643"></a>00643 {
<a name="l00644"></a>00644   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> top_bit = (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) 1 &lt;&lt; (size * 8 - 2);
<a name="l00645"></a>00645 
<a name="l00646"></a>00646   <span class="keywordflow">return</span> top_bit | (top_bit - 1);
<a name="l00647"></a>00647 }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649 <span class="comment">/* Minimum value of a SIZE-byte signed integer type.  */</span>
<a name="l00650"></a>00650 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l00651"></a>00651 min_of_size (<span class="keywordtype">int</span> size)
<a name="l00652"></a>00652 {
<a name="l00653"></a>00653   <span class="keywordflow">return</span> -max_of_size (size) - 1;
<a name="l00654"></a>00654 }
<a name="l00655"></a>00655 
<a name="l00656"></a>00656 <span class="comment">/* Maximum value of a SIZE-byte unsigned integer type.  */</span>
<a name="l00657"></a>00657 <span class="keyword">static</span> <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a>
<a name="l00658"></a>00658 umax_of_size (<span class="keywordtype">int</span> size)
<a name="l00659"></a>00659 {
<a name="l00660"></a>00660   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> top_bit = (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a>) 1 &lt;&lt; (size * 8 - 1);
<a name="l00661"></a>00661 
<a name="l00662"></a>00662   <span class="keywordflow">return</span> top_bit | (top_bit - 1);
<a name="l00663"></a>00663 }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665 <span class="comment">/* Maximum value of integral type T, as a signed quantity.  */</span>
<a name="l00666"></a>00666 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l00667"></a>00667 max_of_type (<span class="keyword">struct</span> type *t)
<a name="l00668"></a>00668 {
<a name="l00669"></a>00669   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">TYPE_UNSIGNED</a> (t))
<a name="l00670"></a>00670     <span class="keywordflow">return</span> (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) umax_of_size (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (t));
<a name="l00671"></a>00671   <span class="keywordflow">else</span>
<a name="l00672"></a>00672     <span class="keywordflow">return</span> max_of_size (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (t));
<a name="l00673"></a>00673 }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 <span class="comment">/* Minimum value of integral type T, as a signed quantity.  */</span>
<a name="l00676"></a>00676 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l00677"></a>00677 min_of_type (<span class="keyword">struct</span> type *t)
<a name="l00678"></a>00678 {
<a name="l00679"></a>00679   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">TYPE_UNSIGNED</a> (t)) 
<a name="l00680"></a>00680     <span class="keywordflow">return</span> 0;
<a name="l00681"></a>00681   <span class="keywordflow">else</span>
<a name="l00682"></a>00682     <span class="keywordflow">return</span> min_of_size (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (t));
<a name="l00683"></a>00683 }
<a name="l00684"></a>00684 
<a name="l00685"></a>00685 <span class="comment">/* The largest value in the domain of TYPE, a discrete type, as an integer.  */</span>
<a name="l00686"></a>00686 <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l00687"></a><a class="code" href="ada-lang_8h.html#a4f12dcbb45a3744addca42f1e16f2607">00687</a> <a class="code" href="ada-lang_8c.html#a9c9b5c63f7cb76eb9fdf216fa2721509">ada_discrete_type_high_bound</a> (<span class="keyword">struct</span> type *type)
<a name="l00688"></a>00688 {
<a name="l00689"></a>00689   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l00690"></a>00690     {
<a name="l00691"></a>00691     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>:
<a name="l00692"></a>00692       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a77cdc334123abc6858b3ea8b3361cd5d">TYPE_HIGH_BOUND</a> (type);
<a name="l00693"></a>00693     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>:
<a name="l00694"></a>00694       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a2ab26ef1ee13615e128e3cb3cd058a5c">TYPE_FIELD_ENUMVAL</a> (type, <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) - 1);
<a name="l00695"></a>00695     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462afbf0aa0241df408e1017ae7ff8e6798c">TYPE_CODE_BOOL</a>:
<a name="l00696"></a>00696       <span class="keywordflow">return</span> 1;
<a name="l00697"></a>00697     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae991dd7ea70631f3e1b67a1a75020b5f">TYPE_CODE_CHAR</a>:
<a name="l00698"></a>00698     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>:
<a name="l00699"></a>00699       <span class="keywordflow">return</span> max_of_type (type);
<a name="l00700"></a>00700     <span class="keywordflow">default</span>:
<a name="l00701"></a>00701       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unexpected type in ada_discrete_type_high_bound.&quot;</span>));
<a name="l00702"></a>00702     }
<a name="l00703"></a>00703 }
<a name="l00704"></a>00704 
<a name="l00705"></a>00705 <span class="comment">/* The smallest value in the domain of TYPE, a discrete type, as an integer.  */</span>
<a name="l00706"></a>00706 <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l00707"></a><a class="code" href="ada-lang_8h.html#a03eec58bef034e19d0a19fd9c10ae33e">00707</a> <a class="code" href="ada-lang_8c.html#ad4891bc1ffa6690999afab17e367bc57">ada_discrete_type_low_bound</a> (<span class="keyword">struct</span> type *type)
<a name="l00708"></a>00708 {
<a name="l00709"></a>00709   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l00710"></a>00710     {
<a name="l00711"></a>00711     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>:
<a name="l00712"></a>00712       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a8a35064d1a955f191b0a63b03755689b">TYPE_LOW_BOUND</a> (type);
<a name="l00713"></a>00713     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>:
<a name="l00714"></a>00714       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a2ab26ef1ee13615e128e3cb3cd058a5c">TYPE_FIELD_ENUMVAL</a> (type, 0);
<a name="l00715"></a>00715     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462afbf0aa0241df408e1017ae7ff8e6798c">TYPE_CODE_BOOL</a>:
<a name="l00716"></a>00716       <span class="keywordflow">return</span> 0;
<a name="l00717"></a>00717     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae991dd7ea70631f3e1b67a1a75020b5f">TYPE_CODE_CHAR</a>:
<a name="l00718"></a>00718     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>:
<a name="l00719"></a>00719       <span class="keywordflow">return</span> min_of_type (type);
<a name="l00720"></a>00720     <span class="keywordflow">default</span>:
<a name="l00721"></a>00721       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unexpected type in ada_discrete_type_low_bound.&quot;</span>));
<a name="l00722"></a>00722     }
<a name="l00723"></a>00723 }
<a name="l00724"></a>00724 
<a name="l00725"></a>00725 <span class="comment">/* The identity on non-range types.  For range types, the underlying</span>
<a name="l00726"></a>00726 <span class="comment">   non-range scalar type.  */</span>
<a name="l00727"></a>00727 
<a name="l00728"></a>00728 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l00729"></a>00729 get_base_type (<span class="keyword">struct</span> type *type)
<a name="l00730"></a>00730 {
<a name="l00731"></a>00731   <span class="keywordflow">while</span> (type != NULL &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>)
<a name="l00732"></a>00732     {
<a name="l00733"></a>00733       <span class="keywordflow">if</span> (type == <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type) || <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type) == NULL)
<a name="l00734"></a>00734         <span class="keywordflow">return</span> type;
<a name="l00735"></a>00735       type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l00736"></a>00736     }
<a name="l00737"></a>00737   <span class="keywordflow">return</span> type;
<a name="l00738"></a>00738 }
<a name="l00739"></a>00739 
<a name="l00740"></a>00740 <span class="comment">/* Return a decoded version of the given VALUE.  This means returning</span>
<a name="l00741"></a>00741 <span class="comment">   a value whose type is obtained by applying all the GNAT-specific</span>
<a name="l00742"></a>00742 <span class="comment">   encondings, making the resulting type a static but standard description</span>
<a name="l00743"></a>00743 <span class="comment">   of the initial type.  */</span>
<a name="l00744"></a>00744 
<a name="l00745"></a>00745 <span class="keyword">struct </span>value *
<a name="l00746"></a><a class="code" href="ada-lang_8h.html#a418ac2f77a5357313be0b37efc61ebfb">00746</a> <a class="code" href="ada-lang_8c.html#a418ac2f77a5357313be0b37efc61ebfb">ada_get_decoded_value</a> (<span class="keyword">struct</span> value *value)
<a name="l00747"></a>00747 {
<a name="l00748"></a>00748   <span class="keyword">struct </span>type *type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (value));
<a name="l00749"></a>00749 
<a name="l00750"></a>00750   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (type)
<a name="l00751"></a>00751       || (<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (type)
<a name="l00752"></a>00752           &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>))
<a name="l00753"></a>00753     {
<a name="l00754"></a>00754       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>)  <span class="comment">/* array access type.  */</span>
<a name="l00755"></a>00755         value = <a class="code" href="ada-lang_8c.html#ae180af59d7a123a3aefc23883acb77d7">ada_coerce_to_simple_array_ptr</a> (value);
<a name="l00756"></a>00756       <span class="keywordflow">else</span>
<a name="l00757"></a>00757         value = <a class="code" href="ada-lang_8c.html#a184966871049f553a895f96f7590884a">ada_coerce_to_simple_array</a> (value);
<a name="l00758"></a>00758     }
<a name="l00759"></a>00759   <span class="keywordflow">else</span>
<a name="l00760"></a>00760     value = <a class="code" href="ada-lang_8c.html#aff7bccfb43d0188dfaf758dffe8b58ce">ada_to_fixed_value</a> (value);
<a name="l00761"></a>00761 
<a name="l00762"></a>00762   <span class="keywordflow">return</span> value;
<a name="l00763"></a>00763 }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765 <span class="comment">/* Same as ada_get_decoded_value, but with the given TYPE.</span>
<a name="l00766"></a>00766 <span class="comment">   Because there is no associated actual value for this type,</span>
<a name="l00767"></a>00767 <span class="comment">   the resulting type might be a best-effort approximation in</span>
<a name="l00768"></a>00768 <span class="comment">   the case of dynamic types.  */</span>
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 <span class="keyword">struct </span>type *
<a name="l00771"></a><a class="code" href="ada-lang_8h.html#ae79f64d3d7ea8e5dd3ac506cb9ba7a44">00771</a> <a class="code" href="ada-lang_8c.html#ae79f64d3d7ea8e5dd3ac506cb9ba7a44">ada_get_decoded_type</a> (<span class="keyword">struct</span> type *type)
<a name="l00772"></a>00772 {
<a name="l00773"></a>00773   type = to_static_fixed_type (type);
<a name="l00774"></a>00774   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (type))
<a name="l00775"></a>00775     type = <a class="code" href="ada-lang_8c.html#a08af5f804b36a05cc3a11fe364b5b57a">ada_coerce_to_simple_array_type</a> (type);
<a name="l00776"></a>00776   <span class="keywordflow">return</span> type;
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779 
<a name="l00780"></a>00780 
<a name="l00781"></a>00781                                 <span class="comment">/* Language Selection */</span>
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 <span class="comment">/* If the main program is in Ada, return language_ada, otherwise return LANG</span>
<a name="l00784"></a>00784 <span class="comment">   (the main program is in Ada iif the adainit symbol is found).  */</span>
<a name="l00785"></a>00785 
<a name="l00786"></a>00786 <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a>
<a name="l00787"></a><a class="code" href="ada-lang_8h.html#a1f35f1ea236a75446fc1ecdefa6e4f45">00787</a> <a class="code" href="ada-lang_8c.html#ae183d69cbd41460251cae6b66a9acbed">ada_update_initial_language</a> (<span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> lang)
<a name="l00788"></a>00788 {
<a name="l00789"></a>00789   <span class="keywordflow">if</span> (<a class="code" href="minsyms_8c.html#af87f7a894386515074ddd71365bc09b8">lookup_minimal_symbol</a> (<span class="stringliteral">&quot;adainit&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span> *) NULL,
<a name="l00790"></a>00790                              (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *) NULL) != NULL)
<a name="l00791"></a>00791     <span class="keywordflow">return</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>;
<a name="l00792"></a>00792 
<a name="l00793"></a>00793   <span class="keywordflow">return</span> lang;
<a name="l00794"></a>00794 }
<a name="l00795"></a>00795 
<a name="l00796"></a>00796 <span class="comment">/* If the main procedure is written in Ada, then return its name.</span>
<a name="l00797"></a>00797 <span class="comment">   The result is good until the next call.  Return NULL if the main</span>
<a name="l00798"></a>00798 <span class="comment">   procedure doesn&#39;t appear to be in Ada.  */</span>
<a name="l00799"></a>00799 
<a name="l00800"></a>00800 <span class="keywordtype">char</span> *
<a name="l00801"></a><a class="code" href="ada-lang_8h.html#a4ccd078345dbe305ac4a070a6319f96c">00801</a> <a class="code" href="ada-lang_8c.html#a4ccd078345dbe305ac4a070a6319f96c">ada_main_name</a> (<span class="keywordtype">void</span>)
<a name="l00802"></a>00802 {
<a name="l00803"></a>00803   <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *msym;
<a name="l00804"></a>00804   <span class="keyword">static</span> <span class="keywordtype">char</span> *main_program_name = NULL;
<a name="l00805"></a>00805 
<a name="l00806"></a>00806   <span class="comment">/* For Ada, the name of the main procedure is stored in a specific</span>
<a name="l00807"></a>00807 <span class="comment">     string constant, generated by the binder.  Look for that symbol,</span>
<a name="l00808"></a>00808 <span class="comment">     extract its address, and then read that string.  If we didn&#39;t find</span>
<a name="l00809"></a>00809 <span class="comment">     that string, then most probably the main procedure is not written</span>
<a name="l00810"></a>00810 <span class="comment">     in Ada.  */</span>
<a name="l00811"></a>00811   msym = <a class="code" href="minsyms_8c.html#af87f7a894386515074ddd71365bc09b8">lookup_minimal_symbol</a> (ADA_MAIN_PROGRAM_SYMBOL_NAME, NULL, NULL);
<a name="l00812"></a>00812 
<a name="l00813"></a>00813   <span class="keywordflow">if</span> (msym != NULL)
<a name="l00814"></a>00814     {
<a name="l00815"></a>00815       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> main_program_name_addr;
<a name="l00816"></a>00816       <span class="keywordtype">int</span> err_code;
<a name="l00817"></a>00817 
<a name="l00818"></a>00818       main_program_name_addr = <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (msym);
<a name="l00819"></a>00819       <span class="keywordflow">if</span> (main_program_name_addr == 0)
<a name="l00820"></a>00820         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Invalid address for Ada main program name.&quot;</span>));
<a name="l00821"></a>00821 
<a name="l00822"></a>00822       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (main_program_name);
<a name="l00823"></a>00823       <a class="code" href="target_8c.html#a394bfbed99bddd14b28ca9b6538292c2">target_read_string</a> (main_program_name_addr, &amp;main_program_name,
<a name="l00824"></a>00824                           1024, &amp;err_code);
<a name="l00825"></a>00825 
<a name="l00826"></a>00826       <span class="keywordflow">if</span> (err_code != 0)
<a name="l00827"></a>00827         <span class="keywordflow">return</span> NULL;
<a name="l00828"></a>00828       <span class="keywordflow">return</span> main_program_name;
<a name="l00829"></a>00829     }
<a name="l00830"></a>00830 
<a name="l00831"></a>00831   <span class="comment">/* The main procedure doesn&#39;t seem to be in Ada.  */</span>
<a name="l00832"></a>00832   <span class="keywordflow">return</span> NULL;
<a name="l00833"></a>00833 }
<a name="l00834"></a>00834 
<a name="l00835"></a>00835                                 <span class="comment">/* Symbols */</span>
<a name="l00836"></a>00836 
<a name="l00837"></a>00837 <span class="comment">/* Table of Ada operators and their GNAT-encoded names.  Last entry is pair</span>
<a name="l00838"></a>00838 <span class="comment">   of NULLs.  */</span>
<a name="l00839"></a>00839 
<a name="l00840"></a><a class="code" href="ada-lang_8h.html#a781ba01ff5799c7f5f84df58f20e0129">00840</a> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structada__opname__map.html">ada_opname_map</a> <a class="code" href="ada-lang_8c.html#a781ba01ff5799c7f5f84df58f20e0129">ada_opname_table</a>[] = {
<a name="l00841"></a>00841   {<span class="stringliteral">&quot;Oadd&quot;</span>, <span class="stringliteral">&quot;\&quot;+\&quot;&quot;</span>, BINOP_ADD},
<a name="l00842"></a>00842   {<span class="stringliteral">&quot;Osubtract&quot;</span>, <span class="stringliteral">&quot;\&quot;-\&quot;&quot;</span>, BINOP_SUB},
<a name="l00843"></a>00843   {<span class="stringliteral">&quot;Omultiply&quot;</span>, <span class="stringliteral">&quot;\&quot;*\&quot;&quot;</span>, BINOP_MUL},
<a name="l00844"></a>00844   {<span class="stringliteral">&quot;Odivide&quot;</span>, <span class="stringliteral">&quot;\&quot;/\&quot;&quot;</span>, BINOP_DIV},
<a name="l00845"></a>00845   {<span class="stringliteral">&quot;Omod&quot;</span>, <span class="stringliteral">&quot;\&quot;mod\&quot;&quot;</span>, BINOP_MOD},
<a name="l00846"></a>00846   {<span class="stringliteral">&quot;Orem&quot;</span>, <span class="stringliteral">&quot;\&quot;rem\&quot;&quot;</span>, BINOP_REM},
<a name="l00847"></a>00847   {<span class="stringliteral">&quot;Oexpon&quot;</span>, <span class="stringliteral">&quot;\&quot;**\&quot;&quot;</span>, BINOP_EXP},
<a name="l00848"></a>00848   {<span class="stringliteral">&quot;Olt&quot;</span>, <span class="stringliteral">&quot;\&quot;&lt;\&quot;&quot;</span>, BINOP_LESS},
<a name="l00849"></a>00849   {<span class="stringliteral">&quot;Ole&quot;</span>, <span class="stringliteral">&quot;\&quot;&lt;=\&quot;&quot;</span>, BINOP_LEQ},
<a name="l00850"></a>00850   {<span class="stringliteral">&quot;Ogt&quot;</span>, <span class="stringliteral">&quot;\&quot;&gt;\&quot;&quot;</span>, BINOP_GTR},
<a name="l00851"></a>00851   {<span class="stringliteral">&quot;Oge&quot;</span>, <span class="stringliteral">&quot;\&quot;&gt;=\&quot;&quot;</span>, BINOP_GEQ},
<a name="l00852"></a>00852   {<span class="stringliteral">&quot;Oeq&quot;</span>, <span class="stringliteral">&quot;\&quot;=\&quot;&quot;</span>, BINOP_EQUAL},
<a name="l00853"></a>00853   {<span class="stringliteral">&quot;One&quot;</span>, <span class="stringliteral">&quot;\&quot;/=\&quot;&quot;</span>, BINOP_NOTEQUAL},
<a name="l00854"></a>00854   {<span class="stringliteral">&quot;Oand&quot;</span>, <span class="stringliteral">&quot;\&quot;and\&quot;&quot;</span>, BINOP_BITWISE_AND},
<a name="l00855"></a>00855   {<span class="stringliteral">&quot;Oor&quot;</span>, <span class="stringliteral">&quot;\&quot;or\&quot;&quot;</span>, BINOP_BITWISE_IOR},
<a name="l00856"></a>00856   {<span class="stringliteral">&quot;Oxor&quot;</span>, <span class="stringliteral">&quot;\&quot;xor\&quot;&quot;</span>, BINOP_BITWISE_XOR},
<a name="l00857"></a>00857   {<span class="stringliteral">&quot;Oconcat&quot;</span>, <span class="stringliteral">&quot;\&quot;&amp;\&quot;&quot;</span>, BINOP_CONCAT},
<a name="l00858"></a>00858   {<span class="stringliteral">&quot;Oabs&quot;</span>, <span class="stringliteral">&quot;\&quot;abs\&quot;&quot;</span>, UNOP_ABS},
<a name="l00859"></a>00859   {<span class="stringliteral">&quot;Onot&quot;</span>, <span class="stringliteral">&quot;\&quot;not\&quot;&quot;</span>, UNOP_LOGICAL_NOT},
<a name="l00860"></a>00860   {<span class="stringliteral">&quot;Oadd&quot;</span>, <span class="stringliteral">&quot;\&quot;+\&quot;&quot;</span>, UNOP_PLUS},
<a name="l00861"></a>00861   {<span class="stringliteral">&quot;Osubtract&quot;</span>, <span class="stringliteral">&quot;\&quot;-\&quot;&quot;</span>, UNOP_NEG},
<a name="l00862"></a>00862   {NULL, NULL}
<a name="l00863"></a>00863 };
<a name="l00864"></a>00864 
<a name="l00865"></a>00865 <span class="comment">/* The &quot;encoded&quot; form of DECODED, according to GNAT conventions.</span>
<a name="l00866"></a>00866 <span class="comment">   The result is valid until the next call to ada_encode.  */</span>
<a name="l00867"></a>00867 
<a name="l00868"></a>00868 <span class="keywordtype">char</span> *
<a name="l00869"></a><a class="code" href="ada-lang_8h.html#a22d64ffdc71a2d8ef4d13aaf0ecbb497">00869</a> <a class="code" href="ada-lang_8c.html#ae2acc3345983845169c3d4239e922b75">ada_encode</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structada__opname__map.html#a84c52a9db147c775a3ccb707fe99130b">decoded</a>)
<a name="l00870"></a>00870 {
<a name="l00871"></a>00871   <span class="keyword">static</span> <span class="keywordtype">char</span> *encoding_buffer = NULL;
<a name="l00872"></a>00872   <span class="keyword">static</span> <span class="keywordtype">size_t</span> encoding_buffer_size = 0;
<a name="l00873"></a>00873   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>;
<a name="l00874"></a>00874   <span class="keywordtype">int</span> k;
<a name="l00875"></a>00875 
<a name="l00876"></a>00876   <span class="keywordflow">if</span> (decoded == NULL)
<a name="l00877"></a>00877     <span class="keywordflow">return</span> NULL;
<a name="l00878"></a>00878 
<a name="l00879"></a>00879   <a class="code" href="ada-lang_8h.html#a48e9e90d45825a693f1690a4ebcb2a1e">GROW_VECT</a> (encoding_buffer, encoding_buffer_size,
<a name="l00880"></a>00880              2 * strlen (decoded) + 10);
<a name="l00881"></a>00881 
<a name="l00882"></a>00882   k = 0;
<a name="l00883"></a>00883   <span class="keywordflow">for</span> (p = decoded; *p != <span class="charliteral">&#39;\0&#39;</span>; p += 1)
<a name="l00884"></a>00884     {
<a name="l00885"></a>00885       <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39;.&#39;</span>)
<a name="l00886"></a>00886         {
<a name="l00887"></a>00887           encoding_buffer[k] = encoding_buffer[k + 1] = <span class="charliteral">&#39;_&#39;</span>;
<a name="l00888"></a>00888           k += 2;
<a name="l00889"></a>00889         }
<a name="l00890"></a>00890       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39;&quot;&#39;</span>)
<a name="l00891"></a>00891         {
<a name="l00892"></a>00892           <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structada__opname__map.html">ada_opname_map</a> *mapping;
<a name="l00893"></a>00893 
<a name="l00894"></a>00894           <span class="keywordflow">for</span> (mapping = ada_opname_table;
<a name="l00895"></a>00895                mapping-&gt;<a class="code" href="structada__opname__map.html#af4e7f0cadf2f970fb92488ae523cb706">encoded</a> != NULL
<a name="l00896"></a>00896                &amp;&amp; strncmp (mapping-&gt;<a class="code" href="structada__opname__map.html#a84c52a9db147c775a3ccb707fe99130b">decoded</a>, p,
<a name="l00897"></a>00897                            strlen (mapping-&gt;<a class="code" href="structada__opname__map.html#a84c52a9db147c775a3ccb707fe99130b">decoded</a>)) != 0; mapping += 1)
<a name="l00898"></a>00898             ;
<a name="l00899"></a>00899           <span class="keywordflow">if</span> (mapping-&gt;<a class="code" href="structada__opname__map.html#af4e7f0cadf2f970fb92488ae523cb706">encoded</a> == NULL)
<a name="l00900"></a>00900             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;invalid Ada operator name: %s&quot;</span>), p);
<a name="l00901"></a>00901           strcpy (encoding_buffer + k, mapping-&gt;<a class="code" href="structada__opname__map.html#af4e7f0cadf2f970fb92488ae523cb706">encoded</a>);
<a name="l00902"></a>00902           k += strlen (mapping-&gt;<a class="code" href="structada__opname__map.html#af4e7f0cadf2f970fb92488ae523cb706">encoded</a>);
<a name="l00903"></a>00903           <span class="keywordflow">break</span>;
<a name="l00904"></a>00904         }
<a name="l00905"></a>00905       <span class="keywordflow">else</span>
<a name="l00906"></a>00906         {
<a name="l00907"></a>00907           encoding_buffer[k] = *p;
<a name="l00908"></a>00908           k += 1;
<a name="l00909"></a>00909         }
<a name="l00910"></a>00910     }
<a name="l00911"></a>00911 
<a name="l00912"></a>00912   encoding_buffer[k] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00913"></a>00913   <span class="keywordflow">return</span> encoding_buffer;
<a name="l00914"></a>00914 }
<a name="l00915"></a>00915 
<a name="l00916"></a>00916 <span class="comment">/* Return NAME folded to lower case, or, if surrounded by single</span>
<a name="l00917"></a>00917 <span class="comment">   quotes, unfolded, but with the quotes stripped away.  Result good</span>
<a name="l00918"></a>00918 <span class="comment">   to next call.  */</span>
<a name="l00919"></a>00919 
<a name="l00920"></a>00920 <span class="keywordtype">char</span> *
<a name="l00921"></a><a class="code" href="ada-lang_8h.html#a6f28c86444a5c713a5b065f8ece15a11">00921</a> <a class="code" href="ada-lang_8c.html#a93c72077b027134d644b38b8fcf19036">ada_fold_name</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>)
<a name="l00922"></a>00922 {
<a name="l00923"></a>00923   <span class="keyword">static</span> <span class="keywordtype">char</span> *fold_buffer = NULL;
<a name="l00924"></a>00924   <span class="keyword">static</span> <span class="keywordtype">size_t</span> fold_buffer_size = 0;
<a name="l00925"></a>00925 
<a name="l00926"></a>00926   <span class="keywordtype">int</span> len = strlen (name);
<a name="l00927"></a>00927   <a class="code" href="ada-lang_8h.html#a48e9e90d45825a693f1690a4ebcb2a1e">GROW_VECT</a> (fold_buffer, fold_buffer_size, len + 1);
<a name="l00928"></a>00928 
<a name="l00929"></a>00929   <span class="keywordflow">if</span> (name[0] == <span class="charliteral">&#39;\&#39;&#39;</span>)
<a name="l00930"></a>00930     {
<a name="l00931"></a>00931       strncpy (fold_buffer, name + 1, len - 2);
<a name="l00932"></a>00932       fold_buffer[len - 2] = <span class="charliteral">&#39;\000&#39;</span>;
<a name="l00933"></a>00933     }
<a name="l00934"></a>00934   <span class="keywordflow">else</span>
<a name="l00935"></a>00935     {
<a name="l00936"></a>00936       <span class="keywordtype">int</span> i;
<a name="l00937"></a>00937 
<a name="l00938"></a>00938       <span class="keywordflow">for</span> (i = 0; i &lt;= <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>; i += 1)
<a name="l00939"></a>00939         fold_buffer[i] = tolower (name[i]);
<a name="l00940"></a>00940     }
<a name="l00941"></a>00941 
<a name="l00942"></a>00942   <span class="keywordflow">return</span> fold_buffer;
<a name="l00943"></a>00943 }
<a name="l00944"></a>00944 
<a name="l00945"></a>00945 <span class="comment">/* Return nonzero if C is either a digit or a lowercase alphabet character.  */</span>
<a name="l00946"></a>00946 
<a name="l00947"></a>00947 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00948"></a>00948 is_lower_alphanum (<span class="keyword">const</span> <span class="keywordtype">char</span> c)
<a name="l00949"></a>00949 {
<a name="l00950"></a>00950   <span class="keywordflow">return</span> (isdigit (c) || (isalpha (c) &amp;&amp; islower (c)));
<a name="l00951"></a>00951 }
<a name="l00952"></a>00952 
<a name="l00953"></a>00953 <span class="comment">/* ENCODED is the linkage name of a symbol and LEN contains its length.</span>
<a name="l00954"></a>00954 <span class="comment">   This function saves in LEN the length of that same symbol name but</span>
<a name="l00955"></a>00955 <span class="comment">   without either of these suffixes:</span>
<a name="l00956"></a>00956 <span class="comment">     . .{DIGIT}+</span>
<a name="l00957"></a>00957 <span class="comment">     . ${DIGIT}+</span>
<a name="l00958"></a>00958 <span class="comment">     . ___{DIGIT}+</span>
<a name="l00959"></a>00959 <span class="comment">     . __{DIGIT}+.</span>
<a name="l00960"></a>00960 <span class="comment"></span>
<a name="l00961"></a>00961 <span class="comment">   These are suffixes introduced by the compiler for entities such as</span>
<a name="l00962"></a>00962 <span class="comment">   nested subprogram for instance, in order to avoid name clashes.</span>
<a name="l00963"></a>00963 <span class="comment">   They do not serve any purpose for the debugger.  */</span>
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00966"></a>00966 ada_remove_trailing_digits (<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structada__opname__map.html#af4e7f0cadf2f970fb92488ae523cb706">encoded</a>, <span class="keywordtype">int</span> *len)
<a name="l00967"></a>00967 {
<a name="l00968"></a>00968   <span class="keywordflow">if</span> (*len &gt; 1 &amp;&amp; isdigit (encoded[*len - 1]))
<a name="l00969"></a>00969     {
<a name="l00970"></a>00970       <span class="keywordtype">int</span> i = *len - 2;
<a name="l00971"></a>00971 
<a name="l00972"></a>00972       <span class="keywordflow">while</span> (i &gt; 0 &amp;&amp; isdigit (encoded[i]))
<a name="l00973"></a>00973         i--;
<a name="l00974"></a>00974       <span class="keywordflow">if</span> (i &gt;= 0 &amp;&amp; encoded[i] == <span class="charliteral">&#39;.&#39;</span>)
<a name="l00975"></a>00975         *len = i;
<a name="l00976"></a>00976       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i &gt;= 0 &amp;&amp; encoded[i] == <span class="charliteral">&#39;$&#39;</span>)
<a name="l00977"></a>00977         *len = i;
<a name="l00978"></a>00978       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i &gt;= 2 &amp;&amp; strncmp (encoded + i - 2, <span class="stringliteral">&quot;___&quot;</span>, 3) == 0)
<a name="l00979"></a>00979         *len = i - 2;
<a name="l00980"></a>00980       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i &gt;= 1 &amp;&amp; strncmp (encoded + i - 1, <span class="stringliteral">&quot;__&quot;</span>, 2) == 0)
<a name="l00981"></a>00981         *len = i - 1;
<a name="l00982"></a>00982     }
<a name="l00983"></a>00983 }
<a name="l00984"></a>00984 
<a name="l00985"></a>00985 <span class="comment">/* Remove the suffix introduced by the compiler for protected object</span>
<a name="l00986"></a>00986 <span class="comment">   subprograms.  */</span>
<a name="l00987"></a>00987 
<a name="l00988"></a>00988 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00989"></a>00989 ada_remove_po_subprogram_suffix (<span class="keyword">const</span> <span class="keywordtype">char</span> *encoded, <span class="keywordtype">int</span> *len)
<a name="l00990"></a>00990 {
<a name="l00991"></a>00991   <span class="comment">/* Remove trailing N.  */</span>
<a name="l00992"></a>00992 
<a name="l00993"></a>00993   <span class="comment">/* Protected entry subprograms are broken into two</span>
<a name="l00994"></a>00994 <span class="comment">     separate subprograms: The first one is unprotected, and has</span>
<a name="l00995"></a>00995 <span class="comment">     a &#39;N&#39; suffix; the second is the protected version, and has</span>
<a name="l00996"></a>00996 <span class="comment">     the &#39;P&#39; suffix.  The second calls the first one after handling</span>
<a name="l00997"></a>00997 <span class="comment">     the protection.  Since the P subprograms are internally generated,</span>
<a name="l00998"></a>00998 <span class="comment">     we leave these names undecoded, giving the user a clue that this</span>
<a name="l00999"></a>00999 <span class="comment">     entity is internal.  */</span>
<a name="l01000"></a>01000 
<a name="l01001"></a>01001   <span class="keywordflow">if</span> (*len &gt; 1
<a name="l01002"></a>01002       &amp;&amp; encoded[*len - 1] == <span class="charliteral">&#39;N&#39;</span>
<a name="l01003"></a>01003       &amp;&amp; (isdigit (encoded[*len - 2]) || islower (encoded[*len - 2])))
<a name="l01004"></a>01004     *len = *len - 1;
<a name="l01005"></a>01005 }
<a name="l01006"></a>01006 
<a name="l01007"></a>01007 <span class="comment">/* Remove trailing X[bn]* suffixes (indicating names in package bodies).  */</span>
<a name="l01008"></a>01008 
<a name="l01009"></a>01009 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01010"></a>01010 ada_remove_Xbn_suffix (<span class="keyword">const</span> <span class="keywordtype">char</span> *encoded, <span class="keywordtype">int</span> *len)
<a name="l01011"></a>01011 {
<a name="l01012"></a>01012   <span class="keywordtype">int</span> i = *len - 1;
<a name="l01013"></a>01013 
<a name="l01014"></a>01014   <span class="keywordflow">while</span> (i &gt; 0 &amp;&amp; (encoded[i] == <span class="charliteral">&#39;b&#39;</span> || encoded[i] == <span class="charliteral">&#39;n&#39;</span>))
<a name="l01015"></a>01015     i--;
<a name="l01016"></a>01016 
<a name="l01017"></a>01017   <span class="keywordflow">if</span> (encoded[i] != <span class="charliteral">&#39;X&#39;</span>)
<a name="l01018"></a>01018     <span class="keywordflow">return</span>;
<a name="l01019"></a>01019 
<a name="l01020"></a>01020   <span class="keywordflow">if</span> (i == 0)
<a name="l01021"></a>01021     <span class="keywordflow">return</span>;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023   <span class="keywordflow">if</span> (isalnum (encoded[i-1]))
<a name="l01024"></a>01024     *len = i;
<a name="l01025"></a>01025 }
<a name="l01026"></a>01026 
<a name="l01027"></a>01027 <span class="comment">/* If ENCODED follows the GNAT entity encoding conventions, then return</span>
<a name="l01028"></a>01028 <span class="comment">   the decoded form of ENCODED.  Otherwise, return &quot;&lt;%s&gt;&quot; where &quot;%s&quot; is</span>
<a name="l01029"></a>01029 <span class="comment">   replaced by ENCODED.</span>
<a name="l01030"></a>01030 <span class="comment"></span>
<a name="l01031"></a>01031 <span class="comment">   The resulting string is valid until the next call of ada_decode.</span>
<a name="l01032"></a>01032 <span class="comment">   If the string is unchanged by decoding, the original string pointer</span>
<a name="l01033"></a>01033 <span class="comment">   is returned.  */</span>
<a name="l01034"></a>01034 
<a name="l01035"></a>01035 <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l01036"></a><a class="code" href="ada-lang_8h.html#a35fb770380aa7f2cdd0a559375190991">01036</a> <a class="code" href="ada-lang_8c.html#a09b16b65c7ccf6ce05e91a51321903a1">ada_decode</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *encoded)
<a name="l01037"></a>01037 {
<a name="l01038"></a>01038   <span class="keywordtype">int</span> i, j;
<a name="l01039"></a>01039   <span class="keywordtype">int</span> len0;
<a name="l01040"></a>01040   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>;
<a name="l01041"></a>01041   <span class="keywordtype">char</span> *<a class="code" href="structada__opname__map.html#a84c52a9db147c775a3ccb707fe99130b">decoded</a>;
<a name="l01042"></a>01042   <span class="keywordtype">int</span> at_start_name;
<a name="l01043"></a>01043   <span class="keyword">static</span> <span class="keywordtype">char</span> *decoding_buffer = NULL;
<a name="l01044"></a>01044   <span class="keyword">static</span> <span class="keywordtype">size_t</span> decoding_buffer_size = 0;
<a name="l01045"></a>01045 
<a name="l01046"></a>01046   <span class="comment">/* The name of the Ada main procedure starts with &quot;_ada_&quot;.</span>
<a name="l01047"></a>01047 <span class="comment">     This prefix is not part of the decoded name, so skip this part</span>
<a name="l01048"></a>01048 <span class="comment">     if we see this prefix.  */</span>
<a name="l01049"></a>01049   <span class="keywordflow">if</span> (strncmp (encoded, <span class="stringliteral">&quot;_ada_&quot;</span>, 5) == 0)
<a name="l01050"></a>01050     encoded += 5;
<a name="l01051"></a>01051 
<a name="l01052"></a>01052   <span class="comment">/* If the name starts with &#39;_&#39;, then it is not a properly encoded</span>
<a name="l01053"></a>01053 <span class="comment">     name, so do not attempt to decode it.  Similarly, if the name</span>
<a name="l01054"></a>01054 <span class="comment">     starts with &#39;&lt;&#39;, the name should not be decoded.  */</span>
<a name="l01055"></a>01055   <span class="keywordflow">if</span> (encoded[0] == <span class="charliteral">&#39;_&#39;</span> || encoded[0] == <span class="charliteral">&#39;&lt;&#39;</span>)
<a name="l01056"></a>01056     <span class="keywordflow">goto</span> Suppress;
<a name="l01057"></a>01057 
<a name="l01058"></a>01058   len0 = strlen (encoded);
<a name="l01059"></a>01059 
<a name="l01060"></a>01060   ada_remove_trailing_digits (encoded, &amp;len0);
<a name="l01061"></a>01061   ada_remove_po_subprogram_suffix (encoded, &amp;len0);
<a name="l01062"></a>01062 
<a name="l01063"></a>01063   <span class="comment">/* Remove the ___X.* suffix if present.  Do not forget to verify that</span>
<a name="l01064"></a>01064 <span class="comment">     the suffix is located before the current &quot;end&quot; of ENCODED.  We want</span>
<a name="l01065"></a>01065 <span class="comment">     to avoid re-matching parts of ENCODED that have previously been</span>
<a name="l01066"></a>01066 <span class="comment">     marked as discarded (by decrementing LEN0).  */</span>
<a name="l01067"></a>01067   p = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (encoded, <span class="stringliteral">&quot;___&quot;</span>);
<a name="l01068"></a>01068   <span class="keywordflow">if</span> (p != NULL &amp;&amp; p - encoded &lt; len0 - 3)
<a name="l01069"></a>01069     {
<a name="l01070"></a>01070       <span class="keywordflow">if</span> (p[3] == <span class="charliteral">&#39;X&#39;</span>)
<a name="l01071"></a>01071         len0 = p - <a class="code" href="structada__opname__map.html#af4e7f0cadf2f970fb92488ae523cb706">encoded</a>;
<a name="l01072"></a>01072       <span class="keywordflow">else</span>
<a name="l01073"></a>01073         <span class="keywordflow">goto</span> Suppress;
<a name="l01074"></a>01074     }
<a name="l01075"></a>01075 
<a name="l01076"></a>01076   <span class="comment">/* Remove any trailing TKB suffix.  It tells us that this symbol</span>
<a name="l01077"></a>01077 <span class="comment">     is for the body of a task, but that information does not actually</span>
<a name="l01078"></a>01078 <span class="comment">     appear in the decoded name.  */</span>
<a name="l01079"></a>01079 
<a name="l01080"></a>01080   <span class="keywordflow">if</span> (len0 &gt; 3 &amp;&amp; strncmp (encoded + len0 - 3, <span class="stringliteral">&quot;TKB&quot;</span>, 3) == 0)
<a name="l01081"></a>01081     len0 -= 3;
<a name="l01082"></a>01082 
<a name="l01083"></a>01083   <span class="comment">/* Remove any trailing TB suffix.  The TB suffix is slightly different</span>
<a name="l01084"></a>01084 <span class="comment">     from the TKB suffix because it is used for non-anonymous task</span>
<a name="l01085"></a>01085 <span class="comment">     bodies.  */</span>
<a name="l01086"></a>01086 
<a name="l01087"></a>01087   <span class="keywordflow">if</span> (len0 &gt; 2 &amp;&amp; strncmp (encoded + len0 - 2, <span class="stringliteral">&quot;TB&quot;</span>, 2) == 0)
<a name="l01088"></a>01088     len0 -= 2;
<a name="l01089"></a>01089 
<a name="l01090"></a>01090   <span class="comment">/* Remove trailing &quot;B&quot; suffixes.  */</span>
<a name="l01091"></a>01091   <span class="comment">/* FIXME: brobecker/2006-04-19: Not sure what this are used for...  */</span>
<a name="l01092"></a>01092 
<a name="l01093"></a>01093   <span class="keywordflow">if</span> (len0 &gt; 1 &amp;&amp; strncmp (encoded + len0 - 1, <span class="stringliteral">&quot;B&quot;</span>, 1) == 0)
<a name="l01094"></a>01094     len0 -= 1;
<a name="l01095"></a>01095 
<a name="l01096"></a>01096   <span class="comment">/* Make decoded big enough for possible expansion by operator name.  */</span>
<a name="l01097"></a>01097 
<a name="l01098"></a>01098   <a class="code" href="ada-lang_8h.html#a48e9e90d45825a693f1690a4ebcb2a1e">GROW_VECT</a> (decoding_buffer, decoding_buffer_size, 2 * len0 + 1);
<a name="l01099"></a>01099   decoded = decoding_buffer;
<a name="l01100"></a>01100 
<a name="l01101"></a>01101   <span class="comment">/* Remove trailing __{digit}+ or trailing ${digit}+.  */</span>
<a name="l01102"></a>01102 
<a name="l01103"></a>01103   <span class="keywordflow">if</span> (len0 &gt; 1 &amp;&amp; isdigit (encoded[len0 - 1]))
<a name="l01104"></a>01104     {
<a name="l01105"></a>01105       i = len0 - 2;
<a name="l01106"></a>01106       <span class="keywordflow">while</span> ((i &gt;= 0 &amp;&amp; isdigit (encoded[i]))
<a name="l01107"></a>01107              || (i &gt;= 1 &amp;&amp; encoded[i] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; isdigit (encoded[i - 1])))
<a name="l01108"></a>01108         i -= 1;
<a name="l01109"></a>01109       <span class="keywordflow">if</span> (i &gt; 1 &amp;&amp; encoded[i] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; encoded[i - 1] == <span class="charliteral">&#39;_&#39;</span>)
<a name="l01110"></a>01110         len0 = i - 1;
<a name="l01111"></a>01111       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (encoded[i] == <span class="charliteral">&#39;$&#39;</span>)
<a name="l01112"></a>01112         len0 = i;
<a name="l01113"></a>01113     }
<a name="l01114"></a>01114 
<a name="l01115"></a>01115   <span class="comment">/* The first few characters that are not alphabetic are not part</span>
<a name="l01116"></a>01116 <span class="comment">     of any encoding we use, so we can copy them over verbatim.  */</span>
<a name="l01117"></a>01117 
<a name="l01118"></a>01118   <span class="keywordflow">for</span> (i = 0, j = 0; i &lt; len0 &amp;&amp; !isalpha (encoded[i]); i += 1, j += 1)
<a name="l01119"></a>01119     decoded[j] = encoded[i];
<a name="l01120"></a>01120 
<a name="l01121"></a>01121   at_start_name = 1;
<a name="l01122"></a>01122   <span class="keywordflow">while</span> (i &lt; len0)
<a name="l01123"></a>01123     {
<a name="l01124"></a>01124       <span class="comment">/* Is this a symbol function?  */</span>
<a name="l01125"></a>01125       <span class="keywordflow">if</span> (at_start_name &amp;&amp; encoded[i] == <span class="charliteral">&#39;O&#39;</span>)
<a name="l01126"></a>01126         {
<a name="l01127"></a>01127           <span class="keywordtype">int</span> k;
<a name="l01128"></a>01128 
<a name="l01129"></a>01129           <span class="keywordflow">for</span> (k = 0; ada_opname_table[k].<a class="code" href="structada__opname__map.html#af4e7f0cadf2f970fb92488ae523cb706">encoded</a> != NULL; k += 1)
<a name="l01130"></a>01130             {
<a name="l01131"></a>01131               <span class="keywordtype">int</span> op_len = strlen (ada_opname_table[k].encoded);
<a name="l01132"></a>01132               <span class="keywordflow">if</span> ((strncmp (ada_opname_table[k].encoded + 1, encoded + i + 1,
<a name="l01133"></a>01133                             op_len - 1) == 0)
<a name="l01134"></a>01134                   &amp;&amp; !isalnum (encoded[i + op_len]))
<a name="l01135"></a>01135                 {
<a name="l01136"></a>01136                   strcpy (decoded + j, ada_opname_table[k].decoded);
<a name="l01137"></a>01137                   at_start_name = 0;
<a name="l01138"></a>01138                   i += op_len;
<a name="l01139"></a>01139                   j += strlen (ada_opname_table[k].decoded);
<a name="l01140"></a>01140                   <span class="keywordflow">break</span>;
<a name="l01141"></a>01141                 }
<a name="l01142"></a>01142             }
<a name="l01143"></a>01143           <span class="keywordflow">if</span> (ada_opname_table[k].encoded != NULL)
<a name="l01144"></a>01144             <span class="keywordflow">continue</span>;
<a name="l01145"></a>01145         }
<a name="l01146"></a>01146       at_start_name = 0;
<a name="l01147"></a>01147 
<a name="l01148"></a>01148       <span class="comment">/* Replace &quot;TK__&quot; with &quot;__&quot;, which will eventually be translated</span>
<a name="l01149"></a>01149 <span class="comment">         into &quot;.&quot; (just below).  */</span>
<a name="l01150"></a>01150 
<a name="l01151"></a>01151       <span class="keywordflow">if</span> (i &lt; len0 - 4 &amp;&amp; strncmp (encoded + i, <span class="stringliteral">&quot;TK__&quot;</span>, 4) == 0)
<a name="l01152"></a>01152         i += 2;
<a name="l01153"></a>01153 
<a name="l01154"></a>01154       <span class="comment">/* Replace &quot;__B_{DIGITS}+__&quot; sequences by &quot;__&quot;, which will eventually</span>
<a name="l01155"></a>01155 <span class="comment">         be translated into &quot;.&quot; (just below).  These are internal names</span>
<a name="l01156"></a>01156 <span class="comment">         generated for anonymous blocks inside which our symbol is nested.  */</span>
<a name="l01157"></a>01157 
<a name="l01158"></a>01158       <span class="keywordflow">if</span> (len0 - i &gt; 5 &amp;&amp; encoded [i] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; encoded [i+1] == <span class="charliteral">&#39;_&#39;</span>
<a name="l01159"></a>01159           &amp;&amp; encoded [i+2] == <span class="charliteral">&#39;B&#39;</span> &amp;&amp; encoded [i+3] == <span class="charliteral">&#39;_&#39;</span>
<a name="l01160"></a>01160           &amp;&amp; isdigit (encoded [i+4]))
<a name="l01161"></a>01161         {
<a name="l01162"></a>01162           <span class="keywordtype">int</span> k = i + 5;
<a name="l01163"></a>01163           
<a name="l01164"></a>01164           <span class="keywordflow">while</span> (k &lt; len0 &amp;&amp; isdigit (encoded[k]))
<a name="l01165"></a>01165             k++;  <span class="comment">/* Skip any extra digit.  */</span>
<a name="l01166"></a>01166 
<a name="l01167"></a>01167           <span class="comment">/* Double-check that the &quot;__B_{DIGITS}+&quot; sequence we found</span>
<a name="l01168"></a>01168 <span class="comment">             is indeed followed by &quot;__&quot;.  */</span>
<a name="l01169"></a>01169           <span class="keywordflow">if</span> (len0 - k &gt; 2 &amp;&amp; encoded [k] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; encoded [k+1] == <span class="charliteral">&#39;_&#39;</span>)
<a name="l01170"></a>01170             i = k;
<a name="l01171"></a>01171         }
<a name="l01172"></a>01172 
<a name="l01173"></a>01173       <span class="comment">/* Remove _E{DIGITS}+[sb] */</span>
<a name="l01174"></a>01174 
<a name="l01175"></a>01175       <span class="comment">/* Just as for protected object subprograms, there are 2 categories</span>
<a name="l01176"></a>01176 <span class="comment">         of subprograms created by the compiler for each entry.  The first</span>
<a name="l01177"></a>01177 <span class="comment">         one implements the actual entry code, and has a suffix following</span>
<a name="l01178"></a>01178 <span class="comment">         the convention above; the second one implements the barrier and</span>
<a name="l01179"></a>01179 <span class="comment">         uses the same convention as above, except that the &#39;E&#39; is replaced</span>
<a name="l01180"></a>01180 <span class="comment">         by a &#39;B&#39;.</span>
<a name="l01181"></a>01181 <span class="comment"></span>
<a name="l01182"></a>01182 <span class="comment">         Just as above, we do not decode the name of barrier functions</span>
<a name="l01183"></a>01183 <span class="comment">         to give the user a clue that the code he is debugging has been</span>
<a name="l01184"></a>01184 <span class="comment">         internally generated.  */</span>
<a name="l01185"></a>01185 
<a name="l01186"></a>01186       <span class="keywordflow">if</span> (len0 - i &gt; 3 &amp;&amp; encoded [i] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; encoded[i+1] == <span class="charliteral">&#39;E&#39;</span>
<a name="l01187"></a>01187           &amp;&amp; isdigit (encoded[i+2]))
<a name="l01188"></a>01188         {
<a name="l01189"></a>01189           <span class="keywordtype">int</span> k = i + 3;
<a name="l01190"></a>01190 
<a name="l01191"></a>01191           <span class="keywordflow">while</span> (k &lt; len0 &amp;&amp; isdigit (encoded[k]))
<a name="l01192"></a>01192             k++;
<a name="l01193"></a>01193 
<a name="l01194"></a>01194           <span class="keywordflow">if</span> (k &lt; len0
<a name="l01195"></a>01195               &amp;&amp; (encoded[k] == <span class="charliteral">&#39;b&#39;</span> || encoded[k] == <span class="charliteral">&#39;s&#39;</span>))
<a name="l01196"></a>01196             {
<a name="l01197"></a>01197               k++;
<a name="l01198"></a>01198               <span class="comment">/* Just as an extra precaution, make sure that if this</span>
<a name="l01199"></a>01199 <span class="comment">                 suffix is followed by anything else, it is a &#39;_&#39;.</span>
<a name="l01200"></a>01200 <span class="comment">                 Otherwise, we matched this sequence by accident.  */</span>
<a name="l01201"></a>01201               <span class="keywordflow">if</span> (k == len0
<a name="l01202"></a>01202                   || (k &lt; len0 &amp;&amp; encoded[k] == <span class="charliteral">&#39;_&#39;</span>))
<a name="l01203"></a>01203                 i = k;
<a name="l01204"></a>01204             }
<a name="l01205"></a>01205         }
<a name="l01206"></a>01206 
<a name="l01207"></a>01207       <span class="comment">/* Remove trailing &quot;N&quot; in [a-z0-9]+N__.  The N is added by</span>
<a name="l01208"></a>01208 <span class="comment">         the GNAT front-end in protected object subprograms.  */</span>
<a name="l01209"></a>01209 
<a name="l01210"></a>01210       <span class="keywordflow">if</span> (i &lt; len0 + 3
<a name="l01211"></a>01211           &amp;&amp; encoded[i] == <span class="charliteral">&#39;N&#39;</span> &amp;&amp; encoded[i+1] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; encoded[i+2] == <span class="charliteral">&#39;_&#39;</span>)
<a name="l01212"></a>01212         {
<a name="l01213"></a>01213           <span class="comment">/* Backtrack a bit up until we reach either the begining of</span>
<a name="l01214"></a>01214 <span class="comment">             the encoded name, or &quot;__&quot;.  Make sure that we only find</span>
<a name="l01215"></a>01215 <span class="comment">             digits or lowercase characters.  */</span>
<a name="l01216"></a>01216           <span class="keyword">const</span> <span class="keywordtype">char</span> *ptr = encoded + i - 1;
<a name="l01217"></a>01217 
<a name="l01218"></a>01218           <span class="keywordflow">while</span> (ptr &gt;= encoded &amp;&amp; is_lower_alphanum (ptr[0]))
<a name="l01219"></a>01219             ptr--;
<a name="l01220"></a>01220           <span class="keywordflow">if</span> (ptr &lt; encoded
<a name="l01221"></a>01221               || (ptr &gt; encoded &amp;&amp; ptr[0] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; ptr[-1] == <span class="charliteral">&#39;_&#39;</span>))
<a name="l01222"></a>01222             i++;
<a name="l01223"></a>01223         }
<a name="l01224"></a>01224 
<a name="l01225"></a>01225       <span class="keywordflow">if</span> (encoded[i] == <span class="charliteral">&#39;X&#39;</span> &amp;&amp; i != 0 &amp;&amp; isalnum (encoded[i - 1]))
<a name="l01226"></a>01226         {
<a name="l01227"></a>01227           <span class="comment">/* This is a X[bn]* sequence not separated from the previous</span>
<a name="l01228"></a>01228 <span class="comment">             part of the name with a non-alpha-numeric character (in other</span>
<a name="l01229"></a>01229 <span class="comment">             words, immediately following an alpha-numeric character), then</span>
<a name="l01230"></a>01230 <span class="comment">             verify that it is placed at the end of the encoded name.  If</span>
<a name="l01231"></a>01231 <span class="comment">             not, then the encoding is not valid and we should abort the</span>
<a name="l01232"></a>01232 <span class="comment">             decoding.  Otherwise, just skip it, it is used in body-nested</span>
<a name="l01233"></a>01233 <span class="comment">             package names.  */</span>
<a name="l01234"></a>01234           <span class="keywordflow">do</span>
<a name="l01235"></a>01235             i += 1;
<a name="l01236"></a>01236           <span class="keywordflow">while</span> (i &lt; len0 &amp;&amp; (encoded[i] == <span class="charliteral">&#39;b&#39;</span> || encoded[i] == <span class="charliteral">&#39;n&#39;</span>));
<a name="l01237"></a>01237           <span class="keywordflow">if</span> (i &lt; len0)
<a name="l01238"></a>01238             <span class="keywordflow">goto</span> Suppress;
<a name="l01239"></a>01239         }
<a name="l01240"></a>01240       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i &lt; len0 - 2 &amp;&amp; encoded[i] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; encoded[i + 1] == <span class="charliteral">&#39;_&#39;</span>)
<a name="l01241"></a>01241         {
<a name="l01242"></a>01242          <span class="comment">/* Replace &#39;__&#39; by &#39;.&#39;.  */</span>
<a name="l01243"></a>01243           decoded[j] = <span class="charliteral">&#39;.&#39;</span>;
<a name="l01244"></a>01244           at_start_name = 1;
<a name="l01245"></a>01245           i += 2;
<a name="l01246"></a>01246           j += 1;
<a name="l01247"></a>01247         }
<a name="l01248"></a>01248       <span class="keywordflow">else</span>
<a name="l01249"></a>01249         {
<a name="l01250"></a>01250           <span class="comment">/* It&#39;s a character part of the decoded name, so just copy it</span>
<a name="l01251"></a>01251 <span class="comment">             over.  */</span>
<a name="l01252"></a>01252           decoded[j] = encoded[i];
<a name="l01253"></a>01253           i += 1;
<a name="l01254"></a>01254           j += 1;
<a name="l01255"></a>01255         }
<a name="l01256"></a>01256     }
<a name="l01257"></a>01257   decoded[j] = <span class="charliteral">&#39;\000&#39;</span>;
<a name="l01258"></a>01258 
<a name="l01259"></a>01259   <span class="comment">/* Decoded names should never contain any uppercase character.</span>
<a name="l01260"></a>01260 <span class="comment">     Double-check this, and abort the decoding if we find one.  */</span>
<a name="l01261"></a>01261 
<a name="l01262"></a>01262   <span class="keywordflow">for</span> (i = 0; decoded[i] != <span class="charliteral">&#39;\0&#39;</span>; i += 1)
<a name="l01263"></a>01263     <span class="keywordflow">if</span> (isupper (decoded[i]) || decoded[i] == <span class="charliteral">&#39; &#39;</span>)
<a name="l01264"></a>01264       <span class="keywordflow">goto</span> Suppress;
<a name="l01265"></a>01265 
<a name="l01266"></a>01266   <span class="keywordflow">if</span> (strcmp (decoded, encoded) == 0)
<a name="l01267"></a>01267     <span class="keywordflow">return</span> <a class="code" href="structada__opname__map.html#af4e7f0cadf2f970fb92488ae523cb706">encoded</a>;
<a name="l01268"></a>01268   <span class="keywordflow">else</span>
<a name="l01269"></a>01269     <span class="keywordflow">return</span> <a class="code" href="structada__opname__map.html#a84c52a9db147c775a3ccb707fe99130b">decoded</a>;
<a name="l01270"></a>01270 
<a name="l01271"></a>01271 Suppress:
<a name="l01272"></a>01272   <a class="code" href="ada-lang_8h.html#a48e9e90d45825a693f1690a4ebcb2a1e">GROW_VECT</a> (decoding_buffer, decoding_buffer_size, strlen (encoded) + 3);
<a name="l01273"></a>01273   decoded = decoding_buffer;
<a name="l01274"></a>01274   <span class="keywordflow">if</span> (encoded[0] == <span class="charliteral">&#39;&lt;&#39;</span>)
<a name="l01275"></a>01275     strcpy (decoded, encoded);
<a name="l01276"></a>01276   <span class="keywordflow">else</span>
<a name="l01277"></a>01277     <a class="code" href="common-utils_8c.html#ad9940337ec98983dae9951c947879fc8">xsnprintf</a> (decoded, decoding_buffer_size, <span class="stringliteral">&quot;&lt;%s&gt;&quot;</span>, encoded);
<a name="l01278"></a>01278   <span class="keywordflow">return</span> <a class="code" href="structada__opname__map.html#a84c52a9db147c775a3ccb707fe99130b">decoded</a>;
<a name="l01279"></a>01279 
<a name="l01280"></a>01280 }
<a name="l01281"></a>01281 
<a name="l01282"></a>01282 <span class="comment">/* Table for keeping permanent unique copies of decoded names.  Once</span>
<a name="l01283"></a>01283 <span class="comment">   allocated, names in this table are never released.  While this is a</span>
<a name="l01284"></a>01284 <span class="comment">   storage leak, it should not be significant unless there are massive</span>
<a name="l01285"></a>01285 <span class="comment">   changes in the set of decoded names in successive versions of a </span>
<a name="l01286"></a>01286 <span class="comment">   symbol table loaded during a single session.  */</span>
<a name="l01287"></a>01287 <span class="keyword">static</span> <span class="keyword">struct </span>htab *decoded_names_store;
<a name="l01288"></a>01288 
<a name="l01289"></a>01289 <span class="comment">/* Returns the decoded name of GSYMBOL, as for ada_decode, caching it</span>
<a name="l01290"></a>01290 <span class="comment">   in the language-specific part of GSYMBOL, if it has not been</span>
<a name="l01291"></a>01291 <span class="comment">   previously computed.  Tries to save the decoded name in the same</span>
<a name="l01292"></a>01292 <span class="comment">   obstack as GSYMBOL, if possible, and otherwise on the heap (so that,</span>
<a name="l01293"></a>01293 <span class="comment">   in any case, the decoded symbol has a lifetime at least that of</span>
<a name="l01294"></a>01294 <span class="comment">   GSYMBOL).</span>
<a name="l01295"></a>01295 <span class="comment">   The GSYMBOL parameter is &quot;mutable&quot; in the C++ sense: logically</span>
<a name="l01296"></a>01296 <span class="comment">   const, but nevertheless modified to a semantically equivalent form</span>
<a name="l01297"></a>01297 <span class="comment">   when a decoded name is cached in it.  */</span>
<a name="l01298"></a>01298 
<a name="l01299"></a>01299 <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l01300"></a><a class="code" href="ada-lang_8h.html#a7ec97e06c1c231aad1dd2c10fa516143">01300</a> <a class="code" href="ada-lang_8c.html#a0759556a07147e12315c47f285d099ba">ada_decode_symbol</a> (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structgeneral__symbol__info.html">general_symbol_info</a> *arg)
<a name="l01301"></a>01301 {
<a name="l01302"></a>01302   <span class="keyword">struct </span><a class="code" href="structgeneral__symbol__info.html">general_symbol_info</a> *gsymbol = (<span class="keyword">struct </span><a class="code" href="structgeneral__symbol__info.html">general_symbol_info</a> *) arg;
<a name="l01303"></a>01303   <span class="keyword">const</span> <span class="keywordtype">char</span> **resultp =
<a name="l01304"></a>01304     &amp;gsymbol-&gt;<a class="code" href="structgeneral__symbol__info.html#a56c967485fe77ac483b3fa11c75f514f">language_specific</a>.<a class="code" href="structgeneral__symbol__info.html#a4d022d9217329d4bde9210c9439d81b7">mangled_lang</a>.demangled_name;
<a name="l01305"></a>01305 
<a name="l01306"></a>01306   <span class="keywordflow">if</span> (!gsymbol-&gt;<a class="code" href="structgeneral__symbol__info.html#a7fa02a4f21c4460f0a7a4f4072bfed68">ada_mangled</a>)
<a name="l01307"></a>01307     {
<a name="l01308"></a>01308       <span class="keyword">const</span> <span class="keywordtype">char</span> *decoded = <a class="code" href="ada-lang_8c.html#a09b16b65c7ccf6ce05e91a51321903a1">ada_decode</a> (gsymbol-&gt;<a class="code" href="structgeneral__symbol__info.html#a4347da5f5930f7be0ae6d9e400304884">name</a>);
<a name="l01309"></a>01309       <span class="keyword">struct </span>obstack *obstack = gsymbol-&gt;<a class="code" href="structgeneral__symbol__info.html#a56c967485fe77ac483b3fa11c75f514f">language_specific</a>.<a class="code" href="structgeneral__symbol__info.html#a2b557d3695b119eb548bb73e0904527b">obstack</a>;
<a name="l01310"></a>01310 
<a name="l01311"></a>01311       gsymbol-&gt;<a class="code" href="structgeneral__symbol__info.html#a7fa02a4f21c4460f0a7a4f4072bfed68">ada_mangled</a> = 1;
<a name="l01312"></a>01312 
<a name="l01313"></a>01313       <span class="keywordflow">if</span> (obstack != NULL)
<a name="l01314"></a>01314         *resultp = obstack_copy0 (obstack, decoded, strlen (decoded));
<a name="l01315"></a>01315       <span class="keywordflow">else</span>
<a name="l01316"></a>01316         {
<a name="l01317"></a>01317           <span class="comment">/* Sometimes, we can&#39;t find a corresponding objfile, in</span>
<a name="l01318"></a>01318 <span class="comment">             which case, we put the result on the heap.  Since we only</span>
<a name="l01319"></a>01319 <span class="comment">             decode when needed, we hope this usually does not cause a</span>
<a name="l01320"></a>01320 <span class="comment">             significant memory leak (FIXME).  */</span>
<a name="l01321"></a>01321 
<a name="l01322"></a>01322           <span class="keywordtype">char</span> **slot = (<span class="keywordtype">char</span> **) htab_find_slot (decoded_names_store,
<a name="l01323"></a>01323                                                   decoded, INSERT);
<a name="l01324"></a>01324 
<a name="l01325"></a>01325           <span class="keywordflow">if</span> (*slot == NULL)
<a name="l01326"></a>01326             *slot = xstrdup (decoded);
<a name="l01327"></a>01327           *resultp = *slot;
<a name="l01328"></a>01328         }
<a name="l01329"></a>01329     }
<a name="l01330"></a>01330 
<a name="l01331"></a>01331   <span class="keywordflow">return</span> *resultp;
<a name="l01332"></a>01332 }
<a name="l01333"></a>01333 
<a name="l01334"></a>01334 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l01335"></a>01335 ada_la_decode (<span class="keyword">const</span> <span class="keywordtype">char</span> *encoded, <span class="keywordtype">int</span> options)
<a name="l01336"></a>01336 {
<a name="l01337"></a>01337   <span class="keywordflow">return</span> xstrdup (<a class="code" href="ada-lang_8c.html#a09b16b65c7ccf6ce05e91a51321903a1">ada_decode</a> (encoded));
<a name="l01338"></a>01338 }
<a name="l01339"></a>01339 
<a name="l01340"></a>01340 <span class="comment">/* Returns non-zero iff SYM_NAME matches NAME, ignoring any trailing</span>
<a name="l01341"></a>01341 <span class="comment">   suffixes that encode debugging information or leading _ada_ on</span>
<a name="l01342"></a>01342 <span class="comment">   SYM_NAME (see is_name_suffix commentary for the debugging</span>
<a name="l01343"></a>01343 <span class="comment">   information that is ignored).  If WILD, then NAME need only match a</span>
<a name="l01344"></a>01344 <span class="comment">   suffix of SYM_NAME minus the same suffixes.  Also returns 0 if</span>
<a name="l01345"></a>01345 <span class="comment">   either argument is NULL.  */</span>
<a name="l01346"></a>01346 
<a name="l01347"></a>01347 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01348"></a>01348 match_name (<span class="keyword">const</span> <span class="keywordtype">char</span> *sym_name, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, <span class="keywordtype">int</span> wild)
<a name="l01349"></a>01349 {
<a name="l01350"></a>01350   <span class="keywordflow">if</span> (sym_name == NULL || name == NULL)
<a name="l01351"></a>01351     <span class="keywordflow">return</span> 0;
<a name="l01352"></a>01352   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wild)
<a name="l01353"></a>01353     <span class="keywordflow">return</span> wild_match (sym_name, name) == 0;
<a name="l01354"></a>01354   <span class="keywordflow">else</span>
<a name="l01355"></a>01355     {
<a name="l01356"></a>01356       <span class="keywordtype">int</span> len_name = strlen (name);
<a name="l01357"></a>01357 
<a name="l01358"></a>01358       <span class="keywordflow">return</span> (strncmp (sym_name, name, len_name) == 0
<a name="l01359"></a>01359               &amp;&amp; is_name_suffix (sym_name + len_name))
<a name="l01360"></a>01360         || (strncmp (sym_name, <span class="stringliteral">&quot;_ada_&quot;</span>, 5) == 0
<a name="l01361"></a>01361             &amp;&amp; strncmp (sym_name + 5, name, len_name) == 0
<a name="l01362"></a>01362             &amp;&amp; is_name_suffix (sym_name + len_name + 5));
<a name="l01363"></a>01363     }
<a name="l01364"></a>01364 }
<a name="l01365"></a>01365 
<a name="l01366"></a>01366 
<a name="l01367"></a>01367                                 <span class="comment">/* Arrays */</span>
<a name="l01368"></a>01368 
<a name="l01369"></a>01369 <span class="comment">/* Assuming that INDEX_DESC_TYPE is an ___XA structure, a structure</span>
<a name="l01370"></a>01370 <span class="comment">   generated by the GNAT compiler to describe the index type used</span>
<a name="l01371"></a>01371 <span class="comment">   for each dimension of an array, check whether it follows the latest</span>
<a name="l01372"></a>01372 <span class="comment">   known encoding.  If not, fix it up to conform to the latest encoding.</span>
<a name="l01373"></a>01373 <span class="comment">   Otherwise, do nothing.  This function also does nothing if</span>
<a name="l01374"></a>01374 <span class="comment">   INDEX_DESC_TYPE is NULL.</span>
<a name="l01375"></a>01375 <span class="comment"></span>
<a name="l01376"></a>01376 <span class="comment">   The GNAT encoding used to describle the array index type evolved a bit.</span>
<a name="l01377"></a>01377 <span class="comment">   Initially, the information would be provided through the name of each</span>
<a name="l01378"></a>01378 <span class="comment">   field of the structure type only, while the type of these fields was</span>
<a name="l01379"></a>01379 <span class="comment">   described as unspecified and irrelevant.  The debugger was then expected</span>
<a name="l01380"></a>01380 <span class="comment">   to perform a global type lookup using the name of that field in order</span>
<a name="l01381"></a>01381 <span class="comment">   to get access to the full index type description.  Because these global</span>
<a name="l01382"></a>01382 <span class="comment">   lookups can be very expensive, the encoding was later enhanced to make</span>
<a name="l01383"></a>01383 <span class="comment">   the global lookup unnecessary by defining the field type as being</span>
<a name="l01384"></a>01384 <span class="comment">   the full index type description.</span>
<a name="l01385"></a>01385 <span class="comment"></span>
<a name="l01386"></a>01386 <span class="comment">   The purpose of this routine is to allow us to support older versions</span>
<a name="l01387"></a>01387 <span class="comment">   of the compiler by detecting the use of the older encoding, and by</span>
<a name="l01388"></a>01388 <span class="comment">   fixing up the INDEX_DESC_TYPE to follow the new one (at this point,</span>
<a name="l01389"></a>01389 <span class="comment">   we essentially replace each field&#39;s meaningless type by the associated</span>
<a name="l01390"></a>01390 <span class="comment">   index subtype).  */</span>
<a name="l01391"></a>01391 
<a name="l01392"></a>01392 <span class="keywordtype">void</span>
<a name="l01393"></a><a class="code" href="ada-lang_8h.html#ad725b7268112515bd22d705724724044">01393</a> <a class="code" href="ada-lang_8c.html#ad725b7268112515bd22d705724724044">ada_fixup_array_indexes_type</a> (<span class="keyword">struct</span> type *index_desc_type)
<a name="l01394"></a>01394 {
<a name="l01395"></a>01395   <span class="keywordtype">int</span> i;
<a name="l01396"></a>01396 
<a name="l01397"></a>01397   <span class="keywordflow">if</span> (index_desc_type == NULL)
<a name="l01398"></a>01398     <span class="keywordflow">return</span>;
<a name="l01399"></a>01399   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (index_desc_type) &gt; 0);
<a name="l01400"></a>01400 
<a name="l01401"></a>01401   <span class="comment">/* Check if INDEX_DESC_TYPE follows the older encoding (it is sufficient</span>
<a name="l01402"></a>01402 <span class="comment">     to check one field only, no need to check them all).  If not, return</span>
<a name="l01403"></a>01403 <span class="comment">     now.</span>
<a name="l01404"></a>01404 <span class="comment"></span>
<a name="l01405"></a>01405 <span class="comment">     If our INDEX_DESC_TYPE was generated using the older encoding,</span>
<a name="l01406"></a>01406 <span class="comment">     the field type should be a meaningless integer type whose name</span>
<a name="l01407"></a>01407 <span class="comment">     is not equal to the field name.  */</span>
<a name="l01408"></a>01408   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (index_desc_type, 0)) != NULL
<a name="l01409"></a>01409       &amp;&amp; strcmp (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (index_desc_type, 0)),
<a name="l01410"></a>01410                  <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (index_desc_type, 0)) == 0)
<a name="l01411"></a>01411     <span class="keywordflow">return</span>;
<a name="l01412"></a>01412 
<a name="l01413"></a>01413   <span class="comment">/* Fixup each field of INDEX_DESC_TYPE.  */</span>
<a name="l01414"></a>01414   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (index_desc_type); i++)
<a name="l01415"></a>01415    {
<a name="l01416"></a>01416      <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (index_desc_type, i);
<a name="l01417"></a>01417      <span class="keyword">struct </span>type *raw_type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (ada_find_any_type (name));
<a name="l01418"></a>01418 
<a name="l01419"></a>01419      <span class="keywordflow">if</span> (raw_type)
<a name="l01420"></a>01420        <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (index_desc_type, i) = raw_type;
<a name="l01421"></a>01421    }
<a name="l01422"></a>01422 }
<a name="l01423"></a>01423 
<a name="l01424"></a>01424 <span class="comment">/* Names of MAX_ADA_DIMENS bounds in P_BOUNDS fields of array descriptors.  */</span>
<a name="l01425"></a>01425 
<a name="l01426"></a>01426 <span class="keyword">static</span> <span class="keywordtype">char</span> *bound_name[] = {
<a name="l01427"></a>01427   <span class="stringliteral">&quot;LB0&quot;</span>, <span class="stringliteral">&quot;UB0&quot;</span>, <span class="stringliteral">&quot;LB1&quot;</span>, <span class="stringliteral">&quot;UB1&quot;</span>, <span class="stringliteral">&quot;LB2&quot;</span>, <span class="stringliteral">&quot;UB2&quot;</span>, <span class="stringliteral">&quot;LB3&quot;</span>, <span class="stringliteral">&quot;UB3&quot;</span>,
<a name="l01428"></a>01428   <span class="stringliteral">&quot;LB4&quot;</span>, <span class="stringliteral">&quot;UB4&quot;</span>, <span class="stringliteral">&quot;LB5&quot;</span>, <span class="stringliteral">&quot;UB5&quot;</span>, <span class="stringliteral">&quot;LB6&quot;</span>, <span class="stringliteral">&quot;UB6&quot;</span>, <span class="stringliteral">&quot;LB7&quot;</span>, <span class="stringliteral">&quot;UB7&quot;</span>
<a name="l01429"></a>01429 };
<a name="l01430"></a>01430 
<a name="l01431"></a>01431 <span class="comment">/* Maximum number of array dimensions we are prepared to handle.  */</span>
<a name="l01432"></a>01432 
<a name="l01433"></a><a class="code" href="ada-lang_8c.html#a07b35ed5c6847ea2da5630412628cfb3">01433</a> <span class="preprocessor">#define MAX_ADA_DIMENS (sizeof(bound_name) / (2*sizeof(char *)))</span>
<a name="l01434"></a>01434 <span class="preprocessor"></span>
<a name="l01435"></a>01435 
<a name="l01436"></a>01436 <span class="comment">/* The desc_* routines return primitive portions of array descriptors</span>
<a name="l01437"></a>01437 <span class="comment">   (fat pointers).  */</span>
<a name="l01438"></a>01438 
<a name="l01439"></a>01439 <span class="comment">/* The descriptor or array type, if any, indicated by TYPE; removes</span>
<a name="l01440"></a>01440 <span class="comment">   level of indirection, if needed.  */</span>
<a name="l01441"></a>01441 
<a name="l01442"></a>01442 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l01443"></a>01443 desc_base_type (<span class="keyword">struct</span> type *type)
<a name="l01444"></a>01444 {
<a name="l01445"></a>01445   <span class="keywordflow">if</span> (type == NULL)
<a name="l01446"></a>01446     <span class="keywordflow">return</span> NULL;
<a name="l01447"></a>01447   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l01448"></a>01448   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>)
<a name="l01449"></a>01449     type = ada_typedef_target_type (type);
<a name="l01450"></a>01450 
<a name="l01451"></a>01451   <span class="keywordflow">if</span> (type != NULL
<a name="l01452"></a>01452       &amp;&amp; (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l01453"></a>01453           || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>))
<a name="l01454"></a>01454     <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type));
<a name="l01455"></a>01455   <span class="keywordflow">else</span>
<a name="l01456"></a>01456     <span class="keywordflow">return</span> type;
<a name="l01457"></a>01457 }
<a name="l01458"></a>01458 
<a name="l01459"></a>01459 <span class="comment">/* True iff TYPE indicates a &quot;thin&quot; array pointer type.  */</span>
<a name="l01460"></a>01460 
<a name="l01461"></a>01461 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01462"></a>01462 is_thin_pntr (<span class="keyword">struct</span> type *type)
<a name="l01463"></a>01463 {
<a name="l01464"></a>01464   <span class="keywordflow">return</span>
<a name="l01465"></a>01465     is_suffix (<a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (desc_base_type (type)), <span class="stringliteral">&quot;___XUT&quot;</span>)
<a name="l01466"></a>01466     || is_suffix (<a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (desc_base_type (type)), <span class="stringliteral">&quot;___XUT___XVE&quot;</span>);
<a name="l01467"></a>01467 }
<a name="l01468"></a>01468 
<a name="l01469"></a>01469 <span class="comment">/* The descriptor type for thin pointer type TYPE.  */</span>
<a name="l01470"></a>01470 
<a name="l01471"></a>01471 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l01472"></a>01472 thin_descriptor_type (<span class="keyword">struct</span> type *type)
<a name="l01473"></a>01473 {
<a name="l01474"></a>01474   <span class="keyword">struct </span>type *base_type = desc_base_type (type);
<a name="l01475"></a>01475 
<a name="l01476"></a>01476   <span class="keywordflow">if</span> (base_type == NULL)
<a name="l01477"></a>01477     <span class="keywordflow">return</span> NULL;
<a name="l01478"></a>01478   <span class="keywordflow">if</span> (is_suffix (<a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (base_type), <span class="stringliteral">&quot;___XVE&quot;</span>))
<a name="l01479"></a>01479     <span class="keywordflow">return</span> base_type;
<a name="l01480"></a>01480   <span class="keywordflow">else</span>
<a name="l01481"></a>01481     {
<a name="l01482"></a>01482       <span class="keyword">struct </span>type *alt_type = <a class="code" href="ada-lang_8c.html#ade263e735047904b7eabe725cd6cc2f9">ada_find_parallel_type</a> (base_type, <span class="stringliteral">&quot;___XVE&quot;</span>);
<a name="l01483"></a>01483 
<a name="l01484"></a>01484       <span class="keywordflow">if</span> (alt_type == NULL)
<a name="l01485"></a>01485         <span class="keywordflow">return</span> base_type;
<a name="l01486"></a>01486       <span class="keywordflow">else</span>
<a name="l01487"></a>01487         <span class="keywordflow">return</span> alt_type;
<a name="l01488"></a>01488     }
<a name="l01489"></a>01489 }
<a name="l01490"></a>01490 
<a name="l01491"></a>01491 <span class="comment">/* A pointer to the array data for thin-pointer value VAL.  */</span>
<a name="l01492"></a>01492 
<a name="l01493"></a>01493 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l01494"></a>01494 thin_data_pntr (<span class="keyword">struct</span> value *val)
<a name="l01495"></a>01495 {
<a name="l01496"></a>01496   <span class="keyword">struct </span>type *type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val));
<a name="l01497"></a>01497   <span class="keyword">struct </span>type *data_type = desc_data_target_type (thin_descriptor_type (type));
<a name="l01498"></a>01498 
<a name="l01499"></a>01499   data_type = <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (data_type);
<a name="l01500"></a>01500 
<a name="l01501"></a>01501   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l01502"></a>01502     <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (data_type, <a class="code" href="value_8c.html#abe2b4f6342cfefdbb63666b6bcba636b">value_copy</a> (val));
<a name="l01503"></a>01503   <span class="keywordflow">else</span>
<a name="l01504"></a>01504     <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (data_type, <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (val));
<a name="l01505"></a>01505 }
<a name="l01506"></a>01506 
<a name="l01507"></a>01507 <span class="comment">/* True iff TYPE indicates a &quot;thick&quot; array pointer type.  */</span>
<a name="l01508"></a>01508 
<a name="l01509"></a>01509 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01510"></a>01510 is_thick_pntr (<span class="keyword">struct</span> type *type)
<a name="l01511"></a>01511 {
<a name="l01512"></a>01512   type = desc_base_type (type);
<a name="l01513"></a>01513   <span class="keywordflow">return</span> (type != NULL &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l01514"></a>01514           &amp;&amp; <a class="code" href="gdbtypes_8c.html#af148a4aea0393ca08a9da997b8cda7d6">lookup_struct_elt_type</a> (type, <span class="stringliteral">&quot;P_BOUNDS&quot;</span>, 1) != NULL);
<a name="l01515"></a>01515 }
<a name="l01516"></a>01516 
<a name="l01517"></a>01517 <span class="comment">/* If TYPE is the type of an array descriptor (fat or thin pointer) or a</span>
<a name="l01518"></a>01518 <span class="comment">   pointer to one, the type of its bounds data; otherwise, NULL.  */</span>
<a name="l01519"></a>01519 
<a name="l01520"></a>01520 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l01521"></a>01521 desc_bounds_type (<span class="keyword">struct</span> type *type)
<a name="l01522"></a>01522 {
<a name="l01523"></a>01523   <span class="keyword">struct </span>type *r;
<a name="l01524"></a>01524 
<a name="l01525"></a>01525   type = desc_base_type (type);
<a name="l01526"></a>01526 
<a name="l01527"></a>01527   <span class="keywordflow">if</span> (type == NULL)
<a name="l01528"></a>01528     <span class="keywordflow">return</span> NULL;
<a name="l01529"></a>01529   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_thin_pntr (type))
<a name="l01530"></a>01530     {
<a name="l01531"></a>01531       type = thin_descriptor_type (type);
<a name="l01532"></a>01532       <span class="keywordflow">if</span> (type == NULL)
<a name="l01533"></a>01533         <span class="keywordflow">return</span> NULL;
<a name="l01534"></a>01534       r = <a class="code" href="gdbtypes_8c.html#af148a4aea0393ca08a9da997b8cda7d6">lookup_struct_elt_type</a> (type, <span class="stringliteral">&quot;BOUNDS&quot;</span>, 1);
<a name="l01535"></a>01535       <span class="keywordflow">if</span> (r != NULL)
<a name="l01536"></a>01536         <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (r);
<a name="l01537"></a>01537     }
<a name="l01538"></a>01538   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>)
<a name="l01539"></a>01539     {
<a name="l01540"></a>01540       r = <a class="code" href="gdbtypes_8c.html#af148a4aea0393ca08a9da997b8cda7d6">lookup_struct_elt_type</a> (type, <span class="stringliteral">&quot;P_BOUNDS&quot;</span>, 1);
<a name="l01541"></a>01541       <span class="keywordflow">if</span> (r != NULL)
<a name="l01542"></a>01542         <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (r)));
<a name="l01543"></a>01543     }
<a name="l01544"></a>01544   <span class="keywordflow">return</span> NULL;
<a name="l01545"></a>01545 }
<a name="l01546"></a>01546 
<a name="l01547"></a>01547 <span class="comment">/* If ARR is an array descriptor (fat or thin pointer), or pointer to</span>
<a name="l01548"></a>01548 <span class="comment">   one, a pointer to its bounds data.   Otherwise NULL.  */</span>
<a name="l01549"></a>01549 
<a name="l01550"></a>01550 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l01551"></a>01551 desc_bounds (<span class="keyword">struct</span> value *arr)
<a name="l01552"></a>01552 {
<a name="l01553"></a>01553   <span class="keyword">struct </span>type *type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr));
<a name="l01554"></a>01554 
<a name="l01555"></a>01555   <span class="keywordflow">if</span> (is_thin_pntr (type))
<a name="l01556"></a>01556     {
<a name="l01557"></a>01557       <span class="keyword">struct </span>type *bounds_type =
<a name="l01558"></a>01558         desc_bounds_type (thin_descriptor_type (type));
<a name="l01559"></a>01559       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> addr;
<a name="l01560"></a>01560 
<a name="l01561"></a>01561       <span class="keywordflow">if</span> (bounds_type == NULL)
<a name="l01562"></a>01562         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Bad GNAT array descriptor&quot;</span>));
<a name="l01563"></a>01563 
<a name="l01564"></a>01564       <span class="comment">/* NOTE: The following calculation is not really kosher, but</span>
<a name="l01565"></a>01565 <span class="comment">         since desc_type is an XVE-encoded type (and shouldn&#39;t be),</span>
<a name="l01566"></a>01566 <span class="comment">         the correct calculation is a real pain.  FIXME (and fix GCC).  */</span>
<a name="l01567"></a>01567       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l01568"></a>01568         addr = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arr);
<a name="l01569"></a>01569       <span class="keywordflow">else</span>
<a name="l01570"></a>01570         addr = <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (arr);
<a name="l01571"></a>01571 
<a name="l01572"></a>01572       <span class="keywordflow">return</span>
<a name="l01573"></a>01573         <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (<a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (bounds_type),
<a name="l01574"></a>01574                             addr - <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (bounds_type));
<a name="l01575"></a>01575     }
<a name="l01576"></a>01576 
<a name="l01577"></a>01577   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_thick_pntr (type))
<a name="l01578"></a>01578     {
<a name="l01579"></a>01579       <span class="keyword">struct </span>value *p_bounds = <a class="code" href="valops_8c.html#a6abb19142201b9964d661edfd4d8a058">value_struct_elt</a> (&amp;arr, NULL, <span class="stringliteral">&quot;P_BOUNDS&quot;</span>, NULL,
<a name="l01580"></a>01580                                                <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Bad GNAT array descriptor&quot;</span>));
<a name="l01581"></a>01581       <span class="keyword">struct </span>type *p_bounds_type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (p_bounds);
<a name="l01582"></a>01582 
<a name="l01583"></a>01583       <span class="keywordflow">if</span> (p_bounds_type
<a name="l01584"></a>01584           &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (p_bounds_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l01585"></a>01585         {
<a name="l01586"></a>01586           <span class="keyword">struct </span>type *target_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (p_bounds_type);
<a name="l01587"></a>01587 
<a name="l01588"></a>01588           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aec5d0569d60af8ecfc5d2c7edae87d9c">TYPE_STUB</a> (target_type))
<a name="l01589"></a>01589             p_bounds = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (<a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a>
<a name="l01590"></a>01590                                    (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (target_type)),
<a name="l01591"></a>01591                                    p_bounds);
<a name="l01592"></a>01592         }
<a name="l01593"></a>01593       <span class="keywordflow">else</span>
<a name="l01594"></a>01594         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Bad GNAT array descriptor&quot;</span>));
<a name="l01595"></a>01595 
<a name="l01596"></a>01596       <span class="keywordflow">return</span> p_bounds;
<a name="l01597"></a>01597     }
<a name="l01598"></a>01598   <span class="keywordflow">else</span>
<a name="l01599"></a>01599     <span class="keywordflow">return</span> NULL;
<a name="l01600"></a>01600 }
<a name="l01601"></a>01601 
<a name="l01602"></a>01602 <span class="comment">/* If TYPE is the type of an array-descriptor (fat pointer),  the bit</span>
<a name="l01603"></a>01603 <span class="comment">   position of the field containing the address of the bounds data.  */</span>
<a name="l01604"></a>01604 
<a name="l01605"></a>01605 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01606"></a>01606 fat_pntr_bounds_bitpos (<span class="keyword">struct</span> type *type)
<a name="l01607"></a>01607 {
<a name="l01608"></a>01608   <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (desc_base_type (type), 1);
<a name="l01609"></a>01609 }
<a name="l01610"></a>01610 
<a name="l01611"></a>01611 <span class="comment">/* If TYPE is the type of an array-descriptor (fat pointer), the bit</span>
<a name="l01612"></a>01612 <span class="comment">   size of the field containing the address of the bounds data.  */</span>
<a name="l01613"></a>01613 
<a name="l01614"></a>01614 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01615"></a>01615 fat_pntr_bounds_bitsize (<span class="keyword">struct</span> type *type)
<a name="l01616"></a>01616 {
<a name="l01617"></a>01617   type = desc_base_type (type);
<a name="l01618"></a>01618 
<a name="l01619"></a>01619   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (type, 1) &gt; 0)
<a name="l01620"></a>01620     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (type, 1);
<a name="l01621"></a>01621   <span class="keywordflow">else</span>
<a name="l01622"></a>01622     <span class="keywordflow">return</span> 8 * <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, 1)));
<a name="l01623"></a>01623 }
<a name="l01624"></a>01624 
<a name="l01625"></a>01625 <span class="comment">/* If TYPE is the type of an array descriptor (fat or thin pointer) or a</span>
<a name="l01626"></a>01626 <span class="comment">   pointer to one, the type of its array data (a array-with-no-bounds type);</span>
<a name="l01627"></a>01627 <span class="comment">   otherwise, NULL.  Use ada_type_of_array to get an array type with bounds</span>
<a name="l01628"></a>01628 <span class="comment">   data.  */</span>
<a name="l01629"></a>01629 
<a name="l01630"></a>01630 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l01631"></a>01631 desc_data_target_type (<span class="keyword">struct</span> type *type)
<a name="l01632"></a>01632 {
<a name="l01633"></a>01633   type = desc_base_type (type);
<a name="l01634"></a>01634 
<a name="l01635"></a>01635   <span class="comment">/* NOTE: The following is bogus; see comment in desc_bounds.  */</span>
<a name="l01636"></a>01636   <span class="keywordflow">if</span> (is_thin_pntr (type))
<a name="l01637"></a>01637     <span class="keywordflow">return</span> desc_base_type (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (thin_descriptor_type (type), 1));
<a name="l01638"></a>01638   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_thick_pntr (type))
<a name="l01639"></a>01639     {
<a name="l01640"></a>01640       <span class="keyword">struct </span>type *data_type = <a class="code" href="gdbtypes_8c.html#af148a4aea0393ca08a9da997b8cda7d6">lookup_struct_elt_type</a> (type, <span class="stringliteral">&quot;P_ARRAY&quot;</span>, 1);
<a name="l01641"></a>01641 
<a name="l01642"></a>01642       <span class="keywordflow">if</span> (data_type
<a name="l01643"></a>01643           &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (data_type)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l01644"></a>01644         <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (data_type));
<a name="l01645"></a>01645     }
<a name="l01646"></a>01646 
<a name="l01647"></a>01647   <span class="keywordflow">return</span> NULL;
<a name="l01648"></a>01648 }
<a name="l01649"></a>01649 
<a name="l01650"></a>01650 <span class="comment">/* If ARR is an array descriptor (fat or thin pointer), a pointer to</span>
<a name="l01651"></a>01651 <span class="comment">   its array data.  */</span>
<a name="l01652"></a>01652 
<a name="l01653"></a>01653 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l01654"></a>01654 desc_data (<span class="keyword">struct</span> value *arr)
<a name="l01655"></a>01655 {
<a name="l01656"></a>01656   <span class="keyword">struct </span>type *type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr);
<a name="l01657"></a>01657 
<a name="l01658"></a>01658   <span class="keywordflow">if</span> (is_thin_pntr (type))
<a name="l01659"></a>01659     <span class="keywordflow">return</span> thin_data_pntr (arr);
<a name="l01660"></a>01660   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_thick_pntr (type))
<a name="l01661"></a>01661     <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a6abb19142201b9964d661edfd4d8a058">value_struct_elt</a> (&amp;arr, NULL, <span class="stringliteral">&quot;P_ARRAY&quot;</span>, NULL,
<a name="l01662"></a>01662                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Bad GNAT array descriptor&quot;</span>));
<a name="l01663"></a>01663   <span class="keywordflow">else</span>
<a name="l01664"></a>01664     <span class="keywordflow">return</span> NULL;
<a name="l01665"></a>01665 }
<a name="l01666"></a>01666 
<a name="l01667"></a>01667 
<a name="l01668"></a>01668 <span class="comment">/* If TYPE is the type of an array-descriptor (fat pointer), the bit</span>
<a name="l01669"></a>01669 <span class="comment">   position of the field containing the address of the data.  */</span>
<a name="l01670"></a>01670 
<a name="l01671"></a>01671 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01672"></a>01672 fat_pntr_data_bitpos (<span class="keyword">struct</span> type *type)
<a name="l01673"></a>01673 {
<a name="l01674"></a>01674   <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (desc_base_type (type), 0);
<a name="l01675"></a>01675 }
<a name="l01676"></a>01676 
<a name="l01677"></a>01677 <span class="comment">/* If TYPE is the type of an array-descriptor (fat pointer), the bit</span>
<a name="l01678"></a>01678 <span class="comment">   size of the field containing the address of the data.  */</span>
<a name="l01679"></a>01679 
<a name="l01680"></a>01680 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01681"></a>01681 fat_pntr_data_bitsize (<span class="keyword">struct</span> type *type)
<a name="l01682"></a>01682 {
<a name="l01683"></a>01683   type = desc_base_type (type);
<a name="l01684"></a>01684 
<a name="l01685"></a>01685   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (type, 0) &gt; 0)
<a name="l01686"></a>01686     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (type, 0);
<a name="l01687"></a>01687   <span class="keywordflow">else</span>
<a name="l01688"></a>01688     <span class="keywordflow">return</span> TARGET_CHAR_BIT * <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, 0));
<a name="l01689"></a>01689 }
<a name="l01690"></a>01690 
<a name="l01691"></a>01691 <span class="comment">/* If BOUNDS is an array-bounds structure (or pointer to one), return</span>
<a name="l01692"></a>01692 <span class="comment">   the Ith lower bound stored in it, if WHICH is 0, and the Ith upper</span>
<a name="l01693"></a>01693 <span class="comment">   bound, if WHICH is 1.  The first bound is I=1.  */</span>
<a name="l01694"></a>01694 
<a name="l01695"></a>01695 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l01696"></a>01696 desc_one_bound (<span class="keyword">struct</span> value *bounds, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> which)
<a name="l01697"></a>01697 {
<a name="l01698"></a>01698   <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a6abb19142201b9964d661edfd4d8a058">value_struct_elt</a> (&amp;bounds, NULL, bound_name[2 * i + which - 2], NULL,
<a name="l01699"></a>01699                            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Bad GNAT array descriptor bounds&quot;</span>));
<a name="l01700"></a>01700 }
<a name="l01701"></a>01701 
<a name="l01702"></a>01702 <span class="comment">/* If BOUNDS is an array-bounds structure type, return the bit position</span>
<a name="l01703"></a>01703 <span class="comment">   of the Ith lower bound stored in it, if WHICH is 0, and the Ith upper</span>
<a name="l01704"></a>01704 <span class="comment">   bound, if WHICH is 1.  The first bound is I=1.  */</span>
<a name="l01705"></a>01705 
<a name="l01706"></a>01706 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01707"></a>01707 desc_bound_bitpos (<span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> which)
<a name="l01708"></a>01708 {
<a name="l01709"></a>01709   <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (desc_base_type (type), 2 * i + which - 2);
<a name="l01710"></a>01710 }
<a name="l01711"></a>01711 
<a name="l01712"></a>01712 <span class="comment">/* If BOUNDS is an array-bounds structure type, return the bit field size</span>
<a name="l01713"></a>01713 <span class="comment">   of the Ith lower bound stored in it, if WHICH is 0, and the Ith upper</span>
<a name="l01714"></a>01714 <span class="comment">   bound, if WHICH is 1.  The first bound is I=1.  */</span>
<a name="l01715"></a>01715 
<a name="l01716"></a>01716 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01717"></a>01717 desc_bound_bitsize (<span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> which)
<a name="l01718"></a>01718 {
<a name="l01719"></a>01719   type = desc_base_type (type);
<a name="l01720"></a>01720 
<a name="l01721"></a>01721   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (type, 2 * i + which - 2) &gt; 0)
<a name="l01722"></a>01722     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (type, 2 * i + which - 2);
<a name="l01723"></a>01723   <span class="keywordflow">else</span>
<a name="l01724"></a>01724     <span class="keywordflow">return</span> 8 * <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, 2 * i + which - 2));
<a name="l01725"></a>01725 }
<a name="l01726"></a>01726 
<a name="l01727"></a>01727 <span class="comment">/* If TYPE is the type of an array-bounds structure, the type of its</span>
<a name="l01728"></a>01728 <span class="comment">   Ith bound (numbering from 1).  Otherwise, NULL.  */</span>
<a name="l01729"></a>01729 
<a name="l01730"></a>01730 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l01731"></a>01731 desc_index_type (<span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> i)
<a name="l01732"></a>01732 {
<a name="l01733"></a>01733   type = desc_base_type (type);
<a name="l01734"></a>01734 
<a name="l01735"></a>01735   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>)
<a name="l01736"></a>01736     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#af148a4aea0393ca08a9da997b8cda7d6">lookup_struct_elt_type</a> (type, bound_name[2 * i - 2], 1);
<a name="l01737"></a>01737   <span class="keywordflow">else</span>
<a name="l01738"></a>01738     <span class="keywordflow">return</span> NULL;
<a name="l01739"></a>01739 }
<a name="l01740"></a>01740 
<a name="l01741"></a>01741 <span class="comment">/* The number of index positions in the array-bounds type TYPE.</span>
<a name="l01742"></a>01742 <span class="comment">   Return 0 if TYPE is NULL.  */</span>
<a name="l01743"></a>01743 
<a name="l01744"></a>01744 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01745"></a>01745 desc_arity (<span class="keyword">struct</span> type *type)
<a name="l01746"></a>01746 {
<a name="l01747"></a>01747   type = desc_base_type (type);
<a name="l01748"></a>01748 
<a name="l01749"></a>01749   <span class="keywordflow">if</span> (type != NULL)
<a name="l01750"></a>01750     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) / 2;
<a name="l01751"></a>01751   <span class="keywordflow">return</span> 0;
<a name="l01752"></a>01752 }
<a name="l01753"></a>01753 
<a name="l01754"></a>01754 <span class="comment">/* Non-zero iff TYPE is a simple array type (not a pointer to one) or </span>
<a name="l01755"></a>01755 <span class="comment">   an array descriptor type (representing an unconstrained array</span>
<a name="l01756"></a>01756 <span class="comment">   type).  */</span>
<a name="l01757"></a>01757 
<a name="l01758"></a>01758 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01759"></a>01759 ada_is_direct_array_type (<span class="keyword">struct</span> type *type)
<a name="l01760"></a>01760 {
<a name="l01761"></a>01761   <span class="keywordflow">if</span> (type == NULL)
<a name="l01762"></a>01762     <span class="keywordflow">return</span> 0;
<a name="l01763"></a>01763   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l01764"></a>01764   <span class="keywordflow">return</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l01765"></a>01765           || <a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (type));
<a name="l01766"></a>01766 }
<a name="l01767"></a>01767 
<a name="l01768"></a>01768 <span class="comment">/* Non-zero iff TYPE represents any kind of array in Ada, or a pointer</span>
<a name="l01769"></a>01769 <span class="comment"> * to one.  */</span>
<a name="l01770"></a>01770 
<a name="l01771"></a>01771 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01772"></a>01772 ada_is_array_type (<span class="keyword">struct</span> type *type)
<a name="l01773"></a>01773 {
<a name="l01774"></a>01774   <span class="keywordflow">while</span> (type != NULL 
<a name="l01775"></a>01775          &amp;&amp; (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a> 
<a name="l01776"></a>01776              || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>))
<a name="l01777"></a>01777     type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l01778"></a>01778   <span class="keywordflow">return</span> ada_is_direct_array_type (type);
<a name="l01779"></a>01779 }
<a name="l01780"></a>01780 
<a name="l01781"></a>01781 <span class="comment">/* Non-zero iff TYPE is a simple array type or pointer to one.  */</span>
<a name="l01782"></a>01782 
<a name="l01783"></a>01783 <span class="keywordtype">int</span>
<a name="l01784"></a><a class="code" href="ada-lang_8h.html#af2c33cc9892c4903b4d7dd1c33282f10">01784</a> <a class="code" href="ada-lang_8c.html#a98ee7e79620d6af77ffd35c586fcf7bd">ada_is_simple_array_type</a> (<span class="keyword">struct</span> type *type)
<a name="l01785"></a>01785 {
<a name="l01786"></a>01786   <span class="keywordflow">if</span> (type == NULL)
<a name="l01787"></a>01787     <span class="keywordflow">return</span> 0;
<a name="l01788"></a>01788   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l01789"></a>01789   <span class="keywordflow">return</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l01790"></a>01790           || (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l01791"></a>01791               &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)))
<a name="l01792"></a>01792                  == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>));
<a name="l01793"></a>01793 }
<a name="l01794"></a>01794 
<a name="l01795"></a>01795 <span class="comment">/* Non-zero iff TYPE belongs to a GNAT array descriptor.  */</span>
<a name="l01796"></a>01796 
<a name="l01797"></a>01797 <span class="keywordtype">int</span>
<a name="l01798"></a><a class="code" href="ada-lang_8h.html#afaa3693b593bcf01df5e760b83b0f15a">01798</a> <a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (<span class="keyword">struct</span> type *type)
<a name="l01799"></a>01799 {
<a name="l01800"></a>01800   <span class="keyword">struct </span>type *data_type = desc_data_target_type (type);
<a name="l01801"></a>01801 
<a name="l01802"></a>01802   <span class="keywordflow">if</span> (type == NULL)
<a name="l01803"></a>01803     <span class="keywordflow">return</span> 0;
<a name="l01804"></a>01804   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l01805"></a>01805   <span class="keywordflow">return</span> (data_type != NULL
<a name="l01806"></a>01806           &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (data_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l01807"></a>01807           &amp;&amp; desc_arity (desc_bounds_type (type)) &gt; 0);
<a name="l01808"></a>01808 }
<a name="l01809"></a>01809 
<a name="l01810"></a>01810 <span class="comment">/* Non-zero iff type is a partially mal-formed GNAT array</span>
<a name="l01811"></a>01811 <span class="comment">   descriptor.  FIXME: This is to compensate for some problems with</span>
<a name="l01812"></a>01812 <span class="comment">   debugging output from GNAT.  Re-examine periodically to see if it</span>
<a name="l01813"></a>01813 <span class="comment">   is still needed.  */</span>
<a name="l01814"></a>01814 
<a name="l01815"></a>01815 <span class="keywordtype">int</span>
<a name="l01816"></a><a class="code" href="ada-lang_8h.html#a8d2df60c001c385e610cb3828671c41d">01816</a> <a class="code" href="ada-lang_8c.html#ad52f9674c514aacff59ea5803e354f89">ada_is_bogus_array_descriptor</a> (<span class="keyword">struct</span> type *type)
<a name="l01817"></a>01817 {
<a name="l01818"></a>01818   <span class="keywordflow">return</span>
<a name="l01819"></a>01819     type != NULL
<a name="l01820"></a>01820     &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l01821"></a>01821     &amp;&amp; (<a class="code" href="gdbtypes_8c.html#af148a4aea0393ca08a9da997b8cda7d6">lookup_struct_elt_type</a> (type, <span class="stringliteral">&quot;P_BOUNDS&quot;</span>, 1) != NULL
<a name="l01822"></a>01822         || <a class="code" href="gdbtypes_8c.html#af148a4aea0393ca08a9da997b8cda7d6">lookup_struct_elt_type</a> (type, <span class="stringliteral">&quot;P_ARRAY&quot;</span>, 1) != NULL)
<a name="l01823"></a>01823     &amp;&amp; !<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (type);
<a name="l01824"></a>01824 }
<a name="l01825"></a>01825 
<a name="l01826"></a>01826 
<a name="l01827"></a>01827 <span class="comment">/* If ARR has a record type in the form of a standard GNAT array descriptor,</span>
<a name="l01828"></a>01828 <span class="comment">   (fat pointer) returns the type of the array data described---specifically,</span>
<a name="l01829"></a>01829 <span class="comment">   a pointer-to-array type.  If BOUNDS is non-zero, the bounds data are filled</span>
<a name="l01830"></a>01830 <span class="comment">   in from the descriptor; otherwise, they are left unspecified.  If</span>
<a name="l01831"></a>01831 <span class="comment">   the ARR denotes a null array descriptor and BOUNDS is non-zero,</span>
<a name="l01832"></a>01832 <span class="comment">   returns NULL.  The result is simply the type of ARR if ARR is not</span>
<a name="l01833"></a>01833 <span class="comment">   a descriptor.  */</span>
<a name="l01834"></a>01834 <span class="keyword">struct </span>type *
<a name="l01835"></a><a class="code" href="ada-lang_8h.html#a0d999a5bbba61bfacd82f02a5df512e4">01835</a> <a class="code" href="ada-lang_8c.html#a7a98282573c2d74e48913babce683aa0">ada_type_of_array</a> (<span class="keyword">struct</span> value *arr, <span class="keywordtype">int</span> bounds)
<a name="l01836"></a>01836 {
<a name="l01837"></a>01837   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr)))
<a name="l01838"></a>01838     <span class="keywordflow">return</span> decode_constrained_packed_array_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr));
<a name="l01839"></a>01839 
<a name="l01840"></a>01840   <span class="keywordflow">if</span> (!<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr)))
<a name="l01841"></a>01841     <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr);
<a name="l01842"></a>01842 
<a name="l01843"></a>01843   <span class="keywordflow">if</span> (!bounds)
<a name="l01844"></a>01844     {
<a name="l01845"></a>01845       <span class="keyword">struct </span>type *array_type =
<a name="l01846"></a>01846         <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (desc_data_target_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr)));
<a name="l01847"></a>01847 
<a name="l01848"></a>01848       <span class="keywordflow">if</span> (ada_is_unconstrained_packed_array_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr)))
<a name="l01849"></a>01849         <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (array_type, 0) =
<a name="l01850"></a>01850           decode_packed_array_bitsize (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr));
<a name="l01851"></a>01851       
<a name="l01852"></a>01852       <span class="keywordflow">return</span> array_type;
<a name="l01853"></a>01853     }
<a name="l01854"></a>01854   <span class="keywordflow">else</span>
<a name="l01855"></a>01855     {
<a name="l01856"></a>01856       <span class="keyword">struct </span>type *elt_type;
<a name="l01857"></a>01857       <span class="keywordtype">int</span> arity;
<a name="l01858"></a>01858       <span class="keyword">struct </span>value *descriptor;
<a name="l01859"></a>01859 
<a name="l01860"></a>01860       elt_type = <a class="code" href="ada-lang_8c.html#a6d2b3240a3d6eabb276131b5753e804e">ada_array_element_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr), -1);
<a name="l01861"></a>01861       arity = <a class="code" href="ada-lang_8c.html#ae9a1f2e16ad116a02636b91afd809c4b">ada_array_arity</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr));
<a name="l01862"></a>01862 
<a name="l01863"></a>01863       <span class="keywordflow">if</span> (elt_type == NULL || arity == 0)
<a name="l01864"></a>01864         <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr));
<a name="l01865"></a>01865 
<a name="l01866"></a>01866       descriptor = desc_bounds (arr);
<a name="l01867"></a>01867       <span class="keywordflow">if</span> (<a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (descriptor) == 0)
<a name="l01868"></a>01868         <span class="keywordflow">return</span> NULL;
<a name="l01869"></a>01869       <span class="keywordflow">while</span> (arity &gt; 0)
<a name="l01870"></a>01870         {
<a name="l01871"></a>01871           <span class="keyword">struct </span>type *range_type = <a class="code" href="gdbtypes_8c.html#a2e8f72ee412f83ecd89f47068fda9634">alloc_type_copy</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr));
<a name="l01872"></a>01872           <span class="keyword">struct </span>type *array_type = <a class="code" href="gdbtypes_8c.html#a2e8f72ee412f83ecd89f47068fda9634">alloc_type_copy</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr));
<a name="l01873"></a>01873           <span class="keyword">struct </span>value *low = desc_one_bound (descriptor, arity, 0);
<a name="l01874"></a>01874           <span class="keyword">struct </span>value *high = desc_one_bound (descriptor, arity, 1);
<a name="l01875"></a>01875 
<a name="l01876"></a>01876           arity -= 1;
<a name="l01877"></a>01877           <a class="code" href="gdbtypes_8c.html#ab0885fdae181c47ff3f958bcba70b82d">create_range_type</a> (range_type, <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (low),
<a name="l01878"></a>01878                              <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (<a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (low)),
<a name="l01879"></a>01879                              <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (<a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (high)));
<a name="l01880"></a>01880           elt_type = <a class="code" href="gdbtypes_8c.html#a779bbebb8202264a73344b49b22d774e">create_array_type</a> (array_type, elt_type, range_type);
<a name="l01881"></a>01881 
<a name="l01882"></a>01882           <span class="keywordflow">if</span> (ada_is_unconstrained_packed_array_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr)))
<a name="l01883"></a>01883             {
<a name="l01884"></a>01884               <span class="comment">/* We need to store the element packed bitsize, as well as</span>
<a name="l01885"></a>01885 <span class="comment">                 recompute the array size, because it was previously</span>
<a name="l01886"></a>01886 <span class="comment">                 computed based on the unpacked element size.  */</span>
<a name="l01887"></a>01887               <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> lo = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (low);
<a name="l01888"></a>01888               <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> hi = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (high);
<a name="l01889"></a>01889 
<a name="l01890"></a>01890               <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (elt_type, 0) =
<a name="l01891"></a>01891                 decode_packed_array_bitsize (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr));
<a name="l01892"></a>01892               <span class="comment">/* If the array has no element, then the size is already</span>
<a name="l01893"></a>01893 <span class="comment">                 zero, and does not need to be recomputed.  */</span>
<a name="l01894"></a>01894               <span class="keywordflow">if</span> (lo &lt; hi)
<a name="l01895"></a>01895                 {
<a name="l01896"></a>01896                   <span class="keywordtype">int</span> array_bitsize =
<a name="l01897"></a>01897                         (hi - lo + 1) * <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (elt_type, 0);
<a name="l01898"></a>01898 
<a name="l01899"></a>01899                   <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (array_type) = (array_bitsize + 7) / 8;
<a name="l01900"></a>01900                 }
<a name="l01901"></a>01901             }
<a name="l01902"></a>01902         }
<a name="l01903"></a>01903 
<a name="l01904"></a>01904       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (elt_type);
<a name="l01905"></a>01905     }
<a name="l01906"></a>01906 }
<a name="l01907"></a>01907 
<a name="l01908"></a>01908 <span class="comment">/* If ARR does not represent an array, returns ARR unchanged.</span>
<a name="l01909"></a>01909 <span class="comment">   Otherwise, returns either a standard GDB array with bounds set</span>
<a name="l01910"></a>01910 <span class="comment">   appropriately or, if ARR is a non-null fat pointer, a pointer to a standard</span>
<a name="l01911"></a>01911 <span class="comment">   GDB array.  Returns NULL if ARR is a null fat pointer.  */</span>
<a name="l01912"></a>01912 
<a name="l01913"></a>01913 <span class="keyword">struct </span>value *
<a name="l01914"></a><a class="code" href="ada-lang_8h.html#abab060b36f60ea538fd693d5e535eabb">01914</a> <a class="code" href="ada-lang_8c.html#ae180af59d7a123a3aefc23883acb77d7">ada_coerce_to_simple_array_ptr</a> (<span class="keyword">struct</span> value *arr)
<a name="l01915"></a>01915 {
<a name="l01916"></a>01916   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr)))
<a name="l01917"></a>01917     {
<a name="l01918"></a>01918       <span class="keyword">struct </span>type *arrType = <a class="code" href="ada-lang_8c.html#a7a98282573c2d74e48913babce683aa0">ada_type_of_array</a> (arr, 1);
<a name="l01919"></a>01919 
<a name="l01920"></a>01920       <span class="keywordflow">if</span> (arrType == NULL)
<a name="l01921"></a>01921         <span class="keywordflow">return</span> NULL;
<a name="l01922"></a>01922       <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (arrType, <a class="code" href="value_8c.html#abe2b4f6342cfefdbb63666b6bcba636b">value_copy</a> (desc_data (arr)));
<a name="l01923"></a>01923     }
<a name="l01924"></a>01924   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr)))
<a name="l01925"></a>01925     <span class="keywordflow">return</span> decode_constrained_packed_array (arr);
<a name="l01926"></a>01926   <span class="keywordflow">else</span>
<a name="l01927"></a>01927     <span class="keywordflow">return</span> arr;
<a name="l01928"></a>01928 }
<a name="l01929"></a>01929 
<a name="l01930"></a>01930 <span class="comment">/* If ARR does not represent an array, returns ARR unchanged.</span>
<a name="l01931"></a>01931 <span class="comment">   Otherwise, returns a standard GDB array describing ARR (which may</span>
<a name="l01932"></a>01932 <span class="comment">   be ARR itself if it already is in the proper form).  */</span>
<a name="l01933"></a>01933 
<a name="l01934"></a>01934 <span class="keyword">struct </span>value *
<a name="l01935"></a><a class="code" href="ada-lang_8h.html#af913c588af21f3cc010509de16d392a6">01935</a> <a class="code" href="ada-lang_8c.html#a184966871049f553a895f96f7590884a">ada_coerce_to_simple_array</a> (<span class="keyword">struct</span> value *arr)
<a name="l01936"></a>01936 {
<a name="l01937"></a>01937   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr)))
<a name="l01938"></a>01938     {
<a name="l01939"></a>01939       <span class="keyword">struct </span>value *arrVal = <a class="code" href="ada-lang_8c.html#ae180af59d7a123a3aefc23883acb77d7">ada_coerce_to_simple_array_ptr</a> (arr);
<a name="l01940"></a>01940 
<a name="l01941"></a>01941       <span class="keywordflow">if</span> (arrVal == NULL)
<a name="l01942"></a>01942         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Bounds unavailable for null array pointer.&quot;</span>));
<a name="l01943"></a>01943       check_size (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arrVal)));
<a name="l01944"></a>01944       <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (arrVal);
<a name="l01945"></a>01945     }
<a name="l01946"></a>01946   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr)))
<a name="l01947"></a>01947     <span class="keywordflow">return</span> decode_constrained_packed_array (arr);
<a name="l01948"></a>01948   <span class="keywordflow">else</span>
<a name="l01949"></a>01949     <span class="keywordflow">return</span> arr;
<a name="l01950"></a>01950 }
<a name="l01951"></a>01951 
<a name="l01952"></a>01952 <span class="comment">/* If TYPE represents a GNAT array type, return it translated to an</span>
<a name="l01953"></a>01953 <span class="comment">   ordinary GDB array type (possibly with BITSIZE fields indicating</span>
<a name="l01954"></a>01954 <span class="comment">   packing).  For other types, is the identity.  */</span>
<a name="l01955"></a>01955 
<a name="l01956"></a>01956 <span class="keyword">struct </span>type *
<a name="l01957"></a><a class="code" href="ada-lang_8h.html#a4ce090df1b8e377e57d236d26b5205a5">01957</a> <a class="code" href="ada-lang_8c.html#a08af5f804b36a05cc3a11fe364b5b57a">ada_coerce_to_simple_array_type</a> (<span class="keyword">struct</span> type *type)
<a name="l01958"></a>01958 {
<a name="l01959"></a>01959   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (type))
<a name="l01960"></a>01960     <span class="keywordflow">return</span> decode_constrained_packed_array_type (type);
<a name="l01961"></a>01961 
<a name="l01962"></a>01962   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (type))
<a name="l01963"></a>01963     <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (desc_data_target_type (type));
<a name="l01964"></a>01964 
<a name="l01965"></a>01965   <span class="keywordflow">return</span> type;
<a name="l01966"></a>01966 }
<a name="l01967"></a>01967 
<a name="l01968"></a>01968 <span class="comment">/* Non-zero iff TYPE represents a standard GNAT packed-array type.  */</span>
<a name="l01969"></a>01969 
<a name="l01970"></a>01970 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01971"></a>01971 ada_is_packed_array_type  (<span class="keyword">struct</span> type *type)
<a name="l01972"></a>01972 {
<a name="l01973"></a>01973   <span class="keywordflow">if</span> (type == NULL)
<a name="l01974"></a>01974     <span class="keywordflow">return</span> 0;
<a name="l01975"></a>01975   type = desc_base_type (type);
<a name="l01976"></a>01976   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l01977"></a>01977   <span class="keywordflow">return</span>
<a name="l01978"></a>01978     <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type) != NULL
<a name="l01979"></a>01979     &amp;&amp; <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (<a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type), <span class="stringliteral">&quot;___XP&quot;</span>) != NULL;
<a name="l01980"></a>01980 }
<a name="l01981"></a>01981 
<a name="l01982"></a>01982 <span class="comment">/* Non-zero iff TYPE represents a standard GNAT constrained</span>
<a name="l01983"></a>01983 <span class="comment">   packed-array type.  */</span>
<a name="l01984"></a>01984 
<a name="l01985"></a>01985 <span class="keywordtype">int</span>
<a name="l01986"></a><a class="code" href="ada-lang_8h.html#ab4fa2974ee8a0b63da5e27cfe2b1fb76">01986</a> <a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (<span class="keyword">struct</span> type *type)
<a name="l01987"></a>01987 {
<a name="l01988"></a>01988   <span class="keywordflow">return</span> ada_is_packed_array_type (type)
<a name="l01989"></a>01989     &amp;&amp; !<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (type);
<a name="l01990"></a>01990 }
<a name="l01991"></a>01991 
<a name="l01992"></a>01992 <span class="comment">/* Non-zero iff TYPE represents an array descriptor for a</span>
<a name="l01993"></a>01993 <span class="comment">   unconstrained packed-array type.  */</span>
<a name="l01994"></a>01994 
<a name="l01995"></a>01995 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01996"></a>01996 ada_is_unconstrained_packed_array_type (<span class="keyword">struct</span> type *type)
<a name="l01997"></a>01997 {
<a name="l01998"></a>01998   <span class="keywordflow">return</span> ada_is_packed_array_type (type)
<a name="l01999"></a>01999     &amp;&amp; <a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (type);
<a name="l02000"></a>02000 }
<a name="l02001"></a>02001 
<a name="l02002"></a>02002 <span class="comment">/* Given that TYPE encodes a packed array type (constrained or unconstrained),</span>
<a name="l02003"></a>02003 <span class="comment">   return the size of its elements in bits.  */</span>
<a name="l02004"></a>02004 
<a name="l02005"></a>02005 <span class="keyword">static</span> <span class="keywordtype">long</span>
<a name="l02006"></a>02006 decode_packed_array_bitsize (<span class="keyword">struct</span> type *type)
<a name="l02007"></a>02007 {
<a name="l02008"></a>02008   <span class="keyword">const</span> <span class="keywordtype">char</span> *raw_name;
<a name="l02009"></a>02009   <span class="keyword">const</span> <span class="keywordtype">char</span> *tail;
<a name="l02010"></a>02010   <span class="keywordtype">long</span> <a class="code" href="arm-tdep_8c.html#a6d53921cd0f216408c4aed2806a0cb1f">bits</a>;
<a name="l02011"></a>02011 
<a name="l02012"></a>02012   <span class="comment">/* Access to arrays implemented as fat pointers are encoded as a typedef</span>
<a name="l02013"></a>02013 <span class="comment">     of the fat pointer type.  We need the name of the fat pointer type</span>
<a name="l02014"></a>02014 <span class="comment">     to do the decoding, so strip the typedef layer.  */</span>
<a name="l02015"></a>02015   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>)
<a name="l02016"></a>02016     type = ada_typedef_target_type (type);
<a name="l02017"></a>02017 
<a name="l02018"></a>02018   raw_name = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type));
<a name="l02019"></a>02019   <span class="keywordflow">if</span> (!raw_name)
<a name="l02020"></a>02020     raw_name = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (desc_base_type (type));
<a name="l02021"></a>02021 
<a name="l02022"></a>02022   <span class="keywordflow">if</span> (!raw_name)
<a name="l02023"></a>02023     <span class="keywordflow">return</span> 0;
<a name="l02024"></a>02024 
<a name="l02025"></a>02025   tail = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (raw_name, <span class="stringliteral">&quot;___XP&quot;</span>);
<a name="l02026"></a>02026   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (tail != NULL);
<a name="l02027"></a>02027 
<a name="l02028"></a>02028   <span class="keywordflow">if</span> (sscanf (tail + <span class="keyword">sizeof</span> (<span class="stringliteral">&quot;___XP&quot;</span>) - 1, <span class="stringliteral">&quot;%ld&quot;</span>, &amp;bits) != 1)
<a name="l02029"></a>02029     {
<a name="l02030"></a>02030       lim_warning
<a name="l02031"></a>02031         (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;could not understand bit size information on packed array&quot;</span>));
<a name="l02032"></a>02032       <span class="keywordflow">return</span> 0;
<a name="l02033"></a>02033     }
<a name="l02034"></a>02034 
<a name="l02035"></a>02035   <span class="keywordflow">return</span> <a class="code" href="arm-tdep_8c.html#a6d53921cd0f216408c4aed2806a0cb1f">bits</a>;
<a name="l02036"></a>02036 }
<a name="l02037"></a>02037 
<a name="l02038"></a>02038 <span class="comment">/* Given that TYPE is a standard GDB array type with all bounds filled</span>
<a name="l02039"></a>02039 <span class="comment">   in, and that the element size of its ultimate scalar constituents</span>
<a name="l02040"></a>02040 <span class="comment">   (that is, either its elements, or, if it is an array of arrays, its</span>
<a name="l02041"></a>02041 <span class="comment">   elements&#39; elements, etc.) is *ELT_BITS, return an identical type,</span>
<a name="l02042"></a>02042 <span class="comment">   but with the bit sizes of its elements (and those of any</span>
<a name="l02043"></a>02043 <span class="comment">   constituent arrays) recorded in the BITSIZE components of its</span>
<a name="l02044"></a>02044 <span class="comment">   TYPE_FIELD_BITSIZE values, and with *ELT_BITS set to its total size</span>
<a name="l02045"></a>02045 <span class="comment">   in bits.  */</span>
<a name="l02046"></a>02046 
<a name="l02047"></a>02047 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l02048"></a>02048 constrained_packed_array_type (<span class="keyword">struct</span> type *type, <span class="keywordtype">long</span> *elt_bits)
<a name="l02049"></a>02049 {
<a name="l02050"></a>02050   <span class="keyword">struct </span>type *new_elt_type;
<a name="l02051"></a>02051   <span class="keyword">struct </span>type *new_type;
<a name="l02052"></a>02052   <span class="keyword">struct </span>type *index_type_desc;
<a name="l02053"></a>02053   <span class="keyword">struct </span>type *index_type;
<a name="l02054"></a>02054   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> low_bound, high_bound;
<a name="l02055"></a>02055 
<a name="l02056"></a>02056   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l02057"></a>02057   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l02058"></a>02058     <span class="keywordflow">return</span> type;
<a name="l02059"></a>02059 
<a name="l02060"></a>02060   index_type_desc = <a class="code" href="ada-lang_8c.html#ade263e735047904b7eabe725cd6cc2f9">ada_find_parallel_type</a> (type, <span class="stringliteral">&quot;___XA&quot;</span>);
<a name="l02061"></a>02061   <span class="keywordflow">if</span> (index_type_desc)
<a name="l02062"></a>02062     index_type = to_fixed_range_type (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (index_type_desc, 0),
<a name="l02063"></a>02063                                       NULL);
<a name="l02064"></a>02064   <span class="keywordflow">else</span>
<a name="l02065"></a>02065     index_type = <a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (type);
<a name="l02066"></a>02066 
<a name="l02067"></a>02067   new_type = <a class="code" href="gdbtypes_8c.html#a2e8f72ee412f83ecd89f47068fda9634">alloc_type_copy</a> (type);
<a name="l02068"></a>02068   new_elt_type =
<a name="l02069"></a>02069     constrained_packed_array_type (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)),
<a name="l02070"></a>02070                                    elt_bits);
<a name="l02071"></a>02071   <a class="code" href="gdbtypes_8c.html#a779bbebb8202264a73344b49b22d774e">create_array_type</a> (new_type, new_elt_type, index_type);
<a name="l02072"></a>02072   <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (new_type, 0) = *elt_bits;
<a name="l02073"></a>02073   <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (new_type) = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type);
<a name="l02074"></a>02074 
<a name="l02075"></a>02075   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#a6b7f508cb2cdaf4d8f53494d9239b163">get_discrete_bounds</a> (index_type, &amp;low_bound, &amp;high_bound) &lt; 0)
<a name="l02076"></a>02076     low_bound = high_bound = 0;
<a name="l02077"></a>02077   <span class="keywordflow">if</span> (high_bound &lt; low_bound)
<a name="l02078"></a>02078     *elt_bits = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (new_type) = 0;
<a name="l02079"></a>02079   <span class="keywordflow">else</span>
<a name="l02080"></a>02080     {
<a name="l02081"></a>02081       *elt_bits *= (high_bound - low_bound + 1);
<a name="l02082"></a>02082       <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (new_type) =
<a name="l02083"></a>02083         (*elt_bits + <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - 1) / <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02084"></a>02084     }
<a name="l02085"></a>02085 
<a name="l02086"></a>02086   <a class="code" href="gdbtypes_8h.html#a82cbfd363fdf782853ce90946f81c355">TYPE_FIXED_INSTANCE</a> (new_type) = 1;
<a name="l02087"></a>02087   <span class="keywordflow">return</span> new_type;
<a name="l02088"></a>02088 }
<a name="l02089"></a>02089 
<a name="l02090"></a>02090 <span class="comment">/* The array type encoded by TYPE, where</span>
<a name="l02091"></a>02091 <span class="comment">   ada_is_constrained_packed_array_type (TYPE).  */</span>
<a name="l02092"></a>02092 
<a name="l02093"></a>02093 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l02094"></a>02094 decode_constrained_packed_array_type (<span class="keyword">struct</span> type *type)
<a name="l02095"></a>02095 {
<a name="l02096"></a>02096   <span class="keyword">const</span> <span class="keywordtype">char</span> *raw_name = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type));
<a name="l02097"></a>02097   <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l02098"></a>02098   <span class="keyword">const</span> <span class="keywordtype">char</span> *tail;
<a name="l02099"></a>02099   <span class="keyword">struct </span>type *shadow_type;
<a name="l02100"></a>02100   <span class="keywordtype">long</span> <a class="code" href="arm-tdep_8c.html#a6d53921cd0f216408c4aed2806a0cb1f">bits</a>;
<a name="l02101"></a>02101 
<a name="l02102"></a>02102   <span class="keywordflow">if</span> (!raw_name)
<a name="l02103"></a>02103     raw_name = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (desc_base_type (type));
<a name="l02104"></a>02104 
<a name="l02105"></a>02105   <span class="keywordflow">if</span> (!raw_name)
<a name="l02106"></a>02106     <span class="keywordflow">return</span> NULL;
<a name="l02107"></a>02107 
<a name="l02108"></a>02108   name = (<span class="keywordtype">char</span> *) alloca (strlen (raw_name) + 1);
<a name="l02109"></a>02109   tail = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (raw_name, <span class="stringliteral">&quot;___XP&quot;</span>);
<a name="l02110"></a>02110   type = desc_base_type (type);
<a name="l02111"></a>02111 
<a name="l02112"></a>02112   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (name, raw_name, tail - raw_name);
<a name="l02113"></a>02113   name[tail - raw_name] = <span class="charliteral">&#39;\000&#39;</span>;
<a name="l02114"></a>02114 
<a name="l02115"></a>02115   shadow_type = ada_find_parallel_type_with_name (type, name);
<a name="l02116"></a>02116 
<a name="l02117"></a>02117   <span class="keywordflow">if</span> (shadow_type == NULL)
<a name="l02118"></a>02118     {
<a name="l02119"></a>02119       lim_warning (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;could not find bounds information on packed array&quot;</span>));
<a name="l02120"></a>02120       <span class="keywordflow">return</span> NULL;
<a name="l02121"></a>02121     }
<a name="l02122"></a>02122   <a class="code" href="gdbtypes_8h.html#ae2f9348c644babaa9038b4dc18bffaac">CHECK_TYPEDEF</a> (shadow_type);
<a name="l02123"></a>02123 
<a name="l02124"></a>02124   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (shadow_type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l02125"></a>02125     {
<a name="l02126"></a>02126       lim_warning (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;could not understand bounds &quot;</span>
<a name="l02127"></a>02127                      <span class="stringliteral">&quot;information on packed array&quot;</span>));
<a name="l02128"></a>02128       <span class="keywordflow">return</span> NULL;
<a name="l02129"></a>02129     }
<a name="l02130"></a>02130 
<a name="l02131"></a>02131   bits = decode_packed_array_bitsize (type);
<a name="l02132"></a>02132   <span class="keywordflow">return</span> constrained_packed_array_type (shadow_type, &amp;bits);
<a name="l02133"></a>02133 }
<a name="l02134"></a>02134 
<a name="l02135"></a>02135 <span class="comment">/* Given that ARR is a struct value *indicating a GNAT constrained packed</span>
<a name="l02136"></a>02136 <span class="comment">   array, returns a simple array that denotes that array.  Its type is a</span>
<a name="l02137"></a>02137 <span class="comment">   standard GDB array type except that the BITSIZEs of the array</span>
<a name="l02138"></a>02138 <span class="comment">   target types are set to the number of bits in each element, and the</span>
<a name="l02139"></a>02139 <span class="comment">   type length is set appropriately.  */</span>
<a name="l02140"></a>02140 
<a name="l02141"></a>02141 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l02142"></a>02142 decode_constrained_packed_array (<span class="keyword">struct</span> value *arr)
<a name="l02143"></a>02143 {
<a name="l02144"></a>02144   <span class="keyword">struct </span>type *type;
<a name="l02145"></a>02145 
<a name="l02146"></a>02146   arr = ada_coerce_ref (arr);
<a name="l02147"></a>02147 
<a name="l02148"></a>02148   <span class="comment">/* If our value is a pointer, then dererence it.  Make sure that</span>
<a name="l02149"></a>02149 <span class="comment">     this operation does not cause the target type to be fixed, as</span>
<a name="l02150"></a>02150 <span class="comment">     this would indirectly cause this array to be decoded.  The rest</span>
<a name="l02151"></a>02151 <span class="comment">     of the routine assumes that the array hasn&#39;t been decoded yet,</span>
<a name="l02152"></a>02152 <span class="comment">     so we use the basic &quot;value_ind&quot; routine to perform the dereferencing,</span>
<a name="l02153"></a>02153 <span class="comment">     as opposed to using &quot;ada_value_ind&quot;.  */</span>
<a name="l02154"></a>02154   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr))) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l02155"></a>02155     arr = <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (arr);
<a name="l02156"></a>02156 
<a name="l02157"></a>02157   type = decode_constrained_packed_array_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr));
<a name="l02158"></a>02158   <span class="keywordflow">if</span> (type == NULL)
<a name="l02159"></a>02159     {
<a name="l02160"></a>02160       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;can&#39;t unpack array&quot;</span>));
<a name="l02161"></a>02161       <span class="keywordflow">return</span> NULL;
<a name="l02162"></a>02162     }
<a name="l02163"></a>02163 
<a name="l02164"></a>02164   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#afb14c978ec22423f831b98d7ac768382">gdbarch_bits_big_endian</a> (<a class="code" href="gdbtypes_8c.html#a84ca61a6d58c2bd2c7dcedf19d56a39d">get_type_arch</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr)))
<a name="l02165"></a>02165       &amp;&amp; <a class="code" href="ada-lang_8c.html#a3f7ddcd366cd67c24fb3c7b2431abeb9">ada_is_modular_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr)))
<a name="l02166"></a>02166     {
<a name="l02167"></a>02167        <span class="comment">/* This is a (right-justified) modular type representing a packed</span>
<a name="l02168"></a>02168 <span class="comment">         array with no wrapper.  In order to interpret the value through</span>
<a name="l02169"></a>02169 <span class="comment">         the (left-justified) packed array type we just built, we must</span>
<a name="l02170"></a>02170 <span class="comment">         first left-justify it.  */</span>
<a name="l02171"></a>02171       <span class="keywordtype">int</span> bit_size, bit_pos;
<a name="l02172"></a>02172       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> mod;
<a name="l02173"></a>02173 
<a name="l02174"></a>02174       mod = <a class="code" href="ada-lang_8c.html#a357116c53325c29524dfd0ccff308754">ada_modulus</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr)) - 1;
<a name="l02175"></a>02175       bit_size = 0;
<a name="l02176"></a>02176       <span class="keywordflow">while</span> (mod &gt; 0)
<a name="l02177"></a>02177         {
<a name="l02178"></a>02178           bit_size += 1;
<a name="l02179"></a>02179           mod &gt;&gt;= 1;
<a name="l02180"></a>02180         }
<a name="l02181"></a>02181       bit_pos = <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> * <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr)) - bit_size;
<a name="l02182"></a>02182       arr = <a class="code" href="ada-lang_8c.html#a3f0830ba146bedfa9564f572fa61042c">ada_value_primitive_packed_val</a> (arr, NULL,
<a name="l02183"></a>02183                                             bit_pos / <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>,
<a name="l02184"></a>02184                                             bit_pos % <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>,
<a name="l02185"></a>02185                                             bit_size,
<a name="l02186"></a>02186                                             type);
<a name="l02187"></a>02187     }
<a name="l02188"></a>02188 
<a name="l02189"></a>02189   <span class="keywordflow">return</span> coerce_unspec_val_to_type (arr, type);
<a name="l02190"></a>02190 }
<a name="l02191"></a>02191 
<a name="l02192"></a>02192 
<a name="l02193"></a>02193 <span class="comment">/* The value of the element of packed array ARR at the ARITY indices</span>
<a name="l02194"></a>02194 <span class="comment">   given in IND.   ARR must be a simple array.  */</span>
<a name="l02195"></a>02195 
<a name="l02196"></a>02196 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l02197"></a>02197 value_subscript_packed (<span class="keyword">struct</span> value *arr, <span class="keywordtype">int</span> arity, <span class="keyword">struct</span> value **ind)
<a name="l02198"></a>02198 {
<a name="l02199"></a>02199   <span class="keywordtype">int</span> i;
<a name="l02200"></a>02200   <span class="keywordtype">int</span> <a class="code" href="arm-tdep_8c.html#a6d53921cd0f216408c4aed2806a0cb1f">bits</a>, elt_off, bit_off;
<a name="l02201"></a>02201   <span class="keywordtype">long</span> elt_total_bit_offset;
<a name="l02202"></a>02202   <span class="keyword">struct </span>type *elt_type;
<a name="l02203"></a>02203   <span class="keyword">struct </span>value *v;
<a name="l02204"></a>02204 
<a name="l02205"></a>02205   bits = 0;
<a name="l02206"></a>02206   elt_total_bit_offset = 0;
<a name="l02207"></a>02207   elt_type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr));
<a name="l02208"></a>02208   <span class="keywordflow">for</span> (i = 0; i &lt; arity; i += 1)
<a name="l02209"></a>02209     {
<a name="l02210"></a>02210       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (elt_type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l02211"></a>02211           || <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (elt_type, 0) == 0)
<a name="l02212"></a>02212         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a>
<a name="l02213"></a>02213           (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;attempt to do packed indexing of &quot;</span>
<a name="l02214"></a>02214              <span class="stringliteral">&quot;something other than a packed array&quot;</span>));
<a name="l02215"></a>02215       <span class="keywordflow">else</span>
<a name="l02216"></a>02216         {
<a name="l02217"></a>02217           <span class="keyword">struct </span>type *range_type = <a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (elt_type);
<a name="l02218"></a>02218           <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> lowerbound, upperbound;
<a name="l02219"></a>02219           <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> idx;
<a name="l02220"></a>02220 
<a name="l02221"></a>02221           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#a6b7f508cb2cdaf4d8f53494d9239b163">get_discrete_bounds</a> (range_type, &amp;lowerbound, &amp;upperbound) &lt; 0)
<a name="l02222"></a>02222             {
<a name="l02223"></a>02223               lim_warning (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;don&#39;t know bounds of array&quot;</span>));
<a name="l02224"></a>02224               lowerbound = upperbound = 0;
<a name="l02225"></a>02225             }
<a name="l02226"></a>02226 
<a name="l02227"></a>02227           idx = pos_atr (ind[i]);
<a name="l02228"></a>02228           <span class="keywordflow">if</span> (idx &lt; lowerbound || idx &gt; upperbound)
<a name="l02229"></a>02229             lim_warning (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;packed array index %ld out of bounds&quot;</span>),
<a name="l02230"></a>02230                          (<span class="keywordtype">long</span>) idx);
<a name="l02231"></a>02231           bits = <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (elt_type, 0);
<a name="l02232"></a>02232           elt_total_bit_offset += (idx - lowerbound) * bits;
<a name="l02233"></a>02233           elt_type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (elt_type));
<a name="l02234"></a>02234         }
<a name="l02235"></a>02235     }
<a name="l02236"></a>02236   elt_off = elt_total_bit_offset / <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02237"></a>02237   bit_off = elt_total_bit_offset % <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02238"></a>02238 
<a name="l02239"></a>02239   v = <a class="code" href="ada-lang_8c.html#a3f0830ba146bedfa9564f572fa61042c">ada_value_primitive_packed_val</a> (arr, NULL, elt_off, bit_off,
<a name="l02240"></a>02240                                       bits, elt_type);
<a name="l02241"></a>02241   <span class="keywordflow">return</span> v;
<a name="l02242"></a>02242 }
<a name="l02243"></a>02243 
<a name="l02244"></a>02244 <span class="comment">/* Non-zero iff TYPE includes negative integer values.  */</span>
<a name="l02245"></a>02245 
<a name="l02246"></a>02246 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02247"></a>02247 has_negatives (<span class="keyword">struct</span> type *type)
<a name="l02248"></a>02248 {
<a name="l02249"></a>02249   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l02250"></a>02250     {
<a name="l02251"></a>02251     <span class="keywordflow">default</span>:
<a name="l02252"></a>02252       <span class="keywordflow">return</span> 0;
<a name="l02253"></a>02253     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>:
<a name="l02254"></a>02254       <span class="keywordflow">return</span> !<a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">TYPE_UNSIGNED</a> (type);
<a name="l02255"></a>02255     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>:
<a name="l02256"></a>02256       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a8a35064d1a955f191b0a63b03755689b">TYPE_LOW_BOUND</a> (type) &lt; 0;
<a name="l02257"></a>02257     }
<a name="l02258"></a>02258 }
<a name="l02259"></a>02259 
<a name="l02260"></a>02260 
<a name="l02261"></a>02261 <span class="comment">/* Create a new value of type TYPE from the contents of OBJ starting</span>
<a name="l02262"></a>02262 <span class="comment">   at byte OFFSET, and bit offset BIT_OFFSET within that byte,</span>
<a name="l02263"></a>02263 <span class="comment">   proceeding for BIT_SIZE bits.  If OBJ is an lval in memory, then</span>
<a name="l02264"></a>02264 <span class="comment">   assigning through the result will set the field fetched from.</span>
<a name="l02265"></a>02265 <span class="comment">   VALADDR is ignored unless OBJ is NULL, in which case,</span>
<a name="l02266"></a>02266 <span class="comment">   VALADDR+OFFSET must address the start of storage containing the </span>
<a name="l02267"></a>02267 <span class="comment">   packed value.  The value returned  in this case is never an lval.</span>
<a name="l02268"></a>02268 <span class="comment">   Assumes 0 &lt;= BIT_OFFSET &lt; HOST_CHAR_BIT.  */</span>
<a name="l02269"></a>02269 
<a name="l02270"></a>02270 <span class="keyword">struct </span>value *
<a name="l02271"></a><a class="code" href="ada-lang_8h.html#aeb53cc1485396c7044aab5944a41b388">02271</a> <a class="code" href="ada-lang_8c.html#a3f0830ba146bedfa9564f572fa61042c">ada_value_primitive_packed_val</a> (<span class="keyword">struct</span> value *obj, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valaddr,
<a name="l02272"></a>02272                                 <span class="keywordtype">long</span> offset, <span class="keywordtype">int</span> bit_offset, <span class="keywordtype">int</span> bit_size,
<a name="l02273"></a>02273                                 <span class="keyword">struct</span> type *type)
<a name="l02274"></a>02274 {
<a name="l02275"></a>02275   <span class="keyword">struct </span>value *v;
<a name="l02276"></a>02276   <span class="keywordtype">int</span> src,                      <span class="comment">/* Index into the source area */</span>
<a name="l02277"></a>02277     targ,                       <span class="comment">/* Index into the target area */</span>
<a name="l02278"></a>02278     srcBitsLeft,                <span class="comment">/* Number of source bits left to move */</span>
<a name="l02279"></a>02279     nsrc, ntarg,                <span class="comment">/* Number of source and target bytes */</span>
<a name="l02280"></a>02280     unusedLS,                   <span class="comment">/* Number of bits in next significant</span>
<a name="l02281"></a>02281 <span class="comment">                                   byte of source that are unused */</span>
<a name="l02282"></a>02282     accumSize;                  <span class="comment">/* Number of meaningful bits in accum */</span>
<a name="l02283"></a>02283   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *bytes;         <span class="comment">/* First byte containing data to unpack */</span>
<a name="l02284"></a>02284   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *unpacked;
<a name="l02285"></a>02285   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> accum;          <span class="comment">/* Staging area for bits being transferred */</span>
<a name="l02286"></a>02286   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> sign;
<a name="l02287"></a>02287   <span class="keywordtype">int</span> len = (bit_size + bit_offset + <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - 1) / 8;
<a name="l02288"></a>02288   <span class="comment">/* Transmit bytes from least to most significant; delta is the direction</span>
<a name="l02289"></a>02289 <span class="comment">     the indices move.  */</span>
<a name="l02290"></a>02290   <span class="keywordtype">int</span> delta = <a class="code" href="gdbarch_8c.html#afb14c978ec22423f831b98d7ac768382">gdbarch_bits_big_endian</a> (<a class="code" href="gdbtypes_8c.html#a84ca61a6d58c2bd2c7dcedf19d56a39d">get_type_arch</a> (type)) ? -1 : 1;
<a name="l02291"></a>02291 
<a name="l02292"></a>02292   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l02293"></a>02293 
<a name="l02294"></a>02294   <span class="keywordflow">if</span> (obj == NULL)
<a name="l02295"></a>02295     {
<a name="l02296"></a>02296       v = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (type);
<a name="l02297"></a>02297       bytes = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (valaddr + offset);
<a name="l02298"></a>02298     }
<a name="l02299"></a>02299   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (obj) == <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a> &amp;&amp; <a class="code" href="value_8c.html#aa60bc8ecf77867a2d16bec57a4ccf983">value_lazy</a> (obj))
<a name="l02300"></a>02300     {
<a name="l02301"></a>02301       v = <a class="code" href="valops_8c.html#aed5411e37c248ed2abd959ddae4e9d34">value_at</a> (type, <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (obj));
<a name="l02302"></a>02302       bytes = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) alloca (len);
<a name="l02303"></a>02303       <a class="code" href="corefile_8c.html#a5e0189c6f21f1c9321b379877183b819">read_memory</a> (<a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (v) + offset, bytes, len);
<a name="l02304"></a>02304     }
<a name="l02305"></a>02305   <span class="keywordflow">else</span>
<a name="l02306"></a>02306     {
<a name="l02307"></a>02307       v = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (type);
<a name="l02308"></a>02308       bytes = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (obj) + <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l02309"></a>02309     }
<a name="l02310"></a>02310 
<a name="l02311"></a>02311   <span class="keywordflow">if</span> (obj != NULL)
<a name="l02312"></a>02312     {
<a name="l02313"></a>02313       <span class="keywordtype">long</span> new_offset = <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l02314"></a>02314 
<a name="l02315"></a>02315       <a class="code" href="value_8c.html#a3b68f85fbdfad03a038292fef7520e53">set_value_component_location</a> (v, obj);
<a name="l02316"></a>02316       <a class="code" href="value_8c.html#a21e0ad85da358983672e7b0420686067">set_value_bitpos</a> (v, bit_offset + <a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (obj));
<a name="l02317"></a>02317       <a class="code" href="value_8c.html#a81ff3b095a88c76df6444a8394e72664">set_value_bitsize</a> (v, bit_size);
<a name="l02318"></a>02318       <span class="keywordflow">if</span> (<a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (v) &gt;= <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>)
<a name="l02319"></a>02319         {
<a name="l02320"></a>02320           ++new_offset;
<a name="l02321"></a>02321           <a class="code" href="value_8c.html#a21e0ad85da358983672e7b0420686067">set_value_bitpos</a> (v, <a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (v) - <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>);
<a name="l02322"></a>02322         }
<a name="l02323"></a>02323       <a class="code" href="value_8c.html#a3d475a6b1e01fde10fa68ed0d666067e">set_value_offset</a> (v, new_offset);
<a name="l02324"></a>02324 
<a name="l02325"></a>02325       <span class="comment">/* Also set the parent value.  This is needed when trying to</span>
<a name="l02326"></a>02326 <span class="comment">         assign a new value (in inferior memory).  */</span>
<a name="l02327"></a>02327       <a class="code" href="value_8c.html#a594b083b7cc11477ddfd3eb57a9a136b">set_value_parent</a> (v, obj);
<a name="l02328"></a>02328     }
<a name="l02329"></a>02329   <span class="keywordflow">else</span>
<a name="l02330"></a>02330     <a class="code" href="value_8c.html#a81ff3b095a88c76df6444a8394e72664">set_value_bitsize</a> (v, bit_size);
<a name="l02331"></a>02331   unpacked = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (v);
<a name="l02332"></a>02332 
<a name="l02333"></a>02333   srcBitsLeft = bit_size;
<a name="l02334"></a>02334   nsrc = <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l02335"></a>02335   ntarg = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type);
<a name="l02336"></a>02336   sign = 0;
<a name="l02337"></a>02337   <span class="keywordflow">if</span> (bit_size == 0)
<a name="l02338"></a>02338     {
<a name="l02339"></a>02339       <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (unpacked, 0, <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type));
<a name="l02340"></a>02340       <span class="keywordflow">return</span> v;
<a name="l02341"></a>02341     }
<a name="l02342"></a>02342   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#afb14c978ec22423f831b98d7ac768382">gdbarch_bits_big_endian</a> (<a class="code" href="gdbtypes_8c.html#a84ca61a6d58c2bd2c7dcedf19d56a39d">get_type_arch</a> (type)))
<a name="l02343"></a>02343     {
<a name="l02344"></a>02344       src = len - 1;
<a name="l02345"></a>02345       <span class="keywordflow">if</span> (has_negatives (type)
<a name="l02346"></a>02346           &amp;&amp; ((bytes[0] &lt;&lt; bit_offset) &amp; (1 &lt;&lt; (<a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - 1))))
<a name="l02347"></a>02347         sign = ~0;
<a name="l02348"></a>02348 
<a name="l02349"></a>02349       unusedLS =
<a name="l02350"></a>02350         (<a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - (bit_size + bit_offset) % <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>)
<a name="l02351"></a>02351         % <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02352"></a>02352 
<a name="l02353"></a>02353       <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l02354"></a>02354         {
<a name="l02355"></a>02355         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>:
<a name="l02356"></a>02356         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>:
<a name="l02357"></a>02357         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l02358"></a>02358           <span class="comment">/* Non-scalar values must be aligned at a byte boundary...  */</span>
<a name="l02359"></a>02359           accumSize =
<a name="l02360"></a>02360             (<a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - bit_size % <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>) % <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02361"></a>02361           <span class="comment">/* ... And are placed at the beginning (most-significant) bytes</span>
<a name="l02362"></a>02362 <span class="comment">             of the target.  */</span>
<a name="l02363"></a>02363           targ = (bit_size + <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - 1) / <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - 1;
<a name="l02364"></a>02364           ntarg = targ + 1;
<a name="l02365"></a>02365           <span class="keywordflow">break</span>;
<a name="l02366"></a>02366         <span class="keywordflow">default</span>:
<a name="l02367"></a>02367           accumSize = 0;
<a name="l02368"></a>02368           targ = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) - 1;
<a name="l02369"></a>02369           <span class="keywordflow">break</span>;
<a name="l02370"></a>02370         }
<a name="l02371"></a>02371     }
<a name="l02372"></a>02372   <span class="keywordflow">else</span>
<a name="l02373"></a>02373     {
<a name="l02374"></a>02374       <span class="keywordtype">int</span> sign_bit_offset = (bit_size + bit_offset - 1) % 8;
<a name="l02375"></a>02375 
<a name="l02376"></a>02376       src = targ = 0;
<a name="l02377"></a>02377       unusedLS = bit_offset;
<a name="l02378"></a>02378       accumSize = 0;
<a name="l02379"></a>02379 
<a name="l02380"></a>02380       <span class="keywordflow">if</span> (has_negatives (type) &amp;&amp; (bytes[len - 1] &amp; (1 &lt;&lt; sign_bit_offset)))
<a name="l02381"></a>02381         sign = ~0;
<a name="l02382"></a>02382     }
<a name="l02383"></a>02383 
<a name="l02384"></a>02384   accum = 0;
<a name="l02385"></a>02385   <span class="keywordflow">while</span> (nsrc &gt; 0)
<a name="l02386"></a>02386     {
<a name="l02387"></a>02387       <span class="comment">/* Mask for removing bits of the next source byte that are not</span>
<a name="l02388"></a>02388 <span class="comment">         part of the value.  */</span>
<a name="l02389"></a>02389       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unusedMSMask =
<a name="l02390"></a>02390         (1 &lt;&lt; (srcBitsLeft &gt;= <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> ? <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> : srcBitsLeft)) -
<a name="l02391"></a>02391         1;
<a name="l02392"></a>02392       <span class="comment">/* Sign-extend bits for this byte.  */</span>
<a name="l02393"></a>02393       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> signMask = sign &amp; ~unusedMSMask;
<a name="l02394"></a>02394 
<a name="l02395"></a>02395       accum |=
<a name="l02396"></a>02396         (((bytes[src] &gt;&gt; unusedLS) &amp; unusedMSMask) | signMask) &lt;&lt; accumSize;
<a name="l02397"></a>02397       accumSize += <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - unusedLS;
<a name="l02398"></a>02398       <span class="keywordflow">if</span> (accumSize &gt;= <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>)
<a name="l02399"></a>02399         {
<a name="l02400"></a>02400           unpacked[targ] = accum &amp; ~(~0<a class="code" href="ia64-tdep_8c.html#aa7fb549cf7936f8264053676ad5a5115aef31cc6fe9479955961311ee18ac205f">L</a> &lt;&lt; <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>);
<a name="l02401"></a>02401           accumSize -= <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02402"></a>02402           accum &gt;&gt;= <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02403"></a>02403           ntarg -= 1;
<a name="l02404"></a>02404           targ += delta;
<a name="l02405"></a>02405         }
<a name="l02406"></a>02406       srcBitsLeft -= <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - unusedLS;
<a name="l02407"></a>02407       unusedLS = 0;
<a name="l02408"></a>02408       nsrc -= 1;
<a name="l02409"></a>02409       src += delta;
<a name="l02410"></a>02410     }
<a name="l02411"></a>02411   <span class="keywordflow">while</span> (ntarg &gt; 0)
<a name="l02412"></a>02412     {
<a name="l02413"></a>02413       accum |= sign &lt;&lt; accumSize;
<a name="l02414"></a>02414       unpacked[targ] = accum &amp; ~(~0<a class="code" href="ia64-tdep_8c.html#aa7fb549cf7936f8264053676ad5a5115aef31cc6fe9479955961311ee18ac205f">L</a> &lt;&lt; <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>);
<a name="l02415"></a>02415       accumSize -= <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02416"></a>02416       accum &gt;&gt;= <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02417"></a>02417       ntarg -= 1;
<a name="l02418"></a>02418       targ += delta;
<a name="l02419"></a>02419     }
<a name="l02420"></a>02420 
<a name="l02421"></a>02421   <span class="keywordflow">return</span> v;
<a name="l02422"></a>02422 }
<a name="l02423"></a>02423 
<a name="l02424"></a>02424 <span class="comment">/* Move N bits from SOURCE, starting at bit offset SRC_OFFSET to</span>
<a name="l02425"></a>02425 <span class="comment">   TARGET, starting at bit offset TARG_OFFSET.  SOURCE and TARGET must</span>
<a name="l02426"></a>02426 <span class="comment">   not overlap.  */</span>
<a name="l02427"></a>02427 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02428"></a>02428 move_bits (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *target, <span class="keywordtype">int</span> targ_offset, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *source,
<a name="l02429"></a>02429            <span class="keywordtype">int</span> src_offset, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> bits_big_endian_p)
<a name="l02430"></a>02430 {
<a name="l02431"></a>02431   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> accum, mask;
<a name="l02432"></a>02432   <span class="keywordtype">int</span> accum_bits, chunk_size;
<a name="l02433"></a>02433 
<a name="l02434"></a>02434   target += targ_offset / <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02435"></a>02435   targ_offset %= <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02436"></a>02436   source += src_offset / <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02437"></a>02437   src_offset %= <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02438"></a>02438   <span class="keywordflow">if</span> (bits_big_endian_p)
<a name="l02439"></a>02439     {
<a name="l02440"></a>02440       accum = (<span class="keywordtype">unsigned</span> char) *source;
<a name="l02441"></a>02441       source += 1;
<a name="l02442"></a>02442       accum_bits = <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - src_offset;
<a name="l02443"></a>02443 
<a name="l02444"></a>02444       <span class="keywordflow">while</span> (n &gt; 0)
<a name="l02445"></a>02445         {
<a name="l02446"></a>02446           <span class="keywordtype">int</span> unused_right;
<a name="l02447"></a>02447 
<a name="l02448"></a>02448           accum = (accum &lt;&lt; <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>) + (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) *source;
<a name="l02449"></a>02449           accum_bits += <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02450"></a>02450           source += 1;
<a name="l02451"></a>02451           chunk_size = <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - targ_offset;
<a name="l02452"></a>02452           <span class="keywordflow">if</span> (chunk_size &gt; n)
<a name="l02453"></a>02453             chunk_size = n;
<a name="l02454"></a>02454           unused_right = <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - (chunk_size + targ_offset);
<a name="l02455"></a>02455           mask = ((1 &lt;&lt; chunk_size) - 1) &lt;&lt; unused_right;
<a name="l02456"></a>02456           *target =
<a name="l02457"></a>02457             (*target &amp; ~mask)
<a name="l02458"></a>02458             | ((accum &gt;&gt; (accum_bits - chunk_size - unused_right)) &amp; mask);
<a name="l02459"></a>02459           n -= chunk_size;
<a name="l02460"></a>02460           accum_bits -= chunk_size;
<a name="l02461"></a>02461           target += 1;
<a name="l02462"></a>02462           targ_offset = 0;
<a name="l02463"></a>02463         }
<a name="l02464"></a>02464     }
<a name="l02465"></a>02465   <span class="keywordflow">else</span>
<a name="l02466"></a>02466     {
<a name="l02467"></a>02467       accum = (<span class="keywordtype">unsigned</span> char) *source &gt;&gt; src_offset;
<a name="l02468"></a>02468       source += 1;
<a name="l02469"></a>02469       accum_bits = <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - src_offset;
<a name="l02470"></a>02470 
<a name="l02471"></a>02471       <span class="keywordflow">while</span> (n &gt; 0)
<a name="l02472"></a>02472         {
<a name="l02473"></a>02473           accum = accum + ((<span class="keywordtype">unsigned</span> char) *source &lt;&lt; accum_bits);
<a name="l02474"></a>02474           accum_bits += <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02475"></a>02475           source += 1;
<a name="l02476"></a>02476           chunk_size = <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - targ_offset;
<a name="l02477"></a>02477           <span class="keywordflow">if</span> (chunk_size &gt; n)
<a name="l02478"></a>02478             chunk_size = n;
<a name="l02479"></a>02479           mask = ((1 &lt;&lt; chunk_size) - 1) &lt;&lt; targ_offset;
<a name="l02480"></a>02480           *target = (*target &amp; ~mask) | ((accum &lt;&lt; targ_offset) &amp; mask);
<a name="l02481"></a>02481           n -= chunk_size;
<a name="l02482"></a>02482           accum_bits -= chunk_size;
<a name="l02483"></a>02483           accum &gt;&gt;= chunk_size;
<a name="l02484"></a>02484           target += 1;
<a name="l02485"></a>02485           targ_offset = 0;
<a name="l02486"></a>02486         }
<a name="l02487"></a>02487     }
<a name="l02488"></a>02488 }
<a name="l02489"></a>02489 
<a name="l02490"></a>02490 <span class="comment">/* Store the contents of FROMVAL into the location of TOVAL.</span>
<a name="l02491"></a>02491 <span class="comment">   Return a new value with the location of TOVAL and contents of</span>
<a name="l02492"></a>02492 <span class="comment">   FROMVAL.   Handles assignment into packed fields that have</span>
<a name="l02493"></a>02493 <span class="comment">   floating-point or non-scalar types.  */</span>
<a name="l02494"></a>02494 
<a name="l02495"></a>02495 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l02496"></a>02496 ada_value_assign (<span class="keyword">struct</span> value *toval, <span class="keyword">struct</span> value *fromval)
<a name="l02497"></a>02497 {
<a name="l02498"></a>02498   <span class="keyword">struct </span>type *type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (toval);
<a name="l02499"></a>02499   <span class="keywordtype">int</span> bits = <a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (toval);
<a name="l02500"></a>02500 
<a name="l02501"></a>02501   toval = ada_coerce_ref (toval);
<a name="l02502"></a>02502   fromval = ada_coerce_ref (fromval);
<a name="l02503"></a>02503 
<a name="l02504"></a>02504   <span class="keywordflow">if</span> (ada_is_direct_array_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (toval)))
<a name="l02505"></a>02505     toval = <a class="code" href="ada-lang_8c.html#a184966871049f553a895f96f7590884a">ada_coerce_to_simple_array</a> (toval);
<a name="l02506"></a>02506   <span class="keywordflow">if</span> (ada_is_direct_array_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (fromval)))
<a name="l02507"></a>02507     fromval = <a class="code" href="ada-lang_8c.html#a184966871049f553a895f96f7590884a">ada_coerce_to_simple_array</a> (fromval);
<a name="l02508"></a>02508 
<a name="l02509"></a>02509   <span class="keywordflow">if</span> (!<a class="code" href="value_8c.html#af38ad07ecbd1d8ae5a31ad793399d0ba">deprecated_value_modifiable</a> (toval))
<a name="l02510"></a>02510     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Left operand of assignment is not a modifiable lvalue.&quot;</span>));
<a name="l02511"></a>02511 
<a name="l02512"></a>02512   <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (toval) == <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>
<a name="l02513"></a>02513       &amp;&amp; bits &gt; 0
<a name="l02514"></a>02514       &amp;&amp; (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>
<a name="l02515"></a>02515           || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>))
<a name="l02516"></a>02516     {
<a name="l02517"></a>02517       <span class="keywordtype">int</span> len = (<a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (toval)
<a name="l02518"></a>02518                  + bits + <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> - 1) / <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l02519"></a>02519       <span class="keywordtype">int</span> from_size;
<a name="l02520"></a>02520       <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structbuffer.html">buffer</a> = alloca (len);
<a name="l02521"></a>02521       <span class="keyword">struct </span>value *val;
<a name="l02522"></a>02522       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> to_addr = <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (toval);
<a name="l02523"></a>02523 
<a name="l02524"></a>02524       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>)
<a name="l02525"></a>02525         fromval = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (type, fromval);
<a name="l02526"></a>02526 
<a name="l02527"></a>02527       <a class="code" href="corefile_8c.html#a5e0189c6f21f1c9321b379877183b819">read_memory</a> (to_addr, buffer, len);
<a name="l02528"></a>02528       from_size = <a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (fromval);
<a name="l02529"></a>02529       <span class="keywordflow">if</span> (from_size == 0)
<a name="l02530"></a>02530         from_size = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (fromval)) * TARGET_CHAR_BIT;
<a name="l02531"></a>02531       <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#afb14c978ec22423f831b98d7ac768382">gdbarch_bits_big_endian</a> (<a class="code" href="gdbtypes_8c.html#a84ca61a6d58c2bd2c7dcedf19d56a39d">get_type_arch</a> (type)))
<a name="l02532"></a>02532         move_bits (buffer, <a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (toval),
<a name="l02533"></a>02533                    <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (fromval), from_size - bits, bits, 1);
<a name="l02534"></a>02534       <span class="keywordflow">else</span>
<a name="l02535"></a>02535         move_bits (buffer, <a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (toval),
<a name="l02536"></a>02536                    <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (fromval), 0, bits, 0);
<a name="l02537"></a>02537       <a class="code" href="corefile_8c.html#a79bfa0e1eb4062f8c9e8448b47e7b3ea">write_memory_with_notification</a> (to_addr, buffer, len);
<a name="l02538"></a>02538 
<a name="l02539"></a>02539       val = <a class="code" href="value_8c.html#abe2b4f6342cfefdbb63666b6bcba636b">value_copy</a> (toval);
<a name="l02540"></a>02540       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="value_8c.html#a9f59e572fabef6e1905632fb81cc00e1">value_contents_raw</a> (val), <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (fromval),
<a name="l02541"></a>02541               <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type));
<a name="l02542"></a>02542       <a class="code" href="value_8c.html#adac1b2d5054e2d7b44ea25ac1f8002f1">deprecated_set_value_type</a> (val, type);
<a name="l02543"></a>02543 
<a name="l02544"></a>02544       <span class="keywordflow">return</span> val;
<a name="l02545"></a>02545     }
<a name="l02546"></a>02546 
<a name="l02547"></a>02547   <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a1357019ae48dabe7c46916ab0cf04ba2">value_assign</a> (toval, fromval);
<a name="l02548"></a>02548 }
<a name="l02549"></a>02549 
<a name="l02550"></a>02550 
<a name="l02551"></a>02551 <span class="comment">/* Given that COMPONENT is a memory lvalue that is part of the lvalue </span>
<a name="l02552"></a>02552 <span class="comment"> * CONTAINER, assign the contents of VAL to COMPONENTS&#39;s place in </span>
<a name="l02553"></a>02553 <span class="comment"> * CONTAINER.  Modifies the VALUE_CONTENTS of CONTAINER only, not </span>
<a name="l02554"></a>02554 <span class="comment"> * COMPONENT, and not the inferior&#39;s memory.  The current contents </span>
<a name="l02555"></a>02555 <span class="comment"> * of COMPONENT are ignored.  */</span>
<a name="l02556"></a>02556 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02557"></a>02557 value_assign_to_component (<span class="keyword">struct</span> value *container, <span class="keyword">struct</span> value *component,
<a name="l02558"></a>02558                            <span class="keyword">struct</span> value *val)
<a name="l02559"></a>02559 {
<a name="l02560"></a>02560   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> offset_in_container =
<a name="l02561"></a>02561     (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>)  (<a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (component) - <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (container));
<a name="l02562"></a>02562   <span class="keywordtype">int</span> bit_offset_in_container = 
<a name="l02563"></a>02563     <a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (component) - <a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (container);
<a name="l02564"></a>02564   <span class="keywordtype">int</span> <a class="code" href="arm-tdep_8c.html#a6d53921cd0f216408c4aed2806a0cb1f">bits</a>;
<a name="l02565"></a>02565   
<a name="l02566"></a>02566   val = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (component), val);
<a name="l02567"></a>02567 
<a name="l02568"></a>02568   <span class="keywordflow">if</span> (<a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (component) == 0)
<a name="l02569"></a>02569     bits = TARGET_CHAR_BIT * <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (component));
<a name="l02570"></a>02570   <span class="keywordflow">else</span>
<a name="l02571"></a>02571     bits = <a class="code" href="value_8c.html#a237b758259a150ee8759bb8f4bd41a97">value_bitsize</a> (component);
<a name="l02572"></a>02572 
<a name="l02573"></a>02573   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#afb14c978ec22423f831b98d7ac768382">gdbarch_bits_big_endian</a> (<a class="code" href="gdbtypes_8c.html#a84ca61a6d58c2bd2c7dcedf19d56a39d">get_type_arch</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (container))))
<a name="l02574"></a>02574     move_bits (<a class="code" href="value_8c.html#a13d7c6c06f661cae284e575c50647344">value_contents_writeable</a> (container) + offset_in_container, 
<a name="l02575"></a>02575                <a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (container) + bit_offset_in_container,
<a name="l02576"></a>02576                <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (val),
<a name="l02577"></a>02577                <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (component)) * TARGET_CHAR_BIT - bits,
<a name="l02578"></a>02578                bits, 1);
<a name="l02579"></a>02579   <span class="keywordflow">else</span>
<a name="l02580"></a>02580     move_bits (<a class="code" href="value_8c.html#a13d7c6c06f661cae284e575c50647344">value_contents_writeable</a> (container) + offset_in_container, 
<a name="l02581"></a>02581                <a class="code" href="value_8c.html#a280b9579a65c8e480d5e542ffe847c8e">value_bitpos</a> (container) + bit_offset_in_container,
<a name="l02582"></a>02582                <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (val), 0, bits, 0);
<a name="l02583"></a>02583 }              
<a name="l02584"></a>02584                         
<a name="l02585"></a>02585 <span class="comment">/* The value of the element of array ARR at the ARITY indices given in IND.</span>
<a name="l02586"></a>02586 <span class="comment">   ARR may be either a simple array, GNAT array descriptor, or pointer</span>
<a name="l02587"></a>02587 <span class="comment">   thereto.  */</span>
<a name="l02588"></a>02588 
<a name="l02589"></a>02589 <span class="keyword">struct </span>value *
<a name="l02590"></a><a class="code" href="ada-lang_8h.html#afbdd75ac7aa77f61424c10cf27b754ea">02590</a> <a class="code" href="ada-lang_8c.html#a40dcd8728888b5b445fa2a917076c1a9">ada_value_subscript</a> (<span class="keyword">struct</span> value *arr, <span class="keywordtype">int</span> arity, <span class="keyword">struct</span> value **ind)
<a name="l02591"></a>02591 {
<a name="l02592"></a>02592   <span class="keywordtype">int</span> k;
<a name="l02593"></a>02593   <span class="keyword">struct </span>value *elt;
<a name="l02594"></a>02594   <span class="keyword">struct </span>type *elt_type;
<a name="l02595"></a>02595 
<a name="l02596"></a>02596   elt = <a class="code" href="ada-lang_8c.html#a184966871049f553a895f96f7590884a">ada_coerce_to_simple_array</a> (arr);
<a name="l02597"></a>02597 
<a name="l02598"></a>02598   elt_type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (elt));
<a name="l02599"></a>02599   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (elt_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l02600"></a>02600       &amp;&amp; <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (elt_type, 0) &gt; 0)
<a name="l02601"></a>02601     <span class="keywordflow">return</span> value_subscript_packed (elt, arity, ind);
<a name="l02602"></a>02602 
<a name="l02603"></a>02603   <span class="keywordflow">for</span> (k = 0; k &lt; arity; k += 1)
<a name="l02604"></a>02604     {
<a name="l02605"></a>02605       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (elt_type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l02606"></a>02606         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;too many subscripts (%d expected)&quot;</span>), k);
<a name="l02607"></a>02607       elt = <a class="code" href="valarith_8c.html#a7d54cbfda0e6179b9e818951b91916d3">value_subscript</a> (elt, pos_atr (ind[k]));
<a name="l02608"></a>02608     }
<a name="l02609"></a>02609   <span class="keywordflow">return</span> elt;
<a name="l02610"></a>02610 }
<a name="l02611"></a>02611 
<a name="l02612"></a>02612 <span class="comment">/* Assuming ARR is a pointer to a standard GDB array of type TYPE, the</span>
<a name="l02613"></a>02613 <span class="comment">   value of the element of *ARR at the ARITY indices given in</span>
<a name="l02614"></a>02614 <span class="comment">   IND.  Does not read the entire array into memory.  */</span>
<a name="l02615"></a>02615 
<a name="l02616"></a>02616 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l02617"></a>02617 ada_value_ptr_subscript (<span class="keyword">struct</span> value *arr, <span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> arity,
<a name="l02618"></a>02618                          <span class="keyword">struct</span> value **ind)
<a name="l02619"></a>02619 {
<a name="l02620"></a>02620   <span class="keywordtype">int</span> k;
<a name="l02621"></a>02621 
<a name="l02622"></a>02622   <span class="keywordflow">for</span> (k = 0; k &lt; arity; k += 1)
<a name="l02623"></a>02623     {
<a name="l02624"></a>02624       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> lwb, upb;
<a name="l02625"></a>02625 
<a name="l02626"></a>02626       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l02627"></a>02627         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;too many subscripts (%d expected)&quot;</span>), k);
<a name="l02628"></a>02628       arr = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (<a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)),
<a name="l02629"></a>02629                         <a class="code" href="value_8c.html#abe2b4f6342cfefdbb63666b6bcba636b">value_copy</a> (arr));
<a name="l02630"></a>02630       <a class="code" href="gdbtypes_8c.html#a6b7f508cb2cdaf4d8f53494d9239b163">get_discrete_bounds</a> (<a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (type), &amp;lwb, &amp;upb);
<a name="l02631"></a>02631       arr = <a class="code" href="valarith_8c.html#adbc56b15746661876f9a226b8606c4d2">value_ptradd</a> (arr, pos_atr (ind[k]) - lwb);
<a name="l02632"></a>02632       type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l02633"></a>02633     }
<a name="l02634"></a>02634 
<a name="l02635"></a>02635   <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (arr);
<a name="l02636"></a>02636 }
<a name="l02637"></a>02637 
<a name="l02638"></a>02638 <span class="comment">/* Given that ARRAY_PTR is a pointer or reference to an array of type TYPE (the</span>
<a name="l02639"></a>02639 <span class="comment">   actual type of ARRAY_PTR is ignored), returns the Ada slice of HIGH-LOW+1</span>
<a name="l02640"></a>02640 <span class="comment">   elements starting at index LOW.  The lower bound of this array is LOW, as</span>
<a name="l02641"></a>02641 <span class="comment">   per Ada rules.  */</span>
<a name="l02642"></a>02642 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l02643"></a>02643 ada_value_slice_from_ptr (<span class="keyword">struct</span> value *array_ptr, <span class="keyword">struct</span> type *type,
<a name="l02644"></a>02644                           <span class="keywordtype">int</span> low, <span class="keywordtype">int</span> high)
<a name="l02645"></a>02645 {
<a name="l02646"></a>02646   <span class="keyword">struct </span>type *type0 = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l02647"></a>02647   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> base = <a class="code" href="value_8c.html#a2e64d8ca2ab5480e05097c6b2df1aa02">value_as_address</a> (array_ptr)
<a name="l02648"></a>02648     + ((low - <a class="code" href="ada-lang_8c.html#ad4891bc1ffa6690999afab17e367bc57">ada_discrete_type_low_bound</a> (<a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (type0)))
<a name="l02649"></a>02649        * <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type0)));
<a name="l02650"></a>02650   <span class="keyword">struct </span>type *index_type =
<a name="l02651"></a>02651     <a class="code" href="gdbtypes_8c.html#ab0885fdae181c47ff3f958bcba70b82d">create_range_type</a> (NULL, <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (type0)),
<a name="l02652"></a>02652                        low, high);
<a name="l02653"></a>02653   <span class="keyword">struct </span>type *slice_type =
<a name="l02654"></a>02654     <a class="code" href="gdbtypes_8c.html#a779bbebb8202264a73344b49b22d774e">create_array_type</a> (NULL, <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type0), index_type);
<a name="l02655"></a>02655 
<a name="l02656"></a>02656   <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (slice_type, base);
<a name="l02657"></a>02657 }
<a name="l02658"></a>02658 
<a name="l02659"></a>02659 
<a name="l02660"></a>02660 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l02661"></a>02661 ada_value_slice (<span class="keyword">struct</span> value *array, <span class="keywordtype">int</span> low, <span class="keywordtype">int</span> high)
<a name="l02662"></a>02662 {
<a name="l02663"></a>02663   <span class="keyword">struct </span>type *type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array));
<a name="l02664"></a>02664   <span class="keyword">struct </span>type *index_type =
<a name="l02665"></a>02665     <a class="code" href="gdbtypes_8c.html#ab0885fdae181c47ff3f958bcba70b82d">create_range_type</a> (NULL, <a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (type), low, high);
<a name="l02666"></a>02666   <span class="keyword">struct </span>type *slice_type =
<a name="l02667"></a>02667     <a class="code" href="gdbtypes_8c.html#a779bbebb8202264a73344b49b22d774e">create_array_type</a> (NULL, <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type), index_type);
<a name="l02668"></a>02668 
<a name="l02669"></a>02669   <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (slice_type, <a class="code" href="valops_8c.html#adb4d883c475f4c92b1afc51dbd6b638c">value_slice</a> (array, low, high - low + 1));
<a name="l02670"></a>02670 }
<a name="l02671"></a>02671 
<a name="l02672"></a>02672 <span class="comment">/* If type is a record type in the form of a standard GNAT array</span>
<a name="l02673"></a>02673 <span class="comment">   descriptor, returns the number of dimensions for type.  If arr is a</span>
<a name="l02674"></a>02674 <span class="comment">   simple array, returns the number of &quot;array of&quot;s that prefix its</span>
<a name="l02675"></a>02675 <span class="comment">   type designation.  Otherwise, returns 0.  */</span>
<a name="l02676"></a>02676 
<a name="l02677"></a>02677 <span class="keywordtype">int</span>
<a name="l02678"></a><a class="code" href="ada-lang_8h.html#ab7cc876aaedf02635fc550f0aff21427">02678</a> <a class="code" href="ada-lang_8c.html#ae9a1f2e16ad116a02636b91afd809c4b">ada_array_arity</a> (<span class="keyword">struct</span> type *type)
<a name="l02679"></a>02679 {
<a name="l02680"></a>02680   <span class="keywordtype">int</span> arity;
<a name="l02681"></a>02681 
<a name="l02682"></a>02682   <span class="keywordflow">if</span> (type == NULL)
<a name="l02683"></a>02683     <span class="keywordflow">return</span> 0;
<a name="l02684"></a>02684 
<a name="l02685"></a>02685   type = desc_base_type (type);
<a name="l02686"></a>02686 
<a name="l02687"></a>02687   arity = 0;
<a name="l02688"></a>02688   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>)
<a name="l02689"></a>02689     <span class="keywordflow">return</span> desc_arity (desc_bounds_type (type));
<a name="l02690"></a>02690   <span class="keywordflow">else</span>
<a name="l02691"></a>02691     <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l02692"></a>02692       {
<a name="l02693"></a>02693         arity += 1;
<a name="l02694"></a>02694         type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type));
<a name="l02695"></a>02695       }
<a name="l02696"></a>02696 
<a name="l02697"></a>02697   <span class="keywordflow">return</span> arity;
<a name="l02698"></a>02698 }
<a name="l02699"></a>02699 
<a name="l02700"></a>02700 <span class="comment">/* If TYPE is a record type in the form of a standard GNAT array</span>
<a name="l02701"></a>02701 <span class="comment">   descriptor or a simple array type, returns the element type for</span>
<a name="l02702"></a>02702 <span class="comment">   TYPE after indexing by NINDICES indices, or by all indices if</span>
<a name="l02703"></a>02703 <span class="comment">   NINDICES is -1.  Otherwise, returns NULL.  */</span>
<a name="l02704"></a>02704 
<a name="l02705"></a>02705 <span class="keyword">struct </span>type *
<a name="l02706"></a><a class="code" href="ada-lang_8h.html#a3e76079191230de1616d14b794d8c034">02706</a> <a class="code" href="ada-lang_8c.html#a6d2b3240a3d6eabb276131b5753e804e">ada_array_element_type</a> (<span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> nindices)
<a name="l02707"></a>02707 {
<a name="l02708"></a>02708   type = desc_base_type (type);
<a name="l02709"></a>02709 
<a name="l02710"></a>02710   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>)
<a name="l02711"></a>02711     {
<a name="l02712"></a>02712       <span class="keywordtype">int</span> k;
<a name="l02713"></a>02713       <span class="keyword">struct </span>type *p_array_type;
<a name="l02714"></a>02714 
<a name="l02715"></a>02715       p_array_type = desc_data_target_type (type);
<a name="l02716"></a>02716 
<a name="l02717"></a>02717       k = <a class="code" href="ada-lang_8c.html#ae9a1f2e16ad116a02636b91afd809c4b">ada_array_arity</a> (type);
<a name="l02718"></a>02718       <span class="keywordflow">if</span> (k == 0)
<a name="l02719"></a>02719         <span class="keywordflow">return</span> NULL;
<a name="l02720"></a>02720 
<a name="l02721"></a>02721       <span class="comment">/* Initially p_array_type = elt_type(*)[]...(k times)...[].  */</span>
<a name="l02722"></a>02722       <span class="keywordflow">if</span> (nindices &gt;= 0 &amp;&amp; k &gt; nindices)
<a name="l02723"></a>02723         k = nindices;
<a name="l02724"></a>02724       <span class="keywordflow">while</span> (k &gt; 0 &amp;&amp; p_array_type != NULL)
<a name="l02725"></a>02725         {
<a name="l02726"></a>02726           p_array_type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (p_array_type));
<a name="l02727"></a>02727           k -= 1;
<a name="l02728"></a>02728         }
<a name="l02729"></a>02729       <span class="keywordflow">return</span> p_array_type;
<a name="l02730"></a>02730     }
<a name="l02731"></a>02731   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l02732"></a>02732     {
<a name="l02733"></a>02733       <span class="keywordflow">while</span> (nindices != 0 &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l02734"></a>02734         {
<a name="l02735"></a>02735           type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l02736"></a>02736           nindices -= 1;
<a name="l02737"></a>02737         }
<a name="l02738"></a>02738       <span class="keywordflow">return</span> type;
<a name="l02739"></a>02739     }
<a name="l02740"></a>02740 
<a name="l02741"></a>02741   <span class="keywordflow">return</span> NULL;
<a name="l02742"></a>02742 }
<a name="l02743"></a>02743 
<a name="l02744"></a>02744 <span class="comment">/* The type of nth index in arrays of given type (n numbering from 1).</span>
<a name="l02745"></a>02745 <span class="comment">   Does not examine memory.  Throws an error if N is invalid or TYPE</span>
<a name="l02746"></a>02746 <span class="comment">   is not an array type.  NAME is the name of the Ada attribute being</span>
<a name="l02747"></a>02747 <span class="comment">   evaluated (&#39;range, &#39;first, &#39;last, or &#39;length); it is used in building</span>
<a name="l02748"></a>02748 <span class="comment">   the error message.  */</span>
<a name="l02749"></a>02749 
<a name="l02750"></a>02750 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l02751"></a>02751 ada_index_type (<span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l02752"></a>02752 {
<a name="l02753"></a>02753   <span class="keyword">struct </span>type *result_type;
<a name="l02754"></a>02754 
<a name="l02755"></a>02755   type = desc_base_type (type);
<a name="l02756"></a>02756 
<a name="l02757"></a>02757   <span class="keywordflow">if</span> (n &lt; 0 || n &gt; <a class="code" href="ada-lang_8c.html#ae9a1f2e16ad116a02636b91afd809c4b">ada_array_arity</a> (type))
<a name="l02758"></a>02758     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;invalid dimension number to &#39;%s&quot;</span>), name);
<a name="l02759"></a>02759 
<a name="l02760"></a>02760   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a98ee7e79620d6af77ffd35c586fcf7bd">ada_is_simple_array_type</a> (type))
<a name="l02761"></a>02761     {
<a name="l02762"></a>02762       <span class="keywordtype">int</span> i;
<a name="l02763"></a>02763 
<a name="l02764"></a>02764       <span class="keywordflow">for</span> (i = 1; i &lt; n; i += 1)
<a name="l02765"></a>02765         type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l02766"></a>02766       result_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (type));
<a name="l02767"></a>02767       <span class="comment">/* FIXME: The stabs type r(0,0);bound;bound in an array type</span>
<a name="l02768"></a>02768 <span class="comment">         has a target type of TYPE_CODE_UNDEF.  We compensate here, but</span>
<a name="l02769"></a>02769 <span class="comment">         perhaps stabsread.c would make more sense.  */</span>
<a name="l02770"></a>02770       <span class="keywordflow">if</span> (result_type &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (result_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ac0ed09886a958d1a94646893440004a8">TYPE_CODE_UNDEF</a>)
<a name="l02771"></a>02771         result_type = NULL;
<a name="l02772"></a>02772     }
<a name="l02773"></a>02773   <span class="keywordflow">else</span>
<a name="l02774"></a>02774     {
<a name="l02775"></a>02775       result_type = desc_index_type (desc_bounds_type (type), n);
<a name="l02776"></a>02776       <span class="keywordflow">if</span> (result_type == NULL)
<a name="l02777"></a>02777         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;attempt to take bound of something that is not an array&quot;</span>));
<a name="l02778"></a>02778     }
<a name="l02779"></a>02779 
<a name="l02780"></a>02780   <span class="keywordflow">return</span> result_type;
<a name="l02781"></a>02781 }
<a name="l02782"></a>02782 
<a name="l02783"></a>02783 <span class="comment">/* Given that arr is an array type, returns the lower bound of the</span>
<a name="l02784"></a>02784 <span class="comment">   Nth index (numbering from 1) if WHICH is 0, and the upper bound if</span>
<a name="l02785"></a>02785 <span class="comment">   WHICH is 1.  This returns bounds 0 .. -1 if ARR_TYPE is an</span>
<a name="l02786"></a>02786 <span class="comment">   array-descriptor type.  It works for other arrays with bounds supplied</span>
<a name="l02787"></a>02787 <span class="comment">   by run-time quantities other than discriminants.  */</span>
<a name="l02788"></a>02788 
<a name="l02789"></a>02789 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l02790"></a>02790 ada_array_bound_from_type (<span class="keyword">struct</span> type * arr_type, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> which)
<a name="l02791"></a>02791 {
<a name="l02792"></a>02792   <span class="keyword">struct </span>type *type, *elt_type, *index_type_desc, *index_type;
<a name="l02793"></a>02793   <span class="keywordtype">int</span> i;
<a name="l02794"></a>02794 
<a name="l02795"></a>02795   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (which == 0 || which == 1);
<a name="l02796"></a>02796 
<a name="l02797"></a>02797   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (arr_type))
<a name="l02798"></a>02798     arr_type = decode_constrained_packed_array_type (arr_type);
<a name="l02799"></a>02799 
<a name="l02800"></a>02800   <span class="keywordflow">if</span> (arr_type == NULL || !<a class="code" href="ada-lang_8c.html#a98ee7e79620d6af77ffd35c586fcf7bd">ada_is_simple_array_type</a> (arr_type))
<a name="l02801"></a>02801     <span class="keywordflow">return</span> (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) - which;
<a name="l02802"></a>02802 
<a name="l02803"></a>02803   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (arr_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l02804"></a>02804     type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (arr_type);
<a name="l02805"></a>02805   <span class="keywordflow">else</span>
<a name="l02806"></a>02806     type = arr_type;
<a name="l02807"></a>02807 
<a name="l02808"></a>02808   elt_type = type;
<a name="l02809"></a>02809   <span class="keywordflow">for</span> (i = n; i &gt; 1; i--)
<a name="l02810"></a>02810     elt_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l02811"></a>02811 
<a name="l02812"></a>02812   index_type_desc = <a class="code" href="ada-lang_8c.html#ade263e735047904b7eabe725cd6cc2f9">ada_find_parallel_type</a> (type, <span class="stringliteral">&quot;___XA&quot;</span>);
<a name="l02813"></a>02813   <a class="code" href="ada-lang_8c.html#ad725b7268112515bd22d705724724044">ada_fixup_array_indexes_type</a> (index_type_desc);
<a name="l02814"></a>02814   <span class="keywordflow">if</span> (index_type_desc != NULL)
<a name="l02815"></a>02815     index_type = to_fixed_range_type (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (index_type_desc, n - 1),
<a name="l02816"></a>02816                                       NULL);
<a name="l02817"></a>02817   <span class="keywordflow">else</span>
<a name="l02818"></a>02818     index_type = <a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (elt_type);
<a name="l02819"></a>02819 
<a name="l02820"></a>02820   <span class="keywordflow">return</span>
<a name="l02821"></a>02821     (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) (which == 0
<a name="l02822"></a>02822                ? <a class="code" href="ada-lang_8c.html#ad4891bc1ffa6690999afab17e367bc57">ada_discrete_type_low_bound</a> (index_type)
<a name="l02823"></a>02823                : <a class="code" href="ada-lang_8c.html#a9c9b5c63f7cb76eb9fdf216fa2721509">ada_discrete_type_high_bound</a> (index_type));
<a name="l02824"></a>02824 }
<a name="l02825"></a>02825 
<a name="l02826"></a>02826 <span class="comment">/* Given that arr is an array value, returns the lower bound of the</span>
<a name="l02827"></a>02827 <span class="comment">   nth index (numbering from 1) if WHICH is 0, and the upper bound if</span>
<a name="l02828"></a>02828 <span class="comment">   WHICH is 1.  This routine will also work for arrays with bounds</span>
<a name="l02829"></a>02829 <span class="comment">   supplied by run-time quantities other than discriminants.  */</span>
<a name="l02830"></a>02830 
<a name="l02831"></a>02831 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l02832"></a>02832 ada_array_bound (<span class="keyword">struct</span> value *arr, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> which)
<a name="l02833"></a>02833 {
<a name="l02834"></a>02834   <span class="keyword">struct </span>type *arr_type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr);
<a name="l02835"></a>02835 
<a name="l02836"></a>02836   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (arr_type))
<a name="l02837"></a>02837     <span class="keywordflow">return</span> ada_array_bound (decode_constrained_packed_array (arr), n, which);
<a name="l02838"></a>02838   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a98ee7e79620d6af77ffd35c586fcf7bd">ada_is_simple_array_type</a> (arr_type))
<a name="l02839"></a>02839     <span class="keywordflow">return</span> ada_array_bound_from_type (arr_type, n, which);
<a name="l02840"></a>02840   <span class="keywordflow">else</span>
<a name="l02841"></a>02841     <span class="keywordflow">return</span> <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (desc_one_bound (desc_bounds (arr), n, which));
<a name="l02842"></a>02842 }
<a name="l02843"></a>02843 
<a name="l02844"></a>02844 <span class="comment">/* Given that arr is an array value, returns the length of the</span>
<a name="l02845"></a>02845 <span class="comment">   nth index.  This routine will also work for arrays with bounds</span>
<a name="l02846"></a>02846 <span class="comment">   supplied by run-time quantities other than discriminants.</span>
<a name="l02847"></a>02847 <span class="comment">   Does not work for arrays indexed by enumeration types with representation</span>
<a name="l02848"></a>02848 <span class="comment">   clauses at the moment.  */</span>
<a name="l02849"></a>02849 
<a name="l02850"></a>02850 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l02851"></a>02851 ada_array_length (<span class="keyword">struct</span> value *arr, <span class="keywordtype">int</span> n)
<a name="l02852"></a>02852 {
<a name="l02853"></a>02853   <span class="keyword">struct </span>type *arr_type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr));
<a name="l02854"></a>02854 
<a name="l02855"></a>02855   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (arr_type))
<a name="l02856"></a>02856     <span class="keywordflow">return</span> ada_array_length (decode_constrained_packed_array (arr), n);
<a name="l02857"></a>02857 
<a name="l02858"></a>02858   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a98ee7e79620d6af77ffd35c586fcf7bd">ada_is_simple_array_type</a> (arr_type))
<a name="l02859"></a>02859     <span class="keywordflow">return</span> (ada_array_bound_from_type (arr_type, n, 1)
<a name="l02860"></a>02860             - ada_array_bound_from_type (arr_type, n, 0) + 1);
<a name="l02861"></a>02861   <span class="keywordflow">else</span>
<a name="l02862"></a>02862     <span class="keywordflow">return</span> (<a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (desc_one_bound (desc_bounds (arr), n, 1))
<a name="l02863"></a>02863             - <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (desc_one_bound (desc_bounds (arr), n, 0)) + 1);
<a name="l02864"></a>02864 }
<a name="l02865"></a>02865 
<a name="l02866"></a>02866 <span class="comment">/* An empty array whose type is that of ARR_TYPE (an array type),</span>
<a name="l02867"></a>02867 <span class="comment">   with bounds LOW to LOW-1.  */</span>
<a name="l02868"></a>02868 
<a name="l02869"></a>02869 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l02870"></a>02870 empty_array (<span class="keyword">struct</span> type *arr_type, <span class="keywordtype">int</span> low)
<a name="l02871"></a>02871 {
<a name="l02872"></a>02872   <span class="keyword">struct </span>type *arr_type0 = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (arr_type);
<a name="l02873"></a>02873   <span class="keyword">struct </span>type *index_type =
<a name="l02874"></a>02874     <a class="code" href="gdbtypes_8c.html#ab0885fdae181c47ff3f958bcba70b82d">create_range_type</a> (NULL, <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (arr_type0)),
<a name="l02875"></a>02875                        low, low - 1);
<a name="l02876"></a>02876   <span class="keyword">struct </span>type *elt_type = <a class="code" href="ada-lang_8c.html#a6d2b3240a3d6eabb276131b5753e804e">ada_array_element_type</a> (arr_type0, 1);
<a name="l02877"></a>02877 
<a name="l02878"></a>02878   <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (<a class="code" href="gdbtypes_8c.html#a779bbebb8202264a73344b49b22d774e">create_array_type</a> (NULL, elt_type, index_type));
<a name="l02879"></a>02879 }
<a name="l02880"></a>02880 
<a name="l02881"></a>02881 
<a name="l02882"></a>02882                                 <span class="comment">/* Name resolution */</span>
<a name="l02883"></a>02883 
<a name="l02884"></a>02884 <span class="comment">/* The &quot;decoded&quot; name for the user-definable Ada operator corresponding</span>
<a name="l02885"></a>02885 <span class="comment">   to OP.  */</span>
<a name="l02886"></a>02886 
<a name="l02887"></a>02887 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l02888"></a>02888 ada_decoded_op_name (<span class="keyword">enum</span> <a class="code" href="expression_8h.html#a13f8bfc7b2a183fe56716508bfddae41">exp_opcode</a> op)
<a name="l02889"></a>02889 {
<a name="l02890"></a>02890   <span class="keywordtype">int</span> i;
<a name="l02891"></a>02891 
<a name="l02892"></a>02892   <span class="keywordflow">for</span> (i = 0; ada_opname_table[i].<a class="code" href="structada__opname__map.html#af4e7f0cadf2f970fb92488ae523cb706">encoded</a> != NULL; i += 1)
<a name="l02893"></a>02893     {
<a name="l02894"></a>02894       <span class="keywordflow">if</span> (ada_opname_table[i].op == op)
<a name="l02895"></a>02895         <span class="keywordflow">return</span> ada_opname_table[i].<a class="code" href="structada__opname__map.html#a84c52a9db147c775a3ccb707fe99130b">decoded</a>;
<a name="l02896"></a>02896     }
<a name="l02897"></a>02897   <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Could not find operator name for opcode&quot;</span>));
<a name="l02898"></a>02898 }
<a name="l02899"></a>02899 
<a name="l02900"></a>02900 
<a name="l02901"></a>02901 <span class="comment">/* Same as evaluate_type (*EXP), but resolves ambiguous symbol</span>
<a name="l02902"></a>02902 <span class="comment">   references (marked by OP_VAR_VALUE nodes in which the symbol has an</span>
<a name="l02903"></a>02903 <span class="comment">   undefined namespace) and converts operators that are</span>
<a name="l02904"></a>02904 <span class="comment">   user-defined into appropriate function calls.  If CONTEXT_TYPE is</span>
<a name="l02905"></a>02905 <span class="comment">   non-null, it provides a preferred result type [at the moment, only</span>
<a name="l02906"></a>02906 <span class="comment">   type void has any effect---causing procedures to be preferred over</span>
<a name="l02907"></a>02907 <span class="comment">   functions in calls].  A null CONTEXT_TYPE indicates that a non-void</span>
<a name="l02908"></a>02908 <span class="comment">   return type is preferred.  May change (expand) *EXP.  */</span>
<a name="l02909"></a>02909 
<a name="l02910"></a>02910 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02911"></a>02911 <a class="code" href="sol-thread_8c.html#abbb193592c924dcda7896a284d3bd592">resolve</a> (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> **expp, <span class="keywordtype">int</span> void_context_p)
<a name="l02912"></a>02912 {
<a name="l02913"></a>02913   <span class="keyword">struct </span>type *context_type = NULL;
<a name="l02914"></a>02914   <span class="keywordtype">int</span> pc = 0;
<a name="l02915"></a>02915 
<a name="l02916"></a>02916   <span class="keywordflow">if</span> (void_context_p)
<a name="l02917"></a>02917     context_type = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> ((*expp)-&gt;gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#ae1b424251656c129a027977d3c0ea066">builtin_void</a>;
<a name="l02918"></a>02918 
<a name="l02919"></a>02919   resolve_subexp (expp, &amp;pc, 1, context_type);
<a name="l02920"></a>02920 }
<a name="l02921"></a>02921 
<a name="l02922"></a>02922 <span class="comment">/* Resolve the operator of the subexpression beginning at</span>
<a name="l02923"></a>02923 <span class="comment">   position *POS of *EXPP.  &quot;Resolving&quot; consists of replacing</span>
<a name="l02924"></a>02924 <span class="comment">   the symbols that have undefined namespaces in OP_VAR_VALUE nodes</span>
<a name="l02925"></a>02925 <span class="comment">   with their resolutions, replacing built-in operators with</span>
<a name="l02926"></a>02926 <span class="comment">   function calls to user-defined operators, where appropriate, and,</span>
<a name="l02927"></a>02927 <span class="comment">   when DEPROCEDURE_P is non-zero, converting function-valued variables</span>
<a name="l02928"></a>02928 <span class="comment">   into parameterless calls.  May expand *EXPP.  The CONTEXT_TYPE functions</span>
<a name="l02929"></a>02929 <span class="comment">   are as in ada_resolve, above.  */</span>
<a name="l02930"></a>02930 
<a name="l02931"></a>02931 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l02932"></a>02932 resolve_subexp (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> **expp, <span class="keywordtype">int</span> *pos, <span class="keywordtype">int</span> deprocedure_p,
<a name="l02933"></a>02933                 <span class="keyword">struct</span> type *context_type)
<a name="l02934"></a>02934 {
<a name="l02935"></a>02935   <span class="keywordtype">int</span> pc = *pos;
<a name="l02936"></a>02936   <span class="keywordtype">int</span> i;
<a name="l02937"></a>02937   <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *exp;       <span class="comment">/* Convenience: == *expp.  */</span>
<a name="l02938"></a>02938   <span class="keyword">enum</span> <a class="code" href="expression_8h.html#a13f8bfc7b2a183fe56716508bfddae41">exp_opcode</a> op = (*expp)-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a>;
<a name="l02939"></a>02939   <span class="keyword">struct </span>value **argvec;        <span class="comment">/* Vector of operand types (alloca&#39;ed).  */</span>
<a name="l02940"></a>02940   <span class="keywordtype">int</span> nargs;                    <span class="comment">/* Number of operands.  */</span>
<a name="l02941"></a>02941   <span class="keywordtype">int</span> oplen;
<a name="l02942"></a>02942 
<a name="l02943"></a>02943   argvec = NULL;
<a name="l02944"></a>02944   nargs = 0;
<a name="l02945"></a>02945   exp = *expp;
<a name="l02946"></a>02946 
<a name="l02947"></a>02947   <span class="comment">/* Pass one: resolve operands, saving their types and updating *pos,</span>
<a name="l02948"></a>02948 <span class="comment">     if needed.  */</span>
<a name="l02949"></a>02949   <span class="keywordflow">switch</span> (op)
<a name="l02950"></a>02950     {
<a name="l02951"></a>02951     <span class="keywordflow">case</span> OP_FUNCALL:
<a name="l02952"></a>02952       <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 3].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a> == OP_VAR_VALUE
<a name="l02953"></a>02953           &amp;&amp; <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 5].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>) == <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa6b943c7bcdab5c62ae6a0cbe8929f91f">UNDEF_DOMAIN</a>)
<a name="l02954"></a>02954         *pos += 7;
<a name="l02955"></a>02955       <span class="keywordflow">else</span>
<a name="l02956"></a>02956         {
<a name="l02957"></a>02957           *pos += 3;
<a name="l02958"></a>02958           resolve_subexp (expp, pos, 0, NULL);
<a name="l02959"></a>02959         }
<a name="l02960"></a>02960       nargs = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l02961"></a>02961       <span class="keywordflow">break</span>;
<a name="l02962"></a>02962 
<a name="l02963"></a>02963     <span class="keywordflow">case</span> UNOP_ADDR:
<a name="l02964"></a>02964       *pos += 1;
<a name="l02965"></a>02965       resolve_subexp (expp, pos, 0, NULL);
<a name="l02966"></a>02966       <span class="keywordflow">break</span>;
<a name="l02967"></a>02967 
<a name="l02968"></a>02968     <span class="keywordflow">case</span> UNOP_QUAL:
<a name="l02969"></a>02969       *pos += 3;
<a name="l02970"></a>02970       resolve_subexp (expp, pos, 1, <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>));
<a name="l02971"></a>02971       <span class="keywordflow">break</span>;
<a name="l02972"></a>02972 
<a name="l02973"></a>02973     <span class="keywordflow">case</span> OP_ATR_MODULUS:
<a name="l02974"></a>02974     <span class="keywordflow">case</span> OP_ATR_SIZE:
<a name="l02975"></a>02975     <span class="keywordflow">case</span> OP_ATR_TAG:
<a name="l02976"></a>02976     <span class="keywordflow">case</span> OP_ATR_FIRST:
<a name="l02977"></a>02977     <span class="keywordflow">case</span> OP_ATR_LAST:
<a name="l02978"></a>02978     <span class="keywordflow">case</span> OP_ATR_LENGTH:
<a name="l02979"></a>02979     <span class="keywordflow">case</span> OP_ATR_POS:
<a name="l02980"></a>02980     <span class="keywordflow">case</span> OP_ATR_VAL:
<a name="l02981"></a>02981     <span class="keywordflow">case</span> OP_ATR_MIN:
<a name="l02982"></a>02982     <span class="keywordflow">case</span> OP_ATR_MAX:
<a name="l02983"></a>02983     <span class="keywordflow">case</span> TERNOP_IN_RANGE:
<a name="l02984"></a>02984     <span class="keywordflow">case</span> BINOP_IN_BOUNDS:
<a name="l02985"></a>02985     <span class="keywordflow">case</span> UNOP_IN_RANGE:
<a name="l02986"></a>02986     <span class="keywordflow">case</span> OP_AGGREGATE:
<a name="l02987"></a>02987     <span class="keywordflow">case</span> OP_OTHERS:
<a name="l02988"></a>02988     <span class="keywordflow">case</span> OP_CHOICES:
<a name="l02989"></a>02989     <span class="keywordflow">case</span> OP_POSITIONAL:
<a name="l02990"></a>02990     <span class="keywordflow">case</span> OP_DISCRETE_RANGE:
<a name="l02991"></a>02991     <span class="keywordflow">case</span> OP_NAME:
<a name="l02992"></a>02992       ada_forward_operator_length (exp, pc, &amp;oplen, &amp;nargs);
<a name="l02993"></a>02993       *pos += oplen;
<a name="l02994"></a>02994       <span class="keywordflow">break</span>;
<a name="l02995"></a>02995 
<a name="l02996"></a>02996     <span class="keywordflow">case</span> BINOP_ASSIGN:
<a name="l02997"></a>02997       {
<a name="l02998"></a>02998         <span class="keyword">struct </span>value *arg1;
<a name="l02999"></a>02999 
<a name="l03000"></a>03000         *pos += 1;
<a name="l03001"></a>03001         arg1 = resolve_subexp (expp, pos, 0, NULL);
<a name="l03002"></a>03002         <span class="keywordflow">if</span> (arg1 == NULL)
<a name="l03003"></a>03003           resolve_subexp (expp, pos, 1, NULL);
<a name="l03004"></a>03004         <span class="keywordflow">else</span>
<a name="l03005"></a>03005           resolve_subexp (expp, pos, 1, <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1));
<a name="l03006"></a>03006         <span class="keywordflow">break</span>;
<a name="l03007"></a>03007       }
<a name="l03008"></a>03008 
<a name="l03009"></a>03009     <span class="keywordflow">case</span> UNOP_CAST:
<a name="l03010"></a>03010       *pos += 3;
<a name="l03011"></a>03011       nargs = 1;
<a name="l03012"></a>03012       <span class="keywordflow">break</span>;
<a name="l03013"></a>03013 
<a name="l03014"></a>03014     <span class="keywordflow">case</span> BINOP_ADD:
<a name="l03015"></a>03015     <span class="keywordflow">case</span> BINOP_SUB:
<a name="l03016"></a>03016     <span class="keywordflow">case</span> BINOP_MUL:
<a name="l03017"></a>03017     <span class="keywordflow">case</span> BINOP_DIV:
<a name="l03018"></a>03018     <span class="keywordflow">case</span> BINOP_REM:
<a name="l03019"></a>03019     <span class="keywordflow">case</span> BINOP_MOD:
<a name="l03020"></a>03020     <span class="keywordflow">case</span> BINOP_EXP:
<a name="l03021"></a>03021     <span class="keywordflow">case</span> BINOP_CONCAT:
<a name="l03022"></a>03022     <span class="keywordflow">case</span> BINOP_LOGICAL_AND:
<a name="l03023"></a>03023     <span class="keywordflow">case</span> BINOP_LOGICAL_OR:
<a name="l03024"></a>03024     <span class="keywordflow">case</span> BINOP_BITWISE_AND:
<a name="l03025"></a>03025     <span class="keywordflow">case</span> BINOP_BITWISE_IOR:
<a name="l03026"></a>03026     <span class="keywordflow">case</span> BINOP_BITWISE_XOR:
<a name="l03027"></a>03027 
<a name="l03028"></a>03028     <span class="keywordflow">case</span> BINOP_EQUAL:
<a name="l03029"></a>03029     <span class="keywordflow">case</span> BINOP_NOTEQUAL:
<a name="l03030"></a>03030     <span class="keywordflow">case</span> BINOP_LESS:
<a name="l03031"></a>03031     <span class="keywordflow">case</span> BINOP_GTR:
<a name="l03032"></a>03032     <span class="keywordflow">case</span> BINOP_LEQ:
<a name="l03033"></a>03033     <span class="keywordflow">case</span> BINOP_GEQ:
<a name="l03034"></a>03034 
<a name="l03035"></a>03035     <span class="keywordflow">case</span> BINOP_REPEAT:
<a name="l03036"></a>03036     <span class="keywordflow">case</span> BINOP_SUBSCRIPT:
<a name="l03037"></a>03037     <span class="keywordflow">case</span> BINOP_COMMA:
<a name="l03038"></a>03038       *pos += 1;
<a name="l03039"></a>03039       nargs = 2;
<a name="l03040"></a>03040       <span class="keywordflow">break</span>;
<a name="l03041"></a>03041 
<a name="l03042"></a>03042     <span class="keywordflow">case</span> UNOP_NEG:
<a name="l03043"></a>03043     <span class="keywordflow">case</span> UNOP_PLUS:
<a name="l03044"></a>03044     <span class="keywordflow">case</span> UNOP_LOGICAL_NOT:
<a name="l03045"></a>03045     <span class="keywordflow">case</span> UNOP_ABS:
<a name="l03046"></a>03046     <span class="keywordflow">case</span> UNOP_IND:
<a name="l03047"></a>03047       *pos += 1;
<a name="l03048"></a>03048       nargs = 1;
<a name="l03049"></a>03049       <span class="keywordflow">break</span>;
<a name="l03050"></a>03050 
<a name="l03051"></a>03051     <span class="keywordflow">case</span> OP_LONG:
<a name="l03052"></a>03052     <span class="keywordflow">case</span> OP_DOUBLE:
<a name="l03053"></a>03053     <span class="keywordflow">case</span> OP_VAR_VALUE:
<a name="l03054"></a>03054       *pos += 4;
<a name="l03055"></a>03055       <span class="keywordflow">break</span>;
<a name="l03056"></a>03056 
<a name="l03057"></a>03057     <span class="keywordflow">case</span> OP_TYPE:
<a name="l03058"></a>03058     <span class="keywordflow">case</span> OP_BOOL:
<a name="l03059"></a>03059     <span class="keywordflow">case</span> OP_LAST:
<a name="l03060"></a>03060     <span class="keywordflow">case</span> OP_INTERNALVAR:
<a name="l03061"></a>03061       *pos += 3;
<a name="l03062"></a>03062       <span class="keywordflow">break</span>;
<a name="l03063"></a>03063 
<a name="l03064"></a>03064     <span class="keywordflow">case</span> UNOP_MEMVAL:
<a name="l03065"></a>03065       *pos += 3;
<a name="l03066"></a>03066       nargs = 1;
<a name="l03067"></a>03067       <span class="keywordflow">break</span>;
<a name="l03068"></a>03068 
<a name="l03069"></a>03069     <span class="keywordflow">case</span> OP_REGISTER:
<a name="l03070"></a>03070       *pos += 4 + <a class="code" href="expression_8h.html#a8a1be157bb41aa92434ac6ce0e0fcf78">BYTES_TO_EXP_ELEM</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a> + 1);
<a name="l03071"></a>03071       <span class="keywordflow">break</span>;
<a name="l03072"></a>03072 
<a name="l03073"></a>03073     <span class="keywordflow">case</span> STRUCTOP_STRUCT:
<a name="l03074"></a>03074       *pos += 4 + <a class="code" href="expression_8h.html#a8a1be157bb41aa92434ac6ce0e0fcf78">BYTES_TO_EXP_ELEM</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a> + 1);
<a name="l03075"></a>03075       nargs = 1;
<a name="l03076"></a>03076       <span class="keywordflow">break</span>;
<a name="l03077"></a>03077 
<a name="l03078"></a>03078     <span class="keywordflow">case</span> TERNOP_SLICE:
<a name="l03079"></a>03079       *pos += 1;
<a name="l03080"></a>03080       nargs = 3;
<a name="l03081"></a>03081       <span class="keywordflow">break</span>;
<a name="l03082"></a>03082 
<a name="l03083"></a>03083     <span class="keywordflow">case</span> OP_STRING:
<a name="l03084"></a>03084       <span class="keywordflow">break</span>;
<a name="l03085"></a>03085 
<a name="l03086"></a>03086     <span class="keywordflow">default</span>:
<a name="l03087"></a>03087       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unexpected operator during name resolution&quot;</span>));
<a name="l03088"></a>03088     }
<a name="l03089"></a>03089 
<a name="l03090"></a>03090   argvec = (<span class="keyword">struct </span>value * *) alloca (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> value *) * (nargs + 1));
<a name="l03091"></a>03091   <span class="keywordflow">for</span> (i = 0; i &lt; nargs; i += 1)
<a name="l03092"></a>03092     argvec[i] = resolve_subexp (expp, pos, 1, NULL);
<a name="l03093"></a>03093   argvec[i] = NULL;
<a name="l03094"></a>03094   exp = *expp;
<a name="l03095"></a>03095 
<a name="l03096"></a>03096   <span class="comment">/* Pass two: perform any resolution on principal operator.  */</span>
<a name="l03097"></a>03097   <span class="keywordflow">switch</span> (op)
<a name="l03098"></a>03098     {
<a name="l03099"></a>03099     <span class="keywordflow">default</span>:
<a name="l03100"></a>03100       <span class="keywordflow">break</span>;
<a name="l03101"></a>03101 
<a name="l03102"></a>03102     <span class="keywordflow">case</span> OP_VAR_VALUE:
<a name="l03103"></a>03103       <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>) == <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa6b943c7bcdab5c62ae6a0cbe8929f91f">UNDEF_DOMAIN</a>)
<a name="l03104"></a>03104         {
<a name="l03105"></a>03105           <span class="keyword">struct </span><a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *candidates;
<a name="l03106"></a>03106           <span class="keywordtype">int</span> n_candidates;
<a name="l03107"></a>03107 
<a name="l03108"></a>03108           n_candidates =
<a name="l03109"></a>03109             <a class="code" href="ada-lang_8c.html#aa04634fbe1ee55e7efef10df7f0bc55b">ada_lookup_symbol_list</a> (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a>
<a name="l03110"></a>03110                                     (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>),
<a name="l03111"></a>03111                                     exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a140894cc6f8f336a98a4ec9340c7859b">block</a>, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>,
<a name="l03112"></a>03112                                     &amp;candidates);
<a name="l03113"></a>03113 
<a name="l03114"></a>03114           <span class="keywordflow">if</span> (n_candidates &gt; 1)
<a name="l03115"></a>03115             {
<a name="l03116"></a>03116               <span class="comment">/* Types tend to get re-introduced locally, so if there</span>
<a name="l03117"></a>03117 <span class="comment">                 are any local symbols that are not types, first filter</span>
<a name="l03118"></a>03118 <span class="comment">                 out all types.  */</span>
<a name="l03119"></a>03119               <span class="keywordtype">int</span> j;
<a name="l03120"></a>03120               <span class="keywordflow">for</span> (j = 0; j &lt; n_candidates; j += 1)
<a name="l03121"></a>03121                 <span class="keywordflow">switch</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (candidates[j].<a class="code" href="structada__symbol__info.html#ab424e8140f59e695fcb43c8d1c818728">sym</a>))
<a name="l03122"></a>03122                   {
<a name="l03123"></a>03123                   <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a2a9bcb7d8487d7ccb3858184340712e7">LOC_REGISTER</a>:
<a name="l03124"></a>03124                   <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3affc89e823125f8ae758aee5fb913b308">LOC_ARG</a>:
<a name="l03125"></a>03125                   <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a3c444a41d837bee346e19072ca35f8d3">LOC_REF_ARG</a>:
<a name="l03126"></a>03126                   <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ad9b13677899a4fbbd0f44f39726416e7">LOC_REGPARM_ADDR</a>:
<a name="l03127"></a>03127                   <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a495b83fa459ac0722b15a3e94afadbce">LOC_LOCAL</a>:
<a name="l03128"></a>03128                   <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3afd4303a25cda7805900ce8212c67ed45">LOC_COMPUTED</a>:
<a name="l03129"></a>03129                     <span class="keywordflow">goto</span> FoundNonType;
<a name="l03130"></a>03130                   <span class="keywordflow">default</span>:
<a name="l03131"></a>03131                     <span class="keywordflow">break</span>;
<a name="l03132"></a>03132                   }
<a name="l03133"></a>03133             FoundNonType:
<a name="l03134"></a>03134               <span class="keywordflow">if</span> (j &lt; n_candidates)
<a name="l03135"></a>03135                 {
<a name="l03136"></a>03136                   j = 0;
<a name="l03137"></a>03137                   <span class="keywordflow">while</span> (j &lt; n_candidates)
<a name="l03138"></a>03138                     {
<a name="l03139"></a>03139                       <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (candidates[j].sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>)
<a name="l03140"></a>03140                         {
<a name="l03141"></a>03141                           candidates[j] = candidates[n_candidates - 1];
<a name="l03142"></a>03142                           n_candidates -= 1;
<a name="l03143"></a>03143                         }
<a name="l03144"></a>03144                       <span class="keywordflow">else</span>
<a name="l03145"></a>03145                         j += 1;
<a name="l03146"></a>03146                     }
<a name="l03147"></a>03147                 }
<a name="l03148"></a>03148             }
<a name="l03149"></a>03149 
<a name="l03150"></a>03150           <span class="keywordflow">if</span> (n_candidates == 0)
<a name="l03151"></a>03151             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No definition found for %s&quot;</span>),
<a name="l03152"></a>03152                    <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>));
<a name="l03153"></a>03153           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n_candidates == 1)
<a name="l03154"></a>03154             i = 0;
<a name="l03155"></a>03155           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deprocedure_p
<a name="l03156"></a>03156                    &amp;&amp; !is_nonfunction (candidates, n_candidates))
<a name="l03157"></a>03157             {
<a name="l03158"></a>03158               i = ada_resolve_function
<a name="l03159"></a>03159                 (candidates, n_candidates, NULL, 0,
<a name="l03160"></a>03160                  <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>),
<a name="l03161"></a>03161                  context_type);
<a name="l03162"></a>03162               <span class="keywordflow">if</span> (i &lt; 0)
<a name="l03163"></a>03163                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Could not find a match for %s&quot;</span>),
<a name="l03164"></a>03164                        <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>));
<a name="l03165"></a>03165             }
<a name="l03166"></a>03166           <span class="keywordflow">else</span>
<a name="l03167"></a>03167             {
<a name="l03168"></a>03168               <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Multiple matches for %s\n&quot;</span>),
<a name="l03169"></a>03169                                <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>));
<a name="l03170"></a>03170               <a class="code" href="ada-lang_8c.html#a57bc0835e21ff6bf16d144f2e9db56f9">user_select_syms</a> (candidates, n_candidates, 1);
<a name="l03171"></a>03171               i = 0;
<a name="l03172"></a>03172             }
<a name="l03173"></a>03173 
<a name="l03174"></a>03174           exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a140894cc6f8f336a98a4ec9340c7859b">block</a> = candidates[i].<a class="code" href="structada__symbol__info.html#a42d6b64e717f920614470bc34c421b76">block</a>;
<a name="l03175"></a>03175           exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a> = candidates[i].<a class="code" href="structada__symbol__info.html#ab424e8140f59e695fcb43c8d1c818728">sym</a>;
<a name="l03176"></a>03176           <span class="keywordflow">if</span> (<a class="code" href="expression_8h.html#a6b2028f35010cd9648aa5d5e8f7d653d">innermost_block</a> == NULL
<a name="l03177"></a>03177               || <a class="code" href="block_8c.html#a24329baf96c81f9fa59a469df0a1b018">contained_in</a> (candidates[i].<a class="code" href="structblock.html">block</a>, <a class="code" href="expression_8h.html#a6b2028f35010cd9648aa5d5e8f7d653d">innermost_block</a>))
<a name="l03178"></a>03178             <a class="code" href="expression_8h.html#a6b2028f35010cd9648aa5d5e8f7d653d">innermost_block</a> = candidates[i].<a class="code" href="structada__symbol__info.html#a42d6b64e717f920614470bc34c421b76">block</a>;
<a name="l03179"></a>03179         }
<a name="l03180"></a>03180 
<a name="l03181"></a>03181       <span class="keywordflow">if</span> (deprocedure_p
<a name="l03182"></a>03182           &amp;&amp; (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>))
<a name="l03183"></a>03183               == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>))
<a name="l03184"></a>03184         {
<a name="l03185"></a>03185           replace_operator_with_call (expp, pc, 0, 0,
<a name="l03186"></a>03186                                       exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>,
<a name="l03187"></a>03187                                       exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a140894cc6f8f336a98a4ec9340c7859b">block</a>);
<a name="l03188"></a>03188           exp = *expp;
<a name="l03189"></a>03189         }
<a name="l03190"></a>03190       <span class="keywordflow">break</span>;
<a name="l03191"></a>03191 
<a name="l03192"></a>03192     <span class="keywordflow">case</span> OP_FUNCALL:
<a name="l03193"></a>03193       {
<a name="l03194"></a>03194         <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 3].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a> == OP_VAR_VALUE
<a name="l03195"></a>03195             &amp;&amp; <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 5].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>) == <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa6b943c7bcdab5c62ae6a0cbe8929f91f">UNDEF_DOMAIN</a>)
<a name="l03196"></a>03196           {
<a name="l03197"></a>03197             <span class="keyword">struct </span><a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *candidates;
<a name="l03198"></a>03198             <span class="keywordtype">int</span> n_candidates;
<a name="l03199"></a>03199 
<a name="l03200"></a>03200             n_candidates =
<a name="l03201"></a>03201               <a class="code" href="ada-lang_8c.html#aa04634fbe1ee55e7efef10df7f0bc55b">ada_lookup_symbol_list</a> (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a>
<a name="l03202"></a>03202                                       (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 5].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>),
<a name="l03203"></a>03203                                       exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 4].<a class="code" href="unionexp__element.html#a140894cc6f8f336a98a4ec9340c7859b">block</a>, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>,
<a name="l03204"></a>03204                                       &amp;candidates);
<a name="l03205"></a>03205             <span class="keywordflow">if</span> (n_candidates == 1)
<a name="l03206"></a>03206               i = 0;
<a name="l03207"></a>03207             <span class="keywordflow">else</span>
<a name="l03208"></a>03208               {
<a name="l03209"></a>03209                 i = ada_resolve_function
<a name="l03210"></a>03210                   (candidates, n_candidates,
<a name="l03211"></a>03211                    argvec, nargs,
<a name="l03212"></a>03212                    <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 5].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>),
<a name="l03213"></a>03213                    context_type);
<a name="l03214"></a>03214                 <span class="keywordflow">if</span> (i &lt; 0)
<a name="l03215"></a>03215                   <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Could not find a match for %s&quot;</span>),
<a name="l03216"></a>03216                          <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 5].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>));
<a name="l03217"></a>03217               }
<a name="l03218"></a>03218 
<a name="l03219"></a>03219             exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 4].<a class="code" href="unionexp__element.html#a140894cc6f8f336a98a4ec9340c7859b">block</a> = candidates[i].<a class="code" href="structada__symbol__info.html#a42d6b64e717f920614470bc34c421b76">block</a>;
<a name="l03220"></a>03220             exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 5].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a> = candidates[i].<a class="code" href="structada__symbol__info.html#ab424e8140f59e695fcb43c8d1c818728">sym</a>;
<a name="l03221"></a>03221             <span class="keywordflow">if</span> (<a class="code" href="expression_8h.html#a6b2028f35010cd9648aa5d5e8f7d653d">innermost_block</a> == NULL
<a name="l03222"></a>03222                 || <a class="code" href="block_8c.html#a24329baf96c81f9fa59a469df0a1b018">contained_in</a> (candidates[i].<a class="code" href="structblock.html">block</a>, <a class="code" href="expression_8h.html#a6b2028f35010cd9648aa5d5e8f7d653d">innermost_block</a>))
<a name="l03223"></a>03223               <a class="code" href="expression_8h.html#a6b2028f35010cd9648aa5d5e8f7d653d">innermost_block</a> = candidates[i].<a class="code" href="structada__symbol__info.html#a42d6b64e717f920614470bc34c421b76">block</a>;
<a name="l03224"></a>03224           }
<a name="l03225"></a>03225       }
<a name="l03226"></a>03226       <span class="keywordflow">break</span>;
<a name="l03227"></a>03227     <span class="keywordflow">case</span> BINOP_ADD:
<a name="l03228"></a>03228     <span class="keywordflow">case</span> BINOP_SUB:
<a name="l03229"></a>03229     <span class="keywordflow">case</span> BINOP_MUL:
<a name="l03230"></a>03230     <span class="keywordflow">case</span> BINOP_DIV:
<a name="l03231"></a>03231     <span class="keywordflow">case</span> BINOP_REM:
<a name="l03232"></a>03232     <span class="keywordflow">case</span> BINOP_MOD:
<a name="l03233"></a>03233     <span class="keywordflow">case</span> BINOP_CONCAT:
<a name="l03234"></a>03234     <span class="keywordflow">case</span> BINOP_BITWISE_AND:
<a name="l03235"></a>03235     <span class="keywordflow">case</span> BINOP_BITWISE_IOR:
<a name="l03236"></a>03236     <span class="keywordflow">case</span> BINOP_BITWISE_XOR:
<a name="l03237"></a>03237     <span class="keywordflow">case</span> BINOP_EQUAL:
<a name="l03238"></a>03238     <span class="keywordflow">case</span> BINOP_NOTEQUAL:
<a name="l03239"></a>03239     <span class="keywordflow">case</span> BINOP_LESS:
<a name="l03240"></a>03240     <span class="keywordflow">case</span> BINOP_GTR:
<a name="l03241"></a>03241     <span class="keywordflow">case</span> BINOP_LEQ:
<a name="l03242"></a>03242     <span class="keywordflow">case</span> BINOP_GEQ:
<a name="l03243"></a>03243     <span class="keywordflow">case</span> BINOP_EXP:
<a name="l03244"></a>03244     <span class="keywordflow">case</span> UNOP_NEG:
<a name="l03245"></a>03245     <span class="keywordflow">case</span> UNOP_PLUS:
<a name="l03246"></a>03246     <span class="keywordflow">case</span> UNOP_LOGICAL_NOT:
<a name="l03247"></a>03247     <span class="keywordflow">case</span> UNOP_ABS:
<a name="l03248"></a>03248       <span class="keywordflow">if</span> (possible_user_operator_p (op, argvec))
<a name="l03249"></a>03249         {
<a name="l03250"></a>03250           <span class="keyword">struct </span><a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *candidates;
<a name="l03251"></a>03251           <span class="keywordtype">int</span> n_candidates;
<a name="l03252"></a>03252 
<a name="l03253"></a>03253           n_candidates =
<a name="l03254"></a>03254             <a class="code" href="ada-lang_8c.html#aa04634fbe1ee55e7efef10df7f0bc55b">ada_lookup_symbol_list</a> (<a class="code" href="ada-lang_8c.html#ae2acc3345983845169c3d4239e922b75">ada_encode</a> (ada_decoded_op_name (op)),
<a name="l03255"></a>03255                                     (<span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *) NULL, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>,
<a name="l03256"></a>03256                                     &amp;candidates);
<a name="l03257"></a>03257           i = ada_resolve_function (candidates, n_candidates, argvec, nargs,
<a name="l03258"></a>03258                                     ada_decoded_op_name (op), NULL);
<a name="l03259"></a>03259           <span class="keywordflow">if</span> (i &lt; 0)
<a name="l03260"></a>03260             <span class="keywordflow">break</span>;
<a name="l03261"></a>03261 
<a name="l03262"></a>03262           replace_operator_with_call (expp, pc, nargs, 1,
<a name="l03263"></a>03263                                       candidates[i].sym, candidates[i].<a class="code" href="structblock.html">block</a>);
<a name="l03264"></a>03264           exp = *expp;
<a name="l03265"></a>03265         }
<a name="l03266"></a>03266       <span class="keywordflow">break</span>;
<a name="l03267"></a>03267 
<a name="l03268"></a>03268     <span class="keywordflow">case</span> OP_TYPE:
<a name="l03269"></a>03269     <span class="keywordflow">case</span> OP_REGISTER:
<a name="l03270"></a>03270       <span class="keywordflow">return</span> NULL;
<a name="l03271"></a>03271     }
<a name="l03272"></a>03272 
<a name="l03273"></a>03273   *pos = pc;
<a name="l03274"></a>03274   <span class="keywordflow">return</span> evaluate_subexp_type (exp, pos);
<a name="l03275"></a>03275 }
<a name="l03276"></a>03276 
<a name="l03277"></a>03277 <span class="comment">/* Return non-zero if formal type FTYPE matches actual type ATYPE.  If</span>
<a name="l03278"></a>03278 <span class="comment">   MAY_DEREF is non-zero, the formal may be a pointer and the actual</span>
<a name="l03279"></a>03279 <span class="comment">   a non-pointer.  */</span>
<a name="l03280"></a>03280 <span class="comment">/* The term &quot;match&quot; here is rather loose.  The match is heuristic and</span>
<a name="l03281"></a>03281 <span class="comment">   liberal.  */</span>
<a name="l03282"></a>03282 
<a name="l03283"></a>03283 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03284"></a>03284 ada_type_match (<span class="keyword">struct</span> type *ftype, <span class="keyword">struct</span> type *atype, <span class="keywordtype">int</span> may_deref)
<a name="l03285"></a>03285 {
<a name="l03286"></a>03286   ftype = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (ftype);
<a name="l03287"></a>03287   atype = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (atype);
<a name="l03288"></a>03288 
<a name="l03289"></a>03289   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (ftype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l03290"></a>03290     ftype = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (ftype);
<a name="l03291"></a>03291   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (atype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l03292"></a>03292     atype = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (atype);
<a name="l03293"></a>03293 
<a name="l03294"></a>03294   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (ftype))
<a name="l03295"></a>03295     {
<a name="l03296"></a>03296     <span class="keywordflow">default</span>:
<a name="l03297"></a>03297       <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (ftype) == <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (atype);
<a name="l03298"></a>03298     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>:
<a name="l03299"></a>03299       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (atype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l03300"></a>03300         <span class="keywordflow">return</span> ada_type_match (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (ftype),
<a name="l03301"></a>03301                                <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (atype), 0);
<a name="l03302"></a>03302       <span class="keywordflow">else</span>
<a name="l03303"></a>03303         <span class="keywordflow">return</span> (may_deref
<a name="l03304"></a>03304                 &amp;&amp; ada_type_match (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (ftype), atype, 0));
<a name="l03305"></a>03305     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>:
<a name="l03306"></a>03306     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>:
<a name="l03307"></a>03307     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>:
<a name="l03308"></a>03308       <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (atype))
<a name="l03309"></a>03309         {
<a name="l03310"></a>03310         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>:
<a name="l03311"></a>03311         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>:
<a name="l03312"></a>03312         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>:
<a name="l03313"></a>03313           <span class="keywordflow">return</span> 1;
<a name="l03314"></a>03314         <span class="keywordflow">default</span>:
<a name="l03315"></a>03315           <span class="keywordflow">return</span> 0;
<a name="l03316"></a>03316         }
<a name="l03317"></a>03317 
<a name="l03318"></a>03318     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>:
<a name="l03319"></a>03319       <span class="keywordflow">return</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (atype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l03320"></a>03320               || <a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (atype));
<a name="l03321"></a>03321 
<a name="l03322"></a>03322     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l03323"></a>03323       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (ftype))
<a name="l03324"></a>03324         <span class="keywordflow">return</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (atype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l03325"></a>03325                 || <a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (atype));
<a name="l03326"></a>03326       <span class="keywordflow">else</span>
<a name="l03327"></a>03327         <span class="keywordflow">return</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (atype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l03328"></a>03328                 &amp;&amp; !<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (atype));
<a name="l03329"></a>03329 
<a name="l03330"></a>03330     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>:
<a name="l03331"></a>03331     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>:
<a name="l03332"></a>03332       <span class="keywordflow">return</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (atype) == <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (ftype));
<a name="l03333"></a>03333     }
<a name="l03334"></a>03334 }
<a name="l03335"></a>03335 
<a name="l03336"></a>03336 <span class="comment">/* Return non-zero if the formals of FUNC &quot;sufficiently match&quot; the</span>
<a name="l03337"></a>03337 <span class="comment">   vector of actual argument types ACTUALS of size N_ACTUALS.  FUNC</span>
<a name="l03338"></a>03338 <span class="comment">   may also be an enumeral, in which case it is treated as a 0-</span>
<a name="l03339"></a>03339 <span class="comment">   argument function.  */</span>
<a name="l03340"></a>03340 
<a name="l03341"></a>03341 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03342"></a>03342 ada_args_match (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>, <span class="keyword">struct</span> value **actuals, <span class="keywordtype">int</span> n_actuals)
<a name="l03343"></a>03343 {
<a name="l03344"></a>03344   <span class="keywordtype">int</span> i;
<a name="l03345"></a>03345   <span class="keyword">struct </span>type *<a class="code" href="structfunc__type.html">func_type</a> = <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (func);
<a name="l03346"></a>03346 
<a name="l03347"></a>03347   <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (func) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a5268309778a6727d08106ff9f2966e54">LOC_CONST</a>
<a name="l03348"></a>03348       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (func_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>)
<a name="l03349"></a>03349     <span class="keywordflow">return</span> (n_actuals == 0);
<a name="l03350"></a>03350   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func_type == NULL || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (func_type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>)
<a name="l03351"></a>03351     <span class="keywordflow">return</span> 0;
<a name="l03352"></a>03352 
<a name="l03353"></a>03353   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (func_type) != n_actuals)
<a name="l03354"></a>03354     <span class="keywordflow">return</span> 0;
<a name="l03355"></a>03355 
<a name="l03356"></a>03356   <span class="keywordflow">for</span> (i = 0; i &lt; n_actuals; i += 1)
<a name="l03357"></a>03357     {
<a name="l03358"></a>03358       <span class="keywordflow">if</span> (actuals[i] == NULL)
<a name="l03359"></a>03359         <span class="keywordflow">return</span> 0;
<a name="l03360"></a>03360       <span class="keywordflow">else</span>
<a name="l03361"></a>03361         {
<a name="l03362"></a>03362           <span class="keyword">struct </span>type *ftype = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (func_type,
<a name="l03363"></a>03363                                                                    i));
<a name="l03364"></a>03364           <span class="keyword">struct </span>type *atype = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (actuals[i]));
<a name="l03365"></a>03365 
<a name="l03366"></a>03366           <span class="keywordflow">if</span> (!ada_type_match (ftype, atype, 1))
<a name="l03367"></a>03367             <span class="keywordflow">return</span> 0;
<a name="l03368"></a>03368         }
<a name="l03369"></a>03369     }
<a name="l03370"></a>03370   <span class="keywordflow">return</span> 1;
<a name="l03371"></a>03371 }
<a name="l03372"></a>03372 
<a name="l03373"></a>03373 <span class="comment">/* False iff function type FUNC_TYPE definitely does not produce a value</span>
<a name="l03374"></a>03374 <span class="comment">   compatible with type CONTEXT_TYPE.  Conservatively returns 1 if</span>
<a name="l03375"></a>03375 <span class="comment">   FUNC_TYPE is not a valid function type with a non-null return type</span>
<a name="l03376"></a>03376 <span class="comment">   or an enumerated type.  A null CONTEXT_TYPE indicates any non-void type.  */</span>
<a name="l03377"></a>03377 
<a name="l03378"></a>03378 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03379"></a>03379 return_match (<span class="keyword">struct</span> type *func_type, <span class="keyword">struct</span> type *context_type)
<a name="l03380"></a>03380 {
<a name="l03381"></a>03381   <span class="keyword">struct </span>type *return_type;
<a name="l03382"></a>03382 
<a name="l03383"></a>03383   <span class="keywordflow">if</span> (func_type == NULL)
<a name="l03384"></a>03384     <span class="keywordflow">return</span> 1;
<a name="l03385"></a>03385 
<a name="l03386"></a>03386   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (func_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>)
<a name="l03387"></a>03387     return_type = get_base_type (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (func_type));
<a name="l03388"></a>03388   <span class="keywordflow">else</span>
<a name="l03389"></a>03389     return_type = get_base_type (func_type);
<a name="l03390"></a>03390   <span class="keywordflow">if</span> (return_type == NULL)
<a name="l03391"></a>03391     <span class="keywordflow">return</span> 1;
<a name="l03392"></a>03392 
<a name="l03393"></a>03393   context_type = get_base_type (context_type);
<a name="l03394"></a>03394 
<a name="l03395"></a>03395   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (return_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>)
<a name="l03396"></a>03396     <span class="keywordflow">return</span> context_type == NULL || return_type == context_type;
<a name="l03397"></a>03397   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (context_type == NULL)
<a name="l03398"></a>03398     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (return_type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>;
<a name="l03399"></a>03399   <span class="keywordflow">else</span>
<a name="l03400"></a>03400     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (return_type) == <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (context_type);
<a name="l03401"></a>03401 }
<a name="l03402"></a>03402 
<a name="l03403"></a>03403 
<a name="l03404"></a>03404 <span class="comment">/* Returns the index in SYMS[0..NSYMS-1] that contains  the symbol for the</span>
<a name="l03405"></a>03405 <span class="comment">   function (if any) that matches the types of the NARGS arguments in</span>
<a name="l03406"></a>03406 <span class="comment">   ARGS.  If CONTEXT_TYPE is non-null and there is at least one match</span>
<a name="l03407"></a>03407 <span class="comment">   that returns that type, then eliminate matches that don&#39;t.  If</span>
<a name="l03408"></a>03408 <span class="comment">   CONTEXT_TYPE is void and there is at least one match that does not</span>
<a name="l03409"></a>03409 <span class="comment">   return void, eliminate all matches that do.</span>
<a name="l03410"></a>03410 <span class="comment"></span>
<a name="l03411"></a>03411 <span class="comment">   Asks the user if there is more than one match remaining.  Returns -1</span>
<a name="l03412"></a>03412 <span class="comment">   if there is no such symbol or none is selected.  NAME is used</span>
<a name="l03413"></a>03413 <span class="comment">   solely for messages.  May re-arrange and modify SYMS in</span>
<a name="l03414"></a>03414 <span class="comment">   the process; the index returned is for the modified vector.  */</span>
<a name="l03415"></a>03415 
<a name="l03416"></a>03416 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03417"></a>03417 ada_resolve_function (<span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a> syms[],
<a name="l03418"></a>03418                       <span class="keywordtype">int</span> nsyms, <span class="keyword">struct</span> value **args, <span class="keywordtype">int</span> nargs,
<a name="l03419"></a>03419                       <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> type *context_type)
<a name="l03420"></a>03420 {
<a name="l03421"></a>03421   <span class="keywordtype">int</span> fallback;
<a name="l03422"></a>03422   <span class="keywordtype">int</span> k;
<a name="l03423"></a>03423   <span class="keywordtype">int</span> <a class="code" href="namespacearm-linux.html#a8594a1214bfb32c5d61201101374a289">m</a>;                        <span class="comment">/* Number of hits */</span>
<a name="l03424"></a>03424 
<a name="l03425"></a>03425   m = 0;
<a name="l03426"></a>03426   <span class="comment">/* In the first pass of the loop, we only accept functions matching</span>
<a name="l03427"></a>03427 <span class="comment">     context_type.  If none are found, we add a second pass of the loop</span>
<a name="l03428"></a>03428 <span class="comment">     where every function is accepted.  */</span>
<a name="l03429"></a>03429   <span class="keywordflow">for</span> (fallback = 0; m == 0 &amp;&amp; fallback &lt; 2; fallback++)
<a name="l03430"></a>03430     {
<a name="l03431"></a>03431       <span class="keywordflow">for</span> (k = 0; k &lt; nsyms; k += 1)
<a name="l03432"></a>03432         {
<a name="l03433"></a>03433           <span class="keyword">struct </span>type *type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[k].sym));
<a name="l03434"></a>03434 
<a name="l03435"></a>03435           <span class="keywordflow">if</span> (ada_args_match (syms[k].sym, args, nargs)
<a name="l03436"></a>03436               &amp;&amp; (fallback || return_match (type, context_type)))
<a name="l03437"></a>03437             {
<a name="l03438"></a>03438               syms[<a class="code" href="namespacearm-linux.html#a8594a1214bfb32c5d61201101374a289">m</a>] = syms[k];
<a name="l03439"></a>03439               m += 1;
<a name="l03440"></a>03440             }
<a name="l03441"></a>03441         }
<a name="l03442"></a>03442     }
<a name="l03443"></a>03443 
<a name="l03444"></a>03444   <span class="keywordflow">if</span> (m == 0)
<a name="l03445"></a>03445     <span class="keywordflow">return</span> -1;
<a name="l03446"></a>03446   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m &gt; 1)
<a name="l03447"></a>03447     {
<a name="l03448"></a>03448       <a class="code" href="utils_8c.html#a8a83ee04701e157bf53e23d8682874e8">printf_filtered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Multiple matches for %s\n&quot;</span>), name);
<a name="l03449"></a>03449       <a class="code" href="ada-lang_8c.html#a57bc0835e21ff6bf16d144f2e9db56f9">user_select_syms</a> (syms, m, 1);
<a name="l03450"></a>03450       <span class="keywordflow">return</span> 0;
<a name="l03451"></a>03451     }
<a name="l03452"></a>03452   <span class="keywordflow">return</span> 0;
<a name="l03453"></a>03453 }
<a name="l03454"></a>03454 
<a name="l03455"></a>03455 <span class="comment">/* Returns true (non-zero) iff decoded name N0 should appear before N1</span>
<a name="l03456"></a>03456 <span class="comment">   in a listing of choices during disambiguation (see sort_choices, below).</span>
<a name="l03457"></a>03457 <span class="comment">   The idea is that overloadings of a subprogram name from the</span>
<a name="l03458"></a>03458 <span class="comment">   same package should sort in their source order.  We settle for ordering</span>
<a name="l03459"></a>03459 <span class="comment">   such symbols by their trailing number (__N  or $N).  */</span>
<a name="l03460"></a>03460 
<a name="l03461"></a>03461 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03462"></a>03462 encoded_ordered_before (<span class="keyword">const</span> <span class="keywordtype">char</span> *N0, <span class="keyword">const</span> <span class="keywordtype">char</span> *N1)
<a name="l03463"></a>03463 {
<a name="l03464"></a>03464   <span class="keywordflow">if</span> (N1 == NULL)
<a name="l03465"></a>03465     <span class="keywordflow">return</span> 0;
<a name="l03466"></a>03466   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (N0 == NULL)
<a name="l03467"></a>03467     <span class="keywordflow">return</span> 1;
<a name="l03468"></a>03468   <span class="keywordflow">else</span>
<a name="l03469"></a>03469     {
<a name="l03470"></a>03470       <span class="keywordtype">int</span> k0, k1;
<a name="l03471"></a>03471 
<a name="l03472"></a>03472       <span class="keywordflow">for</span> (k0 = strlen (N0) - 1; k0 &gt; 0 &amp;&amp; isdigit (N0[k0]); k0 -= 1)
<a name="l03473"></a>03473         ;
<a name="l03474"></a>03474       <span class="keywordflow">for</span> (k1 = strlen (N1) - 1; k1 &gt; 0 &amp;&amp; isdigit (N1[k1]); k1 -= 1)
<a name="l03475"></a>03475         ;
<a name="l03476"></a>03476       <span class="keywordflow">if</span> ((N0[k0] == <span class="charliteral">&#39;_&#39;</span> || N0[k0] == <span class="charliteral">&#39;$&#39;</span>) &amp;&amp; N0[k0 + 1] != <span class="charliteral">&#39;\000&#39;</span>
<a name="l03477"></a>03477           &amp;&amp; (N1[k1] == <span class="charliteral">&#39;_&#39;</span> || N1[k1] == <span class="charliteral">&#39;$&#39;</span>) &amp;&amp; N1[k1 + 1] != <span class="charliteral">&#39;\000&#39;</span>)
<a name="l03478"></a>03478         {
<a name="l03479"></a>03479           <span class="keywordtype">int</span> n0, n1;
<a name="l03480"></a>03480 
<a name="l03481"></a>03481           n0 = k0;
<a name="l03482"></a>03482           <span class="keywordflow">while</span> (N0[n0] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; n0 &gt; 0 &amp;&amp; N0[n0 - 1] == <span class="charliteral">&#39;_&#39;</span>)
<a name="l03483"></a>03483             n0 -= 1;
<a name="l03484"></a>03484           n1 = k1;
<a name="l03485"></a>03485           <span class="keywordflow">while</span> (N1[n1] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; n1 &gt; 0 &amp;&amp; N1[n1 - 1] == <span class="charliteral">&#39;_&#39;</span>)
<a name="l03486"></a>03486             n1 -= 1;
<a name="l03487"></a>03487           <span class="keywordflow">if</span> (n0 == n1 &amp;&amp; strncmp (N0, N1, n0) == 0)
<a name="l03488"></a>03488             <span class="keywordflow">return</span> (atoi (N0 + k0 + 1) &lt; atoi (N1 + k1 + 1));
<a name="l03489"></a>03489         }
<a name="l03490"></a>03490       <span class="keywordflow">return</span> (strcmp (N0, N1) &lt; 0);
<a name="l03491"></a>03491     }
<a name="l03492"></a>03492 }
<a name="l03493"></a>03493 
<a name="l03494"></a>03494 <span class="comment">/* Sort SYMS[0..NSYMS-1] to put the choices in a canonical order by the</span>
<a name="l03495"></a>03495 <span class="comment">   encoded names.  */</span>
<a name="l03496"></a>03496 
<a name="l03497"></a>03497 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03498"></a>03498 sort_choices (<span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a> syms[], <span class="keywordtype">int</span> nsyms)
<a name="l03499"></a>03499 {
<a name="l03500"></a>03500   <span class="keywordtype">int</span> i;
<a name="l03501"></a>03501 
<a name="l03502"></a>03502   <span class="keywordflow">for</span> (i = 1; i &lt; nsyms; i += 1)
<a name="l03503"></a>03503     {
<a name="l03504"></a>03504       <span class="keyword">struct </span><a class="code" href="structada__symbol__info.html">ada_symbol_info</a> sym = syms[i];
<a name="l03505"></a>03505       <span class="keywordtype">int</span> j;
<a name="l03506"></a>03506 
<a name="l03507"></a>03507       <span class="keywordflow">for</span> (j = i - 1; j &gt;= 0; j -= 1)
<a name="l03508"></a>03508         {
<a name="l03509"></a>03509           <span class="keywordflow">if</span> (encoded_ordered_before (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (syms[j].sym),
<a name="l03510"></a>03510                                       <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym.sym)))
<a name="l03511"></a>03511             <span class="keywordflow">break</span>;
<a name="l03512"></a>03512           syms[j + 1] = syms[j];
<a name="l03513"></a>03513         }
<a name="l03514"></a>03514       syms[j + 1] = <a class="code" href="structada__symbol__info.html#ab424e8140f59e695fcb43c8d1c818728">sym</a>;
<a name="l03515"></a>03515     }
<a name="l03516"></a>03516 }
<a name="l03517"></a>03517 
<a name="l03518"></a>03518 <span class="comment">/* Given a list of NSYMS symbols in SYMS, select up to MAX_RESULTS&gt;0 </span>
<a name="l03519"></a>03519 <span class="comment">   by asking the user (if necessary), returning the number selected, </span>
<a name="l03520"></a>03520 <span class="comment">   and setting the first elements of SYMS items.  Error if no symbols</span>
<a name="l03521"></a>03521 <span class="comment">   selected.  */</span>
<a name="l03522"></a>03522 
<a name="l03523"></a>03523 <span class="comment">/* NOTE: Adapted from decode_line_2 in symtab.c, with which it ought</span>
<a name="l03524"></a>03524 <span class="comment">   to be re-integrated one of these days.  */</span>
<a name="l03525"></a>03525 
<a name="l03526"></a>03526 <span class="keywordtype">int</span>
<a name="l03527"></a><a class="code" href="ada-lang_8h.html#aed6093634a50a13357813540dc67c075">03527</a> <a class="code" href="ada-lang_8c.html#a57bc0835e21ff6bf16d144f2e9db56f9">user_select_syms</a> (<span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *syms, <span class="keywordtype">int</span> nsyms, <span class="keywordtype">int</span> max_results)
<a name="l03528"></a>03528 {
<a name="l03529"></a>03529   <span class="keywordtype">int</span> i;
<a name="l03530"></a>03530   <span class="keywordtype">int</span> *chosen = (<span class="keywordtype">int</span> *) alloca (<span class="keyword">sizeof</span> (<span class="keywordtype">int</span>) * nsyms);
<a name="l03531"></a>03531   <span class="keywordtype">int</span> n_chosen;
<a name="l03532"></a>03532   <span class="keywordtype">int</span> first_choice = (max_results == 1) ? 1 : 2;
<a name="l03533"></a>03533   <span class="keyword">const</span> <span class="keywordtype">char</span> *select_mode = <a class="code" href="symtab_8c.html#ac1196047fdb70a2214cfcaecda5478d9">multiple_symbols_select_mode</a> ();
<a name="l03534"></a>03534 
<a name="l03535"></a>03535   <span class="keywordflow">if</span> (max_results &lt; 1)
<a name="l03536"></a>03536     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Request to select 0 symbols!&quot;</span>));
<a name="l03537"></a>03537   <span class="keywordflow">if</span> (nsyms &lt;= 1)
<a name="l03538"></a>03538     <span class="keywordflow">return</span> nsyms;
<a name="l03539"></a>03539 
<a name="l03540"></a>03540   <span class="keywordflow">if</span> (select_mode == <a class="code" href="symtab_8c.html#a5a9b380bd1851dbd78165e00514e2b64">multiple_symbols_cancel</a>)
<a name="l03541"></a>03541     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l03542"></a>03542 <span class="stringliteral">canceled because the command is ambiguous\n\</span>
<a name="l03543"></a>03543 <span class="stringliteral">See set/show multiple-symbol.&quot;</span>));
<a name="l03544"></a>03544   
<a name="l03545"></a>03545   <span class="comment">/* If select_mode is &quot;all&quot;, then return all possible symbols.</span>
<a name="l03546"></a>03546 <span class="comment">     Only do that if more than one symbol can be selected, of course.</span>
<a name="l03547"></a>03547 <span class="comment">     Otherwise, display the menu as usual.  */</span>
<a name="l03548"></a>03548   <span class="keywordflow">if</span> (select_mode == <a class="code" href="symtab_8c.html#a2457c524e394ad239661c86ceedb99a7">multiple_symbols_all</a> &amp;&amp; max_results &gt; 1)
<a name="l03549"></a>03549     <span class="keywordflow">return</span> nsyms;
<a name="l03550"></a>03550 
<a name="l03551"></a>03551   <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;[0] cancel\n&quot;</span>));
<a name="l03552"></a>03552   <span class="keywordflow">if</span> (max_results &gt; 1)
<a name="l03553"></a>03553     <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;[1] all\n&quot;</span>));
<a name="l03554"></a>03554 
<a name="l03555"></a>03555   sort_choices (syms, nsyms);
<a name="l03556"></a>03556 
<a name="l03557"></a>03557   <span class="keywordflow">for</span> (i = 0; i &lt; nsyms; i += 1)
<a name="l03558"></a>03558     {
<a name="l03559"></a>03559       <span class="keywordflow">if</span> (syms[i].sym == NULL)
<a name="l03560"></a>03560         <span class="keywordflow">continue</span>;
<a name="l03561"></a>03561 
<a name="l03562"></a>03562       <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (syms[i].sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>)
<a name="l03563"></a>03563         {
<a name="l03564"></a>03564           <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a> sal =
<a name="l03565"></a>03565             <a class="code" href="symtab_8c.html#ab927e83e70b2cff20b3750daff6f84c5">find_function_start_sal</a> (syms[i].sym, 1);
<a name="l03566"></a>03566 
<a name="l03567"></a>03567           <span class="keywordflow">if</span> (sal.<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a> == NULL)
<a name="l03568"></a>03568             <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;[%d] %s at &lt;no source file available&gt;:%d\n&quot;</span>),
<a name="l03569"></a>03569                                i + first_choice,
<a name="l03570"></a>03570                                <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (syms[i].sym),
<a name="l03571"></a>03571                                sal.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a>);
<a name="l03572"></a>03572           <span class="keywordflow">else</span>
<a name="l03573"></a>03573             <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;[%d] %s at %s:%d\n&quot;</span>), i + first_choice,
<a name="l03574"></a>03574                                <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (syms[i].sym),
<a name="l03575"></a>03575                                <a class="code" href="source_8c.html#ae251616cab166301d5fed95cbdd31232">symtab_to_filename_for_display</a> (sal.<a class="code" href="structsymtab__and__line.html#a74216e171a96d8bcaab43fe69b49c599">symtab</a>),
<a name="l03576"></a>03576                                sal.<a class="code" href="structsymtab__and__line.html#a6a0468be675b9ac19a5b3ef26f471eaf">line</a>);
<a name="l03577"></a>03577           <span class="keywordflow">continue</span>;
<a name="l03578"></a>03578         }
<a name="l03579"></a>03579       <span class="keywordflow">else</span>
<a name="l03580"></a>03580         {
<a name="l03581"></a>03581           <span class="keywordtype">int</span> is_enumeral =
<a name="l03582"></a>03582             (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (syms[i].sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a5268309778a6727d08106ff9f2966e54">LOC_CONST</a>
<a name="l03583"></a>03583              &amp;&amp; <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[i].sym) != NULL
<a name="l03584"></a>03584              &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[i].sym)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>);
<a name="l03585"></a>03585           <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *<a class="code" href="structsymtab.html">symtab</a> = <a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (syms[i].sym);
<a name="l03586"></a>03586 
<a name="l03587"></a>03587           <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#aaaa694c80f2e32770027d7561a171a55">SYMBOL_LINE</a> (syms[i].sym) != 0 &amp;&amp; symtab != NULL)
<a name="l03588"></a>03588             <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;[%d] %s at %s:%d\n&quot;</span>),
<a name="l03589"></a>03589                                i + first_choice,
<a name="l03590"></a>03590                                <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (syms[i].sym),
<a name="l03591"></a>03591                                <a class="code" href="source_8c.html#ae251616cab166301d5fed95cbdd31232">symtab_to_filename_for_display</a> (symtab),
<a name="l03592"></a>03592                                <a class="code" href="symtab_8h.html#aaaa694c80f2e32770027d7561a171a55">SYMBOL_LINE</a> (syms[i].sym));
<a name="l03593"></a>03593           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_enumeral
<a name="l03594"></a>03594                    &amp;&amp; <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[i].sym)) != NULL)
<a name="l03595"></a>03595             {
<a name="l03596"></a>03596               <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> ((<span class="stringliteral">&quot;[%d] &quot;</span>), i + first_choice);
<a name="l03597"></a>03597               <a class="code" href="ada-lang_8h.html#a30df4f3f0e5ed3346f73d2be79adcfbc">ada_print_type</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[i].sym), NULL,
<a name="l03598"></a>03598                               <a class="code" href="main_8c.html#a41a2b997ba5454df787d61f051dd918c">gdb_stdout</a>, -1, 0, &amp;<a class="code" href="typeprint_8c.html#a66053927e0c2e901b62bd36fd9769296">type_print_raw_options</a>);
<a name="l03599"></a>03599               <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;&#39;(%s) (enumeral)\n&quot;</span>),
<a name="l03600"></a>03600                                  <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (syms[i].sym));
<a name="l03601"></a>03601             }
<a name="l03602"></a>03602           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (symtab != NULL)
<a name="l03603"></a>03603             <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (is_enumeral
<a name="l03604"></a>03604                                ? <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;[%d] %s in %s (enumeral)\n&quot;</span>)
<a name="l03605"></a>03605                                : <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;[%d] %s at %s:?\n&quot;</span>),
<a name="l03606"></a>03606                                i + first_choice,
<a name="l03607"></a>03607                                <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (syms[i].sym),
<a name="l03608"></a>03608                                <a class="code" href="source_8c.html#ae251616cab166301d5fed95cbdd31232">symtab_to_filename_for_display</a> (symtab));
<a name="l03609"></a>03609           <span class="keywordflow">else</span>
<a name="l03610"></a>03610             <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (is_enumeral
<a name="l03611"></a>03611                                ? <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;[%d] %s (enumeral)\n&quot;</span>)
<a name="l03612"></a>03612                                : <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;[%d] %s at ?\n&quot;</span>),
<a name="l03613"></a>03613                                i + first_choice,
<a name="l03614"></a>03614                                <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (syms[i].sym));
<a name="l03615"></a>03615         }
<a name="l03616"></a>03616     }
<a name="l03617"></a>03617 
<a name="l03618"></a>03618   n_chosen = <a class="code" href="ada-lang_8c.html#a1cb378c18cd6f52885dd1c987f3843b5">get_selections</a> (chosen, nsyms, max_results, max_results &gt; 1,
<a name="l03619"></a>03619                              <span class="stringliteral">&quot;overload-choice&quot;</span>);
<a name="l03620"></a>03620 
<a name="l03621"></a>03621   <span class="keywordflow">for</span> (i = 0; i &lt; n_chosen; i += 1)
<a name="l03622"></a>03622     syms[i] = syms[chosen[i]];
<a name="l03623"></a>03623 
<a name="l03624"></a>03624   <span class="keywordflow">return</span> n_chosen;
<a name="l03625"></a>03625 }
<a name="l03626"></a>03626 
<a name="l03627"></a>03627 <span class="comment">/* Read and validate a set of numeric choices from the user in the</span>
<a name="l03628"></a>03628 <span class="comment">   range 0 .. N_CHOICES-1.  Place the results in increasing</span>
<a name="l03629"></a>03629 <span class="comment">   order in CHOICES[0 .. N-1], and return N.</span>
<a name="l03630"></a>03630 <span class="comment"></span>
<a name="l03631"></a>03631 <span class="comment">   The user types choices as a sequence of numbers on one line</span>
<a name="l03632"></a>03632 <span class="comment">   separated by blanks, encoding them as follows:</span>
<a name="l03633"></a>03633 <span class="comment"></span>
<a name="l03634"></a>03634 <span class="comment">     + A choice of 0 means to cancel the selection, throwing an error.</span>
<a name="l03635"></a>03635 <span class="comment">     + If IS_ALL_CHOICE, a choice of 1 selects the entire set 0 .. N_CHOICES-1.</span>
<a name="l03636"></a>03636 <span class="comment">     + The user chooses k by typing k+IS_ALL_CHOICE+1.</span>
<a name="l03637"></a>03637 <span class="comment"></span>
<a name="l03638"></a>03638 <span class="comment">   The user is not allowed to choose more than MAX_RESULTS values.</span>
<a name="l03639"></a>03639 <span class="comment"></span>
<a name="l03640"></a>03640 <span class="comment">   ANNOTATION_SUFFIX, if present, is used to annotate the input</span>
<a name="l03641"></a>03641 <span class="comment">   prompts (for use with the -f switch).  */</span>
<a name="l03642"></a>03642 
<a name="l03643"></a>03643 <span class="keywordtype">int</span>
<a name="l03644"></a><a class="code" href="ada-lang_8h.html#ab66344bc90d5fb8f85001c37e23371af">03644</a> <a class="code" href="ada-lang_8c.html#a1cb378c18cd6f52885dd1c987f3843b5">get_selections</a> (<span class="keywordtype">int</span> *choices, <span class="keywordtype">int</span> n_choices, <span class="keywordtype">int</span> max_results,
<a name="l03645"></a>03645                 <span class="keywordtype">int</span> is_all_choice, <span class="keywordtype">char</span> *annotation_suffix)
<a name="l03646"></a>03646 {
<a name="l03647"></a>03647   <span class="keywordtype">char</span> *args;
<a name="l03648"></a>03648   <span class="keywordtype">char</span> *prompt;
<a name="l03649"></a>03649   <span class="keywordtype">int</span> n_chosen;
<a name="l03650"></a>03650   <span class="keywordtype">int</span> first_choice = is_all_choice ? 2 : 1;
<a name="l03651"></a>03651 
<a name="l03652"></a>03652   prompt = getenv (<span class="stringliteral">&quot;PS2&quot;</span>);
<a name="l03653"></a>03653   <span class="keywordflow">if</span> (prompt == NULL)
<a name="l03654"></a>03654     prompt = <span class="stringliteral">&quot;&gt; &quot;</span>;
<a name="l03655"></a>03655 
<a name="l03656"></a>03656   args = <a class="code" href="defs_8h.html#a06b7acf2ace3fbf28f5873e57eb39376">command_line_input</a> (prompt, 0, annotation_suffix);
<a name="l03657"></a>03657 
<a name="l03658"></a>03658   <span class="keywordflow">if</span> (args == NULL)
<a name="l03659"></a>03659     <a class="code" href="cli-cmds_8c.html#a68aef78cdf72abc9df2495a4618842c3">error_no_arg</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;one or more choice numbers&quot;</span>));
<a name="l03660"></a>03660 
<a name="l03661"></a>03661   n_chosen = 0;
<a name="l03662"></a>03662 
<a name="l03663"></a>03663   <span class="comment">/* Set choices[0 .. n_chosen-1] to the users&#39; choices in ascending</span>
<a name="l03664"></a>03664 <span class="comment">     order, as given in args.  Choices are validated.  */</span>
<a name="l03665"></a>03665   <span class="keywordflow">while</span> (1)
<a name="l03666"></a>03666     {
<a name="l03667"></a>03667       <span class="keywordtype">char</span> *args2;
<a name="l03668"></a>03668       <span class="keywordtype">int</span> choice, j;
<a name="l03669"></a>03669 
<a name="l03670"></a>03670       args = <a class="code" href="cli-utils_8c.html#afa70bcaee54d487b4412d2a7a5a0c8fa">skip_spaces</a> (args);
<a name="l03671"></a>03671       <span class="keywordflow">if</span> (*args == <span class="charliteral">&#39;\0&#39;</span> &amp;&amp; n_chosen == 0)
<a name="l03672"></a>03672         <a class="code" href="cli-cmds_8c.html#a68aef78cdf72abc9df2495a4618842c3">error_no_arg</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;one or more choice numbers&quot;</span>));
<a name="l03673"></a>03673       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*args == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l03674"></a>03674         <span class="keywordflow">break</span>;
<a name="l03675"></a>03675 
<a name="l03676"></a>03676       choice = strtol (args, &amp;args2, 10);
<a name="l03677"></a>03677       <span class="keywordflow">if</span> (args == args2 || choice &lt; 0
<a name="l03678"></a>03678           || choice &gt; n_choices + first_choice - 1)
<a name="l03679"></a>03679         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Argument must be choice number&quot;</span>));
<a name="l03680"></a>03680       args = args2;
<a name="l03681"></a>03681 
<a name="l03682"></a>03682       <span class="keywordflow">if</span> (choice == 0)
<a name="l03683"></a>03683         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cancelled&quot;</span>));
<a name="l03684"></a>03684 
<a name="l03685"></a>03685       <span class="keywordflow">if</span> (choice &lt; first_choice)
<a name="l03686"></a>03686         {
<a name="l03687"></a>03687           n_chosen = n_choices;
<a name="l03688"></a>03688           <span class="keywordflow">for</span> (j = 0; j &lt; n_choices; j += 1)
<a name="l03689"></a>03689             choices[j] = j;
<a name="l03690"></a>03690           <span class="keywordflow">break</span>;
<a name="l03691"></a>03691         }
<a name="l03692"></a>03692       choice -= first_choice;
<a name="l03693"></a>03693 
<a name="l03694"></a>03694       <span class="keywordflow">for</span> (j = n_chosen - 1; j &gt;= 0 &amp;&amp; choice &lt; choices[j]; j -= 1)
<a name="l03695"></a>03695         {
<a name="l03696"></a>03696         }
<a name="l03697"></a>03697 
<a name="l03698"></a>03698       <span class="keywordflow">if</span> (j &lt; 0 || choice != choices[j])
<a name="l03699"></a>03699         {
<a name="l03700"></a>03700           <span class="keywordtype">int</span> k;
<a name="l03701"></a>03701 
<a name="l03702"></a>03702           <span class="keywordflow">for</span> (k = n_chosen - 1; k &gt; j; k -= 1)
<a name="l03703"></a>03703             choices[k + 1] = choices[k];
<a name="l03704"></a>03704           choices[j + 1] = choice;
<a name="l03705"></a>03705           n_chosen += 1;
<a name="l03706"></a>03706         }
<a name="l03707"></a>03707     }
<a name="l03708"></a>03708 
<a name="l03709"></a>03709   <span class="keywordflow">if</span> (n_chosen &gt; max_results)
<a name="l03710"></a>03710     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Select no more than %d of the above&quot;</span>), max_results);
<a name="l03711"></a>03711 
<a name="l03712"></a>03712   <span class="keywordflow">return</span> n_chosen;
<a name="l03713"></a>03713 }
<a name="l03714"></a>03714 
<a name="l03715"></a>03715 <span class="comment">/* Replace the operator of length OPLEN at position PC in *EXPP with a call</span>
<a name="l03716"></a>03716 <span class="comment">   on the function identified by SYM and BLOCK, and taking NARGS</span>
<a name="l03717"></a>03717 <span class="comment">   arguments.  Update *EXPP as needed to hold more space.  */</span>
<a name="l03718"></a>03718 
<a name="l03719"></a>03719 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03720"></a>03720 replace_operator_with_call (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> **expp, <span class="keywordtype">int</span> pc, <span class="keywordtype">int</span> nargs,
<a name="l03721"></a>03721                             <span class="keywordtype">int</span> oplen, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym,
<a name="l03722"></a>03722                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structblock.html">block</a> *<a class="code" href="structblock.html">block</a>)
<a name="l03723"></a>03723 {
<a name="l03724"></a>03724   <span class="comment">/* A new expression, with 6 more elements (3 for funcall, 4 for function</span>
<a name="l03725"></a>03725 <span class="comment">     symbol, -oplen for operator being replaced).  */</span>
<a name="l03726"></a>03726   <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *newexp = (<span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *)
<a name="l03727"></a>03727     <a class="code" href="common-utils_8c.html#ad7ead2fc5daad78a7f124e173863b16e">xzalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a>)
<a name="l03728"></a>03728              + <a class="code" href="expression_8h.html#a0c3bd719efe17f3c1df1fe790f4ffd0d">EXP_ELEM_TO_BYTES</a> ((*expp)-&gt;nelts + 7 - oplen));
<a name="l03729"></a>03729   <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *exp = *expp;
<a name="l03730"></a>03730 
<a name="l03731"></a>03731   newexp-&gt;<a class="code" href="structexpression.html#ad5e1dbc7e3732d94d29b8c3d61696123">nelts</a> = exp-&gt;<a class="code" href="structexpression.html#ad5e1dbc7e3732d94d29b8c3d61696123">nelts</a> + 7 - oplen;
<a name="l03732"></a>03732   newexp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a> = exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>;
<a name="l03733"></a>03733   newexp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a> = exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>;
<a name="l03734"></a>03734   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (newexp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>, exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>, <a class="code" href="expression_8h.html#a0c3bd719efe17f3c1df1fe790f4ffd0d">EXP_ELEM_TO_BYTES</a> (pc));
<a name="l03735"></a>03735   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (newexp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a> + pc + 7, exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a> + pc + oplen,
<a name="l03736"></a>03736           <a class="code" href="expression_8h.html#a0c3bd719efe17f3c1df1fe790f4ffd0d">EXP_ELEM_TO_BYTES</a> (exp-&gt;<a class="code" href="structexpression.html#ad5e1dbc7e3732d94d29b8c3d61696123">nelts</a> - pc - oplen));
<a name="l03737"></a>03737 
<a name="l03738"></a>03738   newexp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a> = newexp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a> = OP_FUNCALL;
<a name="l03739"></a>03739   newexp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a> = (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) nargs;
<a name="l03740"></a>03740 
<a name="l03741"></a>03741   newexp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 3].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a> = newexp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 6].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a> = OP_VAR_VALUE;
<a name="l03742"></a>03742   newexp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 4].<a class="code" href="unionexp__element.html#a140894cc6f8f336a98a4ec9340c7859b">block</a> = block;
<a name="l03743"></a>03743   newexp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 5].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a> = sym;
<a name="l03744"></a>03744 
<a name="l03745"></a>03745   *expp = newexp;
<a name="l03746"></a>03746   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (exp);
<a name="l03747"></a>03747 }
<a name="l03748"></a>03748 
<a name="l03749"></a>03749 <span class="comment">/* Type-class predicates */</span>
<a name="l03750"></a>03750 
<a name="l03751"></a>03751 <span class="comment">/* True iff TYPE is numeric (i.e., an INT, RANGE (of numeric type),</span>
<a name="l03752"></a>03752 <span class="comment">   or FLOAT).  */</span>
<a name="l03753"></a>03753 
<a name="l03754"></a>03754 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03755"></a>03755 numeric_type_p (<span class="keyword">struct</span> type *type)
<a name="l03756"></a>03756 {
<a name="l03757"></a>03757   <span class="keywordflow">if</span> (type == NULL)
<a name="l03758"></a>03758     <span class="keywordflow">return</span> 0;
<a name="l03759"></a>03759   <span class="keywordflow">else</span>
<a name="l03760"></a>03760     {
<a name="l03761"></a>03761       <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l03762"></a>03762         {
<a name="l03763"></a>03763         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>:
<a name="l03764"></a>03764         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>:
<a name="l03765"></a>03765           <span class="keywordflow">return</span> 1;
<a name="l03766"></a>03766         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>:
<a name="l03767"></a>03767           <span class="keywordflow">return</span> (type == <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)
<a name="l03768"></a>03768                   || numeric_type_p (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)));
<a name="l03769"></a>03769         <span class="keywordflow">default</span>:
<a name="l03770"></a>03770           <span class="keywordflow">return</span> 0;
<a name="l03771"></a>03771         }
<a name="l03772"></a>03772     }
<a name="l03773"></a>03773 }
<a name="l03774"></a>03774 
<a name="l03775"></a>03775 <span class="comment">/* True iff TYPE is integral (an INT or RANGE of INTs).  */</span>
<a name="l03776"></a>03776 
<a name="l03777"></a>03777 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03778"></a>03778 integer_type_p (<span class="keyword">struct</span> type *type)
<a name="l03779"></a>03779 {
<a name="l03780"></a>03780   <span class="keywordflow">if</span> (type == NULL)
<a name="l03781"></a>03781     <span class="keywordflow">return</span> 0;
<a name="l03782"></a>03782   <span class="keywordflow">else</span>
<a name="l03783"></a>03783     {
<a name="l03784"></a>03784       <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l03785"></a>03785         {
<a name="l03786"></a>03786         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>:
<a name="l03787"></a>03787           <span class="keywordflow">return</span> 1;
<a name="l03788"></a>03788         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>:
<a name="l03789"></a>03789           <span class="keywordflow">return</span> (type == <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)
<a name="l03790"></a>03790                   || integer_type_p (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)));
<a name="l03791"></a>03791         <span class="keywordflow">default</span>:
<a name="l03792"></a>03792           <span class="keywordflow">return</span> 0;
<a name="l03793"></a>03793         }
<a name="l03794"></a>03794     }
<a name="l03795"></a>03795 }
<a name="l03796"></a>03796 
<a name="l03797"></a>03797 <span class="comment">/* True iff TYPE is scalar (INT, RANGE, FLOAT, ENUM).  */</span>
<a name="l03798"></a>03798 
<a name="l03799"></a>03799 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03800"></a>03800 scalar_type_p (<span class="keyword">struct</span> type *type)
<a name="l03801"></a>03801 {
<a name="l03802"></a>03802   <span class="keywordflow">if</span> (type == NULL)
<a name="l03803"></a>03803     <span class="keywordflow">return</span> 0;
<a name="l03804"></a>03804   <span class="keywordflow">else</span>
<a name="l03805"></a>03805     {
<a name="l03806"></a>03806       <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l03807"></a>03807         {
<a name="l03808"></a>03808         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>:
<a name="l03809"></a>03809         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>:
<a name="l03810"></a>03810         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>:
<a name="l03811"></a>03811         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>:
<a name="l03812"></a>03812           <span class="keywordflow">return</span> 1;
<a name="l03813"></a>03813         <span class="keywordflow">default</span>:
<a name="l03814"></a>03814           <span class="keywordflow">return</span> 0;
<a name="l03815"></a>03815         }
<a name="l03816"></a>03816     }
<a name="l03817"></a>03817 }
<a name="l03818"></a>03818 
<a name="l03819"></a>03819 <span class="comment">/* True iff TYPE is discrete (INT, RANGE, ENUM).  */</span>
<a name="l03820"></a>03820 
<a name="l03821"></a>03821 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03822"></a>03822 discrete_type_p (<span class="keyword">struct</span> type *type)
<a name="l03823"></a>03823 {
<a name="l03824"></a>03824   <span class="keywordflow">if</span> (type == NULL)
<a name="l03825"></a>03825     <span class="keywordflow">return</span> 0;
<a name="l03826"></a>03826   <span class="keywordflow">else</span>
<a name="l03827"></a>03827     {
<a name="l03828"></a>03828       <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l03829"></a>03829         {
<a name="l03830"></a>03830         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>:
<a name="l03831"></a>03831         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>:
<a name="l03832"></a>03832         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>:
<a name="l03833"></a>03833         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462afbf0aa0241df408e1017ae7ff8e6798c">TYPE_CODE_BOOL</a>:
<a name="l03834"></a>03834           <span class="keywordflow">return</span> 1;
<a name="l03835"></a>03835         <span class="keywordflow">default</span>:
<a name="l03836"></a>03836           <span class="keywordflow">return</span> 0;
<a name="l03837"></a>03837         }
<a name="l03838"></a>03838     }
<a name="l03839"></a>03839 }
<a name="l03840"></a>03840 
<a name="l03841"></a>03841 <span class="comment">/* Returns non-zero if OP with operands in the vector ARGS could be</span>
<a name="l03842"></a>03842 <span class="comment">   a user-defined function.  Errs on the side of pre-defined operators</span>
<a name="l03843"></a>03843 <span class="comment">   (i.e., result 0).  */</span>
<a name="l03844"></a>03844 
<a name="l03845"></a>03845 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03846"></a>03846 possible_user_operator_p (<span class="keyword">enum</span> <a class="code" href="expression_8h.html#a13f8bfc7b2a183fe56716508bfddae41">exp_opcode</a> op, <span class="keyword">struct</span> value *args[])
<a name="l03847"></a>03847 {
<a name="l03848"></a>03848   <span class="keyword">struct </span>type *type0 =
<a name="l03849"></a>03849     (args[0] == NULL) ? NULL : <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (args[0]));
<a name="l03850"></a>03850   <span class="keyword">struct </span>type *type1 =
<a name="l03851"></a>03851     (args[1] == NULL) ? NULL : <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (args[1]));
<a name="l03852"></a>03852 
<a name="l03853"></a>03853   <span class="keywordflow">if</span> (type0 == NULL)
<a name="l03854"></a>03854     <span class="keywordflow">return</span> 0;
<a name="l03855"></a>03855 
<a name="l03856"></a>03856   <span class="keywordflow">switch</span> (op)
<a name="l03857"></a>03857     {
<a name="l03858"></a>03858     <span class="keywordflow">default</span>:
<a name="l03859"></a>03859       <span class="keywordflow">return</span> 0;
<a name="l03860"></a>03860 
<a name="l03861"></a>03861     <span class="keywordflow">case</span> BINOP_ADD:
<a name="l03862"></a>03862     <span class="keywordflow">case</span> BINOP_SUB:
<a name="l03863"></a>03863     <span class="keywordflow">case</span> BINOP_MUL:
<a name="l03864"></a>03864     <span class="keywordflow">case</span> BINOP_DIV:
<a name="l03865"></a>03865       <span class="keywordflow">return</span> (!(numeric_type_p (type0) &amp;&amp; numeric_type_p (type1)));
<a name="l03866"></a>03866 
<a name="l03867"></a>03867     <span class="keywordflow">case</span> BINOP_REM:
<a name="l03868"></a>03868     <span class="keywordflow">case</span> BINOP_MOD:
<a name="l03869"></a>03869     <span class="keywordflow">case</span> BINOP_BITWISE_AND:
<a name="l03870"></a>03870     <span class="keywordflow">case</span> BINOP_BITWISE_IOR:
<a name="l03871"></a>03871     <span class="keywordflow">case</span> BINOP_BITWISE_XOR:
<a name="l03872"></a>03872       <span class="keywordflow">return</span> (!(integer_type_p (type0) &amp;&amp; integer_type_p (type1)));
<a name="l03873"></a>03873 
<a name="l03874"></a>03874     <span class="keywordflow">case</span> BINOP_EQUAL:
<a name="l03875"></a>03875     <span class="keywordflow">case</span> BINOP_NOTEQUAL:
<a name="l03876"></a>03876     <span class="keywordflow">case</span> BINOP_LESS:
<a name="l03877"></a>03877     <span class="keywordflow">case</span> BINOP_GTR:
<a name="l03878"></a>03878     <span class="keywordflow">case</span> BINOP_LEQ:
<a name="l03879"></a>03879     <span class="keywordflow">case</span> BINOP_GEQ:
<a name="l03880"></a>03880       <span class="keywordflow">return</span> (!(scalar_type_p (type0) &amp;&amp; scalar_type_p (type1)));
<a name="l03881"></a>03881 
<a name="l03882"></a>03882     <span class="keywordflow">case</span> BINOP_CONCAT:
<a name="l03883"></a>03883       <span class="keywordflow">return</span> !ada_is_array_type (type0) || !ada_is_array_type (type1);
<a name="l03884"></a>03884 
<a name="l03885"></a>03885     <span class="keywordflow">case</span> BINOP_EXP:
<a name="l03886"></a>03886       <span class="keywordflow">return</span> (!(numeric_type_p (type0) &amp;&amp; integer_type_p (type1)));
<a name="l03887"></a>03887 
<a name="l03888"></a>03888     <span class="keywordflow">case</span> UNOP_NEG:
<a name="l03889"></a>03889     <span class="keywordflow">case</span> UNOP_PLUS:
<a name="l03890"></a>03890     <span class="keywordflow">case</span> UNOP_LOGICAL_NOT:
<a name="l03891"></a>03891     <span class="keywordflow">case</span> UNOP_ABS:
<a name="l03892"></a>03892       <span class="keywordflow">return</span> (!numeric_type_p (type0));
<a name="l03893"></a>03893 
<a name="l03894"></a>03894     }
<a name="l03895"></a>03895 }
<a name="l03896"></a>03896 
<a name="l03897"></a>03897                                 <span class="comment">/* Renaming */</span>
<a name="l03898"></a>03898 
<a name="l03899"></a>03899 <span class="comment">/* NOTES: </span>
<a name="l03900"></a>03900 <span class="comment"></span>
<a name="l03901"></a>03901 <span class="comment">   1. In the following, we assume that a renaming type&#39;s name may</span>
<a name="l03902"></a>03902 <span class="comment">      have an ___XD suffix.  It would be nice if this went away at some</span>
<a name="l03903"></a>03903 <span class="comment">      point.</span>
<a name="l03904"></a>03904 <span class="comment">   2. We handle both the (old) purely type-based representation of </span>
<a name="l03905"></a>03905 <span class="comment">      renamings and the (new) variable-based encoding.  At some point,</span>
<a name="l03906"></a>03906 <span class="comment">      it is devoutly to be hoped that the former goes away </span>
<a name="l03907"></a>03907 <span class="comment">      (FIXME: hilfinger-2007-07-09).</span>
<a name="l03908"></a>03908 <span class="comment">   3. Subprogram renamings are not implemented, although the XRS</span>
<a name="l03909"></a>03909 <span class="comment">      suffix is recognized (FIXME: hilfinger-2007-07-09).  */</span>
<a name="l03910"></a>03910 
<a name="l03911"></a>03911 <span class="comment">/* If SYM encodes a renaming, </span>
<a name="l03912"></a>03912 <span class="comment"></span>
<a name="l03913"></a>03913 <span class="comment">       &lt;renaming&gt; renames &lt;renamed entity&gt;,</span>
<a name="l03914"></a>03914 <span class="comment"></span>
<a name="l03915"></a>03915 <span class="comment">   sets *LEN to the length of the renamed entity&#39;s name,</span>
<a name="l03916"></a>03916 <span class="comment">   *RENAMED_ENTITY to that name (not null-terminated), and *RENAMING_EXPR to</span>
<a name="l03917"></a>03917 <span class="comment">   the string describing the subcomponent selected from the renamed</span>
<a name="l03918"></a>03918 <span class="comment">   entity.  Returns ADA_NOT_RENAMING if SYM does not encode a renaming</span>
<a name="l03919"></a>03919 <span class="comment">   (in which case, the values of *RENAMED_ENTITY, *LEN, and *RENAMING_EXPR</span>
<a name="l03920"></a>03920 <span class="comment">   are undefined).  Otherwise, returns a value indicating the category</span>
<a name="l03921"></a>03921 <span class="comment">   of entity renamed: an object (ADA_OBJECT_RENAMING), exception</span>
<a name="l03922"></a>03922 <span class="comment">   (ADA_EXCEPTION_RENAMING), package (ADA_PACKAGE_RENAMING), or</span>
<a name="l03923"></a>03923 <span class="comment">   subprogram (ADA_SUBPROGRAM_RENAMING).  Does no allocation; the</span>
<a name="l03924"></a>03924 <span class="comment">   strings returned in *RENAMED_ENTITY and *RENAMING_EXPR should not be</span>
<a name="l03925"></a>03925 <span class="comment">   deallocated.  The values of RENAMED_ENTITY, LEN, or RENAMING_EXPR</span>
<a name="l03926"></a>03926 <span class="comment">   may be NULL, in which case they are not assigned.</span>
<a name="l03927"></a>03927 <span class="comment"></span>
<a name="l03928"></a>03928 <span class="comment">   [Currently, however, GCC does not generate subprogram renamings.]  */</span>
<a name="l03929"></a>03929 
<a name="l03930"></a>03930 <span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5dec">ada_renaming_category</a>
<a name="l03931"></a><a class="code" href="ada-lang_8h.html#a923e266bf4527526978298cca5ae67f7">03931</a> <a class="code" href="ada-lang_8c.html#a7d8e58dccc5e1de5d818463752740f62">ada_parse_renaming</a> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym,
<a name="l03932"></a>03932                     <span class="keyword">const</span> <span class="keywordtype">char</span> **renamed_entity, <span class="keywordtype">int</span> *len, 
<a name="l03933"></a>03933                     <span class="keyword">const</span> <span class="keywordtype">char</span> **renaming_expr)
<a name="l03934"></a>03934 {
<a name="l03935"></a>03935   <span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5dec">ada_renaming_category</a> kind;
<a name="l03936"></a>03936   <span class="keyword">const</span> <span class="keywordtype">char</span> *info;
<a name="l03937"></a>03937   <span class="keyword">const</span> <span class="keywordtype">char</span> *suffix;
<a name="l03938"></a>03938 
<a name="l03939"></a>03939   <span class="keywordflow">if</span> (sym == NULL)
<a name="l03940"></a>03940     <span class="keywordflow">return</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca6b0dcfc5b9c388cea30331121009bcbe">ADA_NOT_RENAMING</a>;
<a name="l03941"></a>03941   <span class="keywordflow">switch</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym)) 
<a name="l03942"></a>03942     {
<a name="l03943"></a>03943     <span class="keywordflow">default</span>:
<a name="l03944"></a>03944       <span class="keywordflow">return</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca6b0dcfc5b9c388cea30331121009bcbe">ADA_NOT_RENAMING</a>;
<a name="l03945"></a>03945     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>:
<a name="l03946"></a>03946       <span class="keywordflow">return</span> parse_old_style_renaming (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym), 
<a name="l03947"></a>03947                                        renamed_entity, len, renaming_expr);
<a name="l03948"></a>03948     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a495b83fa459ac0722b15a3e94afadbce">LOC_LOCAL</a>:
<a name="l03949"></a>03949     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a154b256439f7acd7ec7f6257d5881a0f">LOC_STATIC</a>:
<a name="l03950"></a>03950     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3afd4303a25cda7805900ce8212c67ed45">LOC_COMPUTED</a>:
<a name="l03951"></a>03951     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3aa4f37f80c900ee253911325c30b8a60f">LOC_OPTIMIZED_OUT</a>:
<a name="l03952"></a>03952       info = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym), <span class="stringliteral">&quot;___XR&quot;</span>);
<a name="l03953"></a>03953       <span class="keywordflow">if</span> (info == NULL)
<a name="l03954"></a>03954         <span class="keywordflow">return</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca6b0dcfc5b9c388cea30331121009bcbe">ADA_NOT_RENAMING</a>;
<a name="l03955"></a>03955       <span class="keywordflow">switch</span> (info[5])
<a name="l03956"></a>03956         {
<a name="l03957"></a>03957         <span class="keywordflow">case</span> <span class="charliteral">&#39;_&#39;</span>:
<a name="l03958"></a>03958           kind = <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca699f7a84941953710b7735d7bed1e4e3">ADA_OBJECT_RENAMING</a>;
<a name="l03959"></a>03959           info += 6;
<a name="l03960"></a>03960           <span class="keywordflow">break</span>;
<a name="l03961"></a>03961         <span class="keywordflow">case</span> <span class="charliteral">&#39;E&#39;</span>:
<a name="l03962"></a>03962           kind = <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca0237b62f7ad08b039e531d8222d15a01">ADA_EXCEPTION_RENAMING</a>;
<a name="l03963"></a>03963           info += 7;
<a name="l03964"></a>03964           <span class="keywordflow">break</span>;
<a name="l03965"></a>03965         <span class="keywordflow">case</span> <span class="charliteral">&#39;P&#39;</span>:
<a name="l03966"></a>03966           kind = <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5decab5eb427a2c80b470575aebb9d1a80e85">ADA_PACKAGE_RENAMING</a>;
<a name="l03967"></a>03967           info += 7;
<a name="l03968"></a>03968           <span class="keywordflow">break</span>;
<a name="l03969"></a>03969         <span class="keywordflow">case</span> <span class="charliteral">&#39;S&#39;</span>:
<a name="l03970"></a>03970           kind = <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5decad6cccf7cf2f9b8ff81ad105a7c94e97a">ADA_SUBPROGRAM_RENAMING</a>;
<a name="l03971"></a>03971           info += 7;
<a name="l03972"></a>03972           <span class="keywordflow">break</span>;
<a name="l03973"></a>03973         <span class="keywordflow">default</span>:
<a name="l03974"></a>03974           <span class="keywordflow">return</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca6b0dcfc5b9c388cea30331121009bcbe">ADA_NOT_RENAMING</a>;
<a name="l03975"></a>03975         }
<a name="l03976"></a>03976     }
<a name="l03977"></a>03977 
<a name="l03978"></a>03978   <span class="keywordflow">if</span> (renamed_entity != NULL)
<a name="l03979"></a>03979     *renamed_entity = info;
<a name="l03980"></a>03980   suffix = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (info, <span class="stringliteral">&quot;___XE&quot;</span>);
<a name="l03981"></a>03981   <span class="keywordflow">if</span> (suffix == NULL || suffix == info)
<a name="l03982"></a>03982     <span class="keywordflow">return</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca6b0dcfc5b9c388cea30331121009bcbe">ADA_NOT_RENAMING</a>;
<a name="l03983"></a>03983   <span class="keywordflow">if</span> (len != NULL)
<a name="l03984"></a>03984     *len = strlen (info) - strlen (suffix);
<a name="l03985"></a>03985   suffix += 5;
<a name="l03986"></a>03986   <span class="keywordflow">if</span> (renaming_expr != NULL)
<a name="l03987"></a>03987     *renaming_expr = suffix;
<a name="l03988"></a>03988   <span class="keywordflow">return</span> kind;
<a name="l03989"></a>03989 }
<a name="l03990"></a>03990 
<a name="l03991"></a>03991 <span class="comment">/* Assuming TYPE encodes a renaming according to the old encoding in</span>
<a name="l03992"></a>03992 <span class="comment">   exp_dbug.ads, returns details of that renaming in *RENAMED_ENTITY,</span>
<a name="l03993"></a>03993 <span class="comment">   *LEN, and *RENAMING_EXPR, as for ada_parse_renaming, above.  Returns</span>
<a name="l03994"></a>03994 <span class="comment">   ADA_NOT_RENAMING otherwise.  */</span>
<a name="l03995"></a>03995 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5dec">ada_renaming_category</a>
<a name="l03996"></a>03996 parse_old_style_renaming (<span class="keyword">struct</span> type *type,
<a name="l03997"></a>03997                           <span class="keyword">const</span> <span class="keywordtype">char</span> **renamed_entity, <span class="keywordtype">int</span> *len, 
<a name="l03998"></a>03998                           <span class="keyword">const</span> <span class="keywordtype">char</span> **renaming_expr)
<a name="l03999"></a>03999 {
<a name="l04000"></a>04000   <span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5dec">ada_renaming_category</a> kind;
<a name="l04001"></a>04001   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l04002"></a>04002   <span class="keyword">const</span> <span class="keywordtype">char</span> *info;
<a name="l04003"></a>04003   <span class="keyword">const</span> <span class="keywordtype">char</span> *suffix;
<a name="l04004"></a>04004 
<a name="l04005"></a>04005   <span class="keywordflow">if</span> (type == NULL || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a> 
<a name="l04006"></a>04006       || <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) != 1)
<a name="l04007"></a>04007     <span class="keywordflow">return</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca6b0dcfc5b9c388cea30331121009bcbe">ADA_NOT_RENAMING</a>;
<a name="l04008"></a>04008 
<a name="l04009"></a>04009   name = <a class="code" href="gdbtypes_8c.html#a1bce8398d8a46f3d37bfc7e618ab9e9d">type_name_no_tag</a> (type);
<a name="l04010"></a>04010   <span class="keywordflow">if</span> (name == NULL)
<a name="l04011"></a>04011     <span class="keywordflow">return</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca6b0dcfc5b9c388cea30331121009bcbe">ADA_NOT_RENAMING</a>;
<a name="l04012"></a>04012   
<a name="l04013"></a>04013   name = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (name, <span class="stringliteral">&quot;___XR&quot;</span>);
<a name="l04014"></a>04014   <span class="keywordflow">if</span> (name == NULL)
<a name="l04015"></a>04015     <span class="keywordflow">return</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca6b0dcfc5b9c388cea30331121009bcbe">ADA_NOT_RENAMING</a>;
<a name="l04016"></a>04016   <span class="keywordflow">switch</span> (name[5])
<a name="l04017"></a>04017     {
<a name="l04018"></a>04018     <span class="keywordflow">case</span> <span class="charliteral">&#39;\0&#39;</span>:
<a name="l04019"></a>04019     <span class="keywordflow">case</span> <span class="charliteral">&#39;_&#39;</span>:
<a name="l04020"></a>04020       kind = <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca699f7a84941953710b7735d7bed1e4e3">ADA_OBJECT_RENAMING</a>;
<a name="l04021"></a>04021       <span class="keywordflow">break</span>;
<a name="l04022"></a>04022     <span class="keywordflow">case</span> <span class="charliteral">&#39;E&#39;</span>:
<a name="l04023"></a>04023       kind = <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca0237b62f7ad08b039e531d8222d15a01">ADA_EXCEPTION_RENAMING</a>;
<a name="l04024"></a>04024       <span class="keywordflow">break</span>;
<a name="l04025"></a>04025     <span class="keywordflow">case</span> <span class="charliteral">&#39;P&#39;</span>:
<a name="l04026"></a>04026       kind = <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5decab5eb427a2c80b470575aebb9d1a80e85">ADA_PACKAGE_RENAMING</a>;
<a name="l04027"></a>04027       <span class="keywordflow">break</span>;
<a name="l04028"></a>04028     <span class="keywordflow">case</span> <span class="charliteral">&#39;S&#39;</span>:
<a name="l04029"></a>04029       kind = <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5decad6cccf7cf2f9b8ff81ad105a7c94e97a">ADA_SUBPROGRAM_RENAMING</a>;
<a name="l04030"></a>04030       <span class="keywordflow">break</span>;
<a name="l04031"></a>04031     <span class="keywordflow">default</span>:
<a name="l04032"></a>04032       <span class="keywordflow">return</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca6b0dcfc5b9c388cea30331121009bcbe">ADA_NOT_RENAMING</a>;
<a name="l04033"></a>04033     }
<a name="l04034"></a>04034 
<a name="l04035"></a>04035   info = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, 0);
<a name="l04036"></a>04036   <span class="keywordflow">if</span> (info == NULL)
<a name="l04037"></a>04037     <span class="keywordflow">return</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca6b0dcfc5b9c388cea30331121009bcbe">ADA_NOT_RENAMING</a>;
<a name="l04038"></a>04038   <span class="keywordflow">if</span> (renamed_entity != NULL)
<a name="l04039"></a>04039     *renamed_entity = info;
<a name="l04040"></a>04040   suffix = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (info, <span class="stringliteral">&quot;___XE&quot;</span>);
<a name="l04041"></a>04041   <span class="keywordflow">if</span> (renaming_expr != NULL)
<a name="l04042"></a>04042     *renaming_expr = suffix + 5;
<a name="l04043"></a>04043   <span class="keywordflow">if</span> (suffix == NULL || suffix == info)
<a name="l04044"></a>04044     <span class="keywordflow">return</span> <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca6b0dcfc5b9c388cea30331121009bcbe">ADA_NOT_RENAMING</a>;
<a name="l04045"></a>04045   <span class="keywordflow">if</span> (len != NULL)
<a name="l04046"></a>04046     *len = suffix - info;
<a name="l04047"></a>04047   <span class="keywordflow">return</span> kind;
<a name="l04048"></a>04048 }
<a name="l04049"></a>04049 
<a name="l04050"></a>04050 <span class="comment">/* Compute the value of the given RENAMING_SYM, which is expected to</span>
<a name="l04051"></a>04051 <span class="comment">   be a symbol encoding a renaming expression.  BLOCK is the block</span>
<a name="l04052"></a>04052 <span class="comment">   used to evaluate the renaming.  */</span>
<a name="l04053"></a>04053 
<a name="l04054"></a>04054 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l04055"></a>04055 ada_read_renaming_var_value (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *renaming_sym,
<a name="l04056"></a>04056                              <span class="keyword">struct</span> block *block)
<a name="l04057"></a>04057 {
<a name="l04058"></a>04058   <span class="keyword">const</span> <span class="keywordtype">char</span> *sym_name;
<a name="l04059"></a>04059   <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *expr;
<a name="l04060"></a>04060   <span class="keyword">struct </span>value *value;
<a name="l04061"></a>04061   <span class="keyword">struct </span>cleanup *old_chain = NULL;
<a name="l04062"></a>04062 
<a name="l04063"></a>04063   sym_name = <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (renaming_sym);
<a name="l04064"></a>04064   expr = <a class="code" href="expression_8h.html#abdad295cc4b5351f6e6ec024ab665475">parse_exp_1</a> (&amp;sym_name, 0, block, 0);
<a name="l04065"></a>04065   old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="utils_8c.html#a6d8c21606d3f67a431a7bfbb1f47d12e">free_current_contents</a>, &amp;expr);
<a name="l04066"></a>04066   value = <a class="code" href="eval_8c.html#ab50151ccba3ea3184c114121d6bed422">evaluate_expression</a> (expr);
<a name="l04067"></a>04067 
<a name="l04068"></a>04068   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l04069"></a>04069   <span class="keywordflow">return</span> value;
<a name="l04070"></a>04070 }
<a name="l04071"></a>04071 
<a name="l04072"></a>04072 
<a name="l04073"></a>04073                                 <span class="comment">/* Evaluation: Function Calls */</span>
<a name="l04074"></a>04074 
<a name="l04075"></a>04075 <span class="comment">/* Return an lvalue containing the value VAL.  This is the identity on</span>
<a name="l04076"></a>04076 <span class="comment">   lvalues, and otherwise has the side-effect of allocating memory</span>
<a name="l04077"></a>04077 <span class="comment">   in the inferior where a copy of the value contents is copied.  */</span>
<a name="l04078"></a>04078 
<a name="l04079"></a>04079 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l04080"></a>04080 ensure_lval (<span class="keyword">struct</span> value *val)
<a name="l04081"></a>04081 {
<a name="l04082"></a>04082   <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (val) == <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>
<a name="l04083"></a>04083       || <a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (val) == <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba8dfa3647df3362b7c410ac31f6cde323">lval_internalvar</a>)
<a name="l04084"></a>04084     {
<a name="l04085"></a>04085       <span class="keywordtype">int</span> len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val)));
<a name="l04086"></a>04086       <span class="keyword">const</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr =
<a name="l04087"></a>04087         <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (<a class="code" href="valops_8c.html#a44cbd3d7cac10c3852c1f23cc47987c8">value_allocate_space_in_inferior</a> (len));
<a name="l04088"></a>04088 
<a name="l04089"></a>04089       <a class="code" href="value_8c.html#a33ecd4bc76c6629df42dafee1158307d">set_value_address</a> (val, addr);
<a name="l04090"></a>04090       <a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (val) = <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>;
<a name="l04091"></a>04091       <a class="code" href="corefile_8c.html#a05c568c157071d9349667fab589228e5">write_memory</a> (addr, <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (val), len);
<a name="l04092"></a>04092     }
<a name="l04093"></a>04093 
<a name="l04094"></a>04094   <span class="keywordflow">return</span> val;
<a name="l04095"></a>04095 }
<a name="l04096"></a>04096 
<a name="l04097"></a>04097 <span class="comment">/* Return the value ACTUAL, converted to be an appropriate value for a</span>
<a name="l04098"></a>04098 <span class="comment">   formal of type FORMAL_TYPE.  Use *SP as a stack pointer for</span>
<a name="l04099"></a>04099 <span class="comment">   allocating any necessary descriptors (fat pointers), or copies of</span>
<a name="l04100"></a>04100 <span class="comment">   values not residing in memory, updating it as needed.  */</span>
<a name="l04101"></a>04101 
<a name="l04102"></a>04102 <span class="keyword">struct </span>value *
<a name="l04103"></a><a class="code" href="ada-lang_8h.html#a3d61b5cad57a5e2ce601121e9ed67910">04103</a> <a class="code" href="ada-lang_8c.html#a3d61b5cad57a5e2ce601121e9ed67910">ada_convert_actual</a> (<span class="keyword">struct</span> value *actual, <span class="keyword">struct</span> type *formal_type0)
<a name="l04104"></a>04104 {
<a name="l04105"></a>04105   <span class="keyword">struct </span>type *actual_type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (actual));
<a name="l04106"></a>04106   <span class="keyword">struct </span>type *formal_type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (formal_type0);
<a name="l04107"></a>04107   <span class="keyword">struct </span>type *formal_target =
<a name="l04108"></a>04108     <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (formal_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l04109"></a>04109     ? <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (formal_type)) : formal_type;
<a name="l04110"></a>04110   <span class="keyword">struct </span>type *actual_target =
<a name="l04111"></a>04111     <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (actual_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l04112"></a>04112     ? <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (actual_type)) : actual_type;
<a name="l04113"></a>04113 
<a name="l04114"></a>04114   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (formal_target)
<a name="l04115"></a>04115       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (actual_target) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l04116"></a>04116     <span class="keywordflow">return</span> make_array_descriptor (formal_type, actual);
<a name="l04117"></a>04117   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (formal_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l04118"></a>04118            || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (formal_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l04119"></a>04119     {
<a name="l04120"></a>04120       <span class="keyword">struct </span>value *result;
<a name="l04121"></a>04121 
<a name="l04122"></a>04122       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (formal_target) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l04123"></a>04123           &amp;&amp; <a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (actual_target))
<a name="l04124"></a>04124         result = desc_data (actual);
<a name="l04125"></a>04125       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (actual_type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l04126"></a>04126         {
<a name="l04127"></a>04127           <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (actual) != <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>)
<a name="l04128"></a>04128             {
<a name="l04129"></a>04129               <span class="keyword">struct </span>value *val;
<a name="l04130"></a>04130 
<a name="l04131"></a>04131               actual_type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (actual));
<a name="l04132"></a>04132               val = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (actual_type);
<a name="l04133"></a>04133               <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> ((<span class="keywordtype">char</span> *) <a class="code" href="value_8c.html#a9f59e572fabef6e1905632fb81cc00e1">value_contents_raw</a> (val),
<a name="l04134"></a>04134                       (<span class="keywordtype">char</span> *) <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (actual),
<a name="l04135"></a>04135                       <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (actual_type));
<a name="l04136"></a>04136               actual = ensure_lval (val);
<a name="l04137"></a>04137             }
<a name="l04138"></a>04138           result = <a class="code" href="valops_8c.html#a29bc320305726a3cbf324189df2ca772">value_addr</a> (actual);
<a name="l04139"></a>04139         }
<a name="l04140"></a>04140       <span class="keywordflow">else</span>
<a name="l04141"></a>04141         <span class="keywordflow">return</span> actual;
<a name="l04142"></a>04142       <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a05b825cece89f641f79b46a16afb9425">value_cast_pointers</a> (formal_type, result, 0);
<a name="l04143"></a>04143     }
<a name="l04144"></a>04144   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (actual_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l04145"></a>04145     <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a917a1ba2a6b58d43803a1f999164295b">ada_value_ind</a> (actual);
<a name="l04146"></a>04146 
<a name="l04147"></a>04147   <span class="keywordflow">return</span> actual;
<a name="l04148"></a>04148 }
<a name="l04149"></a>04149 
<a name="l04150"></a>04150 <span class="comment">/* Convert VALUE (which must be an address) to a CORE_ADDR that is a pointer of</span>
<a name="l04151"></a>04151 <span class="comment">   type TYPE.  This is usually an inefficient no-op except on some targets</span>
<a name="l04152"></a>04152 <span class="comment">   (such as AVR) where the representation of a pointer and an address</span>
<a name="l04153"></a>04153 <span class="comment">   differs.  */</span>
<a name="l04154"></a>04154 
<a name="l04155"></a>04155 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l04156"></a>04156 value_pointer (<span class="keyword">struct</span> value *value, <span class="keyword">struct</span> type *type)
<a name="l04157"></a>04157 {
<a name="l04158"></a>04158   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="gdbtypes_8c.html#a84ca61a6d58c2bd2c7dcedf19d56a39d">get_type_arch</a> (type);
<a name="l04159"></a>04159   <span class="keywordtype">unsigned</span> len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type);
<a name="l04160"></a>04160   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf = alloca (len);
<a name="l04161"></a>04161   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr;
<a name="l04162"></a>04162 
<a name="l04163"></a>04163   addr = <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (value);
<a name="l04164"></a>04164   <a class="code" href="gdbarch_8c.html#aa6e70eb13dad5ac1e181afa8efcaa63a">gdbarch_address_to_pointer</a> (gdbarch, type, buf, addr);
<a name="l04165"></a>04165   addr = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf, len, <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch));
<a name="l04166"></a>04166   <span class="keywordflow">return</span> addr;
<a name="l04167"></a>04167 }
<a name="l04168"></a>04168 
<a name="l04169"></a>04169 
<a name="l04170"></a>04170 <span class="comment">/* Push a descriptor of type TYPE for array value ARR on the stack at</span>
<a name="l04171"></a>04171 <span class="comment">   *SP, updating *SP to reflect the new descriptor.  Return either</span>
<a name="l04172"></a>04172 <span class="comment">   an lvalue representing the new descriptor, or (if TYPE is a pointer-</span>
<a name="l04173"></a>04173 <span class="comment">   to-descriptor type rather than a descriptor type), a struct value *</span>
<a name="l04174"></a>04174 <span class="comment">   representing a pointer to this descriptor.  */</span>
<a name="l04175"></a>04175 
<a name="l04176"></a>04176 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l04177"></a>04177 make_array_descriptor (<span class="keyword">struct</span> type *type, <span class="keyword">struct</span> value *arr)
<a name="l04178"></a>04178 {
<a name="l04179"></a>04179   <span class="keyword">struct </span>type *bounds_type = desc_bounds_type (type);
<a name="l04180"></a>04180   <span class="keyword">struct </span>type *desc_type = desc_base_type (type);
<a name="l04181"></a>04181   <span class="keyword">struct </span>value *descriptor = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (desc_type);
<a name="l04182"></a>04182   <span class="keyword">struct </span>value *bounds = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (bounds_type);
<a name="l04183"></a>04183   <span class="keywordtype">int</span> i;
<a name="l04184"></a>04184 
<a name="l04185"></a>04185   <span class="keywordflow">for</span> (i = <a class="code" href="ada-lang_8c.html#ae9a1f2e16ad116a02636b91afd809c4b">ada_array_arity</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arr)));
<a name="l04186"></a>04186        i &gt; 0; i -= 1)
<a name="l04187"></a>04187     {
<a name="l04188"></a>04188       <a class="code" href="value_8c.html#a52aaf72536254f2f365df4d9e8f69a5e">modify_field</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (bounds), <a class="code" href="value_8c.html#a13d7c6c06f661cae284e575c50647344">value_contents_writeable</a> (bounds),
<a name="l04189"></a>04189                     ada_array_bound (arr, i, 0),
<a name="l04190"></a>04190                     desc_bound_bitpos (bounds_type, i, 0),
<a name="l04191"></a>04191                     desc_bound_bitsize (bounds_type, i, 0));
<a name="l04192"></a>04192       <a class="code" href="value_8c.html#a52aaf72536254f2f365df4d9e8f69a5e">modify_field</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (bounds), <a class="code" href="value_8c.html#a13d7c6c06f661cae284e575c50647344">value_contents_writeable</a> (bounds),
<a name="l04193"></a>04193                     ada_array_bound (arr, i, 1),
<a name="l04194"></a>04194                     desc_bound_bitpos (bounds_type, i, 1),
<a name="l04195"></a>04195                     desc_bound_bitsize (bounds_type, i, 1));
<a name="l04196"></a>04196     }
<a name="l04197"></a>04197 
<a name="l04198"></a>04198   bounds = ensure_lval (bounds);
<a name="l04199"></a>04199 
<a name="l04200"></a>04200   <a class="code" href="value_8c.html#a52aaf72536254f2f365df4d9e8f69a5e">modify_field</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (descriptor),
<a name="l04201"></a>04201                 <a class="code" href="value_8c.html#a13d7c6c06f661cae284e575c50647344">value_contents_writeable</a> (descriptor),
<a name="l04202"></a>04202                 value_pointer (ensure_lval (arr),
<a name="l04203"></a>04203                                <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (desc_type, 0)),
<a name="l04204"></a>04204                 fat_pntr_data_bitpos (desc_type),
<a name="l04205"></a>04205                 fat_pntr_data_bitsize (desc_type));
<a name="l04206"></a>04206 
<a name="l04207"></a>04207   <a class="code" href="value_8c.html#a52aaf72536254f2f365df4d9e8f69a5e">modify_field</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (descriptor),
<a name="l04208"></a>04208                 <a class="code" href="value_8c.html#a13d7c6c06f661cae284e575c50647344">value_contents_writeable</a> (descriptor),
<a name="l04209"></a>04209                 value_pointer (bounds,
<a name="l04210"></a>04210                                <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (desc_type, 1)),
<a name="l04211"></a>04211                 fat_pntr_bounds_bitpos (desc_type),
<a name="l04212"></a>04212                 fat_pntr_bounds_bitsize (desc_type));
<a name="l04213"></a>04213 
<a name="l04214"></a>04214   descriptor = ensure_lval (descriptor);
<a name="l04215"></a>04215 
<a name="l04216"></a>04216   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l04217"></a>04217     <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a29bc320305726a3cbf324189df2ca772">value_addr</a> (descriptor);
<a name="l04218"></a>04218   <span class="keywordflow">else</span>
<a name="l04219"></a>04219     <span class="keywordflow">return</span> descriptor;
<a name="l04220"></a>04220 }
<a name="l04221"></a>04221 
<a name="l04222"></a>04222 <span class="comment">/* Dummy definitions for an experimental caching module that is not</span>
<a name="l04223"></a>04223 <span class="comment"> * used in the public sources.  */</span>
<a name="l04224"></a>04224 
<a name="l04225"></a>04225 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04226"></a>04226 lookup_cached_symbol (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> <span class="keyword">namespace</span>,
<a name="l04227"></a>04227                       <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> **sym, <span class="keyword">struct</span> block **block)
<a name="l04228"></a>04228 {
<a name="l04229"></a>04229   <span class="keywordflow">return</span> 0;
<a name="l04230"></a>04230 }
<a name="l04231"></a>04231 
<a name="l04232"></a>04232 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04233"></a>04233 cache_symbol (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> <span class="keyword">namespace</span>, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym,
<a name="l04234"></a>04234               <span class="keyword">const</span> <span class="keyword">struct</span> block *block)
<a name="l04235"></a>04235 {
<a name="l04236"></a>04236 }
<a name="l04237"></a>04237 
<a name="l04238"></a>04238                                 <span class="comment">/* Symbol Lookup */</span>
<a name="l04239"></a>04239 
<a name="l04240"></a>04240 <span class="comment">/* Return nonzero if wild matching should be used when searching for</span>
<a name="l04241"></a>04241 <span class="comment">   all symbols matching LOOKUP_NAME.</span>
<a name="l04242"></a>04242 <span class="comment"></span>
<a name="l04243"></a>04243 <span class="comment">   LOOKUP_NAME is expected to be a symbol name after transformation</span>
<a name="l04244"></a>04244 <span class="comment">   for Ada lookups (see ada_name_for_lookup).  */</span>
<a name="l04245"></a>04245 
<a name="l04246"></a>04246 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04247"></a>04247 should_use_wild_match (<span class="keyword">const</span> <span class="keywordtype">char</span> *lookup_name)
<a name="l04248"></a>04248 {
<a name="l04249"></a>04249   <span class="keywordflow">return</span> (<a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (lookup_name, <span class="stringliteral">&quot;__&quot;</span>) == NULL);
<a name="l04250"></a>04250 }
<a name="l04251"></a>04251 
<a name="l04252"></a>04252 <span class="comment">/* Return the result of a standard (literal, C-like) lookup of NAME in</span>
<a name="l04253"></a>04253 <span class="comment">   given DOMAIN, visible from lexical block BLOCK.  */</span>
<a name="l04254"></a>04254 
<a name="l04255"></a>04255 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *
<a name="l04256"></a>04256 standard_lookup (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keyword">struct</span> block *block,
<a name="l04257"></a>04257                  <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> domain)
<a name="l04258"></a>04258 {
<a name="l04259"></a>04259   <span class="comment">/* Initialize it just to avoid a GCC false warning.  */</span>
<a name="l04260"></a>04260   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym = NULL;
<a name="l04261"></a>04261 
<a name="l04262"></a>04262   <span class="keywordflow">if</span> (lookup_cached_symbol (name, domain, &amp;sym, NULL))
<a name="l04263"></a>04263     <span class="keywordflow">return</span> sym;
<a name="l04264"></a>04264   sym = <a class="code" href="symtab_8c.html#af1c76d61285ee37013eddb8d058996cb">lookup_symbol_in_language</a> (name, block, domain, <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202ad300f80a4c96edb04defba2280620a49">language_c</a>, 0);
<a name="l04265"></a>04265   cache_symbol (name, domain, sym, <a class="code" href="parser-defs_8h.html#a4b63b4fd2a25331b4da688f1936187a6">block_found</a>);
<a name="l04266"></a>04266   <span class="keywordflow">return</span> sym;
<a name="l04267"></a>04267 }
<a name="l04268"></a>04268 
<a name="l04269"></a>04269 
<a name="l04270"></a>04270 <span class="comment">/* Non-zero iff there is at least one non-function/non-enumeral symbol</span>
<a name="l04271"></a>04271 <span class="comment">   in the symbol fields of SYMS[0..N-1].  We treat enumerals as functions, </span>
<a name="l04272"></a>04272 <span class="comment">   since they contend in overloading in the same way.  */</span>
<a name="l04273"></a>04273 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04274"></a>04274 is_nonfunction (<span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a> syms[], <span class="keywordtype">int</span> n)
<a name="l04275"></a>04275 {
<a name="l04276"></a>04276   <span class="keywordtype">int</span> i;
<a name="l04277"></a>04277 
<a name="l04278"></a>04278   <span class="keywordflow">for</span> (i = 0; i &lt; n; i += 1)
<a name="l04279"></a>04279     <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[i].sym)) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>
<a name="l04280"></a>04280         &amp;&amp; (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[i].sym)) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>
<a name="l04281"></a>04281             || <a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (syms[i].sym) != <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a5268309778a6727d08106ff9f2966e54">LOC_CONST</a>))
<a name="l04282"></a>04282       <span class="keywordflow">return</span> 1;
<a name="l04283"></a>04283 
<a name="l04284"></a>04284   <span class="keywordflow">return</span> 0;
<a name="l04285"></a>04285 }
<a name="l04286"></a>04286 
<a name="l04287"></a>04287 <span class="comment">/* If true (non-zero), then TYPE0 and TYPE1 represent equivalent</span>
<a name="l04288"></a>04288 <span class="comment">   struct types.  Otherwise, they may not.  */</span>
<a name="l04289"></a>04289 
<a name="l04290"></a>04290 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04291"></a>04291 equiv_types (<span class="keyword">struct</span> type *type0, <span class="keyword">struct</span> type *type1)
<a name="l04292"></a>04292 {
<a name="l04293"></a>04293   <span class="keywordflow">if</span> (type0 == type1)
<a name="l04294"></a>04294     <span class="keywordflow">return</span> 1;
<a name="l04295"></a>04295   <span class="keywordflow">if</span> (type0 == NULL || type1 == NULL
<a name="l04296"></a>04296       || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type0) != <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type1))
<a name="l04297"></a>04297     <span class="keywordflow">return</span> 0;
<a name="l04298"></a>04298   <span class="keywordflow">if</span> ((<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type0) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l04299"></a>04299        || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type0) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>)
<a name="l04300"></a>04300       &amp;&amp; <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type0) != NULL &amp;&amp; <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type1) != NULL
<a name="l04301"></a>04301       &amp;&amp; strcmp (<a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type0), <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type1)) == 0)
<a name="l04302"></a>04302     <span class="keywordflow">return</span> 1;
<a name="l04303"></a>04303 
<a name="l04304"></a>04304   <span class="keywordflow">return</span> 0;
<a name="l04305"></a>04305 }
<a name="l04306"></a>04306 
<a name="l04307"></a>04307 <span class="comment">/* True iff SYM0 represents the same entity as SYM1, or one that is</span>
<a name="l04308"></a>04308 <span class="comment">   no more defined than that of SYM1.  */</span>
<a name="l04309"></a>04309 
<a name="l04310"></a>04310 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04311"></a>04311 lesseq_defined_than (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym0, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym1)
<a name="l04312"></a>04312 {
<a name="l04313"></a>04313   <span class="keywordflow">if</span> (sym0 == sym1)
<a name="l04314"></a>04314     <span class="keywordflow">return</span> 1;
<a name="l04315"></a>04315   <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym0) != <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym1)
<a name="l04316"></a>04316       || <a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym0) != <a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym1))
<a name="l04317"></a>04317     <span class="keywordflow">return</span> 0;
<a name="l04318"></a>04318 
<a name="l04319"></a>04319   <span class="keywordflow">switch</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym0))
<a name="l04320"></a>04320     {
<a name="l04321"></a>04321     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a8f175362d642a65c7ee6e944ffd59a3d">LOC_UNDEF</a>:
<a name="l04322"></a>04322       <span class="keywordflow">return</span> 1;
<a name="l04323"></a>04323     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>:
<a name="l04324"></a>04324       {
<a name="l04325"></a>04325         <span class="keyword">struct </span>type *type0 = <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym0);
<a name="l04326"></a>04326         <span class="keyword">struct </span>type *type1 = <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym1);
<a name="l04327"></a>04327         <span class="keyword">const</span> <span class="keywordtype">char</span> *name0 = <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym0);
<a name="l04328"></a>04328         <span class="keyword">const</span> <span class="keywordtype">char</span> *name1 = <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym1);
<a name="l04329"></a>04329         <span class="keywordtype">int</span> len0 = strlen (name0);
<a name="l04330"></a>04330 
<a name="l04331"></a>04331         <span class="keywordflow">return</span>
<a name="l04332"></a>04332           <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type0) == <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type1)
<a name="l04333"></a>04333           &amp;&amp; (equiv_types (type0, type1)
<a name="l04334"></a>04334               || (len0 &lt; strlen (name1) &amp;&amp; strncmp (name0, name1, len0) == 0
<a name="l04335"></a>04335                   &amp;&amp; strncmp (name1 + len0, <span class="stringliteral">&quot;___XV&quot;</span>, 5) == 0));
<a name="l04336"></a>04336       }
<a name="l04337"></a>04337     <span class="keywordflow">case</span> <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a5268309778a6727d08106ff9f2966e54">LOC_CONST</a>:
<a name="l04338"></a>04338       <span class="keywordflow">return</span> <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (sym0) == <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (sym1)
<a name="l04339"></a>04339         &amp;&amp; equiv_types (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym0), <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym1));
<a name="l04340"></a>04340     <span class="keywordflow">default</span>:
<a name="l04341"></a>04341       <span class="keywordflow">return</span> 0;
<a name="l04342"></a>04342     }
<a name="l04343"></a>04343 }
<a name="l04344"></a>04344 
<a name="l04345"></a>04345 <span class="comment">/* Append (SYM,BLOCK,SYMTAB) to the end of the array of struct ada_symbol_info</span>
<a name="l04346"></a>04346 <span class="comment">   records in OBSTACKP.  Do nothing if SYM is a duplicate.  */</span>
<a name="l04347"></a>04347 
<a name="l04348"></a>04348 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04349"></a>04349 add_defn_to_vec (<span class="keyword">struct</span> obstack *obstackp,
<a name="l04350"></a>04350                  <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym,
<a name="l04351"></a>04351                  <span class="keyword">struct</span> block *block)
<a name="l04352"></a>04352 {
<a name="l04353"></a>04353   <span class="keywordtype">int</span> i;
<a name="l04354"></a>04354   <span class="keyword">struct </span><a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *prevDefns = defns_collected (obstackp, 0);
<a name="l04355"></a>04355 
<a name="l04356"></a>04356   <span class="comment">/* Do not try to complete stub types, as the debugger is probably</span>
<a name="l04357"></a>04357 <span class="comment">     already scanning all symbols matching a certain name at the</span>
<a name="l04358"></a>04358 <span class="comment">     time when this function is called.  Trying to replace the stub</span>
<a name="l04359"></a>04359 <span class="comment">     type by its associated full type will cause us to restart a scan</span>
<a name="l04360"></a>04360 <span class="comment">     which may lead to an infinite recursion.  Instead, the client</span>
<a name="l04361"></a>04361 <span class="comment">     collecting the matching symbols will end up collecting several</span>
<a name="l04362"></a>04362 <span class="comment">     matches, with at least one of them complete.  It can then filter</span>
<a name="l04363"></a>04363 <span class="comment">     out the stub ones if needed.  */</span>
<a name="l04364"></a>04364 
<a name="l04365"></a>04365   <span class="keywordflow">for</span> (i = num_defns_collected (obstackp) - 1; i &gt;= 0; i -= 1)
<a name="l04366"></a>04366     {
<a name="l04367"></a>04367       <span class="keywordflow">if</span> (lesseq_defined_than (sym, prevDefns[i].sym))
<a name="l04368"></a>04368         <span class="keywordflow">return</span>;
<a name="l04369"></a>04369       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lesseq_defined_than (prevDefns[i].sym, sym))
<a name="l04370"></a>04370         {
<a name="l04371"></a>04371           prevDefns[i].<a class="code" href="structada__symbol__info.html#ab424e8140f59e695fcb43c8d1c818728">sym</a> = <a class="code" href="structada__symbol__info.html#ab424e8140f59e695fcb43c8d1c818728">sym</a>;
<a name="l04372"></a>04372           prevDefns[i].<a class="code" href="structada__symbol__info.html#a42d6b64e717f920614470bc34c421b76">block</a> = <a class="code" href="structada__symbol__info.html#a42d6b64e717f920614470bc34c421b76">block</a>;
<a name="l04373"></a>04373           <span class="keywordflow">return</span>;
<a name="l04374"></a>04374         }
<a name="l04375"></a>04375     }
<a name="l04376"></a>04376 
<a name="l04377"></a>04377   {
<a name="l04378"></a>04378     <span class="keyword">struct </span><a class="code" href="structada__symbol__info.html">ada_symbol_info</a> info;
<a name="l04379"></a>04379 
<a name="l04380"></a>04380     info.<a class="code" href="structada__symbol__info.html#ab424e8140f59e695fcb43c8d1c818728">sym</a> = <a class="code" href="structada__symbol__info.html#ab424e8140f59e695fcb43c8d1c818728">sym</a>;
<a name="l04381"></a>04381     info.block = <a class="code" href="structada__symbol__info.html#a42d6b64e717f920614470bc34c421b76">block</a>;
<a name="l04382"></a>04382     obstack_grow (obstackp, &amp;info, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a>));
<a name="l04383"></a>04383   }
<a name="l04384"></a>04384 }
<a name="l04385"></a>04385 
<a name="l04386"></a>04386 <span class="comment">/* Number of ada_symbol_info structures currently collected in </span>
<a name="l04387"></a>04387 <span class="comment">   current vector in *OBSTACKP.  */</span>
<a name="l04388"></a>04388 
<a name="l04389"></a>04389 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04390"></a>04390 num_defns_collected (<span class="keyword">struct</span> obstack *obstackp)
<a name="l04391"></a>04391 {
<a name="l04392"></a>04392   <span class="keywordflow">return</span> obstack_object_size (obstackp) / <span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structada__symbol__info.html">ada_symbol_info</a>);
<a name="l04393"></a>04393 }
<a name="l04394"></a>04394 
<a name="l04395"></a>04395 <span class="comment">/* Vector of ada_symbol_info structures currently collected in current </span>
<a name="l04396"></a>04396 <span class="comment">   vector in *OBSTACKP.  If FINISH, close off the vector and return</span>
<a name="l04397"></a>04397 <span class="comment">   its final address.  */</span>
<a name="l04398"></a>04398 
<a name="l04399"></a>04399 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *
<a name="l04400"></a>04400 defns_collected (<span class="keyword">struct</span> obstack *obstackp, <span class="keywordtype">int</span> finish)
<a name="l04401"></a>04401 {
<a name="l04402"></a>04402   <span class="keywordflow">if</span> (finish)
<a name="l04403"></a>04403     <span class="keywordflow">return</span> obstack_finish (obstackp);
<a name="l04404"></a>04404   <span class="keywordflow">else</span>
<a name="l04405"></a>04405     <span class="keywordflow">return</span> (<span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *) obstack_base (obstackp);
<a name="l04406"></a>04406 }
<a name="l04407"></a>04407 
<a name="l04408"></a>04408 <span class="comment">/* Return a bound minimal symbol matching NAME according to Ada</span>
<a name="l04409"></a>04409 <span class="comment">   decoding rules.  Returns an invalid symbol if there is no such</span>
<a name="l04410"></a>04410 <span class="comment">   minimal symbol.  Names prefixed with &quot;standard__&quot; are handled</span>
<a name="l04411"></a>04411 <span class="comment">   specially: &quot;standard__&quot; is first stripped off, and only static and</span>
<a name="l04412"></a>04412 <span class="comment">   global symbols are searched.  */</span>
<a name="l04413"></a>04413 
<a name="l04414"></a>04414 <span class="keyword">struct </span><a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol</a>
<a name="l04415"></a><a class="code" href="ada-lang_8h.html#a6d2055d15ffe9c90327870011aff27d7">04415</a> <a class="code" href="ada-lang_8c.html#aa14ca9c1749c6575090f3b4561f29703">ada_lookup_simple_minsym</a> (<a class="code" href="p-lang_8h.html#a21296fc6f36ba2fc4d9780fdd126acb5">const</a> char *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>)
<a name="l04416"></a>04416 {
<a name="l04417"></a>04417   <span class="keyword">struct </span><a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol</a> result;
<a name="l04418"></a>04418   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>;
<a name="l04419"></a>04419   <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *msymbol;
<a name="l04420"></a>04420   <span class="keyword">const</span> <span class="keywordtype">int</span> wild_match_p = should_use_wild_match (name);
<a name="l04421"></a>04421 
<a name="l04422"></a>04422   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;result, 0, <span class="keyword">sizeof</span> (result));
<a name="l04423"></a>04423 
<a name="l04424"></a>04424   <span class="comment">/* Special case: If the user specifies a symbol name inside package</span>
<a name="l04425"></a>04425 <span class="comment">     Standard, do a non-wild matching of the symbol name without</span>
<a name="l04426"></a>04426 <span class="comment">     the &quot;standard__&quot; prefix.  This was primarily introduced in order</span>
<a name="l04427"></a>04427 <span class="comment">     to allow the user to specifically access the standard exceptions</span>
<a name="l04428"></a>04428 <span class="comment">     using, for instance, Standard.Constraint_Error when Constraint_Error</span>
<a name="l04429"></a>04429 <span class="comment">     is ambiguous (due to the user defining its own Constraint_Error</span>
<a name="l04430"></a>04430 <span class="comment">     entity inside its program).  */</span>
<a name="l04431"></a>04431   <span class="keywordflow">if</span> (strncmp (name, <span class="stringliteral">&quot;standard__&quot;</span>, <span class="keyword">sizeof</span> (<span class="stringliteral">&quot;standard__&quot;</span>) - 1) == 0)
<a name="l04432"></a>04432     name += <span class="keyword">sizeof</span> (<span class="stringliteral">&quot;standard__&quot;</span>) - 1;
<a name="l04433"></a>04433 
<a name="l04434"></a>04434   <a class="code" href="objfiles_8h.html#a3d08aae2073557e019d75ab37f8182d8">ALL_MSYMBOLS</a> (objfile, msymbol)
<a name="l04435"></a>04435   {
<a name="l04436"></a>04436     <span class="keywordflow">if</span> (match_name (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (msymbol), name, wild_match_p)
<a name="l04437"></a>04437         &amp;&amp; <a class="code" href="symtab_8h.html#a1d0b27d446f2622f464727b6a06ae263">MSYMBOL_TYPE</a> (msymbol) != <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036aa6ace68113ace3aafa25e705d9fce85d">mst_solib_trampoline</a>)
<a name="l04438"></a>04438       {
<a name="l04439"></a>04439         result.<a class="code" href="structbound__minimal__symbol.html#aabff08898c1d96d6c68a95f35b635214">minsym</a> = msymbol;
<a name="l04440"></a>04440         result.<a class="code" href="structbound__minimal__symbol.html#a070e0e47d191675f0f4892e0b321d663">objfile</a> = objfile;
<a name="l04441"></a>04441         <span class="keywordflow">break</span>;
<a name="l04442"></a>04442       }
<a name="l04443"></a>04443   }
<a name="l04444"></a>04444 
<a name="l04445"></a>04445   <span class="keywordflow">return</span> result;
<a name="l04446"></a>04446 }
<a name="l04447"></a>04447 
<a name="l04448"></a>04448 <span class="comment">/* For all subprograms that statically enclose the subprogram of the</span>
<a name="l04449"></a>04449 <span class="comment">   selected frame, add symbols matching identifier NAME in DOMAIN</span>
<a name="l04450"></a>04450 <span class="comment">   and their blocks to the list of data in OBSTACKP, as for</span>
<a name="l04451"></a>04451 <span class="comment">   ada_add_block_symbols (q.v.).   If WILD_MATCH_P, treat as NAME</span>
<a name="l04452"></a>04452 <span class="comment">   with a wildcard prefix.  */</span>
<a name="l04453"></a>04453 
<a name="l04454"></a>04454 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04455"></a>04455 add_symbols_from_enclosing_procs (<span class="keyword">struct</span> obstack *obstackp,
<a name="l04456"></a>04456                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> <span class="keyword">namespace</span>,
<a name="l04457"></a>04457                                   <span class="keywordtype">int</span> wild_match_p)
<a name="l04458"></a>04458 {
<a name="l04459"></a>04459 }
<a name="l04460"></a>04460 
<a name="l04461"></a>04461 <span class="comment">/* True if TYPE is definitely an artificial type supplied to a symbol</span>
<a name="l04462"></a>04462 <span class="comment">   for which no debugging information was given in the symbol file.  */</span>
<a name="l04463"></a>04463 
<a name="l04464"></a>04464 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04465"></a>04465 is_nondebugging_type (<span class="keyword">struct</span> type *type)
<a name="l04466"></a>04466 {
<a name="l04467"></a>04467   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type);
<a name="l04468"></a>04468 
<a name="l04469"></a>04469   <span class="keywordflow">return</span> (name != NULL &amp;&amp; strcmp (name, <span class="stringliteral">&quot;&lt;variable, no debug info&gt;&quot;</span>) == 0);
<a name="l04470"></a>04470 }
<a name="l04471"></a>04471 
<a name="l04472"></a>04472 <span class="comment">/* Return nonzero if TYPE1 and TYPE2 are two enumeration types</span>
<a name="l04473"></a>04473 <span class="comment">   that are deemed &quot;identical&quot; for practical purposes.</span>
<a name="l04474"></a>04474 <span class="comment"></span>
<a name="l04475"></a>04475 <span class="comment">   This function assumes that TYPE1 and TYPE2 are both TYPE_CODE_ENUM</span>
<a name="l04476"></a>04476 <span class="comment">   types and that their number of enumerals is identical (in other</span>
<a name="l04477"></a>04477 <span class="comment">   words, TYPE_NFIELDS (type1) == TYPE_NFIELDS (type2)).  */</span>
<a name="l04478"></a>04478 
<a name="l04479"></a>04479 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04480"></a>04480 ada_identical_enum_types_p (<span class="keyword">struct</span> type *type1, <span class="keyword">struct</span> type *type2)
<a name="l04481"></a>04481 {
<a name="l04482"></a>04482   <span class="keywordtype">int</span> i;
<a name="l04483"></a>04483 
<a name="l04484"></a>04484   <span class="comment">/* The heuristic we use here is fairly conservative.  We consider</span>
<a name="l04485"></a>04485 <span class="comment">     that 2 enumerate types are identical if they have the same</span>
<a name="l04486"></a>04486 <span class="comment">     number of enumerals and that all enumerals have the same</span>
<a name="l04487"></a>04487 <span class="comment">     underlying value and name.  */</span>
<a name="l04488"></a>04488 
<a name="l04489"></a>04489   <span class="comment">/* All enums in the type should have an identical underlying value.  */</span>
<a name="l04490"></a>04490   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type1); i++)
<a name="l04491"></a>04491     <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a2ab26ef1ee13615e128e3cb3cd058a5c">TYPE_FIELD_ENUMVAL</a> (type1, i) != <a class="code" href="gdbtypes_8h.html#a2ab26ef1ee13615e128e3cb3cd058a5c">TYPE_FIELD_ENUMVAL</a> (type2, i))
<a name="l04492"></a>04492       <span class="keywordflow">return</span> 0;
<a name="l04493"></a>04493 
<a name="l04494"></a>04494   <span class="comment">/* All enumerals should also have the same name (modulo any numerical</span>
<a name="l04495"></a>04495 <span class="comment">     suffix).  */</span>
<a name="l04496"></a>04496   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type1); i++)
<a name="l04497"></a>04497     {
<a name="l04498"></a>04498       <span class="keyword">const</span> <span class="keywordtype">char</span> *name_1 = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type1, i);
<a name="l04499"></a>04499       <span class="keyword">const</span> <span class="keywordtype">char</span> *name_2 = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type2, i);
<a name="l04500"></a>04500       <span class="keywordtype">int</span> len_1 = strlen (name_1);
<a name="l04501"></a>04501       <span class="keywordtype">int</span> len_2 = strlen (name_2);
<a name="l04502"></a>04502 
<a name="l04503"></a>04503       ada_remove_trailing_digits (<a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type1, i), &amp;len_1);
<a name="l04504"></a>04504       ada_remove_trailing_digits (<a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type2, i), &amp;len_2);
<a name="l04505"></a>04505       <span class="keywordflow">if</span> (len_1 != len_2
<a name="l04506"></a>04506           || strncmp (<a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type1, i),
<a name="l04507"></a>04507                       <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type2, i),
<a name="l04508"></a>04508                       len_1) != 0)
<a name="l04509"></a>04509         <span class="keywordflow">return</span> 0;
<a name="l04510"></a>04510     }
<a name="l04511"></a>04511 
<a name="l04512"></a>04512   <span class="keywordflow">return</span> 1;
<a name="l04513"></a>04513 }
<a name="l04514"></a>04514 
<a name="l04515"></a>04515 <span class="comment">/* Return nonzero if all the symbols in SYMS are all enumeral symbols</span>
<a name="l04516"></a>04516 <span class="comment">   that are deemed &quot;identical&quot; for practical purposes.  Sometimes,</span>
<a name="l04517"></a>04517 <span class="comment">   enumerals are not strictly identical, but their types are so similar</span>
<a name="l04518"></a>04518 <span class="comment">   that they can be considered identical.</span>
<a name="l04519"></a>04519 <span class="comment"></span>
<a name="l04520"></a>04520 <span class="comment">   For instance, consider the following code:</span>
<a name="l04521"></a>04521 <span class="comment"></span>
<a name="l04522"></a>04522 <span class="comment">      type Color is (Black, Red, Green, Blue, White);</span>
<a name="l04523"></a>04523 <span class="comment">      type RGB_Color is new Color range Red .. Blue;</span>
<a name="l04524"></a>04524 <span class="comment"></span>
<a name="l04525"></a>04525 <span class="comment">   Type RGB_Color is a subrange of an implicit type which is a copy</span>
<a name="l04526"></a>04526 <span class="comment">   of type Color. If we call that implicit type RGB_ColorB (&quot;B&quot; is</span>
<a name="l04527"></a>04527 <span class="comment">   for &quot;Base Type&quot;), then type RGB_ColorB is a copy of type Color.</span>
<a name="l04528"></a>04528 <span class="comment">   As a result, when an expression references any of the enumeral</span>
<a name="l04529"></a>04529 <span class="comment">   by name (Eg. &quot;print green&quot;), the expression is technically</span>
<a name="l04530"></a>04530 <span class="comment">   ambiguous and the user should be asked to disambiguate. But</span>
<a name="l04531"></a>04531 <span class="comment">   doing so would only hinder the user, since it wouldn&#39;t matter</span>
<a name="l04532"></a>04532 <span class="comment">   what choice he makes, the outcome would always be the same.</span>
<a name="l04533"></a>04533 <span class="comment">   So, for practical purposes, we consider them as the same.  */</span>
<a name="l04534"></a>04534 
<a name="l04535"></a>04535 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04536"></a>04536 symbols_are_identical_enums (<span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *syms, <span class="keywordtype">int</span> nsyms)
<a name="l04537"></a>04537 {
<a name="l04538"></a>04538   <span class="keywordtype">int</span> i;
<a name="l04539"></a>04539 
<a name="l04540"></a>04540   <span class="comment">/* Before performing a thorough comparison check of each type,</span>
<a name="l04541"></a>04541 <span class="comment">     we perform a series of inexpensive checks.  We expect that these</span>
<a name="l04542"></a>04542 <span class="comment">     checks will quickly fail in the vast majority of cases, and thus</span>
<a name="l04543"></a>04543 <span class="comment">     help prevent the unnecessary use of a more expensive comparison.</span>
<a name="l04544"></a>04544 <span class="comment">     Said comparison also expects us to make some of these checks</span>
<a name="l04545"></a>04545 <span class="comment">     (see ada_identical_enum_types_p).  */</span>
<a name="l04546"></a>04546 
<a name="l04547"></a>04547   <span class="comment">/* Quick check: All symbols should have an enum type.  */</span>
<a name="l04548"></a>04548   <span class="keywordflow">for</span> (i = 0; i &lt; nsyms; i++)
<a name="l04549"></a>04549     <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[i].sym)) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>)
<a name="l04550"></a>04550       <span class="keywordflow">return</span> 0;
<a name="l04551"></a>04551 
<a name="l04552"></a>04552   <span class="comment">/* Quick check: They should all have the same value.  */</span>
<a name="l04553"></a>04553   <span class="keywordflow">for</span> (i = 1; i &lt; nsyms; i++)
<a name="l04554"></a>04554     <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (syms[i].sym) != <a class="code" href="symtab_8h.html#a31840856d8e3eed18cbe9ca90cd2bf39">SYMBOL_VALUE</a> (syms[0].sym))
<a name="l04555"></a>04555       <span class="keywordflow">return</span> 0;
<a name="l04556"></a>04556 
<a name="l04557"></a>04557   <span class="comment">/* Quick check: They should all have the same number of enumerals.  */</span>
<a name="l04558"></a>04558   <span class="keywordflow">for</span> (i = 1; i &lt; nsyms; i++)
<a name="l04559"></a>04559     <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[i].sym))
<a name="l04560"></a>04560         != <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[0].sym)))
<a name="l04561"></a>04561       <span class="keywordflow">return</span> 0;
<a name="l04562"></a>04562 
<a name="l04563"></a>04563   <span class="comment">/* All the sanity checks passed, so we might have a set of</span>
<a name="l04564"></a>04564 <span class="comment">     identical enumeration types.  Perform a more complete</span>
<a name="l04565"></a>04565 <span class="comment">     comparison of the type of each symbol.  */</span>
<a name="l04566"></a>04566   <span class="keywordflow">for</span> (i = 1; i &lt; nsyms; i++)
<a name="l04567"></a>04567     <span class="keywordflow">if</span> (!ada_identical_enum_types_p (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[i].sym),
<a name="l04568"></a>04568                                      <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[0].sym)))
<a name="l04569"></a>04569       <span class="keywordflow">return</span> 0;
<a name="l04570"></a>04570 
<a name="l04571"></a>04571   <span class="keywordflow">return</span> 1;
<a name="l04572"></a>04572 }
<a name="l04573"></a>04573 
<a name="l04574"></a>04574 <span class="comment">/* Remove any non-debugging symbols in SYMS[0 .. NSYMS-1] that definitely</span>
<a name="l04575"></a>04575 <span class="comment">   duplicate other symbols in the list (The only case I know of where</span>
<a name="l04576"></a>04576 <span class="comment">   this happens is when object files containing stabs-in-ecoff are</span>
<a name="l04577"></a>04577 <span class="comment">   linked with files containing ordinary ecoff debugging symbols (or no</span>
<a name="l04578"></a>04578 <span class="comment">   debugging symbols)).  Modifies SYMS to squeeze out deleted entries.</span>
<a name="l04579"></a>04579 <span class="comment">   Returns the number of items in the modified list.  */</span>
<a name="l04580"></a>04580 
<a name="l04581"></a>04581 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04582"></a>04582 remove_extra_symbols (<span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *syms, <span class="keywordtype">int</span> nsyms)
<a name="l04583"></a>04583 {
<a name="l04584"></a>04584   <span class="keywordtype">int</span> i, j;
<a name="l04585"></a>04585 
<a name="l04586"></a>04586   <span class="comment">/* We should never be called with less than 2 symbols, as there</span>
<a name="l04587"></a>04587 <span class="comment">     cannot be any extra symbol in that case.  But it&#39;s easy to</span>
<a name="l04588"></a>04588 <span class="comment">     handle, since we have nothing to do in that case.  */</span>
<a name="l04589"></a>04589   <span class="keywordflow">if</span> (nsyms &lt; 2)
<a name="l04590"></a>04590     <span class="keywordflow">return</span> nsyms;
<a name="l04591"></a>04591 
<a name="l04592"></a>04592   i = 0;
<a name="l04593"></a>04593   <span class="keywordflow">while</span> (i &lt; nsyms)
<a name="l04594"></a>04594     {
<a name="l04595"></a>04595       <span class="keywordtype">int</span> remove_p = 0;
<a name="l04596"></a>04596 
<a name="l04597"></a>04597       <span class="comment">/* If two symbols have the same name and one of them is a stub type,</span>
<a name="l04598"></a>04598 <span class="comment">         the get rid of the stub.  */</span>
<a name="l04599"></a>04599 
<a name="l04600"></a>04600       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aec5d0569d60af8ecfc5d2c7edae87d9c">TYPE_STUB</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[i].sym))
<a name="l04601"></a>04601           &amp;&amp; <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (syms[i].sym) != NULL)
<a name="l04602"></a>04602         {
<a name="l04603"></a>04603           <span class="keywordflow">for</span> (j = 0; j &lt; nsyms; j++)
<a name="l04604"></a>04604             {
<a name="l04605"></a>04605               <span class="keywordflow">if</span> (j != i
<a name="l04606"></a>04606                   &amp;&amp; !<a class="code" href="gdbtypes_8h.html#aec5d0569d60af8ecfc5d2c7edae87d9c">TYPE_STUB</a> (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[j].sym))
<a name="l04607"></a>04607                   &amp;&amp; <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (syms[j].sym) != NULL
<a name="l04608"></a>04608                   &amp;&amp; strcmp (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (syms[i].sym),
<a name="l04609"></a>04609                              <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (syms[j].sym)) == 0)
<a name="l04610"></a>04610                 remove_p = 1;
<a name="l04611"></a>04611             }
<a name="l04612"></a>04612         }
<a name="l04613"></a>04613 
<a name="l04614"></a>04614       <span class="comment">/* Two symbols with the same name, same class and same address</span>
<a name="l04615"></a>04615 <span class="comment">         should be identical.  */</span>
<a name="l04616"></a>04616 
<a name="l04617"></a>04617       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (syms[i].sym) != NULL
<a name="l04618"></a>04618           &amp;&amp; <a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (syms[i].sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a154b256439f7acd7ec7f6257d5881a0f">LOC_STATIC</a>
<a name="l04619"></a>04619           &amp;&amp; is_nondebugging_type (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (syms[i].sym)))
<a name="l04620"></a>04620         {
<a name="l04621"></a>04621           <span class="keywordflow">for</span> (j = 0; j &lt; nsyms; j += 1)
<a name="l04622"></a>04622             {
<a name="l04623"></a>04623               <span class="keywordflow">if</span> (i != j
<a name="l04624"></a>04624                   &amp;&amp; <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (syms[j].sym) != NULL
<a name="l04625"></a>04625                   &amp;&amp; strcmp (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (syms[i].sym),
<a name="l04626"></a>04626                              <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (syms[j].sym)) == 0
<a name="l04627"></a>04627                   &amp;&amp; <a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (syms[i].sym) == <a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (syms[j].sym)
<a name="l04628"></a>04628                   &amp;&amp; <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (syms[i].sym)
<a name="l04629"></a>04629                   == <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (syms[j].sym))
<a name="l04630"></a>04630                 remove_p = 1;
<a name="l04631"></a>04631             }
<a name="l04632"></a>04632         }
<a name="l04633"></a>04633       
<a name="l04634"></a>04634       <span class="keywordflow">if</span> (remove_p)
<a name="l04635"></a>04635         {
<a name="l04636"></a>04636           <span class="keywordflow">for</span> (j = i + 1; j &lt; nsyms; j += 1)
<a name="l04637"></a>04637             syms[j - 1] = syms[j];
<a name="l04638"></a>04638           nsyms -= 1;
<a name="l04639"></a>04639         }
<a name="l04640"></a>04640 
<a name="l04641"></a>04641       i += 1;
<a name="l04642"></a>04642     }
<a name="l04643"></a>04643 
<a name="l04644"></a>04644   <span class="comment">/* If all the remaining symbols are identical enumerals, then</span>
<a name="l04645"></a>04645 <span class="comment">     just keep the first one and discard the rest.</span>
<a name="l04646"></a>04646 <span class="comment"></span>
<a name="l04647"></a>04647 <span class="comment">     Unlike what we did previously, we do not discard any entry</span>
<a name="l04648"></a>04648 <span class="comment">     unless they are ALL identical.  This is because the symbol</span>
<a name="l04649"></a>04649 <span class="comment">     comparison is not a strict comparison, but rather a practical</span>
<a name="l04650"></a>04650 <span class="comment">     comparison.  If all symbols are considered identical, then</span>
<a name="l04651"></a>04651 <span class="comment">     we can just go ahead and use the first one and discard the rest.</span>
<a name="l04652"></a>04652 <span class="comment">     But if we cannot reduce the list to a single element, we have</span>
<a name="l04653"></a>04653 <span class="comment">     to ask the user to disambiguate anyways.  And if we have to</span>
<a name="l04654"></a>04654 <span class="comment">     present a multiple-choice menu, it&#39;s less confusing if the list</span>
<a name="l04655"></a>04655 <span class="comment">     isn&#39;t missing some choices that were identical and yet distinct.  */</span>
<a name="l04656"></a>04656   <span class="keywordflow">if</span> (symbols_are_identical_enums (syms, nsyms))
<a name="l04657"></a>04657     nsyms = 1;
<a name="l04658"></a>04658 
<a name="l04659"></a>04659   <span class="keywordflow">return</span> nsyms;
<a name="l04660"></a>04660 }
<a name="l04661"></a>04661 
<a name="l04662"></a>04662 <span class="comment">/* Given a type that corresponds to a renaming entity, use the type name</span>
<a name="l04663"></a>04663 <span class="comment">   to extract the scope (package name or function name, fully qualified,</span>
<a name="l04664"></a>04664 <span class="comment">   and following the GNAT encoding convention) where this renaming has been</span>
<a name="l04665"></a>04665 <span class="comment">   defined.  The string returned needs to be deallocated after use.  */</span>
<a name="l04666"></a>04666 
<a name="l04667"></a>04667 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l04668"></a>04668 xget_renaming_scope (<span class="keyword">struct</span> type *renaming_type)
<a name="l04669"></a>04669 {
<a name="l04670"></a>04670   <span class="comment">/* The renaming types adhere to the following convention:</span>
<a name="l04671"></a>04671 <span class="comment">     &lt;scope&gt;__&lt;rename&gt;___&lt;XR extension&gt;.</span>
<a name="l04672"></a>04672 <span class="comment">     So, to extract the scope, we search for the &quot;___XR&quot; extension,</span>
<a name="l04673"></a>04673 <span class="comment">     and then backtrack until we find the first &quot;__&quot;.  */</span>
<a name="l04674"></a>04674 
<a name="l04675"></a>04675   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="gdbtypes_8c.html#a1bce8398d8a46f3d37bfc7e618ab9e9d">type_name_no_tag</a> (renaming_type);
<a name="l04676"></a>04676   <span class="keywordtype">char</span> *suffix = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (name, <span class="stringliteral">&quot;___XR&quot;</span>);
<a name="l04677"></a>04677   <span class="keywordtype">char</span> *last;
<a name="l04678"></a>04678   <span class="keywordtype">int</span> scope_len;
<a name="l04679"></a>04679   <span class="keywordtype">char</span> *scope;
<a name="l04680"></a>04680 
<a name="l04681"></a>04681   <span class="comment">/* Now, backtrack a bit until we find the first &quot;__&quot;.  Start looking</span>
<a name="l04682"></a>04682 <span class="comment">     at suffix - 3, as the &lt;rename&gt; part is at least one character long.  */</span>
<a name="l04683"></a>04683 
<a name="l04684"></a>04684   <span class="keywordflow">for</span> (last = suffix - 3; last &gt; <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>; last--)
<a name="l04685"></a>04685     <span class="keywordflow">if</span> (last[0] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; last[1] == <span class="charliteral">&#39;_&#39;</span>)
<a name="l04686"></a>04686       <span class="keywordflow">break</span>;
<a name="l04687"></a>04687 
<a name="l04688"></a>04688   <span class="comment">/* Make a copy of scope and return it.  */</span>
<a name="l04689"></a>04689 
<a name="l04690"></a>04690   scope_len = last - <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l04691"></a>04691   scope = (<span class="keywordtype">char</span> *) <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> ((scope_len + 1) * <span class="keyword">sizeof</span> (char));
<a name="l04692"></a>04692 
<a name="l04693"></a>04693   strncpy (scope, name, scope_len);
<a name="l04694"></a>04694   scope[scope_len] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l04695"></a>04695 
<a name="l04696"></a>04696   <span class="keywordflow">return</span> scope;
<a name="l04697"></a>04697 }
<a name="l04698"></a>04698 
<a name="l04699"></a>04699 <span class="comment">/* Return nonzero if NAME corresponds to a package name.  */</span>
<a name="l04700"></a>04700 
<a name="l04701"></a>04701 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04702"></a>04702 is_package_name (<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l04703"></a>04703 {
<a name="l04704"></a>04704   <span class="comment">/* Here, We take advantage of the fact that no symbols are generated</span>
<a name="l04705"></a>04705 <span class="comment">     for packages, while symbols are generated for each function.</span>
<a name="l04706"></a>04706 <span class="comment">     So the condition for NAME represent a package becomes equivalent</span>
<a name="l04707"></a>04707 <span class="comment">     to NAME not existing in our list of symbols.  There is only one</span>
<a name="l04708"></a>04708 <span class="comment">     small complication with library-level functions (see below).  */</span>
<a name="l04709"></a>04709 
<a name="l04710"></a>04710   <span class="keywordtype">char</span> *fun_name;
<a name="l04711"></a>04711 
<a name="l04712"></a>04712   <span class="comment">/* If it is a function that has not been defined at library level,</span>
<a name="l04713"></a>04713 <span class="comment">     then we should be able to look it up in the symbols.  */</span>
<a name="l04714"></a>04714   <span class="keywordflow">if</span> (standard_lookup (name, NULL, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>) != NULL)
<a name="l04715"></a>04715     <span class="keywordflow">return</span> 0;
<a name="l04716"></a>04716 
<a name="l04717"></a>04717   <span class="comment">/* Library-level function names start with &quot;_ada_&quot;.  See if function</span>
<a name="l04718"></a>04718 <span class="comment">     &quot;_ada_&quot; followed by NAME can be found.  */</span>
<a name="l04719"></a>04719 
<a name="l04720"></a>04720   <span class="comment">/* Do a quick check that NAME does not contain &quot;__&quot;, since library-level</span>
<a name="l04721"></a>04721 <span class="comment">     functions names cannot contain &quot;__&quot; in them.  */</span>
<a name="l04722"></a>04722   <span class="keywordflow">if</span> (<a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (name, <span class="stringliteral">&quot;__&quot;</span>) != NULL)
<a name="l04723"></a>04723     <span class="keywordflow">return</span> 0;
<a name="l04724"></a>04724 
<a name="l04725"></a>04725   fun_name = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;_ada_%s&quot;</span>, name);
<a name="l04726"></a>04726 
<a name="l04727"></a>04727   <span class="keywordflow">return</span> (standard_lookup (fun_name, NULL, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>) == NULL);
<a name="l04728"></a>04728 }
<a name="l04729"></a>04729 
<a name="l04730"></a>04730 <span class="comment">/* Return nonzero if SYM corresponds to a renaming entity that is</span>
<a name="l04731"></a>04731 <span class="comment">   not visible from FUNCTION_NAME.  */</span>
<a name="l04732"></a>04732 
<a name="l04733"></a>04733 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04734"></a>04734 old_renaming_is_invisible (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym, <span class="keyword">const</span> <span class="keywordtype">char</span> *function_name)
<a name="l04735"></a>04735 {
<a name="l04736"></a>04736   <span class="keywordtype">char</span> *scope;
<a name="l04737"></a>04737   <span class="keyword">struct </span>cleanup *old_chain;
<a name="l04738"></a>04738 
<a name="l04739"></a>04739   <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) != <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>)
<a name="l04740"></a>04740     <span class="keywordflow">return</span> 0;
<a name="l04741"></a>04741 
<a name="l04742"></a>04742   scope = xget_renaming_scope (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym));
<a name="l04743"></a>04743   old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, scope);
<a name="l04744"></a>04744 
<a name="l04745"></a>04745   <span class="comment">/* If the rename has been defined in a package, then it is visible.  */</span>
<a name="l04746"></a>04746   <span class="keywordflow">if</span> (is_package_name (scope))
<a name="l04747"></a>04747     {
<a name="l04748"></a>04748       <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l04749"></a>04749       <span class="keywordflow">return</span> 0;
<a name="l04750"></a>04750     }
<a name="l04751"></a>04751 
<a name="l04752"></a>04752   <span class="comment">/* Check that the rename is in the current function scope by checking</span>
<a name="l04753"></a>04753 <span class="comment">     that its name starts with SCOPE.  */</span>
<a name="l04754"></a>04754 
<a name="l04755"></a>04755   <span class="comment">/* If the function name starts with &quot;_ada_&quot;, it means that it is</span>
<a name="l04756"></a>04756 <span class="comment">     a library-level function.  Strip this prefix before doing the</span>
<a name="l04757"></a>04757 <span class="comment">     comparison, as the encoding for the renaming does not contain</span>
<a name="l04758"></a>04758 <span class="comment">     this prefix.  */</span>
<a name="l04759"></a>04759   <span class="keywordflow">if</span> (strncmp (function_name, <span class="stringliteral">&quot;_ada_&quot;</span>, 5) == 0)
<a name="l04760"></a>04760     function_name += 5;
<a name="l04761"></a>04761 
<a name="l04762"></a>04762   {
<a name="l04763"></a>04763     <span class="keywordtype">int</span> is_invisible = strncmp (function_name, scope, strlen (scope)) != 0;
<a name="l04764"></a>04764 
<a name="l04765"></a>04765     <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l04766"></a>04766     <span class="keywordflow">return</span> is_invisible;
<a name="l04767"></a>04767   }
<a name="l04768"></a>04768 }
<a name="l04769"></a>04769 
<a name="l04770"></a>04770 <span class="comment">/* Remove entries from SYMS that corresponds to a renaming entity that</span>
<a name="l04771"></a>04771 <span class="comment">   is not visible from the function associated with CURRENT_BLOCK or</span>
<a name="l04772"></a>04772 <span class="comment">   that is superfluous due to the presence of more specific renaming</span>
<a name="l04773"></a>04773 <span class="comment">   information.  Places surviving symbols in the initial entries of</span>
<a name="l04774"></a>04774 <span class="comment">   SYMS and returns the number of surviving symbols.</span>
<a name="l04775"></a>04775 <span class="comment">   </span>
<a name="l04776"></a>04776 <span class="comment">   Rationale:</span>
<a name="l04777"></a>04777 <span class="comment">   First, in cases where an object renaming is implemented as a</span>
<a name="l04778"></a>04778 <span class="comment">   reference variable, GNAT may produce both the actual reference</span>
<a name="l04779"></a>04779 <span class="comment">   variable and the renaming encoding.  In this case, we discard the</span>
<a name="l04780"></a>04780 <span class="comment">   latter.</span>
<a name="l04781"></a>04781 <span class="comment"></span>
<a name="l04782"></a>04782 <span class="comment">   Second, GNAT emits a type following a specified encoding for each renaming</span>
<a name="l04783"></a>04783 <span class="comment">   entity.  Unfortunately, STABS currently does not support the definition</span>
<a name="l04784"></a>04784 <span class="comment">   of types that are local to a given lexical block, so all renamings types</span>
<a name="l04785"></a>04785 <span class="comment">   are emitted at library level.  As a consequence, if an application</span>
<a name="l04786"></a>04786 <span class="comment">   contains two renaming entities using the same name, and a user tries to</span>
<a name="l04787"></a>04787 <span class="comment">   print the value of one of these entities, the result of the ada symbol</span>
<a name="l04788"></a>04788 <span class="comment">   lookup will also contain the wrong renaming type.</span>
<a name="l04789"></a>04789 <span class="comment"></span>
<a name="l04790"></a>04790 <span class="comment">   This function partially covers for this limitation by attempting to</span>
<a name="l04791"></a>04791 <span class="comment">   remove from the SYMS list renaming symbols that should be visible</span>
<a name="l04792"></a>04792 <span class="comment">   from CURRENT_BLOCK.  However, there does not seem be a 100% reliable</span>
<a name="l04793"></a>04793 <span class="comment">   method with the current information available.  The implementation</span>
<a name="l04794"></a>04794 <span class="comment">   below has a couple of limitations (FIXME: brobecker-2003-05-12):  </span>
<a name="l04795"></a>04795 <span class="comment">   </span>
<a name="l04796"></a>04796 <span class="comment">      - When the user tries to print a rename in a function while there</span>
<a name="l04797"></a>04797 <span class="comment">        is another rename entity defined in a package:  Normally, the</span>
<a name="l04798"></a>04798 <span class="comment">        rename in the function has precedence over the rename in the</span>
<a name="l04799"></a>04799 <span class="comment">        package, so the latter should be removed from the list.  This is</span>
<a name="l04800"></a>04800 <span class="comment">        currently not the case.</span>
<a name="l04801"></a>04801 <span class="comment">        </span>
<a name="l04802"></a>04802 <span class="comment">      - This function will incorrectly remove valid renames if</span>
<a name="l04803"></a>04803 <span class="comment">        the CURRENT_BLOCK corresponds to a function which symbol name</span>
<a name="l04804"></a>04804 <span class="comment">        has been changed by an &quot;Export&quot; pragma.  As a consequence,</span>
<a name="l04805"></a>04805 <span class="comment">        the user will be unable to print such rename entities.  */</span>
<a name="l04806"></a>04806 
<a name="l04807"></a>04807 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04808"></a>04808 remove_irrelevant_renamings (<span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *syms,
<a name="l04809"></a>04809                              <span class="keywordtype">int</span> nsyms, <span class="keyword">const</span> <span class="keyword">struct</span> block *current_block)
<a name="l04810"></a>04810 {
<a name="l04811"></a>04811   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *current_function;
<a name="l04812"></a>04812   <span class="keyword">const</span> <span class="keywordtype">char</span> *current_function_name;
<a name="l04813"></a>04813   <span class="keywordtype">int</span> i;
<a name="l04814"></a>04814   <span class="keywordtype">int</span> is_new_style_renaming;
<a name="l04815"></a>04815 
<a name="l04816"></a>04816   <span class="comment">/* If there is both a renaming foo___XR... encoded as a variable and</span>
<a name="l04817"></a>04817 <span class="comment">     a simple variable foo in the same block, discard the latter.</span>
<a name="l04818"></a>04818 <span class="comment">     First, zero out such symbols, then compress.  */</span>
<a name="l04819"></a>04819   is_new_style_renaming = 0;
<a name="l04820"></a>04820   <span class="keywordflow">for</span> (i = 0; i &lt; nsyms; i += 1)
<a name="l04821"></a>04821     {
<a name="l04822"></a>04822       <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym = syms[i].<a class="code" href="structada__symbol__info.html#ab424e8140f59e695fcb43c8d1c818728">sym</a>;
<a name="l04823"></a>04823       <span class="keyword">const</span> <span class="keyword">struct </span>block *block = syms[i].<a class="code" href="structada__symbol__info.html#a42d6b64e717f920614470bc34c421b76">block</a>;
<a name="l04824"></a>04824       <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l04825"></a>04825       <span class="keyword">const</span> <span class="keywordtype">char</span> *suffix;
<a name="l04826"></a>04826 
<a name="l04827"></a>04827       <span class="keywordflow">if</span> (sym == NULL || <a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>)
<a name="l04828"></a>04828         <span class="keywordflow">continue</span>;
<a name="l04829"></a>04829       name = <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym);
<a name="l04830"></a>04830       suffix = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (name, <span class="stringliteral">&quot;___XR&quot;</span>);
<a name="l04831"></a>04831 
<a name="l04832"></a>04832       <span class="keywordflow">if</span> (suffix != NULL)
<a name="l04833"></a>04833         {
<a name="l04834"></a>04834           <span class="keywordtype">int</span> name_len = suffix - <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l04835"></a>04835           <span class="keywordtype">int</span> j;
<a name="l04836"></a>04836 
<a name="l04837"></a>04837           is_new_style_renaming = 1;
<a name="l04838"></a>04838           <span class="keywordflow">for</span> (j = 0; j &lt; nsyms; j += 1)
<a name="l04839"></a>04839             <span class="keywordflow">if</span> (i != j &amp;&amp; syms[j].sym != NULL
<a name="l04840"></a>04840                 &amp;&amp; strncmp (name, <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (syms[j].sym),
<a name="l04841"></a>04841                             name_len) == 0
<a name="l04842"></a>04842                 &amp;&amp; block == syms[j].block)
<a name="l04843"></a>04843               syms[j].<a class="code" href="structada__symbol__info.html#ab424e8140f59e695fcb43c8d1c818728">sym</a> = NULL;
<a name="l04844"></a>04844         }
<a name="l04845"></a>04845     }
<a name="l04846"></a>04846   <span class="keywordflow">if</span> (is_new_style_renaming)
<a name="l04847"></a>04847     {
<a name="l04848"></a>04848       <span class="keywordtype">int</span> j, k;
<a name="l04849"></a>04849 
<a name="l04850"></a>04850       <span class="keywordflow">for</span> (j = k = 0; j &lt; nsyms; j += 1)
<a name="l04851"></a>04851         <span class="keywordflow">if</span> (syms[j].sym != NULL)
<a name="l04852"></a>04852             {
<a name="l04853"></a>04853               syms[k] = syms[j];
<a name="l04854"></a>04854               k += 1;
<a name="l04855"></a>04855             }
<a name="l04856"></a>04856       <span class="keywordflow">return</span> k;
<a name="l04857"></a>04857     }
<a name="l04858"></a>04858 
<a name="l04859"></a>04859   <span class="comment">/* Extract the function name associated to CURRENT_BLOCK.</span>
<a name="l04860"></a>04860 <span class="comment">     Abort if unable to do so.  */</span>
<a name="l04861"></a>04861 
<a name="l04862"></a>04862   <span class="keywordflow">if</span> (current_block == NULL)
<a name="l04863"></a>04863     <span class="keywordflow">return</span> nsyms;
<a name="l04864"></a>04864 
<a name="l04865"></a>04865   current_function = <a class="code" href="block_8c.html#a79d1eee3f8ad664338ecfcccf6e5d2a0">block_linkage_function</a> (current_block);
<a name="l04866"></a>04866   <span class="keywordflow">if</span> (current_function == NULL)
<a name="l04867"></a>04867     <span class="keywordflow">return</span> nsyms;
<a name="l04868"></a>04868 
<a name="l04869"></a>04869   current_function_name = <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (current_function);
<a name="l04870"></a>04870   <span class="keywordflow">if</span> (current_function_name == NULL)
<a name="l04871"></a>04871     <span class="keywordflow">return</span> nsyms;
<a name="l04872"></a>04872 
<a name="l04873"></a>04873   <span class="comment">/* Check each of the symbols, and remove it from the list if it is</span>
<a name="l04874"></a>04874 <span class="comment">     a type corresponding to a renaming that is out of the scope of</span>
<a name="l04875"></a>04875 <span class="comment">     the current block.  */</span>
<a name="l04876"></a>04876 
<a name="l04877"></a>04877   i = 0;
<a name="l04878"></a>04878   <span class="keywordflow">while</span> (i &lt; nsyms)
<a name="l04879"></a>04879     {
<a name="l04880"></a>04880       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a7d8e58dccc5e1de5d818463752740f62">ada_parse_renaming</a> (syms[i].sym, NULL, NULL, NULL)
<a name="l04881"></a>04881           == <a class="code" href="ada-lang_8h.html#a5cbd7d7b1418e0df228a758803fa5deca699f7a84941953710b7735d7bed1e4e3">ADA_OBJECT_RENAMING</a>
<a name="l04882"></a>04882           &amp;&amp; old_renaming_is_invisible (syms[i].sym, current_function_name))
<a name="l04883"></a>04883         {
<a name="l04884"></a>04884           <span class="keywordtype">int</span> j;
<a name="l04885"></a>04885 
<a name="l04886"></a>04886           <span class="keywordflow">for</span> (j = i + 1; j &lt; nsyms; j += 1)
<a name="l04887"></a>04887             syms[j - 1] = syms[j];
<a name="l04888"></a>04888           nsyms -= 1;
<a name="l04889"></a>04889         }
<a name="l04890"></a>04890       <span class="keywordflow">else</span>
<a name="l04891"></a>04891         i += 1;
<a name="l04892"></a>04892     }
<a name="l04893"></a>04893 
<a name="l04894"></a>04894   <span class="keywordflow">return</span> nsyms;
<a name="l04895"></a>04895 }
<a name="l04896"></a>04896 
<a name="l04897"></a>04897 <span class="comment">/* Add to OBSTACKP all symbols from BLOCK (and its super-blocks)</span>
<a name="l04898"></a>04898 <span class="comment">   whose name and domain match NAME and DOMAIN respectively.</span>
<a name="l04899"></a>04899 <span class="comment">   If no match was found, then extend the search to &quot;enclosing&quot;</span>
<a name="l04900"></a>04900 <span class="comment">   routines (in other words, if we&#39;re inside a nested function,</span>
<a name="l04901"></a>04901 <span class="comment">   search the symbols defined inside the enclosing functions).</span>
<a name="l04902"></a>04902 <span class="comment">   If WILD_MATCH_P is nonzero, perform the naming matching in</span>
<a name="l04903"></a>04903 <span class="comment">   &quot;wild&quot; mode (see function &quot;wild_match&quot; for more info).</span>
<a name="l04904"></a>04904 <span class="comment"></span>
<a name="l04905"></a>04905 <span class="comment">   Note: This function assumes that OBSTACKP has 0 (zero) element in it.  */</span>
<a name="l04906"></a>04906 
<a name="l04907"></a>04907 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04908"></a>04908 ada_add_local_symbols (<span class="keyword">struct</span> obstack *obstackp, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l04909"></a>04909                        <span class="keyword">struct</span> block *block, <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> domain,
<a name="l04910"></a>04910                        <span class="keywordtype">int</span> wild_match_p)
<a name="l04911"></a>04911 {
<a name="l04912"></a>04912   <span class="keywordtype">int</span> block_depth = 0;
<a name="l04913"></a>04913 
<a name="l04914"></a>04914   <span class="keywordflow">while</span> (block != NULL)
<a name="l04915"></a>04915     {
<a name="l04916"></a>04916       block_depth += 1;
<a name="l04917"></a>04917       ada_add_block_symbols (obstackp, block, name, domain, NULL,
<a name="l04918"></a>04918                              wild_match_p);
<a name="l04919"></a>04919 
<a name="l04920"></a>04920       <span class="comment">/* If we found a non-function match, assume that&#39;s the one.  */</span>
<a name="l04921"></a>04921       <span class="keywordflow">if</span> (is_nonfunction (defns_collected (obstackp, 0),
<a name="l04922"></a>04922                           num_defns_collected (obstackp)))
<a name="l04923"></a>04923         <span class="keywordflow">return</span>;
<a name="l04924"></a>04924 
<a name="l04925"></a>04925       block = <a class="code" href="block_8h.html#a8b7633ab6d6feadf9b2ee58e10ad8397">BLOCK_SUPERBLOCK</a> (block);
<a name="l04926"></a>04926     }
<a name="l04927"></a>04927 
<a name="l04928"></a>04928   <span class="comment">/* If no luck so far, try to find NAME as a local symbol in some lexically</span>
<a name="l04929"></a>04929 <span class="comment">     enclosing subprogram.  */</span>
<a name="l04930"></a>04930   <span class="keywordflow">if</span> (num_defns_collected (obstackp) == 0 &amp;&amp; block_depth &gt; 2)
<a name="l04931"></a>04931     add_symbols_from_enclosing_procs (obstackp, name, domain, wild_match_p);
<a name="l04932"></a>04932 }
<a name="l04933"></a>04933 
<a name="l04934"></a>04934 <span class="comment">/* An object of this type is used as the user_data argument when</span>
<a name="l04935"></a>04935 <span class="comment">   calling the map_matching_symbols method.  */</span>
<a name="l04936"></a>04936 
<a name="l04937"></a>04937 <span class="keyword">struct </span>match_data
<a name="l04938"></a>04938 {
<a name="l04939"></a>04939   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>;
<a name="l04940"></a>04940   <span class="keyword">struct </span>obstack *obstackp;
<a name="l04941"></a>04941   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *arg_sym;
<a name="l04942"></a>04942   <span class="keywordtype">int</span> found_sym;
<a name="l04943"></a>04943 };
<a name="l04944"></a>04944 
<a name="l04945"></a>04945 <span class="comment">/* A callback for add_matching_symbols that adds SYM, found in BLOCK,</span>
<a name="l04946"></a>04946 <span class="comment">   to a list of symbols.  DATA0 is a pointer to a struct match_data *</span>
<a name="l04947"></a>04947 <span class="comment">   containing the obstack that collects the symbol list, the file that SYM</span>
<a name="l04948"></a>04948 <span class="comment">   must come from, a flag indicating whether a non-argument symbol has</span>
<a name="l04949"></a>04949 <span class="comment">   been found in the current block, and the last argument symbol</span>
<a name="l04950"></a>04950 <span class="comment">   passed in SYM within the current block (if any).  When SYM is null,</span>
<a name="l04951"></a>04951 <span class="comment">   marking the end of a block, the argument symbol is added if no</span>
<a name="l04952"></a>04952 <span class="comment">   other has been found.  */</span>
<a name="l04953"></a>04953 
<a name="l04954"></a>04954 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04955"></a>04955 aux_add_nonlocal_symbols (<span class="keyword">struct</span> block *block, <span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *sym, <span class="keywordtype">void</span> *data0)
<a name="l04956"></a>04956 {
<a name="l04957"></a>04957   <span class="keyword">struct </span>match_data *data = (<span class="keyword">struct </span>match_data *) data0;
<a name="l04958"></a>04958   
<a name="l04959"></a>04959   <span class="keywordflow">if</span> (sym == NULL)
<a name="l04960"></a>04960     {
<a name="l04961"></a>04961       <span class="keywordflow">if</span> (!data-&gt;found_sym &amp;&amp; data-&gt;arg_sym != NULL) 
<a name="l04962"></a>04962         add_defn_to_vec (data-&gt;obstackp,
<a name="l04963"></a>04963                          <a class="code" href="symtab_8c.html#a569809b8edfbd2e0a6d9bb40295840f0">fixup_symbol_section</a> (data-&gt;arg_sym, data-&gt;objfile),
<a name="l04964"></a>04964                          block);
<a name="l04965"></a>04965       data-&gt;found_sym = 0;
<a name="l04966"></a>04966       data-&gt;arg_sym = NULL;
<a name="l04967"></a>04967     }
<a name="l04968"></a>04968   <span class="keywordflow">else</span> 
<a name="l04969"></a>04969     {
<a name="l04970"></a>04970       <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a3d61e7ad56c95328fba05416abc73f7a">LOC_UNRESOLVED</a>)
<a name="l04971"></a>04971         <span class="keywordflow">return</span> 0;
<a name="l04972"></a>04972       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#ab3de6f2d8c380d3ca8bef520b1b4dfb9">SYMBOL_IS_ARGUMENT</a> (sym))
<a name="l04973"></a>04973         data-&gt;arg_sym = sym;
<a name="l04974"></a>04974       <span class="keywordflow">else</span>
<a name="l04975"></a>04975         {
<a name="l04976"></a>04976           data-&gt;found_sym = 1;
<a name="l04977"></a>04977           add_defn_to_vec (data-&gt;obstackp,
<a name="l04978"></a>04978                            <a class="code" href="symtab_8c.html#a569809b8edfbd2e0a6d9bb40295840f0">fixup_symbol_section</a> (sym, data-&gt;objfile),
<a name="l04979"></a>04979                            block);
<a name="l04980"></a>04980         }
<a name="l04981"></a>04981     }
<a name="l04982"></a>04982   <span class="keywordflow">return</span> 0;
<a name="l04983"></a>04983 }
<a name="l04984"></a>04984 
<a name="l04985"></a>04985 <span class="comment">/* Implements compare_names, but only applying the comparision using</span>
<a name="l04986"></a>04986 <span class="comment">   the given CASING.  */</span>
<a name="l04987"></a>04987 
<a name="l04988"></a>04988 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l04989"></a>04989 compare_names_with_case (<span class="keyword">const</span> <span class="keywordtype">char</span> *string1, <span class="keyword">const</span> <span class="keywordtype">char</span> *string2,
<a name="l04990"></a>04990                          <span class="keyword">enum</span> <a class="code" href="language_8h.html#ad102f9e1a41cf77a0045e37883dd2940">case_sensitivity</a> casing)
<a name="l04991"></a>04991 {
<a name="l04992"></a>04992   <span class="keywordflow">while</span> (*string1 != <span class="charliteral">&#39;\0&#39;</span> &amp;&amp; *string2 != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l04993"></a>04993     {
<a name="l04994"></a>04994       <span class="keywordtype">char</span> c1, c2;
<a name="l04995"></a>04995 
<a name="l04996"></a>04996       <span class="keywordflow">if</span> (isspace (*string1) || isspace (*string2))
<a name="l04997"></a>04997         <span class="keywordflow">return</span> <a class="code" href="utils_8c.html#a75e0024041a6c68cde74b1ee53a5e55e">strcmp_iw_ordered</a> (string1, string2);
<a name="l04998"></a>04998 
<a name="l04999"></a>04999       <span class="keywordflow">if</span> (casing == <a class="code" href="language_8h.html#ad102f9e1a41cf77a0045e37883dd2940aeafdb3f995ad73c5c877655272018479">case_sensitive_off</a>)
<a name="l05000"></a>05000         {
<a name="l05001"></a>05001           c1 = tolower (*string1);
<a name="l05002"></a>05002           c2 = tolower (*string2);
<a name="l05003"></a>05003         }
<a name="l05004"></a>05004       <span class="keywordflow">else</span>
<a name="l05005"></a>05005         {
<a name="l05006"></a>05006           c1 = *string1;
<a name="l05007"></a>05007           c2 = *string2;
<a name="l05008"></a>05008         }
<a name="l05009"></a>05009       <span class="keywordflow">if</span> (c1 != c2)
<a name="l05010"></a>05010         <span class="keywordflow">break</span>;
<a name="l05011"></a>05011 
<a name="l05012"></a>05012       string1 += 1;
<a name="l05013"></a>05013       string2 += 1;
<a name="l05014"></a>05014     }
<a name="l05015"></a>05015 
<a name="l05016"></a>05016   <span class="keywordflow">switch</span> (*string1)
<a name="l05017"></a>05017     {
<a name="l05018"></a>05018     <span class="keywordflow">case</span> <span class="charliteral">&#39;(&#39;</span>:
<a name="l05019"></a>05019       <span class="keywordflow">return</span> <a class="code" href="utils_8c.html#a75e0024041a6c68cde74b1ee53a5e55e">strcmp_iw_ordered</a> (string1, string2);
<a name="l05020"></a>05020     <span class="keywordflow">case</span> <span class="charliteral">&#39;_&#39;</span>:
<a name="l05021"></a>05021       <span class="keywordflow">if</span> (*string2 == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l05022"></a>05022         {
<a name="l05023"></a>05023           <span class="keywordflow">if</span> (is_name_suffix (string1))
<a name="l05024"></a>05024             <span class="keywordflow">return</span> 0;
<a name="l05025"></a>05025           <span class="keywordflow">else</span>
<a name="l05026"></a>05026             <span class="keywordflow">return</span> 1;
<a name="l05027"></a>05027         }
<a name="l05028"></a>05028       <span class="comment">/* FALLTHROUGH */</span>
<a name="l05029"></a>05029     <span class="keywordflow">default</span>:
<a name="l05030"></a>05030       <span class="keywordflow">if</span> (*string2 == <span class="charliteral">&#39;(&#39;</span>)
<a name="l05031"></a>05031         <span class="keywordflow">return</span> <a class="code" href="utils_8c.html#a75e0024041a6c68cde74b1ee53a5e55e">strcmp_iw_ordered</a> (string1, string2);
<a name="l05032"></a>05032       <span class="keywordflow">else</span>
<a name="l05033"></a>05033         {
<a name="l05034"></a>05034           <span class="keywordflow">if</span> (casing == <a class="code" href="language_8h.html#ad102f9e1a41cf77a0045e37883dd2940aeafdb3f995ad73c5c877655272018479">case_sensitive_off</a>)
<a name="l05035"></a>05035             <span class="keywordflow">return</span> tolower (*string1) - tolower (*string2);
<a name="l05036"></a>05036           <span class="keywordflow">else</span>
<a name="l05037"></a>05037             <span class="keywordflow">return</span> *string1 - *string2;
<a name="l05038"></a>05038         }
<a name="l05039"></a>05039     }
<a name="l05040"></a>05040 }
<a name="l05041"></a>05041 
<a name="l05042"></a>05042 <span class="comment">/* Compare STRING1 to STRING2, with results as for strcmp.</span>
<a name="l05043"></a>05043 <span class="comment">   Compatible with strcmp_iw_ordered in that...</span>
<a name="l05044"></a>05044 <span class="comment"></span>
<a name="l05045"></a>05045 <span class="comment">       strcmp_iw_ordered (STRING1, STRING2) &lt;= 0</span>
<a name="l05046"></a>05046 <span class="comment"></span>
<a name="l05047"></a>05047 <span class="comment">   ... implies...</span>
<a name="l05048"></a>05048 <span class="comment"></span>
<a name="l05049"></a>05049 <span class="comment">       compare_names (STRING1, STRING2) &lt;= 0</span>
<a name="l05050"></a>05050 <span class="comment"></span>
<a name="l05051"></a>05051 <span class="comment">   (they may differ as to what symbols compare equal).  */</span>
<a name="l05052"></a>05052 
<a name="l05053"></a>05053 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05054"></a>05054 compare_names (<span class="keyword">const</span> <span class="keywordtype">char</span> *string1, <span class="keyword">const</span> <span class="keywordtype">char</span> *string2)
<a name="l05055"></a>05055 {
<a name="l05056"></a>05056   <span class="keywordtype">int</span> result;
<a name="l05057"></a>05057 
<a name="l05058"></a>05058   <span class="comment">/* Similar to what strcmp_iw_ordered does, we need to perform</span>
<a name="l05059"></a>05059 <span class="comment">     a case-insensitive comparison first, and only resort to</span>
<a name="l05060"></a>05060 <span class="comment">     a second, case-sensitive, comparison if the first one was</span>
<a name="l05061"></a>05061 <span class="comment">     not sufficient to differentiate the two strings.  */</span>
<a name="l05062"></a>05062 
<a name="l05063"></a>05063   result = compare_names_with_case (string1, string2, <a class="code" href="language_8h.html#ad102f9e1a41cf77a0045e37883dd2940aeafdb3f995ad73c5c877655272018479">case_sensitive_off</a>);
<a name="l05064"></a>05064   <span class="keywordflow">if</span> (result == 0)
<a name="l05065"></a>05065     result = compare_names_with_case (string1, string2, <a class="code" href="language_8h.html#ad102f9e1a41cf77a0045e37883dd2940a236ce0a37504b1c7b4f94f8236707e36">case_sensitive_on</a>);
<a name="l05066"></a>05066 
<a name="l05067"></a>05067   <span class="keywordflow">return</span> result;
<a name="l05068"></a>05068 }
<a name="l05069"></a>05069 
<a name="l05070"></a>05070 <span class="comment">/* Add to OBSTACKP all non-local symbols whose name and domain match</span>
<a name="l05071"></a>05071 <span class="comment">   NAME and DOMAIN respectively.  The search is performed on GLOBAL_BLOCK</span>
<a name="l05072"></a>05072 <span class="comment">   symbols if GLOBAL is non-zero, or on STATIC_BLOCK symbols otherwise.  */</span>
<a name="l05073"></a>05073 
<a name="l05074"></a>05074 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05075"></a>05075 add_nonlocal_symbols (<span class="keyword">struct</span> obstack *obstackp, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l05076"></a>05076                       <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> domain, <span class="keywordtype">int</span> global,
<a name="l05077"></a>05077                       <span class="keywordtype">int</span> is_wild_match)
<a name="l05078"></a>05078 {
<a name="l05079"></a>05079   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>;
<a name="l05080"></a>05080   <span class="keyword">struct </span>match_data data;
<a name="l05081"></a>05081 
<a name="l05082"></a>05082   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (&amp;data, 0, <span class="keyword">sizeof</span> data);
<a name="l05083"></a>05083   data.obstackp = obstackp;
<a name="l05084"></a>05084 
<a name="l05085"></a>05085   <a class="code" href="objfiles_8h.html#a8efee3b85a322006131a6056d45058b3">ALL_OBJFILES</a> (objfile)
<a name="l05086"></a>05086     {
<a name="l05087"></a>05087       data.objfile = objfile;
<a name="l05088"></a>05088 
<a name="l05089"></a>05089       <span class="keywordflow">if</span> (is_wild_match)
<a name="l05090"></a>05090         objfile-&gt;<a class="code" href="structobjfile.html#af6814df9c2fd1f669fd79d0b0c94262c">sf</a>-&gt;<a class="code" href="structsym__fns.html#ae4cb3e689cab6e5ecf8e2fb8770b55b0">qf</a>-&gt;<a class="code" href="structquick__symbol__functions.html#aeee81195792d9a4c7e7ad4b6e87a5571">map_matching_symbols</a> (objfile, name, domain, global,
<a name="l05091"></a>05091                                                aux_add_nonlocal_symbols, &amp;data,
<a name="l05092"></a>05092                                                wild_match, NULL);
<a name="l05093"></a>05093       <span class="keywordflow">else</span>
<a name="l05094"></a>05094         objfile-&gt;<a class="code" href="structobjfile.html#af6814df9c2fd1f669fd79d0b0c94262c">sf</a>-&gt;<a class="code" href="structsym__fns.html#ae4cb3e689cab6e5ecf8e2fb8770b55b0">qf</a>-&gt;<a class="code" href="structquick__symbol__functions.html#aeee81195792d9a4c7e7ad4b6e87a5571">map_matching_symbols</a> (objfile, name, domain, global,
<a name="l05095"></a>05095                                                aux_add_nonlocal_symbols, &amp;data,
<a name="l05096"></a>05096                                                full_match, compare_names);
<a name="l05097"></a>05097     }
<a name="l05098"></a>05098 
<a name="l05099"></a>05099   <span class="keywordflow">if</span> (num_defns_collected (obstackp) == 0 &amp;&amp; global &amp;&amp; !is_wild_match)
<a name="l05100"></a>05100     {
<a name="l05101"></a>05101       <a class="code" href="objfiles_8h.html#a8efee3b85a322006131a6056d45058b3">ALL_OBJFILES</a> (objfile)
<a name="l05102"></a>05102         {
<a name="l05103"></a>05103           <span class="keywordtype">char</span> *name1 = alloca (strlen (name) + <span class="keyword">sizeof</span> (<span class="stringliteral">&quot;_ada_&quot;</span>));
<a name="l05104"></a>05104           strcpy (name1, <span class="stringliteral">&quot;_ada_&quot;</span>);
<a name="l05105"></a>05105           strcpy (name1 + <span class="keyword">sizeof</span> (<span class="stringliteral">&quot;_ada_&quot;</span>) - 1, name);
<a name="l05106"></a>05106           data.objfile = objfile;
<a name="l05107"></a>05107           objfile-&gt;<a class="code" href="structobjfile.html#af6814df9c2fd1f669fd79d0b0c94262c">sf</a>-&gt;<a class="code" href="structsym__fns.html#ae4cb3e689cab6e5ecf8e2fb8770b55b0">qf</a>-&gt;<a class="code" href="structquick__symbol__functions.html#aeee81195792d9a4c7e7ad4b6e87a5571">map_matching_symbols</a> (objfile, name1, domain,
<a name="l05108"></a>05108                                                  global,
<a name="l05109"></a>05109                                                  aux_add_nonlocal_symbols,
<a name="l05110"></a>05110                                                  &amp;data,
<a name="l05111"></a>05111                                                  full_match, compare_names);
<a name="l05112"></a>05112         }
<a name="l05113"></a>05113     }           
<a name="l05114"></a>05114 }
<a name="l05115"></a>05115 
<a name="l05116"></a>05116 <span class="comment">/* Find symbols in DOMAIN matching NAME0, in BLOCK0 and, if full_search is</span>
<a name="l05117"></a>05117 <span class="comment">   non-zero, enclosing scope and in global scopes, returning the number of</span>
<a name="l05118"></a>05118 <span class="comment">   matches.</span>
<a name="l05119"></a>05119 <span class="comment">   Sets *RESULTS to point to a vector of (SYM,BLOCK) tuples,</span>
<a name="l05120"></a>05120 <span class="comment">   indicating the symbols found and the blocks and symbol tables (if</span>
<a name="l05121"></a>05121 <span class="comment">   any) in which they were found.  This vector is transient---good only to</span>
<a name="l05122"></a>05122 <span class="comment">   the next call of ada_lookup_symbol_list.</span>
<a name="l05123"></a>05123 <span class="comment"></span>
<a name="l05124"></a>05124 <span class="comment">   When full_search is non-zero, any non-function/non-enumeral</span>
<a name="l05125"></a>05125 <span class="comment">   symbol match within the nest of blocks whose innermost member is BLOCK0,</span>
<a name="l05126"></a>05126 <span class="comment">   is the one match returned (no other matches in that or</span>
<a name="l05127"></a>05127 <span class="comment">   enclosing blocks is returned).  If there are any matches in or</span>
<a name="l05128"></a>05128 <span class="comment">   surrounding BLOCK0, then these alone are returned.</span>
<a name="l05129"></a>05129 <span class="comment"></span>
<a name="l05130"></a>05130 <span class="comment">   Names prefixed with &quot;standard__&quot; are handled specially: &quot;standard__&quot;</span>
<a name="l05131"></a>05131 <span class="comment">   is first stripped off, and only static and global symbols are searched.  */</span>
<a name="l05132"></a>05132 
<a name="l05133"></a>05133 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05134"></a>05134 ada_lookup_symbol_list_worker (<span class="keyword">const</span> <span class="keywordtype">char</span> *name0, <span class="keyword">const</span> <span class="keyword">struct</span> block *block0,
<a name="l05135"></a>05135                                <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> <span class="keyword">namespace</span>,
<a name="l05136"></a>05136                                <span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a> **results,
<a name="l05137"></a>05137                                <span class="keywordtype">int</span> full_search)
<a name="l05138"></a>05138 {
<a name="l05139"></a>05139   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l05140"></a>05140   <span class="keyword">struct </span>block *block;
<a name="l05141"></a>05141   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l05142"></a>05142   <span class="keyword">const</span> <span class="keywordtype">int</span> wild_match_p = should_use_wild_match (name0);
<a name="l05143"></a>05143   <span class="keywordtype">int</span> cacheIfUnique;
<a name="l05144"></a>05144   <span class="keywordtype">int</span> ndefns;
<a name="l05145"></a>05145 
<a name="l05146"></a>05146   obstack_free (&amp;symbol_list_obstack, NULL);
<a name="l05147"></a>05147   obstack_init (&amp;symbol_list_obstack);
<a name="l05148"></a>05148 
<a name="l05149"></a>05149   cacheIfUnique = 0;
<a name="l05150"></a>05150 
<a name="l05151"></a>05151   <span class="comment">/* Search specified block and its superiors.  */</span>
<a name="l05152"></a>05152 
<a name="l05153"></a>05153   name = name0;
<a name="l05154"></a>05154   block = (<span class="keyword">struct </span>block *) block0;      <span class="comment">/* FIXME: No cast ought to be</span>
<a name="l05155"></a>05155 <span class="comment">                                           needed, but adding const will</span>
<a name="l05156"></a>05156 <span class="comment">                                           have a cascade effect.  */</span>
<a name="l05157"></a>05157 
<a name="l05158"></a>05158   <span class="comment">/* Special case: If the user specifies a symbol name inside package</span>
<a name="l05159"></a>05159 <span class="comment">     Standard, do a non-wild matching of the symbol name without</span>
<a name="l05160"></a>05160 <span class="comment">     the &quot;standard__&quot; prefix.  This was primarily introduced in order</span>
<a name="l05161"></a>05161 <span class="comment">     to allow the user to specifically access the standard exceptions</span>
<a name="l05162"></a>05162 <span class="comment">     using, for instance, Standard.Constraint_Error when Constraint_Error</span>
<a name="l05163"></a>05163 <span class="comment">     is ambiguous (due to the user defining its own Constraint_Error</span>
<a name="l05164"></a>05164 <span class="comment">     entity inside its program).  */</span>
<a name="l05165"></a>05165   <span class="keywordflow">if</span> (strncmp (name0, <span class="stringliteral">&quot;standard__&quot;</span>, <span class="keyword">sizeof</span> (<span class="stringliteral">&quot;standard__&quot;</span>) - 1) == 0)
<a name="l05166"></a>05166     {
<a name="l05167"></a>05167       block = NULL;
<a name="l05168"></a>05168       name = name0 + <span class="keyword">sizeof</span> (<span class="stringliteral">&quot;standard__&quot;</span>) - 1;
<a name="l05169"></a>05169     }
<a name="l05170"></a>05170 
<a name="l05171"></a>05171   <span class="comment">/* Check the non-global symbols.  If we have ANY match, then we&#39;re done.  */</span>
<a name="l05172"></a>05172 
<a name="l05173"></a>05173   <span class="keywordflow">if</span> (block != NULL)
<a name="l05174"></a>05174     {
<a name="l05175"></a>05175       <span class="keywordflow">if</span> (full_search)
<a name="l05176"></a>05176         {
<a name="l05177"></a>05177           ada_add_local_symbols (&amp;symbol_list_obstack, name, block,
<a name="l05178"></a>05178                                  <span class="keyword">namespace</span>, wild_match_p);
<a name="l05179"></a>05179         }
<a name="l05180"></a>05180       <span class="keywordflow">else</span>
<a name="l05181"></a>05181         {
<a name="l05182"></a>05182           <span class="comment">/* In the !full_search case we&#39;re are being called by</span>
<a name="l05183"></a>05183 <span class="comment">             ada_iterate_over_symbols, and we don&#39;t want to search</span>
<a name="l05184"></a>05184 <span class="comment">             superblocks.  */</span>
<a name="l05185"></a>05185           ada_add_block_symbols (&amp;symbol_list_obstack, block, name,
<a name="l05186"></a>05186                                  <span class="keyword">namespace</span>, NULL, wild_match_p);
<a name="l05187"></a>05187         }
<a name="l05188"></a>05188       <span class="keywordflow">if</span> (num_defns_collected (&amp;symbol_list_obstack) &gt; 0 || !full_search)
<a name="l05189"></a>05189         <span class="keywordflow">goto</span> done;
<a name="l05190"></a>05190     }
<a name="l05191"></a>05191 
<a name="l05192"></a>05192   <span class="comment">/* No non-global symbols found.  Check our cache to see if we have</span>
<a name="l05193"></a>05193 <span class="comment">     already performed this search before.  If we have, then return</span>
<a name="l05194"></a>05194 <span class="comment">     the same result.  */</span>
<a name="l05195"></a>05195 
<a name="l05196"></a>05196   cacheIfUnique = 1;
<a name="l05197"></a>05197   <span class="keywordflow">if</span> (lookup_cached_symbol (name0, <span class="keyword">namespace</span>, &amp;sym, &amp;block))
<a name="l05198"></a>05198     {
<a name="l05199"></a>05199       <span class="keywordflow">if</span> (sym != NULL)
<a name="l05200"></a>05200         add_defn_to_vec (&amp;symbol_list_obstack, sym, block);
<a name="l05201"></a>05201       <span class="keywordflow">goto</span> done;
<a name="l05202"></a>05202     }
<a name="l05203"></a>05203 
<a name="l05204"></a>05204   <span class="comment">/* Search symbols from all global blocks.  */</span>
<a name="l05205"></a>05205  
<a name="l05206"></a>05206   add_nonlocal_symbols (&amp;symbol_list_obstack, name, <span class="keyword">namespace</span>, 1,
<a name="l05207"></a>05207                         wild_match_p);
<a name="l05208"></a>05208 
<a name="l05209"></a>05209   <span class="comment">/* Now add symbols from all per-file blocks if we&#39;ve gotten no hits</span>
<a name="l05210"></a>05210 <span class="comment">     (not strictly correct, but perhaps better than an error).  */</span>
<a name="l05211"></a>05211 
<a name="l05212"></a>05212   <span class="keywordflow">if</span> (num_defns_collected (&amp;symbol_list_obstack) == 0)
<a name="l05213"></a>05213     add_nonlocal_symbols (&amp;symbol_list_obstack, name, <span class="keyword">namespace</span>, 0,
<a name="l05214"></a>05214                           wild_match_p);
<a name="l05215"></a>05215 
<a name="l05216"></a>05216 done:
<a name="l05217"></a>05217   ndefns = num_defns_collected (&amp;symbol_list_obstack);
<a name="l05218"></a>05218   *results = defns_collected (&amp;symbol_list_obstack, 1);
<a name="l05219"></a>05219 
<a name="l05220"></a>05220   ndefns = remove_extra_symbols (*results, ndefns);
<a name="l05221"></a>05221 
<a name="l05222"></a>05222   <span class="keywordflow">if</span> (ndefns == 0 &amp;&amp; full_search)
<a name="l05223"></a>05223     cache_symbol (name0, <span class="keyword">namespace</span>, NULL, NULL);
<a name="l05224"></a>05224 
<a name="l05225"></a>05225   <span class="keywordflow">if</span> (ndefns == 1 &amp;&amp; full_search &amp;&amp; cacheIfUnique)
<a name="l05226"></a>05226     cache_symbol (name0, <span class="keyword">namespace</span>, (*results)[0].sym, (*results)[0].block);
<a name="l05227"></a>05227 
<a name="l05228"></a>05228   ndefns = remove_irrelevant_renamings (*results, ndefns, block0);
<a name="l05229"></a>05229 
<a name="l05230"></a>05230   <span class="keywordflow">return</span> ndefns;
<a name="l05231"></a>05231 }
<a name="l05232"></a>05232 
<a name="l05233"></a>05233 <span class="comment">/* Find symbols in DOMAIN matching NAME0, in BLOCK0 and enclosing scope and</span>
<a name="l05234"></a>05234 <span class="comment">   in global scopes, returning the number of matches, and setting *RESULTS</span>
<a name="l05235"></a>05235 <span class="comment">   to a vector of (SYM,BLOCK) tuples.</span>
<a name="l05236"></a>05236 <span class="comment">   See ada_lookup_symbol_list_worker for further details.  */</span>
<a name="l05237"></a>05237 
<a name="l05238"></a>05238 <span class="keywordtype">int</span>
<a name="l05239"></a><a class="code" href="ada-lang_8h.html#a6e8cd500798f1501dbe82fc288484d04">05239</a> <a class="code" href="ada-lang_8c.html#aa04634fbe1ee55e7efef10df7f0bc55b">ada_lookup_symbol_list</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name0, <span class="keyword">const</span> <span class="keyword">struct</span> block *block0,
<a name="l05240"></a>05240                         <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> domain, <span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a> **results)
<a name="l05241"></a>05241 {
<a name="l05242"></a>05242   <span class="keywordflow">return</span> ada_lookup_symbol_list_worker (name0, block0, domain, results, 1);
<a name="l05243"></a>05243 }
<a name="l05244"></a>05244 
<a name="l05245"></a>05245 <span class="comment">/* Implementation of the la_iterate_over_symbols method.  */</span>
<a name="l05246"></a>05246 
<a name="l05247"></a>05247 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05248"></a>05248 ada_iterate_over_symbols (<span class="keyword">const</span> <span class="keyword">struct</span> block *block,
<a name="l05249"></a>05249                           <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> domain,
<a name="l05250"></a>05250                           <a class="code" href="symtab_8h.html#ad1b2c2531ca06f07126a3f18b5681136">symbol_found_callback_ftype</a> *callback,
<a name="l05251"></a>05251                           <span class="keywordtype">void</span> *data)
<a name="l05252"></a>05252 {
<a name="l05253"></a>05253   <span class="keywordtype">int</span> ndefs, i;
<a name="l05254"></a>05254   <span class="keyword">struct </span><a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *results;
<a name="l05255"></a>05255 
<a name="l05256"></a>05256   ndefs = ada_lookup_symbol_list_worker (name, block, domain, &amp;results, 0);
<a name="l05257"></a>05257   <span class="keywordflow">for</span> (i = 0; i &lt; ndefs; ++i)
<a name="l05258"></a>05258     {
<a name="l05259"></a>05259       <span class="keywordflow">if</span> (! (*callback) (results[i].sym, data))
<a name="l05260"></a>05260         <span class="keywordflow">break</span>;
<a name="l05261"></a>05261     }
<a name="l05262"></a>05262 }
<a name="l05263"></a>05263 
<a name="l05264"></a>05264 <span class="comment">/* If NAME is the name of an entity, return a string that should</span>
<a name="l05265"></a>05265 <span class="comment">   be used to look that entity up in Ada units.  This string should</span>
<a name="l05266"></a>05266 <span class="comment">   be deallocated after use using xfree.</span>
<a name="l05267"></a>05267 <span class="comment"></span>
<a name="l05268"></a>05268 <span class="comment">   NAME can have any form that the &quot;break&quot; or &quot;print&quot; commands might</span>
<a name="l05269"></a>05269 <span class="comment">   recognize.  In other words, it does not have to be the &quot;natural&quot;</span>
<a name="l05270"></a>05270 <span class="comment">   name, or the &quot;encoded&quot; name.  */</span>
<a name="l05271"></a>05271 
<a name="l05272"></a>05272 <span class="keywordtype">char</span> *
<a name="l05273"></a><a class="code" href="ada-lang_8h.html#af661b130d2c06e0913500e03a6bb26a2">05273</a> <a class="code" href="ada-lang_8c.html#af661b130d2c06e0913500e03a6bb26a2">ada_name_for_lookup</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l05274"></a>05274 {
<a name="l05275"></a>05275   <span class="keywordtype">char</span> *canon;
<a name="l05276"></a>05276   <span class="keywordtype">int</span> nlen = strlen (name);
<a name="l05277"></a>05277 
<a name="l05278"></a>05278   <span class="keywordflow">if</span> (name[0] == <span class="charliteral">&#39;&lt;&#39;</span> &amp;&amp; name[nlen - 1] == <span class="charliteral">&#39;&gt;&#39;</span>)
<a name="l05279"></a>05279     {
<a name="l05280"></a>05280       canon = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (nlen - 1);
<a name="l05281"></a>05281       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (canon, name + 1, nlen - 2);
<a name="l05282"></a>05282       canon[nlen - 2] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l05283"></a>05283     }
<a name="l05284"></a>05284   <span class="keywordflow">else</span>
<a name="l05285"></a>05285     canon = xstrdup (<a class="code" href="ada-lang_8c.html#ae2acc3345983845169c3d4239e922b75">ada_encode</a> (<a class="code" href="ada-lang_8c.html#a93c72077b027134d644b38b8fcf19036">ada_fold_name</a> (name)));
<a name="l05286"></a>05286   <span class="keywordflow">return</span> canon;
<a name="l05287"></a>05287 }
<a name="l05288"></a>05288 
<a name="l05289"></a>05289 <span class="comment">/* The result is as for ada_lookup_symbol_list with FULL_SEARCH set</span>
<a name="l05290"></a>05290 <span class="comment">   to 1, but choosing the first symbol found if there are multiple</span>
<a name="l05291"></a>05291 <span class="comment">   choices.</span>
<a name="l05292"></a>05292 <span class="comment"></span>
<a name="l05293"></a>05293 <span class="comment">   The result is stored in *INFO, which must be non-NULL.</span>
<a name="l05294"></a>05294 <span class="comment">   If no match is found, INFO-&gt;SYM is set to NULL.  */</span>
<a name="l05295"></a>05295 
<a name="l05296"></a>05296 <span class="keywordtype">void</span>
<a name="l05297"></a><a class="code" href="ada-lang_8h.html#a4c5e5e0c736011114e0231fd2d7746c0">05297</a> <a class="code" href="ada-lang_8c.html#a2a8adba6de3997242971f444e0927921">ada_lookup_encoded_symbol</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keyword">struct</span> block *block,
<a name="l05298"></a>05298                            <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> <span class="keyword">namespace</span>,
<a name="l05299"></a>05299                            <span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *info)
<a name="l05300"></a>05300 {
<a name="l05301"></a>05301   <span class="keyword">struct </span><a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *candidates;
<a name="l05302"></a>05302   <span class="keywordtype">int</span> n_candidates;
<a name="l05303"></a>05303 
<a name="l05304"></a>05304   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (info != NULL);
<a name="l05305"></a>05305   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (info, 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structada__symbol__info.html">ada_symbol_info</a>));
<a name="l05306"></a>05306 
<a name="l05307"></a>05307   n_candidates = <a class="code" href="ada-lang_8c.html#aa04634fbe1ee55e7efef10df7f0bc55b">ada_lookup_symbol_list</a> (name, block, <span class="keyword">namespace</span>, &amp;candidates);
<a name="l05308"></a>05308   <span class="keywordflow">if</span> (n_candidates == 0)
<a name="l05309"></a>05309     <span class="keywordflow">return</span>;
<a name="l05310"></a>05310 
<a name="l05311"></a>05311   *info = candidates[0];
<a name="l05312"></a>05312   info-&gt;<a class="code" href="structada__symbol__info.html#ab424e8140f59e695fcb43c8d1c818728">sym</a> = <a class="code" href="symtab_8c.html#a569809b8edfbd2e0a6d9bb40295840f0">fixup_symbol_section</a> (info-&gt;<a class="code" href="structada__symbol__info.html#ab424e8140f59e695fcb43c8d1c818728">sym</a>, NULL);
<a name="l05313"></a>05313 }
<a name="l05314"></a>05314 
<a name="l05315"></a>05315 <span class="comment">/* Return a symbol in DOMAIN matching NAME, in BLOCK0 and enclosing</span>
<a name="l05316"></a>05316 <span class="comment">   scope and in global scopes, or NULL if none.  NAME is folded and</span>
<a name="l05317"></a>05317 <span class="comment">   encoded first.  Otherwise, the result is as for ada_lookup_symbol_list,</span>
<a name="l05318"></a>05318 <span class="comment">   choosing the first symbol if there are multiple choices.</span>
<a name="l05319"></a>05319 <span class="comment">   If IS_A_FIELD_OF_THIS is not NULL, it is set to zero.  */</span>
<a name="l05320"></a>05320 
<a name="l05321"></a>05321 <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *
<a name="l05322"></a><a class="code" href="ada-lang_8h.html#ad183f2acb86c640adb839f8dc304aa7d">05322</a> <a class="code" href="ada-lang_8c.html#aa1f04e6ee14a374aafe3c955848f9bec">ada_lookup_symbol</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keyword">struct</span> block *block0,
<a name="l05323"></a>05323                    <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> <span class="keyword">namespace</span>, <span class="keywordtype">int</span> *is_a_field_of_this)
<a name="l05324"></a>05324 {
<a name="l05325"></a>05325   <span class="keyword">struct </span><a class="code" href="structada__symbol__info.html">ada_symbol_info</a> info;
<a name="l05326"></a>05326 
<a name="l05327"></a>05327   <span class="keywordflow">if</span> (is_a_field_of_this != NULL)
<a name="l05328"></a>05328     *is_a_field_of_this = 0;
<a name="l05329"></a>05329 
<a name="l05330"></a>05330   <a class="code" href="ada-lang_8c.html#a2a8adba6de3997242971f444e0927921">ada_lookup_encoded_symbol</a> (<a class="code" href="ada-lang_8c.html#ae2acc3345983845169c3d4239e922b75">ada_encode</a> (<a class="code" href="ada-lang_8c.html#a93c72077b027134d644b38b8fcf19036">ada_fold_name</a> (name)),
<a name="l05331"></a>05331                              block0, <span class="keyword">namespace</span>, &amp;info);
<a name="l05332"></a>05332   <span class="keywordflow">return</span> info.<a class="code" href="structada__symbol__info.html#ab424e8140f59e695fcb43c8d1c818728">sym</a>;
<a name="l05333"></a>05333 }
<a name="l05334"></a>05334 
<a name="l05335"></a>05335 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *
<a name="l05336"></a>05336 ada_lookup_symbol_nonlocal (<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l05337"></a>05337                             <span class="keyword">const</span> <span class="keyword">struct</span> block *block,
<a name="l05338"></a>05338                             <span class="keyword">const</span> <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> domain)
<a name="l05339"></a>05339 {
<a name="l05340"></a>05340   <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#aa1f04e6ee14a374aafe3c955848f9bec">ada_lookup_symbol</a> (name, <a class="code" href="block_8c.html#a05911f60e374e7045638058c1ef6dfd1">block_static_block</a> (block), domain, NULL);
<a name="l05341"></a>05341 }
<a name="l05342"></a>05342 
<a name="l05343"></a>05343 
<a name="l05344"></a>05344 <span class="comment">/* True iff STR is a possible encoded suffix of a normal Ada name</span>
<a name="l05345"></a>05345 <span class="comment">   that is to be ignored for matching purposes.  Suffixes of parallel</span>
<a name="l05346"></a>05346 <span class="comment">   names (e.g., XVE) are not included here.  Currently, the possible suffixes</span>
<a name="l05347"></a>05347 <span class="comment">   are given by any of the regular expressions:</span>
<a name="l05348"></a>05348 <span class="comment"></span>
<a name="l05349"></a>05349 <span class="comment">   [.$][0-9]+       [nested subprogram suffix, on platforms such as GNU/Linux]</span>
<a name="l05350"></a>05350 <span class="comment">   ___[0-9]+        [nested subprogram suffix, on platforms such as HP/UX]</span>
<a name="l05351"></a>05351 <span class="comment">   TKB              [subprogram suffix for task bodies]</span>
<a name="l05352"></a>05352 <span class="comment">   _E[0-9]+[bs]$    [protected object entry suffixes]</span>
<a name="l05353"></a>05353 <span class="comment">   (X[nb]*)?((\$|__)[0-9](_?[0-9]+)|___(JM|LJM|X([FDBUP].*|R[^T]?)))?$</span>
<a name="l05354"></a>05354 <span class="comment"></span>
<a name="l05355"></a>05355 <span class="comment">   Also, any leading &quot;__[0-9]+&quot; sequence is skipped before the suffix</span>
<a name="l05356"></a>05356 <span class="comment">   match is performed.  This sequence is used to differentiate homonyms,</span>
<a name="l05357"></a>05357 <span class="comment">   is an optional part of a valid name suffix.  */</span>
<a name="l05358"></a>05358 
<a name="l05359"></a>05359 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05360"></a>05360 is_name_suffix (<span class="keyword">const</span> <span class="keywordtype">char</span> *str)
<a name="l05361"></a>05361 {
<a name="l05362"></a>05362   <span class="keywordtype">int</span> k;
<a name="l05363"></a>05363   <span class="keyword">const</span> <span class="keywordtype">char</span> *matching;
<a name="l05364"></a>05364   <span class="keyword">const</span> <span class="keywordtype">int</span> len = strlen (str);
<a name="l05365"></a>05365 
<a name="l05366"></a>05366   <span class="comment">/* Skip optional leading __[0-9]+.  */</span>
<a name="l05367"></a>05367 
<a name="l05368"></a>05368   <span class="keywordflow">if</span> (len &gt; 3 &amp;&amp; str[0] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; str[1] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; isdigit (str[2]))
<a name="l05369"></a>05369     {
<a name="l05370"></a>05370       str += 3;
<a name="l05371"></a>05371       <span class="keywordflow">while</span> (isdigit (str[0]))
<a name="l05372"></a>05372         str += 1;
<a name="l05373"></a>05373     }
<a name="l05374"></a>05374   
<a name="l05375"></a>05375   <span class="comment">/* [.$][0-9]+ */</span>
<a name="l05376"></a>05376 
<a name="l05377"></a>05377   <span class="keywordflow">if</span> (str[0] == <span class="charliteral">&#39;.&#39;</span> || str[0] == <span class="charliteral">&#39;$&#39;</span>)
<a name="l05378"></a>05378     {
<a name="l05379"></a>05379       matching = str + 1;
<a name="l05380"></a>05380       <span class="keywordflow">while</span> (isdigit (matching[0]))
<a name="l05381"></a>05381         matching += 1;
<a name="l05382"></a>05382       <span class="keywordflow">if</span> (matching[0] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l05383"></a>05383         <span class="keywordflow">return</span> 1;
<a name="l05384"></a>05384     }
<a name="l05385"></a>05385 
<a name="l05386"></a>05386   <span class="comment">/* ___[0-9]+ */</span>
<a name="l05387"></a>05387 
<a name="l05388"></a>05388   <span class="keywordflow">if</span> (len &gt; 3 &amp;&amp; str[0] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; str[1] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; str[2] == <span class="charliteral">&#39;_&#39;</span>)
<a name="l05389"></a>05389     {
<a name="l05390"></a>05390       matching = str + 3;
<a name="l05391"></a>05391       <span class="keywordflow">while</span> (isdigit (matching[0]))
<a name="l05392"></a>05392         matching += 1;
<a name="l05393"></a>05393       <span class="keywordflow">if</span> (matching[0] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l05394"></a>05394         <span class="keywordflow">return</span> 1;
<a name="l05395"></a>05395     }
<a name="l05396"></a>05396 
<a name="l05397"></a>05397   <span class="comment">/* &quot;TKB&quot; suffixes are used for subprograms implementing task bodies.  */</span>
<a name="l05398"></a>05398 
<a name="l05399"></a>05399   <span class="keywordflow">if</span> (strcmp (str, <span class="stringliteral">&quot;TKB&quot;</span>) == 0)
<a name="l05400"></a>05400     <span class="keywordflow">return</span> 1;
<a name="l05401"></a>05401 
<a name="l05402"></a>05402 <span class="preprocessor">#if 0</span>
<a name="l05403"></a>05403 <span class="preprocessor"></span>  <span class="comment">/* FIXME: brobecker/2005-09-23: Protected Object subprograms end</span>
<a name="l05404"></a>05404 <span class="comment">     with a N at the end.  Unfortunately, the compiler uses the same</span>
<a name="l05405"></a>05405 <span class="comment">     convention for other internal types it creates.  So treating</span>
<a name="l05406"></a>05406 <span class="comment">     all entity names that end with an &quot;N&quot; as a name suffix causes</span>
<a name="l05407"></a>05407 <span class="comment">     some regressions.  For instance, consider the case of an enumerated</span>
<a name="l05408"></a>05408 <span class="comment">     type.  To support the &#39;Image attribute, it creates an array whose</span>
<a name="l05409"></a>05409 <span class="comment">     name ends with N.</span>
<a name="l05410"></a>05410 <span class="comment">     Having a single character like this as a suffix carrying some</span>
<a name="l05411"></a>05411 <span class="comment">     information is a bit risky.  Perhaps we should change the encoding</span>
<a name="l05412"></a>05412 <span class="comment">     to be something like &quot;_N&quot; instead.  In the meantime, do not do</span>
<a name="l05413"></a>05413 <span class="comment">     the following check.  */</span>
<a name="l05414"></a>05414   <span class="comment">/* Protected Object Subprograms */</span>
<a name="l05415"></a>05415   <span class="keywordflow">if</span> (len == 1 &amp;&amp; str [0] == <span class="charliteral">&#39;N&#39;</span>)
<a name="l05416"></a>05416     <span class="keywordflow">return</span> 1;
<a name="l05417"></a>05417 <span class="preprocessor">#endif</span>
<a name="l05418"></a>05418 <span class="preprocessor"></span>
<a name="l05419"></a>05419   <span class="comment">/* _E[0-9]+[bs]$ */</span>
<a name="l05420"></a>05420   <span class="keywordflow">if</span> (len &gt; 3 &amp;&amp; str[0] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; str [1] == <span class="charliteral">&#39;E&#39;</span> &amp;&amp; isdigit (str[2]))
<a name="l05421"></a>05421     {
<a name="l05422"></a>05422       matching = str + 3;
<a name="l05423"></a>05423       <span class="keywordflow">while</span> (isdigit (matching[0]))
<a name="l05424"></a>05424         matching += 1;
<a name="l05425"></a>05425       <span class="keywordflow">if</span> ((matching[0] == <span class="charliteral">&#39;b&#39;</span> || matching[0] == <span class="charliteral">&#39;s&#39;</span>)
<a name="l05426"></a>05426           &amp;&amp; matching [1] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l05427"></a>05427         <span class="keywordflow">return</span> 1;
<a name="l05428"></a>05428     }
<a name="l05429"></a>05429 
<a name="l05430"></a>05430   <span class="comment">/* ??? We should not modify STR directly, as we are doing below.  This</span>
<a name="l05431"></a>05431 <span class="comment">     is fine in this case, but may become problematic later if we find</span>
<a name="l05432"></a>05432 <span class="comment">     that this alternative did not work, and want to try matching</span>
<a name="l05433"></a>05433 <span class="comment">     another one from the begining of STR.  Since we modified it, we</span>
<a name="l05434"></a>05434 <span class="comment">     won&#39;t be able to find the begining of the string anymore!  */</span>
<a name="l05435"></a>05435   <span class="keywordflow">if</span> (str[0] == <span class="charliteral">&#39;X&#39;</span>)
<a name="l05436"></a>05436     {
<a name="l05437"></a>05437       str += 1;
<a name="l05438"></a>05438       <span class="keywordflow">while</span> (str[0] != <span class="charliteral">&#39;_&#39;</span> &amp;&amp; str[0] != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l05439"></a>05439         {
<a name="l05440"></a>05440           <span class="keywordflow">if</span> (str[0] != <span class="charliteral">&#39;n&#39;</span> &amp;&amp; str[0] != <span class="charliteral">&#39;b&#39;</span>)
<a name="l05441"></a>05441             <span class="keywordflow">return</span> 0;
<a name="l05442"></a>05442           str += 1;
<a name="l05443"></a>05443         }
<a name="l05444"></a>05444     }
<a name="l05445"></a>05445 
<a name="l05446"></a>05446   <span class="keywordflow">if</span> (str[0] == <span class="charliteral">&#39;\000&#39;</span>)
<a name="l05447"></a>05447     <span class="keywordflow">return</span> 1;
<a name="l05448"></a>05448 
<a name="l05449"></a>05449   <span class="keywordflow">if</span> (str[0] == <span class="charliteral">&#39;_&#39;</span>)
<a name="l05450"></a>05450     {
<a name="l05451"></a>05451       <span class="keywordflow">if</span> (str[1] != <span class="charliteral">&#39;_&#39;</span> || str[2] == <span class="charliteral">&#39;\000&#39;</span>)
<a name="l05452"></a>05452         <span class="keywordflow">return</span> 0;
<a name="l05453"></a>05453       <span class="keywordflow">if</span> (str[2] == <span class="charliteral">&#39;_&#39;</span>)
<a name="l05454"></a>05454         {
<a name="l05455"></a>05455           <span class="keywordflow">if</span> (strcmp (str + 3, <span class="stringliteral">&quot;JM&quot;</span>) == 0)
<a name="l05456"></a>05456             <span class="keywordflow">return</span> 1;
<a name="l05457"></a>05457           <span class="comment">/* FIXME: brobecker/2004-09-30: GNAT will soon stop using</span>
<a name="l05458"></a>05458 <span class="comment">             the LJM suffix in favor of the JM one.  But we will</span>
<a name="l05459"></a>05459 <span class="comment">             still accept LJM as a valid suffix for a reasonable</span>
<a name="l05460"></a>05460 <span class="comment">             amount of time, just to allow ourselves to debug programs</span>
<a name="l05461"></a>05461 <span class="comment">             compiled using an older version of GNAT.  */</span>
<a name="l05462"></a>05462           <span class="keywordflow">if</span> (strcmp (str + 3, <span class="stringliteral">&quot;LJM&quot;</span>) == 0)
<a name="l05463"></a>05463             <span class="keywordflow">return</span> 1;
<a name="l05464"></a>05464           <span class="keywordflow">if</span> (str[3] != <span class="charliteral">&#39;X&#39;</span>)
<a name="l05465"></a>05465             <span class="keywordflow">return</span> 0;
<a name="l05466"></a>05466           <span class="keywordflow">if</span> (str[4] == <span class="charliteral">&#39;F&#39;</span> || str[4] == <span class="charliteral">&#39;D&#39;</span> || str[4] == <span class="charliteral">&#39;B&#39;</span>
<a name="l05467"></a>05467               || str[4] == <span class="charliteral">&#39;U&#39;</span> || str[4] == <span class="charliteral">&#39;P&#39;</span>)
<a name="l05468"></a>05468             <span class="keywordflow">return</span> 1;
<a name="l05469"></a>05469           <span class="keywordflow">if</span> (str[4] == <span class="charliteral">&#39;R&#39;</span> &amp;&amp; str[5] != <span class="charliteral">&#39;T&#39;</span>)
<a name="l05470"></a>05470             <span class="keywordflow">return</span> 1;
<a name="l05471"></a>05471           <span class="keywordflow">return</span> 0;
<a name="l05472"></a>05472         }
<a name="l05473"></a>05473       <span class="keywordflow">if</span> (!isdigit (str[2]))
<a name="l05474"></a>05474         <span class="keywordflow">return</span> 0;
<a name="l05475"></a>05475       <span class="keywordflow">for</span> (k = 3; str[k] != <span class="charliteral">&#39;\0&#39;</span>; k += 1)
<a name="l05476"></a>05476         <span class="keywordflow">if</span> (!isdigit (str[k]) &amp;&amp; str[k] != <span class="charliteral">&#39;_&#39;</span>)
<a name="l05477"></a>05477           <span class="keywordflow">return</span> 0;
<a name="l05478"></a>05478       <span class="keywordflow">return</span> 1;
<a name="l05479"></a>05479     }
<a name="l05480"></a>05480   <span class="keywordflow">if</span> (str[0] == <span class="charliteral">&#39;$&#39;</span> &amp;&amp; isdigit (str[1]))
<a name="l05481"></a>05481     {
<a name="l05482"></a>05482       <span class="keywordflow">for</span> (k = 2; str[k] != <span class="charliteral">&#39;\0&#39;</span>; k += 1)
<a name="l05483"></a>05483         <span class="keywordflow">if</span> (!isdigit (str[k]) &amp;&amp; str[k] != <span class="charliteral">&#39;_&#39;</span>)
<a name="l05484"></a>05484           <span class="keywordflow">return</span> 0;
<a name="l05485"></a>05485       <span class="keywordflow">return</span> 1;
<a name="l05486"></a>05486     }
<a name="l05487"></a>05487   <span class="keywordflow">return</span> 0;
<a name="l05488"></a>05488 }
<a name="l05489"></a>05489 
<a name="l05490"></a>05490 <span class="comment">/* Return non-zero if the string starting at NAME and ending before</span>
<a name="l05491"></a>05491 <span class="comment">   NAME_END contains no capital letters.  */</span>
<a name="l05492"></a>05492 
<a name="l05493"></a>05493 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05494"></a>05494 is_valid_name_for_wild_match (<span class="keyword">const</span> <span class="keywordtype">char</span> *name0)
<a name="l05495"></a>05495 {
<a name="l05496"></a>05496   <span class="keyword">const</span> <span class="keywordtype">char</span> *decoded_name = <a class="code" href="ada-lang_8c.html#a09b16b65c7ccf6ce05e91a51321903a1">ada_decode</a> (name0);
<a name="l05497"></a>05497   <span class="keywordtype">int</span> i;
<a name="l05498"></a>05498 
<a name="l05499"></a>05499   <span class="comment">/* If the decoded name starts with an angle bracket, it means that</span>
<a name="l05500"></a>05500 <span class="comment">     NAME0 does not follow the GNAT encoding format.  It should then</span>
<a name="l05501"></a>05501 <span class="comment">     not be allowed as a possible wild match.  */</span>
<a name="l05502"></a>05502   <span class="keywordflow">if</span> (decoded_name[0] == <span class="charliteral">&#39;&lt;&#39;</span>)
<a name="l05503"></a>05503     <span class="keywordflow">return</span> 0;
<a name="l05504"></a>05504 
<a name="l05505"></a>05505   <span class="keywordflow">for</span> (i=0; decoded_name[i] != <span class="charliteral">&#39;\0&#39;</span>; i++)
<a name="l05506"></a>05506     <span class="keywordflow">if</span> (isalpha (decoded_name[i]) &amp;&amp; !islower (decoded_name[i]))
<a name="l05507"></a>05507       <span class="keywordflow">return</span> 0;
<a name="l05508"></a>05508 
<a name="l05509"></a>05509   <span class="keywordflow">return</span> 1;
<a name="l05510"></a>05510 }
<a name="l05511"></a>05511 
<a name="l05512"></a>05512 <span class="comment">/* Advance *NAMEP to next occurrence of TARGET0 in the string NAME0</span>
<a name="l05513"></a>05513 <span class="comment">   that could start a simple name.  Assumes that *NAMEP points into</span>
<a name="l05514"></a>05514 <span class="comment">   the string beginning at NAME0.  */</span>
<a name="l05515"></a>05515 
<a name="l05516"></a>05516 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05517"></a>05517 advance_wild_match (<span class="keyword">const</span> <span class="keywordtype">char</span> **namep, <span class="keyword">const</span> <span class="keywordtype">char</span> *name0, <span class="keywordtype">int</span> target0)
<a name="l05518"></a>05518 {
<a name="l05519"></a>05519   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = *namep;
<a name="l05520"></a>05520 
<a name="l05521"></a>05521   <span class="keywordflow">while</span> (1)
<a name="l05522"></a>05522     {
<a name="l05523"></a>05523       <span class="keywordtype">int</span> t0, t1;
<a name="l05524"></a>05524 
<a name="l05525"></a>05525       t0 = *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l05526"></a>05526       <span class="keywordflow">if</span> (t0 == <span class="charliteral">&#39;_&#39;</span>)
<a name="l05527"></a>05527         {
<a name="l05528"></a>05528           t1 = name[1];
<a name="l05529"></a>05529           <span class="keywordflow">if</span> ((t1 &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;&amp; t1 &lt;= <span class="charliteral">&#39;z&#39;</span>) || (t1 &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; t1 &lt;= <span class="charliteral">&#39;9&#39;</span>))
<a name="l05530"></a>05530             {
<a name="l05531"></a>05531               name += 1;
<a name="l05532"></a>05532               <span class="keywordflow">if</span> (name == name0 + 5 &amp;&amp; strncmp (name0, <span class="stringliteral">&quot;_ada&quot;</span>, 4) == 0)
<a name="l05533"></a>05533                 <span class="keywordflow">break</span>;
<a name="l05534"></a>05534               <span class="keywordflow">else</span>
<a name="l05535"></a>05535                 name += 1;
<a name="l05536"></a>05536             }
<a name="l05537"></a>05537           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t1 == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; ((name[2] &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;&amp; name[2] &lt;= <span class="charliteral">&#39;z&#39;</span>)
<a name="l05538"></a>05538                                  || name[2] == target0))
<a name="l05539"></a>05539             {
<a name="l05540"></a>05540               name += 2;
<a name="l05541"></a>05541               <span class="keywordflow">break</span>;
<a name="l05542"></a>05542             }
<a name="l05543"></a>05543           <span class="keywordflow">else</span>
<a name="l05544"></a>05544             <span class="keywordflow">return</span> 0;
<a name="l05545"></a>05545         }
<a name="l05546"></a>05546       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((t0 &gt;= <span class="charliteral">&#39;a&#39;</span> &amp;&amp; t0 &lt;= <span class="charliteral">&#39;z&#39;</span>) || (t0 &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; t0 &lt;= <span class="charliteral">&#39;9&#39;</span>))
<a name="l05547"></a>05547         name += 1;
<a name="l05548"></a>05548       <span class="keywordflow">else</span>
<a name="l05549"></a>05549         <span class="keywordflow">return</span> 0;
<a name="l05550"></a>05550     }
<a name="l05551"></a>05551 
<a name="l05552"></a>05552   *namep = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l05553"></a>05553   <span class="keywordflow">return</span> 1;
<a name="l05554"></a>05554 }
<a name="l05555"></a>05555 
<a name="l05556"></a>05556 <span class="comment">/* Return 0 iff NAME encodes a name of the form prefix.PATN.  Ignores any</span>
<a name="l05557"></a>05557 <span class="comment">   informational suffixes of NAME (i.e., for which is_name_suffix is</span>
<a name="l05558"></a>05558 <span class="comment">   true).  Assumes that PATN is a lower-cased Ada simple name.  */</span>
<a name="l05559"></a>05559 
<a name="l05560"></a>05560 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05561"></a>05561 wild_match (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *patn)
<a name="l05562"></a>05562 {
<a name="l05563"></a>05563   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="windows-nat_8c.html#ade66e4ccafbc33b117610bbc0d85feb0">p</a>;
<a name="l05564"></a>05564   <span class="keyword">const</span> <span class="keywordtype">char</span> *name0 = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l05565"></a>05565 
<a name="l05566"></a>05566   <span class="keywordflow">while</span> (1)
<a name="l05567"></a>05567     {
<a name="l05568"></a>05568       <span class="keyword">const</span> <span class="keywordtype">char</span> *match = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l05569"></a>05569 
<a name="l05570"></a>05570       <span class="keywordflow">if</span> (*name == *patn)
<a name="l05571"></a>05571         {
<a name="l05572"></a>05572           <span class="keywordflow">for</span> (name += 1, p = patn + 1; *p != <span class="charliteral">&#39;\0&#39;</span>; name += 1, p += 1)
<a name="l05573"></a>05573             <span class="keywordflow">if</span> (*p != *name)
<a name="l05574"></a>05574               <span class="keywordflow">break</span>;
<a name="l05575"></a>05575           <span class="keywordflow">if</span> (*p == <span class="charliteral">&#39;\0&#39;</span> &amp;&amp; is_name_suffix (name))
<a name="l05576"></a>05576             <span class="keywordflow">return</span> match != name0 &amp;&amp; !is_valid_name_for_wild_match (name0);
<a name="l05577"></a>05577 
<a name="l05578"></a>05578           <span class="keywordflow">if</span> (name[-1] == <span class="charliteral">&#39;_&#39;</span>)
<a name="l05579"></a>05579             name -= 1;
<a name="l05580"></a>05580         }
<a name="l05581"></a>05581       <span class="keywordflow">if</span> (!advance_wild_match (&amp;name, name0, *patn))
<a name="l05582"></a>05582         <span class="keywordflow">return</span> 1;
<a name="l05583"></a>05583     }
<a name="l05584"></a>05584 }
<a name="l05585"></a>05585 
<a name="l05586"></a>05586 <span class="comment">/* Returns 0 iff symbol name SYM_NAME matches SEARCH_NAME, apart from</span>
<a name="l05587"></a>05587 <span class="comment">   informational suffix.  */</span>
<a name="l05588"></a>05588 
<a name="l05589"></a>05589 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05590"></a>05590 full_match (<span class="keyword">const</span> <span class="keywordtype">char</span> *sym_name, <span class="keyword">const</span> <span class="keywordtype">char</span> *search_name)
<a name="l05591"></a>05591 {
<a name="l05592"></a>05592   <span class="keywordflow">return</span> !match_name (sym_name, search_name, 0);
<a name="l05593"></a>05593 }
<a name="l05594"></a>05594 
<a name="l05595"></a>05595 
<a name="l05596"></a>05596 <span class="comment">/* Add symbols from BLOCK matching identifier NAME in DOMAIN to</span>
<a name="l05597"></a>05597 <span class="comment">   vector *defn_symbols, updating the list of symbols in OBSTACKP </span>
<a name="l05598"></a>05598 <span class="comment">   (if necessary).  If WILD, treat as NAME with a wildcard prefix.</span>
<a name="l05599"></a>05599 <span class="comment">   OBJFILE is the section containing BLOCK.  */</span>
<a name="l05600"></a>05600 
<a name="l05601"></a>05601 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05602"></a>05602 ada_add_block_symbols (<span class="keyword">struct</span> obstack *obstackp,
<a name="l05603"></a>05603                        <span class="keyword">struct</span> block *block, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l05604"></a>05604                        <a class="code" href="symtab_8h.html#abbcd14557de81830c9e96ea4bdfc14aa">domain_enum</a> domain, <span class="keyword">struct</span> objfile *objfile,
<a name="l05605"></a>05605                        <span class="keywordtype">int</span> wild)
<a name="l05606"></a>05606 {
<a name="l05607"></a>05607   <span class="keyword">struct </span><a class="code" href="structblock__iterator.html">block_iterator</a> iter;
<a name="l05608"></a>05608   <span class="keywordtype">int</span> name_len = strlen (name);
<a name="l05609"></a>05609   <span class="comment">/* A matching argument symbol, if any.  */</span>
<a name="l05610"></a>05610   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *arg_sym;
<a name="l05611"></a>05611   <span class="comment">/* Set true when we find a matching non-argument symbol.  */</span>
<a name="l05612"></a>05612   <span class="keywordtype">int</span> found_sym;
<a name="l05613"></a>05613   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l05614"></a>05614 
<a name="l05615"></a>05615   arg_sym = NULL;
<a name="l05616"></a>05616   found_sym = 0;
<a name="l05617"></a>05617   <span class="keywordflow">if</span> (wild)
<a name="l05618"></a>05618     {
<a name="l05619"></a>05619       <span class="keywordflow">for</span> (sym = <a class="code" href="block_8c.html#a0938a1eb8284a627679b4f9c7017b641">block_iter_match_first</a> (block, name, wild_match, &amp;iter);
<a name="l05620"></a>05620            sym != NULL; sym = <a class="code" href="block_8c.html#a2778671a23255479265eb187754ba06a">block_iter_match_next</a> (name, wild_match, &amp;iter))
<a name="l05621"></a>05621       {
<a name="l05622"></a>05622         <span class="keywordflow">if</span> (<a class="code" href="symtab_8c.html#a0e427a626fe6f76b83881c89fe5e8155">symbol_matches_domain</a> (<a class="code" href="symtab_8h.html#a82fc22e60b1007c826a5ebf7d6593e78">SYMBOL_LANGUAGE</a> (sym),
<a name="l05623"></a>05623                                    <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym), domain)
<a name="l05624"></a>05624             &amp;&amp; wild_match (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym), name) == 0)
<a name="l05625"></a>05625           {
<a name="l05626"></a>05626             <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a3d61e7ad56c95328fba05416abc73f7a">LOC_UNRESOLVED</a>)
<a name="l05627"></a>05627               <span class="keywordflow">continue</span>;
<a name="l05628"></a>05628             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#ab3de6f2d8c380d3ca8bef520b1b4dfb9">SYMBOL_IS_ARGUMENT</a> (sym))
<a name="l05629"></a>05629               arg_sym = sym;
<a name="l05630"></a>05630             <span class="keywordflow">else</span>
<a name="l05631"></a>05631               {
<a name="l05632"></a>05632                 found_sym = 1;
<a name="l05633"></a>05633                 add_defn_to_vec (obstackp,
<a name="l05634"></a>05634                                  <a class="code" href="symtab_8c.html#a569809b8edfbd2e0a6d9bb40295840f0">fixup_symbol_section</a> (sym, objfile),
<a name="l05635"></a>05635                                  block);
<a name="l05636"></a>05636               }
<a name="l05637"></a>05637           }
<a name="l05638"></a>05638       }
<a name="l05639"></a>05639     }
<a name="l05640"></a>05640   <span class="keywordflow">else</span>
<a name="l05641"></a>05641     {
<a name="l05642"></a>05642      <span class="keywordflow">for</span> (sym = <a class="code" href="block_8c.html#a0938a1eb8284a627679b4f9c7017b641">block_iter_match_first</a> (block, name, full_match, &amp;iter);
<a name="l05643"></a>05643           sym != NULL; sym = <a class="code" href="block_8c.html#a2778671a23255479265eb187754ba06a">block_iter_match_next</a> (name, full_match, &amp;iter))
<a name="l05644"></a>05644       {
<a name="l05645"></a>05645         <span class="keywordflow">if</span> (<a class="code" href="symtab_8c.html#a0e427a626fe6f76b83881c89fe5e8155">symbol_matches_domain</a> (<a class="code" href="symtab_8h.html#a82fc22e60b1007c826a5ebf7d6593e78">SYMBOL_LANGUAGE</a> (sym),
<a name="l05646"></a>05646                                    <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym), domain))
<a name="l05647"></a>05647           {
<a name="l05648"></a>05648             <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) != <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a3d61e7ad56c95328fba05416abc73f7a">LOC_UNRESOLVED</a>)
<a name="l05649"></a>05649               {
<a name="l05650"></a>05650                 <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#ab3de6f2d8c380d3ca8bef520b1b4dfb9">SYMBOL_IS_ARGUMENT</a> (sym))
<a name="l05651"></a>05651                   arg_sym = sym;
<a name="l05652"></a>05652                 <span class="keywordflow">else</span>
<a name="l05653"></a>05653                   {
<a name="l05654"></a>05654                     found_sym = 1;
<a name="l05655"></a>05655                     add_defn_to_vec (obstackp,
<a name="l05656"></a>05656                                      <a class="code" href="symtab_8c.html#a569809b8edfbd2e0a6d9bb40295840f0">fixup_symbol_section</a> (sym, objfile),
<a name="l05657"></a>05657                                      block);
<a name="l05658"></a>05658                   }
<a name="l05659"></a>05659               }
<a name="l05660"></a>05660           }
<a name="l05661"></a>05661       }
<a name="l05662"></a>05662     }
<a name="l05663"></a>05663 
<a name="l05664"></a>05664   <span class="keywordflow">if</span> (!found_sym &amp;&amp; arg_sym != NULL)
<a name="l05665"></a>05665     {
<a name="l05666"></a>05666       add_defn_to_vec (obstackp,
<a name="l05667"></a>05667                        <a class="code" href="symtab_8c.html#a569809b8edfbd2e0a6d9bb40295840f0">fixup_symbol_section</a> (arg_sym, objfile),
<a name="l05668"></a>05668                        block);
<a name="l05669"></a>05669     }
<a name="l05670"></a>05670 
<a name="l05671"></a>05671   <span class="keywordflow">if</span> (!wild)
<a name="l05672"></a>05672     {
<a name="l05673"></a>05673       arg_sym = NULL;
<a name="l05674"></a>05674       found_sym = 0;
<a name="l05675"></a>05675 
<a name="l05676"></a>05676       <a class="code" href="block_8h.html#a0ffb1db4f5e3a6fd58700861fce48c2b">ALL_BLOCK_SYMBOLS</a> (block, iter, sym)
<a name="l05677"></a>05677       {
<a name="l05678"></a>05678         <span class="keywordflow">if</span> (<a class="code" href="symtab_8c.html#a0e427a626fe6f76b83881c89fe5e8155">symbol_matches_domain</a> (<a class="code" href="symtab_8h.html#a82fc22e60b1007c826a5ebf7d6593e78">SYMBOL_LANGUAGE</a> (sym),
<a name="l05679"></a>05679                                    <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (sym), domain))
<a name="l05680"></a>05680           {
<a name="l05681"></a>05681             <span class="keywordtype">int</span> cmp;
<a name="l05682"></a>05682 
<a name="l05683"></a>05683             cmp = (<a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>) <span class="charliteral">&#39;_&#39;</span> - (<span class="keywordtype">int</span>) <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym)[0];
<a name="l05684"></a>05684             <span class="keywordflow">if</span> (cmp == 0)
<a name="l05685"></a>05685               {
<a name="l05686"></a>05686                 cmp = strncmp (<span class="stringliteral">&quot;_ada_&quot;</span>, <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym), 5);
<a name="l05687"></a>05687                 <span class="keywordflow">if</span> (cmp == 0)
<a name="l05688"></a>05688                   cmp = strncmp (name, <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym) + 5,
<a name="l05689"></a>05689                                  name_len);
<a name="l05690"></a>05690               }
<a name="l05691"></a>05691 
<a name="l05692"></a>05692             <span class="keywordflow">if</span> (cmp == 0
<a name="l05693"></a>05693                 &amp;&amp; is_name_suffix (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym) + name_len + 5))
<a name="l05694"></a>05694               {
<a name="l05695"></a>05695                 <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) != <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a3d61e7ad56c95328fba05416abc73f7a">LOC_UNRESOLVED</a>)
<a name="l05696"></a>05696                   {
<a name="l05697"></a>05697                     <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#ab3de6f2d8c380d3ca8bef520b1b4dfb9">SYMBOL_IS_ARGUMENT</a> (sym))
<a name="l05698"></a>05698                       arg_sym = sym;
<a name="l05699"></a>05699                     <span class="keywordflow">else</span>
<a name="l05700"></a>05700                       {
<a name="l05701"></a>05701                         found_sym = 1;
<a name="l05702"></a>05702                         add_defn_to_vec (obstackp,
<a name="l05703"></a>05703                                          <a class="code" href="symtab_8c.html#a569809b8edfbd2e0a6d9bb40295840f0">fixup_symbol_section</a> (sym, objfile),
<a name="l05704"></a>05704                                          block);
<a name="l05705"></a>05705                       }
<a name="l05706"></a>05706                   }
<a name="l05707"></a>05707               }
<a name="l05708"></a>05708           }
<a name="l05709"></a>05709       }
<a name="l05710"></a>05710 
<a name="l05711"></a>05711       <span class="comment">/* NOTE: This really shouldn&#39;t be needed for _ada_ symbols.</span>
<a name="l05712"></a>05712 <span class="comment">         They aren&#39;t parameters, right?  */</span>
<a name="l05713"></a>05713       <span class="keywordflow">if</span> (!found_sym &amp;&amp; arg_sym != NULL)
<a name="l05714"></a>05714         {
<a name="l05715"></a>05715           add_defn_to_vec (obstackp,
<a name="l05716"></a>05716                            <a class="code" href="symtab_8c.html#a569809b8edfbd2e0a6d9bb40295840f0">fixup_symbol_section</a> (arg_sym, objfile),
<a name="l05717"></a>05717                            block);
<a name="l05718"></a>05718         }
<a name="l05719"></a>05719     }
<a name="l05720"></a>05720 }
<a name="l05721"></a>05721 
<a name="l05722"></a>05722 
<a name="l05723"></a>05723                                 <span class="comment">/* Symbol Completion */</span>
<a name="l05724"></a>05724 
<a name="l05725"></a>05725 <span class="comment">/* If SYM_NAME is a completion candidate for TEXT, return this symbol</span>
<a name="l05726"></a>05726 <span class="comment">   name in a form that&#39;s appropriate for the completion.  The result</span>
<a name="l05727"></a>05727 <span class="comment">   does not need to be deallocated, but is only good until the next call.</span>
<a name="l05728"></a>05728 <span class="comment"></span>
<a name="l05729"></a>05729 <span class="comment">   TEXT_LEN is equal to the length of TEXT.</span>
<a name="l05730"></a>05730 <span class="comment">   Perform a wild match if WILD_MATCH_P is set.</span>
<a name="l05731"></a>05731 <span class="comment">   ENCODED_P should be set if TEXT represents the start of a symbol name</span>
<a name="l05732"></a>05732 <span class="comment">   in its encoded form.  */</span>
<a name="l05733"></a>05733 
<a name="l05734"></a>05734 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l05735"></a>05735 symbol_completion_match (<span class="keyword">const</span> <span class="keywordtype">char</span> *sym_name,
<a name="l05736"></a>05736                          <span class="keyword">const</span> <span class="keywordtype">char</span> *text, <span class="keywordtype">int</span> text_len,
<a name="l05737"></a>05737                          <span class="keywordtype">int</span> wild_match_p, <span class="keywordtype">int</span> encoded_p)
<a name="l05738"></a>05738 {
<a name="l05739"></a>05739   <span class="keyword">const</span> <span class="keywordtype">int</span> verbatim_match = (text[0] == <span class="charliteral">&#39;&lt;&#39;</span>);
<a name="l05740"></a>05740   <span class="keywordtype">int</span> match = 0;
<a name="l05741"></a>05741 
<a name="l05742"></a>05742   <span class="keywordflow">if</span> (verbatim_match)
<a name="l05743"></a>05743     {
<a name="l05744"></a>05744       <span class="comment">/* Strip the leading angle bracket.  */</span>
<a name="l05745"></a>05745       text = text + 1;
<a name="l05746"></a>05746       text_len--;
<a name="l05747"></a>05747     }
<a name="l05748"></a>05748 
<a name="l05749"></a>05749   <span class="comment">/* First, test against the fully qualified name of the symbol.  */</span>
<a name="l05750"></a>05750 
<a name="l05751"></a>05751   <span class="keywordflow">if</span> (strncmp (sym_name, text, text_len) == 0)
<a name="l05752"></a>05752     match = 1;
<a name="l05753"></a>05753 
<a name="l05754"></a>05754   <span class="keywordflow">if</span> (match &amp;&amp; !encoded_p)
<a name="l05755"></a>05755     {
<a name="l05756"></a>05756       <span class="comment">/* One needed check before declaring a positive match is to verify</span>
<a name="l05757"></a>05757 <span class="comment">         that iff we are doing a verbatim match, the decoded version</span>
<a name="l05758"></a>05758 <span class="comment">         of the symbol name starts with &#39;&lt;&#39;.  Otherwise, this symbol name</span>
<a name="l05759"></a>05759 <span class="comment">         is not a suitable completion.  */</span>
<a name="l05760"></a>05760       <span class="keyword">const</span> <span class="keywordtype">char</span> *sym_name_copy = sym_name;
<a name="l05761"></a>05761       <span class="keywordtype">int</span> has_angle_bracket;
<a name="l05762"></a>05762 
<a name="l05763"></a>05763       sym_name = <a class="code" href="ada-lang_8c.html#a09b16b65c7ccf6ce05e91a51321903a1">ada_decode</a> (sym_name);
<a name="l05764"></a>05764       has_angle_bracket = (sym_name[0] == <span class="charliteral">&#39;&lt;&#39;</span>);
<a name="l05765"></a>05765       match = (has_angle_bracket == verbatim_match);
<a name="l05766"></a>05766       sym_name = sym_name_copy;
<a name="l05767"></a>05767     }
<a name="l05768"></a>05768 
<a name="l05769"></a>05769   <span class="keywordflow">if</span> (match &amp;&amp; !verbatim_match)
<a name="l05770"></a>05770     {
<a name="l05771"></a>05771       <span class="comment">/* When doing non-verbatim match, another check that needs to</span>
<a name="l05772"></a>05772 <span class="comment">         be done is to verify that the potentially matching symbol name</span>
<a name="l05773"></a>05773 <span class="comment">         does not include capital letters, because the ada-mode would</span>
<a name="l05774"></a>05774 <span class="comment">         not be able to understand these symbol names without the</span>
<a name="l05775"></a>05775 <span class="comment">         angle bracket notation.  */</span>
<a name="l05776"></a>05776       <span class="keyword">const</span> <span class="keywordtype">char</span> *tmp;
<a name="l05777"></a>05777 
<a name="l05778"></a>05778       <span class="keywordflow">for</span> (tmp = sym_name; *tmp != <span class="charliteral">&#39;\0&#39;</span> &amp;&amp; !isupper (*tmp); tmp++);
<a name="l05779"></a>05779       <span class="keywordflow">if</span> (*tmp != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l05780"></a>05780         match = 0;
<a name="l05781"></a>05781     }
<a name="l05782"></a>05782 
<a name="l05783"></a>05783   <span class="comment">/* Second: Try wild matching...  */</span>
<a name="l05784"></a>05784 
<a name="l05785"></a>05785   <span class="keywordflow">if</span> (!match &amp;&amp; wild_match_p)
<a name="l05786"></a>05786     {
<a name="l05787"></a>05787       <span class="comment">/* Since we are doing wild matching, this means that TEXT</span>
<a name="l05788"></a>05788 <span class="comment">         may represent an unqualified symbol name.  We therefore must</span>
<a name="l05789"></a>05789 <span class="comment">         also compare TEXT against the unqualified name of the symbol.  */</span>
<a name="l05790"></a>05790       sym_name = ada_unqualified_name (<a class="code" href="ada-lang_8c.html#a09b16b65c7ccf6ce05e91a51321903a1">ada_decode</a> (sym_name));
<a name="l05791"></a>05791 
<a name="l05792"></a>05792       <span class="keywordflow">if</span> (strncmp (sym_name, text, text_len) == 0)
<a name="l05793"></a>05793         match = 1;
<a name="l05794"></a>05794     }
<a name="l05795"></a>05795 
<a name="l05796"></a>05796   <span class="comment">/* Finally: If we found a mach, prepare the result to return.  */</span>
<a name="l05797"></a>05797 
<a name="l05798"></a>05798   <span class="keywordflow">if</span> (!match)
<a name="l05799"></a>05799     <span class="keywordflow">return</span> NULL;
<a name="l05800"></a>05800 
<a name="l05801"></a>05801   <span class="keywordflow">if</span> (verbatim_match)
<a name="l05802"></a>05802     sym_name = add_angle_brackets (sym_name);
<a name="l05803"></a>05803 
<a name="l05804"></a>05804   <span class="keywordflow">if</span> (!encoded_p)
<a name="l05805"></a>05805     sym_name = <a class="code" href="ada-lang_8c.html#a09b16b65c7ccf6ce05e91a51321903a1">ada_decode</a> (sym_name);
<a name="l05806"></a>05806 
<a name="l05807"></a>05807   <span class="keywordflow">return</span> sym_name;
<a name="l05808"></a>05808 }
<a name="l05809"></a>05809 
<a name="l05810"></a>05810 <span class="comment">/* A companion function to ada_make_symbol_completion_list().</span>
<a name="l05811"></a>05811 <span class="comment">   Check if SYM_NAME represents a symbol which name would be suitable</span>
<a name="l05812"></a>05812 <span class="comment">   to complete TEXT (TEXT_LEN is the length of TEXT), in which case</span>
<a name="l05813"></a>05813 <span class="comment">   it is appended at the end of the given string vector SV.</span>
<a name="l05814"></a>05814 <span class="comment"></span>
<a name="l05815"></a>05815 <span class="comment">   ORIG_TEXT is the string original string from the user command</span>
<a name="l05816"></a>05816 <span class="comment">   that needs to be completed.  WORD is the entire command on which</span>
<a name="l05817"></a>05817 <span class="comment">   completion should be performed.  These two parameters are used to</span>
<a name="l05818"></a>05818 <span class="comment">   determine which part of the symbol name should be added to the</span>
<a name="l05819"></a>05819 <span class="comment">   completion vector.</span>
<a name="l05820"></a>05820 <span class="comment">   if WILD_MATCH_P is set, then wild matching is performed.</span>
<a name="l05821"></a>05821 <span class="comment">   ENCODED_P should be set if TEXT represents a symbol name in its</span>
<a name="l05822"></a>05822 <span class="comment">   encoded formed (in which case the completion should also be</span>
<a name="l05823"></a>05823 <span class="comment">   encoded).  */</span>
<a name="l05824"></a>05824 
<a name="l05825"></a>05825 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l05826"></a>05826 symbol_completion_add (<a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a>(<a class="code" href="gdb__vecs_8h.html#a5ea7d3fefa2144d9bddaf2053c9691a1">char_ptr</a>) **sv,
<a name="l05827"></a>05827                        <span class="keyword">const</span> <span class="keywordtype">char</span> *sym_name,
<a name="l05828"></a>05828                        <span class="keyword">const</span> <span class="keywordtype">char</span> *text, <span class="keywordtype">int</span> text_len,
<a name="l05829"></a>05829                        <span class="keyword">const</span> <span class="keywordtype">char</span> *orig_text, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="symtab_8h.html#adc1f34651f7bbfa3ba5af27db5f53817">word</a>,
<a name="l05830"></a>05830                        <span class="keywordtype">int</span> wild_match_p, <span class="keywordtype">int</span> encoded_p)
<a name="l05831"></a>05831 {
<a name="l05832"></a>05832   <span class="keyword">const</span> <span class="keywordtype">char</span> *match = symbol_completion_match (sym_name, text, text_len,
<a name="l05833"></a>05833                                                wild_match_p, encoded_p);
<a name="l05834"></a>05834   <span class="keywordtype">char</span> *completion;
<a name="l05835"></a>05835 
<a name="l05836"></a>05836   <span class="keywordflow">if</span> (match == NULL)
<a name="l05837"></a>05837     <span class="keywordflow">return</span>;
<a name="l05838"></a>05838 
<a name="l05839"></a>05839   <span class="comment">/* We found a match, so add the appropriate completion to the given</span>
<a name="l05840"></a>05840 <span class="comment">     string vector.  */</span>
<a name="l05841"></a>05841 
<a name="l05842"></a>05842   <span class="keywordflow">if</span> (word == orig_text)
<a name="l05843"></a>05843     {
<a name="l05844"></a>05844       completion = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (strlen (match) + 5);
<a name="l05845"></a>05845       strcpy (completion, match);
<a name="l05846"></a>05846     }
<a name="l05847"></a>05847   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word &gt; orig_text)
<a name="l05848"></a>05848     {
<a name="l05849"></a>05849       <span class="comment">/* Return some portion of sym_name.  */</span>
<a name="l05850"></a>05850       completion = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (strlen (match) + 5);
<a name="l05851"></a>05851       strcpy (completion, match + (word - orig_text));
<a name="l05852"></a>05852     }
<a name="l05853"></a>05853   <span class="keywordflow">else</span>
<a name="l05854"></a>05854     {
<a name="l05855"></a>05855       <span class="comment">/* Return some of ORIG_TEXT plus sym_name.  */</span>
<a name="l05856"></a>05856       completion = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (strlen (match) + (orig_text - word) + 5);
<a name="l05857"></a>05857       strncpy (completion, word, orig_text - word);
<a name="l05858"></a>05858       completion[orig_text - <a class="code" href="symtab_8h.html#adc1f34651f7bbfa3ba5af27db5f53817">word</a>] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l05859"></a>05859       strcat (completion, match);
<a name="l05860"></a>05860     }
<a name="l05861"></a>05861 
<a name="l05862"></a>05862   <a class="code" href="vec_8h.html#a8d090c0524726d00931070e0c438ba3f">VEC_safe_push</a> (<a class="code" href="gdb__vecs_8h.html#a5ea7d3fefa2144d9bddaf2053c9691a1">char_ptr</a>, *sv, completion);
<a name="l05863"></a>05863 }
<a name="l05864"></a>05864 
<a name="l05865"></a>05865 <span class="comment">/* An object of this type is passed as the user_data argument to the</span>
<a name="l05866"></a>05866 <span class="comment">   expand_partial_symbol_names method.  */</span>
<a name="l05867"></a>05867 <span class="keyword">struct </span>add_partial_datum
<a name="l05868"></a>05868 {
<a name="l05869"></a>05869   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a>(<a class="code" href="gdb__vecs_8h.html#a5ea7d3fefa2144d9bddaf2053c9691a1">char_ptr</a>) **completions;
<a name="l05870"></a>05870   <span class="keyword">const</span> <span class="keywordtype">char</span> *text;
<a name="l05871"></a>05871   <span class="keywordtype">int</span> text_len;
<a name="l05872"></a>05872   <span class="keyword">const</span> <span class="keywordtype">char</span> *text0;
<a name="l05873"></a>05873   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="symtab_8h.html#adc1f34651f7bbfa3ba5af27db5f53817">word</a>;
<a name="l05874"></a>05874   <span class="keywordtype">int</span> wild_match;
<a name="l05875"></a>05875   <span class="keywordtype">int</span> encoded;
<a name="l05876"></a>05876 };
<a name="l05877"></a>05877 
<a name="l05878"></a>05878 <span class="comment">/* A callback for expand_partial_symbol_names.  */</span>
<a name="l05879"></a>05879 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l05880"></a>05880 ada_expand_partial_symbol_name (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">void</span> *user_data)
<a name="l05881"></a>05881 {
<a name="l05882"></a>05882   <span class="keyword">struct </span>add_partial_datum *data = user_data;
<a name="l05883"></a>05883   
<a name="l05884"></a>05884   <span class="keywordflow">return</span> symbol_completion_match (name, data-&gt;text, data-&gt;text_len,
<a name="l05885"></a>05885                                   data-&gt;wild_match, data-&gt;encoded) != NULL;
<a name="l05886"></a>05886 }
<a name="l05887"></a>05887 
<a name="l05888"></a>05888 <span class="comment">/* Return a list of possible symbol names completing TEXT0.  WORD is</span>
<a name="l05889"></a>05889 <span class="comment">   the entire command on which completion is made.  */</span>
<a name="l05890"></a>05890 
<a name="l05891"></a>05891 <span class="keyword">static</span> <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a> (<a class="code" href="gdb__vecs_8h.html#a5ea7d3fefa2144d9bddaf2053c9691a1">char_ptr</a>) *
<a name="l05892"></a>05892 ada_make_symbol_completion_list (<span class="keyword">const</span> <span class="keywordtype">char</span> *text0, <span class="keyword">const</span> <span class="keywordtype">char</span> *word,
<a name="l05893"></a>05893                                  <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> <a class="code" href="ser-unix_8c.html#a45a5b7c00a796a23f01673cef1dbe0a9">code</a>)
<a name="l05894"></a>05894 {
<a name="l05895"></a>05895   <span class="keywordtype">char</span> *text;
<a name="l05896"></a>05896   <span class="keywordtype">int</span> text_len;
<a name="l05897"></a>05897   <span class="keywordtype">int</span> wild_match_p;
<a name="l05898"></a>05898   <span class="keywordtype">int</span> encoded_p;
<a name="l05899"></a>05899   <a class="code" href="vec_8h.html#ab084f6f29fcf16a6b15d15feb653d414">VEC</a>(<a class="code" href="gdb__vecs_8h.html#a5ea7d3fefa2144d9bddaf2053c9691a1">char_ptr</a>) *completions = <a class="code" href="vec_8h.html#a34c31c8820324e1c289454232e30dced">VEC_alloc</a> (<a class="code" href="gdb__vecs_8h.html#a5ea7d3fefa2144d9bddaf2053c9691a1">char_ptr</a>, 128);
<a name="l05900"></a>05900   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l05901"></a>05901   <span class="keyword">struct </span><a class="code" href="structsymtab.html">symtab</a> *s;
<a name="l05902"></a>05902   <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *msymbol;
<a name="l05903"></a>05903   <span class="keyword">struct </span>objfile *objfile;
<a name="l05904"></a>05904   <span class="keyword">struct </span>block *b, *surrounding_static_block = 0;
<a name="l05905"></a>05905   <span class="keywordtype">int</span> i;
<a name="l05906"></a>05906   <span class="keyword">struct </span><a class="code" href="structblock__iterator.html">block_iterator</a> iter;
<a name="l05907"></a>05907   <span class="keyword">struct </span>cleanup *old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, NULL);
<a name="l05908"></a>05908 
<a name="l05909"></a>05909   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ac0ed09886a958d1a94646893440004a8">TYPE_CODE_UNDEF</a>);
<a name="l05910"></a>05910 
<a name="l05911"></a>05911   <span class="keywordflow">if</span> (text0[0] == <span class="charliteral">&#39;&lt;&#39;</span>)
<a name="l05912"></a>05912     {
<a name="l05913"></a>05913       text = xstrdup (text0);
<a name="l05914"></a>05914       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, text);
<a name="l05915"></a>05915       text_len = strlen (text);
<a name="l05916"></a>05916       wild_match_p = 0;
<a name="l05917"></a>05917       encoded_p = 1;
<a name="l05918"></a>05918     }
<a name="l05919"></a>05919   <span class="keywordflow">else</span>
<a name="l05920"></a>05920     {
<a name="l05921"></a>05921       text = xstrdup (<a class="code" href="ada-lang_8c.html#ae2acc3345983845169c3d4239e922b75">ada_encode</a> (text0));
<a name="l05922"></a>05922       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, text);
<a name="l05923"></a>05923       text_len = strlen (text);
<a name="l05924"></a>05924       <span class="keywordflow">for</span> (i = 0; i &lt; text_len; i++)
<a name="l05925"></a>05925         text[i] = tolower (text[i]);
<a name="l05926"></a>05926 
<a name="l05927"></a>05927       encoded_p = (<a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (text0, <span class="stringliteral">&quot;__&quot;</span>) != NULL);
<a name="l05928"></a>05928       <span class="comment">/* If the name contains a &quot;.&quot;, then the user is entering a fully</span>
<a name="l05929"></a>05929 <span class="comment">         qualified entity name, and the match must not be done in wild</span>
<a name="l05930"></a>05930 <span class="comment">         mode.  Similarly, if the user wants to complete what looks like</span>
<a name="l05931"></a>05931 <span class="comment">         an encoded name, the match must not be done in wild mode.  */</span>
<a name="l05932"></a>05932       wild_match_p = (<a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (text0, <span class="charliteral">&#39;.&#39;</span>) == NULL &amp;&amp; !encoded_p);
<a name="l05933"></a>05933     }
<a name="l05934"></a>05934 
<a name="l05935"></a>05935   <span class="comment">/* First, look at the partial symtab symbols.  */</span>
<a name="l05936"></a>05936   {
<a name="l05937"></a>05937     <span class="keyword">struct </span>add_partial_datum data;
<a name="l05938"></a>05938 
<a name="l05939"></a>05939     data.completions = &amp;completions;
<a name="l05940"></a>05940     data.text = text;
<a name="l05941"></a>05941     data.text_len = text_len;
<a name="l05942"></a>05942     data.text0 = text0;
<a name="l05943"></a>05943     data.word = <a class="code" href="symtab_8h.html#adc1f34651f7bbfa3ba5af27db5f53817">word</a>;
<a name="l05944"></a>05944     data.wild_match = wild_match_p;
<a name="l05945"></a>05945     data.encoded = encoded_p;
<a name="l05946"></a>05946     <a class="code" href="psymtab_8c.html#a9c4eed855ee2892c78e1dc3a5ea9a5d5">expand_partial_symbol_names</a> (ada_expand_partial_symbol_name, &amp;data);
<a name="l05947"></a>05947   }
<a name="l05948"></a>05948 
<a name="l05949"></a>05949   <span class="comment">/* At this point scan through the misc symbol vectors and add each</span>
<a name="l05950"></a>05950 <span class="comment">     symbol you find to the list.  Eventually we want to ignore</span>
<a name="l05951"></a>05951 <span class="comment">     anything that isn&#39;t a text symbol (everything else will be</span>
<a name="l05952"></a>05952 <span class="comment">     handled by the psymtab code above).  */</span>
<a name="l05953"></a>05953 
<a name="l05954"></a>05954   <a class="code" href="objfiles_8h.html#a3d08aae2073557e019d75ab37f8182d8">ALL_MSYMBOLS</a> (objfile, msymbol)
<a name="l05955"></a>05955   {
<a name="l05956"></a>05956     <a class="code" href="defs_8h.html#ad24e2b54375e12474e65ebf7175988fb">QUIT</a>;
<a name="l05957"></a>05957     symbol_completion_add (&amp;completions, <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (msymbol),
<a name="l05958"></a>05958                            text, text_len, text0, word, wild_match_p,
<a name="l05959"></a>05959                            encoded_p);
<a name="l05960"></a>05960   }
<a name="l05961"></a>05961 
<a name="l05962"></a>05962   <span class="comment">/* Search upwards from currently selected frame (so that we can</span>
<a name="l05963"></a>05963 <span class="comment">     complete on local vars.  */</span>
<a name="l05964"></a>05964 
<a name="l05965"></a>05965   <span class="keywordflow">for</span> (b = <a class="code" href="frame_8h.html#a91efbdcf182d840c28d378def97cfc23">get_selected_block</a> (0); b != NULL; b = <a class="code" href="block_8h.html#a8b7633ab6d6feadf9b2ee58e10ad8397">BLOCK_SUPERBLOCK</a> (b))
<a name="l05966"></a>05966     {
<a name="l05967"></a>05967       <span class="keywordflow">if</span> (!<a class="code" href="block_8h.html#a8b7633ab6d6feadf9b2ee58e10ad8397">BLOCK_SUPERBLOCK</a> (b))
<a name="l05968"></a>05968         surrounding_static_block = b;   <span class="comment">/* For elmin of dups */</span>
<a name="l05969"></a>05969 
<a name="l05970"></a>05970       <a class="code" href="block_8h.html#a0ffb1db4f5e3a6fd58700861fce48c2b">ALL_BLOCK_SYMBOLS</a> (b, iter, sym)
<a name="l05971"></a>05971       {
<a name="l05972"></a>05972         symbol_completion_add (&amp;completions, <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym),
<a name="l05973"></a>05973                                text, text_len, text0, word,
<a name="l05974"></a>05974                                wild_match_p, encoded_p);
<a name="l05975"></a>05975       }
<a name="l05976"></a>05976     }
<a name="l05977"></a>05977 
<a name="l05978"></a>05978   <span class="comment">/* Go through the symtabs and check the externs and statics for</span>
<a name="l05979"></a>05979 <span class="comment">     symbols which match.  */</span>
<a name="l05980"></a>05980 
<a name="l05981"></a>05981   <a class="code" href="objfiles_8h.html#ac7a49118a426436bba011cabf8b089b9">ALL_SYMTABS</a> (objfile, s)
<a name="l05982"></a>05982   {
<a name="l05983"></a>05983     <a class="code" href="defs_8h.html#ad24e2b54375e12474e65ebf7175988fb">QUIT</a>;
<a name="l05984"></a>05984     b = <a class="code" href="block_8h.html#a84c4a3aa7b6b4d9a127a1c018dd6a776">BLOCKVECTOR_BLOCK</a> (<a class="code" href="symtab_8h.html#a6cd84410d73680ff8006ac44b1b98a9c">BLOCKVECTOR</a> (s), <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124a973ee91cbe4b0cee4eb7603252a29bec">GLOBAL_BLOCK</a>);
<a name="l05985"></a>05985     <a class="code" href="block_8h.html#a0ffb1db4f5e3a6fd58700861fce48c2b">ALL_BLOCK_SYMBOLS</a> (b, iter, sym)
<a name="l05986"></a>05986     {
<a name="l05987"></a>05987       symbol_completion_add (&amp;completions, <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym),
<a name="l05988"></a>05988                              text, text_len, text0, word,
<a name="l05989"></a>05989                              wild_match_p, encoded_p);
<a name="l05990"></a>05990     }
<a name="l05991"></a>05991   }
<a name="l05992"></a>05992 
<a name="l05993"></a>05993   <a class="code" href="objfiles_8h.html#ac7a49118a426436bba011cabf8b089b9">ALL_SYMTABS</a> (objfile, s)
<a name="l05994"></a>05994   {
<a name="l05995"></a>05995     <a class="code" href="defs_8h.html#ad24e2b54375e12474e65ebf7175988fb">QUIT</a>;
<a name="l05996"></a>05996     b = <a class="code" href="block_8h.html#a84c4a3aa7b6b4d9a127a1c018dd6a776">BLOCKVECTOR_BLOCK</a> (<a class="code" href="symtab_8h.html#a6cd84410d73680ff8006ac44b1b98a9c">BLOCKVECTOR</a> (s), <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124a4842990ca5391ee943c2069b28443a99">STATIC_BLOCK</a>);
<a name="l05997"></a>05997     <span class="comment">/* Don&#39;t do this block twice.  */</span>
<a name="l05998"></a>05998     <span class="keywordflow">if</span> (b == surrounding_static_block)
<a name="l05999"></a>05999       <span class="keywordflow">continue</span>;
<a name="l06000"></a>06000     <a class="code" href="block_8h.html#a0ffb1db4f5e3a6fd58700861fce48c2b">ALL_BLOCK_SYMBOLS</a> (b, iter, sym)
<a name="l06001"></a>06001     {
<a name="l06002"></a>06002       symbol_completion_add (&amp;completions, <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym),
<a name="l06003"></a>06003                              text, text_len, text0, word,
<a name="l06004"></a>06004                              wild_match_p, encoded_p);
<a name="l06005"></a>06005     }
<a name="l06006"></a>06006   }
<a name="l06007"></a>06007 
<a name="l06008"></a>06008   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l06009"></a>06009   <span class="keywordflow">return</span> completions;
<a name="l06010"></a>06010 }
<a name="l06011"></a>06011 
<a name="l06012"></a>06012                                 <span class="comment">/* Field Access */</span>
<a name="l06013"></a>06013 
<a name="l06014"></a>06014 <span class="comment">/* Return non-zero if TYPE is a pointer to the GNAT dispatch table used</span>
<a name="l06015"></a>06015 <span class="comment">   for tagged types.  */</span>
<a name="l06016"></a>06016 
<a name="l06017"></a>06017 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l06018"></a>06018 ada_is_dispatch_table_ptr_type (<span class="keyword">struct</span> type *type)
<a name="l06019"></a>06019 {
<a name="l06020"></a>06020   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l06021"></a>06021 
<a name="l06022"></a>06022   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l06023"></a>06023     <span class="keywordflow">return</span> 0;
<a name="l06024"></a>06024 
<a name="l06025"></a>06025   name = <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type));
<a name="l06026"></a>06026   <span class="keywordflow">if</span> (name == NULL)
<a name="l06027"></a>06027     <span class="keywordflow">return</span> 0;
<a name="l06028"></a>06028 
<a name="l06029"></a>06029   <span class="keywordflow">return</span> (strcmp (name, <span class="stringliteral">&quot;ada__tags__dispatch_table&quot;</span>) == 0);
<a name="l06030"></a>06030 }
<a name="l06031"></a>06031 
<a name="l06032"></a>06032 <span class="comment">/* Return non-zero if TYPE is an interface tag.  */</span>
<a name="l06033"></a>06033 
<a name="l06034"></a>06034 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l06035"></a>06035 ada_is_interface_tag (<span class="keyword">struct</span> type *type)
<a name="l06036"></a>06036 {
<a name="l06037"></a>06037   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type);
<a name="l06038"></a>06038 
<a name="l06039"></a>06039   <span class="keywordflow">if</span> (name == NULL)
<a name="l06040"></a>06040     <span class="keywordflow">return</span> 0;
<a name="l06041"></a>06041 
<a name="l06042"></a>06042   <span class="keywordflow">return</span> (strcmp (name, <span class="stringliteral">&quot;ada__tags__interface_tag&quot;</span>) == 0);
<a name="l06043"></a>06043 }
<a name="l06044"></a>06044 
<a name="l06045"></a>06045 <span class="comment">/* True if field number FIELD_NUM in struct or union type TYPE is supposed</span>
<a name="l06046"></a>06046 <span class="comment">   to be invisible to users.  */</span>
<a name="l06047"></a>06047 
<a name="l06048"></a>06048 <span class="keywordtype">int</span>
<a name="l06049"></a><a class="code" href="ada-lang_8h.html#a7a36bbde3917dbf95ce7012d60e3493f">06049</a> <a class="code" href="ada-lang_8c.html#ad9a44edc68931dbf99d0f64e7ec778d7">ada_is_ignored_field</a> (<span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> field_num)
<a name="l06050"></a>06050 {
<a name="l06051"></a>06051   <span class="keywordflow">if</span> (field_num &lt; 0 || field_num &gt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type))
<a name="l06052"></a>06052     <span class="keywordflow">return</span> 1;
<a name="l06053"></a>06053 
<a name="l06054"></a>06054   <span class="comment">/* Check the name of that field.  */</span>
<a name="l06055"></a>06055   {
<a name="l06056"></a>06056     <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, field_num);
<a name="l06057"></a>06057 
<a name="l06058"></a>06058     <span class="comment">/* Anonymous field names should not be printed.</span>
<a name="l06059"></a>06059 <span class="comment">       brobecker/2007-02-20: I don&#39;t think this can actually happen</span>
<a name="l06060"></a>06060 <span class="comment">       but we don&#39;t want to print the value of annonymous fields anyway.  */</span>
<a name="l06061"></a>06061     <span class="keywordflow">if</span> (name == NULL)
<a name="l06062"></a>06062       <span class="keywordflow">return</span> 1;
<a name="l06063"></a>06063 
<a name="l06064"></a>06064     <span class="comment">/* Normally, fields whose name start with an underscore (&quot;_&quot;)</span>
<a name="l06065"></a>06065 <span class="comment">       are fields that have been internally generated by the compiler,</span>
<a name="l06066"></a>06066 <span class="comment">       and thus should not be printed.  The &quot;_parent&quot; field is special,</span>
<a name="l06067"></a>06067 <span class="comment">       however: This is a field internally generated by the compiler</span>
<a name="l06068"></a>06068 <span class="comment">       for tagged types, and it contains the components inherited from</span>
<a name="l06069"></a>06069 <span class="comment">       the parent type.  This field should not be printed as is, but</span>
<a name="l06070"></a>06070 <span class="comment">       should not be ignored either.  */</span>
<a name="l06071"></a>06071     <span class="keywordflow">if</span> (name[0] == <span class="charliteral">&#39;_&#39;</span> &amp;&amp; strncmp (name, <span class="stringliteral">&quot;_parent&quot;</span>, 7) != 0)
<a name="l06072"></a>06072       <span class="keywordflow">return</span> 1;
<a name="l06073"></a>06073   }
<a name="l06074"></a>06074 
<a name="l06075"></a>06075   <span class="comment">/* If this is the dispatch table of a tagged type or an interface tag,</span>
<a name="l06076"></a>06076 <span class="comment">     then ignore.  */</span>
<a name="l06077"></a>06077   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#abbecc644387ffb0a43e57ed0462c2c8b">ada_is_tagged_type</a> (type, 1)
<a name="l06078"></a>06078       &amp;&amp; (ada_is_dispatch_table_ptr_type (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, field_num))
<a name="l06079"></a>06079           || ada_is_interface_tag (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, field_num))))
<a name="l06080"></a>06080     <span class="keywordflow">return</span> 1;
<a name="l06081"></a>06081 
<a name="l06082"></a>06082   <span class="comment">/* Not a special field, so it should not be ignored.  */</span>
<a name="l06083"></a>06083   <span class="keywordflow">return</span> 0;
<a name="l06084"></a>06084 }
<a name="l06085"></a>06085 
<a name="l06086"></a>06086 <span class="comment">/* True iff TYPE has a tag field.  If REFOK, then TYPE may also be a</span>
<a name="l06087"></a>06087 <span class="comment">   pointer or reference type whose ultimate target has a tag field.  */</span>
<a name="l06088"></a>06088 
<a name="l06089"></a>06089 <span class="keywordtype">int</span>
<a name="l06090"></a><a class="code" href="ada-lang_8h.html#a8ed944e7afaf0c4c9dc37f64f6e7db80">06090</a> <a class="code" href="ada-lang_8c.html#abbecc644387ffb0a43e57ed0462c2c8b">ada_is_tagged_type</a> (<span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> refok)
<a name="l06091"></a>06091 {
<a name="l06092"></a>06092   <span class="keywordflow">return</span> (ada_lookup_struct_elt_type (type, <span class="stringliteral">&quot;_tag&quot;</span>, refok, 1, NULL) != NULL);
<a name="l06093"></a>06093 }
<a name="l06094"></a>06094 
<a name="l06095"></a>06095 <span class="comment">/* True iff TYPE represents the type of X&#39;Tag */</span>
<a name="l06096"></a>06096 
<a name="l06097"></a>06097 <span class="keywordtype">int</span>
<a name="l06098"></a><a class="code" href="ada-lang_8h.html#a36920734b43a5bc31afcb6366f559384">06098</a> <a class="code" href="ada-lang_8c.html#ac77dced4f89455cc1908da3513add283">ada_is_tag_type</a> (<span class="keyword">struct</span> type *type)
<a name="l06099"></a>06099 {
<a name="l06100"></a>06100   <span class="keywordflow">if</span> (type == NULL || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l06101"></a>06101     <span class="keywordflow">return</span> 0;
<a name="l06102"></a>06102   <span class="keywordflow">else</span>
<a name="l06103"></a>06103     {
<a name="l06104"></a>06104       <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type));
<a name="l06105"></a>06105 
<a name="l06106"></a>06106       <span class="keywordflow">return</span> (name != NULL
<a name="l06107"></a>06107               &amp;&amp; strcmp (name, <span class="stringliteral">&quot;ada__tags__dispatch_table&quot;</span>) == 0);
<a name="l06108"></a>06108     }
<a name="l06109"></a>06109 }
<a name="l06110"></a>06110 
<a name="l06111"></a>06111 <span class="comment">/* The type of the tag on VAL.  */</span>
<a name="l06112"></a>06112 
<a name="l06113"></a>06113 <span class="keyword">struct </span>type *
<a name="l06114"></a><a class="code" href="ada-lang_8h.html#aa736247a3c70b35b1708577e06831500">06114</a> <a class="code" href="ada-lang_8c.html#a69d9e6970a9bb88a6c44dc0e6edbe9b7">ada_tag_type</a> (<span class="keyword">struct</span> value *val)
<a name="l06115"></a>06115 {
<a name="l06116"></a>06116   <span class="keywordflow">return</span> ada_lookup_struct_elt_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val), <span class="stringliteral">&quot;_tag&quot;</span>, 1, 0, NULL);
<a name="l06117"></a>06117 }
<a name="l06118"></a>06118 
<a name="l06119"></a>06119 <span class="comment">/* Return 1 if TAG follows the old scheme for Ada tags (used for Ada 95,</span>
<a name="l06120"></a>06120 <span class="comment">   retired at Ada 05).  */</span>
<a name="l06121"></a>06121 
<a name="l06122"></a>06122 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l06123"></a>06123 is_ada95_tag (<span class="keyword">struct</span> value *tag)
<a name="l06124"></a>06124 {
<a name="l06125"></a>06125   <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a9d3934026567a1840970ca108755b6e9">ada_value_struct_elt</a> (tag, <span class="stringliteral">&quot;tsd&quot;</span>, 1) != NULL;
<a name="l06126"></a>06126 }
<a name="l06127"></a>06127 
<a name="l06128"></a>06128 <span class="comment">/* The value of the tag on VAL.  */</span>
<a name="l06129"></a>06129 
<a name="l06130"></a>06130 <span class="keyword">struct </span>value *
<a name="l06131"></a><a class="code" href="ada-lang_8h.html#aae132135fc815169a5322bf1dc50ce4c">06131</a> <a class="code" href="ada-lang_8c.html#a13e4a462cc436fc761a68f1e378316db">ada_value_tag</a> (<span class="keyword">struct</span> value *val)
<a name="l06132"></a>06132 {
<a name="l06133"></a>06133   <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a9d3934026567a1840970ca108755b6e9">ada_value_struct_elt</a> (val, <span class="stringliteral">&quot;_tag&quot;</span>, 0);
<a name="l06134"></a>06134 }
<a name="l06135"></a>06135 
<a name="l06136"></a>06136 <span class="comment">/* The value of the tag on the object of type TYPE whose contents are</span>
<a name="l06137"></a>06137 <span class="comment">   saved at VALADDR, if it is non-null, or is at memory address</span>
<a name="l06138"></a>06138 <span class="comment">   ADDRESS.  */</span>
<a name="l06139"></a>06139 
<a name="l06140"></a>06140 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l06141"></a>06141 value_tag_from_contents_and_address (<span class="keyword">struct</span> type *type,
<a name="l06142"></a>06142                                      <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valaddr,
<a name="l06143"></a>06143                                      <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address)
<a name="l06144"></a>06144 {
<a name="l06145"></a>06145   <span class="keywordtype">int</span> tag_byte_offset;
<a name="l06146"></a>06146   <span class="keyword">struct </span>type *tag_type;
<a name="l06147"></a>06147 
<a name="l06148"></a>06148   <span class="keywordflow">if</span> (find_struct_field (<span class="stringliteral">&quot;_tag&quot;</span>, type, 0, &amp;tag_type, &amp;tag_byte_offset,
<a name="l06149"></a>06149                          NULL, NULL, NULL))
<a name="l06150"></a>06150     {
<a name="l06151"></a>06151       <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valaddr1 = ((valaddr == NULL)
<a name="l06152"></a>06152                                   ? NULL
<a name="l06153"></a>06153                                   : valaddr + tag_byte_offset);
<a name="l06154"></a>06154       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address1 = (address == 0) ? 0 : address + tag_byte_offset;
<a name="l06155"></a>06155 
<a name="l06156"></a>06156       <span class="keywordflow">return</span> <a class="code" href="value_8c.html#ab189fd2d8ea1fe71f000581289a20e17">value_from_contents_and_address</a> (tag_type, valaddr1, address1);
<a name="l06157"></a>06157     }
<a name="l06158"></a>06158   <span class="keywordflow">return</span> NULL;
<a name="l06159"></a>06159 }
<a name="l06160"></a>06160 
<a name="l06161"></a>06161 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l06162"></a>06162 type_from_tag (<span class="keyword">struct</span> value *tag)
<a name="l06163"></a>06163 {
<a name="l06164"></a>06164   <span class="keyword">const</span> <span class="keywordtype">char</span> *type_name = <a class="code" href="ada-lang_8c.html#ab835dc5c226256c53c8e6616d7d8978f">ada_tag_name</a> (tag);
<a name="l06165"></a>06165 
<a name="l06166"></a>06166   <span class="keywordflow">if</span> (type_name != NULL)
<a name="l06167"></a>06167     <span class="keywordflow">return</span> ada_find_any_type (<a class="code" href="ada-lang_8c.html#ae2acc3345983845169c3d4239e922b75">ada_encode</a> (type_name));
<a name="l06168"></a>06168   <span class="keywordflow">return</span> NULL;
<a name="l06169"></a>06169 }
<a name="l06170"></a>06170 
<a name="l06171"></a>06171 <span class="comment">/* Given a value OBJ of a tagged type, return a value of this</span>
<a name="l06172"></a>06172 <span class="comment">   type at the base address of the object.  The base address, as</span>
<a name="l06173"></a>06173 <span class="comment">   defined in Ada.Tags, it is the address of the primary tag of</span>
<a name="l06174"></a>06174 <span class="comment">   the object, and therefore where the field values of its full</span>
<a name="l06175"></a>06175 <span class="comment">   view can be fetched.  */</span>
<a name="l06176"></a>06176 
<a name="l06177"></a>06177 <span class="keyword">struct </span>value *
<a name="l06178"></a><a class="code" href="ada-lang_8h.html#a8194e4f9a4e73790e353cc869af2e34a">06178</a> <a class="code" href="ada-lang_8c.html#a8194e4f9a4e73790e353cc869af2e34a">ada_tag_value_at_base_address</a> (<span class="keyword">struct</span> value *obj)
<a name="l06179"></a>06179 {
<a name="l06180"></a>06180   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> e;
<a name="l06181"></a>06181   <span class="keyword">struct </span>value *val;
<a name="l06182"></a>06182   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> offset_to_top = 0;
<a name="l06183"></a>06183   <span class="keyword">struct </span>type *ptr_type, *obj_type;
<a name="l06184"></a>06184   <span class="keyword">struct </span>value *tag;
<a name="l06185"></a>06185   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> base_address;
<a name="l06186"></a>06186 
<a name="l06187"></a>06187   obj_type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (obj);
<a name="l06188"></a>06188 
<a name="l06189"></a>06189   <span class="comment">/* It is the responsability of the caller to deref pointers.  */</span>
<a name="l06190"></a>06190 
<a name="l06191"></a>06191   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (obj_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l06192"></a>06192       || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (obj_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l06193"></a>06193     <span class="keywordflow">return</span> obj;
<a name="l06194"></a>06194 
<a name="l06195"></a>06195   tag = <a class="code" href="ada-lang_8c.html#a13e4a462cc436fc761a68f1e378316db">ada_value_tag</a> (obj);
<a name="l06196"></a>06196   <span class="keywordflow">if</span> (!tag)
<a name="l06197"></a>06197     <span class="keywordflow">return</span> obj;
<a name="l06198"></a>06198 
<a name="l06199"></a>06199   <span class="comment">/* Base addresses only appeared with Ada 05 and multiple inheritance.  */</span>
<a name="l06200"></a>06200 
<a name="l06201"></a>06201   <span class="keywordflow">if</span> (is_ada95_tag (tag))
<a name="l06202"></a>06202     <span class="keywordflow">return</span> obj;
<a name="l06203"></a>06203 
<a name="l06204"></a>06204   ptr_type = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ())-&gt;<a class="code" href="structbuiltin__type.html#a55f6f9ff7436431777683d8ba62f662a">builtin_data_ptr</a>;
<a name="l06205"></a>06205   ptr_type = <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (ptr_type);
<a name="l06206"></a>06206   val = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (ptr_type, tag);
<a name="l06207"></a>06207   <span class="keywordflow">if</span> (!val)
<a name="l06208"></a>06208     <span class="keywordflow">return</span> obj;
<a name="l06209"></a>06209 
<a name="l06210"></a>06210   <span class="comment">/* It is perfectly possible that an exception be raised while</span>
<a name="l06211"></a>06211 <span class="comment">     trying to determine the base address, just like for the tag;</span>
<a name="l06212"></a>06212 <span class="comment">     see ada_tag_name for more details.  We do not print the error</span>
<a name="l06213"></a>06213 <span class="comment">     message for the same reason.  */</span>
<a name="l06214"></a>06214 
<a name="l06215"></a>06215   <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (e, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l06216"></a>06216     {
<a name="l06217"></a>06217       offset_to_top = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (<a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (<a class="code" href="valarith_8c.html#adbc56b15746661876f9a226b8606c4d2">value_ptradd</a> (val, -2)));
<a name="l06218"></a>06218     }
<a name="l06219"></a>06219 
<a name="l06220"></a>06220   <span class="keywordflow">if</span> (e.<a class="code" href="structgdb__exception.html#ae0e14189c63f830024865d557c1122cc">reason</a> &lt; 0)
<a name="l06221"></a>06221     <span class="keywordflow">return</span> obj;
<a name="l06222"></a>06222 
<a name="l06223"></a>06223   <span class="comment">/* If offset is null, nothing to do.  */</span>
<a name="l06224"></a>06224 
<a name="l06225"></a>06225   <span class="keywordflow">if</span> (offset_to_top == 0)
<a name="l06226"></a>06226     <span class="keywordflow">return</span> obj;
<a name="l06227"></a>06227 
<a name="l06228"></a>06228   <span class="comment">/* -1 is a special case in Ada.Tags; however, what should be done</span>
<a name="l06229"></a>06229 <span class="comment">     is not quite clear from the documentation.  So do nothing for</span>
<a name="l06230"></a>06230 <span class="comment">     now.  */</span>
<a name="l06231"></a>06231 
<a name="l06232"></a>06232   <span class="keywordflow">if</span> (offset_to_top == -1)
<a name="l06233"></a>06233     <span class="keywordflow">return</span> obj;
<a name="l06234"></a>06234 
<a name="l06235"></a>06235   base_address = <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (obj) - offset_to_top;
<a name="l06236"></a>06236   tag = value_tag_from_contents_and_address (obj_type, NULL, base_address);
<a name="l06237"></a>06237 
<a name="l06238"></a>06238   <span class="comment">/* Make sure that we have a proper tag at the new address.</span>
<a name="l06239"></a>06239 <span class="comment">     Otherwise, offset_to_top is bogus (which can happen when</span>
<a name="l06240"></a>06240 <span class="comment">     the object is not initialized yet).  */</span>
<a name="l06241"></a>06241 
<a name="l06242"></a>06242   <span class="keywordflow">if</span> (!tag)
<a name="l06243"></a>06243     <span class="keywordflow">return</span> obj;
<a name="l06244"></a>06244 
<a name="l06245"></a>06245   obj_type = type_from_tag (tag);
<a name="l06246"></a>06246 
<a name="l06247"></a>06247   <span class="keywordflow">if</span> (!obj_type)
<a name="l06248"></a>06248     <span class="keywordflow">return</span> obj;
<a name="l06249"></a>06249 
<a name="l06250"></a>06250   <span class="keywordflow">return</span> <a class="code" href="value_8c.html#ab189fd2d8ea1fe71f000581289a20e17">value_from_contents_and_address</a> (obj_type, NULL, base_address);
<a name="l06251"></a>06251 }
<a name="l06252"></a>06252 
<a name="l06253"></a>06253 <span class="comment">/* Return the &quot;ada__tags__type_specific_data&quot; type.  */</span>
<a name="l06254"></a>06254 
<a name="l06255"></a>06255 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l06256"></a>06256 ada_get_tsd_type (<span class="keyword">struct</span> <a class="code" href="structinferior.html">inferior</a> *inf)
<a name="l06257"></a>06257 {
<a name="l06258"></a>06258   <span class="keyword">struct </span>ada_inferior_data *data = get_ada_inferior_data (inf);
<a name="l06259"></a>06259 
<a name="l06260"></a>06260   <span class="keywordflow">if</span> (data-&gt;tsd_type == 0)
<a name="l06261"></a>06261     data-&gt;tsd_type = ada_find_any_type (<span class="stringliteral">&quot;ada__tags__type_specific_data&quot;</span>);
<a name="l06262"></a>06262   <span class="keywordflow">return</span> data-&gt;tsd_type;
<a name="l06263"></a>06263 }
<a name="l06264"></a>06264 
<a name="l06265"></a>06265 <span class="comment">/* Return the TSD (type-specific data) associated to the given TAG.</span>
<a name="l06266"></a>06266 <span class="comment">   TAG is assumed to be the tag of a tagged-type entity.</span>
<a name="l06267"></a>06267 <span class="comment"></span>
<a name="l06268"></a>06268 <span class="comment">   May return NULL if we are unable to get the TSD.  */</span>
<a name="l06269"></a>06269 
<a name="l06270"></a>06270 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l06271"></a>06271 ada_get_tsd_from_tag (<span class="keyword">struct</span> value *tag)
<a name="l06272"></a>06272 {
<a name="l06273"></a>06273   <span class="keyword">struct </span>value *val;
<a name="l06274"></a>06274   <span class="keyword">struct </span>type *type;
<a name="l06275"></a>06275 
<a name="l06276"></a>06276   <span class="comment">/* First option: The TSD is simply stored as a field of our TAG.</span>
<a name="l06277"></a>06277 <span class="comment">     Only older versions of GNAT would use this format, but we have</span>
<a name="l06278"></a>06278 <span class="comment">     to test it first, because there are no visible markers for</span>
<a name="l06279"></a>06279 <span class="comment">     the current approach except the absence of that field.  */</span>
<a name="l06280"></a>06280 
<a name="l06281"></a>06281   val = <a class="code" href="ada-lang_8c.html#a9d3934026567a1840970ca108755b6e9">ada_value_struct_elt</a> (tag, <span class="stringliteral">&quot;tsd&quot;</span>, 1);
<a name="l06282"></a>06282   <span class="keywordflow">if</span> (val)
<a name="l06283"></a>06283     <span class="keywordflow">return</span> val;
<a name="l06284"></a>06284 
<a name="l06285"></a>06285   <span class="comment">/* Try the second representation for the dispatch table (in which</span>
<a name="l06286"></a>06286 <span class="comment">     there is no explicit &#39;tsd&#39; field in the referent of the tag pointer,</span>
<a name="l06287"></a>06287 <span class="comment">     and instead the tsd pointer is stored just before the dispatch</span>
<a name="l06288"></a>06288 <span class="comment">     table.  */</span>
<a name="l06289"></a>06289 
<a name="l06290"></a>06290   type = ada_get_tsd_type (<a class="code" href="inferior_8c.html#a9e592c83e7c0c1f89f1a4a392bd1a277">current_inferior</a>());
<a name="l06291"></a>06291   <span class="keywordflow">if</span> (type == NULL)
<a name="l06292"></a>06292     <span class="keywordflow">return</span> NULL;
<a name="l06293"></a>06293   type = <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (<a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (type));
<a name="l06294"></a>06294   val = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (type, tag);
<a name="l06295"></a>06295   <span class="keywordflow">if</span> (val == NULL)
<a name="l06296"></a>06296     <span class="keywordflow">return</span> NULL;
<a name="l06297"></a>06297   <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (<a class="code" href="valarith_8c.html#adbc56b15746661876f9a226b8606c4d2">value_ptradd</a> (val, -1));
<a name="l06298"></a>06298 }
<a name="l06299"></a>06299 
<a name="l06300"></a>06300 <span class="comment">/* Given the TSD of a tag (type-specific data), return a string</span>
<a name="l06301"></a>06301 <span class="comment">   containing the name of the associated type.</span>
<a name="l06302"></a>06302 <span class="comment"></span>
<a name="l06303"></a>06303 <span class="comment">   The returned value is good until the next call.  May return NULL</span>
<a name="l06304"></a>06304 <span class="comment">   if we are unable to determine the tag name.  */</span>
<a name="l06305"></a>06305 
<a name="l06306"></a>06306 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l06307"></a>06307 ada_tag_name_from_tsd (<span class="keyword">struct</span> value *tsd)
<a name="l06308"></a>06308 {
<a name="l06309"></a>06309   <span class="keyword">static</span> <span class="keywordtype">char</span> name[1024];
<a name="l06310"></a>06310   <span class="keywordtype">char</span> *p;
<a name="l06311"></a>06311   <span class="keyword">struct </span>value *val;
<a name="l06312"></a>06312 
<a name="l06313"></a>06313   val = <a class="code" href="ada-lang_8c.html#a9d3934026567a1840970ca108755b6e9">ada_value_struct_elt</a> (tsd, <span class="stringliteral">&quot;expanded_name&quot;</span>, 1);
<a name="l06314"></a>06314   <span class="keywordflow">if</span> (val == NULL)
<a name="l06315"></a>06315     <span class="keywordflow">return</span> NULL;
<a name="l06316"></a>06316   <a class="code" href="corefile_8c.html#ae846ac897f15e5f6446f7bade1907de7">read_memory_string</a> (<a class="code" href="value_8c.html#a2e64d8ca2ab5480e05097c6b2df1aa02">value_as_address</a> (val), name, <span class="keyword">sizeof</span> (name) - 1);
<a name="l06317"></a>06317   <span class="keywordflow">for</span> (p = name; *p != <span class="charliteral">&#39;\0&#39;</span>; p += 1)
<a name="l06318"></a>06318     <span class="keywordflow">if</span> (isalpha (*p))
<a name="l06319"></a>06319       *p = tolower (*p);
<a name="l06320"></a>06320   <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l06321"></a>06321 }
<a name="l06322"></a>06322 
<a name="l06323"></a>06323 <span class="comment">/* The type name of the dynamic type denoted by the &#39;tag value TAG, as</span>
<a name="l06324"></a>06324 <span class="comment">   a C string.</span>
<a name="l06325"></a>06325 <span class="comment"></span>
<a name="l06326"></a>06326 <span class="comment">   Return NULL if the TAG is not an Ada tag, or if we were unable to</span>
<a name="l06327"></a>06327 <span class="comment">   determine the name of that tag.  The result is good until the next</span>
<a name="l06328"></a>06328 <span class="comment">   call.  */</span>
<a name="l06329"></a>06329 
<a name="l06330"></a>06330 <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l06331"></a><a class="code" href="ada-lang_8h.html#a1bda407926bd09ae98bd460667577702">06331</a> <a class="code" href="ada-lang_8c.html#ab835dc5c226256c53c8e6616d7d8978f">ada_tag_name</a> (<span class="keyword">struct</span> value *tag)
<a name="l06332"></a>06332 {
<a name="l06333"></a>06333   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> e;
<a name="l06334"></a>06334   <span class="keywordtype">char</span> *name = NULL;
<a name="l06335"></a>06335 
<a name="l06336"></a>06336   <span class="keywordflow">if</span> (!<a class="code" href="ada-lang_8c.html#ac77dced4f89455cc1908da3513add283">ada_is_tag_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (tag)))
<a name="l06337"></a>06337     <span class="keywordflow">return</span> NULL;
<a name="l06338"></a>06338 
<a name="l06339"></a>06339   <span class="comment">/* It is perfectly possible that an exception be raised while trying</span>
<a name="l06340"></a>06340 <span class="comment">     to determine the TAG&#39;s name, even under normal circumstances:</span>
<a name="l06341"></a>06341 <span class="comment">     The associated variable may be uninitialized or corrupted, for</span>
<a name="l06342"></a>06342 <span class="comment">     instance. We do not let any exception propagate past this point.</span>
<a name="l06343"></a>06343 <span class="comment">     instead we return NULL.</span>
<a name="l06344"></a>06344 <span class="comment"></span>
<a name="l06345"></a>06345 <span class="comment">     We also do not print the error message either (which often is very</span>
<a name="l06346"></a>06346 <span class="comment">     low-level (Eg: &quot;Cannot read memory at 0x[...]&quot;), but instead let</span>
<a name="l06347"></a>06347 <span class="comment">     the caller print a more meaningful message if necessary.  */</span>
<a name="l06348"></a>06348   <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (e, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l06349"></a>06349     {
<a name="l06350"></a>06350       <span class="keyword">struct </span>value *tsd = ada_get_tsd_from_tag (tag);
<a name="l06351"></a>06351 
<a name="l06352"></a>06352       <span class="keywordflow">if</span> (tsd != NULL)
<a name="l06353"></a>06353         name = ada_tag_name_from_tsd (tsd);
<a name="l06354"></a>06354     }
<a name="l06355"></a>06355 
<a name="l06356"></a>06356   <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l06357"></a>06357 }
<a name="l06358"></a>06358 
<a name="l06359"></a>06359 <span class="comment">/* The parent type of TYPE, or NULL if none.  */</span>
<a name="l06360"></a>06360 
<a name="l06361"></a>06361 <span class="keyword">struct </span>type *
<a name="l06362"></a><a class="code" href="ada-lang_8h.html#a2323d3b7d53907248044f74ac4c4595f">06362</a> <a class="code" href="ada-lang_8c.html#ae55eca0a49184aa2817c429fe9d59686">ada_parent_type</a> (<span class="keyword">struct</span> type *type)
<a name="l06363"></a>06363 {
<a name="l06364"></a>06364   <span class="keywordtype">int</span> i;
<a name="l06365"></a>06365 
<a name="l06366"></a>06366   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l06367"></a>06367 
<a name="l06368"></a>06368   <span class="keywordflow">if</span> (type == NULL || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>)
<a name="l06369"></a>06369     <span class="keywordflow">return</span> NULL;
<a name="l06370"></a>06370 
<a name="l06371"></a>06371   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type); i += 1)
<a name="l06372"></a>06372     <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a9e96ed25126c2b24b6361baf76456186">ada_is_parent_field</a> (type, i))
<a name="l06373"></a>06373       {
<a name="l06374"></a>06374         <span class="keyword">struct </span>type *parent_type = <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, i);
<a name="l06375"></a>06375 
<a name="l06376"></a>06376         <span class="comment">/* If the _parent field is a pointer, then dereference it.  */</span>
<a name="l06377"></a>06377         <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (parent_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l06378"></a>06378           parent_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (parent_type);
<a name="l06379"></a>06379         <span class="comment">/* If there is a parallel XVS type, get the actual base type.  */</span>
<a name="l06380"></a>06380         parent_type = <a class="code" href="ada-lang_8c.html#aac42a4c75acced2b75b65874ef51ead8">ada_get_base_type</a> (parent_type);
<a name="l06381"></a>06381 
<a name="l06382"></a>06382         <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (parent_type);
<a name="l06383"></a>06383       }
<a name="l06384"></a>06384 
<a name="l06385"></a>06385   <span class="keywordflow">return</span> NULL;
<a name="l06386"></a>06386 }
<a name="l06387"></a>06387 
<a name="l06388"></a>06388 <span class="comment">/* True iff field number FIELD_NUM of structure type TYPE contains the</span>
<a name="l06389"></a>06389 <span class="comment">   parent-type (inherited) fields of a derived type.  Assumes TYPE is</span>
<a name="l06390"></a>06390 <span class="comment">   a structure type with at least FIELD_NUM+1 fields.  */</span>
<a name="l06391"></a>06391 
<a name="l06392"></a>06392 <span class="keywordtype">int</span>
<a name="l06393"></a><a class="code" href="ada-lang_8h.html#ace41d384b5e51e9903974840ab7b35a3">06393</a> <a class="code" href="ada-lang_8c.html#a9e96ed25126c2b24b6361baf76456186">ada_is_parent_field</a> (<span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> field_num)
<a name="l06394"></a>06394 {
<a name="l06395"></a>06395   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type), field_num);
<a name="l06396"></a>06396 
<a name="l06397"></a>06397   <span class="keywordflow">return</span> (name != NULL
<a name="l06398"></a>06398           &amp;&amp; (strncmp (name, <span class="stringliteral">&quot;PARENT&quot;</span>, 6) == 0
<a name="l06399"></a>06399               || strncmp (name, <span class="stringliteral">&quot;_parent&quot;</span>, 7) == 0));
<a name="l06400"></a>06400 }
<a name="l06401"></a>06401 
<a name="l06402"></a>06402 <span class="comment">/* True iff field number FIELD_NUM of structure type TYPE is a</span>
<a name="l06403"></a>06403 <span class="comment">   transparent wrapper field (which should be silently traversed when doing</span>
<a name="l06404"></a>06404 <span class="comment">   field selection and flattened when printing).  Assumes TYPE is a</span>
<a name="l06405"></a>06405 <span class="comment">   structure type with at least FIELD_NUM+1 fields.  Such fields are always</span>
<a name="l06406"></a>06406 <span class="comment">   structures.  */</span>
<a name="l06407"></a>06407 
<a name="l06408"></a>06408 <span class="keywordtype">int</span>
<a name="l06409"></a><a class="code" href="ada-lang_8h.html#acb06008b2ecfd1436044df7c486d6cfc">06409</a> <a class="code" href="ada-lang_8c.html#ab6ed5a863da98f196c38498f7512d30b">ada_is_wrapper_field</a> (<span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> field_num)
<a name="l06410"></a>06410 {
<a name="l06411"></a>06411   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, field_num);
<a name="l06412"></a>06412 
<a name="l06413"></a>06413   <span class="keywordflow">return</span> (name != NULL
<a name="l06414"></a>06414           &amp;&amp; (strncmp (name, <span class="stringliteral">&quot;PARENT&quot;</span>, 6) == 0
<a name="l06415"></a>06415               || strcmp (name, <span class="stringliteral">&quot;REP&quot;</span>) == 0
<a name="l06416"></a>06416               || strncmp (name, <span class="stringliteral">&quot;_parent&quot;</span>, 7) == 0
<a name="l06417"></a>06417               || name[0] == <span class="charliteral">&#39;S&#39;</span> || name[0] == <span class="charliteral">&#39;R&#39;</span> || name[0] == <span class="charliteral">&#39;O&#39;</span>));
<a name="l06418"></a>06418 }
<a name="l06419"></a>06419 
<a name="l06420"></a>06420 <span class="comment">/* True iff field number FIELD_NUM of structure or union type TYPE</span>
<a name="l06421"></a>06421 <span class="comment">   is a variant wrapper.  Assumes TYPE is a structure type with at least</span>
<a name="l06422"></a>06422 <span class="comment">   FIELD_NUM+1 fields.  */</span>
<a name="l06423"></a>06423 
<a name="l06424"></a>06424 <span class="keywordtype">int</span>
<a name="l06425"></a><a class="code" href="ada-lang_8h.html#abb7350ec5ac964c68ec57c8dae895266">06425</a> <a class="code" href="ada-lang_8c.html#a370ccbe192d73c5795afa034113a4ffb">ada_is_variant_part</a> (<span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> field_num)
<a name="l06426"></a>06426 {
<a name="l06427"></a>06427   <span class="keyword">struct </span>type *field_type = <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, field_num);
<a name="l06428"></a>06428 
<a name="l06429"></a>06429   <span class="keywordflow">return</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (field_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>
<a name="l06430"></a>06430           || (is_dynamic_field (type, field_num)
<a name="l06431"></a>06431               &amp;&amp; (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (field_type)) 
<a name="l06432"></a>06432                   == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)));
<a name="l06433"></a>06433 }
<a name="l06434"></a>06434 
<a name="l06435"></a>06435 <span class="comment">/* Assuming that VAR_TYPE is a variant wrapper (type of the variant part)</span>
<a name="l06436"></a>06436 <span class="comment">   whose discriminants are contained in the record type OUTER_TYPE,</span>
<a name="l06437"></a>06437 <span class="comment">   returns the type of the controlling discriminant for the variant.</span>
<a name="l06438"></a>06438 <span class="comment">   May return NULL if the type could not be found.  */</span>
<a name="l06439"></a>06439 
<a name="l06440"></a>06440 <span class="keyword">struct </span>type *
<a name="l06441"></a><a class="code" href="ada-lang_8h.html#a3f7cd40fe0d332ae1376edf23bf4a64d">06441</a> <a class="code" href="ada-lang_8c.html#a17ab4056d326fce2f610118e39da3fc7">ada_variant_discrim_type</a> (<span class="keyword">struct</span> type *var_type, <span class="keyword">struct</span> type *outer_type)
<a name="l06442"></a>06442 {
<a name="l06443"></a>06443   <span class="keywordtype">char</span> *name = <a class="code" href="ada-lang_8c.html#ada3cdba439483cae20c9779b19014135">ada_variant_discrim_name</a> (var_type);
<a name="l06444"></a>06444 
<a name="l06445"></a>06445   <span class="keywordflow">return</span> ada_lookup_struct_elt_type (outer_type, name, 1, 1, NULL);
<a name="l06446"></a>06446 }
<a name="l06447"></a>06447 
<a name="l06448"></a>06448 <span class="comment">/* Assuming that TYPE is the type of a variant wrapper, and FIELD_NUM is a</span>
<a name="l06449"></a>06449 <span class="comment">   valid field number within it, returns 1 iff field FIELD_NUM of TYPE</span>
<a name="l06450"></a>06450 <span class="comment">   represents a &#39;when others&#39; clause; otherwise 0.  */</span>
<a name="l06451"></a>06451 
<a name="l06452"></a>06452 <span class="keywordtype">int</span>
<a name="l06453"></a><a class="code" href="ada-lang_8h.html#a027bbe2e413b5f9c1c60c0983f7a6b82">06453</a> <a class="code" href="ada-lang_8c.html#a3d640e6dd563c89a68fc207fe49a9808">ada_is_others_clause</a> (<span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> field_num)
<a name="l06454"></a>06454 {
<a name="l06455"></a>06455   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, field_num);
<a name="l06456"></a>06456 
<a name="l06457"></a>06457   <span class="keywordflow">return</span> (name != NULL &amp;&amp; name[0] == <span class="charliteral">&#39;O&#39;</span>);
<a name="l06458"></a>06458 }
<a name="l06459"></a>06459 
<a name="l06460"></a>06460 <span class="comment">/* Assuming that TYPE0 is the type of the variant part of a record,</span>
<a name="l06461"></a>06461 <span class="comment">   returns the name of the discriminant controlling the variant.</span>
<a name="l06462"></a>06462 <span class="comment">   The value is valid until the next call to ada_variant_discrim_name.  */</span>
<a name="l06463"></a>06463 
<a name="l06464"></a>06464 <span class="keywordtype">char</span> *
<a name="l06465"></a><a class="code" href="ada-lang_8h.html#a4ee601ced10a37741d1cfbbc13a3b9c9">06465</a> <a class="code" href="ada-lang_8c.html#ada3cdba439483cae20c9779b19014135">ada_variant_discrim_name</a> (<span class="keyword">struct</span> type *type0)
<a name="l06466"></a>06466 {
<a name="l06467"></a>06467   <span class="keyword">static</span> <span class="keywordtype">char</span> *result = NULL;
<a name="l06468"></a>06468   <span class="keyword">static</span> <span class="keywordtype">size_t</span> result_len = 0;
<a name="l06469"></a>06469   <span class="keyword">struct </span>type *type;
<a name="l06470"></a>06470   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l06471"></a>06471   <span class="keyword">const</span> <span class="keywordtype">char</span> *discrim_end;
<a name="l06472"></a>06472   <span class="keyword">const</span> <span class="keywordtype">char</span> *discrim_start;
<a name="l06473"></a>06473 
<a name="l06474"></a>06474   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type0) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l06475"></a>06475     type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type0);
<a name="l06476"></a>06476   <span class="keywordflow">else</span>
<a name="l06477"></a>06477     type = type0;
<a name="l06478"></a>06478 
<a name="l06479"></a>06479   name = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type);
<a name="l06480"></a>06480 
<a name="l06481"></a>06481   <span class="keywordflow">if</span> (name == NULL || name[0] == <span class="charliteral">&#39;\000&#39;</span>)
<a name="l06482"></a>06482     <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l06483"></a>06483 
<a name="l06484"></a>06484   <span class="keywordflow">for</span> (discrim_end = name + strlen (name) - 6; discrim_end != <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l06485"></a>06485        discrim_end -= 1)
<a name="l06486"></a>06486     {
<a name="l06487"></a>06487       <span class="keywordflow">if</span> (strncmp (discrim_end, <span class="stringliteral">&quot;___XVN&quot;</span>, 6) == 0)
<a name="l06488"></a>06488         <span class="keywordflow">break</span>;
<a name="l06489"></a>06489     }
<a name="l06490"></a>06490   <span class="keywordflow">if</span> (discrim_end == name)
<a name="l06491"></a>06491     <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l06492"></a>06492 
<a name="l06493"></a>06493   <span class="keywordflow">for</span> (discrim_start = discrim_end; discrim_start != name + 3;
<a name="l06494"></a>06494        discrim_start -= 1)
<a name="l06495"></a>06495     {
<a name="l06496"></a>06496       <span class="keywordflow">if</span> (discrim_start == name + 1)
<a name="l06497"></a>06497         <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l06498"></a>06498       <span class="keywordflow">if</span> ((discrim_start &gt; name + 3
<a name="l06499"></a>06499            &amp;&amp; strncmp (discrim_start - 3, <span class="stringliteral">&quot;___&quot;</span>, 3) == 0)
<a name="l06500"></a>06500           || discrim_start[-1] == <span class="charliteral">&#39;.&#39;</span>)
<a name="l06501"></a>06501         <span class="keywordflow">break</span>;
<a name="l06502"></a>06502     }
<a name="l06503"></a>06503 
<a name="l06504"></a>06504   <a class="code" href="ada-lang_8h.html#a48e9e90d45825a693f1690a4ebcb2a1e">GROW_VECT</a> (result, result_len, discrim_end - discrim_start + 1);
<a name="l06505"></a>06505   strncpy (result, discrim_start, discrim_end - discrim_start);
<a name="l06506"></a>06506   result[discrim_end - discrim_start] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l06507"></a>06507   <span class="keywordflow">return</span> result;
<a name="l06508"></a>06508 }
<a name="l06509"></a>06509 
<a name="l06510"></a>06510 <span class="comment">/* Scan STR for a subtype-encoded number, beginning at position K.</span>
<a name="l06511"></a>06511 <span class="comment">   Put the position of the character just past the number scanned in</span>
<a name="l06512"></a>06512 <span class="comment">   *NEW_K, if NEW_K!=NULL.  Put the scanned number in *R, if R!=NULL.</span>
<a name="l06513"></a>06513 <span class="comment">   Return 1 if there was a valid number at the given position, and 0</span>
<a name="l06514"></a>06514 <span class="comment">   otherwise.  A &quot;subtype-encoded&quot; number consists of the absolute value</span>
<a name="l06515"></a>06515 <span class="comment">   in decimal, followed by the letter &#39;m&#39; to indicate a negative number.</span>
<a name="l06516"></a>06516 <span class="comment">   Assumes 0m does not occur.  */</span>
<a name="l06517"></a>06517 
<a name="l06518"></a>06518 <span class="keywordtype">int</span>
<a name="l06519"></a><a class="code" href="ada-lang_8c.html#ace9b2035b5472767719b10e8d2691e11">06519</a> <a class="code" href="ada-lang_8c.html#ace9b2035b5472767719b10e8d2691e11">ada_scan_number</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> str[], <span class="keywordtype">int</span> k, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> * <a class="code" href="m32c-tdep_8c.html#abb571ec71ccf602d891a81a32597aaba">R</a>, <span class="keywordtype">int</span> *new_k)
<a name="l06520"></a>06520 {
<a name="l06521"></a>06521   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> RU;
<a name="l06522"></a>06522 
<a name="l06523"></a>06523   <span class="keywordflow">if</span> (!isdigit (str[k]))
<a name="l06524"></a>06524     <span class="keywordflow">return</span> 0;
<a name="l06525"></a>06525 
<a name="l06526"></a>06526   <span class="comment">/* Do it the hard way so as not to make any assumption about</span>
<a name="l06527"></a>06527 <span class="comment">     the relationship of unsigned long (%lu scan format code) and</span>
<a name="l06528"></a>06528 <span class="comment">     LONGEST.  */</span>
<a name="l06529"></a>06529   RU = 0;
<a name="l06530"></a>06530   <span class="keywordflow">while</span> (isdigit (str[k]))
<a name="l06531"></a>06531     {
<a name="l06532"></a>06532       RU = RU * 10 + (str[k] - <span class="charliteral">&#39;0&#39;</span>);
<a name="l06533"></a>06533       k += 1;
<a name="l06534"></a>06534     }
<a name="l06535"></a>06535 
<a name="l06536"></a>06536   <span class="keywordflow">if</span> (str[k] == <span class="charliteral">&#39;m&#39;</span>)
<a name="l06537"></a>06537     {
<a name="l06538"></a>06538       <span class="keywordflow">if</span> (R != NULL)
<a name="l06539"></a>06539         *R = (-(<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) (RU - 1)) - 1;
<a name="l06540"></a>06540       k += 1;
<a name="l06541"></a>06541     }
<a name="l06542"></a>06542   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (R != NULL)
<a name="l06543"></a>06543     *R = (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) RU;
<a name="l06544"></a>06544 
<a name="l06545"></a>06545   <span class="comment">/* NOTE on the above: Technically, C does not say what the results of</span>
<a name="l06546"></a>06546 <span class="comment">     - (LONGEST) RU or (LONGEST) -RU are for RU == largest positive</span>
<a name="l06547"></a>06547 <span class="comment">     number representable as a LONGEST (although either would probably work</span>
<a name="l06548"></a>06548 <span class="comment">     in most implementations).  When RU&gt;0, the locution in the then branch</span>
<a name="l06549"></a>06549 <span class="comment">     above is always equivalent to the negative of RU.  */</span>
<a name="l06550"></a>06550 
<a name="l06551"></a>06551   <span class="keywordflow">if</span> (new_k != NULL)
<a name="l06552"></a>06552     *new_k = k;
<a name="l06553"></a>06553   <span class="keywordflow">return</span> 1;
<a name="l06554"></a>06554 }
<a name="l06555"></a>06555 
<a name="l06556"></a>06556 <span class="comment">/* Assuming that TYPE is a variant part wrapper type (a VARIANTS field),</span>
<a name="l06557"></a>06557 <span class="comment">   and FIELD_NUM is a valid field number within it, returns 1 iff VAL is</span>
<a name="l06558"></a>06558 <span class="comment">   in the range encoded by field FIELD_NUM of TYPE; otherwise 0.  */</span>
<a name="l06559"></a>06559 
<a name="l06560"></a>06560 <span class="keywordtype">int</span>
<a name="l06561"></a><a class="code" href="ada-lang_8h.html#a9180f47a6e10e97566e3d15a0cf79fec">06561</a> <a class="code" href="ada-lang_8c.html#ae1ce38556e7e112cf40d0e76833de13f">ada_in_variant</a> (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> val, <span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> field_num)
<a name="l06562"></a>06562 {
<a name="l06563"></a>06563   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, field_num);
<a name="l06564"></a>06564   <span class="keywordtype">int</span> p;
<a name="l06565"></a>06565 
<a name="l06566"></a>06566   p = 0;
<a name="l06567"></a>06567   <span class="keywordflow">while</span> (1)
<a name="l06568"></a>06568     {
<a name="l06569"></a>06569       <span class="keywordflow">switch</span> (name[p])
<a name="l06570"></a>06570         {
<a name="l06571"></a>06571         <span class="keywordflow">case</span> <span class="charliteral">&#39;\0&#39;</span>:
<a name="l06572"></a>06572           <span class="keywordflow">return</span> 0;
<a name="l06573"></a>06573         <span class="keywordflow">case</span> <span class="charliteral">&#39;S&#39;</span>:
<a name="l06574"></a>06574           {
<a name="l06575"></a>06575             <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> W;
<a name="l06576"></a>06576 
<a name="l06577"></a>06577             <span class="keywordflow">if</span> (!<a class="code" href="ada-lang_8c.html#ace9b2035b5472767719b10e8d2691e11">ada_scan_number</a> (name, p + 1, &amp;W, &amp;p))
<a name="l06578"></a>06578               <span class="keywordflow">return</span> 0;
<a name="l06579"></a>06579             <span class="keywordflow">if</span> (val == W)
<a name="l06580"></a>06580               <span class="keywordflow">return</span> 1;
<a name="l06581"></a>06581             <span class="keywordflow">break</span>;
<a name="l06582"></a>06582           }
<a name="l06583"></a>06583         <span class="keywordflow">case</span> <span class="charliteral">&#39;R&#39;</span>:
<a name="l06584"></a>06584           {
<a name="l06585"></a>06585             <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="ia64-tdep_8c.html#aa7fb549cf7936f8264053676ad5a5115aef31cc6fe9479955961311ee18ac205f">L</a>, U;
<a name="l06586"></a>06586 
<a name="l06587"></a>06587             <span class="keywordflow">if</span> (!<a class="code" href="ada-lang_8c.html#ace9b2035b5472767719b10e8d2691e11">ada_scan_number</a> (name, p + 1, &amp;L, &amp;p)
<a name="l06588"></a>06588                 || name[p] != <span class="charliteral">&#39;T&#39;</span> || !<a class="code" href="ada-lang_8c.html#ace9b2035b5472767719b10e8d2691e11">ada_scan_number</a> (name, p + 1, &amp;U, &amp;p))
<a name="l06589"></a>06589               <span class="keywordflow">return</span> 0;
<a name="l06590"></a>06590             <span class="keywordflow">if</span> (val &gt;= L &amp;&amp; val &lt;= U)
<a name="l06591"></a>06591               <span class="keywordflow">return</span> 1;
<a name="l06592"></a>06592             <span class="keywordflow">break</span>;
<a name="l06593"></a>06593           }
<a name="l06594"></a>06594         <span class="keywordflow">case</span> <span class="charliteral">&#39;O&#39;</span>:
<a name="l06595"></a>06595           <span class="keywordflow">return</span> 1;
<a name="l06596"></a>06596         <span class="keywordflow">default</span>:
<a name="l06597"></a>06597           <span class="keywordflow">return</span> 0;
<a name="l06598"></a>06598         }
<a name="l06599"></a>06599     }
<a name="l06600"></a>06600 }
<a name="l06601"></a>06601 
<a name="l06602"></a>06602 <span class="comment">/* FIXME: Lots of redundancy below.  Try to consolidate.  */</span>
<a name="l06603"></a>06603 
<a name="l06604"></a>06604 <span class="comment">/* Given a value ARG1 (offset by OFFSET bytes) of a struct or union type</span>
<a name="l06605"></a>06605 <span class="comment">   ARG_TYPE, extract and return the value of one of its (non-static)</span>
<a name="l06606"></a>06606 <span class="comment">   fields.  FIELDNO says which field.   Differs from value_primitive_field</span>
<a name="l06607"></a>06607 <span class="comment">   only in that it can handle packed values of arbitrary type.  */</span>
<a name="l06608"></a>06608 
<a name="l06609"></a>06609 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l06610"></a>06610 ada_value_primitive_field (<span class="keyword">struct</span> value *arg1, <span class="keywordtype">int</span> offset, <span class="keywordtype">int</span> fieldno,
<a name="l06611"></a>06611                            <span class="keyword">struct</span> type *arg_type)
<a name="l06612"></a>06612 {
<a name="l06613"></a>06613   <span class="keyword">struct </span>type *type;
<a name="l06614"></a>06614 
<a name="l06615"></a>06615   arg_type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (arg_type);
<a name="l06616"></a>06616   type = <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (arg_type, fieldno);
<a name="l06617"></a>06617 
<a name="l06618"></a>06618   <span class="comment">/* Handle packed fields.  */</span>
<a name="l06619"></a>06619 
<a name="l06620"></a>06620   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (arg_type, fieldno) != 0)
<a name="l06621"></a>06621     {
<a name="l06622"></a>06622       <span class="keywordtype">int</span> bit_pos = <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (arg_type, fieldno);
<a name="l06623"></a>06623       <span class="keywordtype">int</span> bit_size = <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (arg_type, fieldno);
<a name="l06624"></a>06624 
<a name="l06625"></a>06625       <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a3f0830ba146bedfa9564f572fa61042c">ada_value_primitive_packed_val</a> (arg1, <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (arg1),
<a name="l06626"></a>06626                                              offset + bit_pos / 8,
<a name="l06627"></a>06627                                              bit_pos % 8, bit_size, type);
<a name="l06628"></a>06628     }
<a name="l06629"></a>06629   <span class="keywordflow">else</span>
<a name="l06630"></a>06630     <span class="keywordflow">return</span> <a class="code" href="value_8c.html#ac6e677d5cd8f7c40c20448fd7418b01c">value_primitive_field</a> (arg1, offset, fieldno, arg_type);
<a name="l06631"></a>06631 }
<a name="l06632"></a>06632 
<a name="l06633"></a>06633 <span class="comment">/* Find field with name NAME in object of type TYPE.  If found, </span>
<a name="l06634"></a>06634 <span class="comment">   set the following for each argument that is non-null:</span>
<a name="l06635"></a>06635 <span class="comment">    - *FIELD_TYPE_P to the field&#39;s type; </span>
<a name="l06636"></a>06636 <span class="comment">    - *BYTE_OFFSET_P to OFFSET + the byte offset of the field within </span>
<a name="l06637"></a>06637 <span class="comment">      an object of that type;</span>
<a name="l06638"></a>06638 <span class="comment">    - *BIT_OFFSET_P to the bit offset modulo byte size of the field; </span>
<a name="l06639"></a>06639 <span class="comment">    - *BIT_SIZE_P to its size in bits if the field is packed, and </span>
<a name="l06640"></a>06640 <span class="comment">      0 otherwise;</span>
<a name="l06641"></a>06641 <span class="comment">   If INDEX_P is non-null, increment *INDEX_P by the number of source-visible</span>
<a name="l06642"></a>06642 <span class="comment">   fields up to but not including the desired field, or by the total</span>
<a name="l06643"></a>06643 <span class="comment">   number of fields if not found.   A NULL value of NAME never</span>
<a name="l06644"></a>06644 <span class="comment">   matches; the function just counts visible fields in this case.</span>
<a name="l06645"></a>06645 <span class="comment">   </span>
<a name="l06646"></a>06646 <span class="comment">   Returns 1 if found, 0 otherwise.  */</span>
<a name="l06647"></a>06647 
<a name="l06648"></a>06648 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l06649"></a>06649 find_struct_field (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> offset,
<a name="l06650"></a>06650                    <span class="keyword">struct</span> type **field_type_p,
<a name="l06651"></a>06651                    <span class="keywordtype">int</span> *byte_offset_p, <span class="keywordtype">int</span> *bit_offset_p, <span class="keywordtype">int</span> *bit_size_p,
<a name="l06652"></a>06652                    <span class="keywordtype">int</span> *index_p)
<a name="l06653"></a>06653 {
<a name="l06654"></a>06654   <span class="keywordtype">int</span> i;
<a name="l06655"></a>06655 
<a name="l06656"></a>06656   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l06657"></a>06657 
<a name="l06658"></a>06658   <span class="keywordflow">if</span> (field_type_p != NULL)
<a name="l06659"></a>06659     *field_type_p = NULL;
<a name="l06660"></a>06660   <span class="keywordflow">if</span> (byte_offset_p != NULL)
<a name="l06661"></a>06661     *byte_offset_p = 0;
<a name="l06662"></a>06662   <span class="keywordflow">if</span> (bit_offset_p != NULL)
<a name="l06663"></a>06663     *bit_offset_p = 0;
<a name="l06664"></a>06664   <span class="keywordflow">if</span> (bit_size_p != NULL)
<a name="l06665"></a>06665     *bit_size_p = 0;
<a name="l06666"></a>06666 
<a name="l06667"></a>06667   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type); i += 1)
<a name="l06668"></a>06668     {
<a name="l06669"></a>06669       <span class="keywordtype">int</span> bit_pos = <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (type, i);
<a name="l06670"></a>06670       <span class="keywordtype">int</span> fld_offset = offset + bit_pos / 8;
<a name="l06671"></a>06671       <span class="keyword">const</span> <span class="keywordtype">char</span> *t_field_name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, i);
<a name="l06672"></a>06672 
<a name="l06673"></a>06673       <span class="keywordflow">if</span> (t_field_name == NULL)
<a name="l06674"></a>06674         <span class="keywordflow">continue</span>;
<a name="l06675"></a>06675 
<a name="l06676"></a>06676       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name != NULL &amp;&amp; field_name_match (t_field_name, name))
<a name="l06677"></a>06677         {
<a name="l06678"></a>06678           <span class="keywordtype">int</span> bit_size = <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (type, i);
<a name="l06679"></a>06679 
<a name="l06680"></a>06680           <span class="keywordflow">if</span> (field_type_p != NULL)
<a name="l06681"></a>06681             *field_type_p = <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, i);
<a name="l06682"></a>06682           <span class="keywordflow">if</span> (byte_offset_p != NULL)
<a name="l06683"></a>06683             *byte_offset_p = fld_offset;
<a name="l06684"></a>06684           <span class="keywordflow">if</span> (bit_offset_p != NULL)
<a name="l06685"></a>06685             *bit_offset_p = bit_pos % 8;
<a name="l06686"></a>06686           <span class="keywordflow">if</span> (bit_size_p != NULL)
<a name="l06687"></a>06687             *bit_size_p = bit_size;
<a name="l06688"></a>06688           <span class="keywordflow">return</span> 1;
<a name="l06689"></a>06689         }
<a name="l06690"></a>06690       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ab6ed5a863da98f196c38498f7512d30b">ada_is_wrapper_field</a> (type, i))
<a name="l06691"></a>06691         {
<a name="l06692"></a>06692           <span class="keywordflow">if</span> (find_struct_field (name, <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, i), fld_offset,
<a name="l06693"></a>06693                                  field_type_p, byte_offset_p, bit_offset_p,
<a name="l06694"></a>06694                                  bit_size_p, index_p))
<a name="l06695"></a>06695             <span class="keywordflow">return</span> 1;
<a name="l06696"></a>06696         }
<a name="l06697"></a>06697       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a370ccbe192d73c5795afa034113a4ffb">ada_is_variant_part</a> (type, i))
<a name="l06698"></a>06698         {
<a name="l06699"></a>06699           <span class="comment">/* PNH: Wait.  Do we ever execute this section, or is ARG always of </span>
<a name="l06700"></a>06700 <span class="comment">             fixed type?? */</span>
<a name="l06701"></a>06701           <span class="keywordtype">int</span> j;
<a name="l06702"></a>06702           <span class="keyword">struct </span>type *field_type
<a name="l06703"></a>06703             = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, i));
<a name="l06704"></a>06704 
<a name="l06705"></a>06705           <span class="keywordflow">for</span> (j = 0; j &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (field_type); j += 1)
<a name="l06706"></a>06706             {
<a name="l06707"></a>06707               <span class="keywordflow">if</span> (find_struct_field (name, <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (field_type, j),
<a name="l06708"></a>06708                                      fld_offset
<a name="l06709"></a>06709                                      + <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (field_type, j) / 8,
<a name="l06710"></a>06710                                      field_type_p, byte_offset_p,
<a name="l06711"></a>06711                                      bit_offset_p, bit_size_p, index_p))
<a name="l06712"></a>06712                 <span class="keywordflow">return</span> 1;
<a name="l06713"></a>06713             }
<a name="l06714"></a>06714         }
<a name="l06715"></a>06715       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (index_p != NULL)
<a name="l06716"></a>06716         *index_p += 1;
<a name="l06717"></a>06717     }
<a name="l06718"></a>06718   <span class="keywordflow">return</span> 0;
<a name="l06719"></a>06719 }
<a name="l06720"></a>06720 
<a name="l06721"></a>06721 <span class="comment">/* Number of user-visible fields in record type TYPE.  */</span>
<a name="l06722"></a>06722 
<a name="l06723"></a>06723 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l06724"></a>06724 num_visible_fields (<span class="keyword">struct</span> type *type)
<a name="l06725"></a>06725 {
<a name="l06726"></a>06726   <span class="keywordtype">int</span> n;
<a name="l06727"></a>06727 
<a name="l06728"></a>06728   n = 0;
<a name="l06729"></a>06729   find_struct_field (NULL, type, 0, NULL, NULL, NULL, NULL, &amp;n);
<a name="l06730"></a>06730   <span class="keywordflow">return</span> n;
<a name="l06731"></a>06731 }
<a name="l06732"></a>06732 
<a name="l06733"></a>06733 <span class="comment">/* Look for a field NAME in ARG.  Adjust the address of ARG by OFFSET bytes,</span>
<a name="l06734"></a>06734 <span class="comment">   and search in it assuming it has (class) type TYPE.</span>
<a name="l06735"></a>06735 <span class="comment">   If found, return value, else return NULL.</span>
<a name="l06736"></a>06736 <span class="comment"></span>
<a name="l06737"></a>06737 <span class="comment">   Searches recursively through wrapper fields (e.g., &#39;_parent&#39;).  */</span>
<a name="l06738"></a>06738 
<a name="l06739"></a>06739 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l06740"></a>06740 ada_search_struct_field (<span class="keywordtype">char</span> *name, <span class="keyword">struct</span> value *arg, <span class="keywordtype">int</span> offset,
<a name="l06741"></a>06741                          <span class="keyword">struct</span> type *type)
<a name="l06742"></a>06742 {
<a name="l06743"></a>06743   <span class="keywordtype">int</span> i;
<a name="l06744"></a>06744 
<a name="l06745"></a>06745   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l06746"></a>06746   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type); i += 1)
<a name="l06747"></a>06747     {
<a name="l06748"></a>06748       <span class="keyword">const</span> <span class="keywordtype">char</span> *t_field_name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, i);
<a name="l06749"></a>06749 
<a name="l06750"></a>06750       <span class="keywordflow">if</span> (t_field_name == NULL)
<a name="l06751"></a>06751         <span class="keywordflow">continue</span>;
<a name="l06752"></a>06752 
<a name="l06753"></a>06753       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (field_name_match (t_field_name, name))
<a name="l06754"></a>06754         <span class="keywordflow">return</span> ada_value_primitive_field (arg, offset, i, type);
<a name="l06755"></a>06755 
<a name="l06756"></a>06756       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ab6ed5a863da98f196c38498f7512d30b">ada_is_wrapper_field</a> (type, i))
<a name="l06757"></a>06757         {
<a name="l06758"></a>06758           <span class="keyword">struct </span>value *v =     <span class="comment">/* Do not let indent join lines here.  */</span>
<a name="l06759"></a>06759             ada_search_struct_field (name, arg,
<a name="l06760"></a>06760                                      offset + <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (type, i) / 8,
<a name="l06761"></a>06761                                      <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, i));
<a name="l06762"></a>06762 
<a name="l06763"></a>06763           <span class="keywordflow">if</span> (v != NULL)
<a name="l06764"></a>06764             <span class="keywordflow">return</span> v;
<a name="l06765"></a>06765         }
<a name="l06766"></a>06766 
<a name="l06767"></a>06767       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a370ccbe192d73c5795afa034113a4ffb">ada_is_variant_part</a> (type, i))
<a name="l06768"></a>06768         {
<a name="l06769"></a>06769           <span class="comment">/* PNH: Do we ever get here?  See find_struct_field.  */</span>
<a name="l06770"></a>06770           <span class="keywordtype">int</span> j;
<a name="l06771"></a>06771           <span class="keyword">struct </span>type *field_type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type,
<a name="l06772"></a>06772                                                                         i));
<a name="l06773"></a>06773           <span class="keywordtype">int</span> var_offset = offset + <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (type, i) / 8;
<a name="l06774"></a>06774 
<a name="l06775"></a>06775           <span class="keywordflow">for</span> (j = 0; j &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (field_type); j += 1)
<a name="l06776"></a>06776             {
<a name="l06777"></a>06777               <span class="keyword">struct </span>value *v = ada_search_struct_field <span class="comment">/* Force line</span>
<a name="l06778"></a>06778 <span class="comment">                                                           break.  */</span>
<a name="l06779"></a>06779                 (<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>, arg,
<a name="l06780"></a>06780                  var_offset + <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (field_type, j) / 8,
<a name="l06781"></a>06781                  <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (field_type, j));
<a name="l06782"></a>06782 
<a name="l06783"></a>06783               <span class="keywordflow">if</span> (v != NULL)
<a name="l06784"></a>06784                 <span class="keywordflow">return</span> v;
<a name="l06785"></a>06785             }
<a name="l06786"></a>06786         }
<a name="l06787"></a>06787     }
<a name="l06788"></a>06788   <span class="keywordflow">return</span> NULL;
<a name="l06789"></a>06789 }
<a name="l06790"></a>06790 
<a name="l06791"></a>06791 <span class="keyword">static</span> <span class="keyword">struct </span>value *ada_index_struct_field_1 (<span class="keywordtype">int</span> *, <span class="keyword">struct</span> value *,
<a name="l06792"></a>06792                                                <span class="keywordtype">int</span>, <span class="keyword">struct</span> type *);
<a name="l06793"></a>06793 
<a name="l06794"></a>06794 
<a name="l06795"></a>06795 <span class="comment">/* Return field #INDEX in ARG, where the index is that returned by</span>
<a name="l06796"></a>06796 <span class="comment"> * find_struct_field through its INDEX_P argument.  Adjust the address</span>
<a name="l06797"></a>06797 <span class="comment"> * of ARG by OFFSET bytes, and search in it assuming it has (class) type TYPE.</span>
<a name="l06798"></a>06798 <span class="comment"> * If found, return value, else return NULL.  */</span>
<a name="l06799"></a>06799 
<a name="l06800"></a>06800 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l06801"></a>06801 ada_index_struct_field (<span class="keywordtype">int</span> index, <span class="keyword">struct</span> value *arg, <span class="keywordtype">int</span> offset,
<a name="l06802"></a>06802                         <span class="keyword">struct</span> type *type)
<a name="l06803"></a>06803 {
<a name="l06804"></a>06804   <span class="keywordflow">return</span> ada_index_struct_field_1 (&amp;index, arg, offset, type);
<a name="l06805"></a>06805 }
<a name="l06806"></a>06806 
<a name="l06807"></a>06807 
<a name="l06808"></a>06808 <span class="comment">/* Auxiliary function for ada_index_struct_field.  Like</span>
<a name="l06809"></a>06809 <span class="comment"> * ada_index_struct_field, but takes index from *INDEX_P and modifies</span>
<a name="l06810"></a>06810 <span class="comment"> * *INDEX_P.  */</span>
<a name="l06811"></a>06811 
<a name="l06812"></a>06812 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l06813"></a>06813 ada_index_struct_field_1 (<span class="keywordtype">int</span> *index_p, <span class="keyword">struct</span> value *arg, <span class="keywordtype">int</span> offset,
<a name="l06814"></a>06814                           <span class="keyword">struct</span> type *type)
<a name="l06815"></a>06815 {
<a name="l06816"></a>06816   <span class="keywordtype">int</span> i;
<a name="l06817"></a>06817   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l06818"></a>06818 
<a name="l06819"></a>06819   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type); i += 1)
<a name="l06820"></a>06820     {
<a name="l06821"></a>06821       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, i) == NULL)
<a name="l06822"></a>06822         <span class="keywordflow">continue</span>;
<a name="l06823"></a>06823       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ab6ed5a863da98f196c38498f7512d30b">ada_is_wrapper_field</a> (type, i))
<a name="l06824"></a>06824         {
<a name="l06825"></a>06825           <span class="keyword">struct </span>value *v =     <span class="comment">/* Do not let indent join lines here.  */</span>
<a name="l06826"></a>06826             ada_index_struct_field_1 (index_p, arg,
<a name="l06827"></a>06827                                       offset + <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (type, i) / 8,
<a name="l06828"></a>06828                                       <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, i));
<a name="l06829"></a>06829 
<a name="l06830"></a>06830           <span class="keywordflow">if</span> (v != NULL)
<a name="l06831"></a>06831             <span class="keywordflow">return</span> v;
<a name="l06832"></a>06832         }
<a name="l06833"></a>06833 
<a name="l06834"></a>06834       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a370ccbe192d73c5795afa034113a4ffb">ada_is_variant_part</a> (type, i))
<a name="l06835"></a>06835         {
<a name="l06836"></a>06836           <span class="comment">/* PNH: Do we ever get here?  See ada_search_struct_field,</span>
<a name="l06837"></a>06837 <span class="comment">             find_struct_field.  */</span>
<a name="l06838"></a>06838           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot assign this kind of variant record&quot;</span>));
<a name="l06839"></a>06839         }
<a name="l06840"></a>06840       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*index_p == 0)
<a name="l06841"></a>06841         <span class="keywordflow">return</span> ada_value_primitive_field (arg, offset, i, type);
<a name="l06842"></a>06842       <span class="keywordflow">else</span>
<a name="l06843"></a>06843         *index_p -= 1;
<a name="l06844"></a>06844     }
<a name="l06845"></a>06845   <span class="keywordflow">return</span> NULL;
<a name="l06846"></a>06846 }
<a name="l06847"></a>06847 
<a name="l06848"></a>06848 <span class="comment">/* Given ARG, a value of type (pointer or reference to a)*</span>
<a name="l06849"></a>06849 <span class="comment">   structure/union, extract the component named NAME from the ultimate</span>
<a name="l06850"></a>06850 <span class="comment">   target structure/union and return it as a value with its</span>
<a name="l06851"></a>06851 <span class="comment">   appropriate type.</span>
<a name="l06852"></a>06852 <span class="comment"></span>
<a name="l06853"></a>06853 <span class="comment">   The routine searches for NAME among all members of the structure itself</span>
<a name="l06854"></a>06854 <span class="comment">   and (recursively) among all members of any wrapper members</span>
<a name="l06855"></a>06855 <span class="comment">   (e.g., &#39;_parent&#39;).</span>
<a name="l06856"></a>06856 <span class="comment"></span>
<a name="l06857"></a>06857 <span class="comment">   If NO_ERR, then simply return NULL in case of error, rather than </span>
<a name="l06858"></a>06858 <span class="comment">   calling error.  */</span>
<a name="l06859"></a>06859 
<a name="l06860"></a>06860 <span class="keyword">struct </span>value *
<a name="l06861"></a><a class="code" href="ada-lang_8h.html#ad38c390022867ada7f2d88d94acb17ed">06861</a> <a class="code" href="ada-lang_8c.html#a9d3934026567a1840970ca108755b6e9">ada_value_struct_elt</a> (<span class="keyword">struct</span> value *arg, <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> no_err)
<a name="l06862"></a>06862 {
<a name="l06863"></a>06863   <span class="keyword">struct </span>type *t, *t1;
<a name="l06864"></a>06864   <span class="keyword">struct </span>value *v;
<a name="l06865"></a>06865 
<a name="l06866"></a>06866   v = NULL;
<a name="l06867"></a>06867   t1 = t = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg));
<a name="l06868"></a>06868   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l06869"></a>06869     {
<a name="l06870"></a>06870       t1 = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (t);
<a name="l06871"></a>06871       <span class="keywordflow">if</span> (t1 == NULL)
<a name="l06872"></a>06872         <span class="keywordflow">goto</span> BadValue;
<a name="l06873"></a>06873       t1 = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (t1);
<a name="l06874"></a>06874       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t1) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l06875"></a>06875         {
<a name="l06876"></a>06876           arg = <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (arg);
<a name="l06877"></a>06877           t = t1;
<a name="l06878"></a>06878         }
<a name="l06879"></a>06879     }
<a name="l06880"></a>06880 
<a name="l06881"></a>06881   <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l06882"></a>06882     {
<a name="l06883"></a>06883       t1 = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (t);
<a name="l06884"></a>06884       <span class="keywordflow">if</span> (t1 == NULL)
<a name="l06885"></a>06885         <span class="keywordflow">goto</span> BadValue;
<a name="l06886"></a>06886       t1 = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (t1);
<a name="l06887"></a>06887       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t1) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l06888"></a>06888         {
<a name="l06889"></a>06889           arg = <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (arg);
<a name="l06890"></a>06890           t = t1;
<a name="l06891"></a>06891         }
<a name="l06892"></a>06892       <span class="keywordflow">else</span>
<a name="l06893"></a>06893         <span class="keywordflow">break</span>;
<a name="l06894"></a>06894     }
<a name="l06895"></a>06895 
<a name="l06896"></a>06896   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t1) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a> &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t1) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>)
<a name="l06897"></a>06897     <span class="keywordflow">goto</span> BadValue;
<a name="l06898"></a>06898 
<a name="l06899"></a>06899   <span class="keywordflow">if</span> (t1 == t)
<a name="l06900"></a>06900     v = ada_search_struct_field (name, arg, 0, t);
<a name="l06901"></a>06901   <span class="keywordflow">else</span>
<a name="l06902"></a>06902     {
<a name="l06903"></a>06903       <span class="keywordtype">int</span> bit_offset, bit_size, byte_offset;
<a name="l06904"></a>06904       <span class="keyword">struct </span>type *field_type;
<a name="l06905"></a>06905       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address;
<a name="l06906"></a>06906 
<a name="l06907"></a>06907       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l06908"></a>06908         address = <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (<a class="code" href="ada-lang_8c.html#a917a1ba2a6b58d43803a1f999164295b">ada_value_ind</a> (arg));
<a name="l06909"></a>06909       <span class="keywordflow">else</span>
<a name="l06910"></a>06910         address = <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (ada_coerce_ref (arg));
<a name="l06911"></a>06911 
<a name="l06912"></a>06912       t1 = <a class="code" href="ada-lang_8c.html#a0096e64d1590f0b629f4a8ca484bddbd">ada_to_fixed_type</a> (<a class="code" href="ada-lang_8c.html#aac42a4c75acced2b75b65874ef51ead8">ada_get_base_type</a> (t1), NULL, address, NULL, 1);
<a name="l06913"></a>06913       <span class="keywordflow">if</span> (find_struct_field (name, t1, 0,
<a name="l06914"></a>06914                              &amp;field_type, &amp;byte_offset, &amp;bit_offset,
<a name="l06915"></a>06915                              &amp;bit_size, NULL))
<a name="l06916"></a>06916         {
<a name="l06917"></a>06917           <span class="keywordflow">if</span> (bit_size != 0)
<a name="l06918"></a>06918             {
<a name="l06919"></a>06919               <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (t) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l06920"></a>06920                 arg = ada_coerce_ref (arg);
<a name="l06921"></a>06921               <span class="keywordflow">else</span>
<a name="l06922"></a>06922                 arg = <a class="code" href="ada-lang_8c.html#a917a1ba2a6b58d43803a1f999164295b">ada_value_ind</a> (arg);
<a name="l06923"></a>06923               v = <a class="code" href="ada-lang_8c.html#a3f0830ba146bedfa9564f572fa61042c">ada_value_primitive_packed_val</a> (arg, NULL, byte_offset,
<a name="l06924"></a>06924                                                   bit_offset, bit_size,
<a name="l06925"></a>06925                                                   field_type);
<a name="l06926"></a>06926             }
<a name="l06927"></a>06927           <span class="keywordflow">else</span>
<a name="l06928"></a>06928             v = <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (field_type, address + byte_offset);
<a name="l06929"></a>06929         }
<a name="l06930"></a>06930     }
<a name="l06931"></a>06931 
<a name="l06932"></a>06932   <span class="keywordflow">if</span> (v != NULL || no_err)
<a name="l06933"></a>06933     <span class="keywordflow">return</span> v;
<a name="l06934"></a>06934   <span class="keywordflow">else</span>
<a name="l06935"></a>06935     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;There is no member named %s.&quot;</span>), name);
<a name="l06936"></a>06936 
<a name="l06937"></a>06937  BadValue:
<a name="l06938"></a>06938   <span class="keywordflow">if</span> (no_err)
<a name="l06939"></a>06939     <span class="keywordflow">return</span> NULL;
<a name="l06940"></a>06940   <span class="keywordflow">else</span>
<a name="l06941"></a>06941     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attempt to extract a component of &quot;</span>
<a name="l06942"></a>06942              <span class="stringliteral">&quot;a value that is not a record.&quot;</span>));
<a name="l06943"></a>06943 }
<a name="l06944"></a>06944 
<a name="l06945"></a>06945 <span class="comment">/* Given a type TYPE, look up the type of the component of type named NAME.</span>
<a name="l06946"></a>06946 <span class="comment">   If DISPP is non-null, add its byte displacement from the beginning of a</span>
<a name="l06947"></a>06947 <span class="comment">   structure (pointed to by a value) of type TYPE to *DISPP (does not</span>
<a name="l06948"></a>06948 <span class="comment">   work for packed fields).</span>
<a name="l06949"></a>06949 <span class="comment"></span>
<a name="l06950"></a>06950 <span class="comment">   Matches any field whose name has NAME as a prefix, possibly</span>
<a name="l06951"></a>06951 <span class="comment">   followed by &quot;___&quot;.</span>
<a name="l06952"></a>06952 <span class="comment"></span>
<a name="l06953"></a>06953 <span class="comment">   TYPE can be either a struct or union.  If REFOK, TYPE may also </span>
<a name="l06954"></a>06954 <span class="comment">   be a (pointer or reference)+ to a struct or union, and the</span>
<a name="l06955"></a>06955 <span class="comment">   ultimate target type will be searched.</span>
<a name="l06956"></a>06956 <span class="comment"></span>
<a name="l06957"></a>06957 <span class="comment">   Looks recursively into variant clauses and parent types.</span>
<a name="l06958"></a>06958 <span class="comment"></span>
<a name="l06959"></a>06959 <span class="comment">   If NOERR is nonzero, return NULL if NAME is not suitably defined or</span>
<a name="l06960"></a>06960 <span class="comment">   TYPE is not a type of the right kind.  */</span>
<a name="l06961"></a>06961 
<a name="l06962"></a>06962 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l06963"></a>06963 ada_lookup_struct_elt_type (<span class="keyword">struct</span> type *type, <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> refok,
<a name="l06964"></a>06964                             <span class="keywordtype">int</span> noerr, <span class="keywordtype">int</span> *dispp)
<a name="l06965"></a>06965 {
<a name="l06966"></a>06966   <span class="keywordtype">int</span> i;
<a name="l06967"></a>06967 
<a name="l06968"></a>06968   <span class="keywordflow">if</span> (name == NULL)
<a name="l06969"></a>06969     <span class="keywordflow">goto</span> BadName;
<a name="l06970"></a>06970 
<a name="l06971"></a>06971   <span class="keywordflow">if</span> (refok &amp;&amp; type != NULL)
<a name="l06972"></a>06972     <span class="keywordflow">while</span> (1)
<a name="l06973"></a>06973       {
<a name="l06974"></a>06974         type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l06975"></a>06975         <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l06976"></a>06976             &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l06977"></a>06977           <span class="keywordflow">break</span>;
<a name="l06978"></a>06978         type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l06979"></a>06979       }
<a name="l06980"></a>06980 
<a name="l06981"></a>06981   <span class="keywordflow">if</span> (type == NULL
<a name="l06982"></a>06982       || (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l06983"></a>06983           &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>))
<a name="l06984"></a>06984     {
<a name="l06985"></a>06985       <span class="keywordflow">if</span> (noerr)
<a name="l06986"></a>06986         <span class="keywordflow">return</span> NULL;
<a name="l06987"></a>06987       <span class="keywordflow">else</span>
<a name="l06988"></a>06988         {
<a name="l06989"></a>06989           <a class="code" href="target_8h.html#a7128a26aa3c50e663201b4a6633636fe">target_terminal_ours</a> ();
<a name="l06990"></a>06990           <a class="code" href="ui-file_8c.html#a046f07b5ef1bcc35c28b4be983e39998">gdb_flush</a> (<a class="code" href="main_8c.html#a41a2b997ba5454df787d61f051dd918c">gdb_stdout</a>);
<a name="l06991"></a>06991           <span class="keywordflow">if</span> (type == NULL)
<a name="l06992"></a>06992             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Type (null) is not a structure or union type&quot;</span>));
<a name="l06993"></a>06993           <span class="keywordflow">else</span>
<a name="l06994"></a>06994             {
<a name="l06995"></a>06995               <span class="comment">/* XXX: type_sprint */</span>
<a name="l06996"></a>06996               <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Type &quot;</span>));
<a name="l06997"></a>06997               <a class="code" href="typeprint_8c.html#ad50c90b55385094557cceaa1ea985e47">type_print</a> (type, <span class="stringliteral">&quot;&quot;</span>, <a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, -1);
<a name="l06998"></a>06998               <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot; is not a structure or union type&quot;</span>));
<a name="l06999"></a>06999             }
<a name="l07000"></a>07000         }
<a name="l07001"></a>07001     }
<a name="l07002"></a>07002 
<a name="l07003"></a>07003   type = to_static_fixed_type (type);
<a name="l07004"></a>07004 
<a name="l07005"></a>07005   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type); i += 1)
<a name="l07006"></a>07006     {
<a name="l07007"></a>07007       <span class="keyword">const</span> <span class="keywordtype">char</span> *t_field_name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, i);
<a name="l07008"></a>07008       <span class="keyword">struct </span>type *t;
<a name="l07009"></a>07009       <span class="keywordtype">int</span> disp;
<a name="l07010"></a>07010 
<a name="l07011"></a>07011       <span class="keywordflow">if</span> (t_field_name == NULL)
<a name="l07012"></a>07012         <span class="keywordflow">continue</span>;
<a name="l07013"></a>07013 
<a name="l07014"></a>07014       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (field_name_match (t_field_name, name))
<a name="l07015"></a>07015         {
<a name="l07016"></a>07016           <span class="keywordflow">if</span> (dispp != NULL)
<a name="l07017"></a>07017             *dispp += <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (type, i) / 8;
<a name="l07018"></a>07018           <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, i));
<a name="l07019"></a>07019         }
<a name="l07020"></a>07020 
<a name="l07021"></a>07021       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ab6ed5a863da98f196c38498f7512d30b">ada_is_wrapper_field</a> (type, i))
<a name="l07022"></a>07022         {
<a name="l07023"></a>07023           disp = 0;
<a name="l07024"></a>07024           t = ada_lookup_struct_elt_type (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, i), name,
<a name="l07025"></a>07025                                           0, 1, &amp;disp);
<a name="l07026"></a>07026           <span class="keywordflow">if</span> (t != NULL)
<a name="l07027"></a>07027             {
<a name="l07028"></a>07028               <span class="keywordflow">if</span> (dispp != NULL)
<a name="l07029"></a>07029                 *dispp += disp + <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (type, i) / 8;
<a name="l07030"></a>07030               <span class="keywordflow">return</span> t;
<a name="l07031"></a>07031             }
<a name="l07032"></a>07032         }
<a name="l07033"></a>07033 
<a name="l07034"></a>07034       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a370ccbe192d73c5795afa034113a4ffb">ada_is_variant_part</a> (type, i))
<a name="l07035"></a>07035         {
<a name="l07036"></a>07036           <span class="keywordtype">int</span> j;
<a name="l07037"></a>07037           <span class="keyword">struct </span>type *field_type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type,
<a name="l07038"></a>07038                                                                         i));
<a name="l07039"></a>07039 
<a name="l07040"></a>07040           <span class="keywordflow">for</span> (j = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (field_type) - 1; j &gt;= 0; j -= 1)
<a name="l07041"></a>07041             {
<a name="l07042"></a>07042               <span class="comment">/* FIXME pnh 2008/01/26: We check for a field that is</span>
<a name="l07043"></a>07043 <span class="comment">                 NOT wrapped in a struct, since the compiler sometimes</span>
<a name="l07044"></a>07044 <span class="comment">                 generates these for unchecked variant types.  Revisit</span>
<a name="l07045"></a>07045 <span class="comment">                 if the compiler changes this practice.  */</span>
<a name="l07046"></a>07046               <span class="keyword">const</span> <span class="keywordtype">char</span> *v_field_name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (field_type, j);
<a name="l07047"></a>07047               disp = 0;
<a name="l07048"></a>07048               <span class="keywordflow">if</span> (v_field_name != NULL 
<a name="l07049"></a>07049                   &amp;&amp; field_name_match (v_field_name, name))
<a name="l07050"></a>07050                 t = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (field_type, j));
<a name="l07051"></a>07051               <span class="keywordflow">else</span>
<a name="l07052"></a>07052                 t = ada_lookup_struct_elt_type (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (field_type,
<a name="l07053"></a>07053                                                                  j),
<a name="l07054"></a>07054                                                 name, 0, 1, &amp;disp);
<a name="l07055"></a>07055 
<a name="l07056"></a>07056               <span class="keywordflow">if</span> (t != NULL)
<a name="l07057"></a>07057                 {
<a name="l07058"></a>07058                   <span class="keywordflow">if</span> (dispp != NULL)
<a name="l07059"></a>07059                     *dispp += disp + <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (type, i) / 8;
<a name="l07060"></a>07060                   <span class="keywordflow">return</span> t;
<a name="l07061"></a>07061                 }
<a name="l07062"></a>07062             }
<a name="l07063"></a>07063         }
<a name="l07064"></a>07064 
<a name="l07065"></a>07065     }
<a name="l07066"></a>07066 
<a name="l07067"></a>07067 BadName:
<a name="l07068"></a>07068   <span class="keywordflow">if</span> (!noerr)
<a name="l07069"></a>07069     {
<a name="l07070"></a>07070       <a class="code" href="target_8h.html#a7128a26aa3c50e663201b4a6633636fe">target_terminal_ours</a> ();
<a name="l07071"></a>07071       <a class="code" href="ui-file_8c.html#a046f07b5ef1bcc35c28b4be983e39998">gdb_flush</a> (<a class="code" href="main_8c.html#a41a2b997ba5454df787d61f051dd918c">gdb_stdout</a>);
<a name="l07072"></a>07072       <span class="keywordflow">if</span> (name == NULL)
<a name="l07073"></a>07073         {
<a name="l07074"></a>07074           <span class="comment">/* XXX: type_sprint */</span>
<a name="l07075"></a>07075           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Type &quot;</span>));
<a name="l07076"></a>07076           <a class="code" href="typeprint_8c.html#ad50c90b55385094557cceaa1ea985e47">type_print</a> (type, <span class="stringliteral">&quot;&quot;</span>, <a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, -1);
<a name="l07077"></a>07077           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot; has no component named &lt;null&gt;&quot;</span>));
<a name="l07078"></a>07078         }
<a name="l07079"></a>07079       <span class="keywordflow">else</span>
<a name="l07080"></a>07080         {
<a name="l07081"></a>07081           <span class="comment">/* XXX: type_sprint */</span>
<a name="l07082"></a>07082           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Type &quot;</span>));
<a name="l07083"></a>07083           <a class="code" href="typeprint_8c.html#ad50c90b55385094557cceaa1ea985e47">type_print</a> (type, <span class="stringliteral">&quot;&quot;</span>, <a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, -1);
<a name="l07084"></a>07084           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot; has no component named %s&quot;</span>), name);
<a name="l07085"></a>07085         }
<a name="l07086"></a>07086     }
<a name="l07087"></a>07087 
<a name="l07088"></a>07088   <span class="keywordflow">return</span> NULL;
<a name="l07089"></a>07089 }
<a name="l07090"></a>07090 
<a name="l07091"></a>07091 <span class="comment">/* Assuming that VAR_TYPE is the type of a variant part of a record (a union),</span>
<a name="l07092"></a>07092 <span class="comment">   within a value of type OUTER_TYPE, return true iff VAR_TYPE</span>
<a name="l07093"></a>07093 <span class="comment">   represents an unchecked union (that is, the variant part of a</span>
<a name="l07094"></a>07094 <span class="comment">   record that is named in an Unchecked_Union pragma).  */</span>
<a name="l07095"></a>07095 
<a name="l07096"></a>07096 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l07097"></a>07097 is_unchecked_variant (<span class="keyword">struct</span> type *var_type, <span class="keyword">struct</span> type *outer_type)
<a name="l07098"></a>07098 {
<a name="l07099"></a>07099   <span class="keywordtype">char</span> *discrim_name = <a class="code" href="ada-lang_8c.html#ada3cdba439483cae20c9779b19014135">ada_variant_discrim_name</a> (var_type);
<a name="l07100"></a>07100 
<a name="l07101"></a>07101   <span class="keywordflow">return</span> (ada_lookup_struct_elt_type (outer_type, discrim_name, 0, 1, NULL) 
<a name="l07102"></a>07102           == NULL);
<a name="l07103"></a>07103 }
<a name="l07104"></a>07104 
<a name="l07105"></a>07105 
<a name="l07106"></a>07106 <span class="comment">/* Assuming that VAR_TYPE is the type of a variant part of a record (a union),</span>
<a name="l07107"></a>07107 <span class="comment">   within a value of type OUTER_TYPE that is stored in GDB at</span>
<a name="l07108"></a>07108 <span class="comment">   OUTER_VALADDR, determine which variant clause (field number in VAR_TYPE,</span>
<a name="l07109"></a>07109 <span class="comment">   numbering from 0) is applicable.  Returns -1 if none are.  */</span>
<a name="l07110"></a>07110 
<a name="l07111"></a>07111 <span class="keywordtype">int</span>
<a name="l07112"></a><a class="code" href="ada-lang_8h.html#a4a5febeedec22c9d7f03e46e48994cbb">07112</a> <a class="code" href="ada-lang_8c.html#ac736764de442ef8224408d04089b2202">ada_which_variant_applies</a> (<span class="keyword">struct</span> type *var_type, <span class="keyword">struct</span> type *outer_type,
<a name="l07113"></a>07113                            <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *outer_valaddr)
<a name="l07114"></a>07114 {
<a name="l07115"></a>07115   <span class="keywordtype">int</span> others_clause;
<a name="l07116"></a>07116   <span class="keywordtype">int</span> i;
<a name="l07117"></a>07117   <span class="keywordtype">char</span> *discrim_name = <a class="code" href="ada-lang_8c.html#ada3cdba439483cae20c9779b19014135">ada_variant_discrim_name</a> (var_type);
<a name="l07118"></a>07118   <span class="keyword">struct </span>value *outer;
<a name="l07119"></a>07119   <span class="keyword">struct </span>value *discrim;
<a name="l07120"></a>07120   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> discrim_val;
<a name="l07121"></a>07121 
<a name="l07122"></a>07122   outer = <a class="code" href="value_8c.html#ab189fd2d8ea1fe71f000581289a20e17">value_from_contents_and_address</a> (outer_type, outer_valaddr, 0);
<a name="l07123"></a>07123   discrim = <a class="code" href="ada-lang_8c.html#a9d3934026567a1840970ca108755b6e9">ada_value_struct_elt</a> (outer, discrim_name, 1);
<a name="l07124"></a>07124   <span class="keywordflow">if</span> (discrim == NULL)
<a name="l07125"></a>07125     <span class="keywordflow">return</span> -1;
<a name="l07126"></a>07126   discrim_val = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (discrim);
<a name="l07127"></a>07127 
<a name="l07128"></a>07128   others_clause = -1;
<a name="l07129"></a>07129   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (var_type); i += 1)
<a name="l07130"></a>07130     {
<a name="l07131"></a>07131       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a3d640e6dd563c89a68fc207fe49a9808">ada_is_others_clause</a> (var_type, i))
<a name="l07132"></a>07132         others_clause = i;
<a name="l07133"></a>07133       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ae1ce38556e7e112cf40d0e76833de13f">ada_in_variant</a> (discrim_val, var_type, i))
<a name="l07134"></a>07134         <span class="keywordflow">return</span> i;
<a name="l07135"></a>07135     }
<a name="l07136"></a>07136 
<a name="l07137"></a>07137   <span class="keywordflow">return</span> others_clause;
<a name="l07138"></a>07138 }
<a name="l07139"></a>07139 
<a name="l07140"></a>07140 
<a name="l07141"></a>07141 
<a name="l07142"></a>07142                                 <span class="comment">/* Dynamic-Sized Records */</span>
<a name="l07143"></a>07143 
<a name="l07144"></a>07144 <span class="comment">/* Strategy: The type ostensibly attached to a value with dynamic size</span>
<a name="l07145"></a>07145 <span class="comment">   (i.e., a size that is not statically recorded in the debugging</span>
<a name="l07146"></a>07146 <span class="comment">   data) does not accurately reflect the size or layout of the value.</span>
<a name="l07147"></a>07147 <span class="comment">   Our strategy is to convert these values to values with accurate,</span>
<a name="l07148"></a>07148 <span class="comment">   conventional types that are constructed on the fly.  */</span>
<a name="l07149"></a>07149 
<a name="l07150"></a>07150 <span class="comment">/* There is a subtle and tricky problem here.  In general, we cannot</span>
<a name="l07151"></a>07151 <span class="comment">   determine the size of dynamic records without its data.  However,</span>
<a name="l07152"></a>07152 <span class="comment">   the &#39;struct value&#39; data structure, which GDB uses to represent</span>
<a name="l07153"></a>07153 <span class="comment">   quantities in the inferior process (the target), requires the size</span>
<a name="l07154"></a>07154 <span class="comment">   of the type at the time of its allocation in order to reserve space</span>
<a name="l07155"></a>07155 <span class="comment">   for GDB&#39;s internal copy of the data.  That&#39;s why the</span>
<a name="l07156"></a>07156 <span class="comment">   &#39;to_fixed_xxx_type&#39; routines take (target) addresses as parameters,</span>
<a name="l07157"></a>07157 <span class="comment">   rather than struct value*s.</span>
<a name="l07158"></a>07158 <span class="comment"></span>
<a name="l07159"></a>07159 <span class="comment">   However, GDB&#39;s internal history variables ($1, $2, etc.) are</span>
<a name="l07160"></a>07160 <span class="comment">   struct value*s containing internal copies of the data that are not, in</span>
<a name="l07161"></a>07161 <span class="comment">   general, the same as the data at their corresponding addresses in</span>
<a name="l07162"></a>07162 <span class="comment">   the target.  Fortunately, the types we give to these values are all</span>
<a name="l07163"></a>07163 <span class="comment">   conventional, fixed-size types (as per the strategy described</span>
<a name="l07164"></a>07164 <span class="comment">   above), so that we don&#39;t usually have to perform the</span>
<a name="l07165"></a>07165 <span class="comment">   &#39;to_fixed_xxx_type&#39; conversions to look at their values.</span>
<a name="l07166"></a>07166 <span class="comment">   Unfortunately, there is one exception: if one of the internal</span>
<a name="l07167"></a>07167 <span class="comment">   history variables is an array whose elements are unconstrained</span>
<a name="l07168"></a>07168 <span class="comment">   records, then we will need to create distinct fixed types for each</span>
<a name="l07169"></a>07169 <span class="comment">   element selected.  */</span>
<a name="l07170"></a>07170 
<a name="l07171"></a>07171 <span class="comment">/* The upshot of all of this is that many routines take a (type, host</span>
<a name="l07172"></a>07172 <span class="comment">   address, target address) triple as arguments to represent a value.</span>
<a name="l07173"></a>07173 <span class="comment">   The host address, if non-null, is supposed to contain an internal</span>
<a name="l07174"></a>07174 <span class="comment">   copy of the relevant data; otherwise, the program is to consult the</span>
<a name="l07175"></a>07175 <span class="comment">   target at the target address.  */</span>
<a name="l07176"></a>07176 
<a name="l07177"></a>07177 <span class="comment">/* Assuming that VAL0 represents a pointer value, the result of</span>
<a name="l07178"></a>07178 <span class="comment">   dereferencing it.  Differs from value_ind in its treatment of</span>
<a name="l07179"></a>07179 <span class="comment">   dynamic-sized types.  */</span>
<a name="l07180"></a>07180 
<a name="l07181"></a>07181 <span class="keyword">struct </span>value *
<a name="l07182"></a><a class="code" href="ada-lang_8h.html#a8c73e42da2592f6819bce6da4ef416ce">07182</a> <a class="code" href="ada-lang_8c.html#a917a1ba2a6b58d43803a1f999164295b">ada_value_ind</a> (<span class="keyword">struct</span> value *val0)
<a name="l07183"></a>07183 {
<a name="l07184"></a>07184   <span class="keyword">struct </span>value *val = <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (val0);
<a name="l07185"></a>07185 
<a name="l07186"></a>07186   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#abbecc644387ffb0a43e57ed0462c2c8b">ada_is_tagged_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val), 0))
<a name="l07187"></a>07187     val = <a class="code" href="ada-lang_8c.html#a8194e4f9a4e73790e353cc869af2e34a">ada_tag_value_at_base_address</a> (val);
<a name="l07188"></a>07188 
<a name="l07189"></a>07189   <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#aff7bccfb43d0188dfaf758dffe8b58ce">ada_to_fixed_value</a> (val);
<a name="l07190"></a>07190 }
<a name="l07191"></a>07191 
<a name="l07192"></a>07192 <span class="comment">/* The value resulting from dereferencing any &quot;reference to&quot;</span>
<a name="l07193"></a>07193 <span class="comment">   qualifiers on VAL0.  */</span>
<a name="l07194"></a>07194 
<a name="l07195"></a>07195 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l07196"></a>07196 ada_coerce_ref (<span class="keyword">struct</span> value *val0)
<a name="l07197"></a>07197 {
<a name="l07198"></a>07198   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val0)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l07199"></a>07199     {
<a name="l07200"></a>07200       <span class="keyword">struct </span>value *val = val0;
<a name="l07201"></a>07201 
<a name="l07202"></a>07202       val = <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (val);
<a name="l07203"></a>07203 
<a name="l07204"></a>07204       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#abbecc644387ffb0a43e57ed0462c2c8b">ada_is_tagged_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val), 0))
<a name="l07205"></a>07205         val = <a class="code" href="ada-lang_8c.html#a8194e4f9a4e73790e353cc869af2e34a">ada_tag_value_at_base_address</a> (val);
<a name="l07206"></a>07206 
<a name="l07207"></a>07207       <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#aff7bccfb43d0188dfaf758dffe8b58ce">ada_to_fixed_value</a> (val);
<a name="l07208"></a>07208     }
<a name="l07209"></a>07209   <span class="keywordflow">else</span>
<a name="l07210"></a>07210     <span class="keywordflow">return</span> val0;
<a name="l07211"></a>07211 }
<a name="l07212"></a>07212 
<a name="l07213"></a>07213 <span class="comment">/* Return OFF rounded upward if necessary to a multiple of</span>
<a name="l07214"></a>07214 <span class="comment">   ALIGNMENT (a power of 2).  */</span>
<a name="l07215"></a>07215 
<a name="l07216"></a>07216 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l07217"></a>07217 align_value (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> off, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> alignment)
<a name="l07218"></a>07218 {
<a name="l07219"></a>07219   <span class="keywordflow">return</span> (off + alignment - 1) &amp; ~(alignment - 1);
<a name="l07220"></a>07220 }
<a name="l07221"></a>07221 
<a name="l07222"></a>07222 <span class="comment">/* Return the bit alignment required for field #F of template type TYPE.  */</span>
<a name="l07223"></a>07223 
<a name="l07224"></a>07224 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l07225"></a>07225 field_alignment (<span class="keyword">struct</span> type *type, <span class="keywordtype">int</span> f)
<a name="l07226"></a>07226 {
<a name="l07227"></a>07227   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, f);
<a name="l07228"></a>07228   <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l07229"></a>07229   <span class="keywordtype">int</span> align_offset;
<a name="l07230"></a>07230 
<a name="l07231"></a>07231   <span class="comment">/* The field name should never be null, unless the debugging information</span>
<a name="l07232"></a>07232 <span class="comment">     is somehow malformed.  In this case, we assume the field does not</span>
<a name="l07233"></a>07233 <span class="comment">     require any alignment.  */</span>
<a name="l07234"></a>07234   <span class="keywordflow">if</span> (name == NULL)
<a name="l07235"></a>07235     <span class="keywordflow">return</span> 1;
<a name="l07236"></a>07236 
<a name="l07237"></a>07237   len = strlen (name);
<a name="l07238"></a>07238 
<a name="l07239"></a>07239   <span class="keywordflow">if</span> (!isdigit (name[len - 1]))
<a name="l07240"></a>07240     <span class="keywordflow">return</span> 1;
<a name="l07241"></a>07241 
<a name="l07242"></a>07242   <span class="keywordflow">if</span> (isdigit (name[len - 2]))
<a name="l07243"></a>07243     align_offset = len - 2;
<a name="l07244"></a>07244   <span class="keywordflow">else</span>
<a name="l07245"></a>07245     align_offset = len - 1;
<a name="l07246"></a>07246 
<a name="l07247"></a>07247   <span class="keywordflow">if</span> (align_offset &lt; 7 || strncmp (<span class="stringliteral">&quot;___XV&quot;</span>, name + align_offset - 6, 5) != 0)
<a name="l07248"></a>07248     <span class="keywordflow">return</span> TARGET_CHAR_BIT;
<a name="l07249"></a>07249 
<a name="l07250"></a>07250   <span class="keywordflow">return</span> atoi (name + align_offset) * TARGET_CHAR_BIT;
<a name="l07251"></a>07251 }
<a name="l07252"></a>07252 
<a name="l07253"></a>07253 <span class="comment">/* Find a typedef or tag symbol named NAME.  Ignores ambiguity.  */</span>
<a name="l07254"></a>07254 
<a name="l07255"></a>07255 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *
<a name="l07256"></a>07256 ada_find_any_type_symbol (<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l07257"></a>07257 {
<a name="l07258"></a>07258   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l07259"></a>07259 
<a name="l07260"></a>07260   sym = standard_lookup (name, <a class="code" href="frame_8h.html#a91efbdcf182d840c28d378def97cfc23">get_selected_block</a> (NULL), <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>);
<a name="l07261"></a>07261   <span class="keywordflow">if</span> (sym != NULL &amp;&amp; <a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3ac0b2498d37ddd0f48d23739bba4abca4">LOC_TYPEDEF</a>)
<a name="l07262"></a>07262     <span class="keywordflow">return</span> sym;
<a name="l07263"></a>07263 
<a name="l07264"></a>07264   sym = standard_lookup (name, NULL, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa1f05a16e681efd2e892974878c353f11">STRUCT_DOMAIN</a>);
<a name="l07265"></a>07265   <span class="keywordflow">return</span> sym;
<a name="l07266"></a>07266 }
<a name="l07267"></a>07267 
<a name="l07268"></a>07268 <span class="comment">/* Find a type named NAME.  Ignores ambiguity.  This routine will look</span>
<a name="l07269"></a>07269 <span class="comment">   solely for types defined by debug info, it will not search the GDB</span>
<a name="l07270"></a>07270 <span class="comment">   primitive types.  */</span>
<a name="l07271"></a>07271 
<a name="l07272"></a>07272 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l07273"></a>07273 ada_find_any_type (<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l07274"></a>07274 {
<a name="l07275"></a>07275   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym = ada_find_any_type_symbol (name);
<a name="l07276"></a>07276 
<a name="l07277"></a>07277   <span class="keywordflow">if</span> (sym != NULL)
<a name="l07278"></a>07278     <span class="keywordflow">return</span> <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (sym);
<a name="l07279"></a>07279 
<a name="l07280"></a>07280   <span class="keywordflow">return</span> NULL;
<a name="l07281"></a>07281 }
<a name="l07282"></a>07282 
<a name="l07283"></a>07283 <span class="comment">/* Given NAME_SYM and an associated BLOCK, find a &quot;renaming&quot; symbol</span>
<a name="l07284"></a>07284 <span class="comment">   associated with NAME_SYM&#39;s name.  NAME_SYM may itself be a renaming</span>
<a name="l07285"></a>07285 <span class="comment">   symbol, in which case it is returned.  Otherwise, this looks for</span>
<a name="l07286"></a>07286 <span class="comment">   symbols whose name is that of NAME_SYM suffixed with  &quot;___XR&quot;.</span>
<a name="l07287"></a>07287 <span class="comment">   Return symbol if found, and NULL otherwise.  */</span>
<a name="l07288"></a>07288 
<a name="l07289"></a>07289 <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *
<a name="l07290"></a><a class="code" href="ada-lang_8h.html#a0d1969cf813f4b68d44fe1c9839bd864">07290</a> <a class="code" href="ada-lang_8c.html#a0d1969cf813f4b68d44fe1c9839bd864">ada_find_renaming_symbol</a> (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *name_sym, <span class="keyword">const</span> <span class="keyword">struct</span> block *block)
<a name="l07291"></a>07291 {
<a name="l07292"></a>07292   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (name_sym);
<a name="l07293"></a>07293   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l07294"></a>07294 
<a name="l07295"></a>07295   <span class="keywordflow">if</span> (<a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (name, <span class="stringliteral">&quot;___XR&quot;</span>) != NULL)
<a name="l07296"></a>07296      <span class="keywordflow">return</span> name_sym;
<a name="l07297"></a>07297 
<a name="l07298"></a>07298   sym = find_old_style_renaming_symbol (name, block);
<a name="l07299"></a>07299 
<a name="l07300"></a>07300   <span class="keywordflow">if</span> (sym != NULL)
<a name="l07301"></a>07301     <span class="keywordflow">return</span> sym;
<a name="l07302"></a>07302 
<a name="l07303"></a>07303   <span class="comment">/* Not right yet.  FIXME pnh 7/20/2007.  */</span>
<a name="l07304"></a>07304   sym = ada_find_any_type_symbol (name);
<a name="l07305"></a>07305   <span class="keywordflow">if</span> (sym != NULL &amp;&amp; <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (<a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym), <span class="stringliteral">&quot;___XR&quot;</span>) != NULL)
<a name="l07306"></a>07306     <span class="keywordflow">return</span> sym;
<a name="l07307"></a>07307   <span class="keywordflow">else</span>
<a name="l07308"></a>07308     <span class="keywordflow">return</span> NULL;
<a name="l07309"></a>07309 }
<a name="l07310"></a>07310 
<a name="l07311"></a>07311 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *
<a name="l07312"></a>07312 find_old_style_renaming_symbol (<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keyword">struct</span> block *block)
<a name="l07313"></a>07313 {
<a name="l07314"></a>07314   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *function_sym = <a class="code" href="block_8c.html#a79d1eee3f8ad664338ecfcccf6e5d2a0">block_linkage_function</a> (block);
<a name="l07315"></a>07315   <span class="keywordtype">char</span> *rename;
<a name="l07316"></a>07316 
<a name="l07317"></a>07317   <span class="keywordflow">if</span> (function_sym != NULL)
<a name="l07318"></a>07318     {
<a name="l07319"></a>07319       <span class="comment">/* If the symbol is defined inside a function, NAME is not fully</span>
<a name="l07320"></a>07320 <span class="comment">         qualified.  This means we need to prepend the function name</span>
<a name="l07321"></a>07321 <span class="comment">         as well as adding the ``___XR&#39;&#39; suffix to build the name of</span>
<a name="l07322"></a>07322 <span class="comment">         the associated renaming symbol.  */</span>
<a name="l07323"></a>07323       <span class="keyword">const</span> <span class="keywordtype">char</span> *function_name = <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (function_sym);
<a name="l07324"></a>07324       <span class="comment">/* Function names sometimes contain suffixes used</span>
<a name="l07325"></a>07325 <span class="comment">         for instance to qualify nested subprograms.  When building</span>
<a name="l07326"></a>07326 <span class="comment">         the XR type name, we need to make sure that this suffix is</span>
<a name="l07327"></a>07327 <span class="comment">         not included.  So do not include any suffix in the function</span>
<a name="l07328"></a>07328 <span class="comment">         name length below.  */</span>
<a name="l07329"></a>07329       <span class="keywordtype">int</span> function_name_len = <a class="code" href="ada-lang_8c.html#aa5624d1411eb736cbb8426496fadcf45">ada_name_prefix_len</a> (function_name);
<a name="l07330"></a>07330       <span class="keyword">const</span> <span class="keywordtype">int</span> rename_len = function_name_len + 2      <span class="comment">/*  &quot;__&quot; */</span>
<a name="l07331"></a>07331         + strlen (name) + 6 <span class="comment">/* &quot;___XR\0&quot; */</span> ;
<a name="l07332"></a>07332 
<a name="l07333"></a>07333       <span class="comment">/* Strip the suffix if necessary.  */</span>
<a name="l07334"></a>07334       ada_remove_trailing_digits (function_name, &amp;function_name_len);
<a name="l07335"></a>07335       ada_remove_po_subprogram_suffix (function_name, &amp;function_name_len);
<a name="l07336"></a>07336       ada_remove_Xbn_suffix (function_name, &amp;function_name_len);
<a name="l07337"></a>07337 
<a name="l07338"></a>07338       <span class="comment">/* Library-level functions are a special case, as GNAT adds</span>
<a name="l07339"></a>07339 <span class="comment">         a ``_ada_&#39;&#39; prefix to the function name to avoid namespace</span>
<a name="l07340"></a>07340 <span class="comment">         pollution.  However, the renaming symbols themselves do not</span>
<a name="l07341"></a>07341 <span class="comment">         have this prefix, so we need to skip this prefix if present.  */</span>
<a name="l07342"></a>07342       <span class="keywordflow">if</span> (function_name_len &gt; 5 <span class="comment">/* &quot;_ada_&quot; */</span>
<a name="l07343"></a>07343           &amp;&amp; <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (function_name, <span class="stringliteral">&quot;_ada_&quot;</span>) == function_name)
<a name="l07344"></a>07344         {
<a name="l07345"></a>07345           function_name += 5;
<a name="l07346"></a>07346           function_name_len -= 5;
<a name="l07347"></a>07347         }
<a name="l07348"></a>07348 
<a name="l07349"></a>07349       rename = (<span class="keywordtype">char</span> *) alloca (rename_len * <span class="keyword">sizeof</span> (<span class="keywordtype">char</span>));
<a name="l07350"></a>07350       strncpy (rename, function_name, function_name_len);
<a name="l07351"></a>07351       <a class="code" href="common-utils_8c.html#ad9940337ec98983dae9951c947879fc8">xsnprintf</a> (rename + function_name_len, rename_len - function_name_len,
<a name="l07352"></a>07352                  <span class="stringliteral">&quot;__%s___XR&quot;</span>, name);
<a name="l07353"></a>07353     }
<a name="l07354"></a>07354   <span class="keywordflow">else</span>
<a name="l07355"></a>07355     {
<a name="l07356"></a>07356       <span class="keyword">const</span> <span class="keywordtype">int</span> rename_len = strlen (name) + 6;
<a name="l07357"></a>07357 
<a name="l07358"></a>07358       rename = (<span class="keywordtype">char</span> *) alloca (rename_len * <span class="keyword">sizeof</span> (<span class="keywordtype">char</span>));
<a name="l07359"></a>07359       <a class="code" href="common-utils_8c.html#ad9940337ec98983dae9951c947879fc8">xsnprintf</a> (rename, rename_len * <span class="keyword">sizeof</span> (<span class="keywordtype">char</span>), <span class="stringliteral">&quot;%s___XR&quot;</span>, name);
<a name="l07360"></a>07360     }
<a name="l07361"></a>07361 
<a name="l07362"></a>07362   <span class="keywordflow">return</span> ada_find_any_type_symbol (rename);
<a name="l07363"></a>07363 }
<a name="l07364"></a>07364 
<a name="l07365"></a>07365 <span class="comment">/* Because of GNAT encoding conventions, several GDB symbols may match a</span>
<a name="l07366"></a>07366 <span class="comment">   given type name.  If the type denoted by TYPE0 is to be preferred to</span>
<a name="l07367"></a>07367 <span class="comment">   that of TYPE1 for purposes of type printing, return non-zero;</span>
<a name="l07368"></a>07368 <span class="comment">   otherwise return 0.  */</span>
<a name="l07369"></a>07369 
<a name="l07370"></a>07370 <span class="keywordtype">int</span>
<a name="l07371"></a><a class="code" href="ada-lang_8h.html#ac5669fb56af5c24b929fd5ffbc794cee">07371</a> <a class="code" href="ada-lang_8c.html#a19d8ab2a6d411d95e82216974b2b0d5f">ada_prefer_type</a> (<span class="keyword">struct</span> type *type0, <span class="keyword">struct</span> type *type1)
<a name="l07372"></a>07372 {
<a name="l07373"></a>07373   <span class="keywordflow">if</span> (type1 == NULL)
<a name="l07374"></a>07374     <span class="keywordflow">return</span> 1;
<a name="l07375"></a>07375   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type0 == NULL)
<a name="l07376"></a>07376     <span class="keywordflow">return</span> 0;
<a name="l07377"></a>07377   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type1) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>)
<a name="l07378"></a>07378     <span class="keywordflow">return</span> 1;
<a name="l07379"></a>07379   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type0) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>)
<a name="l07380"></a>07380     <span class="keywordflow">return</span> 0;
<a name="l07381"></a>07381   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type1) == NULL &amp;&amp; <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type0) != NULL)
<a name="l07382"></a>07382     <span class="keywordflow">return</span> 1;
<a name="l07383"></a>07383   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (type0))
<a name="l07384"></a>07384     <span class="keywordflow">return</span> 1;
<a name="l07385"></a>07385   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (type0)
<a name="l07386"></a>07386            &amp;&amp; !<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (type1))
<a name="l07387"></a>07387     <span class="keywordflow">return</span> 1;
<a name="l07388"></a>07388   <span class="keywordflow">else</span>
<a name="l07389"></a>07389     {
<a name="l07390"></a>07390       <span class="keyword">const</span> <span class="keywordtype">char</span> *type0_name = <a class="code" href="gdbtypes_8c.html#a1bce8398d8a46f3d37bfc7e618ab9e9d">type_name_no_tag</a> (type0);
<a name="l07391"></a>07391       <span class="keyword">const</span> <span class="keywordtype">char</span> *type1_name = <a class="code" href="gdbtypes_8c.html#a1bce8398d8a46f3d37bfc7e618ab9e9d">type_name_no_tag</a> (type1);
<a name="l07392"></a>07392 
<a name="l07393"></a>07393       <span class="keywordflow">if</span> (type0_name != NULL &amp;&amp; <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (type0_name, <span class="stringliteral">&quot;___XR&quot;</span>) != NULL
<a name="l07394"></a>07394           &amp;&amp; (type1_name == NULL || <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (type1_name, <span class="stringliteral">&quot;___XR&quot;</span>) == NULL))
<a name="l07395"></a>07395         <span class="keywordflow">return</span> 1;
<a name="l07396"></a>07396     }
<a name="l07397"></a>07397   <span class="keywordflow">return</span> 0;
<a name="l07398"></a>07398 }
<a name="l07399"></a>07399 
<a name="l07400"></a>07400 <span class="comment">/* The name of TYPE, which is either its TYPE_NAME, or, if that is</span>
<a name="l07401"></a>07401 <span class="comment">   null, its TYPE_TAG_NAME.  Null if TYPE is null.  */</span>
<a name="l07402"></a>07402 
<a name="l07403"></a>07403 <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l07404"></a><a class="code" href="ada-lang_8h.html#a9d064a477a5b695391a39492c01c5685">07404</a> <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (<span class="keyword">struct</span> type *type)
<a name="l07405"></a>07405 {
<a name="l07406"></a>07406   <span class="keywordflow">if</span> (type == NULL)
<a name="l07407"></a>07407     <span class="keywordflow">return</span> NULL;
<a name="l07408"></a>07408   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) != NULL)
<a name="l07409"></a>07409     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type);
<a name="l07410"></a>07410   <span class="keywordflow">else</span>
<a name="l07411"></a>07411     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type);
<a name="l07412"></a>07412 }
<a name="l07413"></a>07413 
<a name="l07414"></a>07414 <span class="comment">/* Search the list of &quot;descriptive&quot; types associated to TYPE for a type</span>
<a name="l07415"></a>07415 <span class="comment">   whose name is NAME.  */</span>
<a name="l07416"></a>07416 
<a name="l07417"></a>07417 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l07418"></a>07418 find_parallel_type_by_descriptive_type (<span class="keyword">struct</span> type *type, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l07419"></a>07419 {
<a name="l07420"></a>07420   <span class="keyword">struct </span>type *result;
<a name="l07421"></a>07421 
<a name="l07422"></a>07422   <span class="comment">/* If there no descriptive-type info, then there is no parallel type</span>
<a name="l07423"></a>07423 <span class="comment">     to be found.  */</span>
<a name="l07424"></a>07424   <span class="keywordflow">if</span> (!<a class="code" href="gdbtypes_8h.html#ae599879d692c6b43f60ff21df29a89c2">HAVE_GNAT_AUX_INFO</a> (type))
<a name="l07425"></a>07425     <span class="keywordflow">return</span> NULL;
<a name="l07426"></a>07426 
<a name="l07427"></a>07427   result = <a class="code" href="gdbtypes_8h.html#a13051c2080a5b87f05b73a931f0eee3a">TYPE_DESCRIPTIVE_TYPE</a> (type);
<a name="l07428"></a>07428   <span class="keywordflow">while</span> (result != NULL)
<a name="l07429"></a>07429     {
<a name="l07430"></a>07430       <span class="keyword">const</span> <span class="keywordtype">char</span> *result_name = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (result);
<a name="l07431"></a>07431 
<a name="l07432"></a>07432       <span class="keywordflow">if</span> (result_name == NULL)
<a name="l07433"></a>07433         {
<a name="l07434"></a>07434           <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unexpected null name on descriptive type&quot;</span>));
<a name="l07435"></a>07435           <span class="keywordflow">return</span> NULL;
<a name="l07436"></a>07436         }
<a name="l07437"></a>07437 
<a name="l07438"></a>07438       <span class="comment">/* If the names match, stop.  */</span>
<a name="l07439"></a>07439       <span class="keywordflow">if</span> (strcmp (result_name, name) == 0)
<a name="l07440"></a>07440         <span class="keywordflow">break</span>;
<a name="l07441"></a>07441 
<a name="l07442"></a>07442       <span class="comment">/* Otherwise, look at the next item on the list, if any.  */</span>
<a name="l07443"></a>07443       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#ae599879d692c6b43f60ff21df29a89c2">HAVE_GNAT_AUX_INFO</a> (result))
<a name="l07444"></a>07444         result = <a class="code" href="gdbtypes_8h.html#a13051c2080a5b87f05b73a931f0eee3a">TYPE_DESCRIPTIVE_TYPE</a> (result);
<a name="l07445"></a>07445       <span class="keywordflow">else</span>
<a name="l07446"></a>07446         result = NULL;
<a name="l07447"></a>07447     }
<a name="l07448"></a>07448 
<a name="l07449"></a>07449   <span class="comment">/* If we didn&#39;t find a match, see whether this is a packed array.  With</span>
<a name="l07450"></a>07450 <span class="comment">     older compilers, the descriptive type information is either absent or</span>
<a name="l07451"></a>07451 <span class="comment">     irrelevant when it comes to packed arrays so the above lookup fails.</span>
<a name="l07452"></a>07452 <span class="comment">     Fall back to using a parallel lookup by name in this case.  */</span>
<a name="l07453"></a>07453   <span class="keywordflow">if</span> (result == NULL &amp;&amp; <a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (type))
<a name="l07454"></a>07454     <span class="keywordflow">return</span> ada_find_any_type (name);
<a name="l07455"></a>07455 
<a name="l07456"></a>07456   <span class="keywordflow">return</span> result;
<a name="l07457"></a>07457 }
<a name="l07458"></a>07458 
<a name="l07459"></a>07459 <span class="comment">/* Find a parallel type to TYPE with the specified NAME, using the</span>
<a name="l07460"></a>07460 <span class="comment">   descriptive type taken from the debugging information, if available,</span>
<a name="l07461"></a>07461 <span class="comment">   and otherwise using the (slower) name-based method.  */</span>
<a name="l07462"></a>07462 
<a name="l07463"></a>07463 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l07464"></a>07464 ada_find_parallel_type_with_name (<span class="keyword">struct</span> type *type, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l07465"></a>07465 {
<a name="l07466"></a>07466   <span class="keyword">struct </span>type *result = NULL;
<a name="l07467"></a>07467 
<a name="l07468"></a>07468   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#ae599879d692c6b43f60ff21df29a89c2">HAVE_GNAT_AUX_INFO</a> (type))
<a name="l07469"></a>07469     result = find_parallel_type_by_descriptive_type (type, name);
<a name="l07470"></a>07470   <span class="keywordflow">else</span>
<a name="l07471"></a>07471     result = ada_find_any_type (name);
<a name="l07472"></a>07472 
<a name="l07473"></a>07473   <span class="keywordflow">return</span> result;
<a name="l07474"></a>07474 }
<a name="l07475"></a>07475 
<a name="l07476"></a>07476 <span class="comment">/* Same as above, but specify the name of the parallel type by appending</span>
<a name="l07477"></a>07477 <span class="comment">   SUFFIX to the name of TYPE.  */</span>
<a name="l07478"></a>07478 
<a name="l07479"></a>07479 <span class="keyword">struct </span>type *
<a name="l07480"></a><a class="code" href="ada-lang_8h.html#a0a6d8ca47bf10214fa08bb35dbe298fe">07480</a> <a class="code" href="ada-lang_8c.html#ade263e735047904b7eabe725cd6cc2f9">ada_find_parallel_type</a> (<span class="keyword">struct</span> type *type, <span class="keyword">const</span> <span class="keywordtype">char</span> *suffix)
<a name="l07481"></a>07481 {
<a name="l07482"></a>07482   <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l07483"></a>07483   <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">typename</span> = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type);
<a name="l07484"></a>07484   <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l07485"></a>07485 
<a name="l07486"></a>07486   <span class="keywordflow">if</span> (<span class="keyword">typename</span> == NULL)
<a name="l07487"></a>07487     <span class="keywordflow">return</span> NULL;
<a name="l07488"></a>07488 
<a name="l07489"></a>07489   len = strlen (<span class="keyword">typename</span>);
<a name="l07490"></a>07490 
<a name="l07491"></a>07491   name = (<span class="keywordtype">char</span> *) alloca (len + strlen (suffix) + 1);
<a name="l07492"></a>07492 
<a name="l07493"></a>07493   strcpy (name, <span class="keyword">typename</span>);
<a name="l07494"></a>07494   strcpy (name + len, suffix);
<a name="l07495"></a>07495 
<a name="l07496"></a>07496   <span class="keywordflow">return</span> ada_find_parallel_type_with_name (type, name);
<a name="l07497"></a>07497 }
<a name="l07498"></a>07498 
<a name="l07499"></a>07499 <span class="comment">/* If TYPE is a variable-size record type, return the corresponding template</span>
<a name="l07500"></a>07500 <span class="comment">   type describing its fields.  Otherwise, return NULL.  */</span>
<a name="l07501"></a>07501 
<a name="l07502"></a>07502 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l07503"></a>07503 dynamic_template_type (<span class="keyword">struct</span> type *type)
<a name="l07504"></a>07504 {
<a name="l07505"></a>07505   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l07506"></a>07506 
<a name="l07507"></a>07507   <span class="keywordflow">if</span> (type == NULL || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l07508"></a>07508       || <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type) == NULL)
<a name="l07509"></a>07509     <span class="keywordflow">return</span> NULL;
<a name="l07510"></a>07510   <span class="keywordflow">else</span>
<a name="l07511"></a>07511     {
<a name="l07512"></a>07512       <span class="keywordtype">int</span> len = strlen (<a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type));
<a name="l07513"></a>07513 
<a name="l07514"></a>07514       <span class="keywordflow">if</span> (len &gt; 6 &amp;&amp; strcmp (<a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type) + len - 6, <span class="stringliteral">&quot;___XVE&quot;</span>) == 0)
<a name="l07515"></a>07515         <span class="keywordflow">return</span> type;
<a name="l07516"></a>07516       <span class="keywordflow">else</span>
<a name="l07517"></a>07517         <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#ade263e735047904b7eabe725cd6cc2f9">ada_find_parallel_type</a> (type, <span class="stringliteral">&quot;___XVE&quot;</span>);
<a name="l07518"></a>07518     }
<a name="l07519"></a>07519 }
<a name="l07520"></a>07520 
<a name="l07521"></a>07521 <span class="comment">/* Assuming that TEMPL_TYPE is a union or struct type, returns</span>
<a name="l07522"></a>07522 <span class="comment">   non-zero iff field FIELD_NUM of TEMPL_TYPE has dynamic size.  */</span>
<a name="l07523"></a>07523 
<a name="l07524"></a>07524 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l07525"></a>07525 is_dynamic_field (<span class="keyword">struct</span> type *templ_type, <span class="keywordtype">int</span> field_num)
<a name="l07526"></a>07526 {
<a name="l07527"></a>07527   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (templ_type, field_num);
<a name="l07528"></a>07528 
<a name="l07529"></a>07529   <span class="keywordflow">return</span> name != NULL
<a name="l07530"></a>07530     &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (templ_type, field_num)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l07531"></a>07531     &amp;&amp; <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (name, <span class="stringliteral">&quot;___XVL&quot;</span>) != NULL;
<a name="l07532"></a>07532 }
<a name="l07533"></a>07533 
<a name="l07534"></a>07534 <span class="comment">/* The index of the variant field of TYPE, or -1 if TYPE does not</span>
<a name="l07535"></a>07535 <span class="comment">   represent a variant record type.  */</span>
<a name="l07536"></a>07536 
<a name="l07537"></a>07537 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l07538"></a>07538 variant_field_index (<span class="keyword">struct</span> type *type)
<a name="l07539"></a>07539 {
<a name="l07540"></a>07540   <span class="keywordtype">int</span> f;
<a name="l07541"></a>07541 
<a name="l07542"></a>07542   <span class="keywordflow">if</span> (type == NULL || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>)
<a name="l07543"></a>07543     <span class="keywordflow">return</span> -1;
<a name="l07544"></a>07544 
<a name="l07545"></a>07545   <span class="keywordflow">for</span> (f = 0; f &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type); f += 1)
<a name="l07546"></a>07546     {
<a name="l07547"></a>07547       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a370ccbe192d73c5795afa034113a4ffb">ada_is_variant_part</a> (type, f))
<a name="l07548"></a>07548         <span class="keywordflow">return</span> f;
<a name="l07549"></a>07549     }
<a name="l07550"></a>07550   <span class="keywordflow">return</span> -1;
<a name="l07551"></a>07551 }
<a name="l07552"></a>07552 
<a name="l07553"></a>07553 <span class="comment">/* A record type with no fields.  */</span>
<a name="l07554"></a>07554 
<a name="l07555"></a>07555 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l07556"></a>07556 empty_record (<span class="keyword">struct</span> type *<span class="keyword">template</span>)
<a name="l07557"></a>07557 {
<a name="l07558"></a>07558   <span class="keyword">struct </span>type *type = <a class="code" href="gdbtypes_8c.html#a2e8f72ee412f83ecd89f47068fda9634">alloc_type_copy</a> (<span class="keyword">template</span>);
<a name="l07559"></a>07559 
<a name="l07560"></a>07560   <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>;
<a name="l07561"></a>07561   <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) = 0;
<a name="l07562"></a>07562   <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (type) = NULL;
<a name="l07563"></a>07563   <a class="code" href="gdbtypes_8h.html#abce922c83265a58f62b491513b7a5aea">INIT_CPLUS_SPECIFIC</a> (type);
<a name="l07564"></a>07564   <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) = <span class="stringliteral">&quot;&lt;empty&gt;&quot;</span>;
<a name="l07565"></a>07565   <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) = NULL;
<a name="l07566"></a>07566   <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = 0;
<a name="l07567"></a>07567   <span class="keywordflow">return</span> type;
<a name="l07568"></a>07568 }
<a name="l07569"></a>07569 
<a name="l07570"></a>07570 <span class="comment">/* An ordinary record type (with fixed-length fields) that describes</span>
<a name="l07571"></a>07571 <span class="comment">   the value of type TYPE at VALADDR or ADDRESS (see comments at</span>
<a name="l07572"></a>07572 <span class="comment">   the beginning of this section) VAL according to GNAT conventions.</span>
<a name="l07573"></a>07573 <span class="comment">   DVAL0 should describe the (portion of a) record that contains any</span>
<a name="l07574"></a>07574 <span class="comment">   necessary discriminants.  It should be NULL if value_type (VAL) is</span>
<a name="l07575"></a>07575 <span class="comment">   an outer-level type (i.e., as opposed to a branch of a variant.)  A</span>
<a name="l07576"></a>07576 <span class="comment">   variant field (unless unchecked) is replaced by a particular branch</span>
<a name="l07577"></a>07577 <span class="comment">   of the variant.</span>
<a name="l07578"></a>07578 <span class="comment"></span>
<a name="l07579"></a>07579 <span class="comment">   If not KEEP_DYNAMIC_FIELDS, then all fields whose position or</span>
<a name="l07580"></a>07580 <span class="comment">   length are not statically known are discarded.  As a consequence,</span>
<a name="l07581"></a>07581 <span class="comment">   VALADDR, ADDRESS and DVAL0 are ignored.</span>
<a name="l07582"></a>07582 <span class="comment"></span>
<a name="l07583"></a>07583 <span class="comment">   NOTE: Limitations: For now, we assume that dynamic fields and</span>
<a name="l07584"></a>07584 <span class="comment">   variants occupy whole numbers of bytes.  However, they need not be</span>
<a name="l07585"></a>07585 <span class="comment">   byte-aligned.  */</span>
<a name="l07586"></a>07586 
<a name="l07587"></a>07587 <span class="keyword">struct </span>type *
<a name="l07588"></a><a class="code" href="ada-lang_8h.html#a9c1702a87eec4475d858de14e61b0c5e">07588</a> <a class="code" href="ada-lang_8c.html#a9c1702a87eec4475d858de14e61b0c5e">ada_template_to_fixed_record_type_1</a> (<span class="keyword">struct</span> type *type,
<a name="l07589"></a>07589                                      <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valaddr,
<a name="l07590"></a>07590                                      <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address, <span class="keyword">struct</span> value *dval0,
<a name="l07591"></a>07591                                      <span class="keywordtype">int</span> keep_dynamic_fields)
<a name="l07592"></a>07592 {
<a name="l07593"></a>07593   <span class="keyword">struct </span>value *mark = <a class="code" href="value_8c.html#a427a12b0dd4d5663b103d29f07a0e1c6">value_mark</a> ();
<a name="l07594"></a>07594   <span class="keyword">struct </span>value *dval;
<a name="l07595"></a>07595   <span class="keyword">struct </span>type *rtype;
<a name="l07596"></a>07596   <span class="keywordtype">int</span> nfields, bit_len;
<a name="l07597"></a>07597   <span class="keywordtype">int</span> variant_field;
<a name="l07598"></a>07598   <span class="keywordtype">long</span> off;
<a name="l07599"></a>07599   <span class="keywordtype">int</span> fld_bit_len;
<a name="l07600"></a>07600   <span class="keywordtype">int</span> f;
<a name="l07601"></a>07601 
<a name="l07602"></a>07602   <span class="comment">/* Compute the number of fields in this record type that are going</span>
<a name="l07603"></a>07603 <span class="comment">     to be processed: unless keep_dynamic_fields, this includes only</span>
<a name="l07604"></a>07604 <span class="comment">     fields whose position and length are static will be processed.  */</span>
<a name="l07605"></a>07605   <span class="keywordflow">if</span> (keep_dynamic_fields)
<a name="l07606"></a>07606     nfields = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type);
<a name="l07607"></a>07607   <span class="keywordflow">else</span>
<a name="l07608"></a>07608     {
<a name="l07609"></a>07609       nfields = 0;
<a name="l07610"></a>07610       <span class="keywordflow">while</span> (nfields &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type)
<a name="l07611"></a>07611              &amp;&amp; !<a class="code" href="ada-lang_8c.html#a370ccbe192d73c5795afa034113a4ffb">ada_is_variant_part</a> (type, nfields)
<a name="l07612"></a>07612              &amp;&amp; !is_dynamic_field (type, nfields))
<a name="l07613"></a>07613         nfields++;
<a name="l07614"></a>07614     }
<a name="l07615"></a>07615 
<a name="l07616"></a>07616   rtype = <a class="code" href="gdbtypes_8c.html#a2e8f72ee412f83ecd89f47068fda9634">alloc_type_copy</a> (type);
<a name="l07617"></a>07617   <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (rtype) = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>;
<a name="l07618"></a>07618   <a class="code" href="gdbtypes_8h.html#abce922c83265a58f62b491513b7a5aea">INIT_CPLUS_SPECIFIC</a> (rtype);
<a name="l07619"></a>07619   <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (rtype) = nfields;
<a name="l07620"></a>07620   <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (rtype) = (<span class="keyword">struct </span>field *)
<a name="l07621"></a>07621     <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (rtype, nfields * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> field));
<a name="l07622"></a>07622   <a class="code" href="gdb__string_8h.html#adb03df3679ce1445e801310614624ccb">memset</a> (<a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (rtype), 0, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> field) * nfields);
<a name="l07623"></a>07623   <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (rtype) = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type);
<a name="l07624"></a>07624   <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (rtype) = NULL;
<a name="l07625"></a>07625   <a class="code" href="gdbtypes_8h.html#a82cbfd363fdf782853ce90946f81c355">TYPE_FIXED_INSTANCE</a> (rtype) = 1;
<a name="l07626"></a>07626 
<a name="l07627"></a>07627   off = 0;
<a name="l07628"></a>07628   bit_len = 0;
<a name="l07629"></a>07629   variant_field = -1;
<a name="l07630"></a>07630 
<a name="l07631"></a>07631   <span class="keywordflow">for</span> (f = 0; f &lt; nfields; f += 1)
<a name="l07632"></a>07632     {
<a name="l07633"></a>07633       off = align_value (off, field_alignment (type, f))
<a name="l07634"></a>07634         + <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (type, f);
<a name="l07635"></a>07635       <a class="code" href="gdbtypes_8h.html#a3b785c6047f2bce21ac78987ab5a4b48">SET_FIELD_BITPOS</a> (<a class="code" href="gdbtypes_8h.html#a8beaef20f443a0d98c7b445bbcfcf031">TYPE_FIELD</a> (rtype, f), off);
<a name="l07636"></a>07636       <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (rtype, f) = 0;
<a name="l07637"></a>07637 
<a name="l07638"></a>07638       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a370ccbe192d73c5795afa034113a4ffb">ada_is_variant_part</a> (type, f))
<a name="l07639"></a>07639         {
<a name="l07640"></a>07640           variant_field = f;
<a name="l07641"></a>07641           fld_bit_len = 0;
<a name="l07642"></a>07642         }
<a name="l07643"></a>07643       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_dynamic_field (type, f))
<a name="l07644"></a>07644         {
<a name="l07645"></a>07645           <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *field_valaddr = valaddr;
<a name="l07646"></a>07646           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> field_address = address;
<a name="l07647"></a>07647           <span class="keyword">struct </span>type *field_type =
<a name="l07648"></a>07648             <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, f));
<a name="l07649"></a>07649 
<a name="l07650"></a>07650           <span class="keywordflow">if</span> (dval0 == NULL)
<a name="l07651"></a>07651             {
<a name="l07652"></a>07652               <span class="comment">/* rtype&#39;s length is computed based on the run-time</span>
<a name="l07653"></a>07653 <span class="comment">                 value of discriminants.  If the discriminants are not</span>
<a name="l07654"></a>07654 <span class="comment">                 initialized, the type size may be completely bogus and</span>
<a name="l07655"></a>07655 <span class="comment">                 GDB may fail to allocate a value for it.  So check the</span>
<a name="l07656"></a>07656 <span class="comment">                 size first before creating the value.  */</span>
<a name="l07657"></a>07657               check_size (rtype);
<a name="l07658"></a>07658               dval = <a class="code" href="value_8c.html#ab189fd2d8ea1fe71f000581289a20e17">value_from_contents_and_address</a> (rtype, valaddr, address);
<a name="l07659"></a>07659             }
<a name="l07660"></a>07660           <span class="keywordflow">else</span>
<a name="l07661"></a>07661             dval = dval0;
<a name="l07662"></a>07662 
<a name="l07663"></a>07663           <span class="comment">/* If the type referenced by this field is an aligner type, we need</span>
<a name="l07664"></a>07664 <span class="comment">             to unwrap that aligner type, because its size might not be set.</span>
<a name="l07665"></a>07665 <span class="comment">             Keeping the aligner type would cause us to compute the wrong</span>
<a name="l07666"></a>07666 <span class="comment">             size for this field, impacting the offset of the all the fields</span>
<a name="l07667"></a>07667 <span class="comment">             that follow this one.  */</span>
<a name="l07668"></a>07668           <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ac972c52cf860cdffae561d774c2f3258">ada_is_aligner_type</a> (field_type))
<a name="l07669"></a>07669             {
<a name="l07670"></a>07670               <span class="keywordtype">long</span> field_offset = <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (field_type, f);
<a name="l07671"></a>07671 
<a name="l07672"></a>07672               field_valaddr = cond_offset_host (field_valaddr, field_offset);
<a name="l07673"></a>07673               field_address = cond_offset_target (field_address, field_offset);
<a name="l07674"></a>07674               field_type = <a class="code" href="ada-lang_8c.html#a67d9e8121909114afa44a208819f932f">ada_aligned_type</a> (field_type);
<a name="l07675"></a>07675             }
<a name="l07676"></a>07676 
<a name="l07677"></a>07677           field_valaddr = cond_offset_host (field_valaddr,
<a name="l07678"></a>07678                                             off / TARGET_CHAR_BIT);
<a name="l07679"></a>07679           field_address = cond_offset_target (field_address,
<a name="l07680"></a>07680                                               off / TARGET_CHAR_BIT);
<a name="l07681"></a>07681 
<a name="l07682"></a>07682           <span class="comment">/* Get the fixed type of the field.  Note that, in this case,</span>
<a name="l07683"></a>07683 <span class="comment">             we do not want to get the real type out of the tag: if</span>
<a name="l07684"></a>07684 <span class="comment">             the current field is the parent part of a tagged record,</span>
<a name="l07685"></a>07685 <span class="comment">             we will get the tag of the object.  Clearly wrong: the real</span>
<a name="l07686"></a>07686 <span class="comment">             type of the parent is not the real type of the child.  We</span>
<a name="l07687"></a>07687 <span class="comment">             would end up in an infinite loop.  */</span>
<a name="l07688"></a>07688           field_type = <a class="code" href="ada-lang_8c.html#aac42a4c75acced2b75b65874ef51ead8">ada_get_base_type</a> (field_type);
<a name="l07689"></a>07689           field_type = <a class="code" href="ada-lang_8c.html#a0096e64d1590f0b629f4a8ca484bddbd">ada_to_fixed_type</a> (field_type, field_valaddr,
<a name="l07690"></a>07690                                           field_address, dval, 0);
<a name="l07691"></a>07691           <span class="comment">/* If the field size is already larger than the maximum</span>
<a name="l07692"></a>07692 <span class="comment">             object size, then the record itself will necessarily</span>
<a name="l07693"></a>07693 <span class="comment">             be larger than the maximum object size.  We need to make</span>
<a name="l07694"></a>07694 <span class="comment">             this check now, because the size might be so ridiculously</span>
<a name="l07695"></a>07695 <span class="comment">             large (due to an uninitialized variable in the inferior)</span>
<a name="l07696"></a>07696 <span class="comment">             that it would cause an overflow when adding it to the</span>
<a name="l07697"></a>07697 <span class="comment">             record size.  */</span>
<a name="l07698"></a>07698           check_size (field_type);
<a name="l07699"></a>07699 
<a name="l07700"></a>07700           <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (rtype, f) = field_type;
<a name="l07701"></a>07701           <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (rtype, f) = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, f);
<a name="l07702"></a>07702           <span class="comment">/* The multiplication can potentially overflow.  But because</span>
<a name="l07703"></a>07703 <span class="comment">             the field length has been size-checked just above, and</span>
<a name="l07704"></a>07704 <span class="comment">             assuming that the maximum size is a reasonable value,</span>
<a name="l07705"></a>07705 <span class="comment">             an overflow should not happen in practice.  So rather than</span>
<a name="l07706"></a>07706 <span class="comment">             adding overflow recovery code to this already complex code,</span>
<a name="l07707"></a>07707 <span class="comment">             we just assume that it&#39;s not going to happen.  */</span>
<a name="l07708"></a>07708           fld_bit_len =
<a name="l07709"></a>07709             <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (rtype, f)) * TARGET_CHAR_BIT;
<a name="l07710"></a>07710         }
<a name="l07711"></a>07711       <span class="keywordflow">else</span>
<a name="l07712"></a>07712         {
<a name="l07713"></a>07713           <span class="comment">/* Note: If this field&#39;s type is a typedef, it is important</span>
<a name="l07714"></a>07714 <span class="comment">             to preserve the typedef layer.</span>
<a name="l07715"></a>07715 <span class="comment"></span>
<a name="l07716"></a>07716 <span class="comment">             Otherwise, we might be transforming a typedef to a fat</span>
<a name="l07717"></a>07717 <span class="comment">             pointer (encoding a pointer to an unconstrained array),</span>
<a name="l07718"></a>07718 <span class="comment">             into a basic fat pointer (encoding an unconstrained</span>
<a name="l07719"></a>07719 <span class="comment">             array).  As both types are implemented using the same</span>
<a name="l07720"></a>07720 <span class="comment">             structure, the typedef is the only clue which allows us</span>
<a name="l07721"></a>07721 <span class="comment">             to distinguish between the two options.  Stripping it</span>
<a name="l07722"></a>07722 <span class="comment">             would prevent us from printing this field appropriately.  */</span>
<a name="l07723"></a>07723           <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (rtype, f) = <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, f);
<a name="l07724"></a>07724           <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (rtype, f) = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, f);
<a name="l07725"></a>07725           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (type, f) &gt; 0)
<a name="l07726"></a>07726             fld_bit_len =
<a name="l07727"></a>07727               <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (rtype, f) = <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (type, f);
<a name="l07728"></a>07728           <span class="keywordflow">else</span>
<a name="l07729"></a>07729             {
<a name="l07730"></a>07730               <span class="keyword">struct </span>type *field_type = <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, f);
<a name="l07731"></a>07731 
<a name="l07732"></a>07732               <span class="comment">/* We need to be careful of typedefs when computing</span>
<a name="l07733"></a>07733 <span class="comment">                 the length of our field.  If this is a typedef,</span>
<a name="l07734"></a>07734 <span class="comment">                 get the length of the target type, not the length</span>
<a name="l07735"></a>07735 <span class="comment">                 of the typedef.  */</span>
<a name="l07736"></a>07736               <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (field_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>)
<a name="l07737"></a>07737                 field_type = ada_typedef_target_type (field_type);
<a name="l07738"></a>07738 
<a name="l07739"></a>07739               fld_bit_len =
<a name="l07740"></a>07740                 <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (field_type)) * TARGET_CHAR_BIT;
<a name="l07741"></a>07741             }
<a name="l07742"></a>07742         }
<a name="l07743"></a>07743       <span class="keywordflow">if</span> (off + fld_bit_len &gt; bit_len)
<a name="l07744"></a>07744         bit_len = off + fld_bit_len;
<a name="l07745"></a>07745       off += fld_bit_len;
<a name="l07746"></a>07746       <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (rtype) =
<a name="l07747"></a>07747         align_value (bit_len, TARGET_CHAR_BIT) / TARGET_CHAR_BIT;
<a name="l07748"></a>07748     }
<a name="l07749"></a>07749 
<a name="l07750"></a>07750   <span class="comment">/* We handle the variant part, if any, at the end because of certain</span>
<a name="l07751"></a>07751 <span class="comment">     odd cases in which it is re-ordered so as NOT to be the last field of</span>
<a name="l07752"></a>07752 <span class="comment">     the record.  This can happen in the presence of representation</span>
<a name="l07753"></a>07753 <span class="comment">     clauses.  */</span>
<a name="l07754"></a>07754   <span class="keywordflow">if</span> (variant_field &gt;= 0)
<a name="l07755"></a>07755     {
<a name="l07756"></a>07756       <span class="keyword">struct </span>type *branch_type;
<a name="l07757"></a>07757 
<a name="l07758"></a>07758       off = <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (rtype, variant_field);
<a name="l07759"></a>07759 
<a name="l07760"></a>07760       <span class="keywordflow">if</span> (dval0 == NULL)
<a name="l07761"></a>07761         dval = <a class="code" href="value_8c.html#ab189fd2d8ea1fe71f000581289a20e17">value_from_contents_and_address</a> (rtype, valaddr, address);
<a name="l07762"></a>07762       <span class="keywordflow">else</span>
<a name="l07763"></a>07763         dval = dval0;
<a name="l07764"></a>07764 
<a name="l07765"></a>07765       branch_type =
<a name="l07766"></a>07766         to_fixed_variant_branch_type
<a name="l07767"></a>07767         (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, variant_field),
<a name="l07768"></a>07768          cond_offset_host (valaddr, off / TARGET_CHAR_BIT),
<a name="l07769"></a>07769          cond_offset_target (address, off / TARGET_CHAR_BIT), dval);
<a name="l07770"></a>07770       <span class="keywordflow">if</span> (branch_type == NULL)
<a name="l07771"></a>07771         {
<a name="l07772"></a>07772           <span class="keywordflow">for</span> (f = variant_field + 1; f &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (rtype); f += 1)
<a name="l07773"></a>07773             <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (rtype)[f - 1] = <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (rtype)[f];
<a name="l07774"></a>07774           <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (rtype) -= 1;
<a name="l07775"></a>07775         }
<a name="l07776"></a>07776       <span class="keywordflow">else</span>
<a name="l07777"></a>07777         {
<a name="l07778"></a>07778           <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (rtype, variant_field) = branch_type;
<a name="l07779"></a>07779           <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (rtype, variant_field) = <span class="stringliteral">&quot;S&quot;</span>;
<a name="l07780"></a>07780           fld_bit_len =
<a name="l07781"></a>07781             <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (rtype, variant_field)) *
<a name="l07782"></a>07782             TARGET_CHAR_BIT;
<a name="l07783"></a>07783           <span class="keywordflow">if</span> (off + fld_bit_len &gt; bit_len)
<a name="l07784"></a>07784             bit_len = off + fld_bit_len;
<a name="l07785"></a>07785           <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (rtype) =
<a name="l07786"></a>07786             align_value (bit_len, TARGET_CHAR_BIT) / TARGET_CHAR_BIT;
<a name="l07787"></a>07787         }
<a name="l07788"></a>07788     }
<a name="l07789"></a>07789 
<a name="l07790"></a>07790   <span class="comment">/* According to exp_dbug.ads, the size of TYPE for variable-size records</span>
<a name="l07791"></a>07791 <span class="comment">     should contain the alignment of that record, which should be a strictly</span>
<a name="l07792"></a>07792 <span class="comment">     positive value.  If null or negative, then something is wrong, most</span>
<a name="l07793"></a>07793 <span class="comment">     probably in the debug info.  In that case, we don&#39;t round up the size</span>
<a name="l07794"></a>07794 <span class="comment">     of the resulting type.  If this record is not part of another structure,</span>
<a name="l07795"></a>07795 <span class="comment">     the current RTYPE length might be good enough for our purposes.  */</span>
<a name="l07796"></a>07796   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) &lt;= 0)
<a name="l07797"></a>07797     {
<a name="l07798"></a>07798       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (rtype))
<a name="l07799"></a>07799         <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Invalid type size for `%s&#39; detected: %d.&quot;</span>),
<a name="l07800"></a>07800                  <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (rtype), <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type));
<a name="l07801"></a>07801       <span class="keywordflow">else</span>
<a name="l07802"></a>07802         <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Invalid type size for &lt;unnamed&gt; detected: %d.&quot;</span>),
<a name="l07803"></a>07803                  <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type));
<a name="l07804"></a>07804     }
<a name="l07805"></a>07805   <span class="keywordflow">else</span>
<a name="l07806"></a>07806     {
<a name="l07807"></a>07807       <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (rtype) = align_value (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (rtype),
<a name="l07808"></a>07808                                          <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type));
<a name="l07809"></a>07809     }
<a name="l07810"></a>07810 
<a name="l07811"></a>07811   <a class="code" href="value_8c.html#a10aad9b72e08c5e90e3051156fa83318">value_free_to_mark</a> (mark);
<a name="l07812"></a>07812   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (rtype) &gt; varsize_limit)
<a name="l07813"></a>07813     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;record type with dynamic size is larger than varsize-limit&quot;</span>));
<a name="l07814"></a>07814   <span class="keywordflow">return</span> rtype;
<a name="l07815"></a>07815 }
<a name="l07816"></a>07816 
<a name="l07817"></a>07817 <span class="comment">/* As for ada_template_to_fixed_record_type_1 with KEEP_DYNAMIC_FIELDS</span>
<a name="l07818"></a>07818 <span class="comment">   of 1.  */</span>
<a name="l07819"></a>07819 
<a name="l07820"></a>07820 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l07821"></a>07821 template_to_fixed_record_type (<span class="keyword">struct</span> type *type, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valaddr,
<a name="l07822"></a>07822                                <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address, <span class="keyword">struct</span> value *dval0)
<a name="l07823"></a>07823 {
<a name="l07824"></a>07824   <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a9c1702a87eec4475d858de14e61b0c5e">ada_template_to_fixed_record_type_1</a> (type, valaddr,
<a name="l07825"></a>07825                                               address, dval0, 1);
<a name="l07826"></a>07826 }
<a name="l07827"></a>07827 
<a name="l07828"></a>07828 <span class="comment">/* An ordinary record type in which ___XVL-convention fields and</span>
<a name="l07829"></a>07829 <span class="comment">   ___XVU- and ___XVN-convention field types in TYPE0 are replaced with</span>
<a name="l07830"></a>07830 <span class="comment">   static approximations, containing all possible fields.  Uses</span>
<a name="l07831"></a>07831 <span class="comment">   no runtime values.  Useless for use in values, but that&#39;s OK,</span>
<a name="l07832"></a>07832 <span class="comment">   since the results are used only for type determinations.   Works on both</span>
<a name="l07833"></a>07833 <span class="comment">   structs and unions.  Representation note: to save space, we memorize</span>
<a name="l07834"></a>07834 <span class="comment">   the result of this function in the TYPE_TARGET_TYPE of the</span>
<a name="l07835"></a>07835 <span class="comment">   template type.  */</span>
<a name="l07836"></a>07836 
<a name="l07837"></a>07837 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l07838"></a>07838 template_to_static_fixed_type (<span class="keyword">struct</span> type *type0)
<a name="l07839"></a>07839 {
<a name="l07840"></a>07840   <span class="keyword">struct </span>type *type;
<a name="l07841"></a>07841   <span class="keywordtype">int</span> nfields;
<a name="l07842"></a>07842   <span class="keywordtype">int</span> f;
<a name="l07843"></a>07843 
<a name="l07844"></a>07844   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type0) != NULL)
<a name="l07845"></a>07845     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type0);
<a name="l07846"></a>07846 
<a name="l07847"></a>07847   nfields = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type0);
<a name="l07848"></a>07848   type = type0;
<a name="l07849"></a>07849 
<a name="l07850"></a>07850   <span class="keywordflow">for</span> (f = 0; f &lt; nfields; f += 1)
<a name="l07851"></a>07851     {
<a name="l07852"></a>07852       <span class="keyword">struct </span>type *field_type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type0, f));
<a name="l07853"></a>07853       <span class="keyword">struct </span>type *new_type;
<a name="l07854"></a>07854 
<a name="l07855"></a>07855       <span class="keywordflow">if</span> (is_dynamic_field (type0, f))
<a name="l07856"></a>07856         new_type = to_static_fixed_type (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (field_type));
<a name="l07857"></a>07857       <span class="keywordflow">else</span>
<a name="l07858"></a>07858         new_type = static_unwrap_type (field_type);
<a name="l07859"></a>07859       <span class="keywordflow">if</span> (type == type0 &amp;&amp; new_type != field_type)
<a name="l07860"></a>07860         {
<a name="l07861"></a>07861           <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type0) = type = <a class="code" href="gdbtypes_8c.html#a2e8f72ee412f83ecd89f47068fda9634">alloc_type_copy</a> (type0);
<a name="l07862"></a>07862           <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) = <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type0);
<a name="l07863"></a>07863           <a class="code" href="gdbtypes_8h.html#abce922c83265a58f62b491513b7a5aea">INIT_CPLUS_SPECIFIC</a> (type);
<a name="l07864"></a>07864           <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) = nfields;
<a name="l07865"></a>07865           <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (type) = (<span class="keyword">struct </span>field *)
<a name="l07866"></a>07866             <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (type, nfields * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> field));
<a name="l07867"></a>07867           <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (type), <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (type0),
<a name="l07868"></a>07868                   <span class="keyword">sizeof</span> (<span class="keyword">struct</span> field) * nfields);
<a name="l07869"></a>07869           <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type0);
<a name="l07870"></a>07870           <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) = NULL;
<a name="l07871"></a>07871           <a class="code" href="gdbtypes_8h.html#a82cbfd363fdf782853ce90946f81c355">TYPE_FIXED_INSTANCE</a> (type) = 1;
<a name="l07872"></a>07872           <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type) = 0;
<a name="l07873"></a>07873         }
<a name="l07874"></a>07874       <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, f) = new_type;
<a name="l07875"></a>07875       <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, f) = <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type0, f);
<a name="l07876"></a>07876     }
<a name="l07877"></a>07877   <span class="keywordflow">return</span> type;
<a name="l07878"></a>07878 }
<a name="l07879"></a>07879 
<a name="l07880"></a>07880 <span class="comment">/* Given an object of type TYPE whose contents are at VALADDR and</span>
<a name="l07881"></a>07881 <span class="comment">   whose address in memory is ADDRESS, returns a revision of TYPE,</span>
<a name="l07882"></a>07882 <span class="comment">   which should be a non-dynamic-sized record, in which the variant</span>
<a name="l07883"></a>07883 <span class="comment">   part, if any, is replaced with the appropriate branch.  Looks</span>
<a name="l07884"></a>07884 <span class="comment">   for discriminant values in DVAL0, which can be NULL if the record</span>
<a name="l07885"></a>07885 <span class="comment">   contains the necessary discriminant values.  */</span>
<a name="l07886"></a>07886 
<a name="l07887"></a>07887 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l07888"></a>07888 to_record_with_fixed_variant_part (<span class="keyword">struct</span> type *type, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valaddr,
<a name="l07889"></a>07889                                    <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address, <span class="keyword">struct</span> value *dval0)
<a name="l07890"></a>07890 {
<a name="l07891"></a>07891   <span class="keyword">struct </span>value *mark = <a class="code" href="value_8c.html#a427a12b0dd4d5663b103d29f07a0e1c6">value_mark</a> ();
<a name="l07892"></a>07892   <span class="keyword">struct </span>value *dval;
<a name="l07893"></a>07893   <span class="keyword">struct </span>type *rtype;
<a name="l07894"></a>07894   <span class="keyword">struct </span>type *branch_type;
<a name="l07895"></a>07895   <span class="keywordtype">int</span> nfields = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type);
<a name="l07896"></a>07896   <span class="keywordtype">int</span> variant_field = variant_field_index (type);
<a name="l07897"></a>07897 
<a name="l07898"></a>07898   <span class="keywordflow">if</span> (variant_field == -1)
<a name="l07899"></a>07899     <span class="keywordflow">return</span> type;
<a name="l07900"></a>07900 
<a name="l07901"></a>07901   <span class="keywordflow">if</span> (dval0 == NULL)
<a name="l07902"></a>07902     dval = <a class="code" href="value_8c.html#ab189fd2d8ea1fe71f000581289a20e17">value_from_contents_and_address</a> (type, valaddr, address);
<a name="l07903"></a>07903   <span class="keywordflow">else</span>
<a name="l07904"></a>07904     dval = dval0;
<a name="l07905"></a>07905 
<a name="l07906"></a>07906   rtype = <a class="code" href="gdbtypes_8c.html#a2e8f72ee412f83ecd89f47068fda9634">alloc_type_copy</a> (type);
<a name="l07907"></a>07907   <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (rtype) = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>;
<a name="l07908"></a>07908   <a class="code" href="gdbtypes_8h.html#abce922c83265a58f62b491513b7a5aea">INIT_CPLUS_SPECIFIC</a> (rtype);
<a name="l07909"></a>07909   <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (rtype) = nfields;
<a name="l07910"></a>07910   <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (rtype) =
<a name="l07911"></a>07911     (<span class="keyword">struct </span>field *) <a class="code" href="gdbtypes_8h.html#adbcd45ddbde753d9ee006d095e9e5607">TYPE_ALLOC</a> (rtype, nfields * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> field));
<a name="l07912"></a>07912   <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (rtype), <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (type),
<a name="l07913"></a>07913           <span class="keyword">sizeof</span> (<span class="keyword">struct</span> field) * nfields);
<a name="l07914"></a>07914   <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (rtype) = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type);
<a name="l07915"></a>07915   <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (rtype) = NULL;
<a name="l07916"></a>07916   <a class="code" href="gdbtypes_8h.html#a82cbfd363fdf782853ce90946f81c355">TYPE_FIXED_INSTANCE</a> (rtype) = 1;
<a name="l07917"></a>07917   <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (rtype) = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type);
<a name="l07918"></a>07918 
<a name="l07919"></a>07919   branch_type = to_fixed_variant_branch_type
<a name="l07920"></a>07920     (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, variant_field),
<a name="l07921"></a>07921      cond_offset_host (valaddr,
<a name="l07922"></a>07922                        <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (type, variant_field)
<a name="l07923"></a>07923                        / TARGET_CHAR_BIT),
<a name="l07924"></a>07924      cond_offset_target (address,
<a name="l07925"></a>07925                          <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (type, variant_field)
<a name="l07926"></a>07926                          / TARGET_CHAR_BIT), dval);
<a name="l07927"></a>07927   <span class="keywordflow">if</span> (branch_type == NULL)
<a name="l07928"></a>07928     {
<a name="l07929"></a>07929       <span class="keywordtype">int</span> f;
<a name="l07930"></a>07930 
<a name="l07931"></a>07931       <span class="keywordflow">for</span> (f = variant_field + 1; f &lt; nfields; f += 1)
<a name="l07932"></a>07932         <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (rtype)[f - 1] = <a class="code" href="gdbtypes_8h.html#a5c5b6ac4d7e269488235dc0cbdfc1801">TYPE_FIELDS</a> (rtype)[f];
<a name="l07933"></a>07933       <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (rtype) -= 1;
<a name="l07934"></a>07934     }
<a name="l07935"></a>07935   <span class="keywordflow">else</span>
<a name="l07936"></a>07936     {
<a name="l07937"></a>07937       <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (rtype, variant_field) = branch_type;
<a name="l07938"></a>07938       <a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (rtype, variant_field) = <span class="stringliteral">&quot;S&quot;</span>;
<a name="l07939"></a>07939       <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (rtype, variant_field) = 0;
<a name="l07940"></a>07940       <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (rtype) += <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (branch_type);
<a name="l07941"></a>07941     }
<a name="l07942"></a>07942   <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (rtype) -= <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, variant_field));
<a name="l07943"></a>07943 
<a name="l07944"></a>07944   <a class="code" href="value_8c.html#a10aad9b72e08c5e90e3051156fa83318">value_free_to_mark</a> (mark);
<a name="l07945"></a>07945   <span class="keywordflow">return</span> rtype;
<a name="l07946"></a>07946 }
<a name="l07947"></a>07947 
<a name="l07948"></a>07948 <span class="comment">/* An ordinary record type (with fixed-length fields) that describes</span>
<a name="l07949"></a>07949 <span class="comment">   the value at (TYPE0, VALADDR, ADDRESS) [see explanation at</span>
<a name="l07950"></a>07950 <span class="comment">   beginning of this section].   Any necessary discriminants&#39; values</span>
<a name="l07951"></a>07951 <span class="comment">   should be in DVAL, a record value; it may be NULL if the object</span>
<a name="l07952"></a>07952 <span class="comment">   at ADDR itself contains any necessary discriminant values.</span>
<a name="l07953"></a>07953 <span class="comment">   Additionally, VALADDR and ADDRESS may also be NULL if no discriminant</span>
<a name="l07954"></a>07954 <span class="comment">   values from the record are needed.  Except in the case that DVAL,</span>
<a name="l07955"></a>07955 <span class="comment">   VALADDR, and ADDRESS are all 0 or NULL, a variant field (unless</span>
<a name="l07956"></a>07956 <span class="comment">   unchecked) is replaced by a particular branch of the variant.</span>
<a name="l07957"></a>07957 <span class="comment"></span>
<a name="l07958"></a>07958 <span class="comment">   NOTE: the case in which DVAL and VALADDR are NULL and ADDRESS is 0</span>
<a name="l07959"></a>07959 <span class="comment">   is questionable and may be removed.  It can arise during the</span>
<a name="l07960"></a>07960 <span class="comment">   processing of an unconstrained-array-of-record type where all the</span>
<a name="l07961"></a>07961 <span class="comment">   variant branches have exactly the same size.  This is because in</span>
<a name="l07962"></a>07962 <span class="comment">   such cases, the compiler does not bother to use the XVS convention</span>
<a name="l07963"></a>07963 <span class="comment">   when encoding the record.  I am currently dubious of this</span>
<a name="l07964"></a>07964 <span class="comment">   shortcut and suspect the compiler should be altered.  FIXME.  */</span>
<a name="l07965"></a>07965 
<a name="l07966"></a>07966 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l07967"></a>07967 to_fixed_record_type (<span class="keyword">struct</span> type *type0, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valaddr,
<a name="l07968"></a>07968                       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address, <span class="keyword">struct</span> value *dval)
<a name="l07969"></a>07969 {
<a name="l07970"></a>07970   <span class="keyword">struct </span>type *templ_type;
<a name="l07971"></a>07971 
<a name="l07972"></a>07972   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a82cbfd363fdf782853ce90946f81c355">TYPE_FIXED_INSTANCE</a> (type0))
<a name="l07973"></a>07973     <span class="keywordflow">return</span> type0;
<a name="l07974"></a>07974 
<a name="l07975"></a>07975   templ_type = dynamic_template_type (type0);
<a name="l07976"></a>07976 
<a name="l07977"></a>07977   <span class="keywordflow">if</span> (templ_type != NULL)
<a name="l07978"></a>07978     <span class="keywordflow">return</span> template_to_fixed_record_type (templ_type, valaddr, address, dval);
<a name="l07979"></a>07979   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (variant_field_index (type0) &gt;= 0)
<a name="l07980"></a>07980     {
<a name="l07981"></a>07981       <span class="keywordflow">if</span> (dval == NULL &amp;&amp; valaddr == NULL &amp;&amp; address == 0)
<a name="l07982"></a>07982         <span class="keywordflow">return</span> type0;
<a name="l07983"></a>07983       <span class="keywordflow">return</span> to_record_with_fixed_variant_part (type0, valaddr, address,
<a name="l07984"></a>07984                                                 dval);
<a name="l07985"></a>07985     }
<a name="l07986"></a>07986   <span class="keywordflow">else</span>
<a name="l07987"></a>07987     {
<a name="l07988"></a>07988       <a class="code" href="gdbtypes_8h.html#a82cbfd363fdf782853ce90946f81c355">TYPE_FIXED_INSTANCE</a> (type0) = 1;
<a name="l07989"></a>07989       <span class="keywordflow">return</span> type0;
<a name="l07990"></a>07990     }
<a name="l07991"></a>07991 
<a name="l07992"></a>07992 }
<a name="l07993"></a>07993 
<a name="l07994"></a>07994 <span class="comment">/* An ordinary record type (with fixed-length fields) that describes</span>
<a name="l07995"></a>07995 <span class="comment">   the value at (VAR_TYPE0, VALADDR, ADDRESS), where VAR_TYPE0 is a</span>
<a name="l07996"></a>07996 <span class="comment">   union type.  Any necessary discriminants&#39; values should be in DVAL,</span>
<a name="l07997"></a>07997 <span class="comment">   a record value.  That is, this routine selects the appropriate</span>
<a name="l07998"></a>07998 <span class="comment">   branch of the union at ADDR according to the discriminant value</span>
<a name="l07999"></a>07999 <span class="comment">   indicated in the union&#39;s type name.  Returns VAR_TYPE0 itself if</span>
<a name="l08000"></a>08000 <span class="comment">   it represents a variant subject to a pragma Unchecked_Union.  */</span>
<a name="l08001"></a>08001 
<a name="l08002"></a>08002 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l08003"></a>08003 to_fixed_variant_branch_type (<span class="keyword">struct</span> type *var_type0, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valaddr,
<a name="l08004"></a>08004                               <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address, <span class="keyword">struct</span> value *dval)
<a name="l08005"></a>08005 {
<a name="l08006"></a>08006   <span class="keywordtype">int</span> which;
<a name="l08007"></a>08007   <span class="keyword">struct </span>type *templ_type;
<a name="l08008"></a>08008   <span class="keyword">struct </span>type *var_type;
<a name="l08009"></a>08009 
<a name="l08010"></a>08010   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (var_type0) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l08011"></a>08011     var_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (var_type0);
<a name="l08012"></a>08012   <span class="keywordflow">else</span>
<a name="l08013"></a>08013     var_type = var_type0;
<a name="l08014"></a>08014 
<a name="l08015"></a>08015   templ_type = <a class="code" href="ada-lang_8c.html#ade263e735047904b7eabe725cd6cc2f9">ada_find_parallel_type</a> (var_type, <span class="stringliteral">&quot;___XVU&quot;</span>);
<a name="l08016"></a>08016 
<a name="l08017"></a>08017   <span class="keywordflow">if</span> (templ_type != NULL)
<a name="l08018"></a>08018     var_type = templ_type;
<a name="l08019"></a>08019 
<a name="l08020"></a>08020   <span class="keywordflow">if</span> (is_unchecked_variant (var_type, <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (dval)))
<a name="l08021"></a>08021       <span class="keywordflow">return</span> var_type0;
<a name="l08022"></a>08022   which =
<a name="l08023"></a>08023     <a class="code" href="ada-lang_8c.html#ac736764de442ef8224408d04089b2202">ada_which_variant_applies</a> (var_type,
<a name="l08024"></a>08024                                <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (dval), <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (dval));
<a name="l08025"></a>08025 
<a name="l08026"></a>08026   <span class="keywordflow">if</span> (which &lt; 0)
<a name="l08027"></a>08027     <span class="keywordflow">return</span> empty_record (var_type);
<a name="l08028"></a>08028   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_dynamic_field (var_type, which))
<a name="l08029"></a>08029     <span class="keywordflow">return</span> to_fixed_record_type
<a name="l08030"></a>08030       (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (var_type, which)),
<a name="l08031"></a>08031        valaddr, address, dval);
<a name="l08032"></a>08032   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (variant_field_index (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (var_type, which)) &gt;= 0)
<a name="l08033"></a>08033     <span class="keywordflow">return</span>
<a name="l08034"></a>08034       to_fixed_record_type
<a name="l08035"></a>08035       (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (var_type, which), valaddr, address, dval);
<a name="l08036"></a>08036   <span class="keywordflow">else</span>
<a name="l08037"></a>08037     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (var_type, which);
<a name="l08038"></a>08038 }
<a name="l08039"></a>08039 
<a name="l08040"></a>08040 <span class="comment">/* Assuming that TYPE0 is an array type describing the type of a value</span>
<a name="l08041"></a>08041 <span class="comment">   at ADDR, and that DVAL describes a record containing any</span>
<a name="l08042"></a>08042 <span class="comment">   discriminants used in TYPE0, returns a type for the value that</span>
<a name="l08043"></a>08043 <span class="comment">   contains no dynamic components (that is, no components whose sizes</span>
<a name="l08044"></a>08044 <span class="comment">   are determined by run-time quantities).  Unless IGNORE_TOO_BIG is</span>
<a name="l08045"></a>08045 <span class="comment">   true, gives an error message if the resulting type&#39;s size is over</span>
<a name="l08046"></a>08046 <span class="comment">   varsize_limit.  */</span>
<a name="l08047"></a>08047 
<a name="l08048"></a>08048 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l08049"></a>08049 to_fixed_array_type (<span class="keyword">struct</span> type *type0, <span class="keyword">struct</span> value *dval,
<a name="l08050"></a>08050                      <span class="keywordtype">int</span> ignore_too_big)
<a name="l08051"></a>08051 {
<a name="l08052"></a>08052   <span class="keyword">struct </span>type *index_type_desc;
<a name="l08053"></a>08053   <span class="keyword">struct </span>type *result;
<a name="l08054"></a>08054   <span class="keywordtype">int</span> constrained_packed_array_p;
<a name="l08055"></a>08055 
<a name="l08056"></a>08056   type0 = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type0);
<a name="l08057"></a>08057   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a82cbfd363fdf782853ce90946f81c355">TYPE_FIXED_INSTANCE</a> (type0))
<a name="l08058"></a>08058     <span class="keywordflow">return</span> type0;
<a name="l08059"></a>08059 
<a name="l08060"></a>08060   constrained_packed_array_p = <a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (type0);
<a name="l08061"></a>08061   <span class="keywordflow">if</span> (constrained_packed_array_p)
<a name="l08062"></a>08062     type0 = decode_constrained_packed_array_type (type0);
<a name="l08063"></a>08063 
<a name="l08064"></a>08064   index_type_desc = <a class="code" href="ada-lang_8c.html#ade263e735047904b7eabe725cd6cc2f9">ada_find_parallel_type</a> (type0, <span class="stringliteral">&quot;___XA&quot;</span>);
<a name="l08065"></a>08065   <a class="code" href="ada-lang_8c.html#ad725b7268112515bd22d705724724044">ada_fixup_array_indexes_type</a> (index_type_desc);
<a name="l08066"></a>08066   <span class="keywordflow">if</span> (index_type_desc == NULL)
<a name="l08067"></a>08067     {
<a name="l08068"></a>08068       <span class="keyword">struct </span>type *elt_type0 = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type0));
<a name="l08069"></a>08069 
<a name="l08070"></a>08070       <span class="comment">/* NOTE: elt_type---the fixed version of elt_type0---should never</span>
<a name="l08071"></a>08071 <span class="comment">         depend on the contents of the array in properly constructed</span>
<a name="l08072"></a>08072 <span class="comment">         debugging data.  */</span>
<a name="l08073"></a>08073       <span class="comment">/* Create a fixed version of the array element type.</span>
<a name="l08074"></a>08074 <span class="comment">         We&#39;re not providing the address of an element here,</span>
<a name="l08075"></a>08075 <span class="comment">         and thus the actual object value cannot be inspected to do</span>
<a name="l08076"></a>08076 <span class="comment">         the conversion.  This should not be a problem, since arrays of</span>
<a name="l08077"></a>08077 <span class="comment">         unconstrained objects are not allowed.  In particular, all</span>
<a name="l08078"></a>08078 <span class="comment">         the elements of an array of a tagged type should all be of</span>
<a name="l08079"></a>08079 <span class="comment">         the same type specified in the debugging info.  No need to</span>
<a name="l08080"></a>08080 <span class="comment">         consult the object tag.  */</span>
<a name="l08081"></a>08081       <span class="keyword">struct </span>type *elt_type = <a class="code" href="ada-lang_8c.html#a0096e64d1590f0b629f4a8ca484bddbd">ada_to_fixed_type</a> (elt_type0, 0, 0, dval, 1);
<a name="l08082"></a>08082 
<a name="l08083"></a>08083       <span class="comment">/* Make sure we always create a new array type when dealing with</span>
<a name="l08084"></a>08084 <span class="comment">         packed array types, since we&#39;re going to fix-up the array</span>
<a name="l08085"></a>08085 <span class="comment">         type length and element bitsize a little further down.  */</span>
<a name="l08086"></a>08086       <span class="keywordflow">if</span> (elt_type0 == elt_type &amp;&amp; !constrained_packed_array_p)
<a name="l08087"></a>08087         result = type0;
<a name="l08088"></a>08088       <span class="keywordflow">else</span>
<a name="l08089"></a>08089         result = <a class="code" href="gdbtypes_8c.html#a779bbebb8202264a73344b49b22d774e">create_array_type</a> (<a class="code" href="gdbtypes_8c.html#a2e8f72ee412f83ecd89f47068fda9634">alloc_type_copy</a> (type0),
<a name="l08090"></a>08090                                     elt_type, <a class="code" href="gdbtypes_8h.html#a6448238a234e871dd78756230f4f57f1">TYPE_INDEX_TYPE</a> (type0));
<a name="l08091"></a>08091     }
<a name="l08092"></a>08092   <span class="keywordflow">else</span>
<a name="l08093"></a>08093     {
<a name="l08094"></a>08094       <span class="keywordtype">int</span> i;
<a name="l08095"></a>08095       <span class="keyword">struct </span>type *elt_type0;
<a name="l08096"></a>08096 
<a name="l08097"></a>08097       elt_type0 = type0;
<a name="l08098"></a>08098       <span class="keywordflow">for</span> (i = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (index_type_desc); i &gt; 0; i -= 1)
<a name="l08099"></a>08099         elt_type0 = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (elt_type0);
<a name="l08100"></a>08100 
<a name="l08101"></a>08101       <span class="comment">/* NOTE: result---the fixed version of elt_type0---should never</span>
<a name="l08102"></a>08102 <span class="comment">         depend on the contents of the array in properly constructed</span>
<a name="l08103"></a>08103 <span class="comment">         debugging data.  */</span>
<a name="l08104"></a>08104       <span class="comment">/* Create a fixed version of the array element type.</span>
<a name="l08105"></a>08105 <span class="comment">         We&#39;re not providing the address of an element here,</span>
<a name="l08106"></a>08106 <span class="comment">         and thus the actual object value cannot be inspected to do</span>
<a name="l08107"></a>08107 <span class="comment">         the conversion.  This should not be a problem, since arrays of</span>
<a name="l08108"></a>08108 <span class="comment">         unconstrained objects are not allowed.  In particular, all</span>
<a name="l08109"></a>08109 <span class="comment">         the elements of an array of a tagged type should all be of</span>
<a name="l08110"></a>08110 <span class="comment">         the same type specified in the debugging info.  No need to</span>
<a name="l08111"></a>08111 <span class="comment">         consult the object tag.  */</span>
<a name="l08112"></a>08112       result =
<a name="l08113"></a>08113         <a class="code" href="ada-lang_8c.html#a0096e64d1590f0b629f4a8ca484bddbd">ada_to_fixed_type</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (elt_type0), 0, 0, dval, 1);
<a name="l08114"></a>08114 
<a name="l08115"></a>08115       elt_type0 = type0;
<a name="l08116"></a>08116       <span class="keywordflow">for</span> (i = <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (index_type_desc) - 1; i &gt;= 0; i -= 1)
<a name="l08117"></a>08117         {
<a name="l08118"></a>08118           <span class="keyword">struct </span>type *range_type =
<a name="l08119"></a>08119             to_fixed_range_type (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (index_type_desc, i), dval);
<a name="l08120"></a>08120 
<a name="l08121"></a>08121           result = <a class="code" href="gdbtypes_8c.html#a779bbebb8202264a73344b49b22d774e">create_array_type</a> (<a class="code" href="gdbtypes_8c.html#a2e8f72ee412f83ecd89f47068fda9634">alloc_type_copy</a> (elt_type0),
<a name="l08122"></a>08122                                       result, range_type);
<a name="l08123"></a>08123           elt_type0 = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (elt_type0);
<a name="l08124"></a>08124         }
<a name="l08125"></a>08125       <span class="keywordflow">if</span> (!ignore_too_big &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (result) &gt; varsize_limit)
<a name="l08126"></a>08126         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;array type with dynamic size is larger than varsize-limit&quot;</span>));
<a name="l08127"></a>08127     }
<a name="l08128"></a>08128 
<a name="l08129"></a>08129   <span class="comment">/* We want to preserve the type name.  This can be useful when</span>
<a name="l08130"></a>08130 <span class="comment">     trying to get the type name of a value that has already been</span>
<a name="l08131"></a>08131 <span class="comment">     printed (for instance, if the user did &quot;print VAR; whatis $&quot;.  */</span>
<a name="l08132"></a>08132   <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (result) = <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type0);
<a name="l08133"></a>08133 
<a name="l08134"></a>08134   <span class="keywordflow">if</span> (constrained_packed_array_p)
<a name="l08135"></a>08135     {
<a name="l08136"></a>08136       <span class="comment">/* So far, the resulting type has been created as if the original</span>
<a name="l08137"></a>08137 <span class="comment">         type was a regular (non-packed) array type.  As a result, the</span>
<a name="l08138"></a>08138 <span class="comment">         bitsize of the array elements needs to be set again, and the array</span>
<a name="l08139"></a>08139 <span class="comment">         length needs to be recomputed based on that bitsize.  */</span>
<a name="l08140"></a>08140       <span class="keywordtype">int</span> len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (result) / <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (result));
<a name="l08141"></a>08141       <span class="keywordtype">int</span> elt_bitsize = <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (type0, 0);
<a name="l08142"></a>08142 
<a name="l08143"></a>08143       <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (result, 0) = <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (type0, 0);
<a name="l08144"></a>08144       <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (result) = len * elt_bitsize / <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a>;
<a name="l08145"></a>08145       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (result) * <a class="code" href="defs_8h.html#a02f9a4c6bafd89c95ba34f80a750eff8">HOST_CHAR_BIT</a> &lt; len * elt_bitsize)
<a name="l08146"></a>08146         <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (result)++;
<a name="l08147"></a>08147     }
<a name="l08148"></a>08148 
<a name="l08149"></a>08149   <a class="code" href="gdbtypes_8h.html#a82cbfd363fdf782853ce90946f81c355">TYPE_FIXED_INSTANCE</a> (result) = 1;
<a name="l08150"></a>08150   <span class="keywordflow">return</span> result;
<a name="l08151"></a>08151 }
<a name="l08152"></a>08152 
<a name="l08153"></a>08153 
<a name="l08154"></a>08154 <span class="comment">/* A standard type (containing no dynamically sized components)</span>
<a name="l08155"></a>08155 <span class="comment">   corresponding to TYPE for the value (TYPE, VALADDR, ADDRESS)</span>
<a name="l08156"></a>08156 <span class="comment">   DVAL describes a record containing any discriminants used in TYPE0,</span>
<a name="l08157"></a>08157 <span class="comment">   and may be NULL if there are none, or if the object of type TYPE at</span>
<a name="l08158"></a>08158 <span class="comment">   ADDRESS or in VALADDR contains these discriminants.</span>
<a name="l08159"></a>08159 <span class="comment">   </span>
<a name="l08160"></a>08160 <span class="comment">   If CHECK_TAG is not null, in the case of tagged types, this function</span>
<a name="l08161"></a>08161 <span class="comment">   attempts to locate the object&#39;s tag and use it to compute the actual</span>
<a name="l08162"></a>08162 <span class="comment">   type.  However, when ADDRESS is null, we cannot use it to determine the</span>
<a name="l08163"></a>08163 <span class="comment">   location of the tag, and therefore compute the tagged type&#39;s actual type.</span>
<a name="l08164"></a>08164 <span class="comment">   So we return the tagged type without consulting the tag.  */</span>
<a name="l08165"></a>08165    
<a name="l08166"></a>08166 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l08167"></a>08167 ada_to_fixed_type_1 (<span class="keyword">struct</span> type *type, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valaddr,
<a name="l08168"></a>08168                    <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address, <span class="keyword">struct</span> value *dval, <span class="keywordtype">int</span> check_tag)
<a name="l08169"></a>08169 {
<a name="l08170"></a>08170   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l08171"></a>08171   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l08172"></a>08172     {
<a name="l08173"></a>08173     <span class="keywordflow">default</span>:
<a name="l08174"></a>08174       <span class="keywordflow">return</span> type;
<a name="l08175"></a>08175     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l08176"></a>08176       {
<a name="l08177"></a>08177         <span class="keyword">struct </span>type *static_type = to_static_fixed_type (type);
<a name="l08178"></a>08178         <span class="keyword">struct </span>type *fixed_record_type =
<a name="l08179"></a>08179           to_fixed_record_type (type, valaddr, address, NULL);
<a name="l08180"></a>08180 
<a name="l08181"></a>08181         <span class="comment">/* If STATIC_TYPE is a tagged type and we know the object&#39;s address,</span>
<a name="l08182"></a>08182 <span class="comment">           then we can determine its tag, and compute the object&#39;s actual</span>
<a name="l08183"></a>08183 <span class="comment">           type from there.  Note that we have to use the fixed record</span>
<a name="l08184"></a>08184 <span class="comment">           type (the parent part of the record may have dynamic fields</span>
<a name="l08185"></a>08185 <span class="comment">           and the way the location of _tag is expressed may depend on</span>
<a name="l08186"></a>08186 <span class="comment">           them).  */</span>
<a name="l08187"></a>08187 
<a name="l08188"></a>08188         <span class="keywordflow">if</span> (check_tag &amp;&amp; address != 0 &amp;&amp; <a class="code" href="ada-lang_8c.html#abbecc644387ffb0a43e57ed0462c2c8b">ada_is_tagged_type</a> (static_type, 0))
<a name="l08189"></a>08189           {
<a name="l08190"></a>08190             <span class="keyword">struct </span>value *tag =
<a name="l08191"></a>08191               value_tag_from_contents_and_address
<a name="l08192"></a>08192               (fixed_record_type,
<a name="l08193"></a>08193                valaddr,
<a name="l08194"></a>08194                address);
<a name="l08195"></a>08195             <span class="keyword">struct </span>type *real_type = type_from_tag (tag);
<a name="l08196"></a>08196             <span class="keyword">struct </span>value *obj =
<a name="l08197"></a>08197               <a class="code" href="value_8c.html#ab189fd2d8ea1fe71f000581289a20e17">value_from_contents_and_address</a> (fixed_record_type,
<a name="l08198"></a>08198                                                valaddr,
<a name="l08199"></a>08199                                                address);
<a name="l08200"></a>08200             <span class="keywordflow">if</span> (real_type != NULL)
<a name="l08201"></a>08201               <span class="keywordflow">return</span> to_fixed_record_type
<a name="l08202"></a>08202                 (real_type, NULL,
<a name="l08203"></a>08203                  <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (<a class="code" href="ada-lang_8c.html#a8194e4f9a4e73790e353cc869af2e34a">ada_tag_value_at_base_address</a> (obj)), NULL);
<a name="l08204"></a>08204           }
<a name="l08205"></a>08205 
<a name="l08206"></a>08206         <span class="comment">/* Check to see if there is a parallel ___XVZ variable.</span>
<a name="l08207"></a>08207 <span class="comment">           If there is, then it provides the actual size of our type.  */</span>
<a name="l08208"></a>08208         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (fixed_record_type) != NULL)
<a name="l08209"></a>08209           {
<a name="l08210"></a>08210             <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (fixed_record_type);
<a name="l08211"></a>08211             <span class="keywordtype">char</span> *xvz_name = alloca (strlen (name) + 7 <span class="comment">/* &quot;___XVZ\0&quot; */</span>);
<a name="l08212"></a>08212             <span class="keywordtype">int</span> xvz_found = 0;
<a name="l08213"></a>08213             <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l08214"></a>08214 
<a name="l08215"></a>08215             <a class="code" href="common-utils_8c.html#ad9940337ec98983dae9951c947879fc8">xsnprintf</a> (xvz_name, strlen (name) + 7, <span class="stringliteral">&quot;%s___XVZ&quot;</span>, name);
<a name="l08216"></a>08216             size = <a class="code" href="ada-lang_8c.html#a484727f9e5debb643d5912928f277dee">get_int_var_value</a> (xvz_name, &amp;xvz_found);
<a name="l08217"></a>08217             <span class="keywordflow">if</span> (xvz_found &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (fixed_record_type) != size)
<a name="l08218"></a>08218               {
<a name="l08219"></a>08219                 fixed_record_type = <a class="code" href="gdbtypes_8c.html#a73be1910eae6da9c7ec226a3d38beeac">copy_type</a> (fixed_record_type);
<a name="l08220"></a>08220                 <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (fixed_record_type) = <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l08221"></a>08221 
<a name="l08222"></a>08222                 <span class="comment">/* The FIXED_RECORD_TYPE may have be a stub.  We have</span>
<a name="l08223"></a>08223 <span class="comment">                   observed this when the debugging info is STABS, and</span>
<a name="l08224"></a>08224 <span class="comment">                   apparently it is something that is hard to fix.</span>
<a name="l08225"></a>08225 <span class="comment"></span>
<a name="l08226"></a>08226 <span class="comment">                   In practice, we don&#39;t need the actual type definition</span>
<a name="l08227"></a>08227 <span class="comment">                   at all, because the presence of the XVZ variable allows us</span>
<a name="l08228"></a>08228 <span class="comment">                   to assume that there must be a XVS type as well, which we</span>
<a name="l08229"></a>08229 <span class="comment">                   should be able to use later, when we need the actual type</span>
<a name="l08230"></a>08230 <span class="comment">                   definition.</span>
<a name="l08231"></a>08231 <span class="comment"></span>
<a name="l08232"></a>08232 <span class="comment">                   In the meantime, pretend that the &quot;fixed&quot; type we are</span>
<a name="l08233"></a>08233 <span class="comment">                   returning is NOT a stub, because this can cause trouble</span>
<a name="l08234"></a>08234 <span class="comment">                   when using this type to create new types targeting it.</span>
<a name="l08235"></a>08235 <span class="comment">                   Indeed, the associated creation routines often check</span>
<a name="l08236"></a>08236 <span class="comment">                   whether the target type is a stub and will try to replace</span>
<a name="l08237"></a>08237 <span class="comment">                   it, thus using a type with the wrong size.  This, in turn,</span>
<a name="l08238"></a>08238 <span class="comment">                   might cause the new type to have the wrong size too.</span>
<a name="l08239"></a>08239 <span class="comment">                   Consider the case of an array, for instance, where the size</span>
<a name="l08240"></a>08240 <span class="comment">                   of the array is computed from the number of elements in</span>
<a name="l08241"></a>08241 <span class="comment">                   our array multiplied by the size of its element.  */</span>
<a name="l08242"></a>08242                 <a class="code" href="gdbtypes_8h.html#aec5d0569d60af8ecfc5d2c7edae87d9c">TYPE_STUB</a> (fixed_record_type) = 0;
<a name="l08243"></a>08243               }
<a name="l08244"></a>08244           }
<a name="l08245"></a>08245         <span class="keywordflow">return</span> fixed_record_type;
<a name="l08246"></a>08246       }
<a name="l08247"></a>08247     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>:
<a name="l08248"></a>08248       <span class="keywordflow">return</span> to_fixed_array_type (type, dval, 1);
<a name="l08249"></a>08249     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>:
<a name="l08250"></a>08250       <span class="keywordflow">if</span> (dval == NULL)
<a name="l08251"></a>08251         <span class="keywordflow">return</span> type;
<a name="l08252"></a>08252       <span class="keywordflow">else</span>
<a name="l08253"></a>08253         <span class="keywordflow">return</span> to_fixed_variant_branch_type (type, valaddr, address, dval);
<a name="l08254"></a>08254     }
<a name="l08255"></a>08255 }
<a name="l08256"></a>08256 
<a name="l08257"></a>08257 <span class="comment">/* The same as ada_to_fixed_type_1, except that it preserves the type</span>
<a name="l08258"></a>08258 <span class="comment">   if it is a TYPE_CODE_TYPEDEF of a type that is already fixed.</span>
<a name="l08259"></a>08259 <span class="comment"></span>
<a name="l08260"></a>08260 <span class="comment">   The typedef layer needs be preserved in order to differentiate between</span>
<a name="l08261"></a>08261 <span class="comment">   arrays and array pointers when both types are implemented using the same</span>
<a name="l08262"></a>08262 <span class="comment">   fat pointer.  In the array pointer case, the pointer is encoded as</span>
<a name="l08263"></a>08263 <span class="comment">   a typedef of the pointer type.  For instance, considering:</span>
<a name="l08264"></a>08264 <span class="comment"></span>
<a name="l08265"></a>08265 <span class="comment">          type String_Access is access String;</span>
<a name="l08266"></a>08266 <span class="comment">          S1 : String_Access := null;</span>
<a name="l08267"></a>08267 <span class="comment"></span>
<a name="l08268"></a>08268 <span class="comment">   To the debugger, S1 is defined as a typedef of type String.  But</span>
<a name="l08269"></a>08269 <span class="comment">   to the user, it is a pointer.  So if the user tries to print S1,</span>
<a name="l08270"></a>08270 <span class="comment">   we should not dereference the array, but print the array address</span>
<a name="l08271"></a>08271 <span class="comment">   instead.</span>
<a name="l08272"></a>08272 <span class="comment"></span>
<a name="l08273"></a>08273 <span class="comment">   If we didn&#39;t preserve the typedef layer, we would lose the fact that</span>
<a name="l08274"></a>08274 <span class="comment">   the type is to be presented as a pointer (needs de-reference before</span>
<a name="l08275"></a>08275 <span class="comment">   being printed).  And we would also use the source-level type name.  */</span>
<a name="l08276"></a>08276 
<a name="l08277"></a>08277 <span class="keyword">struct </span>type *
<a name="l08278"></a><a class="code" href="ada-lang_8h.html#a376cc0bd0efd5047ff253ebf9d4fb6c6">08278</a> <a class="code" href="ada-lang_8c.html#a0096e64d1590f0b629f4a8ca484bddbd">ada_to_fixed_type</a> (<span class="keyword">struct</span> type *type, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valaddr,
<a name="l08279"></a>08279                    <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address, <span class="keyword">struct</span> value *dval, <span class="keywordtype">int</span> check_tag)
<a name="l08280"></a>08280 
<a name="l08281"></a>08281 {
<a name="l08282"></a>08282   <span class="keyword">struct </span>type *fixed_type =
<a name="l08283"></a>08283     ada_to_fixed_type_1 (type, valaddr, address, dval, check_tag);
<a name="l08284"></a>08284 
<a name="l08285"></a>08285   <span class="comment">/*  If TYPE is a typedef and its target type is the same as the FIXED_TYPE,</span>
<a name="l08286"></a>08286 <span class="comment">      then preserve the typedef layer.</span>
<a name="l08287"></a>08287 <span class="comment"></span>
<a name="l08288"></a>08288 <span class="comment">      Implementation note: We can only check the main-type portion of</span>
<a name="l08289"></a>08289 <span class="comment">      the TYPE and FIXED_TYPE, because eliminating the typedef layer</span>
<a name="l08290"></a>08290 <span class="comment">      from TYPE now returns a type that has the same instance flags</span>
<a name="l08291"></a>08291 <span class="comment">      as TYPE.  For instance, if TYPE is a &quot;typedef const&quot;, and its</span>
<a name="l08292"></a>08292 <span class="comment">      target type is a &quot;struct&quot;, then the typedef elimination will return</span>
<a name="l08293"></a>08293 <span class="comment">      a &quot;const&quot; version of the target type.  See check_typedef for more</span>
<a name="l08294"></a>08294 <span class="comment">      details about how the typedef layer elimination is done.</span>
<a name="l08295"></a>08295 <span class="comment"></span>
<a name="l08296"></a>08296 <span class="comment">      brobecker/2010-11-19: It seems to me that the only case where it is</span>
<a name="l08297"></a>08297 <span class="comment">      useful to preserve the typedef layer is when dealing with fat pointers.</span>
<a name="l08298"></a>08298 <span class="comment">      Perhaps, we could add a check for that and preserve the typedef layer</span>
<a name="l08299"></a>08299 <span class="comment">      only in that situation.  But this seems unecessary so far, probably</span>
<a name="l08300"></a>08300 <span class="comment">      because we call check_typedef/ada_check_typedef pretty much everywhere.</span>
<a name="l08301"></a>08301 <span class="comment">      */</span>
<a name="l08302"></a>08302   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>
<a name="l08303"></a>08303       &amp;&amp; (<a class="code" href="gdbtypes_8h.html#a55dcae50baf1c424ac0ceb071bcaa68c">TYPE_MAIN_TYPE</a> (ada_typedef_target_type (type))
<a name="l08304"></a>08304           == <a class="code" href="gdbtypes_8h.html#a55dcae50baf1c424ac0ceb071bcaa68c">TYPE_MAIN_TYPE</a> (fixed_type)))
<a name="l08305"></a>08305     <span class="keywordflow">return</span> type;
<a name="l08306"></a>08306 
<a name="l08307"></a>08307   <span class="keywordflow">return</span> fixed_type;
<a name="l08308"></a>08308 }
<a name="l08309"></a>08309 
<a name="l08310"></a>08310 <span class="comment">/* A standard (static-sized) type corresponding as well as possible to</span>
<a name="l08311"></a>08311 <span class="comment">   TYPE0, but based on no runtime data.  */</span>
<a name="l08312"></a>08312 
<a name="l08313"></a>08313 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l08314"></a>08314 to_static_fixed_type (<span class="keyword">struct</span> type *type0)
<a name="l08315"></a>08315 {
<a name="l08316"></a>08316   <span class="keyword">struct </span>type *type;
<a name="l08317"></a>08317 
<a name="l08318"></a>08318   <span class="keywordflow">if</span> (type0 == NULL)
<a name="l08319"></a>08319     <span class="keywordflow">return</span> NULL;
<a name="l08320"></a>08320 
<a name="l08321"></a>08321   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a82cbfd363fdf782853ce90946f81c355">TYPE_FIXED_INSTANCE</a> (type0))
<a name="l08322"></a>08322     <span class="keywordflow">return</span> type0;
<a name="l08323"></a>08323 
<a name="l08324"></a>08324   type0 = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type0);
<a name="l08325"></a>08325 
<a name="l08326"></a>08326   <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type0))
<a name="l08327"></a>08327     {
<a name="l08328"></a>08328     <span class="keywordflow">default</span>:
<a name="l08329"></a>08329       <span class="keywordflow">return</span> type0;
<a name="l08330"></a>08330     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l08331"></a>08331       type = dynamic_template_type (type0);
<a name="l08332"></a>08332       <span class="keywordflow">if</span> (type != NULL)
<a name="l08333"></a>08333         <span class="keywordflow">return</span> template_to_static_fixed_type (type);
<a name="l08334"></a>08334       <span class="keywordflow">else</span>
<a name="l08335"></a>08335         <span class="keywordflow">return</span> template_to_static_fixed_type (type0);
<a name="l08336"></a>08336     <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>:
<a name="l08337"></a>08337       type = <a class="code" href="ada-lang_8c.html#ade263e735047904b7eabe725cd6cc2f9">ada_find_parallel_type</a> (type0, <span class="stringliteral">&quot;___XVU&quot;</span>);
<a name="l08338"></a>08338       <span class="keywordflow">if</span> (type != NULL)
<a name="l08339"></a>08339         <span class="keywordflow">return</span> template_to_static_fixed_type (type);
<a name="l08340"></a>08340       <span class="keywordflow">else</span>
<a name="l08341"></a>08341         <span class="keywordflow">return</span> template_to_static_fixed_type (type0);
<a name="l08342"></a>08342     }
<a name="l08343"></a>08343 }
<a name="l08344"></a>08344 
<a name="l08345"></a>08345 <span class="comment">/* A static approximation of TYPE with all type wrappers removed.  */</span>
<a name="l08346"></a>08346 
<a name="l08347"></a>08347 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l08348"></a>08348 static_unwrap_type (<span class="keyword">struct</span> type *type)
<a name="l08349"></a>08349 {
<a name="l08350"></a>08350   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ac972c52cf860cdffae561d774c2f3258">ada_is_aligner_type</a> (type))
<a name="l08351"></a>08351     {
<a name="l08352"></a>08352       <span class="keyword">struct </span>type *type1 = <a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type), 0);
<a name="l08353"></a>08353       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type1) == NULL)
<a name="l08354"></a>08354         <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type1) = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type);
<a name="l08355"></a>08355 
<a name="l08356"></a>08356       <span class="keywordflow">return</span> static_unwrap_type (type1);
<a name="l08357"></a>08357     }
<a name="l08358"></a>08358   <span class="keywordflow">else</span>
<a name="l08359"></a>08359     {
<a name="l08360"></a>08360       <span class="keyword">struct </span>type *raw_real_type = <a class="code" href="ada-lang_8c.html#aac42a4c75acced2b75b65874ef51ead8">ada_get_base_type</a> (type);
<a name="l08361"></a>08361 
<a name="l08362"></a>08362       <span class="keywordflow">if</span> (raw_real_type == type)
<a name="l08363"></a>08363         <span class="keywordflow">return</span> type;
<a name="l08364"></a>08364       <span class="keywordflow">else</span>
<a name="l08365"></a>08365         <span class="keywordflow">return</span> to_static_fixed_type (raw_real_type);
<a name="l08366"></a>08366     }
<a name="l08367"></a>08367 }
<a name="l08368"></a>08368 
<a name="l08369"></a>08369 <span class="comment">/* In some cases, incomplete and private types require</span>
<a name="l08370"></a>08370 <span class="comment">   cross-references that are not resolved as records (for example,</span>
<a name="l08371"></a>08371 <span class="comment">      type Foo;</span>
<a name="l08372"></a>08372 <span class="comment">      type FooP is access Foo;</span>
<a name="l08373"></a>08373 <span class="comment">      V: FooP;</span>
<a name="l08374"></a>08374 <span class="comment">      type Foo is array ...;</span>
<a name="l08375"></a>08375 <span class="comment">   ).  In these cases, since there is no mechanism for producing</span>
<a name="l08376"></a>08376 <span class="comment">   cross-references to such types, we instead substitute for FooP a</span>
<a name="l08377"></a>08377 <span class="comment">   stub enumeration type that is nowhere resolved, and whose tag is</span>
<a name="l08378"></a>08378 <span class="comment">   the name of the actual type.  Call these types &quot;non-record stubs&quot;.  */</span>
<a name="l08379"></a>08379 
<a name="l08380"></a>08380 <span class="comment">/* A type equivalent to TYPE that is not a non-record stub, if one</span>
<a name="l08381"></a>08381 <span class="comment">   exists, otherwise TYPE.  */</span>
<a name="l08382"></a>08382 
<a name="l08383"></a>08383 <span class="keyword">struct </span>type *
<a name="l08384"></a><a class="code" href="ada-lang_8h.html#a461c6cddb7099f834786f84a2ecbb8ee">08384</a> <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<span class="keyword">struct</span> type *type)
<a name="l08385"></a>08385 {
<a name="l08386"></a>08386   <span class="keywordflow">if</span> (type == NULL)
<a name="l08387"></a>08387     <span class="keywordflow">return</span> NULL;
<a name="l08388"></a>08388 
<a name="l08389"></a>08389   <span class="comment">/* If our type is a typedef type of a fat pointer, then we&#39;re done.</span>
<a name="l08390"></a>08390 <span class="comment">     We don&#39;t want to strip the TYPE_CODE_TYPDEF layer, because this is</span>
<a name="l08391"></a>08391 <span class="comment">     what allows us to distinguish between fat pointers that represent</span>
<a name="l08392"></a>08392 <span class="comment">     array types, and fat pointers that represent array access types</span>
<a name="l08393"></a>08393 <span class="comment">     (in both cases, the compiler implements them as fat pointers).  */</span>
<a name="l08394"></a>08394   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>
<a name="l08395"></a>08395       &amp;&amp; is_thick_pntr (ada_typedef_target_type (type)))
<a name="l08396"></a>08396     <span class="keywordflow">return</span> type;
<a name="l08397"></a>08397 
<a name="l08398"></a>08398   <a class="code" href="gdbtypes_8h.html#ae2f9348c644babaa9038b4dc18bffaac">CHECK_TYPEDEF</a> (type);
<a name="l08399"></a>08399   <span class="keywordflow">if</span> (type == NULL || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>
<a name="l08400"></a>08400       || !<a class="code" href="gdbtypes_8h.html#aec5d0569d60af8ecfc5d2c7edae87d9c">TYPE_STUB</a> (type)
<a name="l08401"></a>08401       || <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type) == NULL)
<a name="l08402"></a>08402     <span class="keywordflow">return</span> type;
<a name="l08403"></a>08403   <span class="keywordflow">else</span>
<a name="l08404"></a>08404     {
<a name="l08405"></a>08405       <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="gdbtypes_8h.html#acb2abdd2de64c35b3041ddfe1aa64099">TYPE_TAG_NAME</a> (type);
<a name="l08406"></a>08406       <span class="keyword">struct </span>type *type1 = ada_find_any_type (name);
<a name="l08407"></a>08407 
<a name="l08408"></a>08408       <span class="keywordflow">if</span> (type1 == NULL)
<a name="l08409"></a>08409         <span class="keywordflow">return</span> type;
<a name="l08410"></a>08410 
<a name="l08411"></a>08411       <span class="comment">/* TYPE1 might itself be a TYPE_CODE_TYPEDEF (this can happen with</span>
<a name="l08412"></a>08412 <span class="comment">         stubs pointing to arrays, as we don&#39;t create symbols for array</span>
<a name="l08413"></a>08413 <span class="comment">         types, only for the typedef-to-array types).  If that&#39;s the case,</span>
<a name="l08414"></a>08414 <span class="comment">         strip the typedef layer.  */</span>
<a name="l08415"></a>08415       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type1) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>)
<a name="l08416"></a>08416         type1 = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type1);
<a name="l08417"></a>08417 
<a name="l08418"></a>08418       <span class="keywordflow">return</span> type1;
<a name="l08419"></a>08419     }
<a name="l08420"></a>08420 }
<a name="l08421"></a>08421 
<a name="l08422"></a>08422 <span class="comment">/* A value representing the data at VALADDR/ADDRESS as described by</span>
<a name="l08423"></a>08423 <span class="comment">   type TYPE0, but with a standard (static-sized) type that correctly</span>
<a name="l08424"></a>08424 <span class="comment">   describes it.  If VAL0 is not NULL and TYPE0 already is a standard</span>
<a name="l08425"></a>08425 <span class="comment">   type, then return VAL0 [this feature is simply to avoid redundant</span>
<a name="l08426"></a>08426 <span class="comment">   creation of struct values].  */</span>
<a name="l08427"></a>08427 
<a name="l08428"></a>08428 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l08429"></a>08429 ada_to_fixed_value_create (<span class="keyword">struct</span> type *type0, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address,
<a name="l08430"></a>08430                            <span class="keyword">struct</span> value *val0)
<a name="l08431"></a>08431 {
<a name="l08432"></a>08432   <span class="keyword">struct </span>type *type = <a class="code" href="ada-lang_8c.html#a0096e64d1590f0b629f4a8ca484bddbd">ada_to_fixed_type</a> (type0, 0, address, NULL, 1);
<a name="l08433"></a>08433 
<a name="l08434"></a>08434   <span class="keywordflow">if</span> (type == type0 &amp;&amp; val0 != NULL)
<a name="l08435"></a>08435     <span class="keywordflow">return</span> val0;
<a name="l08436"></a>08436   <span class="keywordflow">else</span>
<a name="l08437"></a>08437     <span class="keywordflow">return</span> <a class="code" href="value_8c.html#ab189fd2d8ea1fe71f000581289a20e17">value_from_contents_and_address</a> (type, 0, address);
<a name="l08438"></a>08438 }
<a name="l08439"></a>08439 
<a name="l08440"></a>08440 <span class="comment">/* A value representing VAL, but with a standard (static-sized) type</span>
<a name="l08441"></a>08441 <span class="comment">   that correctly describes it.  Does not necessarily create a new</span>
<a name="l08442"></a>08442 <span class="comment">   value.  */</span>
<a name="l08443"></a>08443 
<a name="l08444"></a>08444 <span class="keyword">struct </span>value *
<a name="l08445"></a><a class="code" href="ada-lang_8h.html#aff7bccfb43d0188dfaf758dffe8b58ce">08445</a> <a class="code" href="ada-lang_8c.html#aff7bccfb43d0188dfaf758dffe8b58ce">ada_to_fixed_value</a> (<span class="keyword">struct</span> value *val)
<a name="l08446"></a>08446 {
<a name="l08447"></a>08447   val = unwrap_value (val);
<a name="l08448"></a>08448   val = ada_to_fixed_value_create (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val),
<a name="l08449"></a>08449                                       <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (val),
<a name="l08450"></a>08450                                       val);
<a name="l08451"></a>08451   <span class="keywordflow">return</span> val;
<a name="l08452"></a>08452 }
<a name="l08453"></a>08453 
<a name="l08454"></a>08454 
<a name="l08455"></a>08455 <span class="comment">/* Attributes */</span>
<a name="l08456"></a>08456 
<a name="l08457"></a>08457 <span class="comment">/* Table mapping attribute numbers to names.</span>
<a name="l08458"></a>08458 <span class="comment">   NOTE: Keep up to date with enum ada_attribute definition in ada-lang.h.  */</span>
<a name="l08459"></a>08459 
<a name="l08460"></a>08460 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *attribute_names[] = {
<a name="l08461"></a>08461   <span class="stringliteral">&quot;&lt;?&gt;&quot;</span>,
<a name="l08462"></a>08462 
<a name="l08463"></a>08463   <span class="stringliteral">&quot;first&quot;</span>,
<a name="l08464"></a>08464   <span class="stringliteral">&quot;last&quot;</span>,
<a name="l08465"></a>08465   <span class="stringliteral">&quot;length&quot;</span>,
<a name="l08466"></a>08466   <span class="stringliteral">&quot;image&quot;</span>,
<a name="l08467"></a>08467   <span class="stringliteral">&quot;max&quot;</span>,
<a name="l08468"></a>08468   <span class="stringliteral">&quot;min&quot;</span>,
<a name="l08469"></a>08469   <span class="stringliteral">&quot;modulus&quot;</span>,
<a name="l08470"></a>08470   <span class="stringliteral">&quot;pos&quot;</span>,
<a name="l08471"></a>08471   <span class="stringliteral">&quot;size&quot;</span>,
<a name="l08472"></a>08472   <span class="stringliteral">&quot;tag&quot;</span>,
<a name="l08473"></a>08473   <span class="stringliteral">&quot;val&quot;</span>,
<a name="l08474"></a>08474   0
<a name="l08475"></a>08475 };
<a name="l08476"></a>08476 
<a name="l08477"></a>08477 <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l08478"></a><a class="code" href="ada-lang_8h.html#a4d45688684fe71d122d4c79f563bae73">08478</a> <a class="code" href="ada-lang_8c.html#a2dc67804b48707c5176aac961d80e83f">ada_attribute_name</a> (<span class="keyword">enum</span> <a class="code" href="expression_8h.html#a13f8bfc7b2a183fe56716508bfddae41">exp_opcode</a> n)
<a name="l08479"></a>08479 {
<a name="l08480"></a>08480   <span class="keywordflow">if</span> (n &gt;= OP_ATR_FIRST &amp;&amp; n &lt;= (<span class="keywordtype">int</span>) OP_ATR_VAL)
<a name="l08481"></a>08481     <span class="keywordflow">return</span> attribute_names[n - OP_ATR_FIRST + 1];
<a name="l08482"></a>08482   <span class="keywordflow">else</span>
<a name="l08483"></a>08483     <span class="keywordflow">return</span> attribute_names[0];
<a name="l08484"></a>08484 }
<a name="l08485"></a>08485 
<a name="l08486"></a>08486 <span class="comment">/* Evaluate the &#39;POS attribute applied to ARG.  */</span>
<a name="l08487"></a>08487 
<a name="l08488"></a>08488 <span class="keyword">static</span> <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l08489"></a>08489 pos_atr (<span class="keyword">struct</span> value *arg)
<a name="l08490"></a>08490 {
<a name="l08491"></a>08491   <span class="keyword">struct </span>value *val = <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (arg);
<a name="l08492"></a>08492   <span class="keyword">struct </span>type *type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val);
<a name="l08493"></a>08493 
<a name="l08494"></a>08494   <span class="keywordflow">if</span> (!discrete_type_p (type))
<a name="l08495"></a>08495     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;&#39;POS only defined on discrete types&quot;</span>));
<a name="l08496"></a>08496 
<a name="l08497"></a>08497   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>)
<a name="l08498"></a>08498     {
<a name="l08499"></a>08499       <span class="keywordtype">int</span> i;
<a name="l08500"></a>08500       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> v = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (val);
<a name="l08501"></a>08501 
<a name="l08502"></a>08502       <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type); i += 1)
<a name="l08503"></a>08503         {
<a name="l08504"></a>08504           <span class="keywordflow">if</span> (v == <a class="code" href="gdbtypes_8h.html#a2ab26ef1ee13615e128e3cb3cd058a5c">TYPE_FIELD_ENUMVAL</a> (type, i))
<a name="l08505"></a>08505             <span class="keywordflow">return</span> i;
<a name="l08506"></a>08506         }
<a name="l08507"></a>08507       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;enumeration value is invalid: can&#39;t find &#39;POS&quot;</span>));
<a name="l08508"></a>08508     }
<a name="l08509"></a>08509   <span class="keywordflow">else</span>
<a name="l08510"></a>08510     <span class="keywordflow">return</span> <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (val);
<a name="l08511"></a>08511 }
<a name="l08512"></a>08512 
<a name="l08513"></a>08513 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l08514"></a>08514 value_pos_atr (<span class="keyword">struct</span> type *type, <span class="keyword">struct</span> value *arg)
<a name="l08515"></a>08515 {
<a name="l08516"></a>08516   <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, pos_atr (arg));
<a name="l08517"></a>08517 }
<a name="l08518"></a>08518 
<a name="l08519"></a>08519 <span class="comment">/* Evaluate the TYPE&#39;VAL attribute applied to ARG.  */</span>
<a name="l08520"></a>08520 
<a name="l08521"></a>08521 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l08522"></a>08522 value_val_atr (<span class="keyword">struct</span> type *type, <span class="keyword">struct</span> value *arg)
<a name="l08523"></a>08523 {
<a name="l08524"></a>08524   <span class="keywordflow">if</span> (!discrete_type_p (type))
<a name="l08525"></a>08525     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;&#39;VAL only defined on discrete types&quot;</span>));
<a name="l08526"></a>08526   <span class="keywordflow">if</span> (!integer_type_p (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg)))
<a name="l08527"></a>08527     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;&#39;VAL requires integral argument&quot;</span>));
<a name="l08528"></a>08528 
<a name="l08529"></a>08529   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>)
<a name="l08530"></a>08530     {
<a name="l08531"></a>08531       <span class="keywordtype">long</span> pos = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg);
<a name="l08532"></a>08532 
<a name="l08533"></a>08533       <span class="keywordflow">if</span> (pos &lt; 0 || pos &gt;= <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type))
<a name="l08534"></a>08534         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;argument to &#39;VAL out of range&quot;</span>));
<a name="l08535"></a>08535       <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, <a class="code" href="gdbtypes_8h.html#a2ab26ef1ee13615e128e3cb3cd058a5c">TYPE_FIELD_ENUMVAL</a> (type, pos));
<a name="l08536"></a>08536     }
<a name="l08537"></a>08537   <span class="keywordflow">else</span>
<a name="l08538"></a>08538     <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg));
<a name="l08539"></a>08539 }
<a name="l08540"></a>08540 
<a name="l08541"></a>08541 
<a name="l08542"></a>08542                                 <span class="comment">/* Evaluation */</span>
<a name="l08543"></a>08543 
<a name="l08544"></a>08544 <span class="comment">/* True if TYPE appears to be an Ada character type.</span>
<a name="l08545"></a>08545 <span class="comment">   [At the moment, this is true only for Character and Wide_Character;</span>
<a name="l08546"></a>08546 <span class="comment">   It is a heuristic test that could stand improvement].  */</span>
<a name="l08547"></a>08547 
<a name="l08548"></a>08548 <span class="keywordtype">int</span>
<a name="l08549"></a><a class="code" href="ada-lang_8h.html#a397999e12fb22d08fea6450263d01b55">08549</a> <a class="code" href="ada-lang_8c.html#a2e175e8fc440c3d89695db478167f098">ada_is_character_type</a> (<span class="keyword">struct</span> type *type)
<a name="l08550"></a>08550 {
<a name="l08551"></a>08551   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l08552"></a>08552 
<a name="l08553"></a>08553   <span class="comment">/* If the type code says it&#39;s a character, then assume it really is,</span>
<a name="l08554"></a>08554 <span class="comment">     and don&#39;t check any further.  */</span>
<a name="l08555"></a>08555   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae991dd7ea70631f3e1b67a1a75020b5f">TYPE_CODE_CHAR</a>)
<a name="l08556"></a>08556     <span class="keywordflow">return</span> 1;
<a name="l08557"></a>08557   
<a name="l08558"></a>08558   <span class="comment">/* Otherwise, assume it&#39;s a character type iff it is a discrete type</span>
<a name="l08559"></a>08559 <span class="comment">     with a known character type name.  */</span>
<a name="l08560"></a>08560   name = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type);
<a name="l08561"></a>08561   <span class="keywordflow">return</span> (name != NULL
<a name="l08562"></a>08562           &amp;&amp; (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>
<a name="l08563"></a>08563               || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>)
<a name="l08564"></a>08564           &amp;&amp; (strcmp (name, <span class="stringliteral">&quot;character&quot;</span>) == 0
<a name="l08565"></a>08565               || strcmp (name, <span class="stringliteral">&quot;wide_character&quot;</span>) == 0
<a name="l08566"></a>08566               || strcmp (name, <span class="stringliteral">&quot;wide_wide_character&quot;</span>) == 0
<a name="l08567"></a>08567               || strcmp (name, <span class="stringliteral">&quot;unsigned char&quot;</span>) == 0));
<a name="l08568"></a>08568 }
<a name="l08569"></a>08569 
<a name="l08570"></a>08570 <span class="comment">/* True if TYPE appears to be an Ada string type.  */</span>
<a name="l08571"></a>08571 
<a name="l08572"></a>08572 <span class="keywordtype">int</span>
<a name="l08573"></a><a class="code" href="ada-lang_8h.html#a103f774c2e4ae0a95b622467d32f30a5">08573</a> <a class="code" href="ada-lang_8c.html#a18f24b5d515fb07617cf7905f26d9067">ada_is_string_type</a> (<span class="keyword">struct</span> type *type)
<a name="l08574"></a>08574 {
<a name="l08575"></a>08575   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l08576"></a>08576   <span class="keywordflow">if</span> (type != NULL
<a name="l08577"></a>08577       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l08578"></a>08578       &amp;&amp; (<a class="code" href="ada-lang_8c.html#a98ee7e79620d6af77ffd35c586fcf7bd">ada_is_simple_array_type</a> (type)
<a name="l08579"></a>08579           || <a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (type))
<a name="l08580"></a>08580       &amp;&amp; <a class="code" href="ada-lang_8c.html#ae9a1f2e16ad116a02636b91afd809c4b">ada_array_arity</a> (type) == 1)
<a name="l08581"></a>08581     {
<a name="l08582"></a>08582       <span class="keyword">struct </span>type *elttype = <a class="code" href="ada-lang_8c.html#a6d2b3240a3d6eabb276131b5753e804e">ada_array_element_type</a> (type, 1);
<a name="l08583"></a>08583 
<a name="l08584"></a>08584       <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a2e175e8fc440c3d89695db478167f098">ada_is_character_type</a> (elttype);
<a name="l08585"></a>08585     }
<a name="l08586"></a>08586   <span class="keywordflow">else</span>
<a name="l08587"></a>08587     <span class="keywordflow">return</span> 0;
<a name="l08588"></a>08588 }
<a name="l08589"></a>08589 
<a name="l08590"></a>08590 <span class="comment">/* The compiler sometimes provides a parallel XVS type for a given</span>
<a name="l08591"></a>08591 <span class="comment">   PAD type.  Normally, it is safe to follow the PAD type directly,</span>
<a name="l08592"></a>08592 <span class="comment">   but older versions of the compiler have a bug that causes the offset</span>
<a name="l08593"></a>08593 <span class="comment">   of its &quot;F&quot; field to be wrong.  Following that field in that case</span>
<a name="l08594"></a>08594 <span class="comment">   would lead to incorrect results, but this can be worked around</span>
<a name="l08595"></a>08595 <span class="comment">   by ignoring the PAD type and using the associated XVS type instead.</span>
<a name="l08596"></a>08596 <span class="comment"></span>
<a name="l08597"></a>08597 <span class="comment">   Set to True if the debugger should trust the contents of PAD types.</span>
<a name="l08598"></a>08598 <span class="comment">   Otherwise, ignore the PAD type if there is a parallel XVS type.  */</span>
<a name="l08599"></a>08599 <span class="keyword">static</span> <span class="keywordtype">int</span> trust_pad_over_xvs = 1;
<a name="l08600"></a>08600 
<a name="l08601"></a>08601 <span class="comment">/* True if TYPE is a struct type introduced by the compiler to force the</span>
<a name="l08602"></a>08602 <span class="comment">   alignment of a value.  Such types have a single field with a</span>
<a name="l08603"></a>08603 <span class="comment">   distinctive name.  */</span>
<a name="l08604"></a>08604 
<a name="l08605"></a>08605 <span class="keywordtype">int</span>
<a name="l08606"></a><a class="code" href="ada-lang_8h.html#ace55557124b6737c59988a50192585ae">08606</a> <a class="code" href="ada-lang_8c.html#ac972c52cf860cdffae561d774c2f3258">ada_is_aligner_type</a> (<span class="keyword">struct</span> type *type)
<a name="l08607"></a>08607 {
<a name="l08608"></a>08608   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l08609"></a>08609 
<a name="l08610"></a>08610   <span class="keywordflow">if</span> (!trust_pad_over_xvs &amp;&amp; <a class="code" href="ada-lang_8c.html#ade263e735047904b7eabe725cd6cc2f9">ada_find_parallel_type</a> (type, <span class="stringliteral">&quot;___XVS&quot;</span>) != NULL)
<a name="l08611"></a>08611     <span class="keywordflow">return</span> 0;
<a name="l08612"></a>08612 
<a name="l08613"></a>08613   <span class="keywordflow">return</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l08614"></a>08614           &amp;&amp; <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (type) == 1
<a name="l08615"></a>08615           &amp;&amp; strcmp (<a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (type, 0), <span class="stringliteral">&quot;F&quot;</span>) == 0);
<a name="l08616"></a>08616 }
<a name="l08617"></a>08617 
<a name="l08618"></a>08618 <span class="comment">/* If there is an ___XVS-convention type parallel to SUBTYPE, return</span>
<a name="l08619"></a>08619 <span class="comment">   the parallel type.  */</span>
<a name="l08620"></a>08620 
<a name="l08621"></a>08621 <span class="keyword">struct </span>type *
<a name="l08622"></a><a class="code" href="ada-lang_8h.html#a29bcba9d67c6732dea93b0e243427e36">08622</a> <a class="code" href="ada-lang_8c.html#aac42a4c75acced2b75b65874ef51ead8">ada_get_base_type</a> (<span class="keyword">struct</span> type *raw_type)
<a name="l08623"></a>08623 {
<a name="l08624"></a>08624   <span class="keyword">struct </span>type *real_type_namer;
<a name="l08625"></a>08625   <span class="keyword">struct </span>type *raw_real_type;
<a name="l08626"></a>08626 
<a name="l08627"></a>08627   <span class="keywordflow">if</span> (raw_type == NULL || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (raw_type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>)
<a name="l08628"></a>08628     <span class="keywordflow">return</span> raw_type;
<a name="l08629"></a>08629 
<a name="l08630"></a>08630   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ac972c52cf860cdffae561d774c2f3258">ada_is_aligner_type</a> (raw_type))
<a name="l08631"></a>08631     <span class="comment">/* The encoding specifies that we should always use the aligner type.</span>
<a name="l08632"></a>08632 <span class="comment">       So, even if this aligner type has an associated XVS type, we should</span>
<a name="l08633"></a>08633 <span class="comment">       simply ignore it.</span>
<a name="l08634"></a>08634 <span class="comment"></span>
<a name="l08635"></a>08635 <span class="comment">       According to the compiler gurus, an XVS type parallel to an aligner</span>
<a name="l08636"></a>08636 <span class="comment">       type may exist because of a stabs limitation.  In stabs, aligner</span>
<a name="l08637"></a>08637 <span class="comment">       types are empty because the field has a variable-sized type, and</span>
<a name="l08638"></a>08638 <span class="comment">       thus cannot actually be used as an aligner type.  As a result,</span>
<a name="l08639"></a>08639 <span class="comment">       we need the associated parallel XVS type to decode the type.</span>
<a name="l08640"></a>08640 <span class="comment">       Since the policy in the compiler is to not change the internal</span>
<a name="l08641"></a>08641 <span class="comment">       representation based on the debugging info format, we sometimes</span>
<a name="l08642"></a>08642 <span class="comment">       end up having a redundant XVS type parallel to the aligner type.  */</span>
<a name="l08643"></a>08643     <span class="keywordflow">return</span> raw_type;
<a name="l08644"></a>08644 
<a name="l08645"></a>08645   real_type_namer = <a class="code" href="ada-lang_8c.html#ade263e735047904b7eabe725cd6cc2f9">ada_find_parallel_type</a> (raw_type, <span class="stringliteral">&quot;___XVS&quot;</span>);
<a name="l08646"></a>08646   <span class="keywordflow">if</span> (real_type_namer == NULL
<a name="l08647"></a>08647       || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (real_type_namer) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l08648"></a>08648       || <a class="code" href="gdbtypes_8h.html#a2872fd7f60b18f9cf1ed3227fc4441cd">TYPE_NFIELDS</a> (real_type_namer) != 1)
<a name="l08649"></a>08649     <span class="keywordflow">return</span> raw_type;
<a name="l08650"></a>08650 
<a name="l08651"></a>08651   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (real_type_namer, 0)) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l08652"></a>08652     {
<a name="l08653"></a>08653       <span class="comment">/* This is an older encoding form where the base type needs to be</span>
<a name="l08654"></a>08654 <span class="comment">         looked up by name.  We prefer the newer enconding because it is</span>
<a name="l08655"></a>08655 <span class="comment">         more efficient.  */</span>
<a name="l08656"></a>08656       raw_real_type = ada_find_any_type (<a class="code" href="gdbtypes_8h.html#a01947c4de3aced365e02aa6e8e6a9dc3">TYPE_FIELD_NAME</a> (real_type_namer, 0));
<a name="l08657"></a>08657       <span class="keywordflow">if</span> (raw_real_type == NULL)
<a name="l08658"></a>08658         <span class="keywordflow">return</span> raw_type;
<a name="l08659"></a>08659       <span class="keywordflow">else</span>
<a name="l08660"></a>08660         <span class="keywordflow">return</span> raw_real_type;
<a name="l08661"></a>08661     }
<a name="l08662"></a>08662 
<a name="l08663"></a>08663   <span class="comment">/* The field in our XVS type is a reference to the base type.  */</span>
<a name="l08664"></a>08664   <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (real_type_namer, 0));
<a name="l08665"></a>08665 }
<a name="l08666"></a>08666 
<a name="l08667"></a>08667 <span class="comment">/* The type of value designated by TYPE, with all aligners removed.  */</span>
<a name="l08668"></a>08668 
<a name="l08669"></a>08669 <span class="keyword">struct </span>type *
<a name="l08670"></a><a class="code" href="ada-lang_8h.html#a385d5d3c68cf91a7f37c307476378c70">08670</a> <a class="code" href="ada-lang_8c.html#a67d9e8121909114afa44a208819f932f">ada_aligned_type</a> (<span class="keyword">struct</span> type *type)
<a name="l08671"></a>08671 {
<a name="l08672"></a>08672   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ac972c52cf860cdffae561d774c2f3258">ada_is_aligner_type</a> (type))
<a name="l08673"></a>08673     <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a67d9e8121909114afa44a208819f932f">ada_aligned_type</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, 0));
<a name="l08674"></a>08674   <span class="keywordflow">else</span>
<a name="l08675"></a>08675     <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#aac42a4c75acced2b75b65874ef51ead8">ada_get_base_type</a> (type);
<a name="l08676"></a>08676 }
<a name="l08677"></a>08677 
<a name="l08678"></a>08678 
<a name="l08679"></a>08679 <span class="comment">/* The address of the aligned value in an object at address VALADDR</span>
<a name="l08680"></a>08680 <span class="comment">   having type TYPE.  Assumes ada_is_aligner_type (TYPE).  */</span>
<a name="l08681"></a>08681 
<a name="l08682"></a>08682 <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *
<a name="l08683"></a><a class="code" href="ada-lang_8h.html#a3fcd626cae6142431aa5d10f82ce0741">08683</a> <a class="code" href="ada-lang_8c.html#a94887786e219d8980c1905e1be7f0d12">ada_aligned_value_addr</a> (<span class="keyword">struct</span> type *type, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *valaddr)
<a name="l08684"></a>08684 {
<a name="l08685"></a>08685   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ac972c52cf860cdffae561d774c2f3258">ada_is_aligner_type</a> (type))
<a name="l08686"></a>08686     <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a94887786e219d8980c1905e1be7f0d12">ada_aligned_value_addr</a> (<a class="code" href="gdbtypes_8h.html#a57f5958d4f2803d1e17748bcfa9c23c3">TYPE_FIELD_TYPE</a> (type, 0),
<a name="l08687"></a>08687                                    valaddr +
<a name="l08688"></a>08688                                    <a class="code" href="gdbtypes_8h.html#a676725f445f8fc5dad99cd215778b3a4">TYPE_FIELD_BITPOS</a> (type,
<a name="l08689"></a>08689                                                       0) / TARGET_CHAR_BIT);
<a name="l08690"></a>08690   <span class="keywordflow">else</span>
<a name="l08691"></a>08691     <span class="keywordflow">return</span> valaddr;
<a name="l08692"></a>08692 }
<a name="l08693"></a>08693 
<a name="l08694"></a>08694 
<a name="l08695"></a>08695 
<a name="l08696"></a>08696 <span class="comment">/* The printed representation of an enumeration literal with encoded</span>
<a name="l08697"></a>08697 <span class="comment">   name NAME.  The value is good to the next call of ada_enum_name.  */</span>
<a name="l08698"></a>08698 <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l08699"></a><a class="code" href="ada-lang_8h.html#a9260e52392937c7cf61c44e0e5c664e0">08699</a> <a class="code" href="ada-lang_8c.html#a42b8ed6c09b88e538db74d2b6013e09f">ada_enum_name</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l08700"></a>08700 {
<a name="l08701"></a>08701   <span class="keyword">static</span> <span class="keywordtype">char</span> *result;
<a name="l08702"></a>08702   <span class="keyword">static</span> <span class="keywordtype">size_t</span> result_len = 0;
<a name="l08703"></a>08703   <span class="keywordtype">char</span> *tmp;
<a name="l08704"></a>08704 
<a name="l08705"></a>08705   <span class="comment">/* First, unqualify the enumeration name:</span>
<a name="l08706"></a>08706 <span class="comment">     1. Search for the last &#39;.&#39; character.  If we find one, then skip</span>
<a name="l08707"></a>08707 <span class="comment">     all the preceding characters, the unqualified name starts</span>
<a name="l08708"></a>08708 <span class="comment">     right after that dot.</span>
<a name="l08709"></a>08709 <span class="comment">     2. Otherwise, we may be debugging on a target where the compiler</span>
<a name="l08710"></a>08710 <span class="comment">     translates dots into &quot;__&quot;.  Search forward for double underscores,</span>
<a name="l08711"></a>08711 <span class="comment">     but stop searching when we hit an overloading suffix, which is</span>
<a name="l08712"></a>08712 <span class="comment">     of the form &quot;__&quot; followed by digits.  */</span>
<a name="l08713"></a>08713 
<a name="l08714"></a>08714   tmp = <a class="code" href="gdb__string_8h.html#a5cbb8bbfc7174d9468b1853f1031efb3">strrchr</a> (name, <span class="charliteral">&#39;.&#39;</span>);
<a name="l08715"></a>08715   <span class="keywordflow">if</span> (tmp != NULL)
<a name="l08716"></a>08716     name = tmp + 1;
<a name="l08717"></a>08717   <span class="keywordflow">else</span>
<a name="l08718"></a>08718     {
<a name="l08719"></a>08719       <span class="keywordflow">while</span> ((tmp = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (name, <span class="stringliteral">&quot;__&quot;</span>)) != NULL)
<a name="l08720"></a>08720         {
<a name="l08721"></a>08721           <span class="keywordflow">if</span> (isdigit (tmp[2]))
<a name="l08722"></a>08722             <span class="keywordflow">break</span>;
<a name="l08723"></a>08723           <span class="keywordflow">else</span>
<a name="l08724"></a>08724             name = tmp + 2;
<a name="l08725"></a>08725         }
<a name="l08726"></a>08726     }
<a name="l08727"></a>08727 
<a name="l08728"></a>08728   <span class="keywordflow">if</span> (name[0] == <span class="charliteral">&#39;Q&#39;</span>)
<a name="l08729"></a>08729     {
<a name="l08730"></a>08730       <span class="keywordtype">int</span> v;
<a name="l08731"></a>08731 
<a name="l08732"></a>08732       <span class="keywordflow">if</span> (name[1] == <span class="charliteral">&#39;U&#39;</span> || name[1] == <span class="charliteral">&#39;W&#39;</span>)
<a name="l08733"></a>08733         {
<a name="l08734"></a>08734           <span class="keywordflow">if</span> (sscanf (name + 2, <span class="stringliteral">&quot;%x&quot;</span>, &amp;v) != 1)
<a name="l08735"></a>08735             <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l08736"></a>08736         }
<a name="l08737"></a>08737       <span class="keywordflow">else</span>
<a name="l08738"></a>08738         <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l08739"></a>08739 
<a name="l08740"></a>08740       <a class="code" href="ada-lang_8h.html#a48e9e90d45825a693f1690a4ebcb2a1e">GROW_VECT</a> (result, result_len, 16);
<a name="l08741"></a>08741       <span class="keywordflow">if</span> (isascii (v) &amp;&amp; isprint (v))
<a name="l08742"></a>08742         <a class="code" href="common-utils_8c.html#ad9940337ec98983dae9951c947879fc8">xsnprintf</a> (result, result_len, <span class="stringliteral">&quot;&#39;%c&#39;&quot;</span>, v);
<a name="l08743"></a>08743       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name[1] == <span class="charliteral">&#39;U&#39;</span>)
<a name="l08744"></a>08744         <a class="code" href="common-utils_8c.html#ad9940337ec98983dae9951c947879fc8">xsnprintf</a> (result, result_len, <span class="stringliteral">&quot;[\&quot;%02x\&quot;]&quot;</span>, v);
<a name="l08745"></a>08745       <span class="keywordflow">else</span>
<a name="l08746"></a>08746         <a class="code" href="common-utils_8c.html#ad9940337ec98983dae9951c947879fc8">xsnprintf</a> (result, result_len, <span class="stringliteral">&quot;[\&quot;%04x\&quot;]&quot;</span>, v);
<a name="l08747"></a>08747 
<a name="l08748"></a>08748       <span class="keywordflow">return</span> result;
<a name="l08749"></a>08749     }
<a name="l08750"></a>08750   <span class="keywordflow">else</span>
<a name="l08751"></a>08751     {
<a name="l08752"></a>08752       tmp = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (name, <span class="stringliteral">&quot;__&quot;</span>);
<a name="l08753"></a>08753       <span class="keywordflow">if</span> (tmp == NULL)
<a name="l08754"></a>08754         tmp = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (name, <span class="stringliteral">&quot;$&quot;</span>);
<a name="l08755"></a>08755       <span class="keywordflow">if</span> (tmp != NULL)
<a name="l08756"></a>08756         {
<a name="l08757"></a>08757           <a class="code" href="ada-lang_8h.html#a48e9e90d45825a693f1690a4ebcb2a1e">GROW_VECT</a> (result, result_len, tmp - name + 1);
<a name="l08758"></a>08758           strncpy (result, name, tmp - name);
<a name="l08759"></a>08759           result[tmp - <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l08760"></a>08760           <span class="keywordflow">return</span> result;
<a name="l08761"></a>08761         }
<a name="l08762"></a>08762 
<a name="l08763"></a>08763       <span class="keywordflow">return</span> <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l08764"></a>08764     }
<a name="l08765"></a>08765 }
<a name="l08766"></a>08766 
<a name="l08767"></a>08767 <span class="comment">/* Evaluate the subexpression of EXP starting at *POS as for</span>
<a name="l08768"></a>08768 <span class="comment">   evaluate_type, updating *POS to point just past the evaluated</span>
<a name="l08769"></a>08769 <span class="comment">   expression.  */</span>
<a name="l08770"></a>08770 
<a name="l08771"></a>08771 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l08772"></a>08772 evaluate_subexp_type (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp, <span class="keywordtype">int</span> *pos)
<a name="l08773"></a>08773 {
<a name="l08774"></a>08774   <span class="keywordflow">return</span> <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>);
<a name="l08775"></a>08775 }
<a name="l08776"></a>08776 
<a name="l08777"></a>08777 <span class="comment">/* If VAL is wrapped in an aligner or subtype wrapper, return the</span>
<a name="l08778"></a>08778 <span class="comment">   value it wraps.  */</span>
<a name="l08779"></a>08779 
<a name="l08780"></a>08780 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l08781"></a>08781 unwrap_value (<span class="keyword">struct</span> value *val)
<a name="l08782"></a>08782 {
<a name="l08783"></a>08783   <span class="keyword">struct </span>type *type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val));
<a name="l08784"></a>08784 
<a name="l08785"></a>08785   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ac972c52cf860cdffae561d774c2f3258">ada_is_aligner_type</a> (type))
<a name="l08786"></a>08786     {
<a name="l08787"></a>08787       <span class="keyword">struct </span>value *v = <a class="code" href="ada-lang_8c.html#a9d3934026567a1840970ca108755b6e9">ada_value_struct_elt</a> (val, <span class="stringliteral">&quot;F&quot;</span>, 0);
<a name="l08788"></a>08788       <span class="keyword">struct </span>type *val_type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (v));
<a name="l08789"></a>08789 
<a name="l08790"></a>08790       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (val_type) == NULL)
<a name="l08791"></a>08791         <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (val_type) = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type);
<a name="l08792"></a>08792 
<a name="l08793"></a>08793       <span class="keywordflow">return</span> unwrap_value (v);
<a name="l08794"></a>08794     }
<a name="l08795"></a>08795   <span class="keywordflow">else</span>
<a name="l08796"></a>08796     {
<a name="l08797"></a>08797       <span class="keyword">struct </span>type *raw_real_type =
<a name="l08798"></a>08798         <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="ada-lang_8c.html#aac42a4c75acced2b75b65874ef51ead8">ada_get_base_type</a> (type));
<a name="l08799"></a>08799 
<a name="l08800"></a>08800       <span class="comment">/* If there is no parallel XVS or XVE type, then the value is</span>
<a name="l08801"></a>08801 <span class="comment">         already unwrapped.  Return it without further modification.  */</span>
<a name="l08802"></a>08802       <span class="keywordflow">if</span> ((type == raw_real_type)
<a name="l08803"></a>08803           &amp;&amp; <a class="code" href="ada-lang_8c.html#ade263e735047904b7eabe725cd6cc2f9">ada_find_parallel_type</a> (type, <span class="stringliteral">&quot;___XVE&quot;</span>) == NULL)
<a name="l08804"></a>08804         <span class="keywordflow">return</span> val;
<a name="l08805"></a>08805 
<a name="l08806"></a>08806       <span class="keywordflow">return</span>
<a name="l08807"></a>08807         coerce_unspec_val_to_type
<a name="l08808"></a>08808         (val, <a class="code" href="ada-lang_8c.html#a0096e64d1590f0b629f4a8ca484bddbd">ada_to_fixed_type</a> (raw_real_type, 0,
<a name="l08809"></a>08809                                  <a class="code" href="value_8c.html#a64c795fa1a8854682b3b727025d0d31d">value_address</a> (val),
<a name="l08810"></a>08810                                  NULL, 1));
<a name="l08811"></a>08811     }
<a name="l08812"></a>08812 }
<a name="l08813"></a>08813 
<a name="l08814"></a>08814 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l08815"></a>08815 cast_to_fixed (<span class="keyword">struct</span> type *type, <span class="keyword">struct</span> value *arg)
<a name="l08816"></a>08816 {
<a name="l08817"></a>08817   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> val;
<a name="l08818"></a>08818 
<a name="l08819"></a>08819   <span class="keywordflow">if</span> (type == <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg))
<a name="l08820"></a>08820     <span class="keywordflow">return</span> arg;
<a name="l08821"></a>08821   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#afe50295540937b9ae0f68f2be4794f18">ada_is_fixed_point_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg)))
<a name="l08822"></a>08822     val = <a class="code" href="ada-lang_8c.html#aad289c0819a5f43573ff9c638190d7a0">ada_float_to_fixed</a> (type,
<a name="l08823"></a>08823                               <a class="code" href="ada-lang_8c.html#a0a599a683dbfa3b513b0bd6e1072f422">ada_fixed_to_float</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg),
<a name="l08824"></a>08824                                                   <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg)));
<a name="l08825"></a>08825   <span class="keywordflow">else</span>
<a name="l08826"></a>08826     {
<a name="l08827"></a>08827       <a class="code" href="doublest_8h.html#ac1812677a2f11158956252854ec47a77">DOUBLEST</a> argd = <a class="code" href="value_8c.html#a70cb29f1d53150216cc7816d93b8b115">value_as_double</a> (arg);
<a name="l08828"></a>08828 
<a name="l08829"></a>08829       val = <a class="code" href="ada-lang_8c.html#aad289c0819a5f43573ff9c638190d7a0">ada_float_to_fixed</a> (type, argd);
<a name="l08830"></a>08830     }
<a name="l08831"></a>08831 
<a name="l08832"></a>08832   <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, val);
<a name="l08833"></a>08833 }
<a name="l08834"></a>08834 
<a name="l08835"></a>08835 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l08836"></a>08836 cast_from_fixed (<span class="keyword">struct</span> type *type, <span class="keyword">struct</span> value *arg)
<a name="l08837"></a>08837 {
<a name="l08838"></a>08838   <a class="code" href="doublest_8h.html#ac1812677a2f11158956252854ec47a77">DOUBLEST</a> val = <a class="code" href="ada-lang_8c.html#a0a599a683dbfa3b513b0bd6e1072f422">ada_fixed_to_float</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg),
<a name="l08839"></a>08839                                      <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg));
<a name="l08840"></a>08840 
<a name="l08841"></a>08841   <span class="keywordflow">return</span> <a class="code" href="value_8c.html#ac2cf5b8fa401dbfc4c1fb505b002c0bf">value_from_double</a> (type, val);
<a name="l08842"></a>08842 }
<a name="l08843"></a>08843 
<a name="l08844"></a>08844 <span class="comment">/* Given two array types T1 and T2, return nonzero iff both arrays</span>
<a name="l08845"></a>08845 <span class="comment">   contain the same number of elements.  */</span>
<a name="l08846"></a>08846 
<a name="l08847"></a>08847 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l08848"></a>08848 ada_same_array_size_p (<span class="keyword">struct</span> type *t1, <span class="keyword">struct</span> type *t2)
<a name="l08849"></a>08849 {
<a name="l08850"></a>08850   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> lo1, hi1, lo2, hi2;
<a name="l08851"></a>08851 
<a name="l08852"></a>08852   <span class="comment">/* Get the array bounds in order to verify that the size of</span>
<a name="l08853"></a>08853 <span class="comment">     the two arrays match.  */</span>
<a name="l08854"></a>08854   <span class="keywordflow">if</span> (!<a class="code" href="gdbtypes_8c.html#a499d94cb3d0212c4f898aa51f264da65">get_array_bounds</a> (t1, &amp;lo1, &amp;hi1)
<a name="l08855"></a>08855       || !<a class="code" href="gdbtypes_8c.html#a499d94cb3d0212c4f898aa51f264da65">get_array_bounds</a> (t2, &amp;lo2, &amp;hi2))
<a name="l08856"></a>08856     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unable to determine array bounds&quot;</span>));
<a name="l08857"></a>08857 
<a name="l08858"></a>08858   <span class="comment">/* To make things easier for size comparison, normalize a bit</span>
<a name="l08859"></a>08859 <span class="comment">     the case of empty arrays by making sure that the difference</span>
<a name="l08860"></a>08860 <span class="comment">     between upper bound and lower bound is always -1.  */</span>
<a name="l08861"></a>08861   <span class="keywordflow">if</span> (lo1 &gt; hi1)
<a name="l08862"></a>08862     hi1 = lo1 - 1;
<a name="l08863"></a>08863   <span class="keywordflow">if</span> (lo2 &gt; hi2)
<a name="l08864"></a>08864     hi2 = lo2 - 1;
<a name="l08865"></a>08865 
<a name="l08866"></a>08866   <span class="keywordflow">return</span> (hi1 - lo1 == hi2 - lo2);
<a name="l08867"></a>08867 }
<a name="l08868"></a>08868 
<a name="l08869"></a>08869 <span class="comment">/* Assuming that VAL is an array of integrals, and TYPE represents</span>
<a name="l08870"></a>08870 <span class="comment">   an array with the same number of elements, but with wider integral</span>
<a name="l08871"></a>08871 <span class="comment">   elements, return an array &quot;casted&quot; to TYPE.  In practice, this</span>
<a name="l08872"></a>08872 <span class="comment">   means that the returned array is built by casting each element</span>
<a name="l08873"></a>08873 <span class="comment">   of the original array into TYPE&#39;s (wider) element type.  */</span>
<a name="l08874"></a>08874 
<a name="l08875"></a>08875 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l08876"></a>08876 ada_promote_array_of_integrals (<span class="keyword">struct</span> type *type, <span class="keyword">struct</span> value *val)
<a name="l08877"></a>08877 {
<a name="l08878"></a>08878   <span class="keyword">struct </span>type *elt_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l08879"></a>08879   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> lo, hi;
<a name="l08880"></a>08880   <span class="keyword">struct </span>value *res;
<a name="l08881"></a>08881   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> i;
<a name="l08882"></a>08882 
<a name="l08883"></a>08883   <span class="comment">/* Verify that both val and type are arrays of scalars, and</span>
<a name="l08884"></a>08884 <span class="comment">     that the size of val&#39;s elements is smaller than the size</span>
<a name="l08885"></a>08885 <span class="comment">     of type&#39;s element.  */</span>
<a name="l08886"></a>08886   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>);
<a name="l08887"></a>08887   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8c.html#a292da1df1ddf044d92c8958d304aac2d">is_integral_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)));
<a name="l08888"></a>08888   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>);
<a name="l08889"></a>08889   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8c.html#a292da1df1ddf044d92c8958d304aac2d">is_integral_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val))));
<a name="l08890"></a>08890   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type))
<a name="l08891"></a>08891               &gt; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val))));
<a name="l08892"></a>08892 
<a name="l08893"></a>08893   <span class="keywordflow">if</span> (!<a class="code" href="gdbtypes_8c.html#a499d94cb3d0212c4f898aa51f264da65">get_array_bounds</a> (type, &amp;lo, &amp;hi))
<a name="l08894"></a>08894     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unable to determine array bounds&quot;</span>));
<a name="l08895"></a>08895 
<a name="l08896"></a>08896   res = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (type);
<a name="l08897"></a>08897 
<a name="l08898"></a>08898   <span class="comment">/* Promote each array element.  */</span>
<a name="l08899"></a>08899   <span class="keywordflow">for</span> (i = 0; i &lt; hi - lo + 1; i++)
<a name="l08900"></a>08900     {
<a name="l08901"></a>08901       <span class="keyword">struct </span>value *elt = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (elt_type, <a class="code" href="valarith_8c.html#a7d54cbfda0e6179b9e818951b91916d3">value_subscript</a> (val, lo + i));
<a name="l08902"></a>08902 
<a name="l08903"></a>08903       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="value_8c.html#a13d7c6c06f661cae284e575c50647344">value_contents_writeable</a> (res) + (i * <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (elt_type)),
<a name="l08904"></a>08904               <a class="code" href="value_8c.html#a169102027b7f913a4d387d01d62dbeae">value_contents_all</a> (elt), <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (elt_type));
<a name="l08905"></a>08905     }
<a name="l08906"></a>08906 
<a name="l08907"></a>08907   <span class="keywordflow">return</span> res;
<a name="l08908"></a>08908 }
<a name="l08909"></a>08909 
<a name="l08910"></a>08910 <span class="comment">/* Coerce VAL as necessary for assignment to an lval of type TYPE, and</span>
<a name="l08911"></a>08911 <span class="comment">   return the converted value.  */</span>
<a name="l08912"></a>08912 
<a name="l08913"></a>08913 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l08914"></a>08914 coerce_for_assign (<span class="keyword">struct</span> type *type, <span class="keyword">struct</span> value *val)
<a name="l08915"></a>08915 {
<a name="l08916"></a>08916   <span class="keyword">struct </span>type *type2 = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val);
<a name="l08917"></a>08917 
<a name="l08918"></a>08918   <span class="keywordflow">if</span> (type == type2)
<a name="l08919"></a>08919     <span class="keywordflow">return</span> val;
<a name="l08920"></a>08920 
<a name="l08921"></a>08921   type2 = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type2);
<a name="l08922"></a>08922   type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (type);
<a name="l08923"></a>08923 
<a name="l08924"></a>08924   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type2) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l08925"></a>08925       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l08926"></a>08926     {
<a name="l08927"></a>08927       val = <a class="code" href="ada-lang_8c.html#a917a1ba2a6b58d43803a1f999164295b">ada_value_ind</a> (val);
<a name="l08928"></a>08928       type2 = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val);
<a name="l08929"></a>08929     }
<a name="l08930"></a>08930 
<a name="l08931"></a>08931   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type2) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l08932"></a>08932       &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l08933"></a>08933     {
<a name="l08934"></a>08934       <span class="keywordflow">if</span> (!ada_same_array_size_p (type, type2))
<a name="l08935"></a>08935         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot assign arrays of different length&quot;</span>));
<a name="l08936"></a>08936 
<a name="l08937"></a>08937       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#a292da1df1ddf044d92c8958d304aac2d">is_integral_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type))
<a name="l08938"></a>08938           &amp;&amp; <a class="code" href="gdbtypes_8c.html#a292da1df1ddf044d92c8958d304aac2d">is_integral_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type2))
<a name="l08939"></a>08939           &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type2))
<a name="l08940"></a>08940                &lt; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)))
<a name="l08941"></a>08941         {
<a name="l08942"></a>08942           <span class="comment">/* Allow implicit promotion of the array elements to</span>
<a name="l08943"></a>08943 <span class="comment">             a wider type.  */</span>
<a name="l08944"></a>08944           <span class="keywordflow">return</span> ada_promote_array_of_integrals (type, val);
<a name="l08945"></a>08945         }
<a name="l08946"></a>08946 
<a name="l08947"></a>08947       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type2))
<a name="l08948"></a>08948           != <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type)))
<a name="l08949"></a>08949         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Incompatible types in assignment&quot;</span>));
<a name="l08950"></a>08950       <a class="code" href="value_8c.html#adac1b2d5054e2d7b44ea25ac1f8002f1">deprecated_set_value_type</a> (val, type);
<a name="l08951"></a>08951     }
<a name="l08952"></a>08952   <span class="keywordflow">return</span> val;
<a name="l08953"></a>08953 }
<a name="l08954"></a>08954 
<a name="l08955"></a>08955 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l08956"></a>08956 ada_value_binop (<span class="keyword">struct</span> value *arg1, <span class="keyword">struct</span> value *arg2, <span class="keyword">enum</span> <a class="code" href="expression_8h.html#a13f8bfc7b2a183fe56716508bfddae41">exp_opcode</a> op)
<a name="l08957"></a>08957 {
<a name="l08958"></a>08958   <span class="keyword">struct </span>value *val;
<a name="l08959"></a>08959   <span class="keyword">struct </span>type *type1, *type2;
<a name="l08960"></a>08960   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> v, v1, v2;
<a name="l08961"></a>08961 
<a name="l08962"></a>08962   arg1 = <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (arg1);
<a name="l08963"></a>08963   arg2 = <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (arg2);
<a name="l08964"></a>08964   type1 = get_base_type (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1)));
<a name="l08965"></a>08965   type2 = get_base_type (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2)));
<a name="l08966"></a>08966 
<a name="l08967"></a>08967   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type1) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>
<a name="l08968"></a>08968       || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type2) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>)
<a name="l08969"></a>08969     <span class="keywordflow">return</span> <a class="code" href="valarith_8c.html#ae19c265649cb1b29f4fbda94d76ec495">value_binop</a> (arg1, arg2, op);
<a name="l08970"></a>08970 
<a name="l08971"></a>08971   <span class="keywordflow">switch</span> (op)
<a name="l08972"></a>08972     {
<a name="l08973"></a>08973     <span class="keywordflow">case</span> BINOP_MOD:
<a name="l08974"></a>08974     <span class="keywordflow">case</span> BINOP_DIV:
<a name="l08975"></a>08975     <span class="keywordflow">case</span> BINOP_REM:
<a name="l08976"></a>08976       <span class="keywordflow">break</span>;
<a name="l08977"></a>08977     <span class="keywordflow">default</span>:
<a name="l08978"></a>08978       <span class="keywordflow">return</span> <a class="code" href="valarith_8c.html#ae19c265649cb1b29f4fbda94d76ec495">value_binop</a> (arg1, arg2, op);
<a name="l08979"></a>08979     }
<a name="l08980"></a>08980 
<a name="l08981"></a>08981   v2 = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg2);
<a name="l08982"></a>08982   <span class="keywordflow">if</span> (v2 == 0)
<a name="l08983"></a>08983     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;second operand of %s must not be zero.&quot;</span>), <a class="code" href="expprint_8c.html#a88ba5e07c45b66320c7455a5cb8cb903">op_string</a> (op));
<a name="l08984"></a>08984 
<a name="l08985"></a>08985   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">TYPE_UNSIGNED</a> (type1) || op == BINOP_MOD)
<a name="l08986"></a>08986     <span class="keywordflow">return</span> <a class="code" href="valarith_8c.html#ae19c265649cb1b29f4fbda94d76ec495">value_binop</a> (arg1, arg2, op);
<a name="l08987"></a>08987 
<a name="l08988"></a>08988   v1 = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg1);
<a name="l08989"></a>08989   <span class="keywordflow">switch</span> (op)
<a name="l08990"></a>08990     {
<a name="l08991"></a>08991     <span class="keywordflow">case</span> BINOP_DIV:
<a name="l08992"></a>08992       v = v1 / v2;
<a name="l08993"></a>08993       <span class="keywordflow">if</span> (!<a class="code" href="ada-lang_8c.html#a57a219b3331c740472bbd7ed4124598c">TRUNCATION_TOWARDS_ZERO</a> &amp;&amp; v1 * (v1 % v2) &lt; 0)
<a name="l08994"></a>08994         v += v &gt; 0 ? -1 : 1;
<a name="l08995"></a>08995       <span class="keywordflow">break</span>;
<a name="l08996"></a>08996     <span class="keywordflow">case</span> BINOP_REM:
<a name="l08997"></a>08997       v = v1 % v2;
<a name="l08998"></a>08998       <span class="keywordflow">if</span> (v * v1 &lt; 0)
<a name="l08999"></a>08999         v -= v2;
<a name="l09000"></a>09000       <span class="keywordflow">break</span>;
<a name="l09001"></a>09001     <span class="keywordflow">default</span>:
<a name="l09002"></a>09002       <span class="comment">/* Should not reach this point.  */</span>
<a name="l09003"></a>09003       v = 0;
<a name="l09004"></a>09004     }
<a name="l09005"></a>09005 
<a name="l09006"></a>09006   val = <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (type1);
<a name="l09007"></a>09007   <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (<a class="code" href="value_8c.html#a9f59e572fabef6e1905632fb81cc00e1">value_contents_raw</a> (val),
<a name="l09008"></a>09008                           <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (val)),
<a name="l09009"></a>09009                           <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (<a class="code" href="gdbtypes_8c.html#a84ca61a6d58c2bd2c7dcedf19d56a39d">get_type_arch</a> (type1)), v);
<a name="l09010"></a>09010   <span class="keywordflow">return</span> val;
<a name="l09011"></a>09011 }
<a name="l09012"></a>09012 
<a name="l09013"></a>09013 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l09014"></a>09014 ada_value_equal (<span class="keyword">struct</span> value *arg1, <span class="keyword">struct</span> value *arg2)
<a name="l09015"></a>09015 {
<a name="l09016"></a>09016   <span class="keywordflow">if</span> (ada_is_direct_array_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1))
<a name="l09017"></a>09017       || ada_is_direct_array_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2)))
<a name="l09018"></a>09018     {
<a name="l09019"></a>09019       <span class="comment">/* Automatically dereference any array reference before</span>
<a name="l09020"></a>09020 <span class="comment">         we attempt to perform the comparison.  */</span>
<a name="l09021"></a>09021       arg1 = ada_coerce_ref (arg1);
<a name="l09022"></a>09022       arg2 = ada_coerce_ref (arg2);
<a name="l09023"></a>09023       
<a name="l09024"></a>09024       arg1 = <a class="code" href="ada-lang_8c.html#a184966871049f553a895f96f7590884a">ada_coerce_to_simple_array</a> (arg1);
<a name="l09025"></a>09025       arg2 = <a class="code" href="ada-lang_8c.html#a184966871049f553a895f96f7590884a">ada_coerce_to_simple_array</a> (arg2);
<a name="l09026"></a>09026       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1)) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l09027"></a>09027           || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2)) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l09028"></a>09028         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attempt to compare array with non-array&quot;</span>));
<a name="l09029"></a>09029       <span class="comment">/* FIXME: The following works only for types whose</span>
<a name="l09030"></a>09030 <span class="comment">         representations use all bits (no padding or undefined bits)</span>
<a name="l09031"></a>09031 <span class="comment">         and do not have user-defined equality.  */</span>
<a name="l09032"></a>09032       <span class="keywordflow">return</span>
<a name="l09033"></a>09033         <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1)) == <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2))
<a name="l09034"></a>09034         &amp;&amp; <a class="code" href="gdb__string_8h.html#a65c3e6b23d6855c86acaf147853c82cc">memcmp</a> (<a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (arg1), <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (arg2),
<a name="l09035"></a>09035                    <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1))) == 0;
<a name="l09036"></a>09036     }
<a name="l09037"></a>09037   <span class="keywordflow">return</span> <a class="code" href="valarith_8c.html#ac4d029b78c2c89aeb0a07ee7ed1f63a5">value_equal</a> (arg1, arg2);
<a name="l09038"></a>09038 }
<a name="l09039"></a>09039 
<a name="l09040"></a>09040 <span class="comment">/* Total number of component associations in the aggregate starting at</span>
<a name="l09041"></a>09041 <span class="comment">   index PC in EXP.  Assumes that index PC is the start of an</span>
<a name="l09042"></a>09042 <span class="comment">   OP_AGGREGATE.  */</span>
<a name="l09043"></a>09043 
<a name="l09044"></a>09044 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l09045"></a>09045 num_component_specs (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp, <span class="keywordtype">int</span> pc)
<a name="l09046"></a>09046 {
<a name="l09047"></a>09047   <span class="keywordtype">int</span> n, <a class="code" href="namespacearm-linux.html#a8594a1214bfb32c5d61201101374a289">m</a>, i;
<a name="l09048"></a>09048 
<a name="l09049"></a>09049   m = exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>;
<a name="l09050"></a>09050   pc += 3;
<a name="l09051"></a>09051   n = 0;
<a name="l09052"></a>09052   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="namespacearm-linux.html#a8594a1214bfb32c5d61201101374a289">m</a>; i += 1)
<a name="l09053"></a>09053     {
<a name="l09054"></a>09054       <span class="keywordflow">switch</span> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a>) 
<a name="l09055"></a>09055         {
<a name="l09056"></a>09056         <span class="keywordflow">default</span>:
<a name="l09057"></a>09057           n += 1;
<a name="l09058"></a>09058           <span class="keywordflow">break</span>;
<a name="l09059"></a>09059         <span class="keywordflow">case</span> OP_CHOICES:
<a name="l09060"></a>09060           n += exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>;
<a name="l09061"></a>09061           <span class="keywordflow">break</span>;
<a name="l09062"></a>09062         }
<a name="l09063"></a>09063       ada_evaluate_subexp (NULL, exp, &amp;pc, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>);
<a name="l09064"></a>09064     }
<a name="l09065"></a>09065   <span class="keywordflow">return</span> n;
<a name="l09066"></a>09066 }
<a name="l09067"></a>09067 
<a name="l09068"></a>09068 <span class="comment">/* Assign the result of evaluating EXP starting at *POS to the INDEXth </span>
<a name="l09069"></a>09069 <span class="comment">   component of LHS (a simple array or a record), updating *POS past</span>
<a name="l09070"></a>09070 <span class="comment">   the expression, assuming that LHS is contained in CONTAINER.  Does</span>
<a name="l09071"></a>09071 <span class="comment">   not modify the inferior&#39;s memory, nor does it modify LHS (unless</span>
<a name="l09072"></a>09072 <span class="comment">   LHS == CONTAINER).  */</span>
<a name="l09073"></a>09073 
<a name="l09074"></a>09074 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l09075"></a>09075 assign_component (<span class="keyword">struct</span> value *container, <span class="keyword">struct</span> value *lhs, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> index,
<a name="l09076"></a>09076                   <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp, <span class="keywordtype">int</span> *pos)
<a name="l09077"></a>09077 {
<a name="l09078"></a>09078   <span class="keyword">struct </span>value *mark = <a class="code" href="value_8c.html#a427a12b0dd4d5663b103d29f07a0e1c6">value_mark</a> ();
<a name="l09079"></a>09079   <span class="keyword">struct </span>value *elt;
<a name="l09080"></a>09080 
<a name="l09081"></a>09081   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (lhs)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l09082"></a>09082     {
<a name="l09083"></a>09083       <span class="keyword">struct </span>type *index_type = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>)-&gt;<a class="code" href="structbuiltin__type.html#ab12f96a04e89e8c951f0eacb379f7ffc">builtin_int</a>;
<a name="l09084"></a>09084       <span class="keyword">struct </span>value *index_val = <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (index_type, index);
<a name="l09085"></a>09085 
<a name="l09086"></a>09086       elt = unwrap_value (<a class="code" href="ada-lang_8c.html#a40dcd8728888b5b445fa2a917076c1a9">ada_value_subscript</a> (lhs, 1, &amp;index_val));
<a name="l09087"></a>09087     }
<a name="l09088"></a>09088   <span class="keywordflow">else</span>
<a name="l09089"></a>09089     {
<a name="l09090"></a>09090       elt = ada_index_struct_field (index, lhs, 0, <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (lhs));
<a name="l09091"></a>09091       elt = <a class="code" href="ada-lang_8c.html#aff7bccfb43d0188dfaf758dffe8b58ce">ada_to_fixed_value</a> (elt);
<a name="l09092"></a>09092     }
<a name="l09093"></a>09093 
<a name="l09094"></a>09094   <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[*pos].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a> == OP_AGGREGATE)
<a name="l09095"></a>09095     assign_aggregate (container, elt, exp, pos, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a2e0f47a90a425663b11d68b22e45be95">EVAL_NORMAL</a>);
<a name="l09096"></a>09096   <span class="keywordflow">else</span>
<a name="l09097"></a>09097     value_assign_to_component (container, elt, 
<a name="l09098"></a>09098                                ada_evaluate_subexp (NULL, exp, pos, 
<a name="l09099"></a>09099                                                     <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a2e0f47a90a425663b11d68b22e45be95">EVAL_NORMAL</a>));
<a name="l09100"></a>09100 
<a name="l09101"></a>09101   <a class="code" href="value_8c.html#a10aad9b72e08c5e90e3051156fa83318">value_free_to_mark</a> (mark);
<a name="l09102"></a>09102 }
<a name="l09103"></a>09103 
<a name="l09104"></a>09104 <span class="comment">/* Assuming that LHS represents an lvalue having a record or array</span>
<a name="l09105"></a>09105 <span class="comment">   type, and EXP-&gt;ELTS[*POS] is an OP_AGGREGATE, evaluate an assignment</span>
<a name="l09106"></a>09106 <span class="comment">   of that aggregate&#39;s value to LHS, advancing *POS past the</span>
<a name="l09107"></a>09107 <span class="comment">   aggregate.  NOSIDE is as for evaluate_subexp.  CONTAINER is an</span>
<a name="l09108"></a>09108 <span class="comment">   lvalue containing LHS (possibly LHS itself).  Does not modify</span>
<a name="l09109"></a>09109 <span class="comment">   the inferior&#39;s memory, nor does it modify the contents of </span>
<a name="l09110"></a>09110 <span class="comment">   LHS (unless == CONTAINER).  Returns the modified CONTAINER.  */</span>
<a name="l09111"></a>09111 
<a name="l09112"></a>09112 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l09113"></a>09113 assign_aggregate (<span class="keyword">struct</span> value *container, 
<a name="l09114"></a>09114                   <span class="keyword">struct</span> value *lhs, <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp, 
<a name="l09115"></a>09115                   <span class="keywordtype">int</span> *pos, <span class="keyword">enum</span> <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73">noside</a> <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73">noside</a>)
<a name="l09116"></a>09116 {
<a name="l09117"></a>09117   <span class="keyword">struct </span>type *lhs_type;
<a name="l09118"></a>09118   <span class="keywordtype">int</span> n = exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[*pos+1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>;
<a name="l09119"></a>09119   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> low_index, high_index;
<a name="l09120"></a>09120   <span class="keywordtype">int</span> num_specs;
<a name="l09121"></a>09121   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *indices;
<a name="l09122"></a>09122   <span class="keywordtype">int</span> max_indices, num_indices;
<a name="l09123"></a>09123   <span class="keywordtype">int</span> i;
<a name="l09124"></a>09124 
<a name="l09125"></a>09125   *pos += 3;
<a name="l09126"></a>09126   <span class="keywordflow">if</span> (noside != <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a2e0f47a90a425663b11d68b22e45be95">EVAL_NORMAL</a>)
<a name="l09127"></a>09127     {
<a name="l09128"></a>09128       <span class="keywordflow">for</span> (i = 0; i &lt; n; i += 1)
<a name="l09129"></a>09129         ada_evaluate_subexp (NULL, exp, pos, noside);
<a name="l09130"></a>09130       <span class="keywordflow">return</span> container;
<a name="l09131"></a>09131     }
<a name="l09132"></a>09132 
<a name="l09133"></a>09133   container = ada_coerce_ref (container);
<a name="l09134"></a>09134   <span class="keywordflow">if</span> (ada_is_direct_array_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (container)))
<a name="l09135"></a>09135     container = <a class="code" href="ada-lang_8c.html#a184966871049f553a895f96f7590884a">ada_coerce_to_simple_array</a> (container);
<a name="l09136"></a>09136   lhs = ada_coerce_ref (lhs);
<a name="l09137"></a>09137   <span class="keywordflow">if</span> (!<a class="code" href="value_8c.html#af38ad07ecbd1d8ae5a31ad793399d0ba">deprecated_value_modifiable</a> (lhs))
<a name="l09138"></a>09138     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Left operand of assignment is not a modifiable lvalue.&quot;</span>));
<a name="l09139"></a>09139 
<a name="l09140"></a>09140   lhs_type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (lhs);
<a name="l09141"></a>09141   <span class="keywordflow">if</span> (ada_is_direct_array_type (lhs_type))
<a name="l09142"></a>09142     {
<a name="l09143"></a>09143       lhs = <a class="code" href="ada-lang_8c.html#a184966871049f553a895f96f7590884a">ada_coerce_to_simple_array</a> (lhs);
<a name="l09144"></a>09144       lhs_type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (lhs);
<a name="l09145"></a>09145       low_index = <a class="code" href="gdbtypes_8h.html#a50a43ece387ccd8f44d6c463315a95e4">TYPE_ARRAY_LOWER_BOUND_VALUE</a> (lhs_type);
<a name="l09146"></a>09146       high_index = <a class="code" href="gdbtypes_8h.html#aad805c525df82e820c813f77892a7b1b">TYPE_ARRAY_UPPER_BOUND_VALUE</a> (lhs_type);
<a name="l09147"></a>09147     }
<a name="l09148"></a>09148   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (lhs_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>)
<a name="l09149"></a>09149     {
<a name="l09150"></a>09150       low_index = 0;
<a name="l09151"></a>09151       high_index = num_visible_fields (lhs_type) - 1;
<a name="l09152"></a>09152     }
<a name="l09153"></a>09153   <span class="keywordflow">else</span>
<a name="l09154"></a>09154     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Left-hand side must be array or record.&quot;</span>));
<a name="l09155"></a>09155 
<a name="l09156"></a>09156   num_specs = num_component_specs (exp, *pos - 3);
<a name="l09157"></a>09157   max_indices = 4 * num_specs + 4;
<a name="l09158"></a>09158   indices = alloca (max_indices * <span class="keyword">sizeof</span> (indices[0]));
<a name="l09159"></a>09159   indices[0] = indices[1] = low_index - 1;
<a name="l09160"></a>09160   indices[2] = indices[3] = high_index + 1;
<a name="l09161"></a>09161   num_indices = 4;
<a name="l09162"></a>09162 
<a name="l09163"></a>09163   <span class="keywordflow">for</span> (i = 0; i &lt; n; i += 1)
<a name="l09164"></a>09164     {
<a name="l09165"></a>09165       <span class="keywordflow">switch</span> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[*pos].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a>)
<a name="l09166"></a>09166         {
<a name="l09167"></a>09167           <span class="keywordflow">case</span> OP_CHOICES:
<a name="l09168"></a>09168             aggregate_assign_from_choices (container, lhs, exp, pos, indices, 
<a name="l09169"></a>09169                                            &amp;num_indices, max_indices,
<a name="l09170"></a>09170                                            low_index, high_index);
<a name="l09171"></a>09171             <span class="keywordflow">break</span>;
<a name="l09172"></a>09172           <span class="keywordflow">case</span> OP_POSITIONAL:
<a name="l09173"></a>09173             aggregate_assign_positional (container, lhs, exp, pos, indices,
<a name="l09174"></a>09174                                          &amp;num_indices, max_indices,
<a name="l09175"></a>09175                                          low_index, high_index);
<a name="l09176"></a>09176             <span class="keywordflow">break</span>;
<a name="l09177"></a>09177           <span class="keywordflow">case</span> OP_OTHERS:
<a name="l09178"></a>09178             <span class="keywordflow">if</span> (i != n-1)
<a name="l09179"></a>09179               <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Misplaced &#39;others&#39; clause&quot;</span>));
<a name="l09180"></a>09180             aggregate_assign_others (container, lhs, exp, pos, indices, 
<a name="l09181"></a>09181                                      num_indices, low_index, high_index);
<a name="l09182"></a>09182             <span class="keywordflow">break</span>;
<a name="l09183"></a>09183           <span class="keywordflow">default</span>:
<a name="l09184"></a>09184             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Internal error: bad aggregate clause&quot;</span>));
<a name="l09185"></a>09185         }
<a name="l09186"></a>09186     }
<a name="l09187"></a>09187 
<a name="l09188"></a>09188   <span class="keywordflow">return</span> container;
<a name="l09189"></a>09189 }
<a name="l09190"></a>09190               
<a name="l09191"></a>09191 <span class="comment">/* Assign into the component of LHS indexed by the OP_POSITIONAL</span>
<a name="l09192"></a>09192 <span class="comment">   construct at *POS, updating *POS past the construct, given that</span>
<a name="l09193"></a>09193 <span class="comment">   the positions are relative to lower bound LOW, where HIGH is the </span>
<a name="l09194"></a>09194 <span class="comment">   upper bound.  Record the position in INDICES[0 .. MAX_INDICES-1]</span>
<a name="l09195"></a>09195 <span class="comment">   updating *NUM_INDICES as needed.  CONTAINER is as for</span>
<a name="l09196"></a>09196 <span class="comment">   assign_aggregate.  */</span>
<a name="l09197"></a>09197 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l09198"></a>09198 aggregate_assign_positional (<span class="keyword">struct</span> value *container,
<a name="l09199"></a>09199                              <span class="keyword">struct</span> value *lhs, <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp,
<a name="l09200"></a>09200                              <span class="keywordtype">int</span> *pos, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *indices, <span class="keywordtype">int</span> *num_indices,
<a name="l09201"></a>09201                              <span class="keywordtype">int</span> max_indices, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> low, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> high) 
<a name="l09202"></a>09202 {
<a name="l09203"></a>09203   <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> ind = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[*pos + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>) + low;
<a name="l09204"></a>09204   
<a name="l09205"></a>09205   <span class="keywordflow">if</span> (ind - 1 == high)
<a name="l09206"></a>09206     <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Extra components in aggregate ignored.&quot;</span>));
<a name="l09207"></a>09207   <span class="keywordflow">if</span> (ind &lt;= high)
<a name="l09208"></a>09208     {
<a name="l09209"></a>09209       add_component_interval (ind, ind, indices, num_indices, max_indices);
<a name="l09210"></a>09210       *pos += 3;
<a name="l09211"></a>09211       assign_component (container, lhs, ind, exp, pos);
<a name="l09212"></a>09212     }
<a name="l09213"></a>09213   <span class="keywordflow">else</span>
<a name="l09214"></a>09214     ada_evaluate_subexp (NULL, exp, pos, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>);
<a name="l09215"></a>09215 }
<a name="l09216"></a>09216 
<a name="l09217"></a>09217 <span class="comment">/* Assign into the components of LHS indexed by the OP_CHOICES</span>
<a name="l09218"></a>09218 <span class="comment">   construct at *POS, updating *POS past the construct, given that</span>
<a name="l09219"></a>09219 <span class="comment">   the allowable indices are LOW..HIGH.  Record the indices assigned</span>
<a name="l09220"></a>09220 <span class="comment">   to in INDICES[0 .. MAX_INDICES-1], updating *NUM_INDICES as</span>
<a name="l09221"></a>09221 <span class="comment">   needed.  CONTAINER is as for assign_aggregate.  */</span>
<a name="l09222"></a>09222 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l09223"></a>09223 aggregate_assign_from_choices (<span class="keyword">struct</span> value *container,
<a name="l09224"></a>09224                                <span class="keyword">struct</span> value *lhs, <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp,
<a name="l09225"></a>09225                                <span class="keywordtype">int</span> *pos, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *indices, <span class="keywordtype">int</span> *num_indices,
<a name="l09226"></a>09226                                <span class="keywordtype">int</span> max_indices, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> low, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> high) 
<a name="l09227"></a>09227 {
<a name="l09228"></a>09228   <span class="keywordtype">int</span> j;
<a name="l09229"></a>09229   <span class="keywordtype">int</span> n_choices = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[*pos+1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l09230"></a>09230   <span class="keywordtype">int</span> choice_pos, expr_pc;
<a name="l09231"></a>09231   <span class="keywordtype">int</span> is_array = ada_is_direct_array_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (lhs));
<a name="l09232"></a>09232 
<a name="l09233"></a>09233   choice_pos = *pos += 3;
<a name="l09234"></a>09234 
<a name="l09235"></a>09235   <span class="keywordflow">for</span> (j = 0; j &lt; n_choices; j += 1)
<a name="l09236"></a>09236     ada_evaluate_subexp (NULL, exp, pos, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>);
<a name="l09237"></a>09237   expr_pc = *pos;
<a name="l09238"></a>09238   ada_evaluate_subexp (NULL, exp, pos, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>);
<a name="l09239"></a>09239   
<a name="l09240"></a>09240   <span class="keywordflow">for</span> (j = 0; j &lt; n_choices; j += 1)
<a name="l09241"></a>09241     {
<a name="l09242"></a>09242       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> lower, upper;
<a name="l09243"></a>09243       <span class="keyword">enum</span> <a class="code" href="expression_8h.html#a13f8bfc7b2a183fe56716508bfddae41">exp_opcode</a> op = exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[choice_pos].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a>;
<a name="l09244"></a>09244 
<a name="l09245"></a>09245       <span class="keywordflow">if</span> (op == OP_DISCRETE_RANGE)
<a name="l09246"></a>09246         {
<a name="l09247"></a>09247           choice_pos += 1;
<a name="l09248"></a>09248           lower = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (ada_evaluate_subexp (NULL, exp, pos,
<a name="l09249"></a>09249                                                       <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a2e0f47a90a425663b11d68b22e45be95">EVAL_NORMAL</a>));
<a name="l09250"></a>09250           upper = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (ada_evaluate_subexp (NULL, exp, pos, 
<a name="l09251"></a>09251                                                       <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a2e0f47a90a425663b11d68b22e45be95">EVAL_NORMAL</a>));
<a name="l09252"></a>09252         }
<a name="l09253"></a>09253       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_array)
<a name="l09254"></a>09254         {
<a name="l09255"></a>09255           lower = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (ada_evaluate_subexp (NULL, exp, &amp;choice_pos, 
<a name="l09256"></a>09256                                                       <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a2e0f47a90a425663b11d68b22e45be95">EVAL_NORMAL</a>));
<a name="l09257"></a>09257           upper = lower;
<a name="l09258"></a>09258         }
<a name="l09259"></a>09259       <span class="keywordflow">else</span>
<a name="l09260"></a>09260         {
<a name="l09261"></a>09261           <span class="keywordtype">int</span> ind;
<a name="l09262"></a>09262           <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l09263"></a>09263 
<a name="l09264"></a>09264           <span class="keywordflow">switch</span> (op)
<a name="l09265"></a>09265             {
<a name="l09266"></a>09266             <span class="keywordflow">case</span> OP_NAME:
<a name="l09267"></a>09267               name = &amp;exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[choice_pos + 2].<a class="code" href="unionexp__element.html#abeeb3252199a524869642283bccda167">string</a>;
<a name="l09268"></a>09268               <span class="keywordflow">break</span>;
<a name="l09269"></a>09269             <span class="keywordflow">case</span> OP_VAR_VALUE:
<a name="l09270"></a>09270               name = <a class="code" href="symtab_8h.html#a243e66afa96ff58a851b38f428bb3394">SYMBOL_NATURAL_NAME</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[choice_pos + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>);
<a name="l09271"></a>09271               <span class="keywordflow">break</span>;
<a name="l09272"></a>09272             <span class="keywordflow">default</span>:
<a name="l09273"></a>09273               <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Invalid record component association.&quot;</span>));
<a name="l09274"></a>09274             }
<a name="l09275"></a>09275           ada_evaluate_subexp (NULL, exp, &amp;choice_pos, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>);
<a name="l09276"></a>09276           ind = 0;
<a name="l09277"></a>09277           <span class="keywordflow">if</span> (! find_struct_field (name, <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (lhs), 0, 
<a name="l09278"></a>09278                                    NULL, NULL, NULL, NULL, &amp;ind))
<a name="l09279"></a>09279             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unknown component name: %s.&quot;</span>), name);
<a name="l09280"></a>09280           lower = upper = ind;
<a name="l09281"></a>09281         }
<a name="l09282"></a>09282 
<a name="l09283"></a>09283       <span class="keywordflow">if</span> (lower &lt;= upper &amp;&amp; (lower &lt; low || upper &gt; high))
<a name="l09284"></a>09284         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Index in component association out of bounds.&quot;</span>));
<a name="l09285"></a>09285 
<a name="l09286"></a>09286       add_component_interval (lower, upper, indices, num_indices,
<a name="l09287"></a>09287                               max_indices);
<a name="l09288"></a>09288       <span class="keywordflow">while</span> (lower &lt;= upper)
<a name="l09289"></a>09289         {
<a name="l09290"></a>09290           <span class="keywordtype">int</span> pos1;
<a name="l09291"></a>09291 
<a name="l09292"></a>09292           pos1 = expr_pc;
<a name="l09293"></a>09293           assign_component (container, lhs, lower, exp, &amp;pos1);
<a name="l09294"></a>09294           lower += 1;
<a name="l09295"></a>09295         }
<a name="l09296"></a>09296     }
<a name="l09297"></a>09297 }
<a name="l09298"></a>09298 
<a name="l09299"></a>09299 <span class="comment">/* Assign the value of the expression in the OP_OTHERS construct in</span>
<a name="l09300"></a>09300 <span class="comment">   EXP at *POS into the components of LHS indexed from LOW .. HIGH that</span>
<a name="l09301"></a>09301 <span class="comment">   have not been previously assigned.  The index intervals already assigned</span>
<a name="l09302"></a>09302 <span class="comment">   are in INDICES[0 .. NUM_INDICES-1].  Updates *POS to after the </span>
<a name="l09303"></a>09303 <span class="comment">   OP_OTHERS clause.  CONTAINER is as for assign_aggregate.  */</span>
<a name="l09304"></a>09304 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l09305"></a>09305 aggregate_assign_others (<span class="keyword">struct</span> value *container,
<a name="l09306"></a>09306                          <span class="keyword">struct</span> value *lhs, <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp,
<a name="l09307"></a>09307                          <span class="keywordtype">int</span> *pos, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> *indices, <span class="keywordtype">int</span> num_indices,
<a name="l09308"></a>09308                          <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> low, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> high) 
<a name="l09309"></a>09309 {
<a name="l09310"></a>09310   <span class="keywordtype">int</span> i;
<a name="l09311"></a>09311   <span class="keywordtype">int</span> expr_pc = *pos + 1;
<a name="l09312"></a>09312   
<a name="l09313"></a>09313   <span class="keywordflow">for</span> (i = 0; i &lt; num_indices - 2; i += 2)
<a name="l09314"></a>09314     {
<a name="l09315"></a>09315       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> ind;
<a name="l09316"></a>09316 
<a name="l09317"></a>09317       <span class="keywordflow">for</span> (ind = indices[i + 1] + 1; ind &lt; indices[i + 2]; ind += 1)
<a name="l09318"></a>09318         {
<a name="l09319"></a>09319           <span class="keywordtype">int</span> localpos;
<a name="l09320"></a>09320 
<a name="l09321"></a>09321           localpos = expr_pc;
<a name="l09322"></a>09322           assign_component (container, lhs, ind, exp, &amp;localpos);
<a name="l09323"></a>09323         }
<a name="l09324"></a>09324     }
<a name="l09325"></a>09325   ada_evaluate_subexp (NULL, exp, pos, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>);
<a name="l09326"></a>09326 }
<a name="l09327"></a>09327 
<a name="l09328"></a>09328 <span class="comment">/* Add the interval [LOW .. HIGH] to the sorted set of intervals </span>
<a name="l09329"></a>09329 <span class="comment">   [ INDICES[0] .. INDICES[1] ],..., [ INDICES[*SIZE-2] .. INDICES[*SIZE-1] ],</span>
<a name="l09330"></a>09330 <span class="comment">   modifying *SIZE as needed.  It is an error if *SIZE exceeds</span>
<a name="l09331"></a>09331 <span class="comment">   MAX_SIZE.  The resulting intervals do not overlap.  */</span>
<a name="l09332"></a>09332 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l09333"></a>09333 add_component_interval (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> low, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> high, 
<a name="l09334"></a>09334                         <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>* indices, <span class="keywordtype">int</span> *size, <span class="keywordtype">int</span> max_size)
<a name="l09335"></a>09335 {
<a name="l09336"></a>09336   <span class="keywordtype">int</span> i, j;
<a name="l09337"></a>09337 
<a name="l09338"></a>09338   <span class="keywordflow">for</span> (i = 0; i &lt; *<a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>; i += 2) {
<a name="l09339"></a>09339     <span class="keywordflow">if</span> (high &gt;= indices[i] &amp;&amp; low &lt;= indices[i + 1])
<a name="l09340"></a>09340       {
<a name="l09341"></a>09341         <span class="keywordtype">int</span> kh;
<a name="l09342"></a>09342 
<a name="l09343"></a>09343         <span class="keywordflow">for</span> (kh = i + 2; kh &lt; *<a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>; kh += 2)
<a name="l09344"></a>09344           <span class="keywordflow">if</span> (high &lt; indices[kh])
<a name="l09345"></a>09345             <span class="keywordflow">break</span>;
<a name="l09346"></a>09346         <span class="keywordflow">if</span> (low &lt; indices[i])
<a name="l09347"></a>09347           indices[i] = low;
<a name="l09348"></a>09348         indices[i + 1] = indices[kh - 1];
<a name="l09349"></a>09349         <span class="keywordflow">if</span> (high &gt; indices[i + 1])
<a name="l09350"></a>09350           indices[i + 1] = high;
<a name="l09351"></a>09351         <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (indices + i + 2, indices + kh, *size - kh);
<a name="l09352"></a>09352         *size -= kh - i - 2;
<a name="l09353"></a>09353         <span class="keywordflow">return</span>;
<a name="l09354"></a>09354       }
<a name="l09355"></a>09355     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (high &lt; indices[i])
<a name="l09356"></a>09356       <span class="keywordflow">break</span>;
<a name="l09357"></a>09357   }
<a name="l09358"></a>09358         
<a name="l09359"></a>09359   <span class="keywordflow">if</span> (*size == max_size)
<a name="l09360"></a>09360     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Internal error: miscounted aggregate components.&quot;</span>));
<a name="l09361"></a>09361   *size += 2;
<a name="l09362"></a>09362   <span class="keywordflow">for</span> (j = *size-1; j &gt;= i+2; j -= 1)
<a name="l09363"></a>09363     indices[j] = indices[j - 2];
<a name="l09364"></a>09364   indices[i] = low;
<a name="l09365"></a>09365   indices[i + 1] = high;
<a name="l09366"></a>09366 }
<a name="l09367"></a>09367 
<a name="l09368"></a>09368 <span class="comment">/* Perform and Ada cast of ARG2 to type TYPE if the type of ARG2</span>
<a name="l09369"></a>09369 <span class="comment">   is different.  */</span>
<a name="l09370"></a>09370 
<a name="l09371"></a>09371 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l09372"></a>09372 ada_value_cast (<span class="keyword">struct</span> type *type, <span class="keyword">struct</span> value *arg2, <span class="keyword">enum</span> noside noside)
<a name="l09373"></a>09373 {
<a name="l09374"></a>09374   <span class="keywordflow">if</span> (type == <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2)))
<a name="l09375"></a>09375     <span class="keywordflow">return</span> arg2;
<a name="l09376"></a>09376 
<a name="l09377"></a>09377   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#afe50295540937b9ae0f68f2be4794f18">ada_is_fixed_point_type</a> (type))
<a name="l09378"></a>09378     <span class="keywordflow">return</span> (cast_to_fixed (type, arg2));
<a name="l09379"></a>09379 
<a name="l09380"></a>09380   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#afe50295540937b9ae0f68f2be4794f18">ada_is_fixed_point_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2)))
<a name="l09381"></a>09381     <span class="keywordflow">return</span> cast_from_fixed (type, arg2);
<a name="l09382"></a>09382 
<a name="l09383"></a>09383   <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (type, arg2);
<a name="l09384"></a>09384 }
<a name="l09385"></a>09385 
<a name="l09386"></a>09386 <span class="comment">/*  Evaluating Ada expressions, and printing their result.</span>
<a name="l09387"></a>09387 <span class="comment">    ------------------------------------------------------</span>
<a name="l09388"></a>09388 <span class="comment"></span>
<a name="l09389"></a>09389 <span class="comment">    1. Introduction:</span>
<a name="l09390"></a>09390 <span class="comment">    ----------------</span>
<a name="l09391"></a>09391 <span class="comment"></span>
<a name="l09392"></a>09392 <span class="comment">    We usually evaluate an Ada expression in order to print its value.</span>
<a name="l09393"></a>09393 <span class="comment">    We also evaluate an expression in order to print its type, which</span>
<a name="l09394"></a>09394 <span class="comment">    happens during the EVAL_AVOID_SIDE_EFFECTS phase of the evaluation,</span>
<a name="l09395"></a>09395 <span class="comment">    but we&#39;ll focus mostly on the EVAL_NORMAL phase.  In practice, the</span>
<a name="l09396"></a>09396 <span class="comment">    EVAL_AVOID_SIDE_EFFECTS phase allows us to simplify certain aspects of</span>
<a name="l09397"></a>09397 <span class="comment">    the evaluation compared to the EVAL_NORMAL, but is otherwise very</span>
<a name="l09398"></a>09398 <span class="comment">    similar.</span>
<a name="l09399"></a>09399 <span class="comment"></span>
<a name="l09400"></a>09400 <span class="comment">    Evaluating expressions is a little more complicated for Ada entities</span>
<a name="l09401"></a>09401 <span class="comment">    than it is for entities in languages such as C.  The main reason for</span>
<a name="l09402"></a>09402 <span class="comment">    this is that Ada provides types whose definition might be dynamic.</span>
<a name="l09403"></a>09403 <span class="comment">    One example of such types is variant records.  Or another example</span>
<a name="l09404"></a>09404 <span class="comment">    would be an array whose bounds can only be known at run time.</span>
<a name="l09405"></a>09405 <span class="comment"></span>
<a name="l09406"></a>09406 <span class="comment">    The following description is a general guide as to what should be</span>
<a name="l09407"></a>09407 <span class="comment">    done (and what should NOT be done) in order to evaluate an expression</span>
<a name="l09408"></a>09408 <span class="comment">    involving such types, and when.  This does not cover how the semantic</span>
<a name="l09409"></a>09409 <span class="comment">    information is encoded by GNAT as this is covered separatly.  For the</span>
<a name="l09410"></a>09410 <span class="comment">    document used as the reference for the GNAT encoding, see exp_dbug.ads</span>
<a name="l09411"></a>09411 <span class="comment">    in the GNAT sources.</span>
<a name="l09412"></a>09412 <span class="comment"></span>
<a name="l09413"></a>09413 <span class="comment">    Ideally, we should embed each part of this description next to its</span>
<a name="l09414"></a>09414 <span class="comment">    associated code.  Unfortunately, the amount of code is so vast right</span>
<a name="l09415"></a>09415 <span class="comment">    now that it&#39;s hard to see whether the code handling a particular</span>
<a name="l09416"></a>09416 <span class="comment">    situation might be duplicated or not.  One day, when the code is</span>
<a name="l09417"></a>09417 <span class="comment">    cleaned up, this guide might become redundant with the comments</span>
<a name="l09418"></a>09418 <span class="comment">    inserted in the code, and we might want to remove it.</span>
<a name="l09419"></a>09419 <span class="comment"></span>
<a name="l09420"></a>09420 <span class="comment">    2. ``Fixing&#39;&#39; an Entity, the Simple Case:</span>
<a name="l09421"></a>09421 <span class="comment">    -----------------------------------------</span>
<a name="l09422"></a>09422 <span class="comment"></span>
<a name="l09423"></a>09423 <span class="comment">    When evaluating Ada expressions, the tricky issue is that they may</span>
<a name="l09424"></a>09424 <span class="comment">    reference entities whose type contents and size are not statically</span>
<a name="l09425"></a>09425 <span class="comment">    known.  Consider for instance a variant record:</span>
<a name="l09426"></a>09426 <span class="comment"></span>
<a name="l09427"></a>09427 <span class="comment">       type Rec (Empty : Boolean := True) is record</span>
<a name="l09428"></a>09428 <span class="comment">          case Empty is</span>
<a name="l09429"></a>09429 <span class="comment">             when True =&gt; null;</span>
<a name="l09430"></a>09430 <span class="comment">             when False =&gt; Value : Integer;</span>
<a name="l09431"></a>09431 <span class="comment">          end case;</span>
<a name="l09432"></a>09432 <span class="comment">       end record;</span>
<a name="l09433"></a>09433 <span class="comment">       Yes : Rec := (Empty =&gt; False, Value =&gt; 1);</span>
<a name="l09434"></a>09434 <span class="comment">       No  : Rec := (empty =&gt; True);</span>
<a name="l09435"></a>09435 <span class="comment"></span>
<a name="l09436"></a>09436 <span class="comment">    The size and contents of that record depends on the value of the</span>
<a name="l09437"></a>09437 <span class="comment">    descriminant (Rec.Empty).  At this point, neither the debugging</span>
<a name="l09438"></a>09438 <span class="comment">    information nor the associated type structure in GDB are able to</span>
<a name="l09439"></a>09439 <span class="comment">    express such dynamic types.  So what the debugger does is to create</span>
<a name="l09440"></a>09440 <span class="comment">    &quot;fixed&quot; versions of the type that applies to the specific object.</span>
<a name="l09441"></a>09441 <span class="comment">    We also informally refer to this opperation as &quot;fixing&quot; an object,</span>
<a name="l09442"></a>09442 <span class="comment">    which means creating its associated fixed type.</span>
<a name="l09443"></a>09443 <span class="comment"></span>
<a name="l09444"></a>09444 <span class="comment">    Example: when printing the value of variable &quot;Yes&quot; above, its fixed</span>
<a name="l09445"></a>09445 <span class="comment">    type would look like this:</span>
<a name="l09446"></a>09446 <span class="comment"></span>
<a name="l09447"></a>09447 <span class="comment">       type Rec is record</span>
<a name="l09448"></a>09448 <span class="comment">          Empty : Boolean;</span>
<a name="l09449"></a>09449 <span class="comment">          Value : Integer;</span>
<a name="l09450"></a>09450 <span class="comment">       end record;</span>
<a name="l09451"></a>09451 <span class="comment"></span>
<a name="l09452"></a>09452 <span class="comment">    On the other hand, if we printed the value of &quot;No&quot;, its fixed type</span>
<a name="l09453"></a>09453 <span class="comment">    would become:</span>
<a name="l09454"></a>09454 <span class="comment"></span>
<a name="l09455"></a>09455 <span class="comment">       type Rec is record</span>
<a name="l09456"></a>09456 <span class="comment">          Empty : Boolean;</span>
<a name="l09457"></a>09457 <span class="comment">       end record;</span>
<a name="l09458"></a>09458 <span class="comment"></span>
<a name="l09459"></a>09459 <span class="comment">    Things become a little more complicated when trying to fix an entity</span>
<a name="l09460"></a>09460 <span class="comment">    with a dynamic type that directly contains another dynamic type,</span>
<a name="l09461"></a>09461 <span class="comment">    such as an array of variant records, for instance.  There are</span>
<a name="l09462"></a>09462 <span class="comment">    two possible cases: Arrays, and records.</span>
<a name="l09463"></a>09463 <span class="comment"></span>
<a name="l09464"></a>09464 <span class="comment">    3. ``Fixing&#39;&#39; Arrays:</span>
<a name="l09465"></a>09465 <span class="comment">    ---------------------</span>
<a name="l09466"></a>09466 <span class="comment"></span>
<a name="l09467"></a>09467 <span class="comment">    The type structure in GDB describes an array in terms of its bounds,</span>
<a name="l09468"></a>09468 <span class="comment">    and the type of its elements.  By design, all elements in the array</span>
<a name="l09469"></a>09469 <span class="comment">    have the same type and we cannot represent an array of variant elements</span>
<a name="l09470"></a>09470 <span class="comment">    using the current type structure in GDB.  When fixing an array,</span>
<a name="l09471"></a>09471 <span class="comment">    we cannot fix the array element, as we would potentially need one</span>
<a name="l09472"></a>09472 <span class="comment">    fixed type per element of the array.  As a result, the best we can do</span>
<a name="l09473"></a>09473 <span class="comment">    when fixing an array is to produce an array whose bounds and size</span>
<a name="l09474"></a>09474 <span class="comment">    are correct (allowing us to read it from memory), but without having</span>
<a name="l09475"></a>09475 <span class="comment">    touched its element type.  Fixing each element will be done later,</span>
<a name="l09476"></a>09476 <span class="comment">    when (if) necessary.</span>
<a name="l09477"></a>09477 <span class="comment"></span>
<a name="l09478"></a>09478 <span class="comment">    Arrays are a little simpler to handle than records, because the same</span>
<a name="l09479"></a>09479 <span class="comment">    amount of memory is allocated for each element of the array, even if</span>
<a name="l09480"></a>09480 <span class="comment">    the amount of space actually used by each element differs from element</span>
<a name="l09481"></a>09481 <span class="comment">    to element.  Consider for instance the following array of type Rec:</span>
<a name="l09482"></a>09482 <span class="comment"></span>
<a name="l09483"></a>09483 <span class="comment">       type Rec_Array is array (1 .. 2) of Rec;</span>
<a name="l09484"></a>09484 <span class="comment"></span>
<a name="l09485"></a>09485 <span class="comment">    The actual amount of memory occupied by each element might be different</span>
<a name="l09486"></a>09486 <span class="comment">    from element to element, depending on the value of their discriminant.</span>
<a name="l09487"></a>09487 <span class="comment">    But the amount of space reserved for each element in the array remains</span>
<a name="l09488"></a>09488 <span class="comment">    fixed regardless.  So we simply need to compute that size using</span>
<a name="l09489"></a>09489 <span class="comment">    the debugging information available, from which we can then determine</span>
<a name="l09490"></a>09490 <span class="comment">    the array size (we multiply the number of elements of the array by</span>
<a name="l09491"></a>09491 <span class="comment">    the size of each element).</span>
<a name="l09492"></a>09492 <span class="comment"></span>
<a name="l09493"></a>09493 <span class="comment">    The simplest case is when we have an array of a constrained element</span>
<a name="l09494"></a>09494 <span class="comment">    type. For instance, consider the following type declarations:</span>
<a name="l09495"></a>09495 <span class="comment"></span>
<a name="l09496"></a>09496 <span class="comment">        type Bounded_String (Max_Size : Integer) is</span>
<a name="l09497"></a>09497 <span class="comment">           Length : Integer;</span>
<a name="l09498"></a>09498 <span class="comment">           Buffer : String (1 .. Max_Size);</span>
<a name="l09499"></a>09499 <span class="comment">        end record;</span>
<a name="l09500"></a>09500 <span class="comment">        type Bounded_String_Array is array (1 ..2) of Bounded_String (80);</span>
<a name="l09501"></a>09501 <span class="comment"></span>
<a name="l09502"></a>09502 <span class="comment">    In this case, the compiler describes the array as an array of</span>
<a name="l09503"></a>09503 <span class="comment">    variable-size elements (identified by its XVS suffix) for which</span>
<a name="l09504"></a>09504 <span class="comment">    the size can be read in the parallel XVZ variable.</span>
<a name="l09505"></a>09505 <span class="comment"></span>
<a name="l09506"></a>09506 <span class="comment">    In the case of an array of an unconstrained element type, the compiler</span>
<a name="l09507"></a>09507 <span class="comment">    wraps the array element inside a private PAD type.  This type should not</span>
<a name="l09508"></a>09508 <span class="comment">    be shown to the user, and must be &quot;unwrap&quot;&#39;ed before printing.  Note</span>
<a name="l09509"></a>09509 <span class="comment">    that we also use the adjective &quot;aligner&quot; in our code to designate</span>
<a name="l09510"></a>09510 <span class="comment">    these wrapper types.</span>
<a name="l09511"></a>09511 <span class="comment"></span>
<a name="l09512"></a>09512 <span class="comment">    In some cases, the size allocated for each element is statically</span>
<a name="l09513"></a>09513 <span class="comment">    known.  In that case, the PAD type already has the correct size,</span>
<a name="l09514"></a>09514 <span class="comment">    and the array element should remain unfixed.</span>
<a name="l09515"></a>09515 <span class="comment"></span>
<a name="l09516"></a>09516 <span class="comment">    But there are cases when this size is not statically known.</span>
<a name="l09517"></a>09517 <span class="comment">    For instance, assuming that &quot;Five&quot; is an integer variable:</span>
<a name="l09518"></a>09518 <span class="comment"></span>
<a name="l09519"></a>09519 <span class="comment">        type Dynamic is array (1 .. Five) of Integer;</span>
<a name="l09520"></a>09520 <span class="comment">        type Wrapper (Has_Length : Boolean := False) is record</span>
<a name="l09521"></a>09521 <span class="comment">           Data : Dynamic;</span>
<a name="l09522"></a>09522 <span class="comment">           case Has_Length is</span>
<a name="l09523"></a>09523 <span class="comment">              when True =&gt; Length : Integer;</span>
<a name="l09524"></a>09524 <span class="comment">              when False =&gt; null;</span>
<a name="l09525"></a>09525 <span class="comment">           end case;</span>
<a name="l09526"></a>09526 <span class="comment">        end record;</span>
<a name="l09527"></a>09527 <span class="comment">        type Wrapper_Array is array (1 .. 2) of Wrapper;</span>
<a name="l09528"></a>09528 <span class="comment"></span>
<a name="l09529"></a>09529 <span class="comment">        Hello : Wrapper_Array := (others =&gt; (Has_Length =&gt; True,</span>
<a name="l09530"></a>09530 <span class="comment">                                             Data =&gt; (others =&gt; 17),</span>
<a name="l09531"></a>09531 <span class="comment">                                             Length =&gt; 1));</span>
<a name="l09532"></a>09532 <span class="comment"></span>
<a name="l09533"></a>09533 <span class="comment"></span>
<a name="l09534"></a>09534 <span class="comment">    The debugging info would describe variable Hello as being an</span>
<a name="l09535"></a>09535 <span class="comment">    array of a PAD type.  The size of that PAD type is not statically</span>
<a name="l09536"></a>09536 <span class="comment">    known, but can be determined using a parallel XVZ variable.</span>
<a name="l09537"></a>09537 <span class="comment">    In that case, a copy of the PAD type with the correct size should</span>
<a name="l09538"></a>09538 <span class="comment">    be used for the fixed array.</span>
<a name="l09539"></a>09539 <span class="comment"></span>
<a name="l09540"></a>09540 <span class="comment">    3. ``Fixing&#39;&#39; record type objects:</span>
<a name="l09541"></a>09541 <span class="comment">    ----------------------------------</span>
<a name="l09542"></a>09542 <span class="comment"></span>
<a name="l09543"></a>09543 <span class="comment">    Things are slightly different from arrays in the case of dynamic</span>
<a name="l09544"></a>09544 <span class="comment">    record types.  In this case, in order to compute the associated</span>
<a name="l09545"></a>09545 <span class="comment">    fixed type, we need to determine the size and offset of each of</span>
<a name="l09546"></a>09546 <span class="comment">    its components.  This, in turn, requires us to compute the fixed</span>
<a name="l09547"></a>09547 <span class="comment">    type of each of these components.</span>
<a name="l09548"></a>09548 <span class="comment"></span>
<a name="l09549"></a>09549 <span class="comment">    Consider for instance the example:</span>
<a name="l09550"></a>09550 <span class="comment"></span>
<a name="l09551"></a>09551 <span class="comment">        type Bounded_String (Max_Size : Natural) is record</span>
<a name="l09552"></a>09552 <span class="comment">           Str : String (1 .. Max_Size);</span>
<a name="l09553"></a>09553 <span class="comment">           Length : Natural;</span>
<a name="l09554"></a>09554 <span class="comment">        end record;</span>
<a name="l09555"></a>09555 <span class="comment">        My_String : Bounded_String (Max_Size =&gt; 10);</span>
<a name="l09556"></a>09556 <span class="comment"></span>
<a name="l09557"></a>09557 <span class="comment">    In that case, the position of field &quot;Length&quot; depends on the size</span>
<a name="l09558"></a>09558 <span class="comment">    of field Str, which itself depends on the value of the Max_Size</span>
<a name="l09559"></a>09559 <span class="comment">    discriminant.  In order to fix the type of variable My_String,</span>
<a name="l09560"></a>09560 <span class="comment">    we need to fix the type of field Str.  Therefore, fixing a variant</span>
<a name="l09561"></a>09561 <span class="comment">    record requires us to fix each of its components.</span>
<a name="l09562"></a>09562 <span class="comment"></span>
<a name="l09563"></a>09563 <span class="comment">    However, if a component does not have a dynamic size, the component</span>
<a name="l09564"></a>09564 <span class="comment">    should not be fixed.  In particular, fields that use a PAD type</span>
<a name="l09565"></a>09565 <span class="comment">    should not fixed.  Here is an example where this might happen</span>
<a name="l09566"></a>09566 <span class="comment">    (assuming type Rec above):</span>
<a name="l09567"></a>09567 <span class="comment"></span>
<a name="l09568"></a>09568 <span class="comment">       type Container (Big : Boolean) is record</span>
<a name="l09569"></a>09569 <span class="comment">          First : Rec;</span>
<a name="l09570"></a>09570 <span class="comment">          After : Integer;</span>
<a name="l09571"></a>09571 <span class="comment">          case Big is</span>
<a name="l09572"></a>09572 <span class="comment">             when True =&gt; Another : Integer;</span>
<a name="l09573"></a>09573 <span class="comment">             when False =&gt; null;</span>
<a name="l09574"></a>09574 <span class="comment">          end case;</span>
<a name="l09575"></a>09575 <span class="comment">       end record;</span>
<a name="l09576"></a>09576 <span class="comment">       My_Container : Container := (Big =&gt; False,</span>
<a name="l09577"></a>09577 <span class="comment">                                    First =&gt; (Empty =&gt; True),</span>
<a name="l09578"></a>09578 <span class="comment">                                    After =&gt; 42);</span>
<a name="l09579"></a>09579 <span class="comment"></span>
<a name="l09580"></a>09580 <span class="comment">    In that example, the compiler creates a PAD type for component First,</span>
<a name="l09581"></a>09581 <span class="comment">    whose size is constant, and then positions the component After just</span>
<a name="l09582"></a>09582 <span class="comment">    right after it.  The offset of component After is therefore constant</span>
<a name="l09583"></a>09583 <span class="comment">    in this case.</span>
<a name="l09584"></a>09584 <span class="comment"></span>
<a name="l09585"></a>09585 <span class="comment">    The debugger computes the position of each field based on an algorithm</span>
<a name="l09586"></a>09586 <span class="comment">    that uses, among other things, the actual position and size of the field</span>
<a name="l09587"></a>09587 <span class="comment">    preceding it.  Let&#39;s now imagine that the user is trying to print</span>
<a name="l09588"></a>09588 <span class="comment">    the value of My_Container.  If the type fixing was recursive, we would</span>
<a name="l09589"></a>09589 <span class="comment">    end up computing the offset of field After based on the size of the</span>
<a name="l09590"></a>09590 <span class="comment">    fixed version of field First.  And since in our example First has</span>
<a name="l09591"></a>09591 <span class="comment">    only one actual field, the size of the fixed type is actually smaller</span>
<a name="l09592"></a>09592 <span class="comment">    than the amount of space allocated to that field, and thus we would</span>
<a name="l09593"></a>09593 <span class="comment">    compute the wrong offset of field After.</span>
<a name="l09594"></a>09594 <span class="comment"></span>
<a name="l09595"></a>09595 <span class="comment">    To make things more complicated, we need to watch out for dynamic</span>
<a name="l09596"></a>09596 <span class="comment">    components of variant records (identified by the ___XVL suffix in</span>
<a name="l09597"></a>09597 <span class="comment">    the component name).  Even if the target type is a PAD type, the size</span>
<a name="l09598"></a>09598 <span class="comment">    of that type might not be statically known.  So the PAD type needs</span>
<a name="l09599"></a>09599 <span class="comment">    to be unwrapped and the resulting type needs to be fixed.  Otherwise,</span>
<a name="l09600"></a>09600 <span class="comment">    we might end up with the wrong size for our component.  This can be</span>
<a name="l09601"></a>09601 <span class="comment">    observed with the following type declarations:</span>
<a name="l09602"></a>09602 <span class="comment"></span>
<a name="l09603"></a>09603 <span class="comment">        type Octal is new Integer range 0 .. 7;</span>
<a name="l09604"></a>09604 <span class="comment">        type Octal_Array is array (Positive range &lt;&gt;) of Octal;</span>
<a name="l09605"></a>09605 <span class="comment">        pragma Pack (Octal_Array);</span>
<a name="l09606"></a>09606 <span class="comment"></span>
<a name="l09607"></a>09607 <span class="comment">        type Octal_Buffer (Size : Positive) is record</span>
<a name="l09608"></a>09608 <span class="comment">           Buffer : Octal_Array (1 .. Size);</span>
<a name="l09609"></a>09609 <span class="comment">           Length : Integer;</span>
<a name="l09610"></a>09610 <span class="comment">        end record;</span>
<a name="l09611"></a>09611 <span class="comment"></span>
<a name="l09612"></a>09612 <span class="comment">    In that case, Buffer is a PAD type whose size is unset and needs</span>
<a name="l09613"></a>09613 <span class="comment">    to be computed by fixing the unwrapped type.</span>
<a name="l09614"></a>09614 <span class="comment"></span>
<a name="l09615"></a>09615 <span class="comment">    4. When to ``Fix&#39;&#39; un-``Fixed&#39;&#39; sub-elements of an entity:</span>
<a name="l09616"></a>09616 <span class="comment">    ----------------------------------------------------------</span>
<a name="l09617"></a>09617 <span class="comment"></span>
<a name="l09618"></a>09618 <span class="comment">    Lastly, when should the sub-elements of an entity that remained unfixed</span>
<a name="l09619"></a>09619 <span class="comment">    thus far, be actually fixed?</span>
<a name="l09620"></a>09620 <span class="comment"></span>
<a name="l09621"></a>09621 <span class="comment">    The answer is: Only when referencing that element.  For instance</span>
<a name="l09622"></a>09622 <span class="comment">    when selecting one component of a record, this specific component</span>
<a name="l09623"></a>09623 <span class="comment">    should be fixed at that point in time.  Or when printing the value</span>
<a name="l09624"></a>09624 <span class="comment">    of a record, each component should be fixed before its value gets</span>
<a name="l09625"></a>09625 <span class="comment">    printed.  Similarly for arrays, the element of the array should be</span>
<a name="l09626"></a>09626 <span class="comment">    fixed when printing each element of the array, or when extracting</span>
<a name="l09627"></a>09627 <span class="comment">    one element out of that array.  On the other hand, fixing should</span>
<a name="l09628"></a>09628 <span class="comment">    not be performed on the elements when taking a slice of an array!</span>
<a name="l09629"></a>09629 <span class="comment"></span>
<a name="l09630"></a>09630 <span class="comment">    Note that one of the side-effects of miscomputing the offset and</span>
<a name="l09631"></a>09631 <span class="comment">    size of each field is that we end up also miscomputing the size</span>
<a name="l09632"></a>09632 <span class="comment">    of the containing type.  This can have adverse results when computing</span>
<a name="l09633"></a>09633 <span class="comment">    the value of an entity.  GDB fetches the value of an entity based</span>
<a name="l09634"></a>09634 <span class="comment">    on the size of its type, and thus a wrong size causes GDB to fetch</span>
<a name="l09635"></a>09635 <span class="comment">    the wrong amount of memory.  In the case where the computed size is</span>
<a name="l09636"></a>09636 <span class="comment">    too small, GDB fetches too little data to print the value of our</span>
<a name="l09637"></a>09637 <span class="comment">    entiry.  Results in this case as unpredicatble, as we usually read</span>
<a name="l09638"></a>09638 <span class="comment">    past the buffer containing the data =:-o.  */</span>
<a name="l09639"></a>09639 
<a name="l09640"></a>09640 <span class="comment">/* Implement the evaluate_exp routine in the exp_descriptor structure</span>
<a name="l09641"></a>09641 <span class="comment">   for the Ada language.  */</span>
<a name="l09642"></a>09642 
<a name="l09643"></a>09643 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l09644"></a>09644 ada_evaluate_subexp (<span class="keyword">struct</span> type *expect_type, <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp,
<a name="l09645"></a>09645                      <span class="keywordtype">int</span> *pos, <span class="keyword">enum</span> noside noside)
<a name="l09646"></a>09646 {
<a name="l09647"></a>09647   <span class="keyword">enum</span> <a class="code" href="expression_8h.html#a13f8bfc7b2a183fe56716508bfddae41">exp_opcode</a> op;
<a name="l09648"></a>09648   <span class="keywordtype">int</span> tem;
<a name="l09649"></a>09649   <span class="keywordtype">int</span> pc;
<a name="l09650"></a>09650   <span class="keyword">struct </span>value *arg1 = NULL, *arg2 = NULL, *arg3;
<a name="l09651"></a>09651   <span class="keyword">struct </span>type *type;
<a name="l09652"></a>09652   <span class="keywordtype">int</span> nargs, oplen;
<a name="l09653"></a>09653   <span class="keyword">struct </span>value **argvec;
<a name="l09654"></a>09654 
<a name="l09655"></a>09655   pc = *pos;
<a name="l09656"></a>09656   *pos += 1;
<a name="l09657"></a>09657   op = exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a>;
<a name="l09658"></a>09658 
<a name="l09659"></a>09659   <span class="keywordflow">switch</span> (op)
<a name="l09660"></a>09660     {
<a name="l09661"></a>09661     <span class="keywordflow">default</span>:
<a name="l09662"></a>09662       *pos -= 1;
<a name="l09663"></a>09663       arg1 = <a class="code" href="eval_8c.html#aac37a75d90c006cb91019b11d6ebb6ef">evaluate_subexp_standard</a> (expect_type, exp, pos, noside);
<a name="l09664"></a>09664 
<a name="l09665"></a>09665       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a2e0f47a90a425663b11d68b22e45be95">EVAL_NORMAL</a>)
<a name="l09666"></a>09666         arg1 = unwrap_value (arg1);
<a name="l09667"></a>09667 
<a name="l09668"></a>09668       <span class="comment">/* If evaluating an OP_DOUBLE and an EXPECT_TYPE was provided,</span>
<a name="l09669"></a>09669 <span class="comment">         then we need to perform the conversion manually, because</span>
<a name="l09670"></a>09670 <span class="comment">         evaluate_subexp_standard doesn&#39;t do it.  This conversion is</span>
<a name="l09671"></a>09671 <span class="comment">         necessary in Ada because the different kinds of float/fixed</span>
<a name="l09672"></a>09672 <span class="comment">         types in Ada have different representations.</span>
<a name="l09673"></a>09673 <span class="comment"></span>
<a name="l09674"></a>09674 <span class="comment">         Similarly, we need to perform the conversion from OP_LONG</span>
<a name="l09675"></a>09675 <span class="comment">         ourselves.  */</span>
<a name="l09676"></a>09676       <span class="keywordflow">if</span> ((op == OP_DOUBLE || op == OP_LONG) &amp;&amp; expect_type != NULL)
<a name="l09677"></a>09677         arg1 = ada_value_cast (expect_type, arg1, noside);
<a name="l09678"></a>09678 
<a name="l09679"></a>09679       <span class="keywordflow">return</span> arg1;
<a name="l09680"></a>09680 
<a name="l09681"></a>09681     <span class="keywordflow">case</span> OP_STRING:
<a name="l09682"></a>09682       {
<a name="l09683"></a>09683         <span class="keyword">struct </span>value *result;
<a name="l09684"></a>09684 
<a name="l09685"></a>09685         *pos -= 1;
<a name="l09686"></a>09686         result = <a class="code" href="eval_8c.html#aac37a75d90c006cb91019b11d6ebb6ef">evaluate_subexp_standard</a> (expect_type, exp, pos, noside);
<a name="l09687"></a>09687         <span class="comment">/* The result type will have code OP_STRING, bashed there from </span>
<a name="l09688"></a>09688 <span class="comment">           OP_ARRAY.  Bash it back.  */</span>
<a name="l09689"></a>09689         <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (result)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a956ce01e5c83060e05208c9404fedca2">TYPE_CODE_STRING</a>)
<a name="l09690"></a>09690           <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (result)) = <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>;
<a name="l09691"></a>09691         <span class="keywordflow">return</span> result;
<a name="l09692"></a>09692       }
<a name="l09693"></a>09693 
<a name="l09694"></a>09694     <span class="keywordflow">case</span> UNOP_CAST:
<a name="l09695"></a>09695       (*pos) += 2;
<a name="l09696"></a>09696       type = exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>;
<a name="l09697"></a>09697       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (type, exp, pos, noside);
<a name="l09698"></a>09698       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l09699"></a>09699         <span class="keywordflow">goto</span> nosideret;
<a name="l09700"></a>09700       arg1 = ada_value_cast (type, arg1, noside);
<a name="l09701"></a>09701       <span class="keywordflow">return</span> arg1;
<a name="l09702"></a>09702 
<a name="l09703"></a>09703     <span class="keywordflow">case</span> UNOP_QUAL:
<a name="l09704"></a>09704       (*pos) += 2;
<a name="l09705"></a>09705       type = exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>;
<a name="l09706"></a>09706       <span class="keywordflow">return</span> ada_evaluate_subexp (type, exp, pos, noside);
<a name="l09707"></a>09707 
<a name="l09708"></a>09708     <span class="keywordflow">case</span> BINOP_ASSIGN:
<a name="l09709"></a>09709       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l09710"></a>09710       <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[*pos].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a> == OP_AGGREGATE)
<a name="l09711"></a>09711         {
<a name="l09712"></a>09712           arg1 = assign_aggregate (arg1, arg1, exp, pos, noside);
<a name="l09713"></a>09713           <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a> || noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l09714"></a>09714             <span class="keywordflow">return</span> arg1;
<a name="l09715"></a>09715           <span class="keywordflow">return</span> ada_value_assign (arg1, arg1);
<a name="l09716"></a>09716         }
<a name="l09717"></a>09717       <span class="comment">/* Force the evaluation of the rhs ARG2 to the type of the lhs ARG1,</span>
<a name="l09718"></a>09718 <span class="comment">         except if the lhs of our assignment is a convenience variable.</span>
<a name="l09719"></a>09719 <span class="comment">         In the case of assigning to a convenience variable, the lhs</span>
<a name="l09720"></a>09720 <span class="comment">         should be exactly the result of the evaluation of the rhs.  */</span>
<a name="l09721"></a>09721       type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1);
<a name="l09722"></a>09722       <span class="keywordflow">if</span> (<a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (arg1) == <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba8dfa3647df3362b7c410ac31f6cde323">lval_internalvar</a>)
<a name="l09723"></a>09723          type = NULL;
<a name="l09724"></a>09724       arg2 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (type, exp, pos, noside);
<a name="l09725"></a>09725       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a> || noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l09726"></a>09726         <span class="keywordflow">return</span> arg1;
<a name="l09727"></a>09727       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#afe50295540937b9ae0f68f2be4794f18">ada_is_fixed_point_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1)))
<a name="l09728"></a>09728         arg2 = cast_to_fixed (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1), arg2);
<a name="l09729"></a>09729       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#afe50295540937b9ae0f68f2be4794f18">ada_is_fixed_point_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2)))
<a name="l09730"></a>09730         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a>
<a name="l09731"></a>09731           (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Fixed-point values must be assigned to fixed-point variables&quot;</span>));
<a name="l09732"></a>09732       <span class="keywordflow">else</span>
<a name="l09733"></a>09733         arg2 = coerce_for_assign (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1), arg2);
<a name="l09734"></a>09734       <span class="keywordflow">return</span> ada_value_assign (arg1, arg2);
<a name="l09735"></a>09735 
<a name="l09736"></a>09736     <span class="keywordflow">case</span> BINOP_ADD:
<a name="l09737"></a>09737       arg1 = <a class="code" href="eval_8c.html#a0ca6dc8b19249f914656b9a3108c73c0">evaluate_subexp_with_coercion</a> (exp, pos, noside);
<a name="l09738"></a>09738       arg2 = <a class="code" href="eval_8c.html#a0ca6dc8b19249f914656b9a3108c73c0">evaluate_subexp_with_coercion</a> (exp, pos, noside);
<a name="l09739"></a>09739       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l09740"></a>09740         <span class="keywordflow">goto</span> nosideret;
<a name="l09741"></a>09741       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l09742"></a>09742         <span class="keywordflow">return</span> (<a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a>
<a name="l09743"></a>09743                  (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1),
<a name="l09744"></a>09744                   <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg1) + <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg2)));
<a name="l09745"></a>09745       <span class="keywordflow">if</span> ((<a class="code" href="ada-lang_8c.html#afe50295540937b9ae0f68f2be4794f18">ada_is_fixed_point_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1))
<a name="l09746"></a>09746            || <a class="code" href="ada-lang_8c.html#afe50295540937b9ae0f68f2be4794f18">ada_is_fixed_point_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2)))
<a name="l09747"></a>09747           &amp;&amp; <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1) != <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2))
<a name="l09748"></a>09748         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Operands of fixed-point addition must have the same type&quot;</span>));
<a name="l09749"></a>09749       <span class="comment">/* Do the addition, and cast the result to the type of the first</span>
<a name="l09750"></a>09750 <span class="comment">         argument.  We cannot cast the result to a reference type, so if</span>
<a name="l09751"></a>09751 <span class="comment">         ARG1 is a reference type, find its underlying type.  */</span>
<a name="l09752"></a>09752       type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1);
<a name="l09753"></a>09753       <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l09754"></a>09754         type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l09755"></a>09755       <a class="code" href="eval_8c.html#a693b03e492de02e792891333afe603d3">binop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1, &amp;arg2);
<a name="l09756"></a>09756       <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (type, <a class="code" href="valarith_8c.html#ae19c265649cb1b29f4fbda94d76ec495">value_binop</a> (arg1, arg2, BINOP_ADD));
<a name="l09757"></a>09757 
<a name="l09758"></a>09758     <span class="keywordflow">case</span> BINOP_SUB:
<a name="l09759"></a>09759       arg1 = <a class="code" href="eval_8c.html#a0ca6dc8b19249f914656b9a3108c73c0">evaluate_subexp_with_coercion</a> (exp, pos, noside);
<a name="l09760"></a>09760       arg2 = <a class="code" href="eval_8c.html#a0ca6dc8b19249f914656b9a3108c73c0">evaluate_subexp_with_coercion</a> (exp, pos, noside);
<a name="l09761"></a>09761       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l09762"></a>09762         <span class="keywordflow">goto</span> nosideret;
<a name="l09763"></a>09763       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l09764"></a>09764         <span class="keywordflow">return</span> (<a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a>
<a name="l09765"></a>09765                  (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1),
<a name="l09766"></a>09766                   <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg1) - <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (arg2)));
<a name="l09767"></a>09767       <span class="keywordflow">if</span> ((<a class="code" href="ada-lang_8c.html#afe50295540937b9ae0f68f2be4794f18">ada_is_fixed_point_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1))
<a name="l09768"></a>09768            || <a class="code" href="ada-lang_8c.html#afe50295540937b9ae0f68f2be4794f18">ada_is_fixed_point_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2)))
<a name="l09769"></a>09769           &amp;&amp; <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1) != <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2))
<a name="l09770"></a>09770         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Operands of fixed-point subtraction &quot;</span>
<a name="l09771"></a>09771                  <span class="stringliteral">&quot;must have the same type&quot;</span>));
<a name="l09772"></a>09772       <span class="comment">/* Do the substraction, and cast the result to the type of the first</span>
<a name="l09773"></a>09773 <span class="comment">         argument.  We cannot cast the result to a reference type, so if</span>
<a name="l09774"></a>09774 <span class="comment">         ARG1 is a reference type, find its underlying type.  */</span>
<a name="l09775"></a>09775       type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1);
<a name="l09776"></a>09776       <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l09777"></a>09777         type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l09778"></a>09778       <a class="code" href="eval_8c.html#a693b03e492de02e792891333afe603d3">binop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1, &amp;arg2);
<a name="l09779"></a>09779       <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (type, <a class="code" href="valarith_8c.html#ae19c265649cb1b29f4fbda94d76ec495">value_binop</a> (arg1, arg2, BINOP_SUB));
<a name="l09780"></a>09780 
<a name="l09781"></a>09781     <span class="keywordflow">case</span> BINOP_MUL:
<a name="l09782"></a>09782     <span class="keywordflow">case</span> BINOP_DIV:
<a name="l09783"></a>09783     <span class="keywordflow">case</span> BINOP_REM:
<a name="l09784"></a>09784     <span class="keywordflow">case</span> BINOP_MOD:
<a name="l09785"></a>09785       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l09786"></a>09786       arg2 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l09787"></a>09787       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l09788"></a>09788         <span class="keywordflow">goto</span> nosideret;
<a name="l09789"></a>09789       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l09790"></a>09790         {
<a name="l09791"></a>09791           <a class="code" href="eval_8c.html#a693b03e492de02e792891333afe603d3">binop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1, &amp;arg2);
<a name="l09792"></a>09792           <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1), <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l09793"></a>09793         }
<a name="l09794"></a>09794       <span class="keywordflow">else</span>
<a name="l09795"></a>09795         {
<a name="l09796"></a>09796           type = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>)-&gt;<a class="code" href="structbuiltin__type.html#a29f1e28c1aa70321c4c7d4094f672b57">builtin_double</a>;
<a name="l09797"></a>09797           <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#afe50295540937b9ae0f68f2be4794f18">ada_is_fixed_point_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1)))
<a name="l09798"></a>09798             arg1 = cast_from_fixed (type, arg1);
<a name="l09799"></a>09799           <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#afe50295540937b9ae0f68f2be4794f18">ada_is_fixed_point_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2)))
<a name="l09800"></a>09800             arg2 = cast_from_fixed (type, arg2);
<a name="l09801"></a>09801           <a class="code" href="eval_8c.html#a693b03e492de02e792891333afe603d3">binop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1, &amp;arg2);
<a name="l09802"></a>09802           <span class="keywordflow">return</span> ada_value_binop (arg1, arg2, op);
<a name="l09803"></a>09803         }
<a name="l09804"></a>09804 
<a name="l09805"></a>09805     <span class="keywordflow">case</span> BINOP_EQUAL:
<a name="l09806"></a>09806     <span class="keywordflow">case</span> BINOP_NOTEQUAL:
<a name="l09807"></a>09807       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l09808"></a>09808       arg2 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1), exp, pos, noside);
<a name="l09809"></a>09809       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l09810"></a>09810         <span class="keywordflow">goto</span> nosideret;
<a name="l09811"></a>09811       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l09812"></a>09812         tem = 0;
<a name="l09813"></a>09813       <span class="keywordflow">else</span>
<a name="l09814"></a>09814         {
<a name="l09815"></a>09815           <a class="code" href="eval_8c.html#a693b03e492de02e792891333afe603d3">binop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1, &amp;arg2);
<a name="l09816"></a>09816           tem = ada_value_equal (arg1, arg2);
<a name="l09817"></a>09817         }
<a name="l09818"></a>09818       <span class="keywordflow">if</span> (op == BINOP_NOTEQUAL)
<a name="l09819"></a>09819         tem = !tem;
<a name="l09820"></a>09820       type = <a class="code" href="language_8c.html#a54ec89b36edf0cd93a00fe594361f90c">language_bool_type</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>);
<a name="l09821"></a>09821       <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) tem);
<a name="l09822"></a>09822 
<a name="l09823"></a>09823     <span class="keywordflow">case</span> UNOP_NEG:
<a name="l09824"></a>09824       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l09825"></a>09825       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l09826"></a>09826         <span class="keywordflow">goto</span> nosideret;
<a name="l09827"></a>09827       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#afe50295540937b9ae0f68f2be4794f18">ada_is_fixed_point_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1)))
<a name="l09828"></a>09828         <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1), <a class="code" href="valarith_8c.html#a648003ef947065a363712c65ea97c11c">value_neg</a> (arg1));
<a name="l09829"></a>09829       <span class="keywordflow">else</span>
<a name="l09830"></a>09830         {
<a name="l09831"></a>09831           <a class="code" href="eval_8c.html#aaf029974a20b0a9016fdcf41c7aeac3f">unop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1);
<a name="l09832"></a>09832           <span class="keywordflow">return</span> <a class="code" href="valarith_8c.html#a648003ef947065a363712c65ea97c11c">value_neg</a> (arg1);
<a name="l09833"></a>09833         }
<a name="l09834"></a>09834 
<a name="l09835"></a>09835     <span class="keywordflow">case</span> BINOP_LOGICAL_AND:
<a name="l09836"></a>09836     <span class="keywordflow">case</span> BINOP_LOGICAL_OR:
<a name="l09837"></a>09837     <span class="keywordflow">case</span> UNOP_LOGICAL_NOT:
<a name="l09838"></a>09838       {
<a name="l09839"></a>09839         <span class="keyword">struct </span>value *val;
<a name="l09840"></a>09840 
<a name="l09841"></a>09841         *pos -= 1;
<a name="l09842"></a>09842         val = <a class="code" href="eval_8c.html#aac37a75d90c006cb91019b11d6ebb6ef">evaluate_subexp_standard</a> (expect_type, exp, pos, noside);
<a name="l09843"></a>09843         type = <a class="code" href="language_8c.html#a54ec89b36edf0cd93a00fe594361f90c">language_bool_type</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>);
<a name="l09844"></a>09844         <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (type, val);
<a name="l09845"></a>09845       }
<a name="l09846"></a>09846 
<a name="l09847"></a>09847     <span class="keywordflow">case</span> BINOP_BITWISE_AND:
<a name="l09848"></a>09848     <span class="keywordflow">case</span> BINOP_BITWISE_IOR:
<a name="l09849"></a>09849     <span class="keywordflow">case</span> BINOP_BITWISE_XOR:
<a name="l09850"></a>09850       {
<a name="l09851"></a>09851         <span class="keyword">struct </span>value *val;
<a name="l09852"></a>09852 
<a name="l09853"></a>09853         arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>);
<a name="l09854"></a>09854         *pos = pc;
<a name="l09855"></a>09855         val = <a class="code" href="eval_8c.html#aac37a75d90c006cb91019b11d6ebb6ef">evaluate_subexp_standard</a> (expect_type, exp, pos, noside);
<a name="l09856"></a>09856 
<a name="l09857"></a>09857         <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1), val);
<a name="l09858"></a>09858       }
<a name="l09859"></a>09859 
<a name="l09860"></a>09860     <span class="keywordflow">case</span> OP_VAR_VALUE:
<a name="l09861"></a>09861       *pos -= 1;
<a name="l09862"></a>09862 
<a name="l09863"></a>09863       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l09864"></a>09864         {
<a name="l09865"></a>09865           *pos += 4;
<a name="l09866"></a>09866           <span class="keywordflow">goto</span> nosideret;
<a name="l09867"></a>09867         }
<a name="l09868"></a>09868       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>) == <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa6b943c7bcdab5c62ae6a0cbe8929f91f">UNDEF_DOMAIN</a>)
<a name="l09869"></a>09869         <span class="comment">/* Only encountered when an unresolved symbol occurs in a</span>
<a name="l09870"></a>09870 <span class="comment">           context other than a function call, in which case, it is</span>
<a name="l09871"></a>09871 <span class="comment">           invalid.  */</span>
<a name="l09872"></a>09872         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unexpected unresolved symbol, %s, during evaluation&quot;</span>),
<a name="l09873"></a>09873                <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>));
<a name="l09874"></a>09874       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l09875"></a>09875         {
<a name="l09876"></a>09876           type = static_unwrap_type (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>));
<a name="l09877"></a>09877           <span class="comment">/* Check to see if this is a tagged type.  We also need to handle</span>
<a name="l09878"></a>09878 <span class="comment">             the case where the type is a reference to a tagged type, but</span>
<a name="l09879"></a>09879 <span class="comment">             we have to be careful to exclude pointers to tagged types.</span>
<a name="l09880"></a>09880 <span class="comment">             The latter should be shown as usual (as a pointer), whereas</span>
<a name="l09881"></a>09881 <span class="comment">             a reference should mostly be transparent to the user.  */</span>
<a name="l09882"></a>09882           <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#abbecc644387ffb0a43e57ed0462c2c8b">ada_is_tagged_type</a> (type, 0)
<a name="l09883"></a>09883               || (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a>(type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>
<a name="l09884"></a>09884                   &amp;&amp; <a class="code" href="ada-lang_8c.html#abbecc644387ffb0a43e57ed0462c2c8b">ada_is_tagged_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type), 0)))
<a name="l09885"></a>09885           {
<a name="l09886"></a>09886             <span class="comment">/* Tagged types are a little special in the fact that the real</span>
<a name="l09887"></a>09887 <span class="comment">               type is dynamic and can only be determined by inspecting the</span>
<a name="l09888"></a>09888 <span class="comment">               object&#39;s tag.  This means that we need to get the object&#39;s</span>
<a name="l09889"></a>09889 <span class="comment">               value first (EVAL_NORMAL) and then extract the actual object</span>
<a name="l09890"></a>09890 <span class="comment">               type from its tag.</span>
<a name="l09891"></a>09891 <span class="comment"></span>
<a name="l09892"></a>09892 <span class="comment">               Note that we cannot skip the final step where we extract</span>
<a name="l09893"></a>09893 <span class="comment">               the object type from its tag, because the EVAL_NORMAL phase</span>
<a name="l09894"></a>09894 <span class="comment">               results in dynamic components being resolved into fixed ones.</span>
<a name="l09895"></a>09895 <span class="comment">               This can cause problems when trying to print the type</span>
<a name="l09896"></a>09896 <span class="comment">               description of tagged types whose parent has a dynamic size:</span>
<a name="l09897"></a>09897 <span class="comment">               We use the type name of the &quot;_parent&quot; component in order</span>
<a name="l09898"></a>09898 <span class="comment">               to print the name of the ancestor type in the type description.</span>
<a name="l09899"></a>09899 <span class="comment">               If that component had a dynamic size, the resolution into</span>
<a name="l09900"></a>09900 <span class="comment">               a fixed type would result in the loss of that type name,</span>
<a name="l09901"></a>09901 <span class="comment">               thus preventing us from printing the name of the ancestor</span>
<a name="l09902"></a>09902 <span class="comment">               type in the type description.  */</span>
<a name="l09903"></a>09903             arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a2e0f47a90a425663b11d68b22e45be95">EVAL_NORMAL</a>);
<a name="l09904"></a>09904 
<a name="l09905"></a>09905             <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l09906"></a>09906               {
<a name="l09907"></a>09907                 <span class="keyword">struct </span>type *actual_type;
<a name="l09908"></a>09908 
<a name="l09909"></a>09909                 actual_type = type_from_tag (<a class="code" href="ada-lang_8c.html#a13e4a462cc436fc761a68f1e378316db">ada_value_tag</a> (arg1));
<a name="l09910"></a>09910                 <span class="keywordflow">if</span> (actual_type == NULL)
<a name="l09911"></a>09911                   <span class="comment">/* If, for some reason, we were unable to determine</span>
<a name="l09912"></a>09912 <span class="comment">                     the actual type from the tag, then use the static</span>
<a name="l09913"></a>09913 <span class="comment">                     approximation that we just computed as a fallback.</span>
<a name="l09914"></a>09914 <span class="comment">                     This can happen if the debugging information is</span>
<a name="l09915"></a>09915 <span class="comment">                     incomplete, for instance.  */</span>
<a name="l09916"></a>09916                   actual_type = type;
<a name="l09917"></a>09917                 <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (actual_type, <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l09918"></a>09918               }
<a name="l09919"></a>09919             <span class="keywordflow">else</span>
<a name="l09920"></a>09920               {
<a name="l09921"></a>09921                 <span class="comment">/* In the case of a ref, ada_coerce_ref takes care</span>
<a name="l09922"></a>09922 <span class="comment">                   of determining the actual type.  But the evaluation</span>
<a name="l09923"></a>09923 <span class="comment">                   should return a ref as it should be valid to ask</span>
<a name="l09924"></a>09924 <span class="comment">                   for its address; so rebuild a ref after coerce.  */</span>
<a name="l09925"></a>09925                 arg1 = ada_coerce_ref (arg1);
<a name="l09926"></a>09926                 <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#ab73ccebbfb87a9332020dcf03976b053">value_ref</a> (arg1);
<a name="l09927"></a>09927               }
<a name="l09928"></a>09928           }
<a name="l09929"></a>09929 
<a name="l09930"></a>09930           *pos += 4;
<a name="l09931"></a>09931           <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a>
<a name="l09932"></a>09932             (to_static_fixed_type
<a name="l09933"></a>09933              (static_unwrap_type (<a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>))),
<a name="l09934"></a>09934              <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l09935"></a>09935         }
<a name="l09936"></a>09936       <span class="keywordflow">else</span>
<a name="l09937"></a>09937         {
<a name="l09938"></a>09938           arg1 = <a class="code" href="eval_8c.html#aac37a75d90c006cb91019b11d6ebb6ef">evaluate_subexp_standard</a> (expect_type, exp, pos, noside);
<a name="l09939"></a>09939           <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#aff7bccfb43d0188dfaf758dffe8b58ce">ada_to_fixed_value</a> (arg1);
<a name="l09940"></a>09940         }
<a name="l09941"></a>09941 
<a name="l09942"></a>09942     <span class="keywordflow">case</span> OP_FUNCALL:
<a name="l09943"></a>09943       (*pos) += 2;
<a name="l09944"></a>09944 
<a name="l09945"></a>09945       <span class="comment">/* Allocate arg vector, including space for the function to be</span>
<a name="l09946"></a>09946 <span class="comment">         called in argvec[0] and a terminating NULL.  */</span>
<a name="l09947"></a>09947       nargs = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l09948"></a>09948       argvec =
<a name="l09949"></a>09949         (<span class="keyword">struct </span>value **) alloca (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> value *) * (nargs + 2));
<a name="l09950"></a>09950 
<a name="l09951"></a>09951       <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[*pos].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a> == OP_VAR_VALUE
<a name="l09952"></a>09952           &amp;&amp; <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 5].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>) == <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa6b943c7bcdab5c62ae6a0cbe8929f91f">UNDEF_DOMAIN</a>)
<a name="l09953"></a>09953         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unexpected unresolved symbol, %s, during evaluation&quot;</span>),
<a name="l09954"></a>09954                <a class="code" href="symtab_8h.html#ac7f4cb1648125545fbd0e4f13b0c572c">SYMBOL_PRINT_NAME</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 5].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>));
<a name="l09955"></a>09955       <span class="keywordflow">else</span>
<a name="l09956"></a>09956         {
<a name="l09957"></a>09957           <span class="keywordflow">for</span> (tem = 0; tem &lt;= nargs; tem += 1)
<a name="l09958"></a>09958             argvec[tem] = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l09959"></a>09959           argvec[tem] = 0;
<a name="l09960"></a>09960 
<a name="l09961"></a>09961           <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l09962"></a>09962             <span class="keywordflow">goto</span> nosideret;
<a name="l09963"></a>09963         }
<a name="l09964"></a>09964 
<a name="l09965"></a>09965       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a>
<a name="l09966"></a>09966           (desc_base_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (argvec[0]))))
<a name="l09967"></a>09967         argvec[0] = <a class="code" href="ada-lang_8c.html#a184966871049f553a895f96f7590884a">ada_coerce_to_simple_array</a> (argvec[0]);
<a name="l09968"></a>09968       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (argvec[0])) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l09969"></a>09969                &amp;&amp; <a class="code" href="gdbtypes_8h.html#abc55e4d1aac1dfb1c8183d412aca66b1">TYPE_FIELD_BITSIZE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (argvec[0]), 0) != 0)
<a name="l09970"></a>09970         <span class="comment">/* This is a packed array that has already been fixed, and</span>
<a name="l09971"></a>09971 <span class="comment">           therefore already coerced to a simple array.  Nothing further</span>
<a name="l09972"></a>09972 <span class="comment">           to do.  */</span>
<a name="l09973"></a>09973         ;
<a name="l09974"></a>09974       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (argvec[0])) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>
<a name="l09975"></a>09975                || (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (argvec[0])) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l09976"></a>09976                    &amp;&amp; <a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (argvec[0]) == <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>))
<a name="l09977"></a>09977         argvec[0] = <a class="code" href="valops_8c.html#a29bc320305726a3cbf324189df2ca772">value_addr</a> (argvec[0]);
<a name="l09978"></a>09978 
<a name="l09979"></a>09979       type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (argvec[0]));
<a name="l09980"></a>09980 
<a name="l09981"></a>09981       <span class="comment">/* Ada allows us to implicitly dereference arrays when subscripting</span>
<a name="l09982"></a>09982 <span class="comment">         them.  So, if this is an array typedef (encoding use for array</span>
<a name="l09983"></a>09983 <span class="comment">         access types encoded as fat pointers), strip it now.  */</span>
<a name="l09984"></a>09984       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462abd0f09e6db7ab38fde35eabec26f1d77">TYPE_CODE_TYPEDEF</a>)
<a name="l09985"></a>09985         type = ada_typedef_target_type (type);
<a name="l09986"></a>09986 
<a name="l09987"></a>09987       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l09988"></a>09988         {
<a name="l09989"></a>09989           <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type))))
<a name="l09990"></a>09990             {
<a name="l09991"></a>09991             <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>:
<a name="l09992"></a>09992               type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type));
<a name="l09993"></a>09993               <span class="keywordflow">break</span>;
<a name="l09994"></a>09994             <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>:
<a name="l09995"></a>09995               <span class="keywordflow">break</span>;
<a name="l09996"></a>09996             <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l09997"></a>09997               <span class="keywordflow">if</span> (noside != <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l09998"></a>09998                 argvec[0] = <a class="code" href="ada-lang_8c.html#a917a1ba2a6b58d43803a1f999164295b">ada_value_ind</a> (argvec[0]);
<a name="l09999"></a>09999               type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type));
<a name="l10000"></a>10000               <span class="keywordflow">break</span>;
<a name="l10001"></a>10001             <span class="keywordflow">default</span>:
<a name="l10002"></a>10002               <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot subscript or call something of type `%s&#39;&quot;</span>),
<a name="l10003"></a>10003                      <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (argvec[0])));
<a name="l10004"></a>10004               <span class="keywordflow">break</span>;
<a name="l10005"></a>10005             }
<a name="l10006"></a>10006         }
<a name="l10007"></a>10007 
<a name="l10008"></a>10008       <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l10009"></a>10009         {
<a name="l10010"></a>10010         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a4b6327934915849a4e96eef151fe312b">TYPE_CODE_FUNC</a>:
<a name="l10011"></a>10011           <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10012"></a>10012             {
<a name="l10013"></a>10013               <span class="keyword">struct </span>type *rtype = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l10014"></a>10014 
<a name="l10015"></a>10015               <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a7f4dd1784f286a82d4525c3a2175f9c9">TYPE_GNU_IFUNC</a> (type))
<a name="l10016"></a>10016                 <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (rtype));
<a name="l10017"></a>10017               <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (rtype);
<a name="l10018"></a>10018             }
<a name="l10019"></a>10019           <span class="keywordflow">return</span> <a class="code" href="infcall_8c.html#a8344d63cd8405f1e9fae104da173283d">call_function_by_hand</a> (argvec[0], nargs, argvec + 1);
<a name="l10020"></a>10020         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a5d698fd1c5c048c06f19bb245a856fbb">TYPE_CODE_INTERNAL_FUNCTION</a>:
<a name="l10021"></a>10021           <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10022"></a>10022             <span class="comment">/* We don&#39;t know anything about what the internal</span>
<a name="l10023"></a>10023 <span class="comment">               function might return, but we have to return</span>
<a name="l10024"></a>10024 <span class="comment">               something.  */</span>
<a name="l10025"></a>10025             <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (<a class="code" href="structbuiltin__type.html">builtin_type</a> (exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>)-&gt;<a class="code" href="structbuiltin__type.html#ab12f96a04e89e8c951f0eacb379f7ffc">builtin_int</a>,
<a name="l10026"></a>10026                                <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l10027"></a>10027           <span class="keywordflow">else</span>
<a name="l10028"></a>10028             <span class="keywordflow">return</span> <a class="code" href="value_8c.html#ae07d96e508c4030e2e0c7245562f0314">call_internal_function</a> (exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>,
<a name="l10029"></a>10029                                            argvec[0], nargs, argvec + 1);
<a name="l10030"></a>10030 
<a name="l10031"></a>10031         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l10032"></a>10032           {
<a name="l10033"></a>10033             <span class="keywordtype">int</span> arity;
<a name="l10034"></a>10034 
<a name="l10035"></a>10035             arity = <a class="code" href="ada-lang_8c.html#ae9a1f2e16ad116a02636b91afd809c4b">ada_array_arity</a> (type);
<a name="l10036"></a>10036             type = <a class="code" href="ada-lang_8c.html#a6d2b3240a3d6eabb276131b5753e804e">ada_array_element_type</a> (type, nargs);
<a name="l10037"></a>10037             <span class="keywordflow">if</span> (type == NULL)
<a name="l10038"></a>10038               <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot subscript or call a record&quot;</span>));
<a name="l10039"></a>10039             <span class="keywordflow">if</span> (arity != nargs)
<a name="l10040"></a>10040               <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;wrong number of subscripts; expecting %d&quot;</span>), arity);
<a name="l10041"></a>10041             <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10042"></a>10042               <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (<a class="code" href="ada-lang_8c.html#a67d9e8121909114afa44a208819f932f">ada_aligned_type</a> (type), <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>);
<a name="l10043"></a>10043             <span class="keywordflow">return</span>
<a name="l10044"></a>10044               unwrap_value (<a class="code" href="ada-lang_8c.html#a40dcd8728888b5b445fa2a917076c1a9">ada_value_subscript</a>
<a name="l10045"></a>10045                             (argvec[0], nargs, argvec + 1));
<a name="l10046"></a>10046           }
<a name="l10047"></a>10047         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>:
<a name="l10048"></a>10048           <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10049"></a>10049             {
<a name="l10050"></a>10050               type = <a class="code" href="ada-lang_8c.html#a6d2b3240a3d6eabb276131b5753e804e">ada_array_element_type</a> (type, nargs);
<a name="l10051"></a>10051               <span class="keywordflow">if</span> (type == NULL)
<a name="l10052"></a>10052                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;element type of array unknown&quot;</span>));
<a name="l10053"></a>10053               <span class="keywordflow">else</span>
<a name="l10054"></a>10054                 <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (<a class="code" href="ada-lang_8c.html#a67d9e8121909114afa44a208819f932f">ada_aligned_type</a> (type), <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>);
<a name="l10055"></a>10055             }
<a name="l10056"></a>10056           <span class="keywordflow">return</span>
<a name="l10057"></a>10057             unwrap_value (<a class="code" href="ada-lang_8c.html#a40dcd8728888b5b445fa2a917076c1a9">ada_value_subscript</a>
<a name="l10058"></a>10058                           (<a class="code" href="ada-lang_8c.html#a184966871049f553a895f96f7590884a">ada_coerce_to_simple_array</a> (argvec[0]),
<a name="l10059"></a>10059                            nargs, argvec + 1));
<a name="l10060"></a>10060         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>:     <span class="comment">/* Pointer to array */</span>
<a name="l10061"></a>10061           type = to_fixed_array_type (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type), NULL, 1);
<a name="l10062"></a>10062           <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10063"></a>10063             {
<a name="l10064"></a>10064               type = <a class="code" href="ada-lang_8c.html#a6d2b3240a3d6eabb276131b5753e804e">ada_array_element_type</a> (type, nargs);
<a name="l10065"></a>10065               <span class="keywordflow">if</span> (type == NULL)
<a name="l10066"></a>10066                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;element type of array unknown&quot;</span>));
<a name="l10067"></a>10067               <span class="keywordflow">else</span>
<a name="l10068"></a>10068                 <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (<a class="code" href="ada-lang_8c.html#a67d9e8121909114afa44a208819f932f">ada_aligned_type</a> (type), <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>);
<a name="l10069"></a>10069             }
<a name="l10070"></a>10070           <span class="keywordflow">return</span>
<a name="l10071"></a>10071             unwrap_value (ada_value_ptr_subscript (argvec[0], type,
<a name="l10072"></a>10072                                                    nargs, argvec + 1));
<a name="l10073"></a>10073 
<a name="l10074"></a>10074         <span class="keywordflow">default</span>:
<a name="l10075"></a>10075           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attempt to index or call something other than an &quot;</span>
<a name="l10076"></a>10076                    <span class="stringliteral">&quot;array or function&quot;</span>));
<a name="l10077"></a>10077         }
<a name="l10078"></a>10078 
<a name="l10079"></a>10079     <span class="keywordflow">case</span> TERNOP_SLICE:
<a name="l10080"></a>10080       {
<a name="l10081"></a>10081         <span class="keyword">struct </span>value *array = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10082"></a>10082         <span class="keyword">struct </span>value *low_bound_val =
<a name="l10083"></a>10083           <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10084"></a>10084         <span class="keyword">struct </span>value *high_bound_val =
<a name="l10085"></a>10085           <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10086"></a>10086         <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> low_bound;
<a name="l10087"></a>10087         <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> high_bound;
<a name="l10088"></a>10088 
<a name="l10089"></a>10089         low_bound_val = <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (low_bound_val);
<a name="l10090"></a>10090         high_bound_val = <a class="code" href="value_8c.html#aed5580291c7c798d71b3346932048a12">coerce_ref</a> (high_bound_val);
<a name="l10091"></a>10091         low_bound = pos_atr (low_bound_val);
<a name="l10092"></a>10092         high_bound = pos_atr (high_bound_val);
<a name="l10093"></a>10093 
<a name="l10094"></a>10094         <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10095"></a>10095           <span class="keywordflow">goto</span> nosideret;
<a name="l10096"></a>10096 
<a name="l10097"></a>10097         <span class="comment">/* If this is a reference to an aligner type, then remove all</span>
<a name="l10098"></a>10098 <span class="comment">           the aligners.  */</span>
<a name="l10099"></a>10099         <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>
<a name="l10100"></a>10100             &amp;&amp; <a class="code" href="ada-lang_8c.html#ac972c52cf860cdffae561d774c2f3258">ada_is_aligner_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array))))
<a name="l10101"></a>10101           <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array)) =
<a name="l10102"></a>10102             <a class="code" href="ada-lang_8c.html#a67d9e8121909114afa44a208819f932f">ada_aligned_type</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array)));
<a name="l10103"></a>10103 
<a name="l10104"></a>10104         <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array)))
<a name="l10105"></a>10105           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot slice a packed array&quot;</span>));
<a name="l10106"></a>10106 
<a name="l10107"></a>10107         <span class="comment">/* If this is a reference to an array or an array lvalue,</span>
<a name="l10108"></a>10108 <span class="comment">           convert to a pointer.  */</span>
<a name="l10109"></a>10109         <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>
<a name="l10110"></a>10110             || (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>
<a name="l10111"></a>10111                 &amp;&amp; <a class="code" href="value_8h.html#a39f15e604dd7037545ce2774310b0cd5">VALUE_LVAL</a> (array) == <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>))
<a name="l10112"></a>10112           array = <a class="code" href="valops_8c.html#a29bc320305726a3cbf324189df2ca772">value_addr</a> (array);
<a name="l10113"></a>10113 
<a name="l10114"></a>10114         <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>
<a name="l10115"></a>10115             &amp;&amp; <a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a>
<a name="l10116"></a>10116                                              (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array))))
<a name="l10117"></a>10117           <span class="keywordflow">return</span> empty_array (<a class="code" href="ada-lang_8c.html#a7a98282573c2d74e48913babce683aa0">ada_type_of_array</a> (array, 0), low_bound);
<a name="l10118"></a>10118 
<a name="l10119"></a>10119         array = <a class="code" href="ada-lang_8c.html#ae180af59d7a123a3aefc23883acb77d7">ada_coerce_to_simple_array_ptr</a> (array);
<a name="l10120"></a>10120 
<a name="l10121"></a>10121         <span class="comment">/* If we have more than one level of pointer indirection,</span>
<a name="l10122"></a>10122 <span class="comment">           dereference the value until we get only one level.  */</span>
<a name="l10123"></a>10123         <span class="keywordflow">while</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array)) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l10124"></a>10124                &amp;&amp; (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array)))
<a name="l10125"></a>10125                      == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>))
<a name="l10126"></a>10126           array = <a class="code" href="valops_8c.html#af1f1e44875d884ca57ccedf048016cc7">value_ind</a> (array);
<a name="l10127"></a>10127 
<a name="l10128"></a>10128         <span class="comment">/* Make sure we really do have an array type before going further,</span>
<a name="l10129"></a>10129 <span class="comment">           to avoid a SEGV when trying to get the index type or the target</span>
<a name="l10130"></a>10130 <span class="comment">           type later down the road if the debug info generated by</span>
<a name="l10131"></a>10131 <span class="comment">           the compiler is incorrect or incomplete.  */</span>
<a name="l10132"></a>10132         <span class="keywordflow">if</span> (!<a class="code" href="ada-lang_8c.html#a98ee7e79620d6af77ffd35c586fcf7bd">ada_is_simple_array_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array)))
<a name="l10133"></a>10133           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot take slice of non-array&quot;</span>));
<a name="l10134"></a>10134 
<a name="l10135"></a>10135         <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array)))
<a name="l10136"></a>10136             == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>)
<a name="l10137"></a>10137           {
<a name="l10138"></a>10138             <span class="keyword">struct </span>type *type0 = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array));
<a name="l10139"></a>10139 
<a name="l10140"></a>10140             <span class="keywordflow">if</span> (high_bound &lt; low_bound || noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10141"></a>10141               <span class="keywordflow">return</span> empty_array (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type0), low_bound);
<a name="l10142"></a>10142             <span class="keywordflow">else</span>
<a name="l10143"></a>10143               {
<a name="l10144"></a>10144                 <span class="keyword">struct </span>type *arr_type0 =
<a name="l10145"></a>10145                   to_fixed_array_type (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type0), NULL, 1);
<a name="l10146"></a>10146 
<a name="l10147"></a>10147                 <span class="keywordflow">return</span> ada_value_slice_from_ptr (array, arr_type0,
<a name="l10148"></a>10148                                                  <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (low_bound),
<a name="l10149"></a>10149                                                  <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (high_bound));
<a name="l10150"></a>10150               }
<a name="l10151"></a>10151           }
<a name="l10152"></a>10152         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10153"></a>10153           <span class="keywordflow">return</span> array;
<a name="l10154"></a>10154         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (high_bound &lt; low_bound)
<a name="l10155"></a>10155           <span class="keywordflow">return</span> empty_array (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (array), low_bound);
<a name="l10156"></a>10156         <span class="keywordflow">else</span>
<a name="l10157"></a>10157           <span class="keywordflow">return</span> ada_value_slice (array, <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (low_bound),
<a name="l10158"></a>10158                                   <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (high_bound));
<a name="l10159"></a>10159       }
<a name="l10160"></a>10160 
<a name="l10161"></a>10161     <span class="keywordflow">case</span> UNOP_IN_RANGE:
<a name="l10162"></a>10162       (*pos) += 2;
<a name="l10163"></a>10163       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10164"></a>10164       type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>);
<a name="l10165"></a>10165 
<a name="l10166"></a>10166       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10167"></a>10167         <span class="keywordflow">goto</span> nosideret;
<a name="l10168"></a>10168 
<a name="l10169"></a>10169       <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type))
<a name="l10170"></a>10170         {
<a name="l10171"></a>10171         <span class="keywordflow">default</span>:
<a name="l10172"></a>10172           lim_warning (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Membership test incompletely implemented; &quot;</span>
<a name="l10173"></a>10173                          <span class="stringliteral">&quot;always returns true&quot;</span>));
<a name="l10174"></a>10174           type = <a class="code" href="language_8c.html#a54ec89b36edf0cd93a00fe594361f90c">language_bool_type</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>);
<a name="l10175"></a>10175           <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) 1);
<a name="l10176"></a>10176 
<a name="l10177"></a>10177         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>:
<a name="l10178"></a>10178           arg2 = <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, <a class="code" href="gdbtypes_8h.html#a8a35064d1a955f191b0a63b03755689b">TYPE_LOW_BOUND</a> (type));
<a name="l10179"></a>10179           arg3 = <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, <a class="code" href="gdbtypes_8h.html#a77cdc334123abc6858b3ea8b3361cd5d">TYPE_HIGH_BOUND</a> (type));
<a name="l10180"></a>10180           <a class="code" href="eval_8c.html#a693b03e492de02e792891333afe603d3">binop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1, &amp;arg2);
<a name="l10181"></a>10181           <a class="code" href="eval_8c.html#a693b03e492de02e792891333afe603d3">binop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1, &amp;arg3);
<a name="l10182"></a>10182           type = <a class="code" href="language_8c.html#a54ec89b36edf0cd93a00fe594361f90c">language_bool_type</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>);
<a name="l10183"></a>10183           <span class="keywordflow">return</span>
<a name="l10184"></a>10184             <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type,
<a name="l10185"></a>10185                                 (<a class="code" href="valarith_8c.html#acac6d9bf0d453fda1832fdf0ff07b3ff">value_less</a> (arg1, arg3)
<a name="l10186"></a>10186                                  || <a class="code" href="valarith_8c.html#ac4d029b78c2c89aeb0a07ee7ed1f63a5">value_equal</a> (arg1, arg3))
<a name="l10187"></a>10187                                 &amp;&amp; (<a class="code" href="valarith_8c.html#acac6d9bf0d453fda1832fdf0ff07b3ff">value_less</a> (arg2, arg1)
<a name="l10188"></a>10188                                     || <a class="code" href="valarith_8c.html#ac4d029b78c2c89aeb0a07ee7ed1f63a5">value_equal</a> (arg2, arg1)));
<a name="l10189"></a>10189         }
<a name="l10190"></a>10190 
<a name="l10191"></a>10191     <span class="keywordflow">case</span> BINOP_IN_BOUNDS:
<a name="l10192"></a>10192       (*pos) += 2;
<a name="l10193"></a>10193       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10194"></a>10194       arg2 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10195"></a>10195 
<a name="l10196"></a>10196       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10197"></a>10197         <span class="keywordflow">goto</span> nosideret;
<a name="l10198"></a>10198 
<a name="l10199"></a>10199       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10200"></a>10200         {
<a name="l10201"></a>10201           type = <a class="code" href="language_8c.html#a54ec89b36edf0cd93a00fe594361f90c">language_bool_type</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>);
<a name="l10202"></a>10202           <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (type, <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l10203"></a>10203         }
<a name="l10204"></a>10204 
<a name="l10205"></a>10205       tem = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l10206"></a>10206 
<a name="l10207"></a>10207       type = ada_index_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2), tem, <span class="stringliteral">&quot;range&quot;</span>);
<a name="l10208"></a>10208       <span class="keywordflow">if</span> (!type)
<a name="l10209"></a>10209         type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1);
<a name="l10210"></a>10210 
<a name="l10211"></a>10211       arg3 = <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, ada_array_bound (arg2, tem, 1));
<a name="l10212"></a>10212       arg2 = <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, ada_array_bound (arg2, tem, 0));
<a name="l10213"></a>10213 
<a name="l10214"></a>10214       <a class="code" href="eval_8c.html#a693b03e492de02e792891333afe603d3">binop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1, &amp;arg2);
<a name="l10215"></a>10215       <a class="code" href="eval_8c.html#a693b03e492de02e792891333afe603d3">binop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1, &amp;arg3);
<a name="l10216"></a>10216       type = <a class="code" href="language_8c.html#a54ec89b36edf0cd93a00fe594361f90c">language_bool_type</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>);
<a name="l10217"></a>10217       <span class="keywordflow">return</span>
<a name="l10218"></a>10218         <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type,
<a name="l10219"></a>10219                             (<a class="code" href="valarith_8c.html#acac6d9bf0d453fda1832fdf0ff07b3ff">value_less</a> (arg1, arg3)
<a name="l10220"></a>10220                              || <a class="code" href="valarith_8c.html#ac4d029b78c2c89aeb0a07ee7ed1f63a5">value_equal</a> (arg1, arg3))
<a name="l10221"></a>10221                             &amp;&amp; (<a class="code" href="valarith_8c.html#acac6d9bf0d453fda1832fdf0ff07b3ff">value_less</a> (arg2, arg1)
<a name="l10222"></a>10222                                 || <a class="code" href="valarith_8c.html#ac4d029b78c2c89aeb0a07ee7ed1f63a5">value_equal</a> (arg2, arg1)));
<a name="l10223"></a>10223 
<a name="l10224"></a>10224     <span class="keywordflow">case</span> TERNOP_IN_RANGE:
<a name="l10225"></a>10225       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10226"></a>10226       arg2 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10227"></a>10227       arg3 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10228"></a>10228 
<a name="l10229"></a>10229       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10230"></a>10230         <span class="keywordflow">goto</span> nosideret;
<a name="l10231"></a>10231 
<a name="l10232"></a>10232       <a class="code" href="eval_8c.html#a693b03e492de02e792891333afe603d3">binop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1, &amp;arg2);
<a name="l10233"></a>10233       <a class="code" href="eval_8c.html#a693b03e492de02e792891333afe603d3">binop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1, &amp;arg3);
<a name="l10234"></a>10234       type = <a class="code" href="language_8c.html#a54ec89b36edf0cd93a00fe594361f90c">language_bool_type</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>);
<a name="l10235"></a>10235       <span class="keywordflow">return</span>
<a name="l10236"></a>10236         <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type,
<a name="l10237"></a>10237                             (<a class="code" href="valarith_8c.html#acac6d9bf0d453fda1832fdf0ff07b3ff">value_less</a> (arg1, arg3)
<a name="l10238"></a>10238                              || <a class="code" href="valarith_8c.html#ac4d029b78c2c89aeb0a07ee7ed1f63a5">value_equal</a> (arg1, arg3))
<a name="l10239"></a>10239                             &amp;&amp; (<a class="code" href="valarith_8c.html#acac6d9bf0d453fda1832fdf0ff07b3ff">value_less</a> (arg2, arg1)
<a name="l10240"></a>10240                                 || <a class="code" href="valarith_8c.html#ac4d029b78c2c89aeb0a07ee7ed1f63a5">value_equal</a> (arg2, arg1)));
<a name="l10241"></a>10241 
<a name="l10242"></a>10242     <span class="keywordflow">case</span> OP_ATR_FIRST:
<a name="l10243"></a>10243     <span class="keywordflow">case</span> OP_ATR_LAST:
<a name="l10244"></a>10244     <span class="keywordflow">case</span> OP_ATR_LENGTH:
<a name="l10245"></a>10245       {
<a name="l10246"></a>10246         <span class="keyword">struct </span>type *type_arg;
<a name="l10247"></a>10247 
<a name="l10248"></a>10248         <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[*pos].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a> == OP_TYPE)
<a name="l10249"></a>10249           {
<a name="l10250"></a>10250             <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>);
<a name="l10251"></a>10251             arg1 = NULL;
<a name="l10252"></a>10252             type_arg = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>);
<a name="l10253"></a>10253           }
<a name="l10254"></a>10254         <span class="keywordflow">else</span>
<a name="l10255"></a>10255           {
<a name="l10256"></a>10256             arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10257"></a>10257             type_arg = NULL;
<a name="l10258"></a>10258           }
<a name="l10259"></a>10259 
<a name="l10260"></a>10260         <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[*pos].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a> != OP_LONG)
<a name="l10261"></a>10261           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Invalid operand to &#39;%s&quot;</span>), <a class="code" href="ada-lang_8c.html#a2dc67804b48707c5176aac961d80e83f">ada_attribute_name</a> (op));
<a name="l10262"></a>10262         tem = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[*pos + 2].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l10263"></a>10263         *pos += 4;
<a name="l10264"></a>10264 
<a name="l10265"></a>10265         <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10266"></a>10266           <span class="keywordflow">goto</span> nosideret;
<a name="l10267"></a>10267 
<a name="l10268"></a>10268         <span class="keywordflow">if</span> (type_arg == NULL)
<a name="l10269"></a>10269           {
<a name="l10270"></a>10270             arg1 = ada_coerce_ref (arg1);
<a name="l10271"></a>10271 
<a name="l10272"></a>10272             <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1)))
<a name="l10273"></a>10273               arg1 = <a class="code" href="ada-lang_8c.html#a184966871049f553a895f96f7590884a">ada_coerce_to_simple_array</a> (arg1);
<a name="l10274"></a>10274 
<a name="l10275"></a>10275             type = ada_index_type (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1), tem,
<a name="l10276"></a>10276                                    <a class="code" href="ada-lang_8c.html#a2dc67804b48707c5176aac961d80e83f">ada_attribute_name</a> (op));
<a name="l10277"></a>10277             <span class="keywordflow">if</span> (type == NULL)
<a name="l10278"></a>10278               type = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>)-&gt;<a class="code" href="structbuiltin__type.html#ab12f96a04e89e8c951f0eacb379f7ffc">builtin_int</a>;
<a name="l10279"></a>10279 
<a name="l10280"></a>10280             <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10281"></a>10281               <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (type);
<a name="l10282"></a>10282 
<a name="l10283"></a>10283             <span class="keywordflow">switch</span> (op)
<a name="l10284"></a>10284               {
<a name="l10285"></a>10285               <span class="keywordflow">default</span>:          <span class="comment">/* Should never happen.  */</span>
<a name="l10286"></a>10286                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unexpected attribute encountered&quot;</span>));
<a name="l10287"></a>10287               <span class="keywordflow">case</span> OP_ATR_FIRST:
<a name="l10288"></a>10288                 <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a>
<a name="l10289"></a>10289                         (type, ada_array_bound (arg1, tem, 0));
<a name="l10290"></a>10290               <span class="keywordflow">case</span> OP_ATR_LAST:
<a name="l10291"></a>10291                 <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a>
<a name="l10292"></a>10292                         (type, ada_array_bound (arg1, tem, 1));
<a name="l10293"></a>10293               <span class="keywordflow">case</span> OP_ATR_LENGTH:
<a name="l10294"></a>10294                 <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a>
<a name="l10295"></a>10295                         (type, ada_array_length (arg1, tem));
<a name="l10296"></a>10296               }
<a name="l10297"></a>10297           }
<a name="l10298"></a>10298         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (discrete_type_p (type_arg))
<a name="l10299"></a>10299           {
<a name="l10300"></a>10300             <span class="keyword">struct </span>type *range_type;
<a name="l10301"></a>10301             <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type_arg);
<a name="l10302"></a>10302 
<a name="l10303"></a>10303             range_type = NULL;
<a name="l10304"></a>10304             <span class="keywordflow">if</span> (name != NULL &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type_arg) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>)
<a name="l10305"></a>10305               range_type = to_fixed_range_type (type_arg, NULL);
<a name="l10306"></a>10306             <span class="keywordflow">if</span> (range_type == NULL)
<a name="l10307"></a>10307               range_type = type_arg;
<a name="l10308"></a>10308             <span class="keywordflow">switch</span> (op)
<a name="l10309"></a>10309               {
<a name="l10310"></a>10310               <span class="keywordflow">default</span>:
<a name="l10311"></a>10311                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unexpected attribute encountered&quot;</span>));
<a name="l10312"></a>10312               <span class="keywordflow">case</span> OP_ATR_FIRST:
<a name="l10313"></a>10313                 <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> 
<a name="l10314"></a>10314                   (range_type, <a class="code" href="ada-lang_8c.html#ad4891bc1ffa6690999afab17e367bc57">ada_discrete_type_low_bound</a> (range_type));
<a name="l10315"></a>10315               <span class="keywordflow">case</span> OP_ATR_LAST:
<a name="l10316"></a>10316                 <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a>
<a name="l10317"></a>10317                   (range_type, <a class="code" href="ada-lang_8c.html#a9c9b5c63f7cb76eb9fdf216fa2721509">ada_discrete_type_high_bound</a> (range_type));
<a name="l10318"></a>10318               <span class="keywordflow">case</span> OP_ATR_LENGTH:
<a name="l10319"></a>10319                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;the &#39;length attribute applies only to array types&quot;</span>));
<a name="l10320"></a>10320               }
<a name="l10321"></a>10321           }
<a name="l10322"></a>10322         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type_arg) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>)
<a name="l10323"></a>10323           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unimplemented type attribute&quot;</span>));
<a name="l10324"></a>10324         <span class="keywordflow">else</span>
<a name="l10325"></a>10325           {
<a name="l10326"></a>10326             <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> low, high;
<a name="l10327"></a>10327 
<a name="l10328"></a>10328             <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#aa15cbb1ffc05648b3da71866bae9447f">ada_is_constrained_packed_array_type</a> (type_arg))
<a name="l10329"></a>10329               type_arg = decode_constrained_packed_array_type (type_arg);
<a name="l10330"></a>10330 
<a name="l10331"></a>10331             type = ada_index_type (type_arg, tem, <a class="code" href="ada-lang_8c.html#a2dc67804b48707c5176aac961d80e83f">ada_attribute_name</a> (op));
<a name="l10332"></a>10332             <span class="keywordflow">if</span> (type == NULL)
<a name="l10333"></a>10333               type = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>)-&gt;<a class="code" href="structbuiltin__type.html#ab12f96a04e89e8c951f0eacb379f7ffc">builtin_int</a>;
<a name="l10334"></a>10334 
<a name="l10335"></a>10335             <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10336"></a>10336               <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (type);
<a name="l10337"></a>10337 
<a name="l10338"></a>10338             <span class="keywordflow">switch</span> (op)
<a name="l10339"></a>10339               {
<a name="l10340"></a>10340               <span class="keywordflow">default</span>:
<a name="l10341"></a>10341                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unexpected attribute encountered&quot;</span>));
<a name="l10342"></a>10342               <span class="keywordflow">case</span> OP_ATR_FIRST:
<a name="l10343"></a>10343                 low = ada_array_bound_from_type (type_arg, tem, 0);
<a name="l10344"></a>10344                 <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, low);
<a name="l10345"></a>10345               <span class="keywordflow">case</span> OP_ATR_LAST:
<a name="l10346"></a>10346                 high = ada_array_bound_from_type (type_arg, tem, 1);
<a name="l10347"></a>10347                 <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, high);
<a name="l10348"></a>10348               <span class="keywordflow">case</span> OP_ATR_LENGTH:
<a name="l10349"></a>10349                 low = ada_array_bound_from_type (type_arg, tem, 0);
<a name="l10350"></a>10350                 high = ada_array_bound_from_type (type_arg, tem, 1);
<a name="l10351"></a>10351                 <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (type, high - low + 1);
<a name="l10352"></a>10352               }
<a name="l10353"></a>10353           }
<a name="l10354"></a>10354       }
<a name="l10355"></a>10355 
<a name="l10356"></a>10356     <span class="keywordflow">case</span> OP_ATR_TAG:
<a name="l10357"></a>10357       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10358"></a>10358       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10359"></a>10359         <span class="keywordflow">goto</span> nosideret;
<a name="l10360"></a>10360 
<a name="l10361"></a>10361       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10362"></a>10362         <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (<a class="code" href="ada-lang_8c.html#a69d9e6970a9bb88a6c44dc0e6edbe9b7">ada_tag_type</a> (arg1), <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l10363"></a>10363 
<a name="l10364"></a>10364       <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a13e4a462cc436fc761a68f1e378316db">ada_value_tag</a> (arg1);
<a name="l10365"></a>10365 
<a name="l10366"></a>10366     <span class="keywordflow">case</span> OP_ATR_MIN:
<a name="l10367"></a>10367     <span class="keywordflow">case</span> OP_ATR_MAX:
<a name="l10368"></a>10368       <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>);
<a name="l10369"></a>10369       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10370"></a>10370       arg2 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10371"></a>10371       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10372"></a>10372         <span class="keywordflow">goto</span> nosideret;
<a name="l10373"></a>10373       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10374"></a>10374         <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1), <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l10375"></a>10375       <span class="keywordflow">else</span>
<a name="l10376"></a>10376         {
<a name="l10377"></a>10377           <a class="code" href="eval_8c.html#a693b03e492de02e792891333afe603d3">binop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1, &amp;arg2);
<a name="l10378"></a>10378           <span class="keywordflow">return</span> <a class="code" href="valarith_8c.html#ae19c265649cb1b29f4fbda94d76ec495">value_binop</a> (arg1, arg2,
<a name="l10379"></a>10379                               op == OP_ATR_MIN ? BINOP_MIN : BINOP_MAX);
<a name="l10380"></a>10380         }
<a name="l10381"></a>10381 
<a name="l10382"></a>10382     <span class="keywordflow">case</span> OP_ATR_MODULUS:
<a name="l10383"></a>10383       {
<a name="l10384"></a>10384         <span class="keyword">struct </span>type *type_arg = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>);
<a name="l10385"></a>10385 
<a name="l10386"></a>10386         <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>);
<a name="l10387"></a>10387         <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10388"></a>10388           <span class="keywordflow">goto</span> nosideret;
<a name="l10389"></a>10389 
<a name="l10390"></a>10390         <span class="keywordflow">if</span> (!<a class="code" href="ada-lang_8c.html#a3f7ddcd366cd67c24fb3c7b2431abeb9">ada_is_modular_type</a> (type_arg))
<a name="l10391"></a>10391           <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;&#39;modulus must be applied to modular type&quot;</span>));
<a name="l10392"></a>10392 
<a name="l10393"></a>10393         <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type_arg),
<a name="l10394"></a>10394                                    <a class="code" href="ada-lang_8c.html#a357116c53325c29524dfd0ccff308754">ada_modulus</a> (type_arg));
<a name="l10395"></a>10395       }
<a name="l10396"></a>10396 
<a name="l10397"></a>10397 
<a name="l10398"></a>10398     <span class="keywordflow">case</span> OP_ATR_POS:
<a name="l10399"></a>10399       <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>);
<a name="l10400"></a>10400       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10401"></a>10401       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10402"></a>10402         <span class="keywordflow">goto</span> nosideret;
<a name="l10403"></a>10403       type = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>)-&gt;<a class="code" href="structbuiltin__type.html#ab12f96a04e89e8c951f0eacb379f7ffc">builtin_int</a>;
<a name="l10404"></a>10404       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10405"></a>10405         <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (type, <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l10406"></a>10406       <span class="keywordflow">else</span>
<a name="l10407"></a>10407         <span class="keywordflow">return</span> value_pos_atr (type, arg1);
<a name="l10408"></a>10408 
<a name="l10409"></a>10409     <span class="keywordflow">case</span> OP_ATR_SIZE:
<a name="l10410"></a>10410       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10411"></a>10411       type = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1);
<a name="l10412"></a>10412 
<a name="l10413"></a>10413       <span class="comment">/* If the argument is a reference, then dereference its type, since</span>
<a name="l10414"></a>10414 <span class="comment">         the user is really asking for the size of the actual object,</span>
<a name="l10415"></a>10415 <span class="comment">         not the size of the pointer.  */</span>
<a name="l10416"></a>10416       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>)
<a name="l10417"></a>10417         type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type);
<a name="l10418"></a>10418 
<a name="l10419"></a>10419       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10420"></a>10420         <span class="keywordflow">goto</span> nosideret;
<a name="l10421"></a>10421       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10422"></a>10422         <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (<a class="code" href="structbuiltin__type.html">builtin_type</a> (exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>)-&gt;<a class="code" href="structbuiltin__type.html#ab12f96a04e89e8c951f0eacb379f7ffc">builtin_int</a>, <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l10423"></a>10423       <span class="keywordflow">else</span>
<a name="l10424"></a>10424         <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (<a class="code" href="structbuiltin__type.html">builtin_type</a> (exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>)-&gt;<a class="code" href="structbuiltin__type.html#ab12f96a04e89e8c951f0eacb379f7ffc">builtin_int</a>,
<a name="l10425"></a>10425                                    TARGET_CHAR_BIT * <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type));
<a name="l10426"></a>10426 
<a name="l10427"></a>10427     <span class="keywordflow">case</span> OP_ATR_VAL:
<a name="l10428"></a>10428       <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>);
<a name="l10429"></a>10429       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10430"></a>10430       type = exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>;
<a name="l10431"></a>10431       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10432"></a>10432         <span class="keywordflow">goto</span> nosideret;
<a name="l10433"></a>10433       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10434"></a>10434         <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (type, <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l10435"></a>10435       <span class="keywordflow">else</span>
<a name="l10436"></a>10436         <span class="keywordflow">return</span> value_val_atr (type, arg1);
<a name="l10437"></a>10437 
<a name="l10438"></a>10438     <span class="keywordflow">case</span> BINOP_EXP:
<a name="l10439"></a>10439       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10440"></a>10440       arg2 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10441"></a>10441       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10442"></a>10442         <span class="keywordflow">goto</span> nosideret;
<a name="l10443"></a>10443       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10444"></a>10444         <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1), <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>);
<a name="l10445"></a>10445       <span class="keywordflow">else</span>
<a name="l10446"></a>10446         {
<a name="l10447"></a>10447           <span class="comment">/* For integer exponentiation operations,</span>
<a name="l10448"></a>10448 <span class="comment">             only promote the first argument.  */</span>
<a name="l10449"></a>10449           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8c.html#a292da1df1ddf044d92c8958d304aac2d">is_integral_type</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg2)))
<a name="l10450"></a>10450             <a class="code" href="eval_8c.html#aaf029974a20b0a9016fdcf41c7aeac3f">unop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1);
<a name="l10451"></a>10451           <span class="keywordflow">else</span>
<a name="l10452"></a>10452             <a class="code" href="eval_8c.html#a693b03e492de02e792891333afe603d3">binop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1, &amp;arg2);
<a name="l10453"></a>10453 
<a name="l10454"></a>10454           <span class="keywordflow">return</span> <a class="code" href="valarith_8c.html#ae19c265649cb1b29f4fbda94d76ec495">value_binop</a> (arg1, arg2, op);
<a name="l10455"></a>10455         }
<a name="l10456"></a>10456 
<a name="l10457"></a>10457     <span class="keywordflow">case</span> UNOP_PLUS:
<a name="l10458"></a>10458       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10459"></a>10459       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10460"></a>10460         <span class="keywordflow">goto</span> nosideret;
<a name="l10461"></a>10461       <span class="keywordflow">else</span>
<a name="l10462"></a>10462         <span class="keywordflow">return</span> arg1;
<a name="l10463"></a>10463 
<a name="l10464"></a>10464     <span class="keywordflow">case</span> UNOP_ABS:
<a name="l10465"></a>10465       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10466"></a>10466       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10467"></a>10467         <span class="keywordflow">goto</span> nosideret;
<a name="l10468"></a>10468       <a class="code" href="eval_8c.html#aaf029974a20b0a9016fdcf41c7aeac3f">unop_promote</a> (exp-&gt;<a class="code" href="structexpression.html#aef94e1723ab6463b705ff3e1fc36d8bf">language_defn</a>, exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>, &amp;arg1);
<a name="l10469"></a>10469       <span class="keywordflow">if</span> (<a class="code" href="valarith_8c.html#acac6d9bf0d453fda1832fdf0ff07b3ff">value_less</a> (arg1, <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1), <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba4c7a515c0bfd34444a3b1edfbd282619">not_lval</a>)))
<a name="l10470"></a>10470         <span class="keywordflow">return</span> <a class="code" href="valarith_8c.html#a648003ef947065a363712c65ea97c11c">value_neg</a> (arg1);
<a name="l10471"></a>10471       <span class="keywordflow">else</span>
<a name="l10472"></a>10472         <span class="keywordflow">return</span> arg1;
<a name="l10473"></a>10473 
<a name="l10474"></a>10474     <span class="keywordflow">case</span> UNOP_IND:
<a name="l10475"></a>10475       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10476"></a>10476       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10477"></a>10477         <span class="keywordflow">goto</span> nosideret;
<a name="l10478"></a>10478       type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1));
<a name="l10479"></a>10479       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10480"></a>10480         {
<a name="l10481"></a>10481           <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (type))
<a name="l10482"></a>10482             <span class="comment">/* GDB allows dereferencing GNAT array descriptors.  */</span>
<a name="l10483"></a>10483             {
<a name="l10484"></a>10484               <span class="keyword">struct </span>type *arrType = <a class="code" href="ada-lang_8c.html#a7a98282573c2d74e48913babce683aa0">ada_type_of_array</a> (arg1, 0);
<a name="l10485"></a>10485 
<a name="l10486"></a>10486               <span class="keywordflow">if</span> (arrType == NULL)
<a name="l10487"></a>10487                 <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attempt to dereference null array pointer.&quot;</span>));
<a name="l10488"></a>10488               <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (arrType, 0);
<a name="l10489"></a>10489             }
<a name="l10490"></a>10490           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1a639160f3e3a2f9f7ac55255942c581">TYPE_CODE_PTR</a>
<a name="l10491"></a>10491                    || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a476430709e5a251f7e0f8e3fb48a713f">TYPE_CODE_REF</a>
<a name="l10492"></a>10492                    <span class="comment">/* In C you can dereference an array to get the 1st elt.  */</span>
<a name="l10493"></a>10493                    || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l10494"></a>10494             {
<a name="l10495"></a>10495               type = to_static_fixed_type
<a name="l10496"></a>10496                 (<a class="code" href="ada-lang_8c.html#a67d9e8121909114afa44a208819f932f">ada_aligned_type</a>
<a name="l10497"></a>10497                  (<a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type))));
<a name="l10498"></a>10498               check_size (type);
<a name="l10499"></a>10499               <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (type, <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>);
<a name="l10500"></a>10500             }
<a name="l10501"></a>10501           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>)
<a name="l10502"></a>10502             {
<a name="l10503"></a>10503               <span class="comment">/* GDB allows dereferencing an int.  */</span>
<a name="l10504"></a>10504               <span class="keywordflow">if</span> (expect_type == NULL)
<a name="l10505"></a>10505                 <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (<a class="code" href="structbuiltin__type.html">builtin_type</a> (exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>)-&gt;<a class="code" href="structbuiltin__type.html#ab12f96a04e89e8c951f0eacb379f7ffc">builtin_int</a>,
<a name="l10506"></a>10506                                    <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>);
<a name="l10507"></a>10507               <span class="keywordflow">else</span>
<a name="l10508"></a>10508                 {
<a name="l10509"></a>10509                   expect_type = 
<a name="l10510"></a>10510                     to_static_fixed_type (<a class="code" href="ada-lang_8c.html#a67d9e8121909114afa44a208819f932f">ada_aligned_type</a> (expect_type));
<a name="l10511"></a>10511                   <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (expect_type, <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>);
<a name="l10512"></a>10512                 }
<a name="l10513"></a>10513             }
<a name="l10514"></a>10514           <span class="keywordflow">else</span>
<a name="l10515"></a>10515             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attempt to take contents of a non-pointer value.&quot;</span>));
<a name="l10516"></a>10516         }
<a name="l10517"></a>10517       arg1 = ada_coerce_ref (arg1);     <span class="comment">/* FIXME: What is this for??  */</span>
<a name="l10518"></a>10518       type = <a class="code" href="ada-lang_8c.html#a3509e46d3d2b17b00602a54a0434be3c">ada_check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1));
<a name="l10519"></a>10519 
<a name="l10520"></a>10520       <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>)
<a name="l10521"></a>10521           <span class="comment">/* GDB allows dereferencing an int.  If we were given</span>
<a name="l10522"></a>10522 <span class="comment">             the expect_type, then use that as the target type.</span>
<a name="l10523"></a>10523 <span class="comment">             Otherwise, assume that the target type is an int.  */</span>
<a name="l10524"></a>10524         {
<a name="l10525"></a>10525           <span class="keywordflow">if</span> (expect_type != NULL)
<a name="l10526"></a>10526             <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a917a1ba2a6b58d43803a1f999164295b">ada_value_ind</a> (<a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (<a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (expect_type),
<a name="l10527"></a>10527                                               arg1));
<a name="l10528"></a>10528           <span class="keywordflow">else</span>
<a name="l10529"></a>10529             <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#ae8cdb6f0257c5b86c719c90621e184d6">value_at_lazy</a> (<a class="code" href="structbuiltin__type.html">builtin_type</a> (exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>)-&gt;<a class="code" href="structbuiltin__type.html#ab12f96a04e89e8c951f0eacb379f7ffc">builtin_int</a>,
<a name="l10530"></a>10530                                   (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) <a class="code" href="value_8c.html#a2e64d8ca2ab5480e05097c6b2df1aa02">value_as_address</a> (arg1));
<a name="l10531"></a>10531         }
<a name="l10532"></a>10532 
<a name="l10533"></a>10533       <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#a7089d9f2c5f1ef0855301c3b4a0fdd91">ada_is_array_descriptor_type</a> (type))
<a name="l10534"></a>10534         <span class="comment">/* GDB allows dereferencing GNAT array descriptors.  */</span>
<a name="l10535"></a>10535         <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a184966871049f553a895f96f7590884a">ada_coerce_to_simple_array</a> (arg1);
<a name="l10536"></a>10536       <span class="keywordflow">else</span>
<a name="l10537"></a>10537         <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#a917a1ba2a6b58d43803a1f999164295b">ada_value_ind</a> (arg1);
<a name="l10538"></a>10538 
<a name="l10539"></a>10539     <span class="keywordflow">case</span> STRUCTOP_STRUCT:
<a name="l10540"></a>10540       tem = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l10541"></a>10541       (*pos) += 3 + <a class="code" href="expression_8h.html#a8a1be157bb41aa92434ac6ce0e0fcf78">BYTES_TO_EXP_ELEM</a> (tem + 1);
<a name="l10542"></a>10542       arg1 = <a class="code" href="eval_8c.html#a35831b259040b92681ffda421ae1ad4e">evaluate_subexp</a> (<a class="code" href="gdbtypes_8h.html#a27a1fcb44e6a426c50b3a854ba584b78">NULL_TYPE</a>, exp, pos, noside);
<a name="l10543"></a>10543       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10544"></a>10544         <span class="keywordflow">goto</span> nosideret;
<a name="l10545"></a>10545       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10546"></a>10546         {
<a name="l10547"></a>10547           <span class="keyword">struct </span>type *type1 = <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg1);
<a name="l10548"></a>10548 
<a name="l10549"></a>10549           <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#abbecc644387ffb0a43e57ed0462c2c8b">ada_is_tagged_type</a> (type1, 1))
<a name="l10550"></a>10550             {
<a name="l10551"></a>10551               type = ada_lookup_struct_elt_type (type1,
<a name="l10552"></a>10552                                                  &amp;exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#abeeb3252199a524869642283bccda167">string</a>,
<a name="l10553"></a>10553                                                  1, 1, NULL);
<a name="l10554"></a>10554               <span class="keywordflow">if</span> (type == NULL)
<a name="l10555"></a>10555                 <span class="comment">/* In this case, we assume that the field COULD exist</span>
<a name="l10556"></a>10556 <span class="comment">                   in some extension of the type.  Return an object of </span>
<a name="l10557"></a>10557 <span class="comment">                   &quot;type&quot; void, which will match any formal </span>
<a name="l10558"></a>10558 <span class="comment">                   (see ada_type_match).  */</span>
<a name="l10559"></a>10559                 <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (<a class="code" href="structbuiltin__type.html">builtin_type</a> (exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>)-&gt;<a class="code" href="structbuiltin__type.html#ae1b424251656c129a027977d3c0ea066">builtin_void</a>,
<a name="l10560"></a>10560                                    <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>);
<a name="l10561"></a>10561             }
<a name="l10562"></a>10562           <span class="keywordflow">else</span>
<a name="l10563"></a>10563             type =
<a name="l10564"></a>10564               ada_lookup_struct_elt_type (type1, &amp;exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#abeeb3252199a524869642283bccda167">string</a>, 1,
<a name="l10565"></a>10565                                           0, NULL);
<a name="l10566"></a>10566 
<a name="l10567"></a>10567           <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a97f02862d1fe8dc4cac71d0585f40870">value_zero</a> (<a class="code" href="ada-lang_8c.html#a67d9e8121909114afa44a208819f932f">ada_aligned_type</a> (type), <a class="code" href="defs_8h.html#aae40e9877f56980bf8fac75923a098aba04e4ffc3d93e9a0cdec974596a72c17e">lval_memory</a>);
<a name="l10568"></a>10568         }
<a name="l10569"></a>10569       <span class="keywordflow">else</span>
<a name="l10570"></a>10570         arg1 = <a class="code" href="ada-lang_8c.html#a9d3934026567a1840970ca108755b6e9">ada_value_struct_elt</a> (arg1, &amp;exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#abeeb3252199a524869642283bccda167">string</a>, 0);
<a name="l10571"></a>10571         arg1 = unwrap_value (arg1);
<a name="l10572"></a>10572         <span class="keywordflow">return</span> <a class="code" href="ada-lang_8c.html#aff7bccfb43d0188dfaf758dffe8b58ce">ada_to_fixed_value</a> (arg1);
<a name="l10573"></a>10573 
<a name="l10574"></a>10574     <span class="keywordflow">case</span> OP_TYPE:
<a name="l10575"></a>10575       <span class="comment">/* The value is not supposed to be used.  This is here to make it</span>
<a name="l10576"></a>10576 <span class="comment">         easier to accommodate expressions that contain types.  */</span>
<a name="l10577"></a>10577       (*pos) += 2;
<a name="l10578"></a>10578       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a0bbfefc5425711c0b2a379484b862d4a">EVAL_SKIP</a>)
<a name="l10579"></a>10579         <span class="keywordflow">goto</span> nosideret;
<a name="l10580"></a>10580       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a3bae8a63e83a3bfe2191bb663e722a34">EVAL_AVOID_SIDE_EFFECTS</a>)
<a name="l10581"></a>10581         <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a37cac41e59c768c42e801aeb969b566e">allocate_value</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>);
<a name="l10582"></a>10582       <span class="keywordflow">else</span>
<a name="l10583"></a>10583         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Attempt to use a type name as an expression&quot;</span>));
<a name="l10584"></a>10584 
<a name="l10585"></a>10585     <span class="keywordflow">case</span> OP_AGGREGATE:
<a name="l10586"></a>10586     <span class="keywordflow">case</span> OP_CHOICES:
<a name="l10587"></a>10587     <span class="keywordflow">case</span> OP_OTHERS:
<a name="l10588"></a>10588     <span class="keywordflow">case</span> OP_DISCRETE_RANGE:
<a name="l10589"></a>10589     <span class="keywordflow">case</span> OP_POSITIONAL:
<a name="l10590"></a>10590     <span class="keywordflow">case</span> OP_NAME:
<a name="l10591"></a>10591       <span class="keywordflow">if</span> (noside == <a class="code" href="expression_8h.html#ad11fe8a649f74f5cf6b6a8a317672c73a2e0f47a90a425663b11d68b22e45be95">EVAL_NORMAL</a>)
<a name="l10592"></a>10592         <span class="keywordflow">switch</span> (op) 
<a name="l10593"></a>10593           {
<a name="l10594"></a>10594           <span class="keywordflow">case</span> OP_NAME:
<a name="l10595"></a>10595             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Undefined name, ambiguous name, or renaming used in &quot;</span>
<a name="l10596"></a>10596                      <span class="stringliteral">&quot;component association: %s.&quot;</span>), &amp;exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc+2].<a class="code" href="unionexp__element.html#abeeb3252199a524869642283bccda167">string</a>);
<a name="l10597"></a>10597           <span class="keywordflow">case</span> OP_AGGREGATE:
<a name="l10598"></a>10598             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Aggregates only allowed on the right of an assignment&quot;</span>));
<a name="l10599"></a>10599           <span class="keywordflow">default</span>:
<a name="l10600"></a>10600             <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l10601"></a>10601                             <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;aggregate apparently mangled&quot;</span>));
<a name="l10602"></a>10602           }
<a name="l10603"></a>10603 
<a name="l10604"></a>10604       ada_forward_operator_length (exp, pc, &amp;oplen, &amp;nargs);
<a name="l10605"></a>10605       *pos += oplen - 1;
<a name="l10606"></a>10606       <span class="keywordflow">for</span> (tem = 0; tem &lt; nargs; tem += 1) 
<a name="l10607"></a>10607         ada_evaluate_subexp (NULL, exp, pos, noside);
<a name="l10608"></a>10608       <span class="keywordflow">goto</span> nosideret;
<a name="l10609"></a>10609     }
<a name="l10610"></a>10610 
<a name="l10611"></a>10611 nosideret:
<a name="l10612"></a>10612   <span class="keywordflow">return</span> <a class="code" href="value_8c.html#a194b41f9d10ade20e32daff64b4ae03c">value_from_longest</a> (<a class="code" href="structbuiltin__type.html">builtin_type</a> (exp-&gt;<a class="code" href="structexpression.html#ae549c2e4f2dd35e0c72338c37eee2961">gdbarch</a>)-&gt;<a class="code" href="structbuiltin__type.html#ab12f96a04e89e8c951f0eacb379f7ffc">builtin_int</a>, 1);
<a name="l10613"></a>10613 }
<a name="l10614"></a>10614 
<a name="l10615"></a>10615 
<a name="l10616"></a>10616                                 <span class="comment">/* Fixed point */</span>
<a name="l10617"></a>10617 
<a name="l10618"></a>10618 <span class="comment">/* If TYPE encodes an Ada fixed-point type, return the suffix of the</span>
<a name="l10619"></a>10619 <span class="comment">   type name that encodes the &#39;small and &#39;delta information.</span>
<a name="l10620"></a>10620 <span class="comment">   Otherwise, return NULL.  */</span>
<a name="l10621"></a>10621 
<a name="l10622"></a>10622 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l10623"></a>10623 fixed_type_info (<span class="keyword">struct</span> type *type)
<a name="l10624"></a>10624 {
<a name="l10625"></a>10625   <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code" href="ada-lang_8c.html#a50675eaca9783535883cedf2185b0a75">ada_type_name</a> (type);
<a name="l10626"></a>10626   <span class="keyword">enum</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462">type_code</a> code = (type == NULL) ? <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ac0ed09886a958d1a94646893440004a8">TYPE_CODE_UNDEF</a> : <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type);
<a name="l10627"></a>10627 
<a name="l10628"></a>10628   <span class="keywordflow">if</span> ((code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a> || code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>) &amp;&amp; name != NULL)
<a name="l10629"></a>10629     {
<a name="l10630"></a>10630       <span class="keyword">const</span> <span class="keywordtype">char</span> *tail = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (name, <span class="stringliteral">&quot;___XF_&quot;</span>);
<a name="l10631"></a>10631 
<a name="l10632"></a>10632       <span class="keywordflow">if</span> (tail == NULL)
<a name="l10633"></a>10633         <span class="keywordflow">return</span> NULL;
<a name="l10634"></a>10634       <span class="keywordflow">else</span>
<a name="l10635"></a>10635         <span class="keywordflow">return</span> tail + 5;
<a name="l10636"></a>10636     }
<a name="l10637"></a>10637   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a> &amp;&amp; <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type) != type)
<a name="l10638"></a>10638     <span class="keywordflow">return</span> fixed_type_info (<a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (type));
<a name="l10639"></a>10639   <span class="keywordflow">else</span>
<a name="l10640"></a>10640     <span class="keywordflow">return</span> NULL;
<a name="l10641"></a>10641 }
<a name="l10642"></a>10642 
<a name="l10643"></a>10643 <span class="comment">/* Returns non-zero iff TYPE represents an Ada fixed-point type.  */</span>
<a name="l10644"></a>10644 
<a name="l10645"></a>10645 <span class="keywordtype">int</span>
<a name="l10646"></a><a class="code" href="ada-lang_8h.html#afc8542a698615831ef9a744f95698003">10646</a> <a class="code" href="ada-lang_8c.html#afe50295540937b9ae0f68f2be4794f18">ada_is_fixed_point_type</a> (<span class="keyword">struct</span> type *type)
<a name="l10647"></a>10647 {
<a name="l10648"></a>10648   <span class="keywordflow">return</span> fixed_type_info (type) != NULL;
<a name="l10649"></a>10649 }
<a name="l10650"></a>10650 
<a name="l10651"></a>10651 <span class="comment">/* Return non-zero iff TYPE represents a System.Address type.  */</span>
<a name="l10652"></a>10652 
<a name="l10653"></a>10653 <span class="keywordtype">int</span>
<a name="l10654"></a><a class="code" href="ada-lang_8h.html#a66c7ce1bc858f63cf50251b28dbff775">10654</a> <a class="code" href="ada-lang_8c.html#a9add14a74258398d53afd8054606a13a">ada_is_system_address_type</a> (<span class="keyword">struct</span> type *type)
<a name="l10655"></a>10655 {
<a name="l10656"></a>10656   <span class="keywordflow">return</span> (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type)
<a name="l10657"></a>10657           &amp;&amp; strcmp (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type), <span class="stringliteral">&quot;system__address&quot;</span>) == 0);
<a name="l10658"></a>10658 }
<a name="l10659"></a>10659 
<a name="l10660"></a>10660 <span class="comment">/* Assuming that TYPE is the representation of an Ada fixed-point</span>
<a name="l10661"></a>10661 <span class="comment">   type, return its delta, or -1 if the type is malformed and the</span>
<a name="l10662"></a>10662 <span class="comment">   delta cannot be determined.  */</span>
<a name="l10663"></a>10663 
<a name="l10664"></a>10664 <a class="code" href="doublest_8h.html#ac1812677a2f11158956252854ec47a77">DOUBLEST</a>
<a name="l10665"></a><a class="code" href="ada-lang_8h.html#a2232d29a7e0c45762d3ee7d0f75a449e">10665</a> <a class="code" href="ada-lang_8c.html#a5360743acec0df22ec50e005f4c7be15">ada_delta</a> (<span class="keyword">struct</span> type *type)
<a name="l10666"></a>10666 {
<a name="l10667"></a>10667   <span class="keyword">const</span> <span class="keywordtype">char</span> *encoding = fixed_type_info (type);
<a name="l10668"></a>10668   <a class="code" href="doublest_8h.html#ac1812677a2f11158956252854ec47a77">DOUBLEST</a> num, den;
<a name="l10669"></a>10669 
<a name="l10670"></a>10670   <span class="comment">/* Strictly speaking, num and den are encoded as integer.  However,</span>
<a name="l10671"></a>10671 <span class="comment">     they may not fit into a long, and they will have to be converted</span>
<a name="l10672"></a>10672 <span class="comment">     to DOUBLEST anyway.  So scan them as DOUBLEST.  */</span>
<a name="l10673"></a>10673   <span class="keywordflow">if</span> (sscanf (encoding, <span class="stringliteral">&quot;_%&quot;</span> <a class="code" href="doublest_8h.html#aa951fcca1f031ca1e767af9358ad2634">DOUBLEST_SCAN_FORMAT</a> <span class="stringliteral">&quot;_%&quot;</span> <a class="code" href="doublest_8h.html#aa951fcca1f031ca1e767af9358ad2634">DOUBLEST_SCAN_FORMAT</a>,
<a name="l10674"></a>10674               &amp;num, &amp;den) &lt; 2)
<a name="l10675"></a>10675     <span class="keywordflow">return</span> -1.0;
<a name="l10676"></a>10676   <span class="keywordflow">else</span>
<a name="l10677"></a>10677     <span class="keywordflow">return</span> num / den;
<a name="l10678"></a>10678 }
<a name="l10679"></a>10679 
<a name="l10680"></a>10680 <span class="comment">/* Assuming that ada_is_fixed_point_type (TYPE), return the scaling</span>
<a name="l10681"></a>10681 <span class="comment">   factor (&#39;SMALL value) associated with the type.  */</span>
<a name="l10682"></a>10682 
<a name="l10683"></a>10683 <span class="keyword">static</span> <a class="code" href="doublest_8h.html#ac1812677a2f11158956252854ec47a77">DOUBLEST</a>
<a name="l10684"></a>10684 scaling_factor (<span class="keyword">struct</span> type *type)
<a name="l10685"></a>10685 {
<a name="l10686"></a>10686   <span class="keyword">const</span> <span class="keywordtype">char</span> *encoding = fixed_type_info (type);
<a name="l10687"></a>10687   <a class="code" href="doublest_8h.html#ac1812677a2f11158956252854ec47a77">DOUBLEST</a> num0, den0, num1, den1;
<a name="l10688"></a>10688   <span class="keywordtype">int</span> n;
<a name="l10689"></a>10689 
<a name="l10690"></a>10690   <span class="comment">/* Strictly speaking, num&#39;s and den&#39;s are encoded as integer.  However,</span>
<a name="l10691"></a>10691 <span class="comment">     they may not fit into a long, and they will have to be converted</span>
<a name="l10692"></a>10692 <span class="comment">     to DOUBLEST anyway.  So scan them as DOUBLEST.  */</span>
<a name="l10693"></a>10693   n = sscanf (encoding,
<a name="l10694"></a>10694               <span class="stringliteral">&quot;_%&quot;</span> <a class="code" href="doublest_8h.html#aa951fcca1f031ca1e767af9358ad2634">DOUBLEST_SCAN_FORMAT</a> <span class="stringliteral">&quot;_%&quot;</span> <a class="code" href="doublest_8h.html#aa951fcca1f031ca1e767af9358ad2634">DOUBLEST_SCAN_FORMAT</a>
<a name="l10695"></a>10695               <span class="stringliteral">&quot;_%&quot;</span> <a class="code" href="doublest_8h.html#aa951fcca1f031ca1e767af9358ad2634">DOUBLEST_SCAN_FORMAT</a> <span class="stringliteral">&quot;_%&quot;</span> <a class="code" href="doublest_8h.html#aa951fcca1f031ca1e767af9358ad2634">DOUBLEST_SCAN_FORMAT</a>,
<a name="l10696"></a>10696               &amp;num0, &amp;den0, &amp;num1, &amp;den1);
<a name="l10697"></a>10697 
<a name="l10698"></a>10698   <span class="keywordflow">if</span> (n &lt; 2)
<a name="l10699"></a>10699     <span class="keywordflow">return</span> 1.0;
<a name="l10700"></a>10700   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n == 4)
<a name="l10701"></a>10701     <span class="keywordflow">return</span> num1 / den1;
<a name="l10702"></a>10702   <span class="keywordflow">else</span>
<a name="l10703"></a>10703     <span class="keywordflow">return</span> num0 / den0;
<a name="l10704"></a>10704 }
<a name="l10705"></a>10705 
<a name="l10706"></a>10706 
<a name="l10707"></a>10707 <span class="comment">/* Assuming that X is the representation of a value of fixed-point</span>
<a name="l10708"></a>10708 <span class="comment">   type TYPE, return its floating-point equivalent.  */</span>
<a name="l10709"></a>10709 
<a name="l10710"></a>10710 <a class="code" href="doublest_8h.html#ac1812677a2f11158956252854ec47a77">DOUBLEST</a>
<a name="l10711"></a><a class="code" href="ada-lang_8h.html#a0e699931a4e43627c63d249cf79b9a61">10711</a> <a class="code" href="ada-lang_8c.html#a0a599a683dbfa3b513b0bd6e1072f422">ada_fixed_to_float</a> (<span class="keyword">struct</span> type *type, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> x)
<a name="l10712"></a>10712 {
<a name="l10713"></a>10713   <span class="keywordflow">return</span> (<a class="code" href="doublest_8h.html#ac1812677a2f11158956252854ec47a77">DOUBLEST</a>) x *scaling_factor (type);
<a name="l10714"></a>10714 }
<a name="l10715"></a>10715 
<a name="l10716"></a>10716 <span class="comment">/* The representation of a fixed-point value of type TYPE</span>
<a name="l10717"></a>10717 <span class="comment">   corresponding to the value X.  */</span>
<a name="l10718"></a>10718 
<a name="l10719"></a>10719 <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l10720"></a><a class="code" href="ada-lang_8h.html#a1c63a3fbb64da17223696e9b38dbcc0b">10720</a> <a class="code" href="ada-lang_8c.html#aad289c0819a5f43573ff9c638190d7a0">ada_float_to_fixed</a> (<span class="keyword">struct</span> type *type, <a class="code" href="doublest_8h.html#ac1812677a2f11158956252854ec47a77">DOUBLEST</a> x)
<a name="l10721"></a>10721 {
<a name="l10722"></a>10722   <span class="keywordflow">return</span> (<a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>) (x / scaling_factor (type) + 0.5);
<a name="l10723"></a>10723 }
<a name="l10724"></a>10724 
<a name="l10725"></a>10725 
<a name="l10726"></a>10726 
<a name="l10727"></a>10727                                 <span class="comment">/* Range types */</span>
<a name="l10728"></a>10728 
<a name="l10729"></a>10729 <span class="comment">/* Scan STR beginning at position K for a discriminant name, and</span>
<a name="l10730"></a>10730 <span class="comment">   return the value of that discriminant field of DVAL in *PX.  If</span>
<a name="l10731"></a>10731 <span class="comment">   PNEW_K is not null, put the position of the character beyond the</span>
<a name="l10732"></a>10732 <span class="comment">   name scanned in *PNEW_K.  Return 1 if successful; return 0 and do</span>
<a name="l10733"></a>10733 <span class="comment">   not alter *PX and *PNEW_K if unsuccessful.  */</span>
<a name="l10734"></a>10734 
<a name="l10735"></a>10735 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l10736"></a>10736 scan_discrim_bound (<span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> k, <span class="keyword">struct</span> value *dval, <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> * px,
<a name="l10737"></a>10737                     <span class="keywordtype">int</span> *pnew_k)
<a name="l10738"></a>10738 {
<a name="l10739"></a>10739   <span class="keyword">static</span> <span class="keywordtype">char</span> *bound_buffer = NULL;
<a name="l10740"></a>10740   <span class="keyword">static</span> <span class="keywordtype">size_t</span> bound_buffer_len = 0;
<a name="l10741"></a>10741   <span class="keywordtype">char</span> *bound;
<a name="l10742"></a>10742   <span class="keywordtype">char</span> *pend;
<a name="l10743"></a>10743   <span class="keyword">struct </span>value *bound_val;
<a name="l10744"></a>10744 
<a name="l10745"></a>10745   <span class="keywordflow">if</span> (dval == NULL || str == NULL || str[k] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l10746"></a>10746     <span class="keywordflow">return</span> 0;
<a name="l10747"></a>10747 
<a name="l10748"></a>10748   pend = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (str + k, <span class="stringliteral">&quot;__&quot;</span>);
<a name="l10749"></a>10749   <span class="keywordflow">if</span> (pend == NULL)
<a name="l10750"></a>10750     {
<a name="l10751"></a>10751       bound = str + k;
<a name="l10752"></a>10752       k += strlen (bound);
<a name="l10753"></a>10753     }
<a name="l10754"></a>10754   <span class="keywordflow">else</span>
<a name="l10755"></a>10755     {
<a name="l10756"></a>10756       <a class="code" href="ada-lang_8h.html#a48e9e90d45825a693f1690a4ebcb2a1e">GROW_VECT</a> (bound_buffer, bound_buffer_len, pend - (str + k) + 1);
<a name="l10757"></a>10757       bound = bound_buffer;
<a name="l10758"></a>10758       strncpy (bound_buffer, str + k, pend - (str + k));
<a name="l10759"></a>10759       bound[pend - (str + k)] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l10760"></a>10760       k = pend - str;
<a name="l10761"></a>10761     }
<a name="l10762"></a>10762 
<a name="l10763"></a>10763   bound_val = ada_search_struct_field (bound, dval, 0, <a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (dval));
<a name="l10764"></a>10764   <span class="keywordflow">if</span> (bound_val == NULL)
<a name="l10765"></a>10765     <span class="keywordflow">return</span> 0;
<a name="l10766"></a>10766 
<a name="l10767"></a>10767   *px = <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (bound_val);
<a name="l10768"></a>10768   <span class="keywordflow">if</span> (pnew_k != NULL)
<a name="l10769"></a>10769     *pnew_k = k;
<a name="l10770"></a>10770   <span class="keywordflow">return</span> 1;
<a name="l10771"></a>10771 }
<a name="l10772"></a>10772 
<a name="l10773"></a>10773 <span class="comment">/* Value of variable named NAME in the current environment.  If</span>
<a name="l10774"></a>10774 <span class="comment">   no such variable found, then if ERR_MSG is null, returns 0, and</span>
<a name="l10775"></a>10775 <span class="comment">   otherwise causes an error with message ERR_MSG.  */</span>
<a name="l10776"></a>10776 
<a name="l10777"></a>10777 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l10778"></a>10778 get_var_value (<span class="keywordtype">char</span> *name, <span class="keywordtype">char</span> *err_msg)
<a name="l10779"></a>10779 {
<a name="l10780"></a>10780   <span class="keyword">struct </span><a class="code" href="structada__symbol__info.html">ada_symbol_info</a> *syms;
<a name="l10781"></a>10781   <span class="keywordtype">int</span> nsyms;
<a name="l10782"></a>10782 
<a name="l10783"></a>10783   nsyms = <a class="code" href="ada-lang_8c.html#aa04634fbe1ee55e7efef10df7f0bc55b">ada_lookup_symbol_list</a> (name, <a class="code" href="frame_8h.html#a91efbdcf182d840c28d378def97cfc23">get_selected_block</a> (0), <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>,
<a name="l10784"></a>10784                                   &amp;syms);
<a name="l10785"></a>10785 
<a name="l10786"></a>10786   <span class="keywordflow">if</span> (nsyms != 1)
<a name="l10787"></a>10787     {
<a name="l10788"></a>10788       <span class="keywordflow">if</span> (err_msg == NULL)
<a name="l10789"></a>10789         <span class="keywordflow">return</span> 0;
<a name="l10790"></a>10790       <span class="keywordflow">else</span>
<a name="l10791"></a>10791         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> ((<span class="stringliteral">&quot;%s&quot;</span>), err_msg);
<a name="l10792"></a>10792     }
<a name="l10793"></a>10793 
<a name="l10794"></a>10794   <span class="keywordflow">return</span> <a class="code" href="valops_8c.html#a353e75e3afb5f274e886d08360d045b8">value_of_variable</a> (syms[0].sym, syms[0].block);
<a name="l10795"></a>10795 }
<a name="l10796"></a>10796 
<a name="l10797"></a>10797 <span class="comment">/* Value of integer variable named NAME in the current environment.  If</span>
<a name="l10798"></a>10798 <span class="comment">   no such variable found, returns 0, and sets *FLAG to 0.  If</span>
<a name="l10799"></a>10799 <span class="comment">   successful, sets *FLAG to 1.  */</span>
<a name="l10800"></a>10800 
<a name="l10801"></a>10801 <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a>
<a name="l10802"></a><a class="code" href="ada-lang_8h.html#a5b5cbedbdfe41f519d40bc44bbea63c1">10802</a> <a class="code" href="ada-lang_8c.html#a484727f9e5debb643d5912928f277dee">get_int_var_value</a> (<span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> *flag)
<a name="l10803"></a>10803 {
<a name="l10804"></a>10804   <span class="keyword">struct </span>value *var_val = get_var_value (name, 0);
<a name="l10805"></a>10805 
<a name="l10806"></a>10806   <span class="keywordflow">if</span> (var_val == 0)
<a name="l10807"></a>10807     {
<a name="l10808"></a>10808       <span class="keywordflow">if</span> (flag != NULL)
<a name="l10809"></a>10809         *flag = 0;
<a name="l10810"></a>10810       <span class="keywordflow">return</span> 0;
<a name="l10811"></a>10811     }
<a name="l10812"></a>10812   <span class="keywordflow">else</span>
<a name="l10813"></a>10813     {
<a name="l10814"></a>10814       <span class="keywordflow">if</span> (flag != NULL)
<a name="l10815"></a>10815         *flag = 1;
<a name="l10816"></a>10816       <span class="keywordflow">return</span> <a class="code" href="value_8c.html#aa95e2692a6e5338edb5db75909064bc1">value_as_long</a> (var_val);
<a name="l10817"></a>10817     }
<a name="l10818"></a>10818 }
<a name="l10819"></a>10819 
<a name="l10820"></a>10820 
<a name="l10821"></a>10821 <span class="comment">/* Return a range type whose base type is that of the range type named</span>
<a name="l10822"></a>10822 <span class="comment">   NAME in the current environment, and whose bounds are calculated</span>
<a name="l10823"></a>10823 <span class="comment">   from NAME according to the GNAT range encoding conventions.</span>
<a name="l10824"></a>10824 <span class="comment">   Extract discriminant values, if needed, from DVAL.  ORIG_TYPE is the</span>
<a name="l10825"></a>10825 <span class="comment">   corresponding range type from debug information; fall back to using it</span>
<a name="l10826"></a>10826 <span class="comment">   if symbol lookup fails.  If a new type must be created, allocate it</span>
<a name="l10827"></a>10827 <span class="comment">   like ORIG_TYPE was.  The bounds information, in general, is encoded</span>
<a name="l10828"></a>10828 <span class="comment">   in NAME, the base type given in the named range type.  */</span>
<a name="l10829"></a>10829 
<a name="l10830"></a>10830 <span class="keyword">static</span> <span class="keyword">struct </span>type *
<a name="l10831"></a>10831 to_fixed_range_type (<span class="keyword">struct</span> type *raw_type, <span class="keyword">struct</span> value *dval)
<a name="l10832"></a>10832 {
<a name="l10833"></a>10833   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l10834"></a>10834   <span class="keyword">struct </span>type *base_type;
<a name="l10835"></a>10835   <span class="keywordtype">char</span> *subtype_info;
<a name="l10836"></a>10836 
<a name="l10837"></a>10837   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (raw_type != NULL);
<a name="l10838"></a>10838   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (raw_type) != NULL);
<a name="l10839"></a>10839 
<a name="l10840"></a>10840   <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (raw_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>)
<a name="l10841"></a>10841     base_type = <a class="code" href="gdbtypes_8h.html#a87a33d723acd28a033e63c4297c6c916">TYPE_TARGET_TYPE</a> (raw_type);
<a name="l10842"></a>10842   <span class="keywordflow">else</span>
<a name="l10843"></a>10843     base_type = raw_type;
<a name="l10844"></a>10844 
<a name="l10845"></a>10845   name = <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (raw_type);
<a name="l10846"></a>10846   subtype_info = <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (name, <span class="stringliteral">&quot;___XD&quot;</span>);
<a name="l10847"></a>10847   <span class="keywordflow">if</span> (subtype_info == NULL)
<a name="l10848"></a>10848     {
<a name="l10849"></a>10849       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="ia64-tdep_8c.html#aa7fb549cf7936f8264053676ad5a5115aef31cc6fe9479955961311ee18ac205f">L</a> = <a class="code" href="ada-lang_8c.html#ad4891bc1ffa6690999afab17e367bc57">ada_discrete_type_low_bound</a> (raw_type);
<a name="l10850"></a>10850       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> U = <a class="code" href="ada-lang_8c.html#a9c9b5c63f7cb76eb9fdf216fa2721509">ada_discrete_type_high_bound</a> (raw_type);
<a name="l10851"></a>10851 
<a name="l10852"></a>10852       <span class="keywordflow">if</span> (L &lt; INT_MIN || U &gt; INT_MAX)
<a name="l10853"></a>10853         <span class="keywordflow">return</span> raw_type;
<a name="l10854"></a>10854       <span class="keywordflow">else</span>
<a name="l10855"></a>10855         <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#ab0885fdae181c47ff3f958bcba70b82d">create_range_type</a> (<a class="code" href="gdbtypes_8c.html#a2e8f72ee412f83ecd89f47068fda9634">alloc_type_copy</a> (raw_type), raw_type,
<a name="l10856"></a>10856                                   <a class="code" href="ada-lang_8c.html#ad4891bc1ffa6690999afab17e367bc57">ada_discrete_type_low_bound</a> (raw_type),
<a name="l10857"></a>10857                                   <a class="code" href="ada-lang_8c.html#a9c9b5c63f7cb76eb9fdf216fa2721509">ada_discrete_type_high_bound</a> (raw_type));
<a name="l10858"></a>10858     }
<a name="l10859"></a>10859   <span class="keywordflow">else</span>
<a name="l10860"></a>10860     {
<a name="l10861"></a>10861       <span class="keyword">static</span> <span class="keywordtype">char</span> *name_buf = NULL;
<a name="l10862"></a>10862       <span class="keyword">static</span> <span class="keywordtype">size_t</span> name_len = 0;
<a name="l10863"></a>10863       <span class="keywordtype">int</span> prefix_len = subtype_info - <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l10864"></a>10864       <a class="code" href="defs_8h.html#ac7647a3f71533007c9e128f3ddda1987">LONGEST</a> <a class="code" href="ia64-tdep_8c.html#aa7fb549cf7936f8264053676ad5a5115aef31cc6fe9479955961311ee18ac205f">L</a>, U;
<a name="l10865"></a>10865       <span class="keyword">struct </span>type *type;
<a name="l10866"></a>10866       <span class="keywordtype">char</span> *bounds_str;
<a name="l10867"></a>10867       <span class="keywordtype">int</span> n;
<a name="l10868"></a>10868 
<a name="l10869"></a>10869       <a class="code" href="ada-lang_8h.html#a48e9e90d45825a693f1690a4ebcb2a1e">GROW_VECT</a> (name_buf, name_len, prefix_len + 5);
<a name="l10870"></a>10870       strncpy (name_buf, name, prefix_len);
<a name="l10871"></a>10871       name_buf[prefix_len] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l10872"></a>10872 
<a name="l10873"></a>10873       subtype_info += 5;
<a name="l10874"></a>10874       bounds_str = <a class="code" href="gdb__string_8h.html#adf46aa8f2e08cfb505868bbfc88b5fd4">strchr</a> (subtype_info, <span class="charliteral">&#39;_&#39;</span>);
<a name="l10875"></a>10875       n = 1;
<a name="l10876"></a>10876 
<a name="l10877"></a>10877       <span class="keywordflow">if</span> (*subtype_info == <span class="charliteral">&#39;L&#39;</span>)
<a name="l10878"></a>10878         {
<a name="l10879"></a>10879           <span class="keywordflow">if</span> (!<a class="code" href="ada-lang_8c.html#ace9b2035b5472767719b10e8d2691e11">ada_scan_number</a> (bounds_str, n, &amp;L, &amp;n)
<a name="l10880"></a>10880               &amp;&amp; !scan_discrim_bound (bounds_str, n, dval, &amp;L, &amp;n))
<a name="l10881"></a>10881             <span class="keywordflow">return</span> raw_type;
<a name="l10882"></a>10882           <span class="keywordflow">if</span> (bounds_str[n] == <span class="charliteral">&#39;_&#39;</span>)
<a name="l10883"></a>10883             n += 2;
<a name="l10884"></a>10884           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bounds_str[n] == <span class="charliteral">&#39;.&#39;</span>)     <span class="comment">/* FIXME? SGI Workshop kludge.  */</span>
<a name="l10885"></a>10885             n += 1;
<a name="l10886"></a>10886           subtype_info += 1;
<a name="l10887"></a>10887         }
<a name="l10888"></a>10888       <span class="keywordflow">else</span>
<a name="l10889"></a>10889         {
<a name="l10890"></a>10890           <span class="keywordtype">int</span> ok;
<a name="l10891"></a>10891 
<a name="l10892"></a>10892           strcpy (name_buf + prefix_len, <span class="stringliteral">&quot;___L&quot;</span>);
<a name="l10893"></a>10893           L = <a class="code" href="ada-lang_8c.html#a484727f9e5debb643d5912928f277dee">get_int_var_value</a> (name_buf, &amp;ok);
<a name="l10894"></a>10894           <span class="keywordflow">if</span> (!ok)
<a name="l10895"></a>10895             {
<a name="l10896"></a>10896               lim_warning (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unknown lower bound, using 1.&quot;</span>));
<a name="l10897"></a>10897               L = 1;
<a name="l10898"></a>10898             }
<a name="l10899"></a>10899         }
<a name="l10900"></a>10900 
<a name="l10901"></a>10901       <span class="keywordflow">if</span> (*subtype_info == <span class="charliteral">&#39;U&#39;</span>)
<a name="l10902"></a>10902         {
<a name="l10903"></a>10903           <span class="keywordflow">if</span> (!<a class="code" href="ada-lang_8c.html#ace9b2035b5472767719b10e8d2691e11">ada_scan_number</a> (bounds_str, n, &amp;U, &amp;n)
<a name="l10904"></a>10904               &amp;&amp; !scan_discrim_bound (bounds_str, n, dval, &amp;U, &amp;n))
<a name="l10905"></a>10905             <span class="keywordflow">return</span> raw_type;
<a name="l10906"></a>10906         }
<a name="l10907"></a>10907       <span class="keywordflow">else</span>
<a name="l10908"></a>10908         {
<a name="l10909"></a>10909           <span class="keywordtype">int</span> ok;
<a name="l10910"></a>10910 
<a name="l10911"></a>10911           strcpy (name_buf + prefix_len, <span class="stringliteral">&quot;___U&quot;</span>);
<a name="l10912"></a>10912           U = <a class="code" href="ada-lang_8c.html#a484727f9e5debb643d5912928f277dee">get_int_var_value</a> (name_buf, &amp;ok);
<a name="l10913"></a>10913           <span class="keywordflow">if</span> (!ok)
<a name="l10914"></a>10914             {
<a name="l10915"></a>10915               lim_warning (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unknown upper bound, using %ld.&quot;</span>), (<span class="keywordtype">long</span>) L);
<a name="l10916"></a>10916               U = <a class="code" href="ia64-tdep_8c.html#aa7fb549cf7936f8264053676ad5a5115aef31cc6fe9479955961311ee18ac205f">L</a>;
<a name="l10917"></a>10917             }
<a name="l10918"></a>10918         }
<a name="l10919"></a>10919 
<a name="l10920"></a>10920       type = <a class="code" href="gdbtypes_8c.html#ab0885fdae181c47ff3f958bcba70b82d">create_range_type</a> (<a class="code" href="gdbtypes_8c.html#a2e8f72ee412f83ecd89f47068fda9634">alloc_type_copy</a> (raw_type), base_type, L, U);
<a name="l10921"></a>10921       <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (type) = <a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l10922"></a>10922       <span class="keywordflow">return</span> type;
<a name="l10923"></a>10923     }
<a name="l10924"></a>10924 }
<a name="l10925"></a>10925 
<a name="l10926"></a>10926 <span class="comment">/* True iff NAME is the name of a range type.  */</span>
<a name="l10927"></a>10927 
<a name="l10928"></a>10928 <span class="keywordtype">int</span>
<a name="l10929"></a><a class="code" href="ada-lang_8h.html#a1b2bb981e11c63b14a48ec4db75d87be">10929</a> <a class="code" href="ada-lang_8c.html#ab593cab72d4a5a415694dbccdc0365fc">ada_is_range_type_name</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l10930"></a>10930 {
<a name="l10931"></a>10931   <span class="keywordflow">return</span> (name != NULL &amp;&amp; <a class="code" href="gdb__string_8h.html#a55c8e1e0e5f3578988a2feb0d417ad1c">strstr</a> (name, <span class="stringliteral">&quot;___XD&quot;</span>));
<a name="l10932"></a>10932 }
<a name="l10933"></a>10933 
<a name="l10934"></a>10934 
<a name="l10935"></a>10935                                 <span class="comment">/* Modular types */</span>
<a name="l10936"></a>10936 
<a name="l10937"></a>10937 <span class="comment">/* True iff TYPE is an Ada modular type.  */</span>
<a name="l10938"></a>10938 
<a name="l10939"></a>10939 <span class="keywordtype">int</span>
<a name="l10940"></a><a class="code" href="ada-lang_8h.html#ae0c1d1d00f9cdb35c509e264f787e605">10940</a> <a class="code" href="ada-lang_8c.html#a3f7ddcd366cd67c24fb3c7b2431abeb9">ada_is_modular_type</a> (<span class="keyword">struct</span> type *type)
<a name="l10941"></a>10941 {
<a name="l10942"></a>10942   <span class="keyword">struct </span>type *subranged_type = get_base_type (type);
<a name="l10943"></a>10943 
<a name="l10944"></a>10944   <span class="keywordflow">return</span> (subranged_type != NULL &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>
<a name="l10945"></a>10945           &amp;&amp; <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (subranged_type) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>
<a name="l10946"></a>10946           &amp;&amp; <a class="code" href="gdbtypes_8h.html#a124c6ba3c6519f8a6ea57495d2f5f7f7">TYPE_UNSIGNED</a> (subranged_type));
<a name="l10947"></a>10947 }
<a name="l10948"></a>10948 
<a name="l10949"></a>10949 <span class="comment">/* Assuming ada_is_modular_type (TYPE), the modulus of TYPE.  */</span>
<a name="l10950"></a>10950 
<a name="l10951"></a>10951 <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a>
<a name="l10952"></a><a class="code" href="ada-lang_8h.html#acfaca6a549b2e7dda77b795cdbf919f4">10952</a> <a class="code" href="ada-lang_8c.html#a357116c53325c29524dfd0ccff308754">ada_modulus</a> (<span class="keyword">struct</span> type *type)
<a name="l10953"></a>10953 {
<a name="l10954"></a>10954   <span class="keywordflow">return</span> (<a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a>) <a class="code" href="gdbtypes_8h.html#a77cdc334123abc6858b3ea8b3361cd5d">TYPE_HIGH_BOUND</a> (type) + 1;
<a name="l10955"></a>10955 }
<a name="l10956"></a>10956 
<a name="l10957"></a>10957 
<a name="l10958"></a>10958 <span class="comment">/* Ada exception catchpoint support:</span>
<a name="l10959"></a>10959 <span class="comment">   ---------------------------------</span>
<a name="l10960"></a>10960 <span class="comment"></span>
<a name="l10961"></a>10961 <span class="comment">   We support 3 kinds of exception catchpoints:</span>
<a name="l10962"></a>10962 <span class="comment">     . catchpoints on Ada exceptions</span>
<a name="l10963"></a>10963 <span class="comment">     . catchpoints on unhandled Ada exceptions</span>
<a name="l10964"></a>10964 <span class="comment">     . catchpoints on failed assertions</span>
<a name="l10965"></a>10965 <span class="comment"></span>
<a name="l10966"></a>10966 <span class="comment">   Exceptions raised during failed assertions, or unhandled exceptions</span>
<a name="l10967"></a>10967 <span class="comment">   could perfectly be caught with the general catchpoint on Ada exceptions.</span>
<a name="l10968"></a>10968 <span class="comment">   However, we can easily differentiate these two special cases, and having</span>
<a name="l10969"></a>10969 <span class="comment">   the option to distinguish these two cases from the rest can be useful</span>
<a name="l10970"></a>10970 <span class="comment">   to zero-in on certain situations.</span>
<a name="l10971"></a>10971 <span class="comment"></span>
<a name="l10972"></a>10972 <span class="comment">   Exception catchpoints are a specialized form of breakpoint,</span>
<a name="l10973"></a>10973 <span class="comment">   since they rely on inserting breakpoints inside known routines</span>
<a name="l10974"></a>10974 <span class="comment">   of the GNAT runtime.  The implementation therefore uses a standard</span>
<a name="l10975"></a>10975 <span class="comment">   breakpoint structure of the BP_BREAKPOINT type, but with its own set</span>
<a name="l10976"></a>10976 <span class="comment">   of breakpoint_ops.</span>
<a name="l10977"></a>10977 <span class="comment"></span>
<a name="l10978"></a>10978 <span class="comment">   Support in the runtime for exception catchpoints have been changed</span>
<a name="l10979"></a>10979 <span class="comment">   a few times already, and these changes affect the implementation</span>
<a name="l10980"></a>10980 <span class="comment">   of these catchpoints.  In order to be able to support several</span>
<a name="l10981"></a>10981 <span class="comment">   variants of the runtime, we use a sniffer that will determine</span>
<a name="l10982"></a>10982 <span class="comment">   the runtime variant used by the program being debugged.  */</span>
<a name="l10983"></a>10983 
<a name="l10984"></a>10984 <span class="comment">/* Ada&#39;s standard exceptions.  */</span>
<a name="l10985"></a>10985 
<a name="l10986"></a>10986 <span class="keyword">static</span> <span class="keywordtype">char</span> *standard_exc[] = {
<a name="l10987"></a>10987   <span class="stringliteral">&quot;constraint_error&quot;</span>,
<a name="l10988"></a>10988   <span class="stringliteral">&quot;program_error&quot;</span>,
<a name="l10989"></a>10989   <span class="stringliteral">&quot;storage_error&quot;</span>,
<a name="l10990"></a>10990   <span class="stringliteral">&quot;tasking_error&quot;</span>
<a name="l10991"></a>10991 };
<a name="l10992"></a>10992 
<a name="l10993"></a><a class="code" href="ada-lang_8c.html#a31684710a0e9e56d33ba531c2fb7b987">10993</a> <span class="keyword">typedef</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> (<a class="code" href="ada-lang_8c.html#a31684710a0e9e56d33ba531c2fb7b987">ada_unhandled_exception_name_addr_ftype</a>) (void);
<a name="l10994"></a>10994 
<a name="l10995"></a>10995 <span class="comment">/* A structure that describes how to support exception catchpoints</span>
<a name="l10996"></a>10996 <span class="comment">   for a given executable.  */</span>
<a name="l10997"></a>10997 
<a name="l10998"></a>10998 <span class="keyword">struct </span>exception_support_info
<a name="l10999"></a>10999 {
<a name="l11000"></a>11000    <span class="comment">/* The name of the symbol to break on in order to insert</span>
<a name="l11001"></a>11001 <span class="comment">      a catchpoint on exceptions.  */</span>
<a name="l11002"></a>11002    <span class="keyword">const</span> <span class="keywordtype">char</span> *catch_exception_sym;
<a name="l11003"></a>11003 
<a name="l11004"></a>11004    <span class="comment">/* The name of the symbol to break on in order to insert</span>
<a name="l11005"></a>11005 <span class="comment">      a catchpoint on unhandled exceptions.  */</span>
<a name="l11006"></a>11006    <span class="keyword">const</span> <span class="keywordtype">char</span> *catch_exception_unhandled_sym;
<a name="l11007"></a>11007 
<a name="l11008"></a>11008    <span class="comment">/* The name of the symbol to break on in order to insert</span>
<a name="l11009"></a>11009 <span class="comment">      a catchpoint on failed assertions.  */</span>
<a name="l11010"></a>11010    <span class="keyword">const</span> <span class="keywordtype">char</span> *catch_assert_sym;
<a name="l11011"></a>11011 
<a name="l11012"></a>11012    <span class="comment">/* Assuming that the inferior just triggered an unhandled exception</span>
<a name="l11013"></a>11013 <span class="comment">      catchpoint, this function is responsible for returning the address</span>
<a name="l11014"></a>11014 <span class="comment">      in inferior memory where the name of that exception is stored.</span>
<a name="l11015"></a>11015 <span class="comment">      Return zero if the address could not be computed.  */</span>
<a name="l11016"></a>11016    <a class="code" href="ada-lang_8c.html#a31684710a0e9e56d33ba531c2fb7b987">ada_unhandled_exception_name_addr_ftype</a> *unhandled_exception_name_addr;
<a name="l11017"></a>11017 };
<a name="l11018"></a>11018 
<a name="l11019"></a>11019 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ada_unhandled_exception_name_addr (<span class="keywordtype">void</span>);
<a name="l11020"></a>11020 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ada_unhandled_exception_name_addr_from_raise (<span class="keywordtype">void</span>);
<a name="l11021"></a>11021 
<a name="l11022"></a>11022 <span class="comment">/* The following exception support info structure describes how to</span>
<a name="l11023"></a>11023 <span class="comment">   implement exception catchpoints with the latest version of the</span>
<a name="l11024"></a>11024 <span class="comment">   Ada runtime (as of 2007-03-06).  */</span>
<a name="l11025"></a>11025 
<a name="l11026"></a>11026 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>exception_support_info default_exception_support_info =
<a name="l11027"></a>11027 {
<a name="l11028"></a>11028   <span class="stringliteral">&quot;__gnat_debug_raise_exception&quot;</span>, <span class="comment">/* catch_exception_sym */</span>
<a name="l11029"></a>11029   <span class="stringliteral">&quot;__gnat_unhandled_exception&quot;</span>, <span class="comment">/* catch_exception_unhandled_sym */</span>
<a name="l11030"></a>11030   <span class="stringliteral">&quot;__gnat_debug_raise_assert_failure&quot;</span>, <span class="comment">/* catch_assert_sym */</span>
<a name="l11031"></a>11031   ada_unhandled_exception_name_addr
<a name="l11032"></a>11032 };
<a name="l11033"></a>11033 
<a name="l11034"></a>11034 <span class="comment">/* The following exception support info structure describes how to</span>
<a name="l11035"></a>11035 <span class="comment">   implement exception catchpoints with a slightly older version</span>
<a name="l11036"></a>11036 <span class="comment">   of the Ada runtime.  */</span>
<a name="l11037"></a>11037 
<a name="l11038"></a>11038 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>exception_support_info exception_support_info_fallback =
<a name="l11039"></a>11039 {
<a name="l11040"></a>11040   <span class="stringliteral">&quot;__gnat_raise_nodefer_with_msg&quot;</span>, <span class="comment">/* catch_exception_sym */</span>
<a name="l11041"></a>11041   <span class="stringliteral">&quot;__gnat_unhandled_exception&quot;</span>, <span class="comment">/* catch_exception_unhandled_sym */</span>
<a name="l11042"></a>11042   <span class="stringliteral">&quot;system__assertions__raise_assert_failure&quot;</span>,  <span class="comment">/* catch_assert_sym */</span>
<a name="l11043"></a>11043   ada_unhandled_exception_name_addr_from_raise
<a name="l11044"></a>11044 };
<a name="l11045"></a>11045 
<a name="l11046"></a>11046 <span class="comment">/* Return nonzero if we can detect the exception support routines</span>
<a name="l11047"></a>11047 <span class="comment">   described in EINFO.</span>
<a name="l11048"></a>11048 <span class="comment"></span>
<a name="l11049"></a>11049 <span class="comment">   This function errors out if an abnormal situation is detected</span>
<a name="l11050"></a>11050 <span class="comment">   (for instance, if we find the exception support routines, but</span>
<a name="l11051"></a>11051 <span class="comment">   that support is found to be incomplete).  */</span>
<a name="l11052"></a>11052 
<a name="l11053"></a>11053 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l11054"></a>11054 ada_has_this_exception_support (<span class="keyword">const</span> <span class="keyword">struct</span> exception_support_info *einfo)
<a name="l11055"></a>11055 {
<a name="l11056"></a>11056   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l11057"></a>11057 
<a name="l11058"></a>11058   <span class="comment">/* The symbol we&#39;re looking up is provided by a unit in the GNAT runtime</span>
<a name="l11059"></a>11059 <span class="comment">     that should be compiled with debugging information.  As a result, we</span>
<a name="l11060"></a>11060 <span class="comment">     expect to find that symbol in the symtabs.  */</span>
<a name="l11061"></a>11061 
<a name="l11062"></a>11062   sym = standard_lookup (einfo-&gt;catch_exception_sym, NULL, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>);
<a name="l11063"></a>11063   <span class="keywordflow">if</span> (sym == NULL)
<a name="l11064"></a>11064     {
<a name="l11065"></a>11065       <span class="comment">/* Perhaps we did not find our symbol because the Ada runtime was</span>
<a name="l11066"></a>11066 <span class="comment">         compiled without debugging info, or simply stripped of it.</span>
<a name="l11067"></a>11067 <span class="comment">         It happens on some GNU/Linux distributions for instance, where</span>
<a name="l11068"></a>11068 <span class="comment">         users have to install a separate debug package in order to get</span>
<a name="l11069"></a>11069 <span class="comment">         the runtime&#39;s debugging info.  In that situation, let the user</span>
<a name="l11070"></a>11070 <span class="comment">         know why we cannot insert an Ada exception catchpoint.</span>
<a name="l11071"></a>11071 <span class="comment"></span>
<a name="l11072"></a>11072 <span class="comment">         Note: Just for the purpose of inserting our Ada exception</span>
<a name="l11073"></a>11073 <span class="comment">         catchpoint, we could rely purely on the associated minimal symbol.</span>
<a name="l11074"></a>11074 <span class="comment">         But we would be operating in degraded mode anyway, since we are</span>
<a name="l11075"></a>11075 <span class="comment">         still lacking the debugging info needed later on to extract</span>
<a name="l11076"></a>11076 <span class="comment">         the name of the exception being raised (this name is printed in</span>
<a name="l11077"></a>11077 <span class="comment">         the catchpoint message, and is also used when trying to catch</span>
<a name="l11078"></a>11078 <span class="comment">         a specific exception).  We do not handle this case for now.  */</span>
<a name="l11079"></a>11079       <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *msym
<a name="l11080"></a>11080         = <a class="code" href="minsyms_8c.html#af87f7a894386515074ddd71365bc09b8">lookup_minimal_symbol</a> (einfo-&gt;catch_exception_sym, NULL, NULL);
<a name="l11081"></a>11081 
<a name="l11082"></a>11082       <span class="keywordflow">if</span> (msym &amp;&amp; <a class="code" href="symtab_8h.html#a1d0b27d446f2622f464727b6a06ae263">MSYMBOL_TYPE</a> (msym) != <a class="code" href="symtab_8h.html#a91ee0a03aba3bbd0e221547c3d82c036aa6ace68113ace3aafa25e705d9fce85d">mst_solib_trampoline</a>)
<a name="l11083"></a>11083         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Your Ada runtime appears to be missing some debugging &quot;</span>
<a name="l11084"></a>11084                  <span class="stringliteral">&quot;information.\nCannot insert Ada exception catchpoint &quot;</span>
<a name="l11085"></a>11085                  <span class="stringliteral">&quot;in this configuration.&quot;</span>));
<a name="l11086"></a>11086 
<a name="l11087"></a>11087       <span class="keywordflow">return</span> 0;
<a name="l11088"></a>11088     }
<a name="l11089"></a>11089 
<a name="l11090"></a>11090   <span class="comment">/* Make sure that the symbol we found corresponds to a function.  */</span>
<a name="l11091"></a>11091 
<a name="l11092"></a>11092   <span class="keywordflow">if</span> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) != <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>)
<a name="l11093"></a>11093     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Symbol \&quot;%s\&quot; is not a function (class = %d)&quot;</span>),
<a name="l11094"></a>11094            <a class="code" href="symtab_8h.html#a956b56288511a18b855d8a263d60e87f">SYMBOL_LINKAGE_NAME</a> (sym), <a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym));
<a name="l11095"></a>11095 
<a name="l11096"></a>11096   <span class="keywordflow">return</span> 1;
<a name="l11097"></a>11097 }
<a name="l11098"></a>11098 
<a name="l11099"></a>11099 <span class="comment">/* Inspect the Ada runtime and determine which exception info structure</span>
<a name="l11100"></a>11100 <span class="comment">   should be used to provide support for exception catchpoints.</span>
<a name="l11101"></a>11101 <span class="comment"></span>
<a name="l11102"></a>11102 <span class="comment">   This function will always set the per-inferior exception_info,</span>
<a name="l11103"></a>11103 <span class="comment">   or raise an error.  */</span>
<a name="l11104"></a>11104 
<a name="l11105"></a>11105 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11106"></a>11106 ada_exception_support_info_sniffer (<span class="keywordtype">void</span>)
<a name="l11107"></a>11107 {
<a name="l11108"></a>11108   <span class="keyword">struct </span>ada_inferior_data *data = get_ada_inferior_data (<a class="code" href="inferior_8c.html#a9e592c83e7c0c1f89f1a4a392bd1a277">current_inferior</a> ());
<a name="l11109"></a>11109 
<a name="l11110"></a>11110   <span class="comment">/* If the exception info is already known, then no need to recompute it.  */</span>
<a name="l11111"></a>11111   <span class="keywordflow">if</span> (data-&gt;exception_info != NULL)
<a name="l11112"></a>11112     <span class="keywordflow">return</span>;
<a name="l11113"></a>11113 
<a name="l11114"></a>11114   <span class="comment">/* Check the latest (default) exception support info.  */</span>
<a name="l11115"></a>11115   <span class="keywordflow">if</span> (ada_has_this_exception_support (&amp;default_exception_support_info))
<a name="l11116"></a>11116     {
<a name="l11117"></a>11117       data-&gt;exception_info = &amp;default_exception_support_info;
<a name="l11118"></a>11118       <span class="keywordflow">return</span>;
<a name="l11119"></a>11119     }
<a name="l11120"></a>11120 
<a name="l11121"></a>11121   <span class="comment">/* Try our fallback exception suport info.  */</span>
<a name="l11122"></a>11122   <span class="keywordflow">if</span> (ada_has_this_exception_support (&amp;exception_support_info_fallback))
<a name="l11123"></a>11123     {
<a name="l11124"></a>11124       data-&gt;exception_info = &amp;exception_support_info_fallback;
<a name="l11125"></a>11125       <span class="keywordflow">return</span>;
<a name="l11126"></a>11126     }
<a name="l11127"></a>11127 
<a name="l11128"></a>11128   <span class="comment">/* Sometimes, it is normal for us to not be able to find the routine</span>
<a name="l11129"></a>11129 <span class="comment">     we are looking for.  This happens when the program is linked with</span>
<a name="l11130"></a>11130 <span class="comment">     the shared version of the GNAT runtime, and the program has not been</span>
<a name="l11131"></a>11131 <span class="comment">     started yet.  Inform the user of these two possible causes if</span>
<a name="l11132"></a>11132 <span class="comment">     applicable.  */</span>
<a name="l11133"></a>11133 
<a name="l11134"></a>11134   <span class="keywordflow">if</span> (<a class="code" href="ada-lang_8c.html#ae183d69cbd41460251cae6b66a9acbed">ada_update_initial_language</a> (<a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a3082c2da456a8ca3aa34f721de2c3565">language_unknown</a>) != <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>)
<a name="l11135"></a>11135     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unable to insert catchpoint.  Is this an Ada main program?&quot;</span>));
<a name="l11136"></a>11136 
<a name="l11137"></a>11137   <span class="comment">/* If the symbol does not exist, then check that the program is</span>
<a name="l11138"></a>11138 <span class="comment">     already started, to make sure that shared libraries have been</span>
<a name="l11139"></a>11139 <span class="comment">     loaded.  If it is not started, this may mean that the symbol is</span>
<a name="l11140"></a>11140 <span class="comment">     in a shared library.  */</span>
<a name="l11141"></a>11141 
<a name="l11142"></a>11142   <span class="keywordflow">if</span> (<a class="code" href="ptid_8c.html#a264ba40fc2a0cf3d4fb24a55fe32aede">ptid_get_pid</a> (<a class="code" href="infcmd_8c.html#a428c5be9ce5e70bd03760e828e19c6b7">inferior_ptid</a>) == 0)
<a name="l11143"></a>11143     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unable to insert catchpoint. Try to start the program first.&quot;</span>));
<a name="l11144"></a>11144 
<a name="l11145"></a>11145   <span class="comment">/* At this point, we know that we are debugging an Ada program and</span>
<a name="l11146"></a>11146 <span class="comment">     that the inferior has been started, but we still are not able to</span>
<a name="l11147"></a>11147 <span class="comment">     find the run-time symbols.  That can mean that we are in</span>
<a name="l11148"></a>11148 <span class="comment">     configurable run time mode, or that a-except as been optimized</span>
<a name="l11149"></a>11149 <span class="comment">     out by the linker...  In any case, at this point it is not worth</span>
<a name="l11150"></a>11150 <span class="comment">     supporting this feature.  */</span>
<a name="l11151"></a>11151 
<a name="l11152"></a>11152   <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Cannot insert Ada exception catchpoints in this configuration.&quot;</span>));
<a name="l11153"></a>11153 }
<a name="l11154"></a>11154 
<a name="l11155"></a>11155 <span class="comment">/* True iff FRAME is very likely to be that of a function that is</span>
<a name="l11156"></a>11156 <span class="comment">   part of the runtime system.  This is all very heuristic, but is</span>
<a name="l11157"></a>11157 <span class="comment">   intended to be used as advice as to what frames are uninteresting</span>
<a name="l11158"></a>11158 <span class="comment">   to most users.  */</span>
<a name="l11159"></a>11159 
<a name="l11160"></a>11160 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l11161"></a>11161 is_known_support_routine (<span class="keyword">struct</span> frame_info *frame)
<a name="l11162"></a>11162 {
<a name="l11163"></a>11163   <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a> sal;
<a name="l11164"></a>11164   <span class="keywordtype">char</span> *func_name;
<a name="l11165"></a>11165   <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> func_lang;
<a name="l11166"></a>11166   <span class="keywordtype">int</span> i;
<a name="l11167"></a>11167   <span class="keyword">const</span> <span class="keywordtype">char</span> *fullname;
<a name="l11168"></a>11168 
<a name="l11169"></a>11169   <span class="comment">/* If this code does not have any debugging information (no symtab),</span>
<a name="l11170"></a>11170 <span class="comment">     This cannot be any user code.  */</span>
<a name="l11171"></a>11171 
<a name="l11172"></a>11172   <a class="code" href="frame_8c.html#a462d32901b9dd9787da65adb627a9a05">find_frame_sal</a> (frame, &amp;sal);
<a name="l11173"></a>11173   <span class="keywordflow">if</span> (sal.symtab == NULL)
<a name="l11174"></a>11174     <span class="keywordflow">return</span> 1;
<a name="l11175"></a>11175 
<a name="l11176"></a>11176   <span class="comment">/* If there is a symtab, but the associated source file cannot be</span>
<a name="l11177"></a>11177 <span class="comment">     located, then assume this is not user code:  Selecting a frame</span>
<a name="l11178"></a>11178 <span class="comment">     for which we cannot display the code would not be very helpful</span>
<a name="l11179"></a>11179 <span class="comment">     for the user.  This should also take care of case such as VxWorks</span>
<a name="l11180"></a>11180 <span class="comment">     where the kernel has some debugging info provided for a few units.  */</span>
<a name="l11181"></a>11181 
<a name="l11182"></a>11182   fullname = <a class="code" href="source_8c.html#aa78177718e9d6c01595600975e8254df">symtab_to_fullname</a> (sal.symtab);
<a name="l11183"></a>11183   <span class="keywordflow">if</span> (access (fullname, R_OK) != 0)
<a name="l11184"></a>11184     <span class="keywordflow">return</span> 1;
<a name="l11185"></a>11185 
<a name="l11186"></a>11186   <span class="comment">/* Check the unit filename againt the Ada runtime file naming.</span>
<a name="l11187"></a>11187 <span class="comment">     We also check the name of the objfile against the name of some</span>
<a name="l11188"></a>11188 <span class="comment">     known system libraries that sometimes come with debugging info</span>
<a name="l11189"></a>11189 <span class="comment">     too.  */</span>
<a name="l11190"></a>11190 
<a name="l11191"></a>11191   <span class="keywordflow">for</span> (i = 0; known_runtime_file_name_patterns[i] != NULL; i += 1)
<a name="l11192"></a>11192     {
<a name="l11193"></a>11193       <a class="code" href="defs_8h.html#ad321e1eefeb38442e0c40b1279f41ca0">re_comp</a> (known_runtime_file_name_patterns[i]);
<a name="l11194"></a>11194       <span class="keywordflow">if</span> (re_exec (lbasename (sal.symtab-&gt;filename)))
<a name="l11195"></a>11195         <span class="keywordflow">return</span> 1;
<a name="l11196"></a>11196       <span class="keywordflow">if</span> (sal.symtab-&gt;objfile != NULL
<a name="l11197"></a>11197           &amp;&amp; re_exec (<a class="code" href="objfiles_8c.html#a33e548a19b86b293435d3c2d6daaaec6">objfile_name</a> (sal.symtab-&gt;objfile)))
<a name="l11198"></a>11198         <span class="keywordflow">return</span> 1;
<a name="l11199"></a>11199     }
<a name="l11200"></a>11200 
<a name="l11201"></a>11201   <span class="comment">/* Check whether the function is a GNAT-generated entity.  */</span>
<a name="l11202"></a>11202 
<a name="l11203"></a>11203   <a class="code" href="stack_8c.html#aae29e3af4291a6c85fd82000e51ee80c">find_frame_funname</a> (frame, &amp;func_name, &amp;func_lang, NULL);
<a name="l11204"></a>11204   <span class="keywordflow">if</span> (func_name == NULL)
<a name="l11205"></a>11205     <span class="keywordflow">return</span> 1;
<a name="l11206"></a>11206 
<a name="l11207"></a>11207   <span class="keywordflow">for</span> (i = 0; known_auxiliary_function_name_patterns[i] != NULL; i += 1)
<a name="l11208"></a>11208     {
<a name="l11209"></a>11209       <a class="code" href="defs_8h.html#ad321e1eefeb38442e0c40b1279f41ca0">re_comp</a> (known_auxiliary_function_name_patterns[i]);
<a name="l11210"></a>11210       <span class="keywordflow">if</span> (re_exec (func_name))
<a name="l11211"></a>11211         {
<a name="l11212"></a>11212           <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (func_name);
<a name="l11213"></a>11213           <span class="keywordflow">return</span> 1;
<a name="l11214"></a>11214         }
<a name="l11215"></a>11215     }
<a name="l11216"></a>11216 
<a name="l11217"></a>11217   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (func_name);
<a name="l11218"></a>11218   <span class="keywordflow">return</span> 0;
<a name="l11219"></a>11219 }
<a name="l11220"></a>11220 
<a name="l11221"></a>11221 <span class="comment">/* Find the first frame that contains debugging information and that is not</span>
<a name="l11222"></a>11222 <span class="comment">   part of the Ada run-time, starting from FI and moving upward.  */</span>
<a name="l11223"></a>11223 
<a name="l11224"></a>11224 <span class="keywordtype">void</span>
<a name="l11225"></a><a class="code" href="ada-lang_8h.html#a913f0d21ae3a48d97b313e4846ce3cf0">11225</a> <a class="code" href="ada-lang_8c.html#a913f0d21ae3a48d97b313e4846ce3cf0">ada_find_printable_frame</a> (<span class="keyword">struct</span> frame_info *fi)
<a name="l11226"></a>11226 {
<a name="l11227"></a>11227   <span class="keywordflow">for</span> (; fi != NULL; fi = <a class="code" href="frame_8c.html#a7dc158f329065de426029f24f5578838">get_prev_frame</a> (fi))
<a name="l11228"></a>11228     {
<a name="l11229"></a>11229       <span class="keywordflow">if</span> (!is_known_support_routine (fi))
<a name="l11230"></a>11230         {
<a name="l11231"></a>11231           <a class="code" href="frame_8c.html#a400fa273ac86863322cdc65683ef2356">select_frame</a> (fi);
<a name="l11232"></a>11232           <span class="keywordflow">break</span>;
<a name="l11233"></a>11233         }
<a name="l11234"></a>11234     }
<a name="l11235"></a>11235 
<a name="l11236"></a>11236 }
<a name="l11237"></a>11237 
<a name="l11238"></a>11238 <span class="comment">/* Assuming that the inferior just triggered an unhandled exception</span>
<a name="l11239"></a>11239 <span class="comment">   catchpoint, return the address in inferior memory where the name</span>
<a name="l11240"></a>11240 <span class="comment">   of the exception is stored.</span>
<a name="l11241"></a>11241 <span class="comment">   </span>
<a name="l11242"></a>11242 <span class="comment">   Return zero if the address could not be computed.  */</span>
<a name="l11243"></a>11243 
<a name="l11244"></a>11244 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l11245"></a>11245 ada_unhandled_exception_name_addr (<span class="keywordtype">void</span>)
<a name="l11246"></a>11246 {
<a name="l11247"></a>11247   <span class="keywordflow">return</span> <a class="code" href="eval_8c.html#adc1b596b06e274a83197cdeaa0c2809c">parse_and_eval_address</a> (<span class="stringliteral">&quot;e.full_name&quot;</span>);
<a name="l11248"></a>11248 }
<a name="l11249"></a>11249 
<a name="l11250"></a>11250 <span class="comment">/* Same as ada_unhandled_exception_name_addr, except that this function</span>
<a name="l11251"></a>11251 <span class="comment">   should be used when the inferior uses an older version of the runtime,</span>
<a name="l11252"></a>11252 <span class="comment">   where the exception name needs to be extracted from a specific frame</span>
<a name="l11253"></a>11253 <span class="comment">   several frames up in the callstack.  */</span>
<a name="l11254"></a>11254 
<a name="l11255"></a>11255 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l11256"></a>11256 ada_unhandled_exception_name_addr_from_raise (<span class="keywordtype">void</span>)
<a name="l11257"></a>11257 {
<a name="l11258"></a>11258   <span class="keywordtype">int</span> frame_level;
<a name="l11259"></a>11259   <span class="keyword">struct </span>frame_info *fi;
<a name="l11260"></a>11260   <span class="keyword">struct </span>ada_inferior_data *data = get_ada_inferior_data (<a class="code" href="inferior_8c.html#a9e592c83e7c0c1f89f1a4a392bd1a277">current_inferior</a> ());
<a name="l11261"></a>11261   <span class="keyword">struct </span>cleanup *old_chain;
<a name="l11262"></a>11262 
<a name="l11263"></a>11263   <span class="comment">/* To determine the name of this exception, we need to select</span>
<a name="l11264"></a>11264 <span class="comment">     the frame corresponding to RAISE_SYM_NAME.  This frame is</span>
<a name="l11265"></a>11265 <span class="comment">     at least 3 levels up, so we simply skip the first 3 frames</span>
<a name="l11266"></a>11266 <span class="comment">     without checking the name of their associated function.  */</span>
<a name="l11267"></a>11267   fi = <a class="code" href="frame_8c.html#a5ab254510728049878a232ed1b889820">get_current_frame</a> ();
<a name="l11268"></a>11268   <span class="keywordflow">for</span> (frame_level = 0; frame_level &lt; 3; frame_level += 1)
<a name="l11269"></a>11269     <span class="keywordflow">if</span> (fi != NULL)
<a name="l11270"></a>11270       fi = <a class="code" href="frame_8c.html#a7dc158f329065de426029f24f5578838">get_prev_frame</a> (fi); 
<a name="l11271"></a>11271 
<a name="l11272"></a>11272   old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, NULL);
<a name="l11273"></a>11273   <span class="keywordflow">while</span> (fi != NULL)
<a name="l11274"></a>11274     {
<a name="l11275"></a>11275       <span class="keywordtype">char</span> *func_name;
<a name="l11276"></a>11276       <span class="keyword">enum</span> <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202">language</a> func_lang;
<a name="l11277"></a>11277 
<a name="l11278"></a>11278       <a class="code" href="stack_8c.html#aae29e3af4291a6c85fd82000e51ee80c">find_frame_funname</a> (fi, &amp;func_name, &amp;func_lang, NULL);
<a name="l11279"></a>11279       <span class="keywordflow">if</span> (func_name != NULL)
<a name="l11280"></a>11280         {
<a name="l11281"></a>11281           <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, func_name);
<a name="l11282"></a>11282 
<a name="l11283"></a>11283           <span class="keywordflow">if</span> (strcmp (func_name,
<a name="l11284"></a>11284                       data-&gt;exception_info-&gt;catch_exception_sym) == 0)
<a name="l11285"></a>11285             <span class="keywordflow">break</span>; <span class="comment">/* We found the frame we were looking for...  */</span>
<a name="l11286"></a>11286           fi = <a class="code" href="frame_8c.html#a7dc158f329065de426029f24f5578838">get_prev_frame</a> (fi);
<a name="l11287"></a>11287         }
<a name="l11288"></a>11288     }
<a name="l11289"></a>11289   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l11290"></a>11290 
<a name="l11291"></a>11291   <span class="keywordflow">if</span> (fi == NULL)
<a name="l11292"></a>11292     <span class="keywordflow">return</span> 0;
<a name="l11293"></a>11293 
<a name="l11294"></a>11294   <a class="code" href="frame_8c.html#a400fa273ac86863322cdc65683ef2356">select_frame</a> (fi);
<a name="l11295"></a>11295   <span class="keywordflow">return</span> <a class="code" href="eval_8c.html#adc1b596b06e274a83197cdeaa0c2809c">parse_and_eval_address</a> (<span class="stringliteral">&quot;id.full_name&quot;</span>);
<a name="l11296"></a>11296 }
<a name="l11297"></a>11297 
<a name="l11298"></a>11298 <span class="comment">/* Assuming the inferior just triggered an Ada exception catchpoint</span>
<a name="l11299"></a>11299 <span class="comment">   (of any type), return the address in inferior memory where the name</span>
<a name="l11300"></a>11300 <span class="comment">   of the exception is stored, if applicable.</span>
<a name="l11301"></a>11301 <span class="comment"></span>
<a name="l11302"></a>11302 <span class="comment">   Return zero if the address could not be computed, or if not relevant.  */</span>
<a name="l11303"></a>11303 
<a name="l11304"></a>11304 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l11305"></a>11305 ada_exception_name_addr_1 (<span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex,
<a name="l11306"></a>11306                            <span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l11307"></a>11307 {
<a name="l11308"></a>11308   <span class="keyword">struct </span>ada_inferior_data *data = get_ada_inferior_data (<a class="code" href="inferior_8c.html#a9e592c83e7c0c1f89f1a4a392bd1a277">current_inferior</a> ());
<a name="l11309"></a>11309 
<a name="l11310"></a>11310   <span class="keywordflow">switch</span> (ex)
<a name="l11311"></a>11311     {
<a name="l11312"></a>11312       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>:
<a name="l11313"></a>11313         <span class="keywordflow">return</span> (<a class="code" href="eval_8c.html#adc1b596b06e274a83197cdeaa0c2809c">parse_and_eval_address</a> (<span class="stringliteral">&quot;e.full_name&quot;</span>));
<a name="l11314"></a>11314         <span class="keywordflow">break</span>;
<a name="l11315"></a>11315 
<a name="l11316"></a>11316       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>:
<a name="l11317"></a>11317         <span class="keywordflow">return</span> data-&gt;exception_info-&gt;unhandled_exception_name_addr ();
<a name="l11318"></a>11318         <span class="keywordflow">break</span>;
<a name="l11319"></a>11319       
<a name="l11320"></a>11320       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>:
<a name="l11321"></a>11321         <span class="keywordflow">return</span> 0;  <span class="comment">/* Exception name is not relevant in this case.  */</span>
<a name="l11322"></a>11322         <span class="keywordflow">break</span>;
<a name="l11323"></a>11323 
<a name="l11324"></a>11324       <span class="keywordflow">default</span>:
<a name="l11325"></a>11325         <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unexpected catchpoint type&quot;</span>));
<a name="l11326"></a>11326         <span class="keywordflow">break</span>;
<a name="l11327"></a>11327     }
<a name="l11328"></a>11328 
<a name="l11329"></a>11329   <span class="keywordflow">return</span> 0; <span class="comment">/* Should never be reached.  */</span>
<a name="l11330"></a>11330 }
<a name="l11331"></a>11331 
<a name="l11332"></a>11332 <span class="comment">/* Same as ada_exception_name_addr_1, except that it intercepts and contains</span>
<a name="l11333"></a>11333 <span class="comment">   any error that ada_exception_name_addr_1 might cause to be thrown.</span>
<a name="l11334"></a>11334 <span class="comment">   When an error is intercepted, a warning with the error message is printed,</span>
<a name="l11335"></a>11335 <span class="comment">   and zero is returned.  */</span>
<a name="l11336"></a>11336 
<a name="l11337"></a>11337 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l11338"></a>11338 ada_exception_name_addr (<span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex,
<a name="l11339"></a>11339                          <span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l11340"></a>11340 {
<a name="l11341"></a>11341   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> e;
<a name="l11342"></a>11342   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> result = 0;
<a name="l11343"></a>11343 
<a name="l11344"></a>11344   <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (e, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l11345"></a>11345     {
<a name="l11346"></a>11346       result = ada_exception_name_addr_1 (ex, b);
<a name="l11347"></a>11347     }
<a name="l11348"></a>11348 
<a name="l11349"></a>11349   <span class="keywordflow">if</span> (e.reason &lt; 0)
<a name="l11350"></a>11350     {
<a name="l11351"></a>11351       <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;failed to get exception name: %s&quot;</span>), e.message);
<a name="l11352"></a>11352       <span class="keywordflow">return</span> 0;
<a name="l11353"></a>11353     }
<a name="l11354"></a>11354 
<a name="l11355"></a>11355   <span class="keywordflow">return</span> result;
<a name="l11356"></a>11356 }
<a name="l11357"></a>11357 
<a name="l11358"></a>11358 <span class="keyword">static</span> <span class="keywordtype">char</span> *ada_exception_catchpoint_cond_string (<span class="keyword">const</span> <span class="keywordtype">char</span> *excep_string);
<a name="l11359"></a>11359 
<a name="l11360"></a>11360 <span class="comment">/* Ada catchpoints.</span>
<a name="l11361"></a>11361 <span class="comment"></span>
<a name="l11362"></a>11362 <span class="comment">   In the case of catchpoints on Ada exceptions, the catchpoint will</span>
<a name="l11363"></a>11363 <span class="comment">   stop the target on every exception the program throws.  When a user</span>
<a name="l11364"></a>11364 <span class="comment">   specifies the name of a specific exception, we translate this</span>
<a name="l11365"></a>11365 <span class="comment">   request into a condition expression (in text form), and then parse</span>
<a name="l11366"></a>11366 <span class="comment">   it into an expression stored in each of the catchpoint&#39;s locations.</span>
<a name="l11367"></a>11367 <span class="comment">   We then use this condition to check whether the exception that was</span>
<a name="l11368"></a>11368 <span class="comment">   raised is the one the user is interested in.  If not, then the</span>
<a name="l11369"></a>11369 <span class="comment">   target is resumed again.  We store the name of the requested</span>
<a name="l11370"></a>11370 <span class="comment">   exception, in order to be able to re-set the condition expression</span>
<a name="l11371"></a>11371 <span class="comment">   when symbols change.  */</span>
<a name="l11372"></a>11372 
<a name="l11373"></a>11373 <span class="comment">/* An instance of this type is used to represent an Ada catchpoint</span>
<a name="l11374"></a>11374 <span class="comment">   breakpoint location.  It includes a &quot;struct bp_location&quot; as a kind</span>
<a name="l11375"></a>11375 <span class="comment">   of base class; users downcast to &quot;struct bp_location *&quot; when</span>
<a name="l11376"></a>11376 <span class="comment">   needed.  */</span>
<a name="l11377"></a>11377 
<a name="l11378"></a>11378 <span class="keyword">struct </span>ada_catchpoint_location
<a name="l11379"></a>11379 {
<a name="l11380"></a>11380   <span class="comment">/* The base class.  */</span>
<a name="l11381"></a>11381   <span class="keyword">struct </span><a class="code" href="structbp__location.html">bp_location</a> base;
<a name="l11382"></a>11382 
<a name="l11383"></a>11383   <span class="comment">/* The condition that checks whether the exception that was raised</span>
<a name="l11384"></a>11384 <span class="comment">     is the specific exception the user specified on catchpoint</span>
<a name="l11385"></a>11385 <span class="comment">     creation.  */</span>
<a name="l11386"></a>11386   <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *excep_cond_expr;
<a name="l11387"></a>11387 };
<a name="l11388"></a>11388 
<a name="l11389"></a>11389 <span class="comment">/* Implement the DTOR method in the bp_location_ops structure for all</span>
<a name="l11390"></a>11390 <span class="comment">   Ada exception catchpoint kinds.  */</span>
<a name="l11391"></a>11391 
<a name="l11392"></a>11392 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11393"></a>11393 ada_catchpoint_location_dtor (<span class="keyword">struct</span> <a class="code" href="structbp__location.html">bp_location</a> *bl)
<a name="l11394"></a>11394 {
<a name="l11395"></a>11395   <span class="keyword">struct </span>ada_catchpoint_location *al = (<span class="keyword">struct </span>ada_catchpoint_location *) bl;
<a name="l11396"></a>11396 
<a name="l11397"></a>11397   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (al-&gt;excep_cond_expr);
<a name="l11398"></a>11398 }
<a name="l11399"></a>11399 
<a name="l11400"></a>11400 <span class="comment">/* The vtable to be used in Ada catchpoint locations.  */</span>
<a name="l11401"></a>11401 
<a name="l11402"></a>11402 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structbp__location__ops.html">bp_location_ops</a> ada_catchpoint_location_ops =
<a name="l11403"></a>11403 {
<a name="l11404"></a>11404   ada_catchpoint_location_dtor
<a name="l11405"></a>11405 };
<a name="l11406"></a>11406 
<a name="l11407"></a>11407 <span class="comment">/* An instance of this type is used to represent an Ada catchpoint.</span>
<a name="l11408"></a>11408 <span class="comment">   It includes a &quot;struct breakpoint&quot; as a kind of base class; users</span>
<a name="l11409"></a>11409 <span class="comment">   downcast to &quot;struct breakpoint *&quot; when needed.  */</span>
<a name="l11410"></a>11410 
<a name="l11411"></a>11411 <span class="keyword">struct </span>ada_catchpoint
<a name="l11412"></a>11412 {
<a name="l11413"></a>11413   <span class="comment">/* The base class.  */</span>
<a name="l11414"></a>11414   <span class="keyword">struct </span><a class="code" href="structbreakpoint.html">breakpoint</a> base;
<a name="l11415"></a>11415 
<a name="l11416"></a>11416   <span class="comment">/* The name of the specific exception the user specified.  */</span>
<a name="l11417"></a>11417   <span class="keywordtype">char</span> *excep_string;
<a name="l11418"></a>11418 };
<a name="l11419"></a>11419 
<a name="l11420"></a>11420 <span class="comment">/* Parse the exception condition string in the context of each of the</span>
<a name="l11421"></a>11421 <span class="comment">   catchpoint&#39;s locations, and store them for later evaluation.  */</span>
<a name="l11422"></a>11422 
<a name="l11423"></a>11423 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11424"></a>11424 create_excep_cond_exprs (<span class="keyword">struct</span> ada_catchpoint *c)
<a name="l11425"></a>11425 {
<a name="l11426"></a>11426   <span class="keyword">struct </span>cleanup *old_chain;
<a name="l11427"></a>11427   <span class="keyword">struct </span><a class="code" href="structbp__location.html">bp_location</a> *bl;
<a name="l11428"></a>11428   <span class="keywordtype">char</span> *cond_string;
<a name="l11429"></a>11429 
<a name="l11430"></a>11430   <span class="comment">/* Nothing to do if there&#39;s no specific exception to catch.  */</span>
<a name="l11431"></a>11431   <span class="keywordflow">if</span> (c-&gt;excep_string == NULL)
<a name="l11432"></a>11432     <span class="keywordflow">return</span>;
<a name="l11433"></a>11433 
<a name="l11434"></a>11434   <span class="comment">/* Same if there are no locations... */</span>
<a name="l11435"></a>11435   <span class="keywordflow">if</span> (c-&gt;base.loc == NULL)
<a name="l11436"></a>11436     <span class="keywordflow">return</span>;
<a name="l11437"></a>11437 
<a name="l11438"></a>11438   <span class="comment">/* Compute the condition expression in text form, from the specific</span>
<a name="l11439"></a>11439 <span class="comment">     expection we want to catch.  */</span>
<a name="l11440"></a>11440   cond_string = ada_exception_catchpoint_cond_string (c-&gt;excep_string);
<a name="l11441"></a>11441   old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, cond_string);
<a name="l11442"></a>11442 
<a name="l11443"></a>11443   <span class="comment">/* Iterate over all the catchpoint&#39;s locations, and parse an</span>
<a name="l11444"></a>11444 <span class="comment">     expression for each.  */</span>
<a name="l11445"></a>11445   <span class="keywordflow">for</span> (bl = c-&gt;base.loc; bl != NULL; bl = bl-&gt;<a class="code" href="structbp__location.html#ab193cb38f87fea89105db96d94191541">next</a>)
<a name="l11446"></a>11446     {
<a name="l11447"></a>11447       <span class="keyword">struct </span>ada_catchpoint_location *ada_loc
<a name="l11448"></a>11448         = (<span class="keyword">struct </span>ada_catchpoint_location *) bl;
<a name="l11449"></a>11449       <span class="keyword">struct </span><a class="code" href="structexpression.html">expression</a> *exp = NULL;
<a name="l11450"></a>11450 
<a name="l11451"></a>11451       <span class="keywordflow">if</span> (!bl-&gt;<a class="code" href="structbp__location.html#a3732b41958ed311106bffd202cbfe4ff">shlib_disabled</a>)
<a name="l11452"></a>11452         {
<a name="l11453"></a>11453           <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> e;
<a name="l11454"></a>11454           <span class="keyword">const</span> <span class="keywordtype">char</span> *s;
<a name="l11455"></a>11455 
<a name="l11456"></a>11456           s = cond_string;
<a name="l11457"></a>11457           <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (e, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6a44de51845416ac49ab08438792b908f0">RETURN_MASK_ERROR</a>)
<a name="l11458"></a>11458             {
<a name="l11459"></a>11459               exp = <a class="code" href="expression_8h.html#abdad295cc4b5351f6e6ec024ab665475">parse_exp_1</a> (&amp;s, bl-&gt;<a class="code" href="structbp__location.html#a6b6cd8b8a488e632200f323309d23823">address</a>,
<a name="l11460"></a>11460                                  <a class="code" href="block_8c.html#a35aadf82f92cb4a47ec068dba0e1b36c">block_for_pc</a> (bl-&gt;<a class="code" href="structbp__location.html#a6b6cd8b8a488e632200f323309d23823">address</a>), 0);
<a name="l11461"></a>11461             }
<a name="l11462"></a>11462           <span class="keywordflow">if</span> (e.reason &lt; 0)
<a name="l11463"></a>11463             <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;failed to reevaluate internal exception condition &quot;</span>
<a name="l11464"></a>11464                        <span class="stringliteral">&quot;for catchpoint %d: %s&quot;</span>),
<a name="l11465"></a>11465                      c-&gt;base.number, e.message);
<a name="l11466"></a>11466         }
<a name="l11467"></a>11467 
<a name="l11468"></a>11468       ada_loc-&gt;excep_cond_expr = exp;
<a name="l11469"></a>11469     }
<a name="l11470"></a>11470 
<a name="l11471"></a>11471   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l11472"></a>11472 }
<a name="l11473"></a>11473 
<a name="l11474"></a>11474 <span class="comment">/* Implement the DTOR method in the breakpoint_ops structure for all</span>
<a name="l11475"></a>11475 <span class="comment">   exception catchpoint kinds.  */</span>
<a name="l11476"></a>11476 
<a name="l11477"></a>11477 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11478"></a>11478 dtor_exception (<span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex, <span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l11479"></a>11479 {
<a name="l11480"></a>11480   <span class="keyword">struct </span>ada_catchpoint *c = (<span class="keyword">struct </span>ada_catchpoint *) b;
<a name="l11481"></a>11481 
<a name="l11482"></a>11482   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (c-&gt;excep_string);
<a name="l11483"></a>11483 
<a name="l11484"></a>11484   <a class="code" href="breakpoint_8c.html#a9b47dd7cd982ec63ffd303246d93cf7a">bkpt_breakpoint_ops</a>.<a class="code" href="structbreakpoint__ops.html#a110b2df7b285e5f83bf40b9a0e5435c1">dtor</a> (b);
<a name="l11485"></a>11485 }
<a name="l11486"></a>11486 
<a name="l11487"></a>11487 <span class="comment">/* Implement the ALLOCATE_LOCATION method in the breakpoint_ops</span>
<a name="l11488"></a>11488 <span class="comment">   structure for all exception catchpoint kinds.  */</span>
<a name="l11489"></a>11489 
<a name="l11490"></a>11490 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structbp__location.html">bp_location</a> *
<a name="l11491"></a>11491 allocate_location_exception (<span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex,
<a name="l11492"></a>11492                              <span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *<span class="keyword">self</span>)
<a name="l11493"></a>11493 {
<a name="l11494"></a>11494   <span class="keyword">struct </span>ada_catchpoint_location *loc;
<a name="l11495"></a>11495 
<a name="l11496"></a>11496   loc = XNEW (<span class="keyword">struct</span> ada_catchpoint_location);
<a name="l11497"></a>11497   <a class="code" href="breakpoint_8c.html#ae971720e6c09c471408d173beee367cd">init_bp_location</a> (&amp;loc-&gt;base, &amp;ada_catchpoint_location_ops, <span class="keyword">self</span>);
<a name="l11498"></a>11498   loc-&gt;excep_cond_expr = NULL;
<a name="l11499"></a>11499   <span class="keywordflow">return</span> &amp;loc-&gt;base;
<a name="l11500"></a>11500 }
<a name="l11501"></a>11501 
<a name="l11502"></a>11502 <span class="comment">/* Implement the RE_SET method in the breakpoint_ops structure for all</span>
<a name="l11503"></a>11503 <span class="comment">   exception catchpoint kinds.  */</span>
<a name="l11504"></a>11504 
<a name="l11505"></a>11505 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11506"></a>11506 re_set_exception (<span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex, <span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l11507"></a>11507 {
<a name="l11508"></a>11508   <span class="keyword">struct </span>ada_catchpoint *c = (<span class="keyword">struct </span>ada_catchpoint *) b;
<a name="l11509"></a>11509 
<a name="l11510"></a>11510   <span class="comment">/* Call the base class&#39;s method.  This updates the catchpoint&#39;s</span>
<a name="l11511"></a>11511 <span class="comment">     locations.  */</span>
<a name="l11512"></a>11512   <a class="code" href="breakpoint_8c.html#a9b47dd7cd982ec63ffd303246d93cf7a">bkpt_breakpoint_ops</a>.<a class="code" href="structbreakpoint__ops.html#a42f6ff20f3eb39f78874c914d34e09b5">re_set</a> (b);
<a name="l11513"></a>11513 
<a name="l11514"></a>11514   <span class="comment">/* Reparse the exception conditional expressions.  One for each</span>
<a name="l11515"></a>11515 <span class="comment">     location.  */</span>
<a name="l11516"></a>11516   create_excep_cond_exprs (c);
<a name="l11517"></a>11517 }
<a name="l11518"></a>11518 
<a name="l11519"></a>11519 <span class="comment">/* Returns true if we should stop for this breakpoint hit.  If the</span>
<a name="l11520"></a>11520 <span class="comment">   user specified a specific exception, we only want to cause a stop</span>
<a name="l11521"></a>11521 <span class="comment">   if the program thrown that exception.  */</span>
<a name="l11522"></a>11522 
<a name="l11523"></a>11523 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l11524"></a>11524 should_stop_exception (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structbp__location.html">bp_location</a> *bl)
<a name="l11525"></a>11525 {
<a name="l11526"></a>11526   <span class="keyword">struct </span>ada_catchpoint *c = (<span class="keyword">struct </span>ada_catchpoint *) bl-&gt;<a class="code" href="structbp__location.html#ade5cd870d1e7255c36ac84c2c6f1c4c2">owner</a>;
<a name="l11527"></a>11527   <span class="keyword">const</span> <span class="keyword">struct</span> ada_catchpoint_location *ada_loc
<a name="l11528"></a>11528     = (<span class="keyword">const</span> <span class="keyword">struct</span> ada_catchpoint_location *) bl;
<a name="l11529"></a>11529   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> ex;
<a name="l11530"></a>11530   <span class="keywordtype">int</span> stop;
<a name="l11531"></a>11531 
<a name="l11532"></a>11532   <span class="comment">/* With no specific exception, should always stop.  */</span>
<a name="l11533"></a>11533   <span class="keywordflow">if</span> (c-&gt;excep_string == NULL)
<a name="l11534"></a>11534     <span class="keywordflow">return</span> 1;
<a name="l11535"></a>11535 
<a name="l11536"></a>11536   <span class="keywordflow">if</span> (ada_loc-&gt;excep_cond_expr == NULL)
<a name="l11537"></a>11537     {
<a name="l11538"></a>11538       <span class="comment">/* We will have a NULL expression if back when we were creating</span>
<a name="l11539"></a>11539 <span class="comment">         the expressions, this location&#39;s had failed to parse.  */</span>
<a name="l11540"></a>11540       <span class="keywordflow">return</span> 1;
<a name="l11541"></a>11541     }
<a name="l11542"></a>11542 
<a name="l11543"></a>11543   stop = 1;
<a name="l11544"></a>11544   <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (ex, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6ab50fde886a7de8c013bf2bd4e7c073a4">RETURN_MASK_ALL</a>)
<a name="l11545"></a>11545     {
<a name="l11546"></a>11546       <span class="keyword">struct </span>value *mark;
<a name="l11547"></a>11547 
<a name="l11548"></a>11548       mark = <a class="code" href="value_8c.html#a427a12b0dd4d5663b103d29f07a0e1c6">value_mark</a> ();
<a name="l11549"></a>11549       stop = <a class="code" href="language_8c.html#ac4c03bad1fa69801b9ca23e550fe2e2c">value_true</a> (<a class="code" href="eval_8c.html#ab50151ccba3ea3184c114121d6bed422">evaluate_expression</a> (ada_loc-&gt;excep_cond_expr));
<a name="l11550"></a>11550       <a class="code" href="value_8c.html#a10aad9b72e08c5e90e3051156fa83318">value_free_to_mark</a> (mark);
<a name="l11551"></a>11551     }
<a name="l11552"></a>11552   <span class="keywordflow">if</span> (ex.reason &lt; 0)
<a name="l11553"></a>11553     <a class="code" href="exceptions_8c.html#ae1dffc77e3a96d17e813da7d2165b16d">exception_fprintf</a> (<a class="code" href="main_8c.html#a2a1dea1e551cadb9541353a004193a47">gdb_stderr</a>, ex,
<a name="l11554"></a>11554                        <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Error in testing exception condition:\n&quot;</span>));
<a name="l11555"></a>11555   <span class="keywordflow">return</span> stop;
<a name="l11556"></a>11556 }
<a name="l11557"></a>11557 
<a name="l11558"></a>11558 <span class="comment">/* Implement the CHECK_STATUS method in the breakpoint_ops structure</span>
<a name="l11559"></a>11559 <span class="comment">   for all exception catchpoint kinds.  */</span>
<a name="l11560"></a>11560 
<a name="l11561"></a>11561 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11562"></a>11562 check_status_exception (<span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex, <a class="code" href="structbpstats.html">bpstat</a> bs)
<a name="l11563"></a>11563 {
<a name="l11564"></a>11564   bs-&gt;<a class="code" href="structbpstats.html#acff86901962f7bc070661b85248c4652">stop</a> = should_stop_exception (bs-&gt;<a class="code" href="structbpstats.html#a510428e7ce2e4852e0613b3b5579142b">bp_location_at</a>);
<a name="l11565"></a>11565 }
<a name="l11566"></a>11566 
<a name="l11567"></a>11567 <span class="comment">/* Implement the PRINT_IT method in the breakpoint_ops structure</span>
<a name="l11568"></a>11568 <span class="comment">   for all exception catchpoint kinds.  */</span>
<a name="l11569"></a>11569 
<a name="l11570"></a>11570 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="breakpoint_8h.html#ab6ab1d6a867561653e32a901b41be66b">print_stop_action</a>
<a name="l11571"></a>11571 print_it_exception (<span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex, <a class="code" href="structbpstats.html">bpstat</a> bs)
<a name="l11572"></a>11572 {
<a name="l11573"></a>11573   <span class="keyword">struct </span>ui_out *uiout = <a class="code" href="ui-out_8c.html#a3d9e2a5710f076cc035ef73920eb8c87">current_uiout</a>;
<a name="l11574"></a>11574   <span class="keyword">struct </span><a class="code" href="structbreakpoint.html">breakpoint</a> *b = bs-&gt;<a class="code" href="structbpstats.html#ac105ed7263dd10f9d65e92e706b04e39">breakpoint_at</a>;
<a name="l11575"></a>11575 
<a name="l11576"></a>11576   <a class="code" href="annotate_8c.html#acb9815704180dd28dd5d5c6af7612a71">annotate_catchpoint</a> (b-&gt;<a class="code" href="structbreakpoint.html#aa46a2ab4a5f2ae1e42412c412997871b">number</a>);
<a name="l11577"></a>11577 
<a name="l11578"></a>11578   <span class="keywordflow">if</span> (<a class="code" href="ui-out_8c.html#a473db54efcfbc60feeb5a4f54f27af46">ui_out_is_mi_like_p</a> (uiout))
<a name="l11579"></a>11579     {
<a name="l11580"></a>11580       <a class="code" href="ui-out_8c.html#a58efe771979c53ca23a30573d06dc291">ui_out_field_string</a> (uiout, <span class="stringliteral">&quot;reason&quot;</span>,
<a name="l11581"></a>11581                            <a class="code" href="mi-common_8c.html#a619e7d180d78af6e6d63a611c6680e90">async_reason_lookup</a> (<a class="code" href="mi-common_8h.html#a06d7bf56f98dcc556d686f49ea570daea20df3a258e30b94df1705d51dff3a180">EXEC_ASYNC_BREAKPOINT_HIT</a>));
<a name="l11582"></a>11582       <a class="code" href="ui-out_8c.html#a58efe771979c53ca23a30573d06dc291">ui_out_field_string</a> (uiout, <span class="stringliteral">&quot;disp&quot;</span>, <a class="code" href="breakpoint_8c.html#a6f45019563f41b3ae4dc92df09f12618">bpdisp_text</a> (b-&gt;<a class="code" href="structbreakpoint.html#a75f0f9a837eac292ab6e768e8d8f1bd7">disposition</a>));
<a name="l11583"></a>11583     }
<a name="l11584"></a>11584 
<a name="l11585"></a>11585   <a class="code" href="ui-out_8c.html#a6a23596295dce32ba2a5bd2fd2d309f8">ui_out_text</a> (uiout,
<a name="l11586"></a>11586                b-&gt;<a class="code" href="structbreakpoint.html#a75f0f9a837eac292ab6e768e8d8f1bd7">disposition</a> == <a class="code" href="breakpoint_8h.html#a15f2bbd9012f59bc09d59feef0c15732a16da7fb4204cb3f58c753fafa80bfab7">disp_del</a> ? <span class="stringliteral">&quot;\nTemporary catchpoint &quot;</span>
<a name="l11587"></a>11587                                           : <span class="stringliteral">&quot;\nCatchpoint &quot;</span>);
<a name="l11588"></a>11588   <a class="code" href="ui-out_8c.html#aa6f66551d03db456fb94ca1c9038f5a0">ui_out_field_int</a> (uiout, <span class="stringliteral">&quot;bkptno&quot;</span>, b-&gt;<a class="code" href="structbreakpoint.html#aa46a2ab4a5f2ae1e42412c412997871b">number</a>);
<a name="l11589"></a>11589   <a class="code" href="ui-out_8c.html#a6a23596295dce32ba2a5bd2fd2d309f8">ui_out_text</a> (uiout, <span class="stringliteral">&quot;, &quot;</span>);
<a name="l11590"></a>11590 
<a name="l11591"></a>11591   <span class="keywordflow">switch</span> (ex)
<a name="l11592"></a>11592     {
<a name="l11593"></a>11593       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>:
<a name="l11594"></a>11594       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>:
<a name="l11595"></a>11595         {
<a name="l11596"></a>11596           <span class="keyword">const</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr = ada_exception_name_addr (ex, b);
<a name="l11597"></a>11597           <span class="keywordtype">char</span> exception_name[256];
<a name="l11598"></a>11598 
<a name="l11599"></a>11599           <span class="keywordflow">if</span> (addr != 0)
<a name="l11600"></a>11600             {
<a name="l11601"></a>11601               <a class="code" href="corefile_8c.html#a5e0189c6f21f1c9321b379877183b819">read_memory</a> (addr, (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *) exception_name,
<a name="l11602"></a>11602                            <span class="keyword">sizeof</span> (exception_name) - 1);
<a name="l11603"></a>11603               exception_name [<span class="keyword">sizeof</span> (exception_name) - 1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l11604"></a>11604             }
<a name="l11605"></a>11605           <span class="keywordflow">else</span>
<a name="l11606"></a>11606             {
<a name="l11607"></a>11607               <span class="comment">/* For some reason, we were unable to read the exception</span>
<a name="l11608"></a>11608 <span class="comment">                 name.  This could happen if the Runtime was compiled</span>
<a name="l11609"></a>11609 <span class="comment">                 without debugging info, for instance.  In that case,</span>
<a name="l11610"></a>11610 <span class="comment">                 just replace the exception name by the generic string</span>
<a name="l11611"></a>11611 <span class="comment">                 &quot;exception&quot; - it will read as &quot;an exception&quot; in the</span>
<a name="l11612"></a>11612 <span class="comment">                 notification we are about to print.  */</span>
<a name="l11613"></a>11613               <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (exception_name, <span class="stringliteral">&quot;exception&quot;</span>, <span class="keyword">sizeof</span> (<span class="stringliteral">&quot;exception&quot;</span>));
<a name="l11614"></a>11614             }
<a name="l11615"></a>11615           <span class="comment">/* In the case of unhandled exception breakpoints, we print</span>
<a name="l11616"></a>11616 <span class="comment">             the exception name as &quot;unhandled EXCEPTION_NAME&quot;, to make</span>
<a name="l11617"></a>11617 <span class="comment">             it clearer to the user which kind of catchpoint just got</span>
<a name="l11618"></a>11618 <span class="comment">             hit.  We used ui_out_text to make sure that this extra</span>
<a name="l11619"></a>11619 <span class="comment">             info does not pollute the exception name in the MI case.  */</span>
<a name="l11620"></a>11620           <span class="keywordflow">if</span> (ex == <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>)
<a name="l11621"></a>11621             <a class="code" href="ui-out_8c.html#a6a23596295dce32ba2a5bd2fd2d309f8">ui_out_text</a> (uiout, <span class="stringliteral">&quot;unhandled &quot;</span>);
<a name="l11622"></a>11622           <a class="code" href="ui-out_8c.html#a58efe771979c53ca23a30573d06dc291">ui_out_field_string</a> (uiout, <span class="stringliteral">&quot;exception-name&quot;</span>, exception_name);
<a name="l11623"></a>11623         }
<a name="l11624"></a>11624         <span class="keywordflow">break</span>;
<a name="l11625"></a>11625       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>:
<a name="l11626"></a>11626         <span class="comment">/* In this case, the name of the exception is not really</span>
<a name="l11627"></a>11627 <span class="comment">           important.  Just print &quot;failed assertion&quot; to make it clearer</span>
<a name="l11628"></a>11628 <span class="comment">           that his program just hit an assertion-failure catchpoint.</span>
<a name="l11629"></a>11629 <span class="comment">           We used ui_out_text because this info does not belong in</span>
<a name="l11630"></a>11630 <span class="comment">           the MI output.  */</span>
<a name="l11631"></a>11631         <a class="code" href="ui-out_8c.html#a6a23596295dce32ba2a5bd2fd2d309f8">ui_out_text</a> (uiout, <span class="stringliteral">&quot;failed assertion&quot;</span>);
<a name="l11632"></a>11632         <span class="keywordflow">break</span>;
<a name="l11633"></a>11633     }
<a name="l11634"></a>11634   <a class="code" href="ui-out_8c.html#a6a23596295dce32ba2a5bd2fd2d309f8">ui_out_text</a> (uiout, <span class="stringliteral">&quot; at &quot;</span>);
<a name="l11635"></a>11635   <a class="code" href="ada-lang_8c.html#a913f0d21ae3a48d97b313e4846ce3cf0">ada_find_printable_frame</a> (<a class="code" href="frame_8c.html#a5ab254510728049878a232ed1b889820">get_current_frame</a> ());
<a name="l11636"></a>11636 
<a name="l11637"></a>11637   <span class="keywordflow">return</span> <a class="code" href="breakpoint_8h.html#ab6ab1d6a867561653e32a901b41be66ba322bad7b3370a43f44f33ae73a196231">PRINT_SRC_AND_LOC</a>;
<a name="l11638"></a>11638 }
<a name="l11639"></a>11639 
<a name="l11640"></a>11640 <span class="comment">/* Implement the PRINT_ONE method in the breakpoint_ops structure</span>
<a name="l11641"></a>11641 <span class="comment">   for all exception catchpoint kinds.  */</span>
<a name="l11642"></a>11642 
<a name="l11643"></a>11643 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11644"></a>11644 print_one_exception (<span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex,
<a name="l11645"></a>11645                      <span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b, <span class="keyword">struct</span> <a class="code" href="structbp__location.html">bp_location</a> **last_loc)
<a name="l11646"></a>11646 { 
<a name="l11647"></a>11647   <span class="keyword">struct </span>ui_out *uiout = <a class="code" href="ui-out_8c.html#a3d9e2a5710f076cc035ef73920eb8c87">current_uiout</a>;
<a name="l11648"></a>11648   <span class="keyword">struct </span>ada_catchpoint *c = (<span class="keyword">struct </span>ada_catchpoint *) b;
<a name="l11649"></a>11649   <span class="keyword">struct </span><a class="code" href="structvalue__print__options.html">value_print_options</a> opts;
<a name="l11650"></a>11650 
<a name="l11651"></a>11651   <a class="code" href="valprint_8c.html#aa2d4dfe4b11841ccafc4d0c0d410095d">get_user_print_options</a> (&amp;opts);
<a name="l11652"></a>11652   <span class="keywordflow">if</span> (opts.addressprint)
<a name="l11653"></a>11653     {
<a name="l11654"></a>11654       <a class="code" href="annotate_8c.html#a3b961efbc346558aade25e12945835fe">annotate_field</a> (4);
<a name="l11655"></a>11655       <a class="code" href="ui-out_8c.html#ada85ed653fecf3c2a80027de6f71ef71">ui_out_field_core_addr</a> (uiout, <span class="stringliteral">&quot;addr&quot;</span>, b-&gt;<a class="code" href="structbreakpoint.html#aa869260f7e4c94204275861d820bb1a9">loc</a>-&gt;<a class="code" href="structbp__location.html#a55f3ff99d536775f5095f11e5f5c3f3e">gdbarch</a>, b-&gt;<a class="code" href="structbreakpoint.html#aa869260f7e4c94204275861d820bb1a9">loc</a>-&gt;<a class="code" href="structbp__location.html#a6b6cd8b8a488e632200f323309d23823">address</a>);
<a name="l11656"></a>11656     }
<a name="l11657"></a>11657 
<a name="l11658"></a>11658   <a class="code" href="annotate_8c.html#a3b961efbc346558aade25e12945835fe">annotate_field</a> (5);
<a name="l11659"></a>11659   *last_loc = b-&gt;<a class="code" href="structbreakpoint.html#aa869260f7e4c94204275861d820bb1a9">loc</a>;
<a name="l11660"></a>11660   <span class="keywordflow">switch</span> (ex)
<a name="l11661"></a>11661     {
<a name="l11662"></a>11662       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>:
<a name="l11663"></a>11663         <span class="keywordflow">if</span> (c-&gt;excep_string != NULL)
<a name="l11664"></a>11664           {
<a name="l11665"></a>11665             <span class="keywordtype">char</span> *msg = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;`%s&#39; Ada exception&quot;</span>), c-&gt;excep_string);
<a name="l11666"></a>11666 
<a name="l11667"></a>11667             <a class="code" href="ui-out_8c.html#a58efe771979c53ca23a30573d06dc291">ui_out_field_string</a> (uiout, <span class="stringliteral">&quot;what&quot;</span>, msg);
<a name="l11668"></a>11668             <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (msg);
<a name="l11669"></a>11669           }
<a name="l11670"></a>11670         <span class="keywordflow">else</span>
<a name="l11671"></a>11671           <a class="code" href="ui-out_8c.html#a58efe771979c53ca23a30573d06dc291">ui_out_field_string</a> (uiout, <span class="stringliteral">&quot;what&quot;</span>, <span class="stringliteral">&quot;all Ada exceptions&quot;</span>);
<a name="l11672"></a>11672         
<a name="l11673"></a>11673         <span class="keywordflow">break</span>;
<a name="l11674"></a>11674 
<a name="l11675"></a>11675       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>:
<a name="l11676"></a>11676         <a class="code" href="ui-out_8c.html#a58efe771979c53ca23a30573d06dc291">ui_out_field_string</a> (uiout, <span class="stringliteral">&quot;what&quot;</span>, <span class="stringliteral">&quot;unhandled Ada exceptions&quot;</span>);
<a name="l11677"></a>11677         <span class="keywordflow">break</span>;
<a name="l11678"></a>11678       
<a name="l11679"></a>11679       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>:
<a name="l11680"></a>11680         <a class="code" href="ui-out_8c.html#a58efe771979c53ca23a30573d06dc291">ui_out_field_string</a> (uiout, <span class="stringliteral">&quot;what&quot;</span>, <span class="stringliteral">&quot;failed Ada assertions&quot;</span>);
<a name="l11681"></a>11681         <span class="keywordflow">break</span>;
<a name="l11682"></a>11682 
<a name="l11683"></a>11683       <span class="keywordflow">default</span>:
<a name="l11684"></a>11684         <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unexpected catchpoint type&quot;</span>));
<a name="l11685"></a>11685         <span class="keywordflow">break</span>;
<a name="l11686"></a>11686     }
<a name="l11687"></a>11687 }
<a name="l11688"></a>11688 
<a name="l11689"></a>11689 <span class="comment">/* Implement the PRINT_MENTION method in the breakpoint_ops structure</span>
<a name="l11690"></a>11690 <span class="comment">   for all exception catchpoint kinds.  */</span>
<a name="l11691"></a>11691 
<a name="l11692"></a>11692 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11693"></a>11693 print_mention_exception (<span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex,
<a name="l11694"></a>11694                          <span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l11695"></a>11695 {
<a name="l11696"></a>11696   <span class="keyword">struct </span>ada_catchpoint *c = (<span class="keyword">struct </span>ada_catchpoint *) b;
<a name="l11697"></a>11697   <span class="keyword">struct </span>ui_out *uiout = <a class="code" href="ui-out_8c.html#a3d9e2a5710f076cc035ef73920eb8c87">current_uiout</a>;
<a name="l11698"></a>11698 
<a name="l11699"></a>11699   <a class="code" href="ui-out_8c.html#a6a23596295dce32ba2a5bd2fd2d309f8">ui_out_text</a> (uiout, b-&gt;<a class="code" href="structbreakpoint.html#a75f0f9a837eac292ab6e768e8d8f1bd7">disposition</a> == <a class="code" href="breakpoint_8h.html#a15f2bbd9012f59bc09d59feef0c15732a16da7fb4204cb3f58c753fafa80bfab7">disp_del</a> ? <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Temporary catchpoint &quot;</span>)
<a name="l11700"></a>11700                                                  : <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Catchpoint &quot;</span>));
<a name="l11701"></a>11701   <a class="code" href="ui-out_8c.html#aa6f66551d03db456fb94ca1c9038f5a0">ui_out_field_int</a> (uiout, <span class="stringliteral">&quot;bkptno&quot;</span>, b-&gt;<a class="code" href="structbreakpoint.html#aa46a2ab4a5f2ae1e42412c412997871b">number</a>);
<a name="l11702"></a>11702   <a class="code" href="ui-out_8c.html#a6a23596295dce32ba2a5bd2fd2d309f8">ui_out_text</a> (uiout, <span class="stringliteral">&quot;: &quot;</span>);
<a name="l11703"></a>11703 
<a name="l11704"></a>11704   <span class="keywordflow">switch</span> (ex)
<a name="l11705"></a>11705     {
<a name="l11706"></a>11706       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>:
<a name="l11707"></a>11707         <span class="keywordflow">if</span> (c-&gt;excep_string != NULL)
<a name="l11708"></a>11708           {
<a name="l11709"></a>11709             <span class="keywordtype">char</span> *info = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;`%s&#39; Ada exception&quot;</span>), c-&gt;excep_string);
<a name="l11710"></a>11710             <span class="keyword">struct </span>cleanup *old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, info);
<a name="l11711"></a>11711 
<a name="l11712"></a>11712             <a class="code" href="ui-out_8c.html#a6a23596295dce32ba2a5bd2fd2d309f8">ui_out_text</a> (uiout, info);
<a name="l11713"></a>11713             <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_chain);
<a name="l11714"></a>11714           }
<a name="l11715"></a>11715         <span class="keywordflow">else</span>
<a name="l11716"></a>11716           <a class="code" href="ui-out_8c.html#a6a23596295dce32ba2a5bd2fd2d309f8">ui_out_text</a> (uiout, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;all Ada exceptions&quot;</span>));
<a name="l11717"></a>11717         <span class="keywordflow">break</span>;
<a name="l11718"></a>11718 
<a name="l11719"></a>11719       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>:
<a name="l11720"></a>11720         <a class="code" href="ui-out_8c.html#a6a23596295dce32ba2a5bd2fd2d309f8">ui_out_text</a> (uiout, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unhandled Ada exceptions&quot;</span>));
<a name="l11721"></a>11721         <span class="keywordflow">break</span>;
<a name="l11722"></a>11722       
<a name="l11723"></a>11723       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>:
<a name="l11724"></a>11724         <a class="code" href="ui-out_8c.html#a6a23596295dce32ba2a5bd2fd2d309f8">ui_out_text</a> (uiout, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;failed Ada assertions&quot;</span>));
<a name="l11725"></a>11725         <span class="keywordflow">break</span>;
<a name="l11726"></a>11726 
<a name="l11727"></a>11727       <span class="keywordflow">default</span>:
<a name="l11728"></a>11728         <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unexpected catchpoint type&quot;</span>));
<a name="l11729"></a>11729         <span class="keywordflow">break</span>;
<a name="l11730"></a>11730     }
<a name="l11731"></a>11731 }
<a name="l11732"></a>11732 
<a name="l11733"></a>11733 <span class="comment">/* Implement the PRINT_RECREATE method in the breakpoint_ops structure</span>
<a name="l11734"></a>11734 <span class="comment">   for all exception catchpoint kinds.  */</span>
<a name="l11735"></a>11735 
<a name="l11736"></a>11736 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11737"></a>11737 print_recreate_exception (<span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex,
<a name="l11738"></a>11738                           <span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b, <span class="keyword">struct</span> ui_file *fp)
<a name="l11739"></a>11739 {
<a name="l11740"></a>11740   <span class="keyword">struct </span>ada_catchpoint *c = (<span class="keyword">struct </span>ada_catchpoint *) b;
<a name="l11741"></a>11741 
<a name="l11742"></a>11742   <span class="keywordflow">switch</span> (ex)
<a name="l11743"></a>11743     {
<a name="l11744"></a>11744       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>:
<a name="l11745"></a>11745         <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (fp, <span class="stringliteral">&quot;catch exception&quot;</span>);
<a name="l11746"></a>11746         <span class="keywordflow">if</span> (c-&gt;excep_string != NULL)
<a name="l11747"></a>11747           <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (fp, <span class="stringliteral">&quot; %s&quot;</span>, c-&gt;excep_string);
<a name="l11748"></a>11748         <span class="keywordflow">break</span>;
<a name="l11749"></a>11749 
<a name="l11750"></a>11750       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>:
<a name="l11751"></a>11751         <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (fp, <span class="stringliteral">&quot;catch exception unhandled&quot;</span>);
<a name="l11752"></a>11752         <span class="keywordflow">break</span>;
<a name="l11753"></a>11753 
<a name="l11754"></a>11754       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>:
<a name="l11755"></a>11755         <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (fp, <span class="stringliteral">&quot;catch assert&quot;</span>);
<a name="l11756"></a>11756         <span class="keywordflow">break</span>;
<a name="l11757"></a>11757 
<a name="l11758"></a>11758       <span class="keywordflow">default</span>:
<a name="l11759"></a>11759         <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unexpected catchpoint type&quot;</span>));
<a name="l11760"></a>11760     }
<a name="l11761"></a>11761   <a class="code" href="breakpoint_8c.html#aae7cd38b01782db6011bcd0150059625">print_recreate_thread</a> (b, fp);
<a name="l11762"></a>11762 }
<a name="l11763"></a>11763 
<a name="l11764"></a>11764 <span class="comment">/* Virtual table for &quot;catch exception&quot; breakpoints.  */</span>
<a name="l11765"></a>11765 
<a name="l11766"></a>11766 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11767"></a>11767 dtor_catch_exception (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l11768"></a>11768 {
<a name="l11769"></a>11769   dtor_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>, b);
<a name="l11770"></a>11770 }
<a name="l11771"></a>11771 
<a name="l11772"></a>11772 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structbp__location.html">bp_location</a> *
<a name="l11773"></a>11773 allocate_location_catch_exception (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *<span class="keyword">self</span>)
<a name="l11774"></a>11774 {
<a name="l11775"></a>11775   <span class="keywordflow">return</span> allocate_location_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>, <span class="keyword">self</span>);
<a name="l11776"></a>11776 }
<a name="l11777"></a>11777 
<a name="l11778"></a>11778 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11779"></a>11779 re_set_catch_exception (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l11780"></a>11780 {
<a name="l11781"></a>11781   re_set_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>, b);
<a name="l11782"></a>11782 }
<a name="l11783"></a>11783 
<a name="l11784"></a>11784 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11785"></a>11785 check_status_catch_exception (<a class="code" href="structbpstats.html">bpstat</a> bs)
<a name="l11786"></a>11786 {
<a name="l11787"></a>11787   check_status_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>, bs);
<a name="l11788"></a>11788 }
<a name="l11789"></a>11789 
<a name="l11790"></a>11790 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="breakpoint_8h.html#ab6ab1d6a867561653e32a901b41be66b">print_stop_action</a>
<a name="l11791"></a>11791 print_it_catch_exception (<a class="code" href="structbpstats.html">bpstat</a> bs)
<a name="l11792"></a>11792 {
<a name="l11793"></a>11793   <span class="keywordflow">return</span> print_it_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>, bs);
<a name="l11794"></a>11794 }
<a name="l11795"></a>11795 
<a name="l11796"></a>11796 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11797"></a>11797 print_one_catch_exception (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b, <span class="keyword">struct</span> <a class="code" href="structbp__location.html">bp_location</a> **last_loc)
<a name="l11798"></a>11798 {
<a name="l11799"></a>11799   print_one_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>, b, last_loc);
<a name="l11800"></a>11800 }
<a name="l11801"></a>11801 
<a name="l11802"></a>11802 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11803"></a>11803 print_mention_catch_exception (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l11804"></a>11804 {
<a name="l11805"></a>11805   print_mention_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>, b);
<a name="l11806"></a>11806 }
<a name="l11807"></a>11807 
<a name="l11808"></a>11808 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11809"></a>11809 print_recreate_catch_exception (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b, <span class="keyword">struct</span> ui_file *fp)
<a name="l11810"></a>11810 {
<a name="l11811"></a>11811   print_recreate_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>, b, fp);
<a name="l11812"></a>11812 }
<a name="l11813"></a>11813 
<a name="l11814"></a>11814 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structbreakpoint__ops.html">breakpoint_ops</a> catch_exception_breakpoint_ops;
<a name="l11815"></a>11815 
<a name="l11816"></a>11816 <span class="comment">/* Virtual table for &quot;catch exception unhandled&quot; breakpoints.  */</span>
<a name="l11817"></a>11817 
<a name="l11818"></a>11818 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11819"></a>11819 dtor_catch_exception_unhandled (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l11820"></a>11820 {
<a name="l11821"></a>11821   dtor_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>, b);
<a name="l11822"></a>11822 }
<a name="l11823"></a>11823 
<a name="l11824"></a>11824 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structbp__location.html">bp_location</a> *
<a name="l11825"></a>11825 allocate_location_catch_exception_unhandled (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *<span class="keyword">self</span>)
<a name="l11826"></a>11826 {
<a name="l11827"></a>11827   <span class="keywordflow">return</span> allocate_location_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>, <span class="keyword">self</span>);
<a name="l11828"></a>11828 }
<a name="l11829"></a>11829 
<a name="l11830"></a>11830 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11831"></a>11831 re_set_catch_exception_unhandled (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l11832"></a>11832 {
<a name="l11833"></a>11833   re_set_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>, b);
<a name="l11834"></a>11834 }
<a name="l11835"></a>11835 
<a name="l11836"></a>11836 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11837"></a>11837 check_status_catch_exception_unhandled (<a class="code" href="structbpstats.html">bpstat</a> bs)
<a name="l11838"></a>11838 {
<a name="l11839"></a>11839   check_status_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>, bs);
<a name="l11840"></a>11840 }
<a name="l11841"></a>11841 
<a name="l11842"></a>11842 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="breakpoint_8h.html#ab6ab1d6a867561653e32a901b41be66b">print_stop_action</a>
<a name="l11843"></a>11843 print_it_catch_exception_unhandled (<a class="code" href="structbpstats.html">bpstat</a> bs)
<a name="l11844"></a>11844 {
<a name="l11845"></a>11845   <span class="keywordflow">return</span> print_it_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>, bs);
<a name="l11846"></a>11846 }
<a name="l11847"></a>11847 
<a name="l11848"></a>11848 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11849"></a>11849 print_one_catch_exception_unhandled (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b,
<a name="l11850"></a>11850                                      <span class="keyword">struct</span> <a class="code" href="structbp__location.html">bp_location</a> **last_loc)
<a name="l11851"></a>11851 {
<a name="l11852"></a>11852   print_one_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>, b, last_loc);
<a name="l11853"></a>11853 }
<a name="l11854"></a>11854 
<a name="l11855"></a>11855 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11856"></a>11856 print_mention_catch_exception_unhandled (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l11857"></a>11857 {
<a name="l11858"></a>11858   print_mention_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>, b);
<a name="l11859"></a>11859 }
<a name="l11860"></a>11860 
<a name="l11861"></a>11861 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11862"></a>11862 print_recreate_catch_exception_unhandled (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b,
<a name="l11863"></a>11863                                           <span class="keyword">struct</span> ui_file *fp)
<a name="l11864"></a>11864 {
<a name="l11865"></a>11865   print_recreate_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>, b, fp);
<a name="l11866"></a>11866 }
<a name="l11867"></a>11867 
<a name="l11868"></a>11868 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structbreakpoint__ops.html">breakpoint_ops</a> catch_exception_unhandled_breakpoint_ops;
<a name="l11869"></a>11869 
<a name="l11870"></a>11870 <span class="comment">/* Virtual table for &quot;catch assert&quot; breakpoints.  */</span>
<a name="l11871"></a>11871 
<a name="l11872"></a>11872 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11873"></a>11873 dtor_catch_assert (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l11874"></a>11874 {
<a name="l11875"></a>11875   dtor_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>, b);
<a name="l11876"></a>11876 }
<a name="l11877"></a>11877 
<a name="l11878"></a>11878 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structbp__location.html">bp_location</a> *
<a name="l11879"></a>11879 allocate_location_catch_assert (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *<span class="keyword">self</span>)
<a name="l11880"></a>11880 {
<a name="l11881"></a>11881   <span class="keywordflow">return</span> allocate_location_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>, <span class="keyword">self</span>);
<a name="l11882"></a>11882 }
<a name="l11883"></a>11883 
<a name="l11884"></a>11884 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11885"></a>11885 re_set_catch_assert (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l11886"></a>11886 {
<a name="l11887"></a>11887   re_set_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>, b);
<a name="l11888"></a>11888 }
<a name="l11889"></a>11889 
<a name="l11890"></a>11890 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11891"></a>11891 check_status_catch_assert (<a class="code" href="structbpstats.html">bpstat</a> bs)
<a name="l11892"></a>11892 {
<a name="l11893"></a>11893   check_status_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>, bs);
<a name="l11894"></a>11894 }
<a name="l11895"></a>11895 
<a name="l11896"></a>11896 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="breakpoint_8h.html#ab6ab1d6a867561653e32a901b41be66b">print_stop_action</a>
<a name="l11897"></a>11897 print_it_catch_assert (<a class="code" href="structbpstats.html">bpstat</a> bs)
<a name="l11898"></a>11898 {
<a name="l11899"></a>11899   <span class="keywordflow">return</span> print_it_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>, bs);
<a name="l11900"></a>11900 }
<a name="l11901"></a>11901 
<a name="l11902"></a>11902 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11903"></a>11903 print_one_catch_assert (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b, <span class="keyword">struct</span> <a class="code" href="structbp__location.html">bp_location</a> **last_loc)
<a name="l11904"></a>11904 {
<a name="l11905"></a>11905   print_one_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>, b, last_loc);
<a name="l11906"></a>11906 }
<a name="l11907"></a>11907 
<a name="l11908"></a>11908 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11909"></a>11909 print_mention_catch_assert (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l11910"></a>11910 {
<a name="l11911"></a>11911   print_mention_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>, b);
<a name="l11912"></a>11912 }
<a name="l11913"></a>11913 
<a name="l11914"></a>11914 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11915"></a>11915 print_recreate_catch_assert (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b, <span class="keyword">struct</span> ui_file *fp)
<a name="l11916"></a>11916 {
<a name="l11917"></a>11917   print_recreate_exception (<a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>, b, fp);
<a name="l11918"></a>11918 }
<a name="l11919"></a>11919 
<a name="l11920"></a>11920 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structbreakpoint__ops.html">breakpoint_ops</a> catch_assert_breakpoint_ops;
<a name="l11921"></a>11921 
<a name="l11922"></a>11922 <span class="comment">/* Return a newly allocated copy of the first space-separated token</span>
<a name="l11923"></a>11923 <span class="comment">   in ARGSP, and then adjust ARGSP to point immediately after that</span>
<a name="l11924"></a>11924 <span class="comment">   token.</span>
<a name="l11925"></a>11925 <span class="comment"></span>
<a name="l11926"></a>11926 <span class="comment">   Return NULL if ARGPS does not contain any more tokens.  */</span>
<a name="l11927"></a>11927 
<a name="l11928"></a>11928 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l11929"></a>11929 ada_get_next_arg (<span class="keywordtype">char</span> **argsp)
<a name="l11930"></a>11930 {
<a name="l11931"></a>11931   <span class="keywordtype">char</span> *args = *argsp;
<a name="l11932"></a>11932   <span class="keywordtype">char</span> *end;
<a name="l11933"></a>11933   <span class="keywordtype">char</span> *result;
<a name="l11934"></a>11934 
<a name="l11935"></a>11935   args = <a class="code" href="cli-utils_8c.html#afa70bcaee54d487b4412d2a7a5a0c8fa">skip_spaces</a> (args);
<a name="l11936"></a>11936   <span class="keywordflow">if</span> (args[0] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l11937"></a>11937     <span class="keywordflow">return</span> NULL; <span class="comment">/* No more arguments.  */</span>
<a name="l11938"></a>11938   
<a name="l11939"></a>11939   <span class="comment">/* Find the end of the current argument.  */</span>
<a name="l11940"></a>11940 
<a name="l11941"></a>11941   end = <a class="code" href="cli-utils_8h.html#a72436dcbbbe357dbd26e02588a6d3808">skip_to_space</a> (args);
<a name="l11942"></a>11942 
<a name="l11943"></a>11943   <span class="comment">/* Adjust ARGSP to point to the start of the next argument.  */</span>
<a name="l11944"></a>11944 
<a name="l11945"></a>11945   *argsp = end;
<a name="l11946"></a>11946 
<a name="l11947"></a>11947   <span class="comment">/* Make a copy of the current argument and return it.  */</span>
<a name="l11948"></a>11948 
<a name="l11949"></a>11949   result = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (end - args + 1);
<a name="l11950"></a>11950   strncpy (result, args, end - args);
<a name="l11951"></a>11951   result[end - args] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l11952"></a>11952   
<a name="l11953"></a>11953   <span class="keywordflow">return</span> result;
<a name="l11954"></a>11954 }
<a name="l11955"></a>11955 
<a name="l11956"></a>11956 <span class="comment">/* Split the arguments specified in a &quot;catch exception&quot; command.  </span>
<a name="l11957"></a>11957 <span class="comment">   Set EX to the appropriate catchpoint type.</span>
<a name="l11958"></a>11958 <span class="comment">   Set EXCEP_STRING to the name of the specific exception if</span>
<a name="l11959"></a>11959 <span class="comment">   specified by the user.</span>
<a name="l11960"></a>11960 <span class="comment">   If a condition is found at the end of the arguments, the condition</span>
<a name="l11961"></a>11961 <span class="comment">   expression is stored in COND_STRING (memory must be deallocated</span>
<a name="l11962"></a>11962 <span class="comment">   after use).  Otherwise COND_STRING is set to NULL.  */</span>
<a name="l11963"></a>11963 
<a name="l11964"></a>11964 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l11965"></a>11965 catch_ada_exception_command_split (<span class="keywordtype">char</span> *args,
<a name="l11966"></a>11966                                    <span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> *ex,
<a name="l11967"></a>11967                                    <span class="keywordtype">char</span> **excep_string,
<a name="l11968"></a>11968                                    <span class="keywordtype">char</span> **cond_string)
<a name="l11969"></a>11969 {
<a name="l11970"></a>11970   <span class="keyword">struct </span>cleanup *old_chain = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="cleanups_8c.html#a1ec2a3980c2be1f31f2142103d1f7abf">null_cleanup</a>, NULL);
<a name="l11971"></a>11971   <span class="keywordtype">char</span> *exception_name;
<a name="l11972"></a>11972   <span class="keywordtype">char</span> *cond = NULL;
<a name="l11973"></a>11973 
<a name="l11974"></a>11974   exception_name = ada_get_next_arg (&amp;args);
<a name="l11975"></a>11975   <span class="keywordflow">if</span> (exception_name != NULL &amp;&amp; strcmp (exception_name, <span class="stringliteral">&quot;if&quot;</span>) == 0)
<a name="l11976"></a>11976     {
<a name="l11977"></a>11977       <span class="comment">/* This is not an exception name; this is the start of a condition</span>
<a name="l11978"></a>11978 <span class="comment">         expression for a catchpoint on all exceptions.  So, &quot;un-get&quot;</span>
<a name="l11979"></a>11979 <span class="comment">         this token, and set exception_name to NULL.  */</span>
<a name="l11980"></a>11980       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (exception_name);
<a name="l11981"></a>11981       exception_name = NULL;
<a name="l11982"></a>11982       args -= 2;
<a name="l11983"></a>11983     }
<a name="l11984"></a>11984   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, exception_name);
<a name="l11985"></a>11985 
<a name="l11986"></a>11986   <span class="comment">/* Check to see if we have a condition.  */</span>
<a name="l11987"></a>11987 
<a name="l11988"></a>11988   args = <a class="code" href="cli-utils_8c.html#afa70bcaee54d487b4412d2a7a5a0c8fa">skip_spaces</a> (args);
<a name="l11989"></a>11989   <span class="keywordflow">if</span> (strncmp (args, <span class="stringliteral">&quot;if&quot;</span>, 2) == 0
<a name="l11990"></a>11990       &amp;&amp; (isspace (args[2]) || args[2] == <span class="charliteral">&#39;\0&#39;</span>))
<a name="l11991"></a>11991     {
<a name="l11992"></a>11992       args += 2;
<a name="l11993"></a>11993       args = <a class="code" href="cli-utils_8c.html#afa70bcaee54d487b4412d2a7a5a0c8fa">skip_spaces</a> (args);
<a name="l11994"></a>11994 
<a name="l11995"></a>11995       <span class="keywordflow">if</span> (args[0] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l11996"></a>11996         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Condition missing after `if&#39; keyword&quot;</span>));
<a name="l11997"></a>11997       cond = xstrdup (args);
<a name="l11998"></a>11998       <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, cond);
<a name="l11999"></a>11999 
<a name="l12000"></a>12000       args += strlen (args);
<a name="l12001"></a>12001     }
<a name="l12002"></a>12002 
<a name="l12003"></a>12003   <span class="comment">/* Check that we do not have any more arguments.  Anything else</span>
<a name="l12004"></a>12004 <span class="comment">     is unexpected.  */</span>
<a name="l12005"></a>12005 
<a name="l12006"></a>12006   <span class="keywordflow">if</span> (args[0] != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l12007"></a>12007     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Junk at end of expression&quot;</span>));
<a name="l12008"></a>12008 
<a name="l12009"></a>12009   <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (old_chain);
<a name="l12010"></a>12010 
<a name="l12011"></a>12011   <span class="keywordflow">if</span> (exception_name == NULL)
<a name="l12012"></a>12012     {
<a name="l12013"></a>12013       <span class="comment">/* Catch all exceptions.  */</span>
<a name="l12014"></a>12014       *ex = <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>;
<a name="l12015"></a>12015       *excep_string = NULL;
<a name="l12016"></a>12016     }
<a name="l12017"></a>12017   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp (exception_name, <span class="stringliteral">&quot;unhandled&quot;</span>) == 0)
<a name="l12018"></a>12018     {
<a name="l12019"></a>12019       <span class="comment">/* Catch unhandled exceptions.  */</span>
<a name="l12020"></a>12020       *ex = <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>;
<a name="l12021"></a>12021       *excep_string = NULL;
<a name="l12022"></a>12022     }
<a name="l12023"></a>12023   <span class="keywordflow">else</span>
<a name="l12024"></a>12024     {
<a name="l12025"></a>12025       <span class="comment">/* Catch a specific exception.  */</span>
<a name="l12026"></a>12026       *ex = <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>;
<a name="l12027"></a>12027       *excep_string = exception_name;
<a name="l12028"></a>12028     }
<a name="l12029"></a>12029   *cond_string = cond;
<a name="l12030"></a>12030 }
<a name="l12031"></a>12031 
<a name="l12032"></a>12032 <span class="comment">/* Return the name of the symbol on which we should break in order to</span>
<a name="l12033"></a>12033 <span class="comment">   implement a catchpoint of the EX kind.  */</span>
<a name="l12034"></a>12034 
<a name="l12035"></a>12035 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l12036"></a>12036 ada_exception_sym_name (<span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex)
<a name="l12037"></a>12037 {
<a name="l12038"></a>12038   <span class="keyword">struct </span>ada_inferior_data *data = get_ada_inferior_data (<a class="code" href="inferior_8c.html#a9e592c83e7c0c1f89f1a4a392bd1a277">current_inferior</a> ());
<a name="l12039"></a>12039 
<a name="l12040"></a>12040   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (data-&gt;exception_info != NULL);
<a name="l12041"></a>12041 
<a name="l12042"></a>12042   <span class="keywordflow">switch</span> (ex)
<a name="l12043"></a>12043     {
<a name="l12044"></a>12044       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>:
<a name="l12045"></a>12045         <span class="keywordflow">return</span> (data-&gt;exception_info-&gt;catch_exception_sym);
<a name="l12046"></a>12046         <span class="keywordflow">break</span>;
<a name="l12047"></a>12047       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>:
<a name="l12048"></a>12048         <span class="keywordflow">return</span> (data-&gt;exception_info-&gt;catch_exception_unhandled_sym);
<a name="l12049"></a>12049         <span class="keywordflow">break</span>;
<a name="l12050"></a>12050       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>:
<a name="l12051"></a>12051         <span class="keywordflow">return</span> (data-&gt;exception_info-&gt;catch_assert_sym);
<a name="l12052"></a>12052         <span class="keywordflow">break</span>;
<a name="l12053"></a>12053       <span class="keywordflow">default</span>:
<a name="l12054"></a>12054         <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l12055"></a>12055                         <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unexpected catchpoint kind (%d)&quot;</span>), ex);
<a name="l12056"></a>12056     }
<a name="l12057"></a>12057 }
<a name="l12058"></a>12058 
<a name="l12059"></a>12059 <span class="comment">/* Return the breakpoint ops &quot;virtual table&quot; used for catchpoints</span>
<a name="l12060"></a>12060 <span class="comment">   of the EX kind.  */</span>
<a name="l12061"></a>12061 
<a name="l12062"></a>12062 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structbreakpoint__ops.html">breakpoint_ops</a> *
<a name="l12063"></a>12063 ada_exception_breakpoint_ops (<span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex)
<a name="l12064"></a>12064 {
<a name="l12065"></a>12065   <span class="keywordflow">switch</span> (ex)
<a name="l12066"></a>12066     {
<a name="l12067"></a>12067       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a3e96adf13b857d03bd89503b6b6e3c4b">ada_catch_exception</a>:
<a name="l12068"></a>12068         <span class="keywordflow">return</span> (&amp;catch_exception_breakpoint_ops);
<a name="l12069"></a>12069         <span class="keywordflow">break</span>;
<a name="l12070"></a>12070       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714a997fb32306029c45aa1409bce8541226">ada_catch_exception_unhandled</a>:
<a name="l12071"></a>12071         <span class="keywordflow">return</span> (&amp;catch_exception_unhandled_breakpoint_ops);
<a name="l12072"></a>12072         <span class="keywordflow">break</span>;
<a name="l12073"></a>12073       <span class="keywordflow">case</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>:
<a name="l12074"></a>12074         <span class="keywordflow">return</span> (&amp;catch_assert_breakpoint_ops);
<a name="l12075"></a>12075         <span class="keywordflow">break</span>;
<a name="l12076"></a>12076       <span class="keywordflow">default</span>:
<a name="l12077"></a>12077         <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l12078"></a>12078                         <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unexpected catchpoint kind (%d)&quot;</span>), ex);
<a name="l12079"></a>12079     }
<a name="l12080"></a>12080 }
<a name="l12081"></a>12081 
<a name="l12082"></a>12082 <span class="comment">/* Return the condition that will be used to match the current exception</span>
<a name="l12083"></a>12083 <span class="comment">   being raised with the exception that the user wants to catch.  This</span>
<a name="l12084"></a>12084 <span class="comment">   assumes that this condition is used when the inferior just triggered</span>
<a name="l12085"></a>12085 <span class="comment">   an exception catchpoint.</span>
<a name="l12086"></a>12086 <span class="comment">   </span>
<a name="l12087"></a>12087 <span class="comment">   The string returned is a newly allocated string that needs to be</span>
<a name="l12088"></a>12088 <span class="comment">   deallocated later.  */</span>
<a name="l12089"></a>12089 
<a name="l12090"></a>12090 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l12091"></a>12091 ada_exception_catchpoint_cond_string (<span class="keyword">const</span> <span class="keywordtype">char</span> *excep_string)
<a name="l12092"></a>12092 {
<a name="l12093"></a>12093   <span class="keywordtype">int</span> i;
<a name="l12094"></a>12094 
<a name="l12095"></a>12095   <span class="comment">/* The standard exceptions are a special case.  They are defined in</span>
<a name="l12096"></a>12096 <span class="comment">     runtime units that have been compiled without debugging info; if</span>
<a name="l12097"></a>12097 <span class="comment">     EXCEP_STRING is the not-fully-qualified name of a standard</span>
<a name="l12098"></a>12098 <span class="comment">     exception (e.g. &quot;constraint_error&quot;) then, during the evaluation</span>
<a name="l12099"></a>12099 <span class="comment">     of the condition expression, the symbol lookup on this name would</span>
<a name="l12100"></a>12100 <span class="comment">     *not* return this standard exception.  The catchpoint condition</span>
<a name="l12101"></a>12101 <span class="comment">     may then be set only on user-defined exceptions which have the</span>
<a name="l12102"></a>12102 <span class="comment">     same not-fully-qualified name (e.g. my_package.constraint_error).</span>
<a name="l12103"></a>12103 <span class="comment"></span>
<a name="l12104"></a>12104 <span class="comment">     To avoid this unexcepted behavior, these standard exceptions are</span>
<a name="l12105"></a>12105 <span class="comment">     systematically prefixed by &quot;standard&quot;.  This means that &quot;catch</span>
<a name="l12106"></a>12106 <span class="comment">     exception constraint_error&quot; is rewritten into &quot;catch exception</span>
<a name="l12107"></a>12107 <span class="comment">     standard.constraint_error&quot;.</span>
<a name="l12108"></a>12108 <span class="comment"></span>
<a name="l12109"></a>12109 <span class="comment">     If an exception named contraint_error is defined in another package of</span>
<a name="l12110"></a>12110 <span class="comment">     the inferior program, then the only way to specify this exception as a</span>
<a name="l12111"></a>12111 <span class="comment">     breakpoint condition is to use its fully-qualified named:</span>
<a name="l12112"></a>12112 <span class="comment">     e.g. my_package.constraint_error.  */</span>
<a name="l12113"></a>12113 
<a name="l12114"></a>12114   <span class="keywordflow">for</span> (i = 0; i &lt; <span class="keyword">sizeof</span> (standard_exc) / <span class="keyword">sizeof</span> (<span class="keywordtype">char</span> *); i++)
<a name="l12115"></a>12115     {
<a name="l12116"></a>12116       <span class="keywordflow">if</span> (strcmp (standard_exc [i], excep_string) == 0)
<a name="l12117"></a>12117         {
<a name="l12118"></a>12118           <span class="keywordflow">return</span> <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;long_integer (e) = long_integer (&amp;standard.%s)&quot;</span>,
<a name="l12119"></a>12119                              excep_string);
<a name="l12120"></a>12120         }
<a name="l12121"></a>12121     }
<a name="l12122"></a>12122   <span class="keywordflow">return</span> <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;long_integer (e) = long_integer (&amp;%s)&quot;</span>, excep_string);
<a name="l12123"></a>12123 }
<a name="l12124"></a>12124 
<a name="l12125"></a>12125 <span class="comment">/* Return the symtab_and_line that should be used to insert an exception</span>
<a name="l12126"></a>12126 <span class="comment">   catchpoint of the TYPE kind.</span>
<a name="l12127"></a>12127 <span class="comment"></span>
<a name="l12128"></a>12128 <span class="comment">   EXCEP_STRING should contain the name of a specific exception that</span>
<a name="l12129"></a>12129 <span class="comment">   the catchpoint should catch, or NULL otherwise.</span>
<a name="l12130"></a>12130 <span class="comment"></span>
<a name="l12131"></a>12131 <span class="comment">   ADDR_STRING returns the name of the function where the real</span>
<a name="l12132"></a>12132 <span class="comment">   breakpoint that implements the catchpoints is set, depending on the</span>
<a name="l12133"></a>12133 <span class="comment">   type of catchpoint we need to create.  */</span>
<a name="l12134"></a>12134 
<a name="l12135"></a>12135 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a>
<a name="l12136"></a>12136 ada_exception_sal (enum <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex, char *excep_string,
<a name="l12137"></a>12137                    <span class="keywordtype">char</span> **addr_string, <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structbreakpoint__ops.html">breakpoint_ops</a> **ops)
<a name="l12138"></a>12138 {
<a name="l12139"></a>12139   <span class="keyword">const</span> <span class="keywordtype">char</span> *sym_name;
<a name="l12140"></a>12140   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *sym;
<a name="l12141"></a>12141 
<a name="l12142"></a>12142   <span class="comment">/* First, find out which exception support info to use.  */</span>
<a name="l12143"></a>12143   ada_exception_support_info_sniffer ();
<a name="l12144"></a>12144 
<a name="l12145"></a>12145   <span class="comment">/* Then lookup the function on which we will break in order to catch</span>
<a name="l12146"></a>12146 <span class="comment">     the Ada exceptions requested by the user.  */</span>
<a name="l12147"></a>12147   sym_name = ada_exception_sym_name (ex);
<a name="l12148"></a>12148   sym = standard_lookup (sym_name, NULL, <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>);
<a name="l12149"></a>12149 
<a name="l12150"></a>12150   <span class="comment">/* We can assume that SYM is not NULL at this stage.  If the symbol</span>
<a name="l12151"></a>12151 <span class="comment">     did not exist, ada_exception_support_info_sniffer would have</span>
<a name="l12152"></a>12152 <span class="comment">     raised an exception.</span>
<a name="l12153"></a>12153 <span class="comment"></span>
<a name="l12154"></a>12154 <span class="comment">     Also, ada_exception_support_info_sniffer should have already</span>
<a name="l12155"></a>12155 <span class="comment">     verified that SYM is a function symbol.  */</span>
<a name="l12156"></a>12156   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (sym != NULL);
<a name="l12157"></a>12157   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="symtab_8h.html#a8394f2ba6c27e8026b2783db7cc0eb40">SYMBOL_CLASS</a> (sym) == <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>);
<a name="l12158"></a>12158 
<a name="l12159"></a>12159   <span class="comment">/* Set ADDR_STRING.  */</span>
<a name="l12160"></a>12160   *addr_string = xstrdup (sym_name);
<a name="l12161"></a>12161 
<a name="l12162"></a>12162   <span class="comment">/* Set OPS.  */</span>
<a name="l12163"></a>12163   *ops = ada_exception_breakpoint_ops (ex);
<a name="l12164"></a>12164 
<a name="l12165"></a>12165   <span class="keywordflow">return</span> <a class="code" href="symtab_8c.html#ab927e83e70b2cff20b3750daff6f84c5">find_function_start_sal</a> (sym, 1);
<a name="l12166"></a>12166 }
<a name="l12167"></a>12167 
<a name="l12168"></a>12168 <span class="comment">/* Create an Ada exception catchpoint.</span>
<a name="l12169"></a>12169 <span class="comment"></span>
<a name="l12170"></a>12170 <span class="comment">   EX_KIND is the kind of exception catchpoint to be created.</span>
<a name="l12171"></a>12171 <span class="comment"></span>
<a name="l12172"></a>12172 <span class="comment">   EXCEPT_STRING, if not NULL, indicates the name of the exception</span>
<a name="l12173"></a>12173 <span class="comment">   to which this catchpoint applies.  If NULL, this catchpoint is</span>
<a name="l12174"></a>12174 <span class="comment">   expected to trigger for all exceptions.</span>
<a name="l12175"></a>12175 <span class="comment"></span>
<a name="l12176"></a>12176 <span class="comment">   COND_STRING, if not NULL, is the catchpoint condition.</span>
<a name="l12177"></a>12177 <span class="comment"></span>
<a name="l12178"></a>12178 <span class="comment">   TEMPFLAG, if nonzero, means that the underlying breakpoint</span>
<a name="l12179"></a>12179 <span class="comment">   should be temporary.</span>
<a name="l12180"></a>12180 <span class="comment"></span>
<a name="l12181"></a>12181 <span class="comment">   FROM_TTY is the usual argument passed to all commands implementations.  */</span>
<a name="l12182"></a>12182 
<a name="l12183"></a>12183 <span class="keywordtype">void</span>
<a name="l12184"></a><a class="code" href="ada-lang_8h.html#a0fc146a60aadd862e54b0edb7e8c174b">12184</a> <a class="code" href="ada-lang_8c.html#a0fc146a60aadd862e54b0edb7e8c174b">create_ada_exception_catchpoint</a> (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l12185"></a>12185                                  <span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex_kind,
<a name="l12186"></a>12186                                  <span class="keywordtype">char</span> *excep_string,
<a name="l12187"></a>12187                                  <span class="keywordtype">char</span> *cond_string,
<a name="l12188"></a>12188                                  <span class="keywordtype">int</span> tempflag,
<a name="l12189"></a>12189                                  <span class="keywordtype">int</span> disabled,
<a name="l12190"></a>12190                                  <span class="keywordtype">int</span> from_tty)
<a name="l12191"></a>12191 {
<a name="l12192"></a>12192   <span class="keyword">struct </span>ada_catchpoint *c;
<a name="l12193"></a>12193   <span class="keywordtype">char</span> *addr_string = NULL;
<a name="l12194"></a>12194   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structbreakpoint__ops.html">breakpoint_ops</a> *ops = NULL;
<a name="l12195"></a>12195   <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a> sal
<a name="l12196"></a>12196     = ada_exception_sal (ex_kind, excep_string, &amp;addr_string, &amp;ops);
<a name="l12197"></a>12197 
<a name="l12198"></a>12198   c = XNEW (<span class="keyword">struct</span> ada_catchpoint);
<a name="l12199"></a>12199   <a class="code" href="breakpoint_8c.html#afd6cc798fa29005c7bd6ae73dc7397dd">init_ada_exception_breakpoint</a> (&amp;c-&gt;base, gdbarch, sal, addr_string,
<a name="l12200"></a>12200                                  ops, tempflag, disabled, from_tty);
<a name="l12201"></a>12201   c-&gt;excep_string = excep_string;
<a name="l12202"></a>12202   create_excep_cond_exprs (c);
<a name="l12203"></a>12203   <span class="keywordflow">if</span> (cond_string != NULL)
<a name="l12204"></a>12204     <a class="code" href="breakpoint_8c.html#adffcf1e43632816a9b049605ab609502">set_breakpoint_condition</a> (&amp;c-&gt;base, cond_string, from_tty);
<a name="l12205"></a>12205   <a class="code" href="breakpoint_8c.html#a74ff6d8191c3b444efd5631143d21635">install_breakpoint</a> (0, &amp;c-&gt;base, 1);
<a name="l12206"></a>12206 }
<a name="l12207"></a>12207 
<a name="l12208"></a>12208 <span class="comment">/* Implement the &quot;catch exception&quot; command.  */</span>
<a name="l12209"></a>12209 
<a name="l12210"></a>12210 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12211"></a>12211 catch_ada_exception_command (<span class="keywordtype">char</span> *arg, <span class="keywordtype">int</span> from_tty,
<a name="l12212"></a>12212                              <span class="keyword">struct</span> <a class="code" href="structcmd__list__element.html">cmd_list_element</a> *command)
<a name="l12213"></a>12213 {
<a name="l12214"></a>12214   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="arch-utils_8c.html#a0fe1e68475f442e5d6dda589e0c62454">get_current_arch</a> ();
<a name="l12215"></a>12215   <span class="keywordtype">int</span> tempflag;
<a name="l12216"></a>12216   <span class="keyword">enum</span> <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714">ada_exception_catchpoint_kind</a> ex_kind;
<a name="l12217"></a>12217   <span class="keywordtype">char</span> *excep_string = NULL;
<a name="l12218"></a>12218   <span class="keywordtype">char</span> *cond_string = NULL;
<a name="l12219"></a>12219 
<a name="l12220"></a>12220   tempflag = <a class="code" href="cli-decode_8c.html#a32e42936fca3a5158162ca425eb2c4b9">get_cmd_context</a> (command) == <a class="code" href="breakpoint_8h.html#a9f80fa035808be1497fc37fd6595587e">CATCH_TEMPORARY</a>;
<a name="l12221"></a>12221 
<a name="l12222"></a>12222   <span class="keywordflow">if</span> (!arg)
<a name="l12223"></a>12223     arg = <span class="stringliteral">&quot;&quot;</span>;
<a name="l12224"></a>12224   catch_ada_exception_command_split (arg, &amp;ex_kind, &amp;excep_string,
<a name="l12225"></a>12225                                      &amp;cond_string);
<a name="l12226"></a>12226   <a class="code" href="ada-lang_8c.html#a0fc146a60aadd862e54b0edb7e8c174b">create_ada_exception_catchpoint</a> (gdbarch, ex_kind,
<a name="l12227"></a>12227                                    excep_string, cond_string,
<a name="l12228"></a>12228                                    tempflag, 1 <span class="comment">/* enabled */</span>,
<a name="l12229"></a>12229                                    from_tty);
<a name="l12230"></a>12230 }
<a name="l12231"></a>12231 
<a name="l12232"></a>12232 <span class="comment">/* Split the arguments specified in a &quot;catch assert&quot; command.</span>
<a name="l12233"></a>12233 <span class="comment"></span>
<a name="l12234"></a>12234 <span class="comment">   ARGS contains the command&#39;s arguments (or the empty string if</span>
<a name="l12235"></a>12235 <span class="comment">   no arguments were passed).</span>
<a name="l12236"></a>12236 <span class="comment"></span>
<a name="l12237"></a>12237 <span class="comment">   If ARGS contains a condition, set COND_STRING to that condition</span>
<a name="l12238"></a>12238 <span class="comment">   (the memory needs to be deallocated after use).  */</span>
<a name="l12239"></a>12239 
<a name="l12240"></a>12240 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12241"></a>12241 catch_ada_assert_command_split (<span class="keywordtype">char</span> *args, <span class="keywordtype">char</span> **cond_string)
<a name="l12242"></a>12242 {
<a name="l12243"></a>12243   args = <a class="code" href="cli-utils_8c.html#afa70bcaee54d487b4412d2a7a5a0c8fa">skip_spaces</a> (args);
<a name="l12244"></a>12244 
<a name="l12245"></a>12245   <span class="comment">/* Check whether a condition was provided.  */</span>
<a name="l12246"></a>12246   <span class="keywordflow">if</span> (strncmp (args, <span class="stringliteral">&quot;if&quot;</span>, 2) == 0
<a name="l12247"></a>12247       &amp;&amp; (isspace (args[2]) || args[2] == <span class="charliteral">&#39;\0&#39;</span>))
<a name="l12248"></a>12248     {
<a name="l12249"></a>12249       args += 2;
<a name="l12250"></a>12250       args = <a class="code" href="cli-utils_8c.html#afa70bcaee54d487b4412d2a7a5a0c8fa">skip_spaces</a> (args);
<a name="l12251"></a>12251       <span class="keywordflow">if</span> (args[0] == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l12252"></a>12252         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;condition missing after `if&#39; keyword&quot;</span>));
<a name="l12253"></a>12253       *cond_string = xstrdup (args);
<a name="l12254"></a>12254     }
<a name="l12255"></a>12255 
<a name="l12256"></a>12256   <span class="comment">/* Otherwise, there should be no other argument at the end of</span>
<a name="l12257"></a>12257 <span class="comment">     the command.  */</span>
<a name="l12258"></a>12258   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (args[0] != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l12259"></a>12259     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Junk at end of arguments.&quot;</span>));
<a name="l12260"></a>12260 }
<a name="l12261"></a>12261 
<a name="l12262"></a>12262 <span class="comment">/* Implement the &quot;catch assert&quot; command.  */</span>
<a name="l12263"></a>12263 
<a name="l12264"></a>12264 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12265"></a>12265 catch_assert_command (<span class="keywordtype">char</span> *arg, <span class="keywordtype">int</span> from_tty,
<a name="l12266"></a>12266                       <span class="keyword">struct</span> <a class="code" href="structcmd__list__element.html">cmd_list_element</a> *command)
<a name="l12267"></a>12267 {
<a name="l12268"></a>12268   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="arch-utils_8c.html#a0fe1e68475f442e5d6dda589e0c62454">get_current_arch</a> ();
<a name="l12269"></a>12269   <span class="keywordtype">int</span> tempflag;
<a name="l12270"></a>12270   <span class="keywordtype">char</span> *cond_string = NULL;
<a name="l12271"></a>12271 
<a name="l12272"></a>12272   tempflag = <a class="code" href="cli-decode_8c.html#a32e42936fca3a5158162ca425eb2c4b9">get_cmd_context</a> (command) == <a class="code" href="breakpoint_8h.html#a9f80fa035808be1497fc37fd6595587e">CATCH_TEMPORARY</a>;
<a name="l12273"></a>12273 
<a name="l12274"></a>12274   <span class="keywordflow">if</span> (!arg)
<a name="l12275"></a>12275     arg = <span class="stringliteral">&quot;&quot;</span>;
<a name="l12276"></a>12276   catch_ada_assert_command_split (arg, &amp;cond_string);
<a name="l12277"></a>12277   <a class="code" href="ada-lang_8c.html#a0fc146a60aadd862e54b0edb7e8c174b">create_ada_exception_catchpoint</a> (gdbarch, <a class="code" href="ada-lang_8h.html#af2d37d48fbf0eca0f894991138aed714aea7b65b7ade48f6f0096c82472e282a2">ada_catch_assert</a>,
<a name="l12278"></a>12278                                    NULL, cond_string,
<a name="l12279"></a>12279                                    tempflag, 1 <span class="comment">/* enabled */</span>,
<a name="l12280"></a>12280                                    from_tty);
<a name="l12281"></a>12281 }
<a name="l12282"></a>12282                                 <span class="comment">/* Operators */</span>
<a name="l12283"></a>12283 <span class="comment">/* Information about operators given special treatment in functions</span>
<a name="l12284"></a>12284 <span class="comment">   below.  */</span>
<a name="l12285"></a>12285 <span class="comment">/* Format: OP_DEFN (&lt;operator&gt;, &lt;operator length&gt;, &lt;# args&gt;, &lt;binop&gt;).  */</span>
<a name="l12286"></a>12286 
<a name="l12287"></a><a class="code" href="ada-lang_8c.html#aeea98c817a3f2feae627140ab539c999">12287</a> <span class="preprocessor">#define ADA_OPERATORS \</span>
<a name="l12288"></a>12288 <span class="preprocessor">    OP_DEFN (OP_VAR_VALUE, 4, 0, 0) \</span>
<a name="l12289"></a>12289 <span class="preprocessor">    OP_DEFN (BINOP_IN_BOUNDS, 3, 2, 0) \</span>
<a name="l12290"></a>12290 <span class="preprocessor">    OP_DEFN (TERNOP_IN_RANGE, 1, 3, 0) \</span>
<a name="l12291"></a>12291 <span class="preprocessor">    OP_DEFN (OP_ATR_FIRST, 1, 2, 0) \</span>
<a name="l12292"></a>12292 <span class="preprocessor">    OP_DEFN (OP_ATR_LAST, 1, 2, 0) \</span>
<a name="l12293"></a>12293 <span class="preprocessor">    OP_DEFN (OP_ATR_LENGTH, 1, 2, 0) \</span>
<a name="l12294"></a>12294 <span class="preprocessor">    OP_DEFN (OP_ATR_IMAGE, 1, 2, 0) \</span>
<a name="l12295"></a>12295 <span class="preprocessor">    OP_DEFN (OP_ATR_MAX, 1, 3, 0) \</span>
<a name="l12296"></a>12296 <span class="preprocessor">    OP_DEFN (OP_ATR_MIN, 1, 3, 0) \</span>
<a name="l12297"></a>12297 <span class="preprocessor">    OP_DEFN (OP_ATR_MODULUS, 1, 1, 0) \</span>
<a name="l12298"></a>12298 <span class="preprocessor">    OP_DEFN (OP_ATR_POS, 1, 2, 0) \</span>
<a name="l12299"></a>12299 <span class="preprocessor">    OP_DEFN (OP_ATR_SIZE, 1, 1, 0) \</span>
<a name="l12300"></a>12300 <span class="preprocessor">    OP_DEFN (OP_ATR_TAG, 1, 1, 0) \</span>
<a name="l12301"></a>12301 <span class="preprocessor">    OP_DEFN (OP_ATR_VAL, 1, 2, 0) \</span>
<a name="l12302"></a>12302 <span class="preprocessor">    OP_DEFN (UNOP_QUAL, 3, 1, 0) \</span>
<a name="l12303"></a>12303 <span class="preprocessor">    OP_DEFN (UNOP_IN_RANGE, 3, 1, 0) \</span>
<a name="l12304"></a>12304 <span class="preprocessor">    OP_DEFN (OP_OTHERS, 1, 1, 0) \</span>
<a name="l12305"></a>12305 <span class="preprocessor">    OP_DEFN (OP_POSITIONAL, 3, 1, 0) \</span>
<a name="l12306"></a>12306 <span class="preprocessor">    OP_DEFN (OP_DISCRETE_RANGE, 1, 2, 0)</span>
<a name="l12307"></a>12307 <span class="preprocessor"></span>
<a name="l12308"></a>12308 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12309"></a>12309 ada_operator_length (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp, <span class="keywordtype">int</span> pc, <span class="keywordtype">int</span> *oplenp,
<a name="l12310"></a>12310                      <span class="keywordtype">int</span> *argsp)
<a name="l12311"></a>12311 {
<a name="l12312"></a>12312   <span class="keywordflow">switch</span> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc - 1].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a>)
<a name="l12313"></a>12313     {
<a name="l12314"></a>12314     <span class="keywordflow">default</span>:
<a name="l12315"></a>12315       <a class="code" href="parse_8c.html#a63b798abb9b9b89ab5f422b1d5c1d16f">operator_length_standard </a>(exp, pc, oplenp, argsp);
<a name="l12316"></a>12316       <span class="keywordflow">break</span>;
<a name="l12317"></a>12317 
<a name="l12318"></a>12318 <span class="preprocessor">#define OP_DEFN(op, len, args, binop) \</span>
<a name="l12319"></a>12319 <span class="preprocessor">    case op: *oplenp = len; *argsp = args; break;</span>
<a name="l12320"></a>12320 <span class="preprocessor"></span>      <a class="code" href="ada-lang_8c.html#aeea98c817a3f2feae627140ab539c999">ADA_OPERATORS</a>;
<a name="l12321"></a>12321 <span class="preprocessor">#undef OP_DEFN</span>
<a name="l12322"></a>12322 <span class="preprocessor"></span>
<a name="l12323"></a>12323     <span class="keywordflow">case</span> OP_AGGREGATE:
<a name="l12324"></a>12324       *oplenp = 3;
<a name="l12325"></a>12325       *argsp = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc - 2].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l12326"></a>12326       <span class="keywordflow">break</span>;
<a name="l12327"></a>12327 
<a name="l12328"></a>12328     <span class="keywordflow">case</span> OP_CHOICES:
<a name="l12329"></a>12329       *oplenp = 3;
<a name="l12330"></a>12330       *argsp = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc - 2].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>) + 1;
<a name="l12331"></a>12331       <span class="keywordflow">break</span>;
<a name="l12332"></a>12332     }
<a name="l12333"></a>12333 }
<a name="l12334"></a>12334 
<a name="l12335"></a>12335 <span class="comment">/* Implementation of the exp_descriptor method operator_check.  */</span>
<a name="l12336"></a>12336 
<a name="l12337"></a>12337 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l12338"></a>12338 ada_operator_check (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp, <span class="keywordtype">int</span> pos,
<a name="l12339"></a>12339                     <span class="keywordtype">int</span> (*objfile_func) (<span class="keyword">struct</span> objfile *objfile, <span class="keywordtype">void</span> *data),
<a name="l12340"></a>12340                     <span class="keywordtype">void</span> *data)
<a name="l12341"></a>12341 {
<a name="l12342"></a>12342   <span class="keyword">const</span> <span class="keyword">union </span><a class="code" href="unionexp__element.html">exp_element</a> *<span class="keyword">const</span> elts = exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>;
<a name="l12343"></a>12343   <span class="keyword">struct </span>type *type = NULL;
<a name="l12344"></a>12344 
<a name="l12345"></a>12345   <span class="keywordflow">switch</span> (elts[pos].opcode)
<a name="l12346"></a>12346     {
<a name="l12347"></a>12347       <span class="keywordflow">case</span> UNOP_IN_RANGE:
<a name="l12348"></a>12348       <span class="keywordflow">case</span> UNOP_QUAL:
<a name="l12349"></a>12349         type = elts[pos + 1].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>;
<a name="l12350"></a>12350         <span class="keywordflow">break</span>;
<a name="l12351"></a>12351 
<a name="l12352"></a>12352       <span class="keywordflow">default</span>:
<a name="l12353"></a>12353         <span class="keywordflow">return</span> <a class="code" href="parse_8c.html#a3c5d5d877d396d73ba4e16142a96a9ad">operator_check_standard </a>(exp, pos, objfile_func, data);
<a name="l12354"></a>12354     }
<a name="l12355"></a>12355 
<a name="l12356"></a>12356   <span class="comment">/* Invoke callbacks for TYPE and OBJFILE if they were set as non-NULL.  */</span>
<a name="l12357"></a>12357 
<a name="l12358"></a>12358   <span class="keywordflow">if</span> (type &amp;&amp; <a class="code" href="gdbtypes_8h.html#aff6665865a3226d047330d04c05bcb3d">TYPE_OBJFILE</a> (type)
<a name="l12359"></a>12359       &amp;&amp; (*objfile_func) (<a class="code" href="gdbtypes_8h.html#aff6665865a3226d047330d04c05bcb3d">TYPE_OBJFILE</a> (type), data))
<a name="l12360"></a>12360     <span class="keywordflow">return</span> 1;
<a name="l12361"></a>12361 
<a name="l12362"></a>12362   <span class="keywordflow">return</span> 0;
<a name="l12363"></a>12363 }
<a name="l12364"></a>12364 
<a name="l12365"></a>12365 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l12366"></a>12366 ada_op_name (<span class="keyword">enum</span> <a class="code" href="expression_8h.html#a13f8bfc7b2a183fe56716508bfddae41">exp_opcode</a> opcode)
<a name="l12367"></a>12367 {
<a name="l12368"></a>12368   <span class="keywordflow">switch</span> (opcode)
<a name="l12369"></a>12369     {
<a name="l12370"></a>12370     <span class="keywordflow">default</span>:
<a name="l12371"></a>12371       <span class="keywordflow">return</span> <a class="code" href="expprint_8c.html#aed49bccbec4ce41f27a5b7478fe97145">op_name_standard</a> (opcode);
<a name="l12372"></a>12372 
<a name="l12373"></a>12373 <span class="preprocessor">#define OP_DEFN(op, len, args, binop) case op: return #op;</span>
<a name="l12374"></a>12374 <span class="preprocessor"></span>      <a class="code" href="ada-lang_8c.html#aeea98c817a3f2feae627140ab539c999">ADA_OPERATORS</a>;
<a name="l12375"></a>12375 <span class="preprocessor">#undef OP_DEFN</span>
<a name="l12376"></a>12376 <span class="preprocessor"></span>
<a name="l12377"></a>12377     <span class="keywordflow">case</span> OP_AGGREGATE:
<a name="l12378"></a>12378       <span class="keywordflow">return</span> <span class="stringliteral">&quot;OP_AGGREGATE&quot;</span>;
<a name="l12379"></a>12379     <span class="keywordflow">case</span> OP_CHOICES:
<a name="l12380"></a>12380       <span class="keywordflow">return</span> <span class="stringliteral">&quot;OP_CHOICES&quot;</span>;
<a name="l12381"></a>12381     <span class="keywordflow">case</span> OP_NAME:
<a name="l12382"></a>12382       <span class="keywordflow">return</span> <span class="stringliteral">&quot;OP_NAME&quot;</span>;
<a name="l12383"></a>12383     }
<a name="l12384"></a>12384 }
<a name="l12385"></a>12385 
<a name="l12386"></a>12386 <span class="comment">/* As for operator_length, but assumes PC is pointing at the first</span>
<a name="l12387"></a>12387 <span class="comment">   element of the operator, and gives meaningful results only for the </span>
<a name="l12388"></a>12388 <span class="comment">   Ada-specific operators, returning 0 for *OPLENP and *ARGSP otherwise.  */</span>
<a name="l12389"></a>12389 
<a name="l12390"></a>12390 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12391"></a>12391 ada_forward_operator_length (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp, <span class="keywordtype">int</span> pc,
<a name="l12392"></a>12392                              <span class="keywordtype">int</span> *oplenp, <span class="keywordtype">int</span> *argsp)
<a name="l12393"></a>12393 {
<a name="l12394"></a>12394   <span class="keywordflow">switch</span> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a>)
<a name="l12395"></a>12395     {
<a name="l12396"></a>12396     <span class="keywordflow">default</span>:
<a name="l12397"></a>12397       *oplenp = *argsp = 0;
<a name="l12398"></a>12398       <span class="keywordflow">break</span>;
<a name="l12399"></a>12399 
<a name="l12400"></a>12400 <span class="preprocessor">#define OP_DEFN(op, len, args, binop) \</span>
<a name="l12401"></a>12401 <span class="preprocessor">    case op: *oplenp = len; *argsp = args; break;</span>
<a name="l12402"></a>12402 <span class="preprocessor"></span>      <a class="code" href="ada-lang_8c.html#aeea98c817a3f2feae627140ab539c999">ADA_OPERATORS</a>;
<a name="l12403"></a>12403 <span class="preprocessor">#undef OP_DEFN</span>
<a name="l12404"></a>12404 <span class="preprocessor"></span>
<a name="l12405"></a>12405     <span class="keywordflow">case</span> OP_AGGREGATE:
<a name="l12406"></a>12406       *oplenp = 3;
<a name="l12407"></a>12407       *argsp = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l12408"></a>12408       <span class="keywordflow">break</span>;
<a name="l12409"></a>12409 
<a name="l12410"></a>12410     <span class="keywordflow">case</span> OP_CHOICES:
<a name="l12411"></a>12411       *oplenp = 3;
<a name="l12412"></a>12412       *argsp = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>) + 1;
<a name="l12413"></a>12413       <span class="keywordflow">break</span>;
<a name="l12414"></a>12414 
<a name="l12415"></a>12415     <span class="keywordflow">case</span> OP_STRING:
<a name="l12416"></a>12416     <span class="keywordflow">case</span> OP_NAME:
<a name="l12417"></a>12417       {
<a name="l12418"></a>12418         <span class="keywordtype">int</span> len = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l12419"></a>12419 
<a name="l12420"></a>12420         *oplenp = 4 + <a class="code" href="expression_8h.html#a8a1be157bb41aa92434ac6ce0e0fcf78">BYTES_TO_EXP_ELEM</a> (len + 1);
<a name="l12421"></a>12421         *argsp = 0;
<a name="l12422"></a>12422         <span class="keywordflow">break</span>;
<a name="l12423"></a>12423       }
<a name="l12424"></a>12424     }
<a name="l12425"></a>12425 }
<a name="l12426"></a>12426 
<a name="l12427"></a>12427 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l12428"></a>12428 ada_dump_subexp_body (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp, <span class="keyword">struct</span> ui_file *stream, <span class="keywordtype">int</span> elt)
<a name="l12429"></a>12429 {
<a name="l12430"></a>12430   <span class="keyword">enum</span> <a class="code" href="expression_8h.html#a13f8bfc7b2a183fe56716508bfddae41">exp_opcode</a> op = exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[elt].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a>;
<a name="l12431"></a>12431   <span class="keywordtype">int</span> oplen, nargs;
<a name="l12432"></a>12432   <span class="keywordtype">int</span> pc = elt;
<a name="l12433"></a>12433   <span class="keywordtype">int</span> i;
<a name="l12434"></a>12434 
<a name="l12435"></a>12435   ada_forward_operator_length (exp, elt, &amp;oplen, &amp;nargs);
<a name="l12436"></a>12436 
<a name="l12437"></a>12437   <span class="keywordflow">switch</span> (op)
<a name="l12438"></a>12438     {
<a name="l12439"></a>12439       <span class="comment">/* Ada attributes (&#39;Foo).  */</span>
<a name="l12440"></a>12440     <span class="keywordflow">case</span> OP_ATR_FIRST:
<a name="l12441"></a>12441     <span class="keywordflow">case</span> OP_ATR_LAST:
<a name="l12442"></a>12442     <span class="keywordflow">case</span> OP_ATR_LENGTH:
<a name="l12443"></a>12443     <span class="keywordflow">case</span> OP_ATR_IMAGE:
<a name="l12444"></a>12444     <span class="keywordflow">case</span> OP_ATR_MAX:
<a name="l12445"></a>12445     <span class="keywordflow">case</span> OP_ATR_MIN:
<a name="l12446"></a>12446     <span class="keywordflow">case</span> OP_ATR_MODULUS:
<a name="l12447"></a>12447     <span class="keywordflow">case</span> OP_ATR_POS:
<a name="l12448"></a>12448     <span class="keywordflow">case</span> OP_ATR_SIZE:
<a name="l12449"></a>12449     <span class="keywordflow">case</span> OP_ATR_TAG:
<a name="l12450"></a>12450     <span class="keywordflow">case</span> OP_ATR_VAL:
<a name="l12451"></a>12451       <span class="keywordflow">break</span>;
<a name="l12452"></a>12452 
<a name="l12453"></a>12453     <span class="keywordflow">case</span> UNOP_IN_RANGE:
<a name="l12454"></a>12454     <span class="keywordflow">case</span> UNOP_QUAL:
<a name="l12455"></a>12455       <span class="comment">/* XXX: gdb_sprint_host_address, type_sprint */</span>
<a name="l12456"></a>12456       <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (stream, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Type @&quot;</span>));
<a name="l12457"></a>12457       <a class="code" href="utils_8c.html#a44c27389317dc7223638a3ee31bcd22b">gdb_print_host_address</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>, stream);
<a name="l12458"></a>12458       <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (stream, <span class="stringliteral">&quot; (&quot;</span>);
<a name="l12459"></a>12459       <a class="code" href="typeprint_8c.html#ad50c90b55385094557cceaa1ea985e47">type_print</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>, NULL, stream, 0);
<a name="l12460"></a>12460       <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (stream, <span class="stringliteral">&quot;)&quot;</span>);
<a name="l12461"></a>12461       <span class="keywordflow">break</span>;
<a name="l12462"></a>12462     <span class="keywordflow">case</span> BINOP_IN_BOUNDS:
<a name="l12463"></a>12463       <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (stream, <span class="stringliteral">&quot; (%d)&quot;</span>,
<a name="l12464"></a>12464                         <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>));
<a name="l12465"></a>12465       <span class="keywordflow">break</span>;
<a name="l12466"></a>12466     <span class="keywordflow">case</span> TERNOP_IN_RANGE:
<a name="l12467"></a>12467       <span class="keywordflow">break</span>;
<a name="l12468"></a>12468 
<a name="l12469"></a>12469     <span class="keywordflow">case</span> OP_AGGREGATE:
<a name="l12470"></a>12470     <span class="keywordflow">case</span> OP_OTHERS:
<a name="l12471"></a>12471     <span class="keywordflow">case</span> OP_DISCRETE_RANGE:
<a name="l12472"></a>12472     <span class="keywordflow">case</span> OP_POSITIONAL:
<a name="l12473"></a>12473     <span class="keywordflow">case</span> OP_CHOICES:
<a name="l12474"></a>12474       <span class="keywordflow">break</span>;
<a name="l12475"></a>12475 
<a name="l12476"></a>12476     <span class="keywordflow">case</span> OP_NAME:
<a name="l12477"></a>12477     <span class="keywordflow">case</span> OP_STRING:
<a name="l12478"></a>12478       {
<a name="l12479"></a>12479         <span class="keywordtype">char</span> *name = &amp;exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[elt + 2].<a class="code" href="unionexp__element.html#abeeb3252199a524869642283bccda167">string</a>;
<a name="l12480"></a>12480         <span class="keywordtype">int</span> len = <a class="code" href="defs_8h.html#a6e860bbd0169e0686e0a559410a7e02e">longest_to_int</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[elt + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l12481"></a>12481 
<a name="l12482"></a>12482         <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (stream, <span class="stringliteral">&quot;Text: `%.*s&#39;&quot;</span>, len, name);
<a name="l12483"></a>12483         <span class="keywordflow">break</span>;
<a name="l12484"></a>12484       }
<a name="l12485"></a>12485 
<a name="l12486"></a>12486     <span class="keywordflow">default</span>:
<a name="l12487"></a>12487       <span class="keywordflow">return</span> <a class="code" href="expprint_8c.html#a41602f65fa035d559466175ce1e77cf2">dump_subexp_body_standard</a> (exp, stream, elt);
<a name="l12488"></a>12488     }
<a name="l12489"></a>12489 
<a name="l12490"></a>12490   elt += oplen;
<a name="l12491"></a>12491   <span class="keywordflow">for</span> (i = 0; i &lt; nargs; i += 1)
<a name="l12492"></a>12492     elt = <a class="code" href="expprint_8c.html#a37118a34cd2ac9fdb10f8b23efa62a53">dump_subexp</a> (exp, stream, elt);
<a name="l12493"></a>12493 
<a name="l12494"></a>12494   <span class="keywordflow">return</span> elt;
<a name="l12495"></a>12495 }
<a name="l12496"></a>12496 
<a name="l12497"></a>12497 <span class="comment">/* The Ada extension of print_subexp (q.v.).  */</span>
<a name="l12498"></a>12498 
<a name="l12499"></a>12499 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12500"></a>12500 ada_print_subexp (<span class="keyword">struct</span> <a class="code" href="structexpression.html">expression</a> *exp, <span class="keywordtype">int</span> *pos,
<a name="l12501"></a>12501                   <span class="keyword">struct</span> ui_file *stream, <span class="keyword">enum</span> <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4a">precedence</a> prec)
<a name="l12502"></a>12502 {
<a name="l12503"></a>12503   <span class="keywordtype">int</span> oplen, nargs, i;
<a name="l12504"></a>12504   <span class="keywordtype">int</span> pc = *pos;
<a name="l12505"></a>12505   <span class="keyword">enum</span> <a class="code" href="expression_8h.html#a13f8bfc7b2a183fe56716508bfddae41">exp_opcode</a> op = exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a>;
<a name="l12506"></a>12506 
<a name="l12507"></a>12507   ada_forward_operator_length (exp, pc, &amp;oplen, &amp;nargs);
<a name="l12508"></a>12508 
<a name="l12509"></a>12509   *pos += oplen;
<a name="l12510"></a>12510   <span class="keywordflow">switch</span> (op)
<a name="l12511"></a>12511     {
<a name="l12512"></a>12512     <span class="keywordflow">default</span>:
<a name="l12513"></a>12513       *pos -= oplen;
<a name="l12514"></a>12514       <a class="code" href="expprint_8c.html#a461e4507de8fa316a5744d83f061e203">print_subexp_standard</a> (exp, pos, stream, prec);
<a name="l12515"></a>12515       <span class="keywordflow">return</span>;
<a name="l12516"></a>12516 
<a name="l12517"></a>12517     <span class="keywordflow">case</span> OP_VAR_VALUE:
<a name="l12518"></a>12518       <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<a class="code" href="symtab_8h.html#a243e66afa96ff58a851b38f428bb3394">SYMBOL_NATURAL_NAME</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 2].<a class="code" href="unionexp__element.html#aaa2c043e08e05f37c03379ca80dcc124">symbol</a>), stream);
<a name="l12519"></a>12519       <span class="keywordflow">return</span>;
<a name="l12520"></a>12520 
<a name="l12521"></a>12521     <span class="keywordflow">case</span> BINOP_IN_BOUNDS:
<a name="l12522"></a>12522       <span class="comment">/* XXX: sprint_subexp */</span>
<a name="l12523"></a>12523       <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>);
<a name="l12524"></a>12524       <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot; in &quot;</span>, stream);
<a name="l12525"></a>12525       <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>);
<a name="l12526"></a>12526       <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot;&#39;range&quot;</span>, stream);
<a name="l12527"></a>12527       <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a> &gt; 1)
<a name="l12528"></a>12528         <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (stream, <span class="stringliteral">&quot;(%ld)&quot;</span>,
<a name="l12529"></a>12529                           (<span class="keywordtype">long</span>) exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a1e73a47f67bc03f19ff133a02d0778a9">longconst</a>);
<a name="l12530"></a>12530       <span class="keywordflow">return</span>;
<a name="l12531"></a>12531 
<a name="l12532"></a>12532     <span class="keywordflow">case</span> TERNOP_IN_RANGE:
<a name="l12533"></a>12533       <span class="keywordflow">if</span> (prec &gt;= <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aab4f80761770aecaaa11be998cb32be94">PREC_EQUAL</a>)
<a name="l12534"></a>12534         <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot;(&quot;</span>, stream);
<a name="l12535"></a>12535       <span class="comment">/* XXX: sprint_subexp */</span>
<a name="l12536"></a>12536       <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>);
<a name="l12537"></a>12537       <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot; in &quot;</span>, stream);
<a name="l12538"></a>12538       <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aab4f80761770aecaaa11be998cb32be94">PREC_EQUAL</a>);
<a name="l12539"></a>12539       <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot; .. &quot;</span>, stream);
<a name="l12540"></a>12540       <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aab4f80761770aecaaa11be998cb32be94">PREC_EQUAL</a>);
<a name="l12541"></a>12541       <span class="keywordflow">if</span> (prec &gt;= <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aab4f80761770aecaaa11be998cb32be94">PREC_EQUAL</a>)
<a name="l12542"></a>12542         <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot;)&quot;</span>, stream);
<a name="l12543"></a>12543       <span class="keywordflow">return</span>;
<a name="l12544"></a>12544 
<a name="l12545"></a>12545     <span class="keywordflow">case</span> OP_ATR_FIRST:
<a name="l12546"></a>12546     <span class="keywordflow">case</span> OP_ATR_LAST:
<a name="l12547"></a>12547     <span class="keywordflow">case</span> OP_ATR_LENGTH:
<a name="l12548"></a>12548     <span class="keywordflow">case</span> OP_ATR_IMAGE:
<a name="l12549"></a>12549     <span class="keywordflow">case</span> OP_ATR_MAX:
<a name="l12550"></a>12550     <span class="keywordflow">case</span> OP_ATR_MIN:
<a name="l12551"></a>12551     <span class="keywordflow">case</span> OP_ATR_MODULUS:
<a name="l12552"></a>12552     <span class="keywordflow">case</span> OP_ATR_POS:
<a name="l12553"></a>12553     <span class="keywordflow">case</span> OP_ATR_SIZE:
<a name="l12554"></a>12554     <span class="keywordflow">case</span> OP_ATR_TAG:
<a name="l12555"></a>12555     <span class="keywordflow">case</span> OP_ATR_VAL:
<a name="l12556"></a>12556       <span class="keywordflow">if</span> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[*pos].<a class="code" href="unionexp__element.html#a732546b7148c98393e390e52d954bc83">opcode</a> == OP_TYPE)
<a name="l12557"></a>12557         {
<a name="l12558"></a>12558           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[*pos + 1].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>) != <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>)
<a name="l12559"></a>12559             <a class="code" href="language_8h.html#a8fbac7443669377b16c4324c96541069">LA_PRINT_TYPE</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[*pos + 1].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>, <span class="stringliteral">&quot;&quot;</span>, stream, 0, 0,
<a name="l12560"></a>12560                            &amp;<a class="code" href="typeprint_8c.html#a66053927e0c2e901b62bd36fd9769296">type_print_raw_options</a>);
<a name="l12561"></a>12561           *pos += 3;
<a name="l12562"></a>12562         }
<a name="l12563"></a>12563       <span class="keywordflow">else</span>
<a name="l12564"></a>12564         <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>);
<a name="l12565"></a>12565       <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (stream, <span class="stringliteral">&quot;&#39;%s&quot;</span>, <a class="code" href="ada-lang_8c.html#a2dc67804b48707c5176aac961d80e83f">ada_attribute_name</a> (op));
<a name="l12566"></a>12566       <span class="keywordflow">if</span> (nargs &gt; 1)
<a name="l12567"></a>12567         {
<a name="l12568"></a>12568           <span class="keywordtype">int</span> tem;
<a name="l12569"></a>12569 
<a name="l12570"></a>12570           <span class="keywordflow">for</span> (tem = 1; tem &lt; nargs; tem += 1)
<a name="l12571"></a>12571             {
<a name="l12572"></a>12572               <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> ((tem == 1) ? <span class="stringliteral">&quot; (&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>, stream);
<a name="l12573"></a>12573               <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aacc3bc7bd515a6aaf9093f0f4dccf8c8b">PREC_ABOVE_COMMA</a>);
<a name="l12574"></a>12574             }
<a name="l12575"></a>12575           <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot;)&quot;</span>, stream);
<a name="l12576"></a>12576         }
<a name="l12577"></a>12577       <span class="keywordflow">return</span>;
<a name="l12578"></a>12578 
<a name="l12579"></a>12579     <span class="keywordflow">case</span> UNOP_QUAL:
<a name="l12580"></a>12580       <a class="code" href="typeprint_8c.html#ad50c90b55385094557cceaa1ea985e47">type_print</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>, <span class="stringliteral">&quot;&quot;</span>, stream, 0);
<a name="l12581"></a>12581       <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot;&#39;(&quot;</span>, stream);
<a name="l12582"></a>12582       <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aa5ee2ba062f4296b69ca2878e3133ff6e">PREC_PREFIX</a>);
<a name="l12583"></a>12583       <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot;)&quot;</span>, stream);
<a name="l12584"></a>12584       <span class="keywordflow">return</span>;
<a name="l12585"></a>12585 
<a name="l12586"></a>12586     <span class="keywordflow">case</span> UNOP_IN_RANGE:
<a name="l12587"></a>12587       <span class="comment">/* XXX: sprint_subexp */</span>
<a name="l12588"></a>12588       <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>);
<a name="l12589"></a>12589       <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot; in &quot;</span>, stream);
<a name="l12590"></a>12590       <a class="code" href="language_8h.html#a8fbac7443669377b16c4324c96541069">LA_PRINT_TYPE</a> (exp-&gt;<a class="code" href="structexpression.html#a121cbb7647db0430c9e217dbcd27021f">elts</a>[pc + 1].<a class="code" href="unionexp__element.html#a5465f279ce78cd1036b1f0cefb1f78e2">type</a>, <span class="stringliteral">&quot;&quot;</span>, stream, 1, 0,
<a name="l12591"></a>12591                      &amp;<a class="code" href="typeprint_8c.html#a66053927e0c2e901b62bd36fd9769296">type_print_raw_options</a>);
<a name="l12592"></a>12592       <span class="keywordflow">return</span>;
<a name="l12593"></a>12593 
<a name="l12594"></a>12594     <span class="keywordflow">case</span> OP_DISCRETE_RANGE:
<a name="l12595"></a>12595       <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>);
<a name="l12596"></a>12596       <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot;..&quot;</span>, stream);
<a name="l12597"></a>12597       <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>);
<a name="l12598"></a>12598       <span class="keywordflow">return</span>;
<a name="l12599"></a>12599 
<a name="l12600"></a>12600     <span class="keywordflow">case</span> OP_OTHERS:
<a name="l12601"></a>12601       <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot;others =&gt; &quot;</span>, stream);
<a name="l12602"></a>12602       <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>);
<a name="l12603"></a>12603       <span class="keywordflow">return</span>;
<a name="l12604"></a>12604 
<a name="l12605"></a>12605     <span class="keywordflow">case</span> OP_CHOICES:
<a name="l12606"></a>12606       <span class="keywordflow">for</span> (i = 0; i &lt; nargs-1; i += 1)
<a name="l12607"></a>12607         {
<a name="l12608"></a>12608           <span class="keywordflow">if</span> (i &gt; 0)
<a name="l12609"></a>12609             <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot;|&quot;</span>, stream);
<a name="l12610"></a>12610           <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>);
<a name="l12611"></a>12611         }
<a name="l12612"></a>12612       <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot; =&gt; &quot;</span>, stream);
<a name="l12613"></a>12613       <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>);
<a name="l12614"></a>12614       <span class="keywordflow">return</span>;
<a name="l12615"></a>12615       
<a name="l12616"></a>12616     <span class="keywordflow">case</span> OP_POSITIONAL:
<a name="l12617"></a>12617       <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>);
<a name="l12618"></a>12618       <span class="keywordflow">return</span>;
<a name="l12619"></a>12619 
<a name="l12620"></a>12620     <span class="keywordflow">case</span> OP_AGGREGATE:
<a name="l12621"></a>12621       <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot;(&quot;</span>, stream);
<a name="l12622"></a>12622       <span class="keywordflow">for</span> (i = 0; i &lt; nargs; i += 1)
<a name="l12623"></a>12623         {
<a name="l12624"></a>12624           <span class="keywordflow">if</span> (i &gt; 0)
<a name="l12625"></a>12625             <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot;, &quot;</span>, stream);
<a name="l12626"></a>12626           <a class="code" href="expprint_8c.html#af5a6bb4e8f767fa7cf81bad9769d7120">print_subexp</a> (exp, pos, stream, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>);
<a name="l12627"></a>12627         }
<a name="l12628"></a>12628       <a class="code" href="utils_8c.html#a4b28488051faf9ab4a2f07633225835f">fputs_filtered</a> (<span class="stringliteral">&quot;)&quot;</span>, stream);
<a name="l12629"></a>12629       <span class="keywordflow">return</span>;
<a name="l12630"></a>12630     }
<a name="l12631"></a>12631 }
<a name="l12632"></a>12632 
<a name="l12633"></a>12633 <span class="comment">/* Table mapping opcodes into strings for printing operators</span>
<a name="l12634"></a>12634 <span class="comment">   and precedences of the operators.  */</span>
<a name="l12635"></a>12635 
<a name="l12636"></a>12636 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structop__print.html">op_print</a> ada_op_print_tab[] = {
<a name="l12637"></a>12637   {<span class="stringliteral">&quot;:=&quot;</span>, BINOP_ASSIGN, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aa5e92f27b45854d3fb0eec6a7a124de27">PREC_ASSIGN</a>, 1},
<a name="l12638"></a>12638   {<span class="stringliteral">&quot;or else&quot;</span>, BINOP_LOGICAL_OR, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aa64fa270482d302628e98c685632f4268">PREC_LOGICAL_OR</a>, 0},
<a name="l12639"></a>12639   {<span class="stringliteral">&quot;and then&quot;</span>, BINOP_LOGICAL_AND, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aaf6f26d1f69e85719e3acdb44ac4ee4ee">PREC_LOGICAL_AND</a>, 0},
<a name="l12640"></a>12640   {<span class="stringliteral">&quot;or&quot;</span>, BINOP_BITWISE_IOR, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aaf353c85696ff7bc39d5017c1a9203372">PREC_BITWISE_IOR</a>, 0},
<a name="l12641"></a>12641   {<span class="stringliteral">&quot;xor&quot;</span>, BINOP_BITWISE_XOR, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aa875ea1a069608469e9aa3bb74191d912">PREC_BITWISE_XOR</a>, 0},
<a name="l12642"></a>12642   {<span class="stringliteral">&quot;and&quot;</span>, BINOP_BITWISE_AND, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aaadadbfbd7d5f8fb39a22da4c406567ef">PREC_BITWISE_AND</a>, 0},
<a name="l12643"></a>12643   {<span class="stringliteral">&quot;=&quot;</span>, BINOP_EQUAL, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aab4f80761770aecaaa11be998cb32be94">PREC_EQUAL</a>, 0},
<a name="l12644"></a>12644   {<span class="stringliteral">&quot;/=&quot;</span>, BINOP_NOTEQUAL, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aab4f80761770aecaaa11be998cb32be94">PREC_EQUAL</a>, 0},
<a name="l12645"></a>12645   {<span class="stringliteral">&quot;&lt;=&quot;</span>, BINOP_LEQ, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aabe35ff2127b6931e77edf2b2c9ebb808">PREC_ORDER</a>, 0},
<a name="l12646"></a>12646   {<span class="stringliteral">&quot;&gt;=&quot;</span>, BINOP_GEQ, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aabe35ff2127b6931e77edf2b2c9ebb808">PREC_ORDER</a>, 0},
<a name="l12647"></a>12647   {<span class="stringliteral">&quot;&gt;&quot;</span>, BINOP_GTR, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aabe35ff2127b6931e77edf2b2c9ebb808">PREC_ORDER</a>, 0},
<a name="l12648"></a>12648   {<span class="stringliteral">&quot;&lt;&quot;</span>, BINOP_LESS, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aabe35ff2127b6931e77edf2b2c9ebb808">PREC_ORDER</a>, 0},
<a name="l12649"></a>12649   {<span class="stringliteral">&quot;&gt;&gt;&quot;</span>, BINOP_RSH, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aa2a8605af70bc30b107eb374ba1fa24f1">PREC_SHIFT</a>, 0},
<a name="l12650"></a>12650   {<span class="stringliteral">&quot;&lt;&lt;&quot;</span>, BINOP_LSH, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aa2a8605af70bc30b107eb374ba1fa24f1">PREC_SHIFT</a>, 0},
<a name="l12651"></a>12651   {<span class="stringliteral">&quot;+&quot;</span>, BINOP_ADD, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aa75d26b179930f86774fd523647ab0016">PREC_ADD</a>, 0},
<a name="l12652"></a>12652   {<span class="stringliteral">&quot;-&quot;</span>, BINOP_SUB, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aa75d26b179930f86774fd523647ab0016">PREC_ADD</a>, 0},
<a name="l12653"></a>12653   {<span class="stringliteral">&quot;&amp;&quot;</span>, BINOP_CONCAT, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aa75d26b179930f86774fd523647ab0016">PREC_ADD</a>, 0},
<a name="l12654"></a>12654   {<span class="stringliteral">&quot;*&quot;</span>, BINOP_MUL, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aac911cdbd79edb8f68cd50c2dbdf4109a">PREC_MUL</a>, 0},
<a name="l12655"></a>12655   {<span class="stringliteral">&quot;/&quot;</span>, BINOP_DIV, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aac911cdbd79edb8f68cd50c2dbdf4109a">PREC_MUL</a>, 0},
<a name="l12656"></a>12656   {<span class="stringliteral">&quot;rem&quot;</span>, BINOP_REM, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aac911cdbd79edb8f68cd50c2dbdf4109a">PREC_MUL</a>, 0},
<a name="l12657"></a>12657   {<span class="stringliteral">&quot;mod&quot;</span>, BINOP_MOD, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aac911cdbd79edb8f68cd50c2dbdf4109a">PREC_MUL</a>, 0},
<a name="l12658"></a>12658   {<span class="stringliteral">&quot;**&quot;</span>, BINOP_EXP, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aae279f8bb77ff7e4e18e893a118c5687e">PREC_REPEAT</a>, 0},
<a name="l12659"></a>12659   {<span class="stringliteral">&quot;@&quot;</span>, BINOP_REPEAT, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aae279f8bb77ff7e4e18e893a118c5687e">PREC_REPEAT</a>, 0},
<a name="l12660"></a>12660   {<span class="stringliteral">&quot;-&quot;</span>, UNOP_NEG, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aa5ee2ba062f4296b69ca2878e3133ff6e">PREC_PREFIX</a>, 0},
<a name="l12661"></a>12661   {<span class="stringliteral">&quot;+&quot;</span>, UNOP_PLUS, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aa5ee2ba062f4296b69ca2878e3133ff6e">PREC_PREFIX</a>, 0},
<a name="l12662"></a>12662   {<span class="stringliteral">&quot;not &quot;</span>, UNOP_LOGICAL_NOT, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aa5ee2ba062f4296b69ca2878e3133ff6e">PREC_PREFIX</a>, 0},
<a name="l12663"></a>12663   {<span class="stringliteral">&quot;not &quot;</span>, UNOP_COMPLEMENT, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aa5ee2ba062f4296b69ca2878e3133ff6e">PREC_PREFIX</a>, 0},
<a name="l12664"></a>12664   {<span class="stringliteral">&quot;abs &quot;</span>, UNOP_ABS, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aa5ee2ba062f4296b69ca2878e3133ff6e">PREC_PREFIX</a>, 0},
<a name="l12665"></a>12665   {<span class="stringliteral">&quot;.all&quot;</span>, UNOP_IND, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>, 1},
<a name="l12666"></a>12666   {<span class="stringliteral">&quot;&#39;access&quot;</span>, UNOP_ADDR, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>, 1},
<a name="l12667"></a>12667   {<span class="stringliteral">&quot;&#39;size&quot;</span>, OP_ATR_SIZE, <a class="code" href="parser-defs_8h.html#a7ba15b09f5921966959e0abb2e1d3e4aadc6d48542f0442d8e2fede72bd0b3976">PREC_SUFFIX</a>, 1},
<a name="l12668"></a>12668   {NULL, 0, 0, 0}
<a name="l12669"></a>12669 };
<a name="l12670"></a>12670 
<a name="l12671"></a><a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95">12671</a> <span class="keyword">enum</span> <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95">ada_primitive_types</a> {
<a name="l12672"></a><a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a321818350af32c87e776deec1bf6d906">12672</a>   <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a321818350af32c87e776deec1bf6d906">ada_primitive_type_int</a>,
<a name="l12673"></a><a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a8e593b72e17a6e4becd7be85eab764b6">12673</a>   <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a8e593b72e17a6e4becd7be85eab764b6">ada_primitive_type_long</a>,
<a name="l12674"></a><a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a577852fab11dadb7d2823ea74811e0ba">12674</a>   <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a577852fab11dadb7d2823ea74811e0ba">ada_primitive_type_short</a>,
<a name="l12675"></a><a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95abd3b06690157be4c6bacb8a067bdb8b1">12675</a>   <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95abd3b06690157be4c6bacb8a067bdb8b1">ada_primitive_type_char</a>,
<a name="l12676"></a><a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a73e698fc2e325ab1b3b3b4c69f138a44">12676</a>   <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a73e698fc2e325ab1b3b3b4c69f138a44">ada_primitive_type_float</a>,
<a name="l12677"></a><a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a4efd29aa54b5ddcb4edceb24eb08a947">12677</a>   <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a4efd29aa54b5ddcb4edceb24eb08a947">ada_primitive_type_double</a>,
<a name="l12678"></a><a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95ac16ca7eb1092a34627605fccffef782d">12678</a>   <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95ac16ca7eb1092a34627605fccffef782d">ada_primitive_type_void</a>,
<a name="l12679"></a><a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a75c76f48d54fa2cc135454b44ba92425">12679</a>   <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a75c76f48d54fa2cc135454b44ba92425">ada_primitive_type_long_long</a>,
<a name="l12680"></a><a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95aaf5d9622f0752242cb79298e1ad15127">12680</a>   <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95aaf5d9622f0752242cb79298e1ad15127">ada_primitive_type_long_double</a>,
<a name="l12681"></a><a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a777c83141b9789f63dd3b17e471b8e3f">12681</a>   <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a777c83141b9789f63dd3b17e471b8e3f">ada_primitive_type_natural</a>,
<a name="l12682"></a><a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a76c02864e243e47488f29dcea4d34585">12682</a>   <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a76c02864e243e47488f29dcea4d34585">ada_primitive_type_positive</a>,
<a name="l12683"></a><a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95abc7932aaab806abbfab2cac30a551efb">12683</a>   <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95abc7932aaab806abbfab2cac30a551efb">ada_primitive_type_system_address</a>,
<a name="l12684"></a><a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95aaa5aef23511852e5234c5157eef96da5">12684</a>   <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95aaa5aef23511852e5234c5157eef96da5">nr_ada_primitive_types</a>
<a name="l12685"></a>12685 };
<a name="l12686"></a>12686 
<a name="l12687"></a>12687 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12688"></a>12688 ada_language_arch_info (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l12689"></a>12689                         <span class="keyword">struct</span> <a class="code" href="structlanguage__arch__info.html">language_arch_info</a> *lai)
<a name="l12690"></a>12690 {
<a name="l12691"></a>12691   <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structbuiltin__type.html">builtin_type</a> *builtin = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch);
<a name="l12692"></a>12692 
<a name="l12693"></a>12693   lai-&gt;<a class="code" href="structlanguage__arch__info.html#ae2f7fe7a273dafc97e3564d0a3676c7a">primitive_type_vector</a>
<a name="l12694"></a>12694     = <a class="code" href="gdbarch_8h.html#a549a8eb8c7bf7b3ceeead14005516d80">GDBARCH_OBSTACK_CALLOC</a> (gdbarch, <a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95aaa5aef23511852e5234c5157eef96da5">nr_ada_primitive_types</a> + 1,
<a name="l12695"></a>12695                               <span class="keyword">struct</span> type *);
<a name="l12696"></a>12696 
<a name="l12697"></a>12697   lai-&gt;<a class="code" href="structlanguage__arch__info.html#ae2f7fe7a273dafc97e3564d0a3676c7a">primitive_type_vector</a> [<a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a321818350af32c87e776deec1bf6d906">ada_primitive_type_int</a>]
<a name="l12698"></a>12698     = <a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (gdbarch, <a class="code" href="gdbarch_8c.html#a6f4f4c6b17870bbd5de1f5e2776f774b">gdbarch_int_bit</a> (gdbarch),
<a name="l12699"></a>12699                          0, <span class="stringliteral">&quot;integer&quot;</span>);
<a name="l12700"></a>12700   lai-&gt;<a class="code" href="structlanguage__arch__info.html#ae2f7fe7a273dafc97e3564d0a3676c7a">primitive_type_vector</a> [<a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a8e593b72e17a6e4becd7be85eab764b6">ada_primitive_type_long</a>]
<a name="l12701"></a>12701     = <a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (gdbarch, <a class="code" href="gdbarch_8c.html#adba59f763c7dd284b240b703c12d149a">gdbarch_long_bit</a> (gdbarch),
<a name="l12702"></a>12702                          0, <span class="stringliteral">&quot;long_integer&quot;</span>);
<a name="l12703"></a>12703   lai-&gt;<a class="code" href="structlanguage__arch__info.html#ae2f7fe7a273dafc97e3564d0a3676c7a">primitive_type_vector</a> [<a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a577852fab11dadb7d2823ea74811e0ba">ada_primitive_type_short</a>]
<a name="l12704"></a>12704     = <a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (gdbarch, <a class="code" href="gdbarch_8c.html#a543f575b65687dd09237c646c0d5738f">gdbarch_short_bit</a> (gdbarch),
<a name="l12705"></a>12705                          0, <span class="stringliteral">&quot;short_integer&quot;</span>);
<a name="l12706"></a>12706   lai-&gt;<a class="code" href="structlanguage__arch__info.html#a9df1511778000393f968580071b67220">string_char_type</a>
<a name="l12707"></a>12707     = lai-&gt;<a class="code" href="structlanguage__arch__info.html#ae2f7fe7a273dafc97e3564d0a3676c7a">primitive_type_vector</a> [<a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95abd3b06690157be4c6bacb8a067bdb8b1">ada_primitive_type_char</a>]
<a name="l12708"></a>12708     = <a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (gdbarch, TARGET_CHAR_BIT, 0, <span class="stringliteral">&quot;character&quot;</span>);
<a name="l12709"></a>12709   lai-&gt;<a class="code" href="structlanguage__arch__info.html#ae2f7fe7a273dafc97e3564d0a3676c7a">primitive_type_vector</a> [<a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a73e698fc2e325ab1b3b3b4c69f138a44">ada_primitive_type_float</a>]
<a name="l12710"></a>12710     = <a class="code" href="gdbtypes_8c.html#a793ccf335a07069a67a654084cd4a513">arch_float_type</a> (gdbarch, <a class="code" href="gdbarch_8c.html#a72c33b4f85bf2f81498943a8cf3c0e05">gdbarch_float_bit</a> (gdbarch),
<a name="l12711"></a>12711                        <span class="stringliteral">&quot;float&quot;</span>, NULL);
<a name="l12712"></a>12712   lai-&gt;<a class="code" href="structlanguage__arch__info.html#ae2f7fe7a273dafc97e3564d0a3676c7a">primitive_type_vector</a> [<a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a4efd29aa54b5ddcb4edceb24eb08a947">ada_primitive_type_double</a>]
<a name="l12713"></a>12713     = <a class="code" href="gdbtypes_8c.html#a793ccf335a07069a67a654084cd4a513">arch_float_type</a> (gdbarch, <a class="code" href="gdbarch_8c.html#aeb804f8a91c27405b672887d29b5f05b">gdbarch_double_bit</a> (gdbarch),
<a name="l12714"></a>12714                        <span class="stringliteral">&quot;long_float&quot;</span>, NULL);
<a name="l12715"></a>12715   lai-&gt;<a class="code" href="structlanguage__arch__info.html#ae2f7fe7a273dafc97e3564d0a3676c7a">primitive_type_vector</a> [<a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a75c76f48d54fa2cc135454b44ba92425">ada_primitive_type_long_long</a>]
<a name="l12716"></a>12716     = <a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (gdbarch, <a class="code" href="gdbarch_8c.html#a4e51936b4aecd9d9a3955e167501c8f1">gdbarch_long_long_bit</a> (gdbarch),
<a name="l12717"></a>12717                          0, <span class="stringliteral">&quot;long_long_integer&quot;</span>);
<a name="l12718"></a>12718   lai-&gt;<a class="code" href="structlanguage__arch__info.html#ae2f7fe7a273dafc97e3564d0a3676c7a">primitive_type_vector</a> [<a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95aaf5d9622f0752242cb79298e1ad15127">ada_primitive_type_long_double</a>]
<a name="l12719"></a>12719     = <a class="code" href="gdbtypes_8c.html#a793ccf335a07069a67a654084cd4a513">arch_float_type</a> (gdbarch, <a class="code" href="gdbarch_8c.html#aeb804f8a91c27405b672887d29b5f05b">gdbarch_double_bit</a> (gdbarch),
<a name="l12720"></a>12720                        <span class="stringliteral">&quot;long_long_float&quot;</span>, NULL);
<a name="l12721"></a>12721   lai-&gt;<a class="code" href="structlanguage__arch__info.html#ae2f7fe7a273dafc97e3564d0a3676c7a">primitive_type_vector</a> [<a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a777c83141b9789f63dd3b17e471b8e3f">ada_primitive_type_natural</a>]
<a name="l12722"></a>12722     = <a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (gdbarch, <a class="code" href="gdbarch_8c.html#a6f4f4c6b17870bbd5de1f5e2776f774b">gdbarch_int_bit</a> (gdbarch),
<a name="l12723"></a>12723                          0, <span class="stringliteral">&quot;natural&quot;</span>);
<a name="l12724"></a>12724   lai-&gt;<a class="code" href="structlanguage__arch__info.html#ae2f7fe7a273dafc97e3564d0a3676c7a">primitive_type_vector</a> [<a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95a76c02864e243e47488f29dcea4d34585">ada_primitive_type_positive</a>]
<a name="l12725"></a>12725     = <a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (gdbarch, <a class="code" href="gdbarch_8c.html#a6f4f4c6b17870bbd5de1f5e2776f774b">gdbarch_int_bit</a> (gdbarch),
<a name="l12726"></a>12726                          0, <span class="stringliteral">&quot;positive&quot;</span>);
<a name="l12727"></a>12727   lai-&gt;<a class="code" href="structlanguage__arch__info.html#ae2f7fe7a273dafc97e3564d0a3676c7a">primitive_type_vector</a> [<a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95ac16ca7eb1092a34627605fccffef782d">ada_primitive_type_void</a>]
<a name="l12728"></a>12728     = builtin-&gt;<a class="code" href="structbuiltin__type.html#ae1b424251656c129a027977d3c0ea066">builtin_void</a>;
<a name="l12729"></a>12729 
<a name="l12730"></a>12730   lai-&gt;<a class="code" href="structlanguage__arch__info.html#ae2f7fe7a273dafc97e3564d0a3676c7a">primitive_type_vector</a> [<a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95abc7932aaab806abbfab2cac30a551efb">ada_primitive_type_system_address</a>]
<a name="l12731"></a>12731     = <a class="code" href="gdbtypes_8c.html#a8edb8d75a169b1455414b420088d1887">lookup_pointer_type</a> (<a class="code" href="gdbtypes_8c.html#a4b444f0f6cfacb3f35d68fd7866402e2">arch_type</a> (gdbarch, <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>, 1, <span class="stringliteral">&quot;void&quot;</span>));
<a name="l12732"></a>12732   <a class="code" href="gdbtypes_8h.html#a60f6434779617e9ff9c60121ceb25015">TYPE_NAME</a> (lai-&gt;<a class="code" href="structlanguage__arch__info.html#ae2f7fe7a273dafc97e3564d0a3676c7a">primitive_type_vector</a> [<a class="code" href="ada-lang_8c.html#a4de37904a1b46b59c4cae1cb4ac81f95abc7932aaab806abbfab2cac30a551efb">ada_primitive_type_system_address</a>])
<a name="l12733"></a>12733     = <span class="stringliteral">&quot;system__address&quot;</span>;
<a name="l12734"></a>12734 
<a name="l12735"></a>12735   lai-&gt;<a class="code" href="structlanguage__arch__info.html#af4d9c147f7ac12e01abddf2418afa666">bool_type_symbol</a> = NULL;
<a name="l12736"></a>12736   lai-&gt;<a class="code" href="structlanguage__arch__info.html#a20c98528276dd045a787bd6f08ec5440">bool_type_default</a> = builtin-&gt;<a class="code" href="structbuiltin__type.html#a57a89bd1fdc8856566719d1dd9ccb4b1">builtin_bool</a>;
<a name="l12737"></a>12737 }
<a name="l12738"></a>12738 
<a name="l12739"></a>12739                                 <span class="comment">/* Language vector */</span>
<a name="l12740"></a>12740 
<a name="l12741"></a>12741 <span class="comment">/* Not really used, but needed in the ada_language_defn.  */</span>
<a name="l12742"></a>12742 
<a name="l12743"></a>12743 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12744"></a>12744 emit_char (<span class="keywordtype">int</span> c, <span class="keyword">struct</span> type *type, <span class="keyword">struct</span> ui_file *stream, <span class="keywordtype">int</span> quoter)
<a name="l12745"></a>12745 {
<a name="l12746"></a>12746   <a class="code" href="ada-lang_8h.html#a542bb61f2782c18e06157a61e8bd52b9">ada_emit_char</a> (c, type, stream, quoter, 1);
<a name="l12747"></a>12747 }
<a name="l12748"></a>12748 
<a name="l12749"></a>12749 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l12750"></a>12750 parse (<span class="keywordtype">void</span>)
<a name="l12751"></a>12751 {
<a name="l12752"></a>12752   warnings_issued = 0;
<a name="l12753"></a>12753   <span class="keywordflow">return</span> <a class="code" href="ada-lang_8h.html#a404a044bb596b619e57bd6fb0fb9dc7e">ada_parse</a> ();
<a name="l12754"></a>12754 }
<a name="l12755"></a>12755 
<a name="l12756"></a>12756 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structexp__descriptor.html">exp_descriptor</a> ada_exp_descriptor = {
<a name="l12757"></a>12757   ada_print_subexp,
<a name="l12758"></a>12758   ada_operator_length,
<a name="l12759"></a>12759   ada_operator_check,
<a name="l12760"></a>12760   ada_op_name,
<a name="l12761"></a>12761   ada_dump_subexp_body,
<a name="l12762"></a>12762   ada_evaluate_subexp
<a name="l12763"></a>12763 };
<a name="l12764"></a>12764 
<a name="l12765"></a>12765 <span class="comment">/* Implement the &quot;la_get_symbol_name_cmp&quot; language_defn method</span>
<a name="l12766"></a>12766 <span class="comment">   for Ada.  */</span>
<a name="l12767"></a>12767 
<a name="l12768"></a>12768 <span class="keyword">static</span> <a class="code" href="language_8h.html#a11b69c55d697057ff7350b55851b671b">symbol_name_cmp_ftype</a>
<a name="l12769"></a>12769 ada_get_symbol_name_cmp (<span class="keyword">const</span> <span class="keywordtype">char</span> *lookup_name)
<a name="l12770"></a>12770 {
<a name="l12771"></a>12771   <span class="keywordflow">if</span> (should_use_wild_match (lookup_name))
<a name="l12772"></a>12772     <span class="keywordflow">return</span> wild_match;
<a name="l12773"></a>12773   <span class="keywordflow">else</span>
<a name="l12774"></a>12774     <span class="keywordflow">return</span> compare_names;
<a name="l12775"></a>12775 }
<a name="l12776"></a>12776 
<a name="l12777"></a>12777 <span class="comment">/* Implement the &quot;la_read_var_value&quot; language_defn method for Ada.  */</span>
<a name="l12778"></a>12778 
<a name="l12779"></a>12779 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l12780"></a>12780 ada_read_var_value (<span class="keyword">struct</span> <a class="code" href="structsymbol.html">symbol</a> *var, <span class="keyword">struct</span> frame_info *frame)
<a name="l12781"></a>12781 {
<a name="l12782"></a>12782   <span class="keyword">struct </span>block *frame_block = NULL;
<a name="l12783"></a>12783   <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *renaming_sym = NULL;
<a name="l12784"></a>12784 
<a name="l12785"></a>12785   <span class="comment">/* The only case where default_read_var_value is not sufficient</span>
<a name="l12786"></a>12786 <span class="comment">     is when VAR is a renaming...  */</span>
<a name="l12787"></a>12787   <span class="keywordflow">if</span> (frame)
<a name="l12788"></a>12788     frame_block = <a class="code" href="blockframe_8c.html#a48cd98610b3a7f167334b616336cadfb">get_frame_block</a> (frame, NULL);
<a name="l12789"></a>12789   <span class="keywordflow">if</span> (frame_block)
<a name="l12790"></a>12790     renaming_sym = <a class="code" href="ada-lang_8c.html#a0d1969cf813f4b68d44fe1c9839bd864">ada_find_renaming_symbol</a> (var, frame_block);
<a name="l12791"></a>12791   <span class="keywordflow">if</span> (renaming_sym != NULL)
<a name="l12792"></a>12792     <span class="keywordflow">return</span> ada_read_renaming_var_value (renaming_sym, frame_block);
<a name="l12793"></a>12793 
<a name="l12794"></a>12794   <span class="comment">/* This is a typical case where we expect the default_read_var_value</span>
<a name="l12795"></a>12795 <span class="comment">     function to work.  */</span>
<a name="l12796"></a>12796   <span class="keywordflow">return</span> <a class="code" href="findvar_8c.html#a4397d3c19060201bb4fe2d679245f6dd">default_read_var_value</a> (var, frame);
<a name="l12797"></a>12797 }
<a name="l12798"></a>12798 
<a name="l12799"></a><a class="code" href="ada-lang_8c.html#a1629c5e08b4a9a275d5bdf474bed1ec0">12799</a> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structlanguage__defn.html">language_defn</a> <a class="code" href="ada-lang_8c.html#a1629c5e08b4a9a275d5bdf474bed1ec0">ada_language_defn</a> = {
<a name="l12800"></a>12800   <span class="stringliteral">&quot;ada&quot;</span>,                        <span class="comment">/* Language name */</span>
<a name="l12801"></a>12801   <a class="code" href="defs_8h.html#aa37aa8979934d47ac32fd96ecff32202a1ecb230e4f06c0f2f30b97470a2ef621">language_ada</a>,
<a name="l12802"></a>12802   <a class="code" href="language_8h.html#a8202735d4285cea82932facdabf35566aec4bbab89cf0e990b8ffa2dbb5496f86">range_check_off</a>,
<a name="l12803"></a>12803   <a class="code" href="language_8h.html#ad102f9e1a41cf77a0045e37883dd2940a236ce0a37504b1c7b4f94f8236707e36">case_sensitive_on</a>,            <span class="comment">/* Yes, Ada is case-insensitive, but</span>
<a name="l12804"></a>12804 <span class="comment">                                   that&#39;s not quite what this means.  */</span>
<a name="l12805"></a>12805   <a class="code" href="language_8h.html#a01793f9b076697670fa7f9c07d925315a8a2dbbdfa4f6850059d3d27c26258d4a">array_row_major</a>,
<a name="l12806"></a>12806   <a class="code" href="language_8h.html#a511881683e72b52d0e2a3f2d561a6d2fa6e45788a6b1223fd0886ac44d761c823">macro_expansion_no</a>,
<a name="l12807"></a>12807   &amp;ada_exp_descriptor,
<a name="l12808"></a>12808   parse,
<a name="l12809"></a>12809   <a class="code" href="ada-lang_8h.html#a96a98efdfca8729d033450eae4c1d4eb">ada_error</a>,
<a name="l12810"></a>12810   <a class="code" href="sol-thread_8c.html#abbb193592c924dcda7896a284d3bd592">resolve</a>,
<a name="l12811"></a>12811   <a class="code" href="ada-lang_8h.html#a4444655161504d5a4057603534062fce">ada_printchar</a>,                <span class="comment">/* Print a character constant */</span>
<a name="l12812"></a>12812   <a class="code" href="ada-lang_8h.html#aa42b87a6d7a8586c94042be10ffcd4c0">ada_printstr</a>,                 <span class="comment">/* Function to print string constant */</span>
<a name="l12813"></a>12813   emit_char,                    <span class="comment">/* Function to print single char (not used) */</span>
<a name="l12814"></a>12814   <a class="code" href="ada-lang_8h.html#a30df4f3f0e5ed3346f73d2be79adcfbc">ada_print_type</a>,               <span class="comment">/* Print a type using appropriate syntax */</span>
<a name="l12815"></a>12815   <a class="code" href="ada-lang_8h.html#a570412c72d613e09fe911d2c6d49be10">ada_print_typedef</a>,            <span class="comment">/* Print a typedef using appropriate syntax */</span>
<a name="l12816"></a>12816   <a class="code" href="ada-lang_8h.html#af494d92cae521bbc5120b45955fa0a39">ada_val_print</a>,                <span class="comment">/* Print a value using appropriate syntax */</span>
<a name="l12817"></a>12817   <a class="code" href="ada-lang_8h.html#a0f64e752cafb8cb6087f25f891d07f67">ada_value_print</a>,              <span class="comment">/* Print a top-level value */</span>
<a name="l12818"></a>12818   ada_read_var_value,           <span class="comment">/* la_read_var_value */</span>
<a name="l12819"></a>12819   NULL,                         <span class="comment">/* Language specific skip_trampoline */</span>
<a name="l12820"></a>12820   NULL,                         <span class="comment">/* name_of_this */</span>
<a name="l12821"></a>12821   ada_lookup_symbol_nonlocal,   <span class="comment">/* Looking up non-local symbols.  */</span>
<a name="l12822"></a>12822   <a class="code" href="symtab_8c.html#a952bee3396047112c61476d5952dfb1e">basic_lookup_transparent_type</a>,        <span class="comment">/* lookup_transparent_type */</span>
<a name="l12823"></a>12823   ada_la_decode,                <span class="comment">/* Language specific symbol demangler */</span>
<a name="l12824"></a>12824   NULL,                         <span class="comment">/* Language specific</span>
<a name="l12825"></a>12825 <span class="comment">                                   class_name_from_physname */</span>
<a name="l12826"></a>12826   ada_op_print_tab,             <span class="comment">/* expression operators for printing */</span>
<a name="l12827"></a>12827   0,                            <span class="comment">/* c-style arrays */</span>
<a name="l12828"></a>12828   1,                            <span class="comment">/* String lower bound */</span>
<a name="l12829"></a>12829   ada_get_gdb_completer_word_break_characters,
<a name="l12830"></a>12830   ada_make_symbol_completion_list,
<a name="l12831"></a>12831   ada_language_arch_info,
<a name="l12832"></a>12832   ada_print_array_index,
<a name="l12833"></a>12833   <a class="code" href="language_8c.html#a037e46fb8e24b253e3ac84a02bfab53e">default_pass_by_reference</a>,
<a name="l12834"></a>12834   <a class="code" href="c-lang_8c.html#afec1faf129f343fad0cf0813571615f2">c_get_string</a>,
<a name="l12835"></a>12835   ada_get_symbol_name_cmp,      <span class="comment">/* la_get_symbol_name_cmp */</span>
<a name="l12836"></a>12836   ada_iterate_over_symbols,
<a name="l12837"></a>12837   <a class="code" href="language_8h.html#adaa27b8c7c639f32b42b1b37c83d863a">LANG_MAGIC</a>
<a name="l12838"></a>12838 };
<a name="l12839"></a>12839 
<a name="l12840"></a>12840 <span class="comment">/* Provide a prototype to silence -Wmissing-prototypes.  */</span>
<a name="l12841"></a>12841 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#a686ed07d4fdcdc366f2bc677216ca08d">initialize_file_ftype</a> <a class="code" href="ada-lang_8c.html#aacad6c2806d9596801ae5e3c310540e3">_initialize_ada_language</a>;
<a name="l12842"></a>12842 
<a name="l12843"></a>12843 <span class="comment">/* Command-list for the &quot;set/show ada&quot; prefix command.  */</span>
<a name="l12844"></a>12844 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcmd__list__element.html">cmd_list_element</a> *set_ada_list;
<a name="l12845"></a>12845 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcmd__list__element.html">cmd_list_element</a> *show_ada_list;
<a name="l12846"></a>12846 
<a name="l12847"></a>12847 <span class="comment">/* Implement the &quot;set ada&quot; prefix command.  */</span>
<a name="l12848"></a>12848 
<a name="l12849"></a>12849 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12850"></a>12850 set_ada_command (<span class="keywordtype">char</span> *arg, <span class="keywordtype">int</span> from_tty)
<a name="l12851"></a>12851 {
<a name="l12852"></a>12852   <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(\
<a name="l12853"></a>12853 <span class="stringliteral">&quot;\&quot;set ada\&quot; must be followed by the name of a setting.\n&quot;</span>));
<a name="l12854"></a>12854   <a class="code" href="cli-decode_8c.html#a2ae762f5189f3597666852868defc038">help_list</a> (set_ada_list, <span class="stringliteral">&quot;set ada &quot;</span>, -1, <a class="code" href="main_8c.html#a41a2b997ba5454df787d61f051dd918c">gdb_stdout</a>);
<a name="l12855"></a>12855 }
<a name="l12856"></a>12856 
<a name="l12857"></a>12857 <span class="comment">/* Implement the &quot;show ada&quot; prefix command.  */</span>
<a name="l12858"></a>12858 
<a name="l12859"></a>12859 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12860"></a>12860 show_ada_command (<span class="keywordtype">char</span> *args, <span class="keywordtype">int</span> from_tty)
<a name="l12861"></a>12861 {
<a name="l12862"></a>12862   <a class="code" href="cli-setshow_8c.html#acad906a9e078be9cde70874ab62b1b1e">cmd_show_list</a> (show_ada_list, from_tty, <span class="stringliteral">&quot;&quot;</span>);
<a name="l12863"></a>12863 }
<a name="l12864"></a>12864 
<a name="l12865"></a>12865 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l12866"></a>12866 initialize_ada_catchpoint_ops (<span class="keywordtype">void</span>)
<a name="l12867"></a>12867 {
<a name="l12868"></a>12868   <span class="keyword">struct </span><a class="code" href="structbreakpoint__ops.html">breakpoint_ops</a> *ops;
<a name="l12869"></a>12869 
<a name="l12870"></a>12870   <a class="code" href="breakpoint_8c.html#a1576e03931c016f098138a3e4cfabb66">initialize_breakpoint_ops</a> ();
<a name="l12871"></a>12871 
<a name="l12872"></a>12872   ops = &amp;catch_exception_breakpoint_ops;
<a name="l12873"></a>12873   *ops = <a class="code" href="breakpoint_8c.html#a9b47dd7cd982ec63ffd303246d93cf7a">bkpt_breakpoint_ops</a>;
<a name="l12874"></a>12874   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a110b2df7b285e5f83bf40b9a0e5435c1">dtor</a> = dtor_catch_exception;
<a name="l12875"></a>12875   ops-&gt;<a class="code" href="structbreakpoint__ops.html#af3730c70eacc8638a63a7ce00581efdc">allocate_location</a> = allocate_location_catch_exception;
<a name="l12876"></a>12876   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a42f6ff20f3eb39f78874c914d34e09b5">re_set</a> = re_set_catch_exception;
<a name="l12877"></a>12877   ops-&gt;<a class="code" href="structbreakpoint__ops.html#afd5b5a27bf4d9d9d49b267507b0633c4">check_status</a> = check_status_catch_exception;
<a name="l12878"></a>12878   ops-&gt;<a class="code" href="structbreakpoint__ops.html#aa8d21fdff10f7839583383d6397fe6a0">print_it</a> = print_it_catch_exception;
<a name="l12879"></a>12879   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a20a11e27ae594ff232488495fd0a0476">print_one</a> = print_one_catch_exception;
<a name="l12880"></a>12880   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a56e47601d6d5230479033e7b7b2d910e">print_mention</a> = print_mention_catch_exception;
<a name="l12881"></a>12881   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a218bc56decfb6ebbcf35def58b7dd271">print_recreate</a> = print_recreate_catch_exception;
<a name="l12882"></a>12882 
<a name="l12883"></a>12883   ops = &amp;catch_exception_unhandled_breakpoint_ops;
<a name="l12884"></a>12884   *ops = <a class="code" href="breakpoint_8c.html#a9b47dd7cd982ec63ffd303246d93cf7a">bkpt_breakpoint_ops</a>;
<a name="l12885"></a>12885   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a110b2df7b285e5f83bf40b9a0e5435c1">dtor</a> = dtor_catch_exception_unhandled;
<a name="l12886"></a>12886   ops-&gt;<a class="code" href="structbreakpoint__ops.html#af3730c70eacc8638a63a7ce00581efdc">allocate_location</a> = allocate_location_catch_exception_unhandled;
<a name="l12887"></a>12887   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a42f6ff20f3eb39f78874c914d34e09b5">re_set</a> = re_set_catch_exception_unhandled;
<a name="l12888"></a>12888   ops-&gt;<a class="code" href="structbreakpoint__ops.html#afd5b5a27bf4d9d9d49b267507b0633c4">check_status</a> = check_status_catch_exception_unhandled;
<a name="l12889"></a>12889   ops-&gt;<a class="code" href="structbreakpoint__ops.html#aa8d21fdff10f7839583383d6397fe6a0">print_it</a> = print_it_catch_exception_unhandled;
<a name="l12890"></a>12890   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a20a11e27ae594ff232488495fd0a0476">print_one</a> = print_one_catch_exception_unhandled;
<a name="l12891"></a>12891   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a56e47601d6d5230479033e7b7b2d910e">print_mention</a> = print_mention_catch_exception_unhandled;
<a name="l12892"></a>12892   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a218bc56decfb6ebbcf35def58b7dd271">print_recreate</a> = print_recreate_catch_exception_unhandled;
<a name="l12893"></a>12893 
<a name="l12894"></a>12894   ops = &amp;catch_assert_breakpoint_ops;
<a name="l12895"></a>12895   *ops = <a class="code" href="breakpoint_8c.html#a9b47dd7cd982ec63ffd303246d93cf7a">bkpt_breakpoint_ops</a>;
<a name="l12896"></a>12896   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a110b2df7b285e5f83bf40b9a0e5435c1">dtor</a> = dtor_catch_assert;
<a name="l12897"></a>12897   ops-&gt;<a class="code" href="structbreakpoint__ops.html#af3730c70eacc8638a63a7ce00581efdc">allocate_location</a> = allocate_location_catch_assert;
<a name="l12898"></a>12898   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a42f6ff20f3eb39f78874c914d34e09b5">re_set</a> = re_set_catch_assert;
<a name="l12899"></a>12899   ops-&gt;<a class="code" href="structbreakpoint__ops.html#afd5b5a27bf4d9d9d49b267507b0633c4">check_status</a> = check_status_catch_assert;
<a name="l12900"></a>12900   ops-&gt;<a class="code" href="structbreakpoint__ops.html#aa8d21fdff10f7839583383d6397fe6a0">print_it</a> = print_it_catch_assert;
<a name="l12901"></a>12901   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a20a11e27ae594ff232488495fd0a0476">print_one</a> = print_one_catch_assert;
<a name="l12902"></a>12902   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a56e47601d6d5230479033e7b7b2d910e">print_mention</a> = print_mention_catch_assert;
<a name="l12903"></a>12903   ops-&gt;<a class="code" href="structbreakpoint__ops.html#a218bc56decfb6ebbcf35def58b7dd271">print_recreate</a> = print_recreate_catch_assert;
<a name="l12904"></a>12904 }
<a name="l12905"></a>12905 
<a name="l12906"></a>12906 <span class="keywordtype">void</span>
<a name="l12907"></a><a class="code" href="ada-lang_8c.html#a3e298ab82ce6befa07fac40ac0a5c7eb">12907</a> _initialize_ada_language (<span class="keywordtype">void</span>)
<a name="l12908"></a>12908 {
<a name="l12909"></a>12909   <a class="code" href="language_8c.html#acf669be4f23fee01f1d5ab3f7194df17">add_language</a> (&amp;ada_language_defn);
<a name="l12910"></a>12910 
<a name="l12911"></a>12911   initialize_ada_catchpoint_ops ();
<a name="l12912"></a>12912 
<a name="l12913"></a>12913   <a class="code" href="cli-decode_8c.html#a8abc1e9af59eb3cb12bb03977d5e8e5a">add_prefix_cmd</a> (<span class="stringliteral">&quot;ada&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49afbf489a4abce7e8770b178aa54f0908b">no_class</a>, set_ada_command,
<a name="l12914"></a>12914                   <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Prefix command for changing Ada-specfic settings&quot;</span>),
<a name="l12915"></a>12915                   &amp;set_ada_list, <span class="stringliteral">&quot;set ada &quot;</span>, 0, &amp;<a class="code" href="cli-cmds_8c.html#a723e0174d833cba0aa82fb936a56c8fa">setlist</a>);
<a name="l12916"></a>12916 
<a name="l12917"></a>12917   <a class="code" href="cli-decode_8c.html#a8abc1e9af59eb3cb12bb03977d5e8e5a">add_prefix_cmd</a> (<span class="stringliteral">&quot;ada&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49afbf489a4abce7e8770b178aa54f0908b">no_class</a>, show_ada_command,
<a name="l12918"></a>12918                   <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Generic command for showing Ada-specific settings.&quot;</span>),
<a name="l12919"></a>12919                   &amp;show_ada_list, <span class="stringliteral">&quot;show ada &quot;</span>, 0, &amp;<a class="code" href="cli-cmds_8c.html#a003932aa76fd3f41763ecc6bee5e2ca8">showlist</a>);
<a name="l12920"></a>12920 
<a name="l12921"></a>12921   <a class="code" href="cli-decode_8c.html#ad86a0f135b6c546ae7ffbb41fd72e14f">add_setshow_boolean_cmd</a> (<span class="stringliteral">&quot;trust-PAD-over-XVS&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a4994a96ac693a93b56bf997637605172">class_obscure</a>,
<a name="l12922"></a>12922                            &amp;trust_pad_over_xvs, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l12923"></a>12923 <span class="stringliteral">Enable or disable an optimization trusting PAD types over XVS types&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l12924"></a>12924 <span class="stringliteral">Show whether an optimization trusting PAD types over XVS types is activated&quot;</span>),
<a name="l12925"></a>12925                            <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l12926"></a>12926 <span class="stringliteral">This is related to the encoding used by the GNAT compiler.  The debugger\n\</span>
<a name="l12927"></a>12927 <span class="stringliteral">should normally trust the contents of PAD types, but certain older versions\n\</span>
<a name="l12928"></a>12928 <span class="stringliteral">of GNAT have a bug that sometimes causes the information in the PAD type\n\</span>
<a name="l12929"></a>12929 <span class="stringliteral">to be incorrect.  Turning this setting \&quot;off\&quot; allows the debugger to\n\</span>
<a name="l12930"></a>12930 <span class="stringliteral">work around this bug.  It is always safe to turn this option \&quot;off\&quot;, but\n\</span>
<a name="l12931"></a>12931 <span class="stringliteral">this incurs a slight performance penalty, so it is recommended to NOT change\n\</span>
<a name="l12932"></a>12932 <span class="stringliteral">this option to \&quot;off\&quot; unless necessary.&quot;</span>),
<a name="l12933"></a>12933                             NULL, NULL, &amp;set_ada_list, &amp;show_ada_list);
<a name="l12934"></a>12934 
<a name="l12935"></a>12935   <a class="code" href="breakpoint_8c.html#a2f9b60e7aa76c6796bf67b46a1f758ce">add_catch_command</a> (<span class="stringliteral">&quot;exception&quot;</span>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l12936"></a>12936 <span class="stringliteral">Catch Ada exceptions, when raised.\n\</span>
<a name="l12937"></a>12937 <span class="stringliteral">With an argument, catch only exceptions with the given name.&quot;</span>),
<a name="l12938"></a>12938                      catch_ada_exception_command,
<a name="l12939"></a>12939                      NULL,
<a name="l12940"></a>12940                      <a class="code" href="breakpoint_8h.html#a025e5e360b0c2f65dd7ac39daba9fee0">CATCH_PERMANENT</a>,
<a name="l12941"></a>12941                      <a class="code" href="breakpoint_8h.html#a9f80fa035808be1497fc37fd6595587e">CATCH_TEMPORARY</a>);
<a name="l12942"></a>12942   <a class="code" href="breakpoint_8c.html#a2f9b60e7aa76c6796bf67b46a1f758ce">add_catch_command</a> (<span class="stringliteral">&quot;assert&quot;</span>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l12943"></a>12943 <span class="stringliteral">Catch failed Ada assertions, when raised.\n\</span>
<a name="l12944"></a>12944 <span class="stringliteral">With an argument, catch only exceptions with the given name.&quot;</span>),
<a name="l12945"></a>12945                      catch_assert_command,
<a name="l12946"></a>12946                      NULL,
<a name="l12947"></a>12947                      <a class="code" href="breakpoint_8h.html#a025e5e360b0c2f65dd7ac39daba9fee0">CATCH_PERMANENT</a>,
<a name="l12948"></a>12948                      <a class="code" href="breakpoint_8h.html#a9f80fa035808be1497fc37fd6595587e">CATCH_TEMPORARY</a>);
<a name="l12949"></a>12949 
<a name="l12950"></a>12950   varsize_limit = 65536;
<a name="l12951"></a>12951 
<a name="l12952"></a>12952   obstack_init (&amp;symbol_list_obstack);
<a name="l12953"></a>12953 
<a name="l12954"></a>12954   decoded_names_store = htab_create_alloc
<a name="l12955"></a>12955     (256, htab_hash_string, (<span class="keywordtype">int</span> (*)(<span class="keyword">const</span> <span class="keywordtype">void</span> *, <span class="keyword">const</span> <span class="keywordtype">void</span> *)) <a class="code" href="utils_8c.html#aa6e179aa2fa149e001055d2697342085">streq</a>,
<a name="l12956"></a>12956      NULL, <a class="code" href="common-utils_8c.html#a05a0a3435b91a07d6cc1a0b4c8788a4d">xcalloc</a>, <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>);
<a name="l12957"></a>12957 
<a name="l12958"></a>12958   <span class="comment">/* Setup per-inferior data.  */</span>
<a name="l12959"></a>12959   <a class="code" href="observer_8h.html#a9a54ebb2156e3189a09d3e7afcf1b067">observer_attach_inferior_exit</a> (ada_inferior_exit);
<a name="l12960"></a>12960   ada_inferior_data
<a name="l12961"></a>12961     = register_inferior_data_with_cleanup (NULL, ada_inferior_data_cleanup);
<a name="l12962"></a>12962 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:12:09 for GDB (API) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
