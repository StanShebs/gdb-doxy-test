<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (API): /home/stan/gdb/src/gdb/jit.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (API)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/jit.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="jit_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Handle JIT code generation in the inferior for GDB, the GNU Debugger.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 2009-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   This file is part of GDB.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00010"></a>00010 <span class="comment">   (at your option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00018"></a>00018 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="jit_8h.html">jit.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="jit-reader_8h.html">jit-reader.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="block_8h.html">block.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="breakpoint_8h.html">breakpoint.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="command_8h.html">command.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="dictionary_8h.html">dictionary.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;filenames.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="frame-unwind_8h.html">frame-unwind.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="gdbcmd_8h.html">gdbcmd.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="gdbcore_8h.html">gdbcore.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="inferior_8h.html">inferior.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="observer_8h.html">observer.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="objfiles_8h.html">objfiles.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="regcache_8h.html">regcache.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="symfile_8h.html">symfile.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="target_8h.html">target.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="gdb-dlfcn_8h.html">gdb-dlfcn.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="gdb__stat_8h.html">gdb_stat.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="exceptions_8h.html">exceptions.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="gdb__bfd_8h.html">gdb_bfd.h</a>&quot;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *jit_reader_dir = NULL;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>objfile_data *jit_objfile_data;
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> jit_break_name = <span class="stringliteral">&quot;__jit_debug_register_code&quot;</span>;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> jit_descriptor_name = <span class="stringliteral">&quot;__jit_debug_descriptor&quot;</span>;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>program_space_data *jit_program_space_data = NULL;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="keyword">static</span> <span class="keywordtype">void</span> jit_inferior_init (<span class="keyword">struct</span> gdbarch *gdbarch);
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="comment">/* An unwinder is registered for every gdbarch.  This key is used to</span>
<a name="l00057"></a>00057 <span class="comment">   remember if the unwinder has been registered for a particular</span>
<a name="l00058"></a>00058 <span class="comment">   gdbarch.  */</span>
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="gdbarch_8c.html#af5b48a62893f4f5f453c3c27ad3b44f7">gdbarch_data</a> *jit_gdbarch_data;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="comment">/* Non-zero if we want to see trace of jit level stuff.  */</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jit_debug = 0;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00067"></a>00067 show_jit_debug (<span class="keyword">struct</span> ui_file *file, <span class="keywordtype">int</span> from_tty,
<a name="l00068"></a>00068                 <span class="keyword">struct</span> <a class="code" href="structcmd__list__element.html">cmd_list_element</a> *c, <span class="keyword">const</span> <span class="keywordtype">char</span> *value)
<a name="l00069"></a>00069 {
<a name="l00070"></a>00070   <a class="code" href="utils_8c.html#aaa819b1a6c0b6c4090bdc0b027eaf64b">fprintf_filtered</a> (file, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;JIT debugging is %s.\n&quot;</span>), value);
<a name="l00071"></a>00071 }
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="keyword">struct </span>target_buffer
<a name="l00074"></a>00074 {
<a name="l00075"></a>00075   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> base;
<a name="l00076"></a>00076   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l00077"></a>00077 };
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="comment">/* Openning the file is a no-op.  */</span>
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="keyword">static</span> <span class="keywordtype">void</span> *
<a name="l00082"></a>00082 mem_bfd_iovec_open (<span class="keyword">struct</span> bfd *abfd, <span class="keywordtype">void</span> *open_closure)
<a name="l00083"></a>00083 {
<a name="l00084"></a>00084   <span class="keywordflow">return</span> open_closure;
<a name="l00085"></a>00085 }
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="comment">/* Closing the file is just freeing the base/size pair on our side.  */</span>
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00090"></a>00090 mem_bfd_iovec_close (<span class="keyword">struct</span> bfd *abfd, <span class="keywordtype">void</span> *stream)
<a name="l00091"></a>00091 {
<a name="l00092"></a>00092   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (stream);
<a name="l00093"></a>00093 
<a name="l00094"></a>00094   <span class="comment">/* Zero means success.  */</span>
<a name="l00095"></a>00095   <span class="keywordflow">return</span> 0;
<a name="l00096"></a>00096 }
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="comment">/* For reading the file, we just need to pass through to target_read_memory and</span>
<a name="l00099"></a>00099 <span class="comment">   fix up the arguments and return values.  */</span>
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="keyword">static</span> file_ptr
<a name="l00102"></a>00102 mem_bfd_iovec_pread (<span class="keyword">struct</span> bfd *abfd, <span class="keywordtype">void</span> *stream, <span class="keywordtype">void</span> *buf,
<a name="l00103"></a>00103                      file_ptr nbytes, file_ptr <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>)
<a name="l00104"></a>00104 {
<a name="l00105"></a>00105   <span class="keywordtype">int</span> err;
<a name="l00106"></a>00106   <span class="keyword">struct </span>target_buffer *<a class="code" href="structbuffer.html">buffer</a> = (<span class="keyword">struct </span>target_buffer *) stream;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <span class="comment">/* If this read will read all of the file, limit it to just the rest.  */</span>
<a name="l00109"></a>00109   <span class="keywordflow">if</span> (offset + nbytes &gt; buffer-&gt;size)
<a name="l00110"></a>00110     nbytes = buffer-&gt;size - <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112   <span class="comment">/* If there are no more bytes left, we&#39;ve reached EOF.  */</span>
<a name="l00113"></a>00113   <span class="keywordflow">if</span> (nbytes == 0)
<a name="l00114"></a>00114     <span class="keywordflow">return</span> 0;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116   err = <a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (buffer-&gt;base + offset, (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *) buf, nbytes);
<a name="l00117"></a>00117   <span class="keywordflow">if</span> (err)
<a name="l00118"></a>00118     <span class="keywordflow">return</span> -1;
<a name="l00119"></a>00119 
<a name="l00120"></a>00120   <span class="keywordflow">return</span> nbytes;
<a name="l00121"></a>00121 }
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 <span class="comment">/* For statting the file, we only support the st_size attribute.  */</span>
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00126"></a>00126 mem_bfd_iovec_stat (<span class="keyword">struct</span> bfd *abfd, <span class="keywordtype">void</span> *stream, <span class="keyword">struct</span> stat *sb)
<a name="l00127"></a>00127 {
<a name="l00128"></a>00128   <span class="keyword">struct </span>target_buffer *buffer = (<span class="keyword">struct </span>target_buffer*) stream;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   sb-&gt;st_size = buffer-&gt;size;
<a name="l00131"></a>00131   <span class="keywordflow">return</span> 0;
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="comment">/* Open a BFD from the target&#39;s memory.  */</span>
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 <span class="keyword">static</span> <span class="keyword">struct </span>bfd *
<a name="l00137"></a>00137 bfd_open_from_target_memory (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>, <span class="keywordtype">char</span> *target)
<a name="l00138"></a>00138 {
<a name="l00139"></a>00139   <span class="keyword">struct </span>target_buffer *buffer = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> target_buffer));
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   buffer-&gt;base = addr;
<a name="l00142"></a>00142   buffer-&gt;size = <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l00143"></a>00143   <span class="keywordflow">return</span> <a class="code" href="gdb__bfd_8c.html#aaee4261acdce3aeb058fde5e2f32a70c">gdb_bfd_openr_iovec</a> (<span class="stringliteral">&quot;&lt;in-memory&gt;&quot;</span>, target,
<a name="l00144"></a>00144                               mem_bfd_iovec_open,
<a name="l00145"></a>00145                               buffer,
<a name="l00146"></a>00146                               mem_bfd_iovec_pread,
<a name="l00147"></a>00147                               mem_bfd_iovec_close,
<a name="l00148"></a>00148                               mem_bfd_iovec_stat);
<a name="l00149"></a>00149 }
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <span class="comment">/* One reader that has been loaded successfully, and can potentially be used to</span>
<a name="l00152"></a>00152 <span class="comment">   parse debug info.  */</span>
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keyword">static</span> <span class="keyword">struct </span>jit_reader
<a name="l00155"></a>00155 {
<a name="l00156"></a>00156   <span class="keyword">struct </span><a class="code" href="structgdb__reader__funcs.html">gdb_reader_funcs</a> *functions;
<a name="l00157"></a>00157   <span class="keywordtype">void</span> *handle;
<a name="l00158"></a>00158 } *loaded_jit_reader = NULL;
<a name="l00159"></a>00159 
<a name="l00160"></a><a class="code" href="jit_8c.html#a43627a7da3efb2e2953905991f765452">00160</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structgdb__reader__funcs.html">gdb_reader_funcs</a> * (<a class="code" href="jit_8c.html#a43627a7da3efb2e2953905991f765452">reader_init_fn_type</a>) (<span class="keywordtype">void</span>);
<a name="l00161"></a>00161 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *reader_init_fn_sym = <span class="stringliteral">&quot;gdb_init_reader&quot;</span>;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">/* Try to load FILE_NAME as a JIT debug info reader.  */</span>
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="keyword">static</span> <span class="keyword">struct </span>jit_reader *
<a name="l00166"></a>00166 jit_reader_load (<span class="keyword">const</span> <span class="keywordtype">char</span> *file_name)
<a name="l00167"></a>00167 {
<a name="l00168"></a>00168   <span class="keywordtype">void</span> *so;
<a name="l00169"></a>00169   <a class="code" href="jit_8c.html#a43627a7da3efb2e2953905991f765452">reader_init_fn_type</a> *init_fn;
<a name="l00170"></a>00170   <span class="keyword">struct </span>jit_reader *new_reader = NULL;
<a name="l00171"></a>00171   <span class="keyword">struct </span><a class="code" href="structgdb__reader__funcs.html">gdb_reader_funcs</a> *funcs = NULL;
<a name="l00172"></a>00172   <span class="keyword">struct </span>cleanup *old_cleanups;
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <span class="keywordflow">if</span> (jit_debug)
<a name="l00175"></a>00175     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Opening shared object %s.\n&quot;</span>),
<a name="l00176"></a>00176                         file_name);
<a name="l00177"></a>00177   so = <a class="code" href="gdb-dlfcn_8c.html#ac2cf9fa384cd8be02ab8828dbd231a5d">gdb_dlopen</a> (file_name);
<a name="l00178"></a>00178   old_cleanups = <a class="code" href="gdb-dlfcn_8c.html#a90e5566bf4a32a630ef02d00f33df1ab">make_cleanup_dlclose</a> (so);
<a name="l00179"></a>00179 
<a name="l00180"></a>00180   init_fn = <a class="code" href="gdb-dlfcn_8c.html#a9e28bab1c038a3a35839cff494ed0025">gdb_dlsym</a> (so, reader_init_fn_sym);
<a name="l00181"></a>00181   <span class="keywordflow">if</span> (!init_fn)
<a name="l00182"></a>00182     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Could not locate initialization function: %s.&quot;</span>),
<a name="l00183"></a>00183           reader_init_fn_sym);
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   <span class="keywordflow">if</span> (<a class="code" href="gdb-dlfcn_8c.html#a9e28bab1c038a3a35839cff494ed0025">gdb_dlsym</a> (so, <span class="stringliteral">&quot;plugin_is_GPL_compatible&quot;</span>) == NULL)
<a name="l00186"></a>00186     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Reader not GPL compatible.&quot;</span>));
<a name="l00187"></a>00187 
<a name="l00188"></a>00188   funcs = init_fn ();
<a name="l00189"></a>00189   <span class="keywordflow">if</span> (funcs-&gt;<a class="code" href="structgdb__reader__funcs.html#a0678d94e813300b00581f595b9ca4e11">reader_version</a> != <a class="code" href="jit-reader_8h.html#aca5f6fae768cda11f600be74951c4b65">GDB_READER_INTERFACE_VERSION</a>)
<a name="l00190"></a>00190     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Reader version does not match GDB version.&quot;</span>));
<a name="l00191"></a>00191 
<a name="l00192"></a>00192   new_reader = <a class="code" href="defs_8h.html#ab004b072c2eba9eb35ffb7b86a72b8c0">XZALLOC</a> (<span class="keyword">struct</span> jit_reader);
<a name="l00193"></a>00193   new_reader-&gt;functions = funcs;
<a name="l00194"></a>00194   new_reader-&gt;handle = so;
<a name="l00195"></a>00195 
<a name="l00196"></a>00196   <a class="code" href="cleanups_8c.html#a5ec3987bf995edcc44def9e17ada6eba">discard_cleanups</a> (old_cleanups);
<a name="l00197"></a>00197   <span class="keywordflow">return</span> new_reader;
<a name="l00198"></a>00198 }
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 <span class="comment">/* Provides the jit-reader-load command.  */</span>
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00203"></a>00203 jit_reader_load_command (<span class="keywordtype">char</span> *args, <span class="keywordtype">int</span> from_tty)
<a name="l00204"></a>00204 {
<a name="l00205"></a>00205   <span class="keywordtype">char</span> *so_name;
<a name="l00206"></a>00206   <span class="keyword">struct </span>cleanup *prev_cleanup;
<a name="l00207"></a>00207 
<a name="l00208"></a>00208   <span class="keywordflow">if</span> (args == NULL)
<a name="l00209"></a>00209     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No reader name provided.&quot;</span>));
<a name="l00210"></a>00210 
<a name="l00211"></a>00211   <span class="keywordflow">if</span> (loaded_jit_reader != NULL)
<a name="l00212"></a>00212     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;JIT reader already loaded.  Run jit-reader-unload first.&quot;</span>));
<a name="l00213"></a>00213 
<a name="l00214"></a>00214   <span class="keywordflow">if</span> (IS_ABSOLUTE_PATH (args))
<a name="l00215"></a>00215     so_name = xstrdup (args);
<a name="l00216"></a>00216   <span class="keywordflow">else</span>
<a name="l00217"></a>00217     so_name = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;%s%s%s&quot;</span>, SLASH_STRING, jit_reader_dir, args);
<a name="l00218"></a>00218   prev_cleanup = <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, so_name);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220   loaded_jit_reader = jit_reader_load (so_name);
<a name="l00221"></a>00221   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (prev_cleanup);
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="comment">/* Provides the jit-reader-unload command.  */</span>
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00227"></a>00227 jit_reader_unload_command (<span class="keywordtype">char</span> *args, <span class="keywordtype">int</span> from_tty)
<a name="l00228"></a>00228 {
<a name="l00229"></a>00229   <span class="keywordflow">if</span> (!loaded_jit_reader)
<a name="l00230"></a>00230     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;No JIT reader loaded.&quot;</span>));
<a name="l00231"></a>00231 
<a name="l00232"></a>00232   loaded_jit_reader-&gt;functions-&gt;destroy (loaded_jit_reader-&gt;functions);
<a name="l00233"></a>00233 
<a name="l00234"></a>00234   <a class="code" href="gdb-dlfcn_8c.html#a704d97a4c8d88352390346eaae9d1c94">gdb_dlclose</a> (loaded_jit_reader-&gt;handle);
<a name="l00235"></a>00235   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (loaded_jit_reader);
<a name="l00236"></a>00236   loaded_jit_reader = NULL;
<a name="l00237"></a>00237 }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 <span class="comment">/* Per-program space structure recording which objfile has the JIT</span>
<a name="l00240"></a>00240 <span class="comment">   symbols.  */</span>
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 <span class="keyword">struct </span>jit_program_space_data
<a name="l00243"></a>00243 {
<a name="l00244"></a>00244   <span class="comment">/* The objfile.  This is NULL if no objfile holds the JIT</span>
<a name="l00245"></a>00245 <span class="comment">     symbols.  */</span>
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   <span class="keyword">struct </span><a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>;
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   <span class="comment">/* If this program space has __jit_debug_register_code, this is the</span>
<a name="l00250"></a>00250 <span class="comment">     cached address from the minimal symbol.  This is used to detect</span>
<a name="l00251"></a>00251 <span class="comment">     relocations requiring the breakpoint to be re-created.  */</span>
<a name="l00252"></a>00252 
<a name="l00253"></a>00253   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> cached_code_address;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255   <span class="comment">/* This is the JIT event breakpoint, or NULL if it has not been</span>
<a name="l00256"></a>00256 <span class="comment">     set.  */</span>
<a name="l00257"></a>00257 
<a name="l00258"></a>00258   <span class="keyword">struct </span><a class="code" href="structbreakpoint.html">breakpoint</a> *jit_breakpoint;
<a name="l00259"></a>00259 };
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 <span class="comment">/* Per-objfile structure recording the addresses in the program space.</span>
<a name="l00262"></a>00262 <span class="comment">   This object serves two purposes: for ordinary objfiles, it may</span>
<a name="l00263"></a>00263 <span class="comment">   cache some symbols related to the JIT interface; and for</span>
<a name="l00264"></a>00264 <span class="comment">   JIT-created objfiles, it holds some information about the</span>
<a name="l00265"></a>00265 <span class="comment">   jit_code_entry.  */</span>
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 <span class="keyword">struct </span>jit_objfile_data
<a name="l00268"></a>00268 {
<a name="l00269"></a>00269   <span class="comment">/* Symbol for __jit_debug_register_code.  */</span>
<a name="l00270"></a>00270   <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *register_code;
<a name="l00271"></a>00271 
<a name="l00272"></a>00272   <span class="comment">/* Symbol for __jit_debug_descriptor.  */</span>
<a name="l00273"></a>00273   <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *descriptor;
<a name="l00274"></a>00274 
<a name="l00275"></a>00275   <span class="comment">/* Address of struct jit_code_entry in this objfile.  This is only</span>
<a name="l00276"></a>00276 <span class="comment">     non-zero for objfiles that represent code created by the JIT.  */</span>
<a name="l00277"></a>00277   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr;
<a name="l00278"></a>00278 };
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="comment">/* Fetch the jit_objfile_data associated with OBJF.  If no data exists</span>
<a name="l00281"></a>00281 <span class="comment">   yet, make a new structure and attach it.  */</span>
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="keyword">static</span> <span class="keyword">struct </span>jit_objfile_data *
<a name="l00284"></a>00284 get_jit_objfile_data (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *objf)
<a name="l00285"></a>00285 {
<a name="l00286"></a>00286   <span class="keyword">struct </span>jit_objfile_data *objf_data;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   objf_data = objfile_data (objf, jit_objfile_data);
<a name="l00289"></a>00289   <span class="keywordflow">if</span> (objf_data == NULL)
<a name="l00290"></a>00290     {
<a name="l00291"></a>00291       objf_data = <a class="code" href="defs_8h.html#ab004b072c2eba9eb35ffb7b86a72b8c0">XZALLOC</a> (<span class="keyword">struct</span> jit_objfile_data);
<a name="l00292"></a>00292       set_objfile_data (objf, jit_objfile_data, objf_data);
<a name="l00293"></a>00293     }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295   <span class="keywordflow">return</span> objf_data;
<a name="l00296"></a>00296 }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="comment">/* Remember OBJFILE has been created for struct jit_code_entry located</span>
<a name="l00299"></a>00299 <span class="comment">   at inferior address ENTRY.  */</span>
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00302"></a>00302 add_objfile_entry (<span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> entry)
<a name="l00303"></a>00303 {
<a name="l00304"></a>00304   <span class="keyword">struct </span>jit_objfile_data *objf_data;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   objf_data = get_jit_objfile_data (objfile);
<a name="l00307"></a>00307   objf_data-&gt;addr = entry;
<a name="l00308"></a>00308 }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 <span class="comment">/* Return jit_program_space_data for current program space.  Allocate</span>
<a name="l00311"></a>00311 <span class="comment">   if not already present.  */</span>
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="keyword">static</span> <span class="keyword">struct </span>jit_program_space_data *
<a name="l00314"></a>00314 get_jit_program_space_data (<span class="keywordtype">void</span>)
<a name="l00315"></a>00315 {
<a name="l00316"></a>00316   <span class="keyword">struct </span>jit_program_space_data *ps_data;
<a name="l00317"></a>00317 
<a name="l00318"></a>00318   ps_data = program_space_data (<a class="code" href="progspace_8c.html#a07722ff15a98814c086dda44f93380c9">current_program_space</a>, jit_program_space_data);
<a name="l00319"></a>00319   <span class="keywordflow">if</span> (ps_data == NULL)
<a name="l00320"></a>00320     {
<a name="l00321"></a>00321       ps_data = <a class="code" href="defs_8h.html#ab004b072c2eba9eb35ffb7b86a72b8c0">XZALLOC</a> (<span class="keyword">struct</span> jit_program_space_data);
<a name="l00322"></a>00322       set_program_space_data (<a class="code" href="progspace_8c.html#a07722ff15a98814c086dda44f93380c9">current_program_space</a>, jit_program_space_data,
<a name="l00323"></a>00323                               ps_data);
<a name="l00324"></a>00324     }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   <span class="keywordflow">return</span> ps_data;
<a name="l00327"></a>00327 }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00330"></a>00330 jit_program_space_data_cleanup (<span class="keyword">struct</span> <a class="code" href="structprogram__space.html">program_space</a> *<a class="code" href="namespacecleanup__check.html#a2f9ce522b7667bef19a5777d12fa44d8">ps</a>, <span class="keywordtype">void</span> *arg)
<a name="l00331"></a>00331 {
<a name="l00332"></a>00332   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (arg);
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="comment">/* Helper function for reading the global JIT descriptor from remote</span>
<a name="l00336"></a>00336 <span class="comment">   memory.  Returns 1 if all went well, 0 otherwise.  */</span>
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00339"></a>00339 jit_read_descriptor (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l00340"></a>00340                      <span class="keyword">struct</span> <a class="code" href="structjit__descriptor.html">jit_descriptor</a> *descriptor,
<a name="l00341"></a>00341                      <span class="keyword">struct</span> jit_program_space_data *ps_data)
<a name="l00342"></a>00342 {
<a name="l00343"></a>00343   <span class="keywordtype">int</span> err;
<a name="l00344"></a>00344   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *ptr_type;
<a name="l00345"></a>00345   <span class="keywordtype">int</span> ptr_size;
<a name="l00346"></a>00346   <span class="keywordtype">int</span> desc_size;
<a name="l00347"></a>00347   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *desc_buf;
<a name="l00348"></a>00348   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l00349"></a>00349   <span class="keyword">struct </span>jit_objfile_data *objf_data;
<a name="l00350"></a>00350 
<a name="l00351"></a>00351   <span class="keywordflow">if</span> (ps_data-&gt;objfile == NULL)
<a name="l00352"></a>00352     <span class="keywordflow">return</span> 0;
<a name="l00353"></a>00353   objf_data = get_jit_objfile_data (ps_data-&gt;objfile);
<a name="l00354"></a>00354   <span class="keywordflow">if</span> (objf_data-&gt;descriptor == NULL)
<a name="l00355"></a>00355     <span class="keywordflow">return</span> 0;
<a name="l00356"></a>00356 
<a name="l00357"></a>00357   <span class="keywordflow">if</span> (jit_debug)
<a name="l00358"></a>00358     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l00359"></a>00359                         <span class="stringliteral">&quot;jit_read_descriptor, descriptor_addr = %s\n&quot;</span>,
<a name="l00360"></a>00360                         <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (objf_data-&gt;descriptor)));
<a name="l00361"></a>00361 
<a name="l00362"></a>00362   <span class="comment">/* Figure out how big the descriptor is on the remote and how to read it.  */</span>
<a name="l00363"></a>00363   ptr_type = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a55f6f9ff7436431777683d8ba62f662a">builtin_data_ptr</a>;
<a name="l00364"></a>00364   ptr_size = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (ptr_type);
<a name="l00365"></a>00365   desc_size = 8 + 2 * ptr_size;  <span class="comment">/* Two 32-bit ints and two pointers.  */</span>
<a name="l00366"></a>00366   desc_buf = alloca (desc_size);
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <span class="comment">/* Read the descriptor.  */</span>
<a name="l00369"></a>00369   err = <a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (<a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (objf_data-&gt;descriptor),
<a name="l00370"></a>00370                             desc_buf, desc_size);
<a name="l00371"></a>00371   <span class="keywordflow">if</span> (err)
<a name="l00372"></a>00372     {
<a name="l00373"></a>00373       <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unable to read JIT descriptor from &quot;</span>
<a name="l00374"></a>00374                            <span class="stringliteral">&quot;remote memory\n&quot;</span>));
<a name="l00375"></a>00375       <span class="keywordflow">return</span> 0;
<a name="l00376"></a>00376     }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378   <span class="comment">/* Fix the endianness to match the host.  */</span>
<a name="l00379"></a>00379   descriptor-&gt;<a class="code" href="structjit__descriptor.html#a99a4d52c382bfded369e98acc42b38c7">version</a> = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;desc_buf[0], 4, byte_order);
<a name="l00380"></a>00380   descriptor-&gt;<a class="code" href="structjit__descriptor.html#a5caa0e4b5007a2b528343dab212f061c">action_flag</a> =
<a name="l00381"></a>00381       <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;desc_buf[4], 4, byte_order);
<a name="l00382"></a>00382   descriptor-&gt;<a class="code" href="structjit__descriptor.html#ae1437c29bc389acbe3b8317ffe7f22b9">relevant_entry</a> = <a class="code" href="defs_8h.html#a8a619d8cb1c6d12c6354da6e663dbd95">extract_typed_address</a> (&amp;desc_buf[8], ptr_type);
<a name="l00383"></a>00383   descriptor-&gt;<a class="code" href="structjit__descriptor.html#a79ccc7b26869a7697f5c9785b0667a82">first_entry</a> =
<a name="l00384"></a>00384       <a class="code" href="defs_8h.html#a8a619d8cb1c6d12c6354da6e663dbd95">extract_typed_address</a> (&amp;desc_buf[8 + ptr_size], ptr_type);
<a name="l00385"></a>00385 
<a name="l00386"></a>00386   <span class="keywordflow">return</span> 1;
<a name="l00387"></a>00387 }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 <span class="comment">/* Helper function for reading a JITed code entry from remote memory.  */</span>
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00392"></a>00392 jit_read_code_entry (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l00393"></a>00393                      <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> code_addr, <span class="keyword">struct</span> <a class="code" href="structjit__code__entry.html">jit_code_entry</a> *code_entry)
<a name="l00394"></a>00394 {
<a name="l00395"></a>00395   <span class="keywordtype">int</span> err, off;
<a name="l00396"></a>00396   <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *ptr_type;
<a name="l00397"></a>00397   <span class="keywordtype">int</span> ptr_size;
<a name="l00398"></a>00398   <span class="keywordtype">int</span> entry_size;
<a name="l00399"></a>00399   <span class="keywordtype">int</span> align_bytes;
<a name="l00400"></a>00400   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *entry_buf;
<a name="l00401"></a>00401   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l00402"></a>00402 
<a name="l00403"></a>00403   <span class="comment">/* Figure out how big the entry is on the remote and how to read it.  */</span>
<a name="l00404"></a>00404   ptr_type = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a55f6f9ff7436431777683d8ba62f662a">builtin_data_ptr</a>;
<a name="l00405"></a>00405   ptr_size = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (ptr_type);
<a name="l00406"></a>00406 
<a name="l00407"></a>00407   <span class="comment">/* Figure out where the longlong value will be.  */</span>
<a name="l00408"></a>00408   align_bytes = <a class="code" href="gdbarch_8c.html#a3ce47f1615eb422d5469f16c824a34c8">gdbarch_long_long_align_bit</a> (gdbarch) / 8;
<a name="l00409"></a>00409   off = 3 * ptr_size;
<a name="l00410"></a>00410   off = (off + (align_bytes - 1)) &amp; ~(align_bytes - 1);
<a name="l00411"></a>00411 
<a name="l00412"></a>00412   entry_size = off + 8;  <span class="comment">/* Three pointers and one 64-bit int.  */</span>
<a name="l00413"></a>00413   entry_buf = alloca (entry_size);
<a name="l00414"></a>00414 
<a name="l00415"></a>00415   <span class="comment">/* Read the entry.  */</span>
<a name="l00416"></a>00416   err = <a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (code_addr, entry_buf, entry_size);
<a name="l00417"></a>00417   <span class="keywordflow">if</span> (err)
<a name="l00418"></a>00418     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unable to read JIT code entry from remote memory!&quot;</span>));
<a name="l00419"></a>00419 
<a name="l00420"></a>00420   <span class="comment">/* Fix the endianness to match the host.  */</span>
<a name="l00421"></a>00421   ptr_type = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a55f6f9ff7436431777683d8ba62f662a">builtin_data_ptr</a>;
<a name="l00422"></a>00422   code_entry-&gt;<a class="code" href="structjit__code__entry.html#a2a464999e8f1be6f87dfa60109882efe">next_entry</a> = <a class="code" href="defs_8h.html#a8a619d8cb1c6d12c6354da6e663dbd95">extract_typed_address</a> (&amp;entry_buf[0], ptr_type);
<a name="l00423"></a>00423   code_entry-&gt;<a class="code" href="structjit__code__entry.html#a38cb8df542f4a18eafa3872ba6f04462">prev_entry</a> =
<a name="l00424"></a>00424       <a class="code" href="defs_8h.html#a8a619d8cb1c6d12c6354da6e663dbd95">extract_typed_address</a> (&amp;entry_buf[ptr_size], ptr_type);
<a name="l00425"></a>00425   code_entry-&gt;<a class="code" href="structjit__code__entry.html#a0e5f39796c30fedbc1c770e989c17b4e">symfile_addr</a> =
<a name="l00426"></a>00426       <a class="code" href="defs_8h.html#a8a619d8cb1c6d12c6354da6e663dbd95">extract_typed_address</a> (&amp;entry_buf[2 * ptr_size], ptr_type);
<a name="l00427"></a>00427   code_entry-&gt;<a class="code" href="structjit__code__entry.html#ae2f93c024fc3a2fe83c5ab3561cf8bc1">symfile_size</a> =
<a name="l00428"></a>00428       <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (&amp;entry_buf[off], 8, byte_order);
<a name="l00429"></a>00429 }
<a name="l00430"></a>00430 
<a name="l00431"></a>00431 <span class="comment">/* Proxy object for building a block.  */</span>
<a name="l00432"></a>00432 
<a name="l00433"></a>00433 <span class="keyword">struct </span>gdb_block
<a name="l00434"></a>00434 {
<a name="l00435"></a>00435   <span class="comment">/* gdb_blocks are linked into a tree structure.  Next points to the</span>
<a name="l00436"></a>00436 <span class="comment">     next node at the same depth as this block and parent to the</span>
<a name="l00437"></a>00437 <span class="comment">     parent gdb_block.  */</span>
<a name="l00438"></a>00438   <span class="keyword">struct </span>gdb_block *next, *parent;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440   <span class="comment">/* Points to the &quot;real&quot; block that is being built out of this</span>
<a name="l00441"></a>00441 <span class="comment">     instance.  This block will be added to a blockvector, which will</span>
<a name="l00442"></a>00442 <span class="comment">     then be added to a symtab.  */</span>
<a name="l00443"></a>00443   <span class="keyword">struct </span><a class="code" href="structblock.html">block</a> *real_block;
<a name="l00444"></a>00444 
<a name="l00445"></a>00445   <span class="comment">/* The first and last code address corresponding to this block.  */</span>
<a name="l00446"></a>00446   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> begin, end;
<a name="l00447"></a>00447 
<a name="l00448"></a>00448   <span class="comment">/* The name of this block (if any).  If this is non-NULL, the</span>
<a name="l00449"></a>00449 <span class="comment">     FUNCTION symbol symbol is set to this value.  */</span>
<a name="l00450"></a>00450   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>;
<a name="l00451"></a>00451 };
<a name="l00452"></a>00452 
<a name="l00453"></a>00453 <span class="comment">/* Proxy object for building a symtab.  */</span>
<a name="l00454"></a>00454 
<a name="l00455"></a>00455 <span class="keyword">struct </span>gdb_symtab
<a name="l00456"></a>00456 {
<a name="l00457"></a>00457   <span class="comment">/* The list of blocks in this symtab.  These will eventually be</span>
<a name="l00458"></a>00458 <span class="comment">     converted to real blocks.  */</span>
<a name="l00459"></a>00459   <span class="keyword">struct </span>gdb_block *blocks;
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="comment">/* The number of blocks inserted.  */</span>
<a name="l00462"></a>00462   <span class="keywordtype">int</span> nblocks;
<a name="l00463"></a>00463 
<a name="l00464"></a>00464   <span class="comment">/* A mapping between line numbers to PC.  */</span>
<a name="l00465"></a>00465   <span class="keyword">struct </span><a class="code" href="structlinetable.html">linetable</a> *<a class="code" href="structlinetable.html">linetable</a>;
<a name="l00466"></a>00466 
<a name="l00467"></a>00467   <span class="comment">/* The source file for this symtab.  */</span>
<a name="l00468"></a>00468   <span class="keyword">const</span> <span class="keywordtype">char</span> *file_name;
<a name="l00469"></a>00469   <span class="keyword">struct </span>gdb_symtab *next;
<a name="l00470"></a>00470 };
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 <span class="comment">/* Proxy object for building an object.  */</span>
<a name="l00473"></a>00473 
<a name="l00474"></a>00474 <span class="keyword">struct </span>gdb_object
<a name="l00475"></a>00475 {
<a name="l00476"></a>00476   <span class="keyword">struct </span>gdb_symtab *symtabs;
<a name="l00477"></a>00477 };
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 <span class="comment">/* The type of the `private&#39; data passed around by the callback</span>
<a name="l00480"></a>00480 <span class="comment">   functions.  */</span>
<a name="l00481"></a>00481 
<a name="l00482"></a><a class="code" href="jit_8c.html#adf3e92657b9358cc177c22a051075096">00482</a> <span class="keyword">typedef</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="jit_8c.html#adf3e92657b9358cc177c22a051075096">jit_dbg_reader_data</a>;
<a name="l00483"></a>00483 
<a name="l00484"></a>00484 <span class="comment">/* The reader calls into this function to read data off the targets</span>
<a name="l00485"></a>00485 <span class="comment">   address space.  */</span>
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="jit-reader_8h.html#a40831c20ece64c96efe16e43a7e094b7">gdb_status</a>
<a name="l00488"></a>00488 jit_target_read_impl (<a class="code" href="jit-reader_8h.html#ab1101f50cba4d6ad71b4d4a89f01a695">GDB_CORE_ADDR</a> target_mem, <span class="keywordtype">void</span> *gdb_buf, <span class="keywordtype">int</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>)
<a name="l00489"></a>00489 {
<a name="l00490"></a>00490   <span class="keywordtype">int</span> result = <a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> ((<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) target_mem, gdb_buf, len);
<a name="l00491"></a>00491   <span class="keywordflow">if</span> (result == 0)
<a name="l00492"></a>00492     <span class="keywordflow">return</span> <a class="code" href="jit-reader_8h.html#a40831c20ece64c96efe16e43a7e094b7a2fe0274459c7e63e2bceba839da16783">GDB_SUCCESS</a>;
<a name="l00493"></a>00493   <span class="keywordflow">else</span>
<a name="l00494"></a>00494     <span class="keywordflow">return</span> <a class="code" href="jit-reader_8h.html#a40831c20ece64c96efe16e43a7e094b7ac5f246161620f340b12a37511e49a512">GDB_FAIL</a>;
<a name="l00495"></a>00495 }
<a name="l00496"></a>00496 
<a name="l00497"></a>00497 <span class="comment">/* The reader calls into this function to create a new gdb_object</span>
<a name="l00498"></a>00498 <span class="comment">   which it can then pass around to the other callbacks.  Right now,</span>
<a name="l00499"></a>00499 <span class="comment">   all that is required is allocating the memory.  */</span>
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 <span class="keyword">static</span> <span class="keyword">struct </span>gdb_object *
<a name="l00502"></a>00502 jit_object_open_impl (<span class="keyword">struct</span> <a class="code" href="structgdb__symbol__callbacks.html">gdb_symbol_callbacks</a> *cb)
<a name="l00503"></a>00503 {
<a name="l00504"></a>00504   <span class="comment">/* CB is not required right now, but sometime in the future we might</span>
<a name="l00505"></a>00505 <span class="comment">     need a handle to it, and we&#39;d like to do that without breaking</span>
<a name="l00506"></a>00506 <span class="comment">     the ABI.  */</span>
<a name="l00507"></a>00507   <span class="keywordflow">return</span> <a class="code" href="defs_8h.html#ab004b072c2eba9eb35ffb7b86a72b8c0">XZALLOC</a> (<span class="keyword">struct</span> gdb_object);
<a name="l00508"></a>00508 }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510 <span class="comment">/* Readers call into this function to open a new gdb_symtab, which,</span>
<a name="l00511"></a>00511 <span class="comment">   again, is passed around to other callbacks.  */</span>
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 <span class="keyword">static</span> <span class="keyword">struct </span>gdb_symtab *
<a name="l00514"></a>00514 jit_symtab_open_impl (<span class="keyword">struct</span> <a class="code" href="structgdb__symbol__callbacks.html">gdb_symbol_callbacks</a> *cb,
<a name="l00515"></a>00515                       <span class="keyword">struct</span> gdb_object *<span class="keywordtype">object</span>,
<a name="l00516"></a>00516                       <span class="keyword">const</span> <span class="keywordtype">char</span> *file_name)
<a name="l00517"></a>00517 {
<a name="l00518"></a>00518   <span class="keyword">struct </span>gdb_symtab *ret;
<a name="l00519"></a>00519 
<a name="l00520"></a>00520   <span class="comment">/* CB stays unused.  See comment in jit_object_open_impl.  */</span>
<a name="l00521"></a>00521 
<a name="l00522"></a>00522   ret = <a class="code" href="defs_8h.html#ab004b072c2eba9eb35ffb7b86a72b8c0">XZALLOC</a> (<span class="keyword">struct</span> gdb_symtab);
<a name="l00523"></a>00523   ret-&gt;file_name = file_name ? xstrdup (file_name) : xstrdup (<span class="stringliteral">&quot;&quot;</span>);
<a name="l00524"></a>00524   ret-&gt;next = <span class="keywordtype">object</span>-&gt;symtabs;
<a name="l00525"></a>00525   <span class="keywordtype">object</span>-&gt;symtabs = ret;
<a name="l00526"></a>00526   <span class="keywordflow">return</span> ret;
<a name="l00527"></a>00527 }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 <span class="comment">/* Returns true if the block corresponding to old should be placed</span>
<a name="l00530"></a>00530 <span class="comment">   before the block corresponding to new in the final blockvector.  */</span>
<a name="l00531"></a>00531 
<a name="l00532"></a>00532 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00533"></a>00533 compare_block (<span class="keyword">const</span> <span class="keyword">struct</span> gdb_block *<span class="keyword">const</span> old,
<a name="l00534"></a>00534                <span class="keyword">const</span> <span class="keyword">struct</span> gdb_block *<span class="keyword">const</span> <span class="keyword">new</span>)
<a name="l00535"></a>00535 {
<a name="l00536"></a>00536   <span class="keywordflow">if</span> (old == NULL)
<a name="l00537"></a>00537     <span class="keywordflow">return</span> 1;
<a name="l00538"></a>00538   <span class="keywordflow">if</span> (old-&gt;begin &lt; new-&gt;begin)
<a name="l00539"></a>00539     <span class="keywordflow">return</span> 1;
<a name="l00540"></a>00540   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (old-&gt;begin == new-&gt;begin)
<a name="l00541"></a>00541     {
<a name="l00542"></a>00542       <span class="keywordflow">if</span> (old-&gt;end &gt; new-&gt;end)
<a name="l00543"></a>00543         <span class="keywordflow">return</span> 1;
<a name="l00544"></a>00544       <span class="keywordflow">else</span>
<a name="l00545"></a>00545         <span class="keywordflow">return</span> 0;
<a name="l00546"></a>00546     }
<a name="l00547"></a>00547   <span class="keywordflow">else</span>
<a name="l00548"></a>00548     <span class="keywordflow">return</span> 0;
<a name="l00549"></a>00549 }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 <span class="comment">/* Called by readers to open a new gdb_block.  This function also</span>
<a name="l00552"></a>00552 <span class="comment">   inserts the new gdb_block in the correct place in the corresponding</span>
<a name="l00553"></a>00553 <span class="comment">   gdb_symtab.  */</span>
<a name="l00554"></a>00554 
<a name="l00555"></a>00555 <span class="keyword">static</span> <span class="keyword">struct </span>gdb_block *
<a name="l00556"></a>00556 jit_block_open_impl (<span class="keyword">struct</span> <a class="code" href="structgdb__symbol__callbacks.html">gdb_symbol_callbacks</a> *cb,
<a name="l00557"></a>00557                      <span class="keyword">struct</span> gdb_symtab *<a class="code" href="structsymtab.html">symtab</a>, <span class="keyword">struct</span> gdb_block *parent,
<a name="l00558"></a>00558                      <a class="code" href="jit-reader_8h.html#ab1101f50cba4d6ad71b4d4a89f01a695">GDB_CORE_ADDR</a> begin, <a class="code" href="jit-reader_8h.html#ab1101f50cba4d6ad71b4d4a89f01a695">GDB_CORE_ADDR</a> end, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>)
<a name="l00559"></a>00559 {
<a name="l00560"></a>00560   <span class="keyword">struct </span>gdb_block *<a class="code" href="structblock.html">block</a> = <a class="code" href="defs_8h.html#ab004b072c2eba9eb35ffb7b86a72b8c0">XZALLOC</a> (<span class="keyword">struct</span> gdb_block);
<a name="l00561"></a>00561 
<a name="l00562"></a>00562   block-&gt;next = symtab-&gt;blocks;
<a name="l00563"></a>00563   block-&gt;begin = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) begin;
<a name="l00564"></a>00564   block-&gt;end = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) end;
<a name="l00565"></a>00565   block-&gt;name = name ? xstrdup (name) : NULL;
<a name="l00566"></a>00566   block-&gt;parent = parent;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568   <span class="comment">/* Ensure that the blocks are inserted in the correct (reverse of</span>
<a name="l00569"></a>00569 <span class="comment">     the order expected by blockvector).  */</span>
<a name="l00570"></a>00570   <span class="keywordflow">if</span> (compare_block (symtab-&gt;blocks, block))
<a name="l00571"></a>00571     {
<a name="l00572"></a>00572       symtab-&gt;blocks = block;
<a name="l00573"></a>00573     }
<a name="l00574"></a>00574   <span class="keywordflow">else</span>
<a name="l00575"></a>00575     {
<a name="l00576"></a>00576       <span class="keyword">struct </span>gdb_block *i = symtab-&gt;blocks;
<a name="l00577"></a>00577 
<a name="l00578"></a>00578       <span class="keywordflow">for</span> (;; i = i-&gt;next)
<a name="l00579"></a>00579         {
<a name="l00580"></a>00580           <span class="comment">/* Guaranteed to terminate, since compare_block (NULL, _)</span>
<a name="l00581"></a>00581 <span class="comment">             returns 1.  */</span>
<a name="l00582"></a>00582           <span class="keywordflow">if</span> (compare_block (i-&gt;next, block))
<a name="l00583"></a>00583             {
<a name="l00584"></a>00584               block-&gt;next = i-&gt;next;
<a name="l00585"></a>00585               i-&gt;next = block;
<a name="l00586"></a>00586               <span class="keywordflow">break</span>;
<a name="l00587"></a>00587             }
<a name="l00588"></a>00588         }
<a name="l00589"></a>00589     }
<a name="l00590"></a>00590   symtab-&gt;nblocks++;
<a name="l00591"></a>00591 
<a name="l00592"></a>00592   <span class="keywordflow">return</span> block;
<a name="l00593"></a>00593 }
<a name="l00594"></a>00594 
<a name="l00595"></a>00595 <span class="comment">/* Readers call this to add a line mapping (from PC to line number) to</span>
<a name="l00596"></a>00596 <span class="comment">   a gdb_symtab.  */</span>
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00599"></a>00599 jit_symtab_line_mapping_add_impl (<span class="keyword">struct</span> <a class="code" href="structgdb__symbol__callbacks.html">gdb_symbol_callbacks</a> *cb,
<a name="l00600"></a>00600                                   <span class="keyword">struct</span> gdb_symtab *stab, <span class="keywordtype">int</span> nlines,
<a name="l00601"></a>00601                                   <span class="keyword">struct</span> <a class="code" href="structgdb__line__mapping.html">gdb_line_mapping</a> *map)
<a name="l00602"></a>00602 {
<a name="l00603"></a>00603   <span class="keywordtype">int</span> i;
<a name="l00604"></a>00604 
<a name="l00605"></a>00605   <span class="keywordflow">if</span> (nlines &lt; 1)
<a name="l00606"></a>00606     <span class="keywordflow">return</span>;
<a name="l00607"></a>00607 
<a name="l00608"></a>00608   stab-&gt;linetable = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structlinetable.html">linetable</a>)
<a name="l00609"></a>00609                              + (nlines - 1) * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structlinetable__entry.html">linetable_entry</a>));
<a name="l00610"></a>00610   stab-&gt;linetable-&gt;nitems = nlines;
<a name="l00611"></a>00611   <span class="keywordflow">for</span> (i = 0; i &lt; nlines; i++)
<a name="l00612"></a>00612     {
<a name="l00613"></a>00613       stab-&gt;linetable-&gt;item[i].pc = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) map[i].pc;
<a name="l00614"></a>00614       stab-&gt;linetable-&gt;item[i].line = map[i].<a class="code" href="structgdb__line__mapping.html#a413d834ed4a3259bef293e97ed1f9519">line</a>;
<a name="l00615"></a>00615     }
<a name="l00616"></a>00616 }
<a name="l00617"></a>00617 
<a name="l00618"></a>00618 <span class="comment">/* Called by readers to close a gdb_symtab.  Does not need to do</span>
<a name="l00619"></a>00619 <span class="comment">   anything as of now.  */</span>
<a name="l00620"></a>00620 
<a name="l00621"></a>00621 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00622"></a>00622 jit_symtab_close_impl (<span class="keyword">struct</span> <a class="code" href="structgdb__symbol__callbacks.html">gdb_symbol_callbacks</a> *cb,
<a name="l00623"></a>00623                        <span class="keyword">struct</span> gdb_symtab *stab)
<a name="l00624"></a>00624 {
<a name="l00625"></a>00625   <span class="comment">/* Right now nothing needs to be done here.  We may need to do some</span>
<a name="l00626"></a>00626 <span class="comment">     cleanup here in the future (again, without breaking the plugin</span>
<a name="l00627"></a>00627 <span class="comment">     ABI).  */</span>
<a name="l00628"></a>00628 }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 <span class="comment">/* Transform STAB to a proper symtab, and add it it OBJFILE.  */</span>
<a name="l00631"></a>00631 
<a name="l00632"></a>00632 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00633"></a>00633 finalize_symtab (<span class="keyword">struct</span> gdb_symtab *stab, <span class="keyword">struct</span> <a class="code" href="structobjfile.html">objfile</a> *<a class="code" href="structobjfile.html">objfile</a>)
<a name="l00634"></a>00634 {
<a name="l00635"></a>00635   <span class="keyword">struct </span>symtab *symtab;
<a name="l00636"></a>00636   <span class="keyword">struct </span>gdb_block *gdb_block_iter, *gdb_block_iter_tmp;
<a name="l00637"></a>00637   <span class="keyword">struct </span>block *block_iter;
<a name="l00638"></a>00638   <span class="keywordtype">int</span> actual_nblocks, i, blockvector_size;
<a name="l00639"></a>00639   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> begin, end;
<a name="l00640"></a>00640 
<a name="l00641"></a>00641   actual_nblocks = <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124aa44bafc9bc0e67afa2e5bb50467d77ae">FIRST_LOCAL_BLOCK</a> + stab-&gt;nblocks;
<a name="l00642"></a>00642 
<a name="l00643"></a>00643   symtab = <a class="code" href="symfile_8c.html#aafc3cce0320aaa35c9037f78fe662a7b">allocate_symtab</a> (stab-&gt;file_name, objfile);
<a name="l00644"></a>00644   <span class="comment">/* JIT compilers compile in memory.  */</span>
<a name="l00645"></a>00645   symtab-&gt;<a class="code" href="structsymtab.html#a3ced004986e8eb900b962fdc5a3ec392">dirname</a> = NULL;
<a name="l00646"></a>00646 
<a name="l00647"></a>00647   <span class="comment">/* Copy over the linetable entry if one was provided.  */</span>
<a name="l00648"></a>00648   <span class="keywordflow">if</span> (stab-&gt;linetable)
<a name="l00649"></a>00649     {
<a name="l00650"></a>00650       <span class="keywordtype">int</span> size = ((stab-&gt;linetable-&gt;nitems - 1)
<a name="l00651"></a>00651                   * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structlinetable__entry.html">linetable_entry</a>)
<a name="l00652"></a>00652                   + <span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structlinetable.html">linetable</a>));
<a name="l00653"></a>00653       <a class="code" href="symtab_8h.html#acfc8268f75517e671feb436a5a845265">LINETABLE</a> (symtab) = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>, size);
<a name="l00654"></a>00654       <a class="code" href="gdb__string_8h.html#a39ebe6a4e122707997e78b549a1e8c5e">memcpy</a> (<a class="code" href="symtab_8h.html#acfc8268f75517e671feb436a5a845265">LINETABLE</a> (symtab), stab-&gt;linetable, size);
<a name="l00655"></a>00655     }
<a name="l00656"></a>00656   <span class="keywordflow">else</span>
<a name="l00657"></a>00657     {
<a name="l00658"></a>00658       <a class="code" href="symtab_8h.html#acfc8268f75517e671feb436a5a845265">LINETABLE</a> (symtab) = NULL;
<a name="l00659"></a>00659     }
<a name="l00660"></a>00660 
<a name="l00661"></a>00661   blockvector_size = (<span class="keyword">sizeof</span> (<span class="keyword">struct </span><a class="code" href="structblockvector.html">blockvector</a>)
<a name="l00662"></a>00662                       + (actual_nblocks - 1) * <span class="keyword">sizeof</span> (<span class="keyword">struct </span>block *));
<a name="l00663"></a>00663   symtab-&gt;<a class="code" href="structsymtab.html#ad3337bb559de193e31e74b56ab244b15">blockvector</a> = obstack_alloc (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l00664"></a>00664                                        blockvector_size);
<a name="l00665"></a>00665 
<a name="l00666"></a>00666   <span class="comment">/* (begin, end) will contain the PC range this entire blockvector</span>
<a name="l00667"></a>00667 <span class="comment">     spans.  */</span>
<a name="l00668"></a>00668   symtab-&gt;<a class="code" href="structsymtab.html#ac7b1b53ffb88e931203f53942070bc7f">primary</a> = 1;
<a name="l00669"></a>00669   <a class="code" href="block_8h.html#aa3e34143098fee8d945850f8f665d903">BLOCKVECTOR_MAP</a> (symtab-&gt;<a class="code" href="structsymtab.html#ad3337bb559de193e31e74b56ab244b15">blockvector</a>) = NULL;
<a name="l00670"></a>00670   begin = stab-&gt;blocks-&gt;begin;
<a name="l00671"></a>00671   end = stab-&gt;blocks-&gt;end;
<a name="l00672"></a>00672   <a class="code" href="block_8h.html#ae5ee617a852fcf6fbff069f0800176a4">BLOCKVECTOR_NBLOCKS</a> (symtab-&gt;<a class="code" href="structsymtab.html#ad3337bb559de193e31e74b56ab244b15">blockvector</a>) = actual_nblocks;
<a name="l00673"></a>00673 
<a name="l00674"></a>00674   <span class="comment">/* First run over all the gdb_block objects, creating a real block</span>
<a name="l00675"></a>00675 <span class="comment">     object for each.  Simultaneously, keep setting the real_block</span>
<a name="l00676"></a>00676 <span class="comment">     fields.  */</span>
<a name="l00677"></a>00677   <span class="keywordflow">for</span> (i = (actual_nblocks - 1), gdb_block_iter = stab-&gt;blocks;
<a name="l00678"></a>00678        i &gt;= <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124aa44bafc9bc0e67afa2e5bb50467d77ae">FIRST_LOCAL_BLOCK</a>;
<a name="l00679"></a>00679        i--, gdb_block_iter = gdb_block_iter-&gt;next)
<a name="l00680"></a>00680     {
<a name="l00681"></a>00681       <span class="keyword">struct </span>block *new_block = <a class="code" href="block_8c.html#ad381b45b45e7442b5392b0cfdf878685">allocate_block</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>);
<a name="l00682"></a>00682       <span class="keyword">struct </span><a class="code" href="structsymbol.html">symbol</a> *block_name = <a class="code" href="symtab_8c.html#a6a7a23ba37378ec001ecd461c5137b83">allocate_symbol</a> (objfile);
<a name="l00683"></a>00683       <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *<a class="code" href="mdebugread_8c.html#aa2494894aca52a71313c23c460fe0443">block_type</a> = <a class="code" href="gdbtypes_8c.html#a4b444f0f6cfacb3f35d68fd7866402e2">arch_type</a> (<a class="code" href="objfiles_8c.html#a1c7101234ac2edc601fa465e48bc3463">get_objfile_arch</a> (objfile),
<a name="l00684"></a>00684                                            <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ad142a78789548b777dee1a3313e3e64f">TYPE_CODE_VOID</a>,
<a name="l00685"></a>00685                                            1,
<a name="l00686"></a>00686                                            <span class="stringliteral">&quot;void&quot;</span>);
<a name="l00687"></a>00687 
<a name="l00688"></a>00688       <a class="code" href="block_8h.html#a26e5c7aedbf6fe80c9fe11873493b8fe">BLOCK_DICT</a> (new_block) = <a class="code" href="dictionary_8c.html#a24ae162c5bb6794445dcde4c2e866c98">dict_create_linear</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l00689"></a>00689                                                    NULL);
<a name="l00690"></a>00690       <span class="comment">/* The address range.  */</span>
<a name="l00691"></a>00691       <a class="code" href="block_8h.html#a08fdff319bcd75e92b61c79139592af6">BLOCK_START</a> (new_block) = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) gdb_block_iter-&gt;begin;
<a name="l00692"></a>00692       <a class="code" href="block_8h.html#a61fcc8934fd274ea984eab2e0f787b6d">BLOCK_END</a> (new_block) = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) gdb_block_iter-&gt;end;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694       <span class="comment">/* The name.  */</span>
<a name="l00695"></a>00695       <a class="code" href="symtab_8h.html#a362f2f64212c0c45fb770a3f21ef5ab0">SYMBOL_DOMAIN</a> (block_name) = <a class="code" href="symtab_8h.html#a5c384cef81c5f50f32caadbfd6974a1aa15693f9d844450eb4bfd4b37114f4aed">VAR_DOMAIN</a>;
<a name="l00696"></a>00696       <a class="code" href="symtab_8h.html#a5237fd1140c320946b00046f4ca32c26">SYMBOL_ACLASS_INDEX</a> (block_name) = <a class="code" href="symtab_8h.html#a40bca6cf3ed5cfa15b1275e6750cdda3a1f1e8d54397f35889104cd7766fcec2b">LOC_BLOCK</a>;
<a name="l00697"></a>00697       <a class="code" href="symtab_8h.html#ae86281e4645c9471cb9cb496d7a5ee21">SYMBOL_SYMTAB</a> (block_name) = symtab;
<a name="l00698"></a>00698       <a class="code" href="symtab_8h.html#aadfeb02c4b5fc2b6764ad32eaccf0e58">SYMBOL_TYPE</a> (block_name) = <a class="code" href="gdbtypes_8c.html#ab21dd6531306fba2a7078534017df6fb">lookup_function_type</a> (block_type);
<a name="l00699"></a>00699       <a class="code" href="symtab_8h.html#a2c83ea82b28e9a9d8f9b655c2d502593">SYMBOL_BLOCK_VALUE</a> (block_name) = new_block;
<a name="l00700"></a>00700 
<a name="l00701"></a>00701       block_name-&gt;<a class="code" href="structsymbol.html#a324e2db145c0615116db355341f7b94c">ginfo</a>.<a class="code" href="structgeneral__symbol__info.html#a4347da5f5930f7be0ae6d9e400304884">name</a> = obstack_copy0 (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l00702"></a>00702                                               gdb_block_iter-&gt;name,
<a name="l00703"></a>00703                                               strlen (gdb_block_iter-&gt;name));
<a name="l00704"></a>00704 
<a name="l00705"></a>00705       <a class="code" href="block_8h.html#aeea4a00e65c2be0c8674106f38d8ab65">BLOCK_FUNCTION</a> (new_block) = block_name;
<a name="l00706"></a>00706 
<a name="l00707"></a>00707       <a class="code" href="block_8h.html#a84c4a3aa7b6b4d9a127a1c018dd6a776">BLOCKVECTOR_BLOCK</a> (symtab-&gt;<a class="code" href="structsymtab.html#ad3337bb559de193e31e74b56ab244b15">blockvector</a>, i) = new_block;
<a name="l00708"></a>00708       <span class="keywordflow">if</span> (begin &gt; <a class="code" href="block_8h.html#a08fdff319bcd75e92b61c79139592af6">BLOCK_START</a> (new_block))
<a name="l00709"></a>00709         begin = <a class="code" href="block_8h.html#a08fdff319bcd75e92b61c79139592af6">BLOCK_START</a> (new_block);
<a name="l00710"></a>00710       <span class="keywordflow">if</span> (end &lt; <a class="code" href="block_8h.html#a61fcc8934fd274ea984eab2e0f787b6d">BLOCK_END</a> (new_block))
<a name="l00711"></a>00711         end = <a class="code" href="block_8h.html#a61fcc8934fd274ea984eab2e0f787b6d">BLOCK_END</a> (new_block);
<a name="l00712"></a>00712 
<a name="l00713"></a>00713       gdb_block_iter-&gt;real_block = new_block;
<a name="l00714"></a>00714     }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716   <span class="comment">/* Now add the special blocks.  */</span>
<a name="l00717"></a>00717   block_iter = NULL;
<a name="l00718"></a>00718   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124aa44bafc9bc0e67afa2e5bb50467d77ae">FIRST_LOCAL_BLOCK</a>; i++)
<a name="l00719"></a>00719     {
<a name="l00720"></a>00720       <span class="keyword">struct </span>block *new_block;
<a name="l00721"></a>00721 
<a name="l00722"></a>00722       new_block = (i == <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124a973ee91cbe4b0cee4eb7603252a29bec">GLOBAL_BLOCK</a>
<a name="l00723"></a>00723                    ? <a class="code" href="block_8c.html#a9882629112d30f4bdbfdb57340388e9e">allocate_global_block</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>)
<a name="l00724"></a>00724                    : <a class="code" href="block_8c.html#ad381b45b45e7442b5392b0cfdf878685">allocate_block</a> (&amp;objfile-&gt;objfile_obstack));
<a name="l00725"></a>00725       <a class="code" href="block_8h.html#a26e5c7aedbf6fe80c9fe11873493b8fe">BLOCK_DICT</a> (new_block) = <a class="code" href="dictionary_8c.html#a24ae162c5bb6794445dcde4c2e866c98">dict_create_linear</a> (&amp;objfile-&gt;<a class="code" href="structobjfile.html#aab9cedc53383f1b540f0b725edd2d9be">objfile_obstack</a>,
<a name="l00726"></a>00726                                                    NULL);
<a name="l00727"></a>00727       <a class="code" href="block_8h.html#a8b7633ab6d6feadf9b2ee58e10ad8397">BLOCK_SUPERBLOCK</a> (new_block) = block_iter;
<a name="l00728"></a>00728       block_iter = new_block;
<a name="l00729"></a>00729 
<a name="l00730"></a>00730       <a class="code" href="block_8h.html#a08fdff319bcd75e92b61c79139592af6">BLOCK_START</a> (new_block) = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) begin;
<a name="l00731"></a>00731       <a class="code" href="block_8h.html#a61fcc8934fd274ea984eab2e0f787b6d">BLOCK_END</a> (new_block) = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) end;
<a name="l00732"></a>00732 
<a name="l00733"></a>00733       <a class="code" href="block_8h.html#a84c4a3aa7b6b4d9a127a1c018dd6a776">BLOCKVECTOR_BLOCK</a> (symtab-&gt;<a class="code" href="structsymtab.html#ad3337bb559de193e31e74b56ab244b15">blockvector</a>, i) = new_block;
<a name="l00734"></a>00734 
<a name="l00735"></a>00735       <span class="keywordflow">if</span> (i == <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124a973ee91cbe4b0cee4eb7603252a29bec">GLOBAL_BLOCK</a>)
<a name="l00736"></a>00736         <a class="code" href="block_8c.html#aa65d53f7571581825a6525b572ef93ca">set_block_symtab</a> (new_block, symtab);
<a name="l00737"></a>00737     }
<a name="l00738"></a>00738 
<a name="l00739"></a>00739   <span class="comment">/* Fill up the superblock fields for the real blocks, using the</span>
<a name="l00740"></a>00740 <span class="comment">     real_block fields populated earlier.  */</span>
<a name="l00741"></a>00741   <span class="keywordflow">for</span> (gdb_block_iter = stab-&gt;blocks;
<a name="l00742"></a>00742        gdb_block_iter;
<a name="l00743"></a>00743        gdb_block_iter = gdb_block_iter-&gt;next)
<a name="l00744"></a>00744     {
<a name="l00745"></a>00745       <span class="keywordflow">if</span> (gdb_block_iter-&gt;parent != NULL)
<a name="l00746"></a>00746         {
<a name="l00747"></a>00747           <span class="comment">/* If the plugin specifically mentioned a parent block, we</span>
<a name="l00748"></a>00748 <span class="comment">             use that.  */</span>
<a name="l00749"></a>00749           <a class="code" href="block_8h.html#a8b7633ab6d6feadf9b2ee58e10ad8397">BLOCK_SUPERBLOCK</a> (gdb_block_iter-&gt;real_block) =
<a name="l00750"></a>00750             gdb_block_iter-&gt;parent-&gt;real_block;
<a name="l00751"></a>00751         }
<a name="l00752"></a>00752       <span class="keywordflow">else</span>
<a name="l00753"></a>00753         {
<a name="l00754"></a>00754           <span class="comment">/* And if not, we set a default parent block.  */</span>
<a name="l00755"></a>00755           <a class="code" href="block_8h.html#a8b7633ab6d6feadf9b2ee58e10ad8397">BLOCK_SUPERBLOCK</a> (gdb_block_iter-&gt;real_block) =
<a name="l00756"></a>00756             <a class="code" href="block_8h.html#a84c4a3aa7b6b4d9a127a1c018dd6a776">BLOCKVECTOR_BLOCK</a> (symtab-&gt;<a class="code" href="structsymtab.html#ad3337bb559de193e31e74b56ab244b15">blockvector</a>, <a class="code" href="defs_8h.html#a8ec407cb404e1ae8ce984f792e83f124a4842990ca5391ee943c2069b28443a99">STATIC_BLOCK</a>);
<a name="l00757"></a>00757         }
<a name="l00758"></a>00758     }
<a name="l00759"></a>00759 
<a name="l00760"></a>00760   <span class="comment">/* Free memory.  */</span>
<a name="l00761"></a>00761   gdb_block_iter = stab-&gt;blocks;
<a name="l00762"></a>00762 
<a name="l00763"></a>00763   <span class="keywordflow">for</span> (gdb_block_iter = stab-&gt;blocks, gdb_block_iter_tmp = gdb_block_iter-&gt;next;
<a name="l00764"></a>00764        gdb_block_iter;
<a name="l00765"></a>00765        gdb_block_iter = gdb_block_iter_tmp)
<a name="l00766"></a>00766     {
<a name="l00767"></a>00767       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> ((<span class="keywordtype">void</span> *) gdb_block_iter-&gt;name);
<a name="l00768"></a>00768       <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (gdb_block_iter);
<a name="l00769"></a>00769     }
<a name="l00770"></a>00770   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (stab-&gt;linetable);
<a name="l00771"></a>00771   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> ((<span class="keywordtype">char</span> *) stab-&gt;file_name);
<a name="l00772"></a>00772   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (stab);
<a name="l00773"></a>00773 }
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 <span class="comment">/* Called when closing a gdb_objfile.  Converts OBJ to a proper</span>
<a name="l00776"></a>00776 <span class="comment">   objfile.  */</span>
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00779"></a>00779 jit_object_close_impl (<span class="keyword">struct</span> <a class="code" href="structgdb__symbol__callbacks.html">gdb_symbol_callbacks</a> *cb,
<a name="l00780"></a>00780                        <span class="keyword">struct</span> gdb_object *obj)
<a name="l00781"></a>00781 {
<a name="l00782"></a>00782   <span class="keyword">struct </span>gdb_symtab *i, *j;
<a name="l00783"></a>00783   <span class="keyword">struct </span>objfile *objfile;
<a name="l00784"></a>00784   jit_dbg_reader_data *priv_data;
<a name="l00785"></a>00785 
<a name="l00786"></a>00786   priv_data = cb-&gt;<a class="code" href="structgdb__symbol__callbacks.html#a9e0ed4ac2f13e63ddfe9bbb8c16abc8d">priv_data</a>;
<a name="l00787"></a>00787 
<a name="l00788"></a>00788   objfile = <a class="code" href="objfiles_8c.html#ac9a615292fe01a31b17319e67b84db2b">allocate_objfile</a> (NULL, <span class="stringliteral">&quot;&lt;&lt; JIT compiled code &gt;&gt;&quot;</span>,
<a name="l00789"></a>00789                               <a class="code" href="objfiles_8h.html#a5c3a990e32041dbf2726c6dca54721c5">OBJF_NOT_FILENAME</a>);
<a name="l00790"></a>00790   objfile-&gt;<a class="code" href="structobjfile.html#a4f3bc3943504820dff1f0362b38d2101">per_bfd</a>-&gt;<a class="code" href="structobjfile__per__bfd__storage.html#aa29ba6b52d98d7dbfbb65e9fdd84813c">gdbarch</a> = <a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ();
<a name="l00791"></a>00791 
<a name="l00792"></a>00792   <a class="code" href="minsyms_8c.html#a4a1bcb0ddf7084c407e304e2351b2eb0">terminate_minimal_symbol_table</a> (objfile);
<a name="l00793"></a>00793 
<a name="l00794"></a>00794   j = NULL;
<a name="l00795"></a>00795   <span class="keywordflow">for</span> (i = obj-&gt;symtabs; i; i = j)
<a name="l00796"></a>00796     {
<a name="l00797"></a>00797       j = i-&gt;next;
<a name="l00798"></a>00798       finalize_symtab (i, objfile);
<a name="l00799"></a>00799     }
<a name="l00800"></a>00800   add_objfile_entry (objfile, *priv_data);
<a name="l00801"></a>00801   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (obj);
<a name="l00802"></a>00802 }
<a name="l00803"></a>00803 
<a name="l00804"></a>00804 <span class="comment">/* Try to read CODE_ENTRY using the loaded jit reader (if any).</span>
<a name="l00805"></a>00805 <span class="comment">   ENTRY_ADDR is the address of the struct jit_code_entry in the</span>
<a name="l00806"></a>00806 <span class="comment">   inferior address space.  */</span>
<a name="l00807"></a>00807 
<a name="l00808"></a>00808 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00809"></a>00809 jit_reader_try_read_symtab (<span class="keyword">struct</span> <a class="code" href="structjit__code__entry.html">jit_code_entry</a> *code_entry,
<a name="l00810"></a>00810                             <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> entry_addr)
<a name="l00811"></a>00811 {
<a name="l00812"></a>00812   <span class="keywordtype">void</span> *gdb_mem;
<a name="l00813"></a>00813   <span class="keywordtype">int</span> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00814"></a>00814   jit_dbg_reader_data priv_data;
<a name="l00815"></a>00815   <span class="keyword">struct </span><a class="code" href="structgdb__reader__funcs.html">gdb_reader_funcs</a> *funcs;
<a name="l00816"></a>00816   <span class="keyword">volatile</span> <span class="keyword">struct </span><a class="code" href="structgdb__exception.html">gdb_exception</a> e;
<a name="l00817"></a>00817   <span class="keyword">struct </span><a class="code" href="structgdb__symbol__callbacks.html">gdb_symbol_callbacks</a> callbacks =
<a name="l00818"></a>00818     {
<a name="l00819"></a>00819       jit_object_open_impl,
<a name="l00820"></a>00820       jit_symtab_open_impl,
<a name="l00821"></a>00821       jit_block_open_impl,
<a name="l00822"></a>00822       jit_symtab_close_impl,
<a name="l00823"></a>00823       jit_object_close_impl,
<a name="l00824"></a>00824 
<a name="l00825"></a>00825       jit_symtab_line_mapping_add_impl,
<a name="l00826"></a>00826       jit_target_read_impl,
<a name="l00827"></a>00827 
<a name="l00828"></a>00828       &amp;priv_data
<a name="l00829"></a>00829     };
<a name="l00830"></a>00830 
<a name="l00831"></a>00831   priv_data = entry_addr;
<a name="l00832"></a>00832 
<a name="l00833"></a>00833   <span class="keywordflow">if</span> (!loaded_jit_reader)
<a name="l00834"></a>00834     <span class="keywordflow">return</span> 0;
<a name="l00835"></a>00835 
<a name="l00836"></a>00836   gdb_mem = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (code_entry-&gt;<a class="code" href="structjit__code__entry.html#ae2f93c024fc3a2fe83c5ab3561cf8bc1">symfile_size</a>);
<a name="l00837"></a>00837 
<a name="l00838"></a>00838   status = 1;
<a name="l00839"></a>00839   <a class="code" href="exceptions_8h.html#aef4514ee39b9305fddee27f49c7c34eb">TRY_CATCH</a> (e, <a class="code" href="exceptions_8h.html#abfa3a3b99557b11f5766baf69465fdf6ab50fde886a7de8c013bf2bd4e7c073a4">RETURN_MASK_ALL</a>)
<a name="l00840"></a>00840     if (<a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (code_entry-&gt;symfile_addr, gdb_mem,
<a name="l00841"></a>00841                             code_entry-&gt;symfile_size))
<a name="l00842"></a>00842       status = 0;
<a name="l00843"></a>00843   if (e.reason &lt; 0)
<a name="l00844"></a>00844     status = 0;
<a name="l00845"></a>00845 
<a name="l00846"></a>00846   if (status)
<a name="l00847"></a>00847     {
<a name="l00848"></a>00848       funcs = loaded_jit_reader-&gt;functions;
<a name="l00849"></a>00849       <span class="keywordflow">if</span> (funcs-&gt;<a class="code" href="structgdb__reader__funcs.html#a25388f459707bce471d8163796f645da">read</a> (funcs, &amp;callbacks, gdb_mem, code_entry-&gt;<a class="code" href="structjit__code__entry.html#ae2f93c024fc3a2fe83c5ab3561cf8bc1">symfile_size</a>)
<a name="l00850"></a>00850           != <a class="code" href="jit-reader_8h.html#a40831c20ece64c96efe16e43a7e094b7a2fe0274459c7e63e2bceba839da16783">GDB_SUCCESS</a>)
<a name="l00851"></a>00851         status = 0;
<a name="l00852"></a>00852     }
<a name="l00853"></a>00853 
<a name="l00854"></a>00854   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (gdb_mem);
<a name="l00855"></a>00855   <span class="keywordflow">if</span> (jit_debug &amp;&amp; status == 0)
<a name="l00856"></a>00856     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l00857"></a>00857                         <span class="stringliteral">&quot;Could not read symtab using the loaded JIT reader.\n&quot;</span>);
<a name="l00858"></a>00858   <span class="keywordflow">return</span> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00859"></a>00859 }
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 <span class="comment">/* Try to read CODE_ENTRY using BFD.  ENTRY_ADDR is the address of the</span>
<a name="l00862"></a>00862 <span class="comment">   struct jit_code_entry in the inferior address space.  */</span>
<a name="l00863"></a>00863 
<a name="l00864"></a>00864 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00865"></a>00865 jit_bfd_try_read_symtab (<span class="keyword">struct</span> <a class="code" href="structjit__code__entry.html">jit_code_entry</a> *code_entry,
<a name="l00866"></a>00866                          <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> entry_addr,
<a name="l00867"></a>00867                          <span class="keyword">struct</span> gdbarch *gdbarch)
<a name="l00868"></a>00868 {
<a name="l00869"></a>00869   bfd *nbfd;
<a name="l00870"></a>00870   <span class="keyword">struct </span><a class="code" href="structsection__addr__info.html">section_addr_info</a> *sai;
<a name="l00871"></a>00871   <span class="keyword">struct </span>bfd_section *sec;
<a name="l00872"></a>00872   <span class="keyword">struct </span>objfile *objfile;
<a name="l00873"></a>00873   <span class="keyword">struct </span>cleanup *old_cleanups;
<a name="l00874"></a>00874   <span class="keywordtype">int</span> i;
<a name="l00875"></a>00875   <span class="keyword">const</span> <span class="keyword">struct </span>bfd_arch_info *b;
<a name="l00876"></a>00876 
<a name="l00877"></a>00877   <span class="keywordflow">if</span> (jit_debug)
<a name="l00878"></a>00878     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l00879"></a>00879                         <span class="stringliteral">&quot;jit_register_code, symfile_addr = %s, &quot;</span>
<a name="l00880"></a>00880                         <span class="stringliteral">&quot;symfile_size = %s\n&quot;</span>,
<a name="l00881"></a>00881                         <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, code_entry-&gt;<a class="code" href="structjit__code__entry.html#a0e5f39796c30fedbc1c770e989c17b4e">symfile_addr</a>),
<a name="l00882"></a>00882                         <a class="code" href="utils_8c.html#ab74ba9d12a782e5964a4af4ddc5de3ae">pulongest</a> (code_entry-&gt;<a class="code" href="structjit__code__entry.html#ae2f93c024fc3a2fe83c5ab3561cf8bc1">symfile_size</a>));
<a name="l00883"></a>00883 
<a name="l00884"></a>00884   nbfd = bfd_open_from_target_memory (code_entry-&gt;<a class="code" href="structjit__code__entry.html#a0e5f39796c30fedbc1c770e989c17b4e">symfile_addr</a>,
<a name="l00885"></a>00885                                       code_entry-&gt;<a class="code" href="structjit__code__entry.html#ae2f93c024fc3a2fe83c5ab3561cf8bc1">symfile_size</a>, <a class="code" href="corefile_8c.html#aa6db5afe2b3bfa2cec356b9e68eea21d">gnutarget</a>);
<a name="l00886"></a>00886   <span class="keywordflow">if</span> (nbfd == NULL)
<a name="l00887"></a>00887     {
<a name="l00888"></a>00888       <a class="code" href="utils_8c.html#ae26e1e0ee2955f76539564ed45a40f9f">puts_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Error opening JITed symbol file, ignoring it.\n&quot;</span>));
<a name="l00889"></a>00889       <span class="keywordflow">return</span>;
<a name="l00890"></a>00890     }
<a name="l00891"></a>00891 
<a name="l00892"></a>00892   <span class="comment">/* Check the format.  NOTE: This initializes important data that GDB uses!</span>
<a name="l00893"></a>00893 <span class="comment">     We would segfault later without this line.  */</span>
<a name="l00894"></a>00894   <span class="keywordflow">if</span> (!bfd_check_format (nbfd, bfd_object))
<a name="l00895"></a>00895     {
<a name="l00896"></a>00896       <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l00897"></a>00897 <span class="stringliteral">JITed symbol file is not an object file, ignoring it.\n&quot;</span>));
<a name="l00898"></a>00898       <a class="code" href="gdb__bfd_8c.html#a1027b59a8494f937b5760901040dc125">gdb_bfd_unref</a> (nbfd);
<a name="l00899"></a>00899       <span class="keywordflow">return</span>;
<a name="l00900"></a>00900     }
<a name="l00901"></a>00901 
<a name="l00902"></a>00902   <span class="comment">/* Check bfd arch.  */</span>
<a name="l00903"></a>00903   b = <a class="code" href="gdbarch_8c.html#a305465885963fbf0fb5a7543594a7bff">gdbarch_bfd_arch_info</a> (gdbarch);
<a name="l00904"></a>00904   <span class="keywordflow">if</span> (b-&gt;compatible (b, bfd_get_arch_info (nbfd)) != b)
<a name="l00905"></a>00905     <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;JITed object file architecture %s is not compatible &quot;</span>
<a name="l00906"></a>00906                <span class="stringliteral">&quot;with target architecture %s.&quot;</span>), bfd_get_arch_info
<a name="l00907"></a>00907              (nbfd)-&gt;printable_name, b-&gt;printable_name);
<a name="l00908"></a>00908 
<a name="l00909"></a>00909   <span class="comment">/* Read the section address information out of the symbol file.  Since the</span>
<a name="l00910"></a>00910 <span class="comment">     file is generated by the JIT at runtime, it should all of the absolute</span>
<a name="l00911"></a>00911 <span class="comment">     addresses that we care about.  */</span>
<a name="l00912"></a>00912   sai = <a class="code" href="symfile_8c.html#acc68af57d564db87012cf48c0f205f26">alloc_section_addr_info</a> (bfd_count_sections (nbfd));
<a name="l00913"></a>00913   old_cleanups = <a class="code" href="utils_8c.html#aa870458757f70de1770cb969b01c8510">make_cleanup_free_section_addr_info</a> (sai);
<a name="l00914"></a>00914   i = 0;
<a name="l00915"></a>00915   <span class="keywordflow">for</span> (sec = nbfd-&gt;sections; sec != NULL; sec = sec-&gt;next)
<a name="l00916"></a>00916     <span class="keywordflow">if</span> ((bfd_get_section_flags (nbfd, sec) &amp; (SEC_ALLOC|SEC_LOAD)) != 0)
<a name="l00917"></a>00917       {
<a name="l00918"></a>00918         <span class="comment">/* We assume that these virtual addresses are absolute, and do not</span>
<a name="l00919"></a>00919 <span class="comment">           treat them as offsets.  */</span>
<a name="l00920"></a>00920         sai-&gt;<a class="code" href="structsection__addr__info.html#a5a54e749266a41c8975eeb0a027b8148">other</a>[i].<a class="code" href="structsection__addr__info_1_1other__sections.html#a06e45211057f46d640cea5d8d8c8d5ec">addr</a> = bfd_get_section_vma (nbfd, sec);
<a name="l00921"></a>00921         sai-&gt;<a class="code" href="structsection__addr__info.html#a5a54e749266a41c8975eeb0a027b8148">other</a>[i].<a class="code" href="structsection__addr__info_1_1other__sections.html#a568df4beecfb01eb888f05cd2d70b527">name</a> = xstrdup (bfd_get_section_name (nbfd, sec));
<a name="l00922"></a>00922         sai-&gt;<a class="code" href="structsection__addr__info.html#a5a54e749266a41c8975eeb0a027b8148">other</a>[i].<a class="code" href="structsection__addr__info_1_1other__sections.html#a2e69dff67606d0e6e9c21633e71d6cf2">sectindex</a> = sec-&gt;index;
<a name="l00923"></a>00923         ++i;
<a name="l00924"></a>00924       }
<a name="l00925"></a>00925   sai-&gt;<a class="code" href="structsection__addr__info.html#ae0c654fc47e50b5e78e218f2d65efe39">num_sections</a> = i;
<a name="l00926"></a>00926 
<a name="l00927"></a>00927   <span class="comment">/* This call does not take ownership of SAI.  */</span>
<a name="l00928"></a>00928   <a class="code" href="utils_8c.html#aefcbd004e34c553d07ce2a6b4a196852">make_cleanup_bfd_unref</a> (nbfd);
<a name="l00929"></a>00929   objfile = <a class="code" href="symfile_8c.html#a3e387e8ae6107a4d23f541fff40c2824">symbol_file_add_from_bfd</a> (nbfd, bfd_get_filename (nbfd), 0, sai,
<a name="l00930"></a>00930                                       <a class="code" href="objfiles_8h.html#a02a85dec7472a89888cd3c7575f88009">OBJF_SHARED</a> | <a class="code" href="objfiles_8h.html#a5c3a990e32041dbf2726c6dca54721c5">OBJF_NOT_FILENAME</a>, NULL);
<a name="l00931"></a>00931 
<a name="l00932"></a>00932   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (old_cleanups);
<a name="l00933"></a>00933   add_objfile_entry (objfile, entry_addr);
<a name="l00934"></a>00934 }
<a name="l00935"></a>00935 
<a name="l00936"></a>00936 <span class="comment">/* This function registers code associated with a JIT code entry.  It uses the</span>
<a name="l00937"></a>00937 <span class="comment">   pointer and size pair in the entry to read the symbol file from the remote</span>
<a name="l00938"></a>00938 <span class="comment">   and then calls symbol_file_add_from_local_memory to add it as though it were</span>
<a name="l00939"></a>00939 <span class="comment">   a symbol file added by the user.  */</span>
<a name="l00940"></a>00940 
<a name="l00941"></a>00941 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00942"></a>00942 jit_register_code (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l00943"></a>00943                    <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> entry_addr, <span class="keyword">struct</span> <a class="code" href="structjit__code__entry.html">jit_code_entry</a> *code_entry)
<a name="l00944"></a>00944 {
<a name="l00945"></a>00945   <span class="keywordtype">int</span> success;
<a name="l00946"></a>00946 
<a name="l00947"></a>00947   <span class="keywordflow">if</span> (jit_debug)
<a name="l00948"></a>00948     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l00949"></a>00949                         <span class="stringliteral">&quot;jit_register_code, symfile_addr = %s, &quot;</span>
<a name="l00950"></a>00950                         <span class="stringliteral">&quot;symfile_size = %s\n&quot;</span>,
<a name="l00951"></a>00951                         <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, code_entry-&gt;<a class="code" href="structjit__code__entry.html#a0e5f39796c30fedbc1c770e989c17b4e">symfile_addr</a>),
<a name="l00952"></a>00952                         <a class="code" href="utils_8c.html#ab74ba9d12a782e5964a4af4ddc5de3ae">pulongest</a> (code_entry-&gt;<a class="code" href="structjit__code__entry.html#ae2f93c024fc3a2fe83c5ab3561cf8bc1">symfile_size</a>));
<a name="l00953"></a>00953 
<a name="l00954"></a>00954   success = jit_reader_try_read_symtab (code_entry, entry_addr);
<a name="l00955"></a>00955 
<a name="l00956"></a>00956   <span class="keywordflow">if</span> (!success)
<a name="l00957"></a>00957     jit_bfd_try_read_symtab (code_entry, entry_addr, gdbarch);
<a name="l00958"></a>00958 }
<a name="l00959"></a>00959 
<a name="l00960"></a>00960 <span class="comment">/* This function unregisters JITed code and frees the corresponding</span>
<a name="l00961"></a>00961 <span class="comment">   objfile.  */</span>
<a name="l00962"></a>00962 
<a name="l00963"></a>00963 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00964"></a>00964 jit_unregister_code (<span class="keyword">struct</span> objfile *objfile)
<a name="l00965"></a>00965 {
<a name="l00966"></a>00966   <a class="code" href="objfiles_8c.html#abaf0cc9c95a939f0411ab167e17acdca">free_objfile</a> (objfile);
<a name="l00967"></a>00967 }
<a name="l00968"></a>00968 
<a name="l00969"></a>00969 <span class="comment">/* Look up the objfile with this code entry address.  */</span>
<a name="l00970"></a>00970 
<a name="l00971"></a>00971 <span class="keyword">static</span> <span class="keyword">struct </span>objfile *
<a name="l00972"></a>00972 jit_find_objf_with_entry_addr (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> entry_addr)
<a name="l00973"></a>00973 {
<a name="l00974"></a>00974   <span class="keyword">struct </span>objfile *objf;
<a name="l00975"></a>00975 
<a name="l00976"></a>00976   <a class="code" href="objfiles_8h.html#a8efee3b85a322006131a6056d45058b3">ALL_OBJFILES</a> (objf)
<a name="l00977"></a>00977     {
<a name="l00978"></a>00978       <span class="keyword">struct </span>jit_objfile_data *objf_data;
<a name="l00979"></a>00979 
<a name="l00980"></a>00980       objf_data = objfile_data (objf, jit_objfile_data);
<a name="l00981"></a>00981       <span class="keywordflow">if</span> (objf_data != NULL &amp;&amp; objf_data-&gt;addr == entry_addr)
<a name="l00982"></a>00982         <span class="keywordflow">return</span> objf;
<a name="l00983"></a>00983     }
<a name="l00984"></a>00984   <span class="keywordflow">return</span> NULL;
<a name="l00985"></a>00985 }
<a name="l00986"></a>00986 
<a name="l00987"></a>00987 <span class="comment">/* This is called when a breakpoint is deleted.  It updates the</span>
<a name="l00988"></a>00988 <span class="comment">   inferior&#39;s cache, if needed.  */</span>
<a name="l00989"></a>00989 
<a name="l00990"></a>00990 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00991"></a>00991 jit_breakpoint_deleted (<span class="keyword">struct</span> <a class="code" href="structbreakpoint.html">breakpoint</a> *b)
<a name="l00992"></a>00992 {
<a name="l00993"></a>00993   <span class="keyword">struct </span><a class="code" href="structbp__location.html">bp_location</a> *iter;
<a name="l00994"></a>00994 
<a name="l00995"></a>00995   <span class="keywordflow">if</span> (b-&gt;<a class="code" href="structbreakpoint.html#aefce6e7d22540b3fffaecd1264a0f73f">type</a> != <a class="code" href="breakpoint_8h.html#a67735d134567a4ba184d011f1db556cfaa189ad5fdf786f2921ba9635bdb926fe">bp_jit_event</a>)
<a name="l00996"></a>00996     <span class="keywordflow">return</span>;
<a name="l00997"></a>00997 
<a name="l00998"></a>00998   <span class="keywordflow">for</span> (iter = b-&gt;<a class="code" href="structbreakpoint.html#aa869260f7e4c94204275861d820bb1a9">loc</a>; iter != NULL; iter = iter-&gt;<a class="code" href="structbp__location.html#ab193cb38f87fea89105db96d94191541">next</a>)
<a name="l00999"></a>00999     {
<a name="l01000"></a>01000       <span class="keyword">struct </span>jit_program_space_data *ps_data;
<a name="l01001"></a>01001 
<a name="l01002"></a>01002       ps_data = program_space_data (iter-&gt;<a class="code" href="structbp__location.html#a0d597e3dbf754a5b8a3d0d84425de77d">pspace</a>, jit_program_space_data);
<a name="l01003"></a>01003       <span class="keywordflow">if</span> (ps_data != NULL &amp;&amp; ps_data-&gt;jit_breakpoint == iter-&gt;<a class="code" href="structbp__location.html#ade5cd870d1e7255c36ac84c2c6f1c4c2">owner</a>)
<a name="l01004"></a>01004         {
<a name="l01005"></a>01005           ps_data-&gt;cached_code_address = 0;
<a name="l01006"></a>01006           ps_data-&gt;jit_breakpoint = NULL;
<a name="l01007"></a>01007         }
<a name="l01008"></a>01008     }
<a name="l01009"></a>01009 }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011 <span class="comment">/* (Re-)Initialize the jit breakpoint if necessary.</span>
<a name="l01012"></a>01012 <span class="comment">   Return 0 on success.  */</span>
<a name="l01013"></a>01013 
<a name="l01014"></a>01014 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01015"></a>01015 jit_breakpoint_re_set_internal (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l01016"></a>01016                                 <span class="keyword">struct</span> jit_program_space_data *ps_data)
<a name="l01017"></a>01017 {
<a name="l01018"></a>01018   <span class="keyword">struct </span><a class="code" href="structbound__minimal__symbol.html">bound_minimal_symbol</a> reg_symbol;
<a name="l01019"></a>01019   <span class="keyword">struct </span><a class="code" href="structminimal__symbol.html">minimal_symbol</a> *desc_symbol;
<a name="l01020"></a>01020   <span class="keyword">struct </span>jit_objfile_data *objf_data;
<a name="l01021"></a>01021   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023   <span class="keywordflow">if</span> (ps_data-&gt;objfile == NULL)
<a name="l01024"></a>01024     {
<a name="l01025"></a>01025       <span class="comment">/* Lookup the registration symbol.  If it is missing, then we</span>
<a name="l01026"></a>01026 <span class="comment">         assume we are not attached to a JIT.  */</span>
<a name="l01027"></a>01027       reg_symbol = <a class="code" href="minsyms_8c.html#a2b5c5e7cf36bc97a96d7cf488afe7e4f">lookup_minimal_symbol_and_objfile</a> (jit_break_name);
<a name="l01028"></a>01028       <span class="keywordflow">if</span> (reg_symbol.minsym == NULL
<a name="l01029"></a>01029           || <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (reg_symbol.minsym) == 0)
<a name="l01030"></a>01030         <span class="keywordflow">return</span> 1;
<a name="l01031"></a>01031 
<a name="l01032"></a>01032       desc_symbol = <a class="code" href="minsyms_8c.html#af87f7a894386515074ddd71365bc09b8">lookup_minimal_symbol</a> (jit_descriptor_name, NULL,
<a name="l01033"></a>01033                                            reg_symbol.objfile);
<a name="l01034"></a>01034       <span class="keywordflow">if</span> (desc_symbol == NULL || <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (desc_symbol) == 0)
<a name="l01035"></a>01035         <span class="keywordflow">return</span> 1;
<a name="l01036"></a>01036 
<a name="l01037"></a>01037       objf_data = get_jit_objfile_data (reg_symbol.objfile);
<a name="l01038"></a>01038       objf_data-&gt;register_code = reg_symbol.minsym;
<a name="l01039"></a>01039       objf_data-&gt;descriptor = desc_symbol;
<a name="l01040"></a>01040 
<a name="l01041"></a>01041       ps_data-&gt;objfile = reg_symbol.objfile;
<a name="l01042"></a>01042     }
<a name="l01043"></a>01043   <span class="keywordflow">else</span>
<a name="l01044"></a>01044     objf_data = get_jit_objfile_data (ps_data-&gt;objfile);
<a name="l01045"></a>01045 
<a name="l01046"></a>01046   addr = <a class="code" href="symtab_8h.html#abee697b9e3bb4f4d164ad920a87ab854">SYMBOL_VALUE_ADDRESS</a> (objf_data-&gt;register_code);
<a name="l01047"></a>01047 
<a name="l01048"></a>01048   <span class="keywordflow">if</span> (jit_debug)
<a name="l01049"></a>01049     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l01050"></a>01050                         <span class="stringliteral">&quot;jit_breakpoint_re_set_internal, &quot;</span>
<a name="l01051"></a>01051                         <span class="stringliteral">&quot;breakpoint_addr = %s\n&quot;</span>,
<a name="l01052"></a>01052                         <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, addr));
<a name="l01053"></a>01053 
<a name="l01054"></a>01054   <span class="keywordflow">if</span> (ps_data-&gt;cached_code_address == addr)
<a name="l01055"></a>01055     <span class="keywordflow">return</span> 1;
<a name="l01056"></a>01056 
<a name="l01057"></a>01057   <span class="comment">/* Delete the old breakpoint.  */</span>
<a name="l01058"></a>01058   <span class="keywordflow">if</span> (ps_data-&gt;jit_breakpoint != NULL)
<a name="l01059"></a>01059     <a class="code" href="breakpoint_8c.html#a0701191361b1ed0d40d76661e88de3f4">delete_breakpoint</a> (ps_data-&gt;jit_breakpoint);
<a name="l01060"></a>01060 
<a name="l01061"></a>01061   <span class="comment">/* Put a breakpoint in the registration symbol.  */</span>
<a name="l01062"></a>01062   ps_data-&gt;cached_code_address = addr;
<a name="l01063"></a>01063   ps_data-&gt;jit_breakpoint = <a class="code" href="breakpoint_8c.html#a99095e21096063a3abde99edc149accf">create_jit_event_breakpoint</a> (gdbarch, addr);
<a name="l01064"></a>01064 
<a name="l01065"></a>01065   <span class="keywordflow">return</span> 0;
<a name="l01066"></a>01066 }
<a name="l01067"></a>01067 
<a name="l01068"></a>01068 <span class="comment">/* The private data passed around in the frame unwind callback</span>
<a name="l01069"></a>01069 <span class="comment">   functions.  */</span>
<a name="l01070"></a>01070 
<a name="l01071"></a>01071 <span class="keyword">struct </span>jit_unwind_private
<a name="l01072"></a>01072 {
<a name="l01073"></a>01073   <span class="comment">/* Cached register values.  See jit_frame_sniffer to see how this</span>
<a name="l01074"></a>01074 <span class="comment">     works.  */</span>
<a name="l01075"></a>01075   <span class="keyword">struct </span><a class="code" href="structgdb__reg__value.html">gdb_reg_value</a> **registers;
<a name="l01076"></a>01076 
<a name="l01077"></a>01077   <span class="comment">/* The frame being unwound.  */</span>
<a name="l01078"></a>01078   <span class="keyword">struct </span>frame_info *this_frame;
<a name="l01079"></a>01079 };
<a name="l01080"></a>01080 
<a name="l01081"></a>01081 <span class="comment">/* Sets the value of a particular register in this frame.  */</span>
<a name="l01082"></a>01082 
<a name="l01083"></a>01083 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01084"></a>01084 jit_unwind_reg_set_impl (<span class="keyword">struct</span> <a class="code" href="structgdb__unwind__callbacks.html">gdb_unwind_callbacks</a> *cb, <span class="keywordtype">int</span> dwarf_regnum,
<a name="l01085"></a>01085                          <span class="keyword">struct</span> <a class="code" href="structgdb__reg__value.html">gdb_reg_value</a> *value)
<a name="l01086"></a>01086 {
<a name="l01087"></a>01087   <span class="keyword">struct </span>jit_unwind_private *priv;
<a name="l01088"></a>01088   <span class="keywordtype">int</span> gdb_reg;
<a name="l01089"></a>01089 
<a name="l01090"></a>01090   priv = cb-&gt;<a class="code" href="structgdb__unwind__callbacks.html#a5fa8e0cb7ec898580e32ec07bea62acc">priv_data</a>;
<a name="l01091"></a>01091 
<a name="l01092"></a>01092   gdb_reg = <a class="code" href="gdbarch_8c.html#a15d37bbfaa9e103fe112bd8b116de0f9">gdbarch_dwarf2_reg_to_regnum</a> (<a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (priv-&gt;this_frame),
<a name="l01093"></a>01093                                           dwarf_regnum);
<a name="l01094"></a>01094   <span class="keywordflow">if</span> (gdb_reg == -1)
<a name="l01095"></a>01095     {
<a name="l01096"></a>01096       <span class="keywordflow">if</span> (jit_debug)
<a name="l01097"></a>01097         <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>,
<a name="l01098"></a>01098                             <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Could not recognize DWARF regnum %d&quot;</span>),
<a name="l01099"></a>01099                             dwarf_regnum);
<a name="l01100"></a>01100       <span class="keywordflow">return</span>;
<a name="l01101"></a>01101     }
<a name="l01102"></a>01102 
<a name="l01103"></a>01103   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (priv-&gt;registers);
<a name="l01104"></a>01104   priv-&gt;registers[gdb_reg] = value;
<a name="l01105"></a>01105 }
<a name="l01106"></a>01106 
<a name="l01107"></a>01107 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01108"></a>01108 reg_value_free_impl (<span class="keyword">struct</span> <a class="code" href="structgdb__reg__value.html">gdb_reg_value</a> *value)
<a name="l01109"></a>01109 {
<a name="l01110"></a>01110   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (value);
<a name="l01111"></a>01111 }
<a name="l01112"></a>01112 
<a name="l01113"></a>01113 <span class="comment">/* Get the value of register REGNUM in the previous frame.  */</span>
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structgdb__reg__value.html">gdb_reg_value</a> *
<a name="l01116"></a>01116 jit_unwind_reg_get_impl (<span class="keyword">struct</span> <a class="code" href="structgdb__unwind__callbacks.html">gdb_unwind_callbacks</a> *cb, <span class="keywordtype">int</span> <a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>)
<a name="l01117"></a>01117 {
<a name="l01118"></a>01118   <span class="keyword">struct </span>jit_unwind_private *priv;
<a name="l01119"></a>01119   <span class="keyword">struct </span><a class="code" href="structgdb__reg__value.html">gdb_reg_value</a> *<a class="code" href="structgdb__reg__value.html#aa041964fc56c7e1edf3494d95643fbe8">value</a>;
<a name="l01120"></a>01120   <span class="keywordtype">int</span> gdb_reg, <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l01121"></a>01121   <span class="keyword">struct </span>gdbarch *frame_arch;
<a name="l01122"></a>01122 
<a name="l01123"></a>01123   priv = cb-&gt;<a class="code" href="structgdb__unwind__callbacks.html#a5fa8e0cb7ec898580e32ec07bea62acc">priv_data</a>;
<a name="l01124"></a>01124   frame_arch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (priv-&gt;this_frame);
<a name="l01125"></a>01125 
<a name="l01126"></a>01126   gdb_reg = <a class="code" href="gdbarch_8c.html#a15d37bbfaa9e103fe112bd8b116de0f9">gdbarch_dwarf2_reg_to_regnum</a> (frame_arch, regnum);
<a name="l01127"></a>01127   size = <a class="code" href="regcache_8c.html#a4c51fa25edb9ce25451b9dc7bd127aac">register_size</a> (frame_arch, gdb_reg);
<a name="l01128"></a>01128   value = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> <a class="code" href="structgdb__reg__value.html">gdb_reg_value</a>) + size - 1);
<a name="l01129"></a>01129   value-&gt;<a class="code" href="structgdb__reg__value.html#a45a73e2f27e676978d4d18ad76f6b5cd">defined</a> = <a class="code" href="frame_8c.html#acb58b853bf35561dc731bad7cea86efd">deprecated_frame_register_read</a> (priv-&gt;this_frame, gdb_reg,
<a name="l01130"></a>01130                                                    value-&gt;<a class="code" href="structgdb__reg__value.html#aa041964fc56c7e1edf3494d95643fbe8">value</a>);
<a name="l01131"></a>01131   value-&gt;<a class="code" href="structgdb__reg__value.html#ab6c3ef00ac402cc2da4d2f9cfb1becd5">size</a> = <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l01132"></a>01132   value-&gt;<a class="code" href="structgdb__reg__value.html#aad60c0179c550d7327330e72c302cf90">free</a> = reg_value_free_impl;
<a name="l01133"></a>01133   <span class="keywordflow">return</span> value;
<a name="l01134"></a>01134 }
<a name="l01135"></a>01135 
<a name="l01136"></a>01136 <span class="comment">/* gdb_reg_value has a free function, which must be called on each</span>
<a name="l01137"></a>01137 <span class="comment">   saved register value.  */</span>
<a name="l01138"></a>01138 
<a name="l01139"></a>01139 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01140"></a>01140 jit_dealloc_cache (<span class="keyword">struct</span> frame_info *this_frame, <span class="keywordtype">void</span> *cache)
<a name="l01141"></a>01141 {
<a name="l01142"></a>01142   <span class="keyword">struct </span>jit_unwind_private *priv_data = cache;
<a name="l01143"></a>01143   <span class="keyword">struct </span>gdbarch *frame_arch;
<a name="l01144"></a>01144   <span class="keywordtype">int</span> i;
<a name="l01145"></a>01145 
<a name="l01146"></a>01146   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (priv_data-&gt;registers);
<a name="l01147"></a>01147   frame_arch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (priv_data-&gt;this_frame);
<a name="l01148"></a>01148 
<a name="l01149"></a>01149   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (frame_arch); i++)
<a name="l01150"></a>01150     <span class="keywordflow">if</span> (priv_data-&gt;registers[i] &amp;&amp; priv_data-&gt;registers[i]-&gt;free)
<a name="l01151"></a>01151       priv_data-&gt;registers[i]-&gt;free (priv_data-&gt;registers[i]);
<a name="l01152"></a>01152 
<a name="l01153"></a>01153   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (priv_data-&gt;registers);
<a name="l01154"></a>01154   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (priv_data);
<a name="l01155"></a>01155 }
<a name="l01156"></a>01156 
<a name="l01157"></a>01157 <span class="comment">/* The frame sniffer for the pseudo unwinder.</span>
<a name="l01158"></a>01158 <span class="comment"></span>
<a name="l01159"></a>01159 <span class="comment">   While this is nominally a frame sniffer, in the case where the JIT</span>
<a name="l01160"></a>01160 <span class="comment">   reader actually recognizes the frame, it does a lot more work -- it</span>
<a name="l01161"></a>01161 <span class="comment">   unwinds the frame and saves the corresponding register values in</span>
<a name="l01162"></a>01162 <span class="comment">   the cache.  jit_frame_prev_register simply returns the saved</span>
<a name="l01163"></a>01163 <span class="comment">   register values.  */</span>
<a name="l01164"></a>01164 
<a name="l01165"></a>01165 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01166"></a>01166 jit_frame_sniffer (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structframe__unwind.html">frame_unwind</a> *<span class="keyword">self</span>,
<a name="l01167"></a>01167                    <span class="keyword">struct</span> frame_info *this_frame, <span class="keywordtype">void</span> **cache)
<a name="l01168"></a>01168 {
<a name="l01169"></a>01169   <span class="keyword">struct </span>jit_unwind_private *priv_data;
<a name="l01170"></a>01170   <span class="keyword">struct </span><a class="code" href="structgdb__unwind__callbacks.html">gdb_unwind_callbacks</a> callbacks;
<a name="l01171"></a>01171   <span class="keyword">struct </span><a class="code" href="structgdb__reader__funcs.html">gdb_reader_funcs</a> *funcs;
<a name="l01172"></a>01172 
<a name="l01173"></a>01173   callbacks.reg_get = jit_unwind_reg_get_impl;
<a name="l01174"></a>01174   callbacks.reg_set = jit_unwind_reg_set_impl;
<a name="l01175"></a>01175   callbacks.<a class="code" href="structgdb__symbol__callbacks.html#a795cda9cdb824c7ca341bda3e277d1ad">target_read</a> = jit_target_read_impl;
<a name="l01176"></a>01176 
<a name="l01177"></a>01177   <span class="keywordflow">if</span> (loaded_jit_reader == NULL)
<a name="l01178"></a>01178     <span class="keywordflow">return</span> 0;
<a name="l01179"></a>01179 
<a name="l01180"></a>01180   funcs = loaded_jit_reader-&gt;functions;
<a name="l01181"></a>01181 
<a name="l01182"></a>01182   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!*cache);
<a name="l01183"></a>01183 
<a name="l01184"></a>01184   *cache = <a class="code" href="defs_8h.html#ab004b072c2eba9eb35ffb7b86a72b8c0">XZALLOC</a> (<span class="keyword">struct</span> jit_unwind_private);
<a name="l01185"></a>01185   priv_data = *cache;
<a name="l01186"></a>01186   priv_data-&gt;registers =
<a name="l01187"></a>01187     <a class="code" href="defs_8h.html#a4c67016fda510e35550be38ad53c44d1">XCALLOC</a> (<a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (<a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame)),
<a name="l01188"></a>01188              <span class="keyword">struct</span> <a class="code" href="structgdb__reg__value.html">gdb_reg_value</a> *);
<a name="l01189"></a>01189   priv_data-&gt;this_frame = this_frame;
<a name="l01190"></a>01190 
<a name="l01191"></a>01191   callbacks.<a class="code" href="structgdb__symbol__callbacks.html#a9e0ed4ac2f13e63ddfe9bbb8c16abc8d">priv_data</a> = <a class="code" href="structgdb__reader__funcs.html#a4f4031efe68755cf683e09916b72dd3a">priv_data</a>;
<a name="l01192"></a>01192 
<a name="l01193"></a>01193   <span class="comment">/* Try to coax the provided unwinder to unwind the stack */</span>
<a name="l01194"></a>01194   <span class="keywordflow">if</span> (funcs-&gt;<a class="code" href="structgdb__reader__funcs.html#aa9ce6fc1adecb7bf521018d0139d91f8">unwind</a> (funcs, &amp;callbacks) == <a class="code" href="jit-reader_8h.html#a40831c20ece64c96efe16e43a7e094b7a2fe0274459c7e63e2bceba839da16783">GDB_SUCCESS</a>)
<a name="l01195"></a>01195     {
<a name="l01196"></a>01196       <span class="keywordflow">if</span> (jit_debug)
<a name="l01197"></a>01197         <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Successfully unwound frame using &quot;</span>
<a name="l01198"></a>01198                                           <span class="stringliteral">&quot;JIT reader.\n&quot;</span>));
<a name="l01199"></a>01199       <span class="keywordflow">return</span> 1;
<a name="l01200"></a>01200     }
<a name="l01201"></a>01201   <span class="keywordflow">if</span> (jit_debug)
<a name="l01202"></a>01202     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Could not unwind frame using &quot;</span>
<a name="l01203"></a>01203                                       <span class="stringliteral">&quot;JIT reader.\n&quot;</span>));
<a name="l01204"></a>01204 
<a name="l01205"></a>01205   jit_dealloc_cache (this_frame, *cache);
<a name="l01206"></a>01206   *cache = NULL;
<a name="l01207"></a>01207 
<a name="l01208"></a>01208   <span class="keywordflow">return</span> 0;
<a name="l01209"></a>01209 }
<a name="l01210"></a>01210 
<a name="l01211"></a>01211 
<a name="l01212"></a>01212 <span class="comment">/* The frame_id function for the pseudo unwinder.  Relays the call to</span>
<a name="l01213"></a>01213 <span class="comment">   the loaded plugin.  */</span>
<a name="l01214"></a>01214 
<a name="l01215"></a>01215 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01216"></a>01216 jit_frame_this_id (<span class="keyword">struct</span> frame_info *this_frame, <span class="keywordtype">void</span> **cache,
<a name="l01217"></a>01217                    <span class="keyword">struct</span> <a class="code" href="structframe__id.html">frame_id</a> *this_id)
<a name="l01218"></a>01218 {
<a name="l01219"></a>01219   <span class="keyword">struct </span>jit_unwind_private private;
<a name="l01220"></a>01220   <span class="keyword">struct </span><a class="code" href="structgdb__frame__id.html">gdb_frame_id</a> <a class="code" href="structframe__id.html">frame_id</a>;
<a name="l01221"></a>01221   <span class="keyword">struct </span><a class="code" href="structgdb__reader__funcs.html">gdb_reader_funcs</a> *funcs;
<a name="l01222"></a>01222   <span class="keyword">struct </span><a class="code" href="structgdb__unwind__callbacks.html">gdb_unwind_callbacks</a> callbacks;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224   <span class="keyword">private</span>.registers = NULL;
<a name="l01225"></a>01225   <span class="keyword">private</span>.this_frame = this_frame;
<a name="l01226"></a>01226 
<a name="l01227"></a>01227   <span class="comment">/* We don&#39;t expect the frame_id function to set any registers, so we</span>
<a name="l01228"></a>01228 <span class="comment">     set reg_set to NULL.  */</span>
<a name="l01229"></a>01229   callbacks.reg_get = jit_unwind_reg_get_impl;
<a name="l01230"></a>01230   callbacks.reg_set = NULL;
<a name="l01231"></a>01231   callbacks.<a class="code" href="structgdb__symbol__callbacks.html#a795cda9cdb824c7ca341bda3e277d1ad">target_read</a> = jit_target_read_impl;
<a name="l01232"></a>01232   callbacks.<a class="code" href="structgdb__symbol__callbacks.html#a9e0ed4ac2f13e63ddfe9bbb8c16abc8d">priv_data</a> = &amp;<span class="keyword">private</span>;
<a name="l01233"></a>01233 
<a name="l01234"></a>01234   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (loaded_jit_reader);
<a name="l01235"></a>01235   funcs = loaded_jit_reader-&gt;functions;
<a name="l01236"></a>01236 
<a name="l01237"></a>01237   <a class="code" href="structframe__id.html">frame_id</a> = funcs-&gt;<a class="code" href="structgdb__reader__funcs.html#ab495da7093f707fa8e04638eded711c7">get_frame_id</a> (funcs, &amp;callbacks);
<a name="l01238"></a>01238   *this_id = <a class="code" href="frame_8c.html#a7f32da6ddc275b4684c301448d891f5b">frame_id_build</a> (<a class="code" href="structframe__id.html">frame_id</a>.stack_address, <a class="code" href="structframe__id.html">frame_id</a>.code_address);
<a name="l01239"></a>01239 }
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 <span class="comment">/* Pseudo unwinder function.  Reads the previously fetched value for</span>
<a name="l01242"></a>01242 <span class="comment">   the register from the cache.  */</span>
<a name="l01243"></a>01243 
<a name="l01244"></a>01244 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l01245"></a>01245 jit_frame_prev_register (<span class="keyword">struct</span> frame_info *this_frame, <span class="keywordtype">void</span> **cache, <span class="keywordtype">int</span> <a class="code" href="structreg.html">reg</a>)
<a name="l01246"></a>01246 {
<a name="l01247"></a>01247   <span class="keyword">struct </span>jit_unwind_private *priv = *cache;
<a name="l01248"></a>01248   <span class="keyword">struct </span><a class="code" href="structgdb__reg__value.html">gdb_reg_value</a> *<a class="code" href="structgdb__reg__value.html#aa041964fc56c7e1edf3494d95643fbe8">value</a>;
<a name="l01249"></a>01249 
<a name="l01250"></a>01250   <span class="keywordflow">if</span> (priv == NULL)
<a name="l01251"></a>01251     <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#a67cc0ab2f5ae49818e1f9648bea131c9">frame_unwind_got_optimized</a> (this_frame, reg);
<a name="l01252"></a>01252 
<a name="l01253"></a>01253   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (priv-&gt;registers);
<a name="l01254"></a>01254   value = priv-&gt;registers[reg];
<a name="l01255"></a>01255   <span class="keywordflow">if</span> (value &amp;&amp; value-&gt;<a class="code" href="structgdb__reg__value.html#a45a73e2f27e676978d4d18ad76f6b5cd">defined</a>)
<a name="l01256"></a>01256     <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#ae67cb1c60367c6ae67ba810d2d05665c">frame_unwind_got_bytes</a> (this_frame, reg, value-&gt;<a class="code" href="structgdb__reg__value.html#aa041964fc56c7e1edf3494d95643fbe8">value</a>);
<a name="l01257"></a>01257   <span class="keywordflow">else</span>
<a name="l01258"></a>01258     <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#a67cc0ab2f5ae49818e1f9648bea131c9">frame_unwind_got_optimized</a> (this_frame, reg);
<a name="l01259"></a>01259 }
<a name="l01260"></a>01260 
<a name="l01261"></a>01261 <span class="comment">/* Relay everything back to the unwinder registered by the JIT debug</span>
<a name="l01262"></a>01262 <span class="comment">   info reader.*/</span>
<a name="l01263"></a>01263 
<a name="l01264"></a>01264 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structframe__unwind.html">frame_unwind</a> jit_frame_unwind =
<a name="l01265"></a>01265 {
<a name="l01266"></a>01266   <a class="code" href="frame_8h.html#a3ca2c0bc7578bf3d337e34b2c08a6c5faeb4f7fd6d9e397d1141feb133746637a">NORMAL_FRAME</a>,
<a name="l01267"></a>01267   <a class="code" href="frame-unwind_8c.html#aa950afe60921514574c6150f0821f05c">default_frame_unwind_stop_reason</a>,
<a name="l01268"></a>01268   jit_frame_this_id,
<a name="l01269"></a>01269   jit_frame_prev_register,
<a name="l01270"></a>01270   NULL,
<a name="l01271"></a>01271   jit_frame_sniffer,
<a name="l01272"></a>01272   jit_dealloc_cache
<a name="l01273"></a>01273 };
<a name="l01274"></a>01274 
<a name="l01275"></a>01275 
<a name="l01276"></a>01276 <span class="comment">/* This is the information that is stored at jit_gdbarch_data for each</span>
<a name="l01277"></a>01277 <span class="comment">   architecture.  */</span>
<a name="l01278"></a>01278 
<a name="l01279"></a>01279 <span class="keyword">struct </span>jit_gdbarch_data_type
<a name="l01280"></a>01280 {
<a name="l01281"></a>01281   <span class="comment">/* Has the (pseudo) unwinder been prepended? */</span>
<a name="l01282"></a>01282   <span class="keywordtype">int</span> unwinder_registered;
<a name="l01283"></a>01283 };
<a name="l01284"></a>01284 
<a name="l01285"></a>01285 <span class="comment">/* Check GDBARCH and prepend the pseudo JIT unwinder if needed.  */</span>
<a name="l01286"></a>01286 
<a name="l01287"></a>01287 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01288"></a>01288 jit_prepend_unwinder (<span class="keyword">struct</span> gdbarch *gdbarch)
<a name="l01289"></a>01289 {
<a name="l01290"></a>01290   <span class="keyword">struct </span>jit_gdbarch_data_type *data;
<a name="l01291"></a>01291 
<a name="l01292"></a>01292   data = <a class="code" href="gdbarch_8c.html#af5b48a62893f4f5f453c3c27ad3b44f7">gdbarch_data</a> (gdbarch, jit_gdbarch_data);
<a name="l01293"></a>01293   <span class="keywordflow">if</span> (!data-&gt;unwinder_registered)
<a name="l01294"></a>01294     {
<a name="l01295"></a>01295       <a class="code" href="frame-unwind_8c.html#a731c456ce19a87c968bfa663c6245675">frame_unwind_prepend_unwinder</a> (gdbarch, &amp;jit_frame_unwind);
<a name="l01296"></a>01296       data-&gt;unwinder_registered = 1;
<a name="l01297"></a>01297     }
<a name="l01298"></a>01298 }
<a name="l01299"></a>01299 
<a name="l01300"></a>01300 <span class="comment">/* Register any already created translations.  */</span>
<a name="l01301"></a>01301 
<a name="l01302"></a>01302 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01303"></a>01303 jit_inferior_init (<span class="keyword">struct</span> gdbarch *gdbarch)
<a name="l01304"></a>01304 {
<a name="l01305"></a>01305   <span class="keyword">struct </span><a class="code" href="structjit__descriptor.html">jit_descriptor</a> descriptor;
<a name="l01306"></a>01306   <span class="keyword">struct </span><a class="code" href="structjit__code__entry.html">jit_code_entry</a> cur_entry;
<a name="l01307"></a>01307   <span class="keyword">struct </span>jit_program_space_data *ps_data;
<a name="l01308"></a>01308   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> cur_entry_addr;
<a name="l01309"></a>01309 
<a name="l01310"></a>01310   <span class="keywordflow">if</span> (jit_debug)
<a name="l01311"></a>01311     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;jit_inferior_init\n&quot;</span>);
<a name="l01312"></a>01312 
<a name="l01313"></a>01313   jit_prepend_unwinder (gdbarch);
<a name="l01314"></a>01314 
<a name="l01315"></a>01315   ps_data = get_jit_program_space_data ();
<a name="l01316"></a>01316   <span class="keywordflow">if</span> (jit_breakpoint_re_set_internal (gdbarch, ps_data) != 0)
<a name="l01317"></a>01317     <span class="keywordflow">return</span>;
<a name="l01318"></a>01318 
<a name="l01319"></a>01319   <span class="comment">/* Read the descriptor so we can check the version number and load</span>
<a name="l01320"></a>01320 <span class="comment">     any already JITed functions.  */</span>
<a name="l01321"></a>01321   <span class="keywordflow">if</span> (!jit_read_descriptor (gdbarch, &amp;descriptor, ps_data))
<a name="l01322"></a>01322     <span class="keywordflow">return</span>;
<a name="l01323"></a>01323 
<a name="l01324"></a>01324   <span class="comment">/* Check that the version number agrees with that we support.  */</span>
<a name="l01325"></a>01325   <span class="keywordflow">if</span> (descriptor.<a class="code" href="structjit__descriptor.html#a99a4d52c382bfded369e98acc42b38c7">version</a> != 1)
<a name="l01326"></a>01326     {
<a name="l01327"></a>01327       <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unsupported JIT protocol version %ld &quot;</span>
<a name="l01328"></a>01328                            <span class="stringliteral">&quot;in descriptor (expected 1)\n&quot;</span>),
<a name="l01329"></a>01329                          (<span class="keywordtype">long</span>) descriptor.<a class="code" href="structjit__descriptor.html#a99a4d52c382bfded369e98acc42b38c7">version</a>);
<a name="l01330"></a>01330       <span class="keywordflow">return</span>;
<a name="l01331"></a>01331     }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333   <span class="comment">/* If we&#39;ve attached to a running program, we need to check the descriptor</span>
<a name="l01334"></a>01334 <span class="comment">     to register any functions that were already generated.  */</span>
<a name="l01335"></a>01335   <span class="keywordflow">for</span> (cur_entry_addr = descriptor.<a class="code" href="structjit__descriptor.html#a79ccc7b26869a7697f5c9785b0667a82">first_entry</a>;
<a name="l01336"></a>01336        cur_entry_addr != 0;
<a name="l01337"></a>01337        cur_entry_addr = cur_entry.next_entry)
<a name="l01338"></a>01338     {
<a name="l01339"></a>01339       jit_read_code_entry (gdbarch, cur_entry_addr, &amp;cur_entry);
<a name="l01340"></a>01340 
<a name="l01341"></a>01341       <span class="comment">/* This hook may be called many times during setup, so make sure we don&#39;t</span>
<a name="l01342"></a>01342 <span class="comment">         add the same symbol file twice.  */</span>
<a name="l01343"></a>01343       <span class="keywordflow">if</span> (jit_find_objf_with_entry_addr (cur_entry_addr) != NULL)
<a name="l01344"></a>01344         <span class="keywordflow">continue</span>;
<a name="l01345"></a>01345 
<a name="l01346"></a>01346       jit_register_code (gdbarch, cur_entry_addr, &amp;cur_entry);
<a name="l01347"></a>01347     }
<a name="l01348"></a>01348 }
<a name="l01349"></a>01349 
<a name="l01350"></a>01350 <span class="comment">/* Exported routine to call when an inferior has been created.  */</span>
<a name="l01351"></a>01351 
<a name="l01352"></a>01352 <span class="keywordtype">void</span>
<a name="l01353"></a><a class="code" href="jit_8h.html#a1f8732dfddc32bc6afd483cacfeceb2d">01353</a> <a class="code" href="jit_8c.html#a1f8732dfddc32bc6afd483cacfeceb2d">jit_inferior_created_hook</a> (<span class="keywordtype">void</span>)
<a name="l01354"></a>01354 {
<a name="l01355"></a>01355   jit_inferior_init (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> ());
<a name="l01356"></a>01356 }
<a name="l01357"></a>01357 
<a name="l01358"></a>01358 <span class="comment">/* Exported routine to call to re-set the jit breakpoints,</span>
<a name="l01359"></a>01359 <span class="comment">   e.g. when a program is rerun.  */</span>
<a name="l01360"></a>01360 
<a name="l01361"></a>01361 <span class="keywordtype">void</span>
<a name="l01362"></a><a class="code" href="jit_8h.html#a92c04c4728e9782c8ac138ff543ac272">01362</a> <a class="code" href="jit_8c.html#a92c04c4728e9782c8ac138ff543ac272">jit_breakpoint_re_set</a> (<span class="keywordtype">void</span>)
<a name="l01363"></a>01363 {
<a name="l01364"></a>01364   jit_breakpoint_re_set_internal (<a class="code" href="gdbarch_8c.html#ad648a33f69abe34e9679744a0c5a0580">target_gdbarch</a> (),
<a name="l01365"></a>01365                                   get_jit_program_space_data ());
<a name="l01366"></a>01366 }
<a name="l01367"></a>01367 
<a name="l01368"></a>01368 <span class="comment">/* This function cleans up any code entries left over when the</span>
<a name="l01369"></a>01369 <span class="comment">   inferior exits.  We get left over code when the inferior exits</span>
<a name="l01370"></a>01370 <span class="comment">   without unregistering its code, for example when it crashes.  */</span>
<a name="l01371"></a>01371 
<a name="l01372"></a>01372 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01373"></a>01373 jit_inferior_exit_hook (<span class="keyword">struct</span> <a class="code" href="structinferior.html">inferior</a> *<a class="code" href="namespacearm-linux.html#aaf6bae53545ee96f24d7ba560ed0a205">inf</a>)
<a name="l01374"></a>01374 {
<a name="l01375"></a>01375   <span class="keyword">struct </span>objfile *objf;
<a name="l01376"></a>01376   <span class="keyword">struct </span>objfile *temp;
<a name="l01377"></a>01377 
<a name="l01378"></a>01378   <a class="code" href="objfiles_8h.html#a7ef07f2da2aa29b817caf474369aa585">ALL_OBJFILES_SAFE</a> (objf, temp)
<a name="l01379"></a>01379     {
<a name="l01380"></a>01380       <span class="keyword">struct </span>jit_objfile_data *objf_data = objfile_data (objf,
<a name="l01381"></a>01381                                                          jit_objfile_data);
<a name="l01382"></a>01382 
<a name="l01383"></a>01383       <span class="keywordflow">if</span> (objf_data != NULL &amp;&amp; objf_data-&gt;addr != 0)
<a name="l01384"></a>01384         jit_unregister_code (objf);
<a name="l01385"></a>01385     }
<a name="l01386"></a>01386 }
<a name="l01387"></a>01387 
<a name="l01388"></a>01388 <span class="keywordtype">void</span>
<a name="l01389"></a><a class="code" href="jit_8h.html#af0d5063aeeb45443b1bd387d7a7229cd">01389</a> <a class="code" href="jit_8c.html#af0d5063aeeb45443b1bd387d7a7229cd">jit_event_handler</a> (<span class="keyword">struct</span> gdbarch *gdbarch)
<a name="l01390"></a>01390 {
<a name="l01391"></a>01391   <span class="keyword">struct </span><a class="code" href="structjit__descriptor.html">jit_descriptor</a> descriptor;
<a name="l01392"></a>01392   <span class="keyword">struct </span><a class="code" href="structjit__code__entry.html">jit_code_entry</a> code_entry;
<a name="l01393"></a>01393   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> entry_addr;
<a name="l01394"></a>01394   <span class="keyword">struct </span>objfile *objf;
<a name="l01395"></a>01395 
<a name="l01396"></a>01396   <span class="comment">/* Read the descriptor from remote memory.  */</span>
<a name="l01397"></a>01397   <span class="keywordflow">if</span> (!jit_read_descriptor (gdbarch, &amp;descriptor,
<a name="l01398"></a>01398                             get_jit_program_space_data ()))
<a name="l01399"></a>01399     <span class="keywordflow">return</span>;
<a name="l01400"></a>01400   entry_addr = descriptor.<a class="code" href="structjit__descriptor.html#ae1437c29bc389acbe3b8317ffe7f22b9">relevant_entry</a>;
<a name="l01401"></a>01401 
<a name="l01402"></a>01402   <span class="comment">/* Do the corresponding action.  */</span>
<a name="l01403"></a>01403   <span class="keywordflow">switch</span> (descriptor.<a class="code" href="structjit__descriptor.html#a5caa0e4b5007a2b528343dab212f061c">action_flag</a>)
<a name="l01404"></a>01404     {
<a name="l01405"></a>01405     <span class="keywordflow">case</span> <a class="code" href="jit_8h.html#a7bdc22420dff03da746c36ea0d1e61e3ab377153f3ed86c501cb1146c7d22b0d0">JIT_NOACTION</a>:
<a name="l01406"></a>01406       <span class="keywordflow">break</span>;
<a name="l01407"></a>01407     <span class="keywordflow">case</span> <a class="code" href="jit_8h.html#a7bdc22420dff03da746c36ea0d1e61e3a07bc2b09e3f681f0459ccd04db7ebc2c">JIT_REGISTER</a>:
<a name="l01408"></a>01408       jit_read_code_entry (gdbarch, entry_addr, &amp;code_entry);
<a name="l01409"></a>01409       jit_register_code (gdbarch, entry_addr, &amp;code_entry);
<a name="l01410"></a>01410       <span class="keywordflow">break</span>;
<a name="l01411"></a>01411     <span class="keywordflow">case</span> <a class="code" href="jit_8h.html#a7bdc22420dff03da746c36ea0d1e61e3a7662cd2063e7d5bd01c5c52ead907fd7">JIT_UNREGISTER</a>:
<a name="l01412"></a>01412       objf = jit_find_objf_with_entry_addr (entry_addr);
<a name="l01413"></a>01413       <span class="keywordflow">if</span> (objf == NULL)
<a name="l01414"></a>01414         <a class="code" href="utils_8c.html#ad57145632bbcb0361dc1dfa134b1efd0">printf_unfiltered</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unable to find JITed code &quot;</span>
<a name="l01415"></a>01415                              <span class="stringliteral">&quot;entry at address: %s\n&quot;</span>),
<a name="l01416"></a>01416                            <a class="code" href="utils_8c.html#ab5c76d72090f01d3848b63dda4e37d1c">paddress</a> (gdbarch, entry_addr));
<a name="l01417"></a>01417       <span class="keywordflow">else</span>
<a name="l01418"></a>01418         jit_unregister_code (objf);
<a name="l01419"></a>01419 
<a name="l01420"></a>01420       <span class="keywordflow">break</span>;
<a name="l01421"></a>01421     <span class="keywordflow">default</span>:
<a name="l01422"></a>01422       <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unknown action_flag value in JIT descriptor!&quot;</span>));
<a name="l01423"></a>01423       <span class="keywordflow">break</span>;
<a name="l01424"></a>01424     }
<a name="l01425"></a>01425 }
<a name="l01426"></a>01426 
<a name="l01427"></a>01427 <span class="comment">/* Called to free the data allocated to the jit_program_space_data slot.  */</span>
<a name="l01428"></a>01428 
<a name="l01429"></a>01429 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01430"></a>01430 free_objfile_data (<span class="keyword">struct</span> objfile *objfile, <span class="keywordtype">void</span> *data)
<a name="l01431"></a>01431 {
<a name="l01432"></a>01432   <span class="keyword">struct </span>jit_objfile_data *objf_data = data;
<a name="l01433"></a>01433 
<a name="l01434"></a>01434   <span class="keywordflow">if</span> (objf_data-&gt;register_code != NULL)
<a name="l01435"></a>01435     {
<a name="l01436"></a>01436       <span class="keyword">struct </span>jit_program_space_data *ps_data;
<a name="l01437"></a>01437 
<a name="l01438"></a>01438       ps_data = program_space_data (objfile-&gt;<a class="code" href="structobjfile.html#a1f6ab738ce0b1fb1588709351b0c9091">pspace</a>, jit_program_space_data);
<a name="l01439"></a>01439       <span class="keywordflow">if</span> (ps_data != NULL &amp;&amp; ps_data-&gt;objfile == objfile)
<a name="l01440"></a>01440         ps_data-&gt;objfile = NULL;
<a name="l01441"></a>01441     }
<a name="l01442"></a>01442 
<a name="l01443"></a>01443   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (data);
<a name="l01444"></a>01444 }
<a name="l01445"></a>01445 
<a name="l01446"></a>01446 <span class="comment">/* Initialize the jit_gdbarch_data slot with an instance of struct</span>
<a name="l01447"></a>01447 <span class="comment">   jit_gdbarch_data_type */</span>
<a name="l01448"></a>01448 
<a name="l01449"></a>01449 <span class="keyword">static</span> <span class="keywordtype">void</span> *
<a name="l01450"></a>01450 jit_gdbarch_data_init (<span class="keyword">struct</span> obstack *obstack)
<a name="l01451"></a>01451 {
<a name="l01452"></a>01452   <span class="keyword">struct </span>jit_gdbarch_data_type *data;
<a name="l01453"></a>01453 
<a name="l01454"></a>01454   data = obstack_alloc (obstack, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> jit_gdbarch_data_type));
<a name="l01455"></a>01455   data-&gt;unwinder_registered = 0;
<a name="l01456"></a>01456   <span class="keywordflow">return</span> data;
<a name="l01457"></a>01457 }
<a name="l01458"></a>01458 
<a name="l01459"></a>01459 <span class="comment">/* Provide a prototype to silence -Wmissing-prototypes.  */</span>
<a name="l01460"></a>01460 
<a name="l01461"></a>01461 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="init_8c.html#a91758f4203cd44916c9f9033ada2a396">_initialize_jit</a> (<span class="keywordtype">void</span>);
<a name="l01462"></a>01462 
<a name="l01463"></a>01463 <span class="keywordtype">void</span>
<a name="l01464"></a><a class="code" href="init_8c.html#a91758f4203cd44916c9f9033ada2a396">01464</a> <a class="code" href="init_8c.html#a91758f4203cd44916c9f9033ada2a396">_initialize_jit</a> (<span class="keywordtype">void</span>)
<a name="l01465"></a>01465 {
<a name="l01466"></a>01466   jit_reader_dir = <a class="code" href="defs_8h.html#ac9f0b9cfddf387cd79b4e962b6493cf8">relocate_gdb_directory</a> (<a class="code" href="config_8h.html#a3f6dc3a6869775a67e1933c4d8ac4572">JIT_READER_DIR</a>,
<a name="l01467"></a>01467                                            <a class="code" href="config_8h.html#a3f1539a33bf3b73ee2cf40832c3dd263">JIT_READER_DIR_RELOCATABLE</a>);
<a name="l01468"></a>01468   <a class="code" href="cli-decode_8c.html#ae32b914a6e0676efa41e6281007a75c1">add_setshow_zuinteger_cmd</a> (<span class="stringliteral">&quot;jit&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a502c7b57c7172ac88ef735f68070bb59">class_maintenance</a>, &amp;jit_debug,
<a name="l01469"></a>01469                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Set JIT debugging.&quot;</span>),
<a name="l01470"></a>01470                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Show JIT debugging.&quot;</span>),
<a name="l01471"></a>01471                              <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;When non-zero, JIT debugging is enabled.&quot;</span>),
<a name="l01472"></a>01472                              NULL,
<a name="l01473"></a>01473                              show_jit_debug,
<a name="l01474"></a>01474                              &amp;<a class="code" href="cli-cmds_8c.html#ae5f16c782e4a29124f3175f4a6285244">setdebuglist</a>, &amp;<a class="code" href="cli-cmds_8c.html#a7e2eed475764f70df1e9c0f5d2476a11">showdebuglist</a>);
<a name="l01475"></a>01475 
<a name="l01476"></a>01476   <a class="code" href="observer_8h.html#a9a54ebb2156e3189a09d3e7afcf1b067">observer_attach_inferior_exit</a> (jit_inferior_exit_hook);
<a name="l01477"></a>01477   <a class="code" href="observer_8h.html#acf9aa982569991bffd276b08c7514af8">observer_attach_breakpoint_deleted</a> (jit_breakpoint_deleted);
<a name="l01478"></a>01478 
<a name="l01479"></a>01479   jit_objfile_data =
<a name="l01480"></a>01480     register_objfile_data_with_cleanup (NULL, free_objfile_data);
<a name="l01481"></a>01481   jit_program_space_data =
<a name="l01482"></a>01482     register_program_space_data_with_cleanup (NULL,
<a name="l01483"></a>01483                                               jit_program_space_data_cleanup);
<a name="l01484"></a>01484   jit_gdbarch_data = <a class="code" href="gdbarch_8c.html#a7686a7d0e7858e65b89babc67ee775cb">gdbarch_data_register_pre_init</a> (jit_gdbarch_data_init);
<a name="l01485"></a>01485   <span class="keywordflow">if</span> (<a class="code" href="gdb-dlfcn_8c.html#a66bbf94407229789eb3eb3d82aac1103">is_dl_available</a> ())
<a name="l01486"></a>01486     {
<a name="l01487"></a>01487       <a class="code" href="cli-decode_8c.html#a0df0ca36d9acd96440e24407cbef593c">add_com</a> (<span class="stringliteral">&quot;jit-reader-load&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49afbf489a4abce7e8770b178aa54f0908b">no_class</a>, jit_reader_load_command, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l01488"></a>01488 <span class="stringliteral">Load FILE as debug info reader and unwinder for JIT compiled code.\n\</span>
<a name="l01489"></a>01489 <span class="stringliteral">Usage: jit-reader-load FILE\n\</span>
<a name="l01490"></a>01490 <span class="stringliteral">Try to load file FILE as a debug info reader (and unwinder) for\n\</span>
<a name="l01491"></a>01491 <span class="stringliteral">JIT compiled code.  The file is loaded from &quot;</span> <a class="code" href="config_8h.html#a3f6dc3a6869775a67e1933c4d8ac4572">JIT_READER_DIR</a> <span class="stringliteral">&quot;,\n\</span>
<a name="l01492"></a>01492 <span class="stringliteral">relocated relative to the GDB executable if required.&quot;</span>));
<a name="l01493"></a>01493       <a class="code" href="cli-decode_8c.html#a0df0ca36d9acd96440e24407cbef593c">add_com</a> (<span class="stringliteral">&quot;jit-reader-unload&quot;</span>, <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49afbf489a4abce7e8770b178aa54f0908b">no_class</a>, jit_reader_unload_command, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l01494"></a>01494 <span class="stringliteral">Unload the currently loaded JIT debug info reader.\n\</span>
<a name="l01495"></a>01495 <span class="stringliteral">Usage: jit-reader-unload FILE\n\n\</span>
<a name="l01496"></a>01496 <span class="stringliteral">Do \&quot;help jit-reader-load\&quot; for info on loading debug info readers.&quot;</span>));
<a name="l01497"></a>01497     }
<a name="l01498"></a>01498 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:12:19 for GDB (API) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
