<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GDB (API): /home/stan/gdb/src/gdb/xtensa-tdep.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GDB (API)
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/stan/gdb/src/gdb/xtensa-tdep.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="xtensa-tdep_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Target-dependent code for the Xtensa port of GDB, the GNU debugger.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   Copyright (C) 2003-2013 Free Software Foundation, Inc.</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   This file is part of GDB.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00008"></a>00008 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00009"></a>00009 <span class="comment">   the Free Software Foundation; either version 3 of the License, or</span>
<a name="l00010"></a>00010 <span class="comment">   (at your option) any later version.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00018"></a>00018 <span class="comment">   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="defs_8h.html">defs.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="frame_8h.html">frame.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="solib-svr4_8h.html">solib-svr4.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="symtab_8h.html">symtab.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="symfile_8h.html">symfile.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="objfiles_8h.html">objfiles.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="gdbtypes_8h.html">gdbtypes.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="gdbcore_8h.html">gdbcore.h</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="value_8h.html">value.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;dis-asm.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="inferior_8h.html">inferior.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;floatformat.h&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="regcache_8h.html">regcache.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="reggroups_8h.html">reggroups.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="regset_8h.html">regset.h</a>&quot;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="dummy-frame_8h.html">dummy-frame.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;dwarf2.h&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="dwarf2-frame_8h.html">dwarf2-frame.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="dwarf2loc_8h.html">dwarf2loc.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="frame_8h.html">frame.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="frame-base_8h.html">frame-base.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="frame-unwind_8h.html">frame-unwind.h</a>&quot;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="arch-utils_8h.html">arch-utils.h</a>&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="gdbarch_8h.html">gdbarch.h</a>&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;<a class="code" href="remote_8h.html">remote.h</a>&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="serial_8h.html">serial.h</a>&quot;</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;<a class="code" href="command_8h.html">command.h</a>&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;<a class="code" href="gdbcmd_8h.html">gdbcmd.h</a>&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;<a class="code" href="gdb__assert_8h.html">gdb_assert.h</a>&quot;</span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;xtensa-isa.h&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;<a class="code" href="xtensa-tdep_8h.html">xtensa-tdep.h</a>&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;xtensa-config.h&quot;</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xtensa_debug_level = 0;
<a name="l00059"></a>00059 
<a name="l00060"></a><a class="code" href="xtensa-tdep_8c.html#a94a3c5809b379ea862361daf743e44b9">00060</a> <span class="preprocessor">#define DEBUGWARN(args...) \</span>
<a name="l00061"></a>00061 <span class="preprocessor">  if (xtensa_debug_level &gt; 0) \</span>
<a name="l00062"></a>00062 <span class="preprocessor">    fprintf_unfiltered (gdb_stdlog, &quot;(warn ) &quot; args)</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span>
<a name="l00064"></a><a class="code" href="xtensa-tdep_8c.html#a9720f72e59ae110cdacf653d01c305cb">00064</a> <span class="preprocessor">#define DEBUGINFO(args...) \</span>
<a name="l00065"></a>00065 <span class="preprocessor">  if (xtensa_debug_level &gt; 1) \</span>
<a name="l00066"></a>00066 <span class="preprocessor">    fprintf_unfiltered (gdb_stdlog, &quot;(info ) &quot; args)</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span>
<a name="l00068"></a><a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">00068</a> <span class="preprocessor">#define DEBUGTRACE(args...) \</span>
<a name="l00069"></a>00069 <span class="preprocessor">  if (xtensa_debug_level &gt; 2) \</span>
<a name="l00070"></a>00070 <span class="preprocessor">    fprintf_unfiltered (gdb_stdlog, &quot;(trace) &quot; args)</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>
<a name="l00072"></a><a class="code" href="xtensa-tdep_8c.html#a16ed05e44161b1f9925d14269a794219">00072</a> <span class="preprocessor">#define DEBUGVERB(args...) \</span>
<a name="l00073"></a>00073 <span class="preprocessor">  if (xtensa_debug_level &gt; 3) \</span>
<a name="l00074"></a>00074 <span class="preprocessor">    fprintf_unfiltered (gdb_stdlog, &quot;(verb ) &quot; args)</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span>
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="comment">/* According to the ABI, the SP must be aligned to 16-byte boundaries.  */</span>
<a name="l00078"></a><a class="code" href="xtensa-tdep_8c.html#acb8b2dd04a867b883f65bdf233b9b602">00078</a> <span class="preprocessor">#define SP_ALIGNMENT 16</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span>
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">/* On Windowed ABI, we use a6 through a11 for passing arguments</span>
<a name="l00082"></a>00082 <span class="comment">   to a function called by GDB because CALL4 is used.  */</span>
<a name="l00083"></a><a class="code" href="xtensa-tdep_8c.html#a28213b5894bb346cd824a7c3404ecd48">00083</a> <span class="preprocessor">#define ARGS_NUM_REGS           6</span>
<a name="l00084"></a><a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">00084</a> <span class="preprocessor"></span><span class="preprocessor">#define REGISTER_SIZE           4</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span>
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="comment">/* Extract the call size from the return address or PS register.  */</span>
<a name="l00088"></a><a class="code" href="xtensa-tdep_8c.html#a736852d6227dd569a6afbc983e4c3aa7">00088</a> <span class="preprocessor">#define PS_CALLINC_SHIFT        16</span>
<a name="l00089"></a><a class="code" href="xtensa-tdep_8c.html#ada609dee644016a6a0e7b5845c6d2b83">00089</a> <span class="preprocessor"></span><span class="preprocessor">#define PS_CALLINC_MASK         0x00030000</span>
<a name="l00090"></a><a class="code" href="xtensa-tdep_8c.html#a65bc09f1f02ffcf0cf1d239595adb769">00090</a> <span class="preprocessor"></span><span class="preprocessor">#define CALLINC(ps)             (((ps) &amp; PS_CALLINC_MASK) &gt;&gt; PS_CALLINC_SHIFT)</span>
<a name="l00091"></a><a class="code" href="xtensa-tdep_8c.html#ab5b0d0abf0586f7a99e090450d41f8ef">00091</a> <span class="preprocessor"></span><span class="preprocessor">#define WINSIZE(ra)             (4 * (( (ra) &gt;&gt; 30) &amp; 0x3))</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span>
<a name="l00093"></a>00093 <span class="comment">/* On TX,  hardware can be configured without Exception Option.</span>
<a name="l00094"></a>00094 <span class="comment">   There is no PS register in this case.  Inside XT-GDB,  let us treat</span>
<a name="l00095"></a>00095 <span class="comment">   it as a virtual read-only register always holding the same value.  */</span>
<a name="l00096"></a><a class="code" href="xtensa-tdep_8c.html#a2bdfbd058994cb622a57096c3080d862">00096</a> <span class="preprocessor">#define TX_PS                   0x20</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span>
<a name="l00098"></a>00098 <span class="comment">/* ABI-independent macros.  */</span>
<a name="l00099"></a><a class="code" href="xtensa-tdep_8c.html#a75e8630347d4e5ed6ba06f0377a9bca7">00099</a> <span class="preprocessor">#define ARG_NOF(gdbarch) \</span>
<a name="l00100"></a>00100 <span class="preprocessor">  (gdbarch_tdep (gdbarch)-&gt;call_abi \</span>
<a name="l00101"></a>00101 <span class="preprocessor">   == CallAbiCall0Only ? C0_NARGS : (ARGS_NUM_REGS))</span>
<a name="l00102"></a><a class="code" href="xtensa-tdep_8c.html#a514cc1a3d9a73356d4cf25986b456337">00102</a> <span class="preprocessor"></span><span class="preprocessor">#define ARG_1ST(gdbarch) \</span>
<a name="l00103"></a>00103 <span class="preprocessor">  (gdbarch_tdep (gdbarch)-&gt;call_abi  == CallAbiCall0Only \</span>
<a name="l00104"></a>00104 <span class="preprocessor">   ? (gdbarch_tdep (gdbarch)-&gt;a0_base + C0_ARGS) \</span>
<a name="l00105"></a>00105 <span class="preprocessor">   : (gdbarch_tdep (gdbarch)-&gt;a0_base + 6))</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span>
<a name="l00107"></a>00107 <span class="comment">/* XTENSA_IS_ENTRY tests whether the first byte of an instruction</span>
<a name="l00108"></a>00108 <span class="comment">   indicates that the instruction is an ENTRY instruction.  */</span>
<a name="l00109"></a>00109 
<a name="l00110"></a><a class="code" href="xtensa-tdep_8c.html#ac609afa31c32b6930458597eeac45022">00110</a> <span class="preprocessor">#define XTENSA_IS_ENTRY(gdbarch, op1) \</span>
<a name="l00111"></a>00111 <span class="preprocessor">  ((gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG) \</span>
<a name="l00112"></a>00112 <span class="preprocessor">   ? ((op1) == 0x6c) : ((op1) == 0x36))</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span>
<a name="l00114"></a><a class="code" href="xtensa-tdep_8c.html#a966cef2835c0501a61df6ba822b7c8e0">00114</a> <span class="preprocessor">#define XTENSA_ENTRY_LENGTH     3</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span>
<a name="l00116"></a>00116 <span class="comment">/* windowing_enabled() returns true, if windowing is enabled.</span>
<a name="l00117"></a>00117 <span class="comment">   WOE must be set to 1; EXCM to 0.</span>
<a name="l00118"></a>00118 <span class="comment">   Note: We assume that EXCM is always 0 for XEA1.  */</span>
<a name="l00119"></a>00119 
<a name="l00120"></a><a class="code" href="xtensa-tdep_8c.html#adb350af63214a61b3187e076a1cb3fa6">00120</a> <span class="preprocessor">#define PS_WOE                  (1&lt;&lt;18)</span>
<a name="l00121"></a><a class="code" href="xtensa-tdep_8c.html#ad279722c56b67506ce58873638892617">00121</a> <span class="preprocessor"></span><span class="preprocessor">#define PS_EXC                  (1&lt;&lt;4)</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span>
<a name="l00123"></a>00123 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00124"></a>00124 windowing_enabled (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacecleanup__check.html#a2f9ce522b7667bef19a5777d12fa44d8">ps</a>)
<a name="l00125"></a>00125 {
<a name="l00126"></a>00126   <span class="comment">/* If we know CALL0 ABI is set explicitly,  say it is Call0.  */</span>
<a name="l00127"></a>00127   <span class="keywordflow">if</span> (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;call_abi == <a class="code" href="xtensa-tdep_8h.html#aa494e78313efd646e55e129992eafbcbadd1a04285f03aa703b8634da6c2df921">CallAbiCall0Only</a>)
<a name="l00128"></a>00128     <span class="keywordflow">return</span> 0;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   <span class="keywordflow">return</span> ((ps &amp; <a class="code" href="xtensa-tdep_8c.html#ad279722c56b67506ce58873638892617">PS_EXC</a>) == 0 &amp;&amp; (ps &amp; <a class="code" href="xtensa-tdep_8c.html#adb350af63214a61b3187e076a1cb3fa6">PS_WOE</a>) != 0);
<a name="l00131"></a>00131 }
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 <span class="comment">/* Convert a live A-register number to the corresponding AR-register</span>
<a name="l00134"></a>00134 <span class="comment">   number.  */</span>
<a name="l00135"></a>00135 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00136"></a>00136 arreg_number (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> a_regnum, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> wb)
<a name="l00137"></a>00137 {
<a name="l00138"></a>00138   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l00139"></a>00139   <span class="keywordtype">int</span> arreg;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   arreg = a_regnum - tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a>;
<a name="l00142"></a>00142   arreg += (wb &amp; ((tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4f769a0e5c51524a59b35f0841991552">num_aregs</a> - 1) &gt;&gt; 2)) &lt;&lt; <a class="code" href="xtensa-tdep_8h.html#a48b565da80fd732a4eef6d6d386ce4b2">WB_SHIFT</a>;
<a name="l00143"></a>00143   arreg &amp;= tdep-&gt;num_aregs - 1;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145   <span class="keywordflow">return</span> arreg + tdep-&gt;ar_base;
<a name="l00146"></a>00146 }
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 <span class="comment">/* Convert a live AR-register number to the corresponding A-register order</span>
<a name="l00149"></a>00149 <span class="comment">   number in a range [0..15].  Return -1, if AR_REGNUM is out of WB window.  */</span>
<a name="l00150"></a>00150 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00151"></a>00151 areg_number (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> ar_regnum, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> wb)
<a name="l00152"></a>00152 {
<a name="l00153"></a>00153   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l00154"></a>00154   <span class="keywordtype">int</span> areg;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   areg = ar_regnum - tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a73432cf260ddfd1984970794410c0b59">ar_base</a>;
<a name="l00157"></a>00157   <span class="keywordflow">if</span> (areg &lt; 0 || areg &gt;= tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4f769a0e5c51524a59b35f0841991552">num_aregs</a>)
<a name="l00158"></a>00158     <span class="keywordflow">return</span> -1;
<a name="l00159"></a>00159   areg = (areg - wb * 4) &amp; (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4f769a0e5c51524a59b35f0841991552">num_aregs</a> - 1);
<a name="l00160"></a>00160   <span class="keywordflow">return</span> (areg &gt; 15) ? -1 : areg;
<a name="l00161"></a>00161 }
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">/* Read Xtensa register directly from the hardware.  */</span> 
<a name="l00164"></a>00164 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>
<a name="l00165"></a>00165 xtensa_read_register (<span class="keywordtype">int</span> <a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>)
<a name="l00166"></a>00166 {
<a name="l00167"></a>00167   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> value;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169   <a class="code" href="regcache_8c.html#a465c747dfdb94bb985d56e0374eb4481">regcache_raw_read_unsigned</a> (<a class="code" href="regcache_8c.html#a09a386286dc22d882378f639630fecef">get_current_regcache</a> (), regnum, &amp;value);
<a name="l00170"></a>00170   <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) value;
<a name="l00171"></a>00171 }
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 <span class="comment">/* Write Xtensa register directly to the hardware.  */</span> 
<a name="l00174"></a>00174 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00175"></a>00175 xtensa_write_register (<span class="keywordtype">int</span> regnum, <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> value)
<a name="l00176"></a>00176 {
<a name="l00177"></a>00177   <a class="code" href="regcache_8c.html#aabf28852a01dbc9342b054408225d396">regcache_raw_write_unsigned</a> (<a class="code" href="regcache_8c.html#a09a386286dc22d882378f639630fecef">get_current_regcache</a> (), regnum, value);
<a name="l00178"></a>00178 }
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 <span class="comment">/* Return the window size of the previous call to the function from which we</span>
<a name="l00181"></a>00181 <span class="comment">   have just returned.</span>
<a name="l00182"></a>00182 <span class="comment"></span>
<a name="l00183"></a>00183 <span class="comment">   This function is used to extract the return value after a called function</span>
<a name="l00184"></a>00184 <span class="comment">   has returned to the caller.  On Xtensa, the register that holds the return</span>
<a name="l00185"></a>00185 <span class="comment">   value (from the perspective of the caller) depends on what call</span>
<a name="l00186"></a>00186 <span class="comment">   instruction was used.  For now, we are assuming that the call instruction</span>
<a name="l00187"></a>00187 <span class="comment">   precedes the current address, so we simply analyze the call instruction.</span>
<a name="l00188"></a>00188 <span class="comment">   If we are in a dummy frame, we simply return 4 as we used a &#39;pseudo-call4&#39;</span>
<a name="l00189"></a>00189 <span class="comment">   method to call the inferior function.  */</span>
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00192"></a>00192 extract_call_winsize (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="structgdbarch__tdep.html#ab7a207d4e85b564c48238283745247b8">pc</a>)
<a name="l00193"></a>00193 {
<a name="l00194"></a>00194   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l00195"></a>00195   <span class="keywordtype">int</span> winsize = 4;
<a name="l00196"></a>00196   <span class="keywordtype">int</span> insn;
<a name="l00197"></a>00197   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> buf[4];
<a name="l00198"></a>00198 
<a name="l00199"></a>00199   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;extract_call_winsize (pc = 0x%08x)\n&quot;</span>, (<span class="keywordtype">int</span>) pc);
<a name="l00200"></a>00200 
<a name="l00201"></a>00201   <span class="comment">/* Read the previous instruction (should be a call[x]{4|8|12}.  */</span>
<a name="l00202"></a>00202   <a class="code" href="corefile_8c.html#a5e0189c6f21f1c9321b379877183b819">read_memory</a> (pc-3, buf, 3);
<a name="l00203"></a>00203   insn = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf, 3, byte_order);
<a name="l00204"></a>00204 
<a name="l00205"></a>00205   <span class="comment">/* Decode call instruction:</span>
<a name="l00206"></a>00206 <span class="comment">     Little Endian</span>
<a name="l00207"></a>00207 <span class="comment">       call{0,4,8,12}   OFFSET || {00,01,10,11} || 0101</span>
<a name="l00208"></a>00208 <span class="comment">       callx{0,4,8,12}  OFFSET || 11 || {00,01,10,11} || 0000</span>
<a name="l00209"></a>00209 <span class="comment">     Big Endian</span>
<a name="l00210"></a>00210 <span class="comment">       call{0,4,8,12}   0101 || {00,01,10,11} || OFFSET</span>
<a name="l00211"></a>00211 <span class="comment">       callx{0,4,8,12}  0000 || {00,01,10,11} || 11 || OFFSET.  */</span>
<a name="l00212"></a>00212 
<a name="l00213"></a>00213   <span class="keywordflow">if</span> (byte_order == BFD_ENDIAN_LITTLE)
<a name="l00214"></a>00214     {
<a name="l00215"></a>00215       <span class="keywordflow">if</span> (((insn &amp; 0xf) == 0x5) || ((insn &amp; 0xcf) == 0xc0))
<a name="l00216"></a>00216         winsize = (insn &amp; 0x30) &gt;&gt; 2;   <span class="comment">/* 0, 4, 8, 12.  */</span>
<a name="l00217"></a>00217     }
<a name="l00218"></a>00218   <span class="keywordflow">else</span>
<a name="l00219"></a>00219     {
<a name="l00220"></a>00220       <span class="keywordflow">if</span> (((insn &gt;&gt; 20) == 0x5) || (((insn &gt;&gt; 16) &amp; 0xf3) == 0x03))
<a name="l00221"></a>00221         winsize = (insn &gt;&gt; 16) &amp; 0xc;   <span class="comment">/* 0, 4, 8, 12.  */</span>
<a name="l00222"></a>00222     }
<a name="l00223"></a>00223   <span class="keywordflow">return</span> winsize;
<a name="l00224"></a>00224 }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 <span class="comment">/* REGISTER INFORMATION */</span>
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="comment">/* Find register by name.  */</span>
<a name="l00230"></a>00230 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00231"></a>00231 xtensa_find_register_by_name (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">char</span> *<a class="code" href="aarch64-tdep_8c.html#acc128f98d9ceca227038c771308eff39">name</a>)
<a name="l00232"></a>00232 {
<a name="l00233"></a>00233   <span class="keywordtype">int</span> i;
<a name="l00234"></a>00234 
<a name="l00235"></a>00235   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (gdbarch)
<a name="l00236"></a>00236          + <a class="code" href="gdbarch_8c.html#a8e0e40f42e5969ee4559ee47717aa9f3">gdbarch_num_pseudo_regs</a> (gdbarch);
<a name="l00237"></a>00237        i++)
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     <span class="keywordflow">if</span> (strcasecmp (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a19d2226ca2b5d41faacd7affdbcccf73">regmap</a>[i].name, name) == 0)
<a name="l00240"></a>00240       <span class="keywordflow">return</span> i;
<a name="l00241"></a>00241 
<a name="l00242"></a>00242   <span class="keywordflow">return</span> -1;
<a name="l00243"></a>00243 }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="comment">/* Returns the name of a register.  */</span>
<a name="l00246"></a>00246 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00247"></a>00247 xtensa_register_name (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> regnum)
<a name="l00248"></a>00248 {
<a name="l00249"></a>00249   <span class="comment">/* Return the name stored in the register map.  */</span>
<a name="l00250"></a>00250   <span class="keywordflow">if</span> (regnum &gt;= 0 &amp;&amp; regnum &lt; <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (gdbarch)
<a name="l00251"></a>00251                               + <a class="code" href="gdbarch_8c.html#a8e0e40f42e5969ee4559ee47717aa9f3">gdbarch_num_pseudo_regs</a> (gdbarch))
<a name="l00252"></a>00252     <span class="keywordflow">return</span> <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a19d2226ca2b5d41faacd7affdbcccf73">regmap</a>[<a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>].<a class="code" href="structxtensa__register__t.html#a5e4dcb31e23e71e5e8813561d832a781">name</a>;
<a name="l00253"></a>00253 
<a name="l00254"></a>00254   <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;invalid register %d&quot;</span>), regnum);
<a name="l00255"></a>00255   <span class="keywordflow">return</span> 0;
<a name="l00256"></a>00256 }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 <span class="comment">/* Return the type of a register.  Create a new type, if necessary.  */</span>
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtype.html">type</a> *
<a name="l00261"></a>00261 xtensa_register_type (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> regnum)
<a name="l00262"></a>00262 {
<a name="l00263"></a>00263   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265   <span class="comment">/* Return signed integer for ARx and Ax registers.  */</span>
<a name="l00266"></a>00266   <span class="keywordflow">if</span> ((regnum &gt;= tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a73432cf260ddfd1984970794410c0b59">ar_base</a>
<a name="l00267"></a>00267        &amp;&amp; regnum &lt; tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a73432cf260ddfd1984970794410c0b59">ar_base</a> + tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4f769a0e5c51524a59b35f0841991552">num_aregs</a>)
<a name="l00268"></a>00268       || (regnum &gt;= tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a>
<a name="l00269"></a>00269           &amp;&amp; regnum &lt; tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a> + 16))
<a name="l00270"></a>00270     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#ab12f96a04e89e8c951f0eacb379f7ffc">builtin_int</a>;
<a name="l00271"></a>00271 
<a name="l00272"></a>00272   <span class="keywordflow">if</span> (regnum == <a class="code" href="gdbarch_8c.html#a07a162ebafea1269eb8f341db44e53e7">gdbarch_pc_regnum</a> (gdbarch)
<a name="l00273"></a>00273       || regnum == tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a> + 1)
<a name="l00274"></a>00274     <span class="keywordflow">return</span> <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a55f6f9ff7436431777683d8ba62f662a">builtin_data_ptr</a>;
<a name="l00275"></a>00275 
<a name="l00276"></a>00276   <span class="comment">/* Return the stored type for all other registers.  */</span>
<a name="l00277"></a>00277   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (regnum &gt;= 0 &amp;&amp; regnum &lt; <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (gdbarch)
<a name="l00278"></a>00278                                    + <a class="code" href="gdbarch_8c.html#a8e0e40f42e5969ee4559ee47717aa9f3">gdbarch_num_pseudo_regs</a> (gdbarch))
<a name="l00279"></a>00279     {
<a name="l00280"></a>00280       <a class="code" href="structxtensa__register__t.html">xtensa_register_t</a>* <a class="code" href="structreg.html">reg</a> = &amp;tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a19d2226ca2b5d41faacd7affdbcccf73">regmap</a>[<a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>];
<a name="l00281"></a>00281 
<a name="l00282"></a>00282       <span class="comment">/* Set ctype for this register (only the first time).  */</span>
<a name="l00283"></a>00283 
<a name="l00284"></a>00284       <span class="keywordflow">if</span> (reg-&gt;<a class="code" href="structxtensa__register__t.html#a4beb7cb3f9fd78167ad795d3e706d454">ctype</a> == 0)
<a name="l00285"></a>00285         {
<a name="l00286"></a>00286           <span class="keyword">struct </span>ctype_cache *tp;
<a name="l00287"></a>00287           <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a> = reg-&gt;<a class="code" href="structxtensa__register__t.html#a02349ab43200a457c2144728e7af4f22">byte_size</a>;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289           <span class="comment">/* We always use the memory representation,</span>
<a name="l00290"></a>00290 <span class="comment">             even if the register width is smaller.  */</span>
<a name="l00291"></a>00291           <span class="keywordflow">switch</span> (size)
<a name="l00292"></a>00292             {
<a name="l00293"></a>00293             <span class="keywordflow">case</span> 1:
<a name="l00294"></a>00294               reg-&gt;<a class="code" href="structxtensa__register__t.html#a4beb7cb3f9fd78167ad795d3e706d454">ctype</a> = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#ad57a1250e3b718be55d3810f484bdc3a">builtin_uint8</a>;
<a name="l00295"></a>00295               <span class="keywordflow">break</span>;
<a name="l00296"></a>00296 
<a name="l00297"></a>00297             <span class="keywordflow">case</span> 2:
<a name="l00298"></a>00298               reg-&gt;<a class="code" href="structxtensa__register__t.html#a4beb7cb3f9fd78167ad795d3e706d454">ctype</a> = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a2278f4cd3362bed6087abfb78d6fb1bd">builtin_uint16</a>;
<a name="l00299"></a>00299               <span class="keywordflow">break</span>;
<a name="l00300"></a>00300 
<a name="l00301"></a>00301             <span class="keywordflow">case</span> 4:
<a name="l00302"></a>00302               reg-&gt;<a class="code" href="structxtensa__register__t.html#a4beb7cb3f9fd78167ad795d3e706d454">ctype</a> = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a7d0cf7d4e93c3cd2f1b744a18fa23b80">builtin_uint32</a>;
<a name="l00303"></a>00303               <span class="keywordflow">break</span>;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305             <span class="keywordflow">case</span> 8:
<a name="l00306"></a>00306               reg-&gt;<a class="code" href="structxtensa__register__t.html#a4beb7cb3f9fd78167ad795d3e706d454">ctype</a> = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a82b181ebbb2bdb20e94beafeb3497674">builtin_uint64</a>;
<a name="l00307"></a>00307               <span class="keywordflow">break</span>;
<a name="l00308"></a>00308 
<a name="l00309"></a>00309             <span class="keywordflow">case</span> 16:
<a name="l00310"></a>00310               reg-&gt;<a class="code" href="structxtensa__register__t.html#a4beb7cb3f9fd78167ad795d3e706d454">ctype</a> = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a462e5c89d490be8effbd7f3efd50e330">builtin_uint128</a>;
<a name="l00311"></a>00311               <span class="keywordflow">break</span>;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313             <span class="keywordflow">default</span>:
<a name="l00314"></a>00314               <span class="keywordflow">for</span> (tp = tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a3a3cad235c8af67345c5fb1ac8829fe8">type_entries</a>; tp != NULL; tp = tp-&gt;<a class="code" href="structgdbarch__tdep_1_1ctype__cache.html#a33db2177720e096733e134587fb75d06">next</a>)
<a name="l00315"></a>00315                 <span class="keywordflow">if</span> (tp-&gt;size == size)
<a name="l00316"></a>00316                   <span class="keywordflow">break</span>;
<a name="l00317"></a>00317 
<a name="l00318"></a>00318               <span class="keywordflow">if</span> (tp == NULL)
<a name="l00319"></a>00319                 {
<a name="l00320"></a>00320                   <span class="keywordtype">char</span> *name = <a class="code" href="common-utils_8c.html#ab9bf7e1b4e68bdd0078e9e1e55c62cec">xstrprintf</a> (<span class="stringliteral">&quot;int%d&quot;</span>, size * 8);
<a name="l00321"></a>00321                   tp = <a class="code" href="common-utils_8c.html#a634d6cd850bb831afebc499579303b3b">xmalloc</a> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> ctype_cache));
<a name="l00322"></a>00322                   tp-&gt;next = tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a3a3cad235c8af67345c5fb1ac8829fe8">type_entries</a>;
<a name="l00323"></a>00323                   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a3a3cad235c8af67345c5fb1ac8829fe8">type_entries</a> = tp;
<a name="l00324"></a>00324                   tp-&gt;<a class="code" href="structgdbarch__tdep_1_1ctype__cache.html#a649ab5f877c2a549345a2ad39fc492c5">size</a> = <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l00325"></a>00325                   tp-&gt;virtual_type
<a name="l00326"></a>00326                     = <a class="code" href="gdbtypes_8c.html#a48d67b6e344214b752cbfe22076af3e1">arch_integer_type</a> (gdbarch, size * 8, 1, name);
<a name="l00327"></a>00327                   <a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a> (name);
<a name="l00328"></a>00328                 }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330               reg-&gt;<a class="code" href="structxtensa__register__t.html#a4beb7cb3f9fd78167ad795d3e706d454">ctype</a> = tp-&gt;virtual_type;
<a name="l00331"></a>00331             }
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333       <span class="keywordflow">return</span> reg-&gt;<a class="code" href="structxtensa__register__t.html#a4beb7cb3f9fd78167ad795d3e706d454">ctype</a>;
<a name="l00334"></a>00334     }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336   <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;invalid register number %d&quot;</span>), regnum);
<a name="l00337"></a>00337   <span class="keywordflow">return</span> 0;
<a name="l00338"></a>00338 }
<a name="l00339"></a>00339 
<a name="l00340"></a>00340 
<a name="l00341"></a>00341 <span class="comment">/* Return the &#39;local&#39; register number for stubs, dwarf2, etc.</span>
<a name="l00342"></a>00342 <span class="comment">   The debugging information enumerates registers starting from 0 for A0</span>
<a name="l00343"></a>00343 <span class="comment">   to n for An.  So, we only have to add the base number for A0.  */</span>
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00346"></a>00346 xtensa_reg_to_regnum (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> regnum)
<a name="l00347"></a>00347 {
<a name="l00348"></a>00348   <span class="keywordtype">int</span> i;
<a name="l00349"></a>00349 
<a name="l00350"></a>00350   <span class="keywordflow">if</span> (regnum &gt;= 0 &amp;&amp; regnum &lt; 16)
<a name="l00351"></a>00351     <span class="keywordflow">return</span> <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a> + <a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>;
<a name="l00352"></a>00352 
<a name="l00353"></a>00353   <span class="keywordflow">for</span> (i = 0;
<a name="l00354"></a>00354        i &lt; <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (gdbarch) + <a class="code" href="gdbarch_8c.html#a8e0e40f42e5969ee4559ee47717aa9f3">gdbarch_num_pseudo_regs</a> (gdbarch);
<a name="l00355"></a>00355        i++)
<a name="l00356"></a>00356     <span class="keywordflow">if</span> (regnum == <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a19d2226ca2b5d41faacd7affdbcccf73">regmap</a>[i].<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a>)
<a name="l00357"></a>00357       <span class="keywordflow">return</span> i;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359   <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l00360"></a>00360                   <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;invalid dwarf/stabs register number %d&quot;</span>), regnum);
<a name="l00361"></a>00361   <span class="keywordflow">return</span> 0;
<a name="l00362"></a>00362 }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 <span class="comment">/* Write the bits of a masked register to the various registers.</span>
<a name="l00366"></a>00366 <span class="comment">   Only the masked areas of these registers are modified; the other</span>
<a name="l00367"></a>00367 <span class="comment">   fields are untouched.  The size of masked registers is always less</span>
<a name="l00368"></a>00368 <span class="comment">   than or equal to 32 bits.  */</span>
<a name="l00369"></a>00369 
<a name="l00370"></a>00370 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00371"></a>00371 xtensa_register_write_masked (<span class="keyword">struct</span> regcache *regcache,
<a name="l00372"></a>00372                               <a class="code" href="structxtensa__register__t.html">xtensa_register_t</a> *reg, <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *<a class="code" href="structbuffer.html">buffer</a>)
<a name="l00373"></a>00373 {
<a name="l00374"></a>00374   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value[(<a class="code" href="defs_8h.html#a1f9aebf1de3ebbf4283a4dcf73308562a4f3d67bb99ae292178850a8930ab8252">MAX_REGISTER_SIZE</a> + 3) / 4];
<a name="l00375"></a>00375   <span class="keyword">const</span> <a class="code" href="structxtensa__mask__t.html">xtensa_mask_t</a> *mask = reg-&gt;<a class="code" href="structxtensa__register__t.html#ae651b2afab674bc8a4ad8be64c8b7e98">mask</a>;
<a name="l00376"></a>00376 
<a name="l00377"></a>00377   <span class="keywordtype">int</span> shift = 0;                <span class="comment">/* Shift for next mask (mod 32).  */</span>
<a name="l00378"></a>00378   <span class="keywordtype">int</span> start, <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;              <span class="comment">/* Start bit and size of current mask.  */</span>
<a name="l00379"></a>00379 
<a name="l00380"></a>00380   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ptr = value;
<a name="l00381"></a>00381   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> regval, <a class="code" href="namespacearm-linux.html#a8594a1214bfb32c5d61201101374a289">m</a>, mem = 0;
<a name="l00382"></a>00382 
<a name="l00383"></a>00383   <span class="keywordtype">int</span> bytesize = reg-&gt;<a class="code" href="structxtensa__register__t.html#a02349ab43200a457c2144728e7af4f22">byte_size</a>;
<a name="l00384"></a>00384   <span class="keywordtype">int</span> bitsize = bytesize * 8;
<a name="l00385"></a>00385   <span class="keywordtype">int</span> i, r;
<a name="l00386"></a>00386 
<a name="l00387"></a>00387   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;xtensa_register_write_masked ()\n&quot;</span>);
<a name="l00388"></a>00388 
<a name="l00389"></a>00389   <span class="comment">/* Copy the masked register to host byte-order.  */</span>
<a name="l00390"></a>00390   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (<a class="code" href="regcache_8c.html#ad4f6d0cdf256b1fa45d59a6d71b50659">get_regcache_arch</a> (regcache)) == BFD_ENDIAN_BIG)
<a name="l00391"></a>00391     <span class="keywordflow">for</span> (i = 0; i &lt; bytesize; i++)
<a name="l00392"></a>00392       {
<a name="l00393"></a>00393         mem &gt;&gt;= 8;
<a name="l00394"></a>00394         mem |= (buffer[bytesize - i - 1] &lt;&lt; 24);
<a name="l00395"></a>00395         <span class="keywordflow">if</span> ((i &amp; 3) == 3)
<a name="l00396"></a>00396           *ptr++ = mem;
<a name="l00397"></a>00397       }
<a name="l00398"></a>00398   <span class="keywordflow">else</span>
<a name="l00399"></a>00399     <span class="keywordflow">for</span> (i = 0; i &lt; bytesize; i++)
<a name="l00400"></a>00400       {
<a name="l00401"></a>00401         mem &gt;&gt;= 8;
<a name="l00402"></a>00402         mem |= (buffer[i] &lt;&lt; 24);
<a name="l00403"></a>00403         <span class="keywordflow">if</span> ((i &amp; 3) == 3)
<a name="l00404"></a>00404           *ptr++ = mem;
<a name="l00405"></a>00405       }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407   <span class="comment">/* We might have to shift the final value:</span>
<a name="l00408"></a>00408 <span class="comment">     bytesize &amp; 3 == 0 -&gt; nothing to do, we use the full 32 bits,</span>
<a name="l00409"></a>00409 <span class="comment">     bytesize &amp; 3 == x -&gt; shift (4-x) * 8.  */</span>
<a name="l00410"></a>00410 
<a name="l00411"></a>00411   *ptr = mem &gt;&gt; (((0 - bytesize) &amp; 3) * 8);
<a name="l00412"></a>00412   ptr = value;
<a name="l00413"></a>00413   mem = *ptr;
<a name="l00414"></a>00414 
<a name="l00415"></a>00415   <span class="comment">/* Write the bits to the masked areas of the other registers.  */</span>
<a name="l00416"></a>00416   <span class="keywordflow">for</span> (i = 0; i &lt; mask-&gt;count; i++)
<a name="l00417"></a>00417     {
<a name="l00418"></a>00418       start = mask-&gt;mask[i].bit_start;
<a name="l00419"></a>00419       size = mask-&gt;mask[i].bit_size;
<a name="l00420"></a>00420       regval = mem &gt;&gt; shift;
<a name="l00421"></a>00421 
<a name="l00422"></a>00422       <span class="keywordflow">if</span> ((shift += size) &gt; bitsize)
<a name="l00423"></a>00423         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;size of all masks is larger than the register&quot;</span>));
<a name="l00424"></a>00424 
<a name="l00425"></a>00425       <span class="keywordflow">if</span> (shift &gt;= 32)
<a name="l00426"></a>00426         {
<a name="l00427"></a>00427           mem = *(++ptr);
<a name="l00428"></a>00428           shift -= 32;
<a name="l00429"></a>00429           bitsize -= 32;
<a name="l00430"></a>00430 
<a name="l00431"></a>00431           <span class="keywordflow">if</span> (shift &gt; 0)
<a name="l00432"></a>00432             regval |= mem &lt;&lt; (size - shift);
<a name="l00433"></a>00433         }
<a name="l00434"></a>00434 
<a name="l00435"></a>00435       <span class="comment">/* Make sure we have a valid register.  */</span>
<a name="l00436"></a>00436       r = mask-&gt;mask[i].reg_num;
<a name="l00437"></a>00437       <span class="keywordflow">if</span> (r &gt;= 0 &amp;&amp; size &gt; 0)
<a name="l00438"></a>00438         {
<a name="l00439"></a>00439           <span class="comment">/* Don&#39;t overwrite the unmasked areas.  */</span>
<a name="l00440"></a>00440           <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> old_val;
<a name="l00441"></a>00441           <a class="code" href="regcache_8c.html#a959a077d769de1641d4f9754cc7b4a1f">regcache_cooked_read_unsigned</a> (regcache, r, &amp;old_val);
<a name="l00442"></a>00442           m = 0xffffffff &gt;&gt; (32 - <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>) &lt;&lt; start;
<a name="l00443"></a>00443           regval &lt;&lt;= start;
<a name="l00444"></a>00444           regval = (regval &amp; <a class="code" href="namespacearm-linux.html#a8594a1214bfb32c5d61201101374a289">m</a>) | (old_val &amp; ~m);
<a name="l00445"></a>00445           <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a> (regcache, r, regval);
<a name="l00446"></a>00446         }
<a name="l00447"></a>00447     }
<a name="l00448"></a>00448 }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 <span class="comment">/* Read a tie state or mapped registers.  Read the masked areas</span>
<a name="l00452"></a>00452 <span class="comment">   of the registers and assemble them into a single value.  */</span>
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00455"></a>00455 xtensa_register_read_masked (<span class="keyword">struct</span> regcache *regcache,
<a name="l00456"></a>00456                              <a class="code" href="structxtensa__register__t.html">xtensa_register_t</a> *reg, <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buffer)
<a name="l00457"></a>00457 {
<a name="l00458"></a>00458   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value[(<a class="code" href="defs_8h.html#a1f9aebf1de3ebbf4283a4dcf73308562a4f3d67bb99ae292178850a8930ab8252">MAX_REGISTER_SIZE</a> + 3) / 4];
<a name="l00459"></a>00459   <span class="keyword">const</span> <a class="code" href="structxtensa__mask__t.html">xtensa_mask_t</a> *mask = reg-&gt;<a class="code" href="structxtensa__register__t.html#ae651b2afab674bc8a4ad8be64c8b7e98">mask</a>;
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="keywordtype">int</span> shift = 0;
<a name="l00462"></a>00462   <span class="keywordtype">int</span> start, <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>;
<a name="l00463"></a>00463 
<a name="l00464"></a>00464   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *ptr = value;
<a name="l00465"></a>00465   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> regval, mem = 0;
<a name="l00466"></a>00466 
<a name="l00467"></a>00467   <span class="keywordtype">int</span> bytesize = reg-&gt;<a class="code" href="structxtensa__register__t.html#a02349ab43200a457c2144728e7af4f22">byte_size</a>;
<a name="l00468"></a>00468   <span class="keywordtype">int</span> bitsize = bytesize * 8;
<a name="l00469"></a>00469   <span class="keywordtype">int</span> i;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;xtensa_register_read_masked (reg \&quot;%s\&quot;, ...)\n&quot;</span>,
<a name="l00472"></a>00472               reg-&gt;<a class="code" href="structxtensa__register__t.html#a5e4dcb31e23e71e5e8813561d832a781">name</a> == 0 ? <span class="stringliteral">&quot;&quot;</span> : reg-&gt;<a class="code" href="structxtensa__register__t.html#a5e4dcb31e23e71e5e8813561d832a781">name</a>);
<a name="l00473"></a>00473 
<a name="l00474"></a>00474   <span class="comment">/* Assemble the register from the masked areas of other registers.  */</span>
<a name="l00475"></a>00475   <span class="keywordflow">for</span> (i = 0; i &lt; mask-&gt;count; i++)
<a name="l00476"></a>00476     {
<a name="l00477"></a>00477       <span class="keywordtype">int</span> r = mask-&gt;mask[i].reg_num;
<a name="l00478"></a>00478       <span class="keywordflow">if</span> (r &gt;= 0)
<a name="l00479"></a>00479         {
<a name="l00480"></a>00480           <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00481"></a>00481           <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> val;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483           status = <a class="code" href="regcache_8c.html#a959a077d769de1641d4f9754cc7b4a1f">regcache_cooked_read_unsigned</a> (regcache, r, &amp;val);
<a name="l00484"></a>00484           <span class="keywordflow">if</span> (status != <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>)
<a name="l00485"></a>00485             <span class="keywordflow">return</span> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00486"></a>00486           regval = (<span class="keywordtype">unsigned</span> <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>) val;
<a name="l00487"></a>00487         }
<a name="l00488"></a>00488       <span class="keywordflow">else</span>
<a name="l00489"></a>00489         regval = 0;
<a name="l00490"></a>00490 
<a name="l00491"></a>00491       start = mask-&gt;mask[i].bit_start;
<a name="l00492"></a>00492       size = mask-&gt;mask[i].bit_size;
<a name="l00493"></a>00493 
<a name="l00494"></a>00494       regval &gt;&gt;= start;
<a name="l00495"></a>00495 
<a name="l00496"></a>00496       <span class="keywordflow">if</span> (size &lt; 32)
<a name="l00497"></a>00497         regval &amp;= (0xffffffff &gt;&gt; (32 - <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>));
<a name="l00498"></a>00498 
<a name="l00499"></a>00499       mem |= regval &lt;&lt; shift;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501       <span class="keywordflow">if</span> ((shift += size) &gt; bitsize)
<a name="l00502"></a>00502         <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;size of all masks is larger than the register&quot;</span>));
<a name="l00503"></a>00503 
<a name="l00504"></a>00504       <span class="keywordflow">if</span> (shift &gt;= 32)
<a name="l00505"></a>00505         {
<a name="l00506"></a>00506           *ptr++ = mem;
<a name="l00507"></a>00507           bitsize -= 32;
<a name="l00508"></a>00508           shift -= 32;
<a name="l00509"></a>00509 
<a name="l00510"></a>00510           <span class="keywordflow">if</span> (shift == 0)
<a name="l00511"></a>00511             mem = 0;
<a name="l00512"></a>00512           <span class="keywordflow">else</span>
<a name="l00513"></a>00513             mem = regval &gt;&gt; (size - shift);
<a name="l00514"></a>00514         }
<a name="l00515"></a>00515     }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517   <span class="keywordflow">if</span> (shift &gt; 0)
<a name="l00518"></a>00518     *ptr = mem;
<a name="l00519"></a>00519 
<a name="l00520"></a>00520   <span class="comment">/* Copy value to target byte order.  */</span>
<a name="l00521"></a>00521   ptr = value;
<a name="l00522"></a>00522   mem = *ptr;
<a name="l00523"></a>00523 
<a name="l00524"></a>00524   <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (<a class="code" href="regcache_8c.html#ad4f6d0cdf256b1fa45d59a6d71b50659">get_regcache_arch</a> (regcache)) == BFD_ENDIAN_BIG)
<a name="l00525"></a>00525     <span class="keywordflow">for</span> (i = 0; i &lt; bytesize; i++)
<a name="l00526"></a>00526       {
<a name="l00527"></a>00527         <span class="keywordflow">if</span> ((i &amp; 3) == 0)
<a name="l00528"></a>00528           mem = *ptr++;
<a name="l00529"></a>00529         buffer[bytesize - i - 1] = mem &amp; 0xff;
<a name="l00530"></a>00530         mem &gt;&gt;= 8;
<a name="l00531"></a>00531       }
<a name="l00532"></a>00532   <span class="keywordflow">else</span>
<a name="l00533"></a>00533     <span class="keywordflow">for</span> (i = 0; i &lt; bytesize; i++)
<a name="l00534"></a>00534       {
<a name="l00535"></a>00535         <span class="keywordflow">if</span> ((i &amp; 3) == 0)
<a name="l00536"></a>00536           mem = *ptr++;
<a name="l00537"></a>00537         buffer[i] = mem &amp; 0xff;
<a name="l00538"></a>00538         mem &gt;&gt;= 8;
<a name="l00539"></a>00539       }
<a name="l00540"></a>00540 
<a name="l00541"></a>00541   <span class="keywordflow">return</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>;
<a name="l00542"></a>00542 }
<a name="l00543"></a>00543 
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 <span class="comment">/* Read pseudo registers.  */</span>
<a name="l00546"></a>00546 
<a name="l00547"></a>00547 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a>
<a name="l00548"></a>00548 xtensa_pseudo_register_read (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l00549"></a>00549                              <span class="keyword">struct</span> regcache *regcache,
<a name="l00550"></a>00550                              <span class="keywordtype">int</span> regnum,
<a name="l00551"></a>00551                              <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buffer)
<a name="l00552"></a>00552 {
<a name="l00553"></a>00553   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l00554"></a>00554 
<a name="l00555"></a>00555   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;xtensa_pseudo_register_read (... regnum = %d (%s) ...)\n&quot;</span>,
<a name="l00556"></a>00556               regnum, xtensa_register_name (gdbarch, regnum));
<a name="l00557"></a>00557 
<a name="l00558"></a>00558   <span class="keywordflow">if</span> (regnum == <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (gdbarch)
<a name="l00559"></a>00559                 + <a class="code" href="gdbarch_8c.html#a8e0e40f42e5969ee4559ee47717aa9f3">gdbarch_num_pseudo_regs</a> (gdbarch) - 1)
<a name="l00560"></a>00560      regnum = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a> + 1;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562   <span class="comment">/* Read aliases a0..a15, if this is a Windowed ABI.  */</span>
<a name="l00563"></a>00563   <span class="keywordflow">if</span> (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;isa_use_windowed_registers
<a name="l00564"></a>00564       &amp;&amp; (regnum &gt;= <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base)
<a name="l00565"></a>00565       &amp;&amp; (regnum &lt;= <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 15))
<a name="l00566"></a>00566     {
<a name="l00567"></a>00567       <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf = (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *) alloca (<a class="code" href="defs_8h.html#a1f9aebf1de3ebbf4283a4dcf73308562a4f3d67bb99ae292178850a8930ab8252">MAX_REGISTER_SIZE</a>);
<a name="l00568"></a>00568       <span class="keyword">enum</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7">register_status</a> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00569"></a>00569 
<a name="l00570"></a>00570       status = <a class="code" href="regcache_8c.html#a995b366cfa6f89eaa36c6e88227f3462">regcache_raw_read</a> (regcache,
<a name="l00571"></a>00571                                   <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;wb_regnum,
<a name="l00572"></a>00572                                   buf);
<a name="l00573"></a>00573       <span class="keywordflow">if</span> (status != <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>)
<a name="l00574"></a>00574         <span class="keywordflow">return</span> <a class="code" href="namespaceexsummary.html#aa4a2eed06e51a1f73ff9053ec9f2591e">status</a>;
<a name="l00575"></a>00575       regnum = arreg_number (gdbarch, regnum,
<a name="l00576"></a>00576                              <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf, 4, byte_order));
<a name="l00577"></a>00577     }
<a name="l00578"></a>00578 
<a name="l00579"></a>00579   <span class="comment">/* We can always read non-pseudo registers.  */</span>
<a name="l00580"></a>00580   <span class="keywordflow">if</span> (regnum &gt;= 0 &amp;&amp; regnum &lt; <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (gdbarch))
<a name="l00581"></a>00581     <span class="keywordflow">return</span> <a class="code" href="regcache_8c.html#a995b366cfa6f89eaa36c6e88227f3462">regcache_raw_read</a> (regcache, regnum, buffer);
<a name="l00582"></a>00582 
<a name="l00583"></a>00583   <span class="comment">/* We have to find out how to deal with priveleged registers.</span>
<a name="l00584"></a>00584 <span class="comment">     Let&#39;s treat them as pseudo-registers, but we cannot read/write them.  */</span>
<a name="l00585"></a>00585      
<a name="l00586"></a>00586   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (regnum &lt; <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base)
<a name="l00587"></a>00587     {
<a name="l00588"></a>00588       buffer[0] = (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a>)0;
<a name="l00589"></a>00589       buffer[1] = (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a>)0;
<a name="l00590"></a>00590       buffer[2] = (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a>)0;
<a name="l00591"></a>00591       buffer[3] = (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a>)0;
<a name="l00592"></a>00592       <span class="keywordflow">return</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>;
<a name="l00593"></a>00593     }
<a name="l00594"></a>00594   <span class="comment">/* Pseudo registers.  */</span>
<a name="l00595"></a>00595   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (regnum &gt;= 0
<a name="l00596"></a>00596             &amp;&amp; regnum &lt; <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (gdbarch)
<a name="l00597"></a>00597                         + <a class="code" href="gdbarch_8c.html#a8e0e40f42e5969ee4559ee47717aa9f3">gdbarch_num_pseudo_regs</a> (gdbarch))
<a name="l00598"></a>00598     {
<a name="l00599"></a>00599       <a class="code" href="structxtensa__register__t.html">xtensa_register_t</a> *reg = &amp;<a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a19d2226ca2b5d41faacd7affdbcccf73">regmap</a>[<a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>];
<a name="l00600"></a>00600       <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1f">xtensa_register_type_t</a> <a class="code" href="structtype.html">type</a> = reg-&gt;<a class="code" href="structxtensa__register__t.html#aa28456da96da2f1817305588c5231061">type</a>;
<a name="l00601"></a>00601       <span class="keywordtype">int</span> <a class="code" href="solib-som_8c.html#a555096840020c318e34b205419e98cca">flags</a> = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#ac0f12680e959943e194ba2b0ad21acfe">target_flags</a>;
<a name="l00602"></a>00602 
<a name="l00603"></a>00603       <span class="comment">/* We cannot read Unknown or Unmapped registers.  */</span>
<a name="l00604"></a>00604       <span class="keywordflow">if</span> (type == <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1faa655a3275b82aff0344f944df61ccd6c">xtRegisterTypeUnmapped</a> || type == <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1fa1aeaf74a4b74b62e6923d3de45111873">xtRegisterTypeUnknown</a>)
<a name="l00605"></a>00605         {
<a name="l00606"></a>00606           <span class="keywordflow">if</span> ((flags &amp; <a class="code" href="xtensa-tdep_8h.html#af65cfb60ca33ff1ab4cba492b277bf38a53e9ef85c33813f0a5cb89e4986df849">xtTargetFlagsNonVisibleRegs</a>) == 0)
<a name="l00607"></a>00607             {
<a name="l00608"></a>00608               <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot read register %s&quot;</span>),
<a name="l00609"></a>00609                        xtensa_register_name (gdbarch, regnum));
<a name="l00610"></a>00610               <span class="keywordflow">return</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>;
<a name="l00611"></a>00611             }
<a name="l00612"></a>00612         }
<a name="l00613"></a>00613 
<a name="l00614"></a>00614       <span class="comment">/* Some targets cannot read TIE register files.  */</span>
<a name="l00615"></a>00615       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1fa8a570eae54952c1b7032db1b837fd691">xtRegisterTypeTieRegfile</a>)
<a name="l00616"></a>00616         {
<a name="l00617"></a>00617           <span class="comment">/* Use &#39;fetch&#39; to get register?  */</span>
<a name="l00618"></a>00618           <span class="keywordflow">if</span> (flags &amp; <a class="code" href="xtensa-tdep_8h.html#af65cfb60ca33ff1ab4cba492b277bf38ae8ec24fd186b54ed492d5852b3bc2c98">xtTargetFlagsUseFetchStore</a>)
<a name="l00619"></a>00619             {
<a name="l00620"></a>00620               <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot read register&quot;</span>));
<a name="l00621"></a>00621               <span class="keywordflow">return</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>;
<a name="l00622"></a>00622             }
<a name="l00623"></a>00623 
<a name="l00624"></a>00624           <span class="comment">/* On some targets (esp. simulators), we can always read the reg.  */</span>
<a name="l00625"></a>00625           <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((flags &amp; xtTargetFlagsNonVisibleRegs) == 0)
<a name="l00626"></a>00626             {
<a name="l00627"></a>00627               <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot read register&quot;</span>));
<a name="l00628"></a>00628               <span class="keywordflow">return</span> <a class="code" href="regcache_8h.html#af900cc04e1a55ea5ae1edc80570f91f7a0155a2fd1e7e3b53cf1d75cf675d2ea2">REG_VALID</a>;
<a name="l00629"></a>00629             }
<a name="l00630"></a>00630         }
<a name="l00631"></a>00631 
<a name="l00632"></a>00632       <span class="comment">/* We can always read mapped registers.  */</span>
<a name="l00633"></a>00633       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1fa3b4f7c7f2368b07a1d97ed8b0f3f488e">xtRegisterTypeMapped</a> || type == <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1faf93000716a5a5855d3d1507f1895829c">xtRegisterTypeTieState</a>)
<a name="l00634"></a>00634         <span class="keywordflow">return</span> xtensa_register_read_masked (regcache, reg, buffer);
<a name="l00635"></a>00635 
<a name="l00636"></a>00636       <span class="comment">/* Assume that we can read the register.  */</span>
<a name="l00637"></a>00637       <span class="keywordflow">return</span> <a class="code" href="regcache_8c.html#a995b366cfa6f89eaa36c6e88227f3462">regcache_raw_read</a> (regcache, regnum, buffer);
<a name="l00638"></a>00638     }
<a name="l00639"></a>00639   <span class="keywordflow">else</span>
<a name="l00640"></a>00640     <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l00641"></a>00641                     <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;invalid register number %d&quot;</span>), regnum);
<a name="l00642"></a>00642 }
<a name="l00643"></a>00643 
<a name="l00644"></a>00644 
<a name="l00645"></a>00645 <span class="comment">/* Write pseudo registers.  */</span>
<a name="l00646"></a>00646 
<a name="l00647"></a>00647 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00648"></a>00648 xtensa_pseudo_register_write (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l00649"></a>00649                               <span class="keyword">struct</span> regcache *regcache,
<a name="l00650"></a>00650                               <span class="keywordtype">int</span> regnum,
<a name="l00651"></a>00651                               <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buffer)
<a name="l00652"></a>00652 {
<a name="l00653"></a>00653   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l00654"></a>00654 
<a name="l00655"></a>00655   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;xtensa_pseudo_register_write (... regnum = %d (%s) ...)\n&quot;</span>,
<a name="l00656"></a>00656               regnum, xtensa_register_name (gdbarch, regnum));
<a name="l00657"></a>00657 
<a name="l00658"></a>00658   <span class="keywordflow">if</span> (regnum == <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (gdbarch)
<a name="l00659"></a>00659                 + <a class="code" href="gdbarch_8c.html#a8e0e40f42e5969ee4559ee47717aa9f3">gdbarch_num_pseudo_regs</a> (gdbarch) -1)
<a name="l00660"></a>00660      regnum = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a> + 1;
<a name="l00661"></a>00661 
<a name="l00662"></a>00662   <span class="comment">/* Renumber register, if aliase a0..a15 on Windowed ABI.  */</span>
<a name="l00663"></a>00663   <span class="keywordflow">if</span> (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;isa_use_windowed_registers
<a name="l00664"></a>00664       &amp;&amp; (regnum &gt;= <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base)
<a name="l00665"></a>00665       &amp;&amp; (regnum &lt;= <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 15))
<a name="l00666"></a>00666     {
<a name="l00667"></a>00667       <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf = (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *) alloca (<a class="code" href="defs_8h.html#a1f9aebf1de3ebbf4283a4dcf73308562a4f3d67bb99ae292178850a8930ab8252">MAX_REGISTER_SIZE</a>);
<a name="l00668"></a>00668 
<a name="l00669"></a>00669       <a class="code" href="regcache_8c.html#a995b366cfa6f89eaa36c6e88227f3462">regcache_raw_read</a> (regcache,
<a name="l00670"></a>00670                          <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;wb_regnum, buf);
<a name="l00671"></a>00671       regnum = arreg_number (gdbarch, regnum,
<a name="l00672"></a>00672                              <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf, 4, byte_order));
<a name="l00673"></a>00673     }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   <span class="comment">/* We can always write &#39;core&#39; registers.</span>
<a name="l00676"></a>00676 <span class="comment">     Note: We might have converted Ax-&gt;ARy.  */</span>
<a name="l00677"></a>00677   <span class="keywordflow">if</span> (regnum &gt;= 0 &amp;&amp; regnum &lt; <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (gdbarch))
<a name="l00678"></a>00678     <a class="code" href="regcache_8c.html#a1102769bb633fd84087614a3fc5c6e20">regcache_raw_write</a> (regcache, regnum, buffer);
<a name="l00679"></a>00679 
<a name="l00680"></a>00680   <span class="comment">/* We have to find out how to deal with priveleged registers.</span>
<a name="l00681"></a>00681 <span class="comment">     Let&#39;s treat them as pseudo-registers, but we cannot read/write them.  */</span>
<a name="l00682"></a>00682 
<a name="l00683"></a>00683   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (regnum &lt; <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base)
<a name="l00684"></a>00684     {
<a name="l00685"></a>00685       <span class="keywordflow">return</span>;
<a name="l00686"></a>00686     }
<a name="l00687"></a>00687   <span class="comment">/* Pseudo registers.  */</span>
<a name="l00688"></a>00688   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (regnum &gt;= 0
<a name="l00689"></a>00689            &amp;&amp; regnum &lt; <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (gdbarch)
<a name="l00690"></a>00690                        + <a class="code" href="gdbarch_8c.html#a8e0e40f42e5969ee4559ee47717aa9f3">gdbarch_num_pseudo_regs</a> (gdbarch))
<a name="l00691"></a>00691     {
<a name="l00692"></a>00692       <a class="code" href="structxtensa__register__t.html">xtensa_register_t</a> *reg = &amp;<a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a19d2226ca2b5d41faacd7affdbcccf73">regmap</a>[<a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>];
<a name="l00693"></a>00693       <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1f">xtensa_register_type_t</a> type = reg-&gt;<a class="code" href="structxtensa__register__t.html#aa28456da96da2f1817305588c5231061">type</a>;
<a name="l00694"></a>00694       <span class="keywordtype">int</span> flags = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#ac0f12680e959943e194ba2b0ad21acfe">target_flags</a>;
<a name="l00695"></a>00695 
<a name="l00696"></a>00696       <span class="comment">/* On most targets, we cannot write registers</span>
<a name="l00697"></a>00697 <span class="comment">         of type &quot;Unknown&quot; or &quot;Unmapped&quot;.  */</span>
<a name="l00698"></a>00698       <span class="keywordflow">if</span> (type == <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1faa655a3275b82aff0344f944df61ccd6c">xtRegisterTypeUnmapped</a> || type == <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1fa1aeaf74a4b74b62e6923d3de45111873">xtRegisterTypeUnknown</a>)
<a name="l00699"></a>00699         {
<a name="l00700"></a>00700           <span class="keywordflow">if</span> ((flags &amp; xtTargetFlagsNonVisibleRegs) == 0)
<a name="l00701"></a>00701             {
<a name="l00702"></a>00702               <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot write register %s&quot;</span>),
<a name="l00703"></a>00703                        xtensa_register_name (gdbarch, regnum));
<a name="l00704"></a>00704               <span class="keywordflow">return</span>;
<a name="l00705"></a>00705             }
<a name="l00706"></a>00706         }
<a name="l00707"></a>00707 
<a name="l00708"></a>00708       <span class="comment">/* Some targets cannot read TIE register files.  */</span>
<a name="l00709"></a>00709       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1fa8a570eae54952c1b7032db1b837fd691">xtRegisterTypeTieRegfile</a>)
<a name="l00710"></a>00710         {
<a name="l00711"></a>00711           <span class="comment">/* Use &#39;store&#39; to get register?  */</span>
<a name="l00712"></a>00712           <span class="keywordflow">if</span> (flags &amp; xtTargetFlagsUseFetchStore)
<a name="l00713"></a>00713             {
<a name="l00714"></a>00714               <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot write register&quot;</span>));
<a name="l00715"></a>00715               <span class="keywordflow">return</span>;
<a name="l00716"></a>00716             }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718           <span class="comment">/* On some targets (esp. simulators), we can always write</span>
<a name="l00719"></a>00719 <span class="comment">             the register.  */</span>
<a name="l00720"></a>00720           <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((flags &amp; xtTargetFlagsNonVisibleRegs) == 0)
<a name="l00721"></a>00721             {
<a name="l00722"></a>00722               <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot write register&quot;</span>));
<a name="l00723"></a>00723               <span class="keywordflow">return</span>;
<a name="l00724"></a>00724             }
<a name="l00725"></a>00725         }
<a name="l00726"></a>00726 
<a name="l00727"></a>00727       <span class="comment">/* We can always write mapped registers.  */</span>
<a name="l00728"></a>00728       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1fa3b4f7c7f2368b07a1d97ed8b0f3f488e">xtRegisterTypeMapped</a> || type == <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1faf93000716a5a5855d3d1507f1895829c">xtRegisterTypeTieState</a>)
<a name="l00729"></a>00729         {
<a name="l00730"></a>00730           xtensa_register_write_masked (regcache, reg, buffer);
<a name="l00731"></a>00731           <span class="keywordflow">return</span>;
<a name="l00732"></a>00732         }
<a name="l00733"></a>00733 
<a name="l00734"></a>00734       <span class="comment">/* Assume that we can write the register.  */</span>
<a name="l00735"></a>00735       <a class="code" href="regcache_8c.html#a1102769bb633fd84087614a3fc5c6e20">regcache_raw_write</a> (regcache, regnum, buffer);
<a name="l00736"></a>00736     }
<a name="l00737"></a>00737   <span class="keywordflow">else</span>
<a name="l00738"></a>00738     <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l00739"></a>00739                     <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;invalid register number %d&quot;</span>), regnum);
<a name="l00740"></a>00740 }
<a name="l00741"></a>00741 
<a name="l00742"></a>00742 <span class="keyword">static</span> <span class="keyword">struct </span>reggroup *xtensa_ar_reggroup;
<a name="l00743"></a>00743 <span class="keyword">static</span> <span class="keyword">struct </span>reggroup *xtensa_user_reggroup;
<a name="l00744"></a>00744 <span class="keyword">static</span> <span class="keyword">struct </span>reggroup *xtensa_vectra_reggroup;
<a name="l00745"></a>00745 <span class="keyword">static</span> <span class="keyword">struct </span>reggroup *xtensa_cp[<a class="code" href="xtensa-tdep_8h.html#a8f5201eecef5bfdf9073e813a423e1c3">XTENSA_MAX_COPROCESSOR</a>];
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00748"></a>00748 xtensa_init_reggroups (<span class="keywordtype">void</span>)
<a name="l00749"></a>00749 {
<a name="l00750"></a>00750   <span class="keywordtype">int</span> i;
<a name="l00751"></a>00751   <span class="keywordtype">char</span> cpname[] = <span class="stringliteral">&quot;cp0&quot;</span>;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753   xtensa_ar_reggroup = <a class="code" href="reggroups_8c.html#a3cb3369b5063997a1382cfb8ad240ad6">reggroup_new</a> (<span class="stringliteral">&quot;ar&quot;</span>, <a class="code" href="reggroups_8h.html#a7377a90943c0ba0d23c3b03a07583f22a9ef6d86366eea2f7b79d387752a38be1">USER_REGGROUP</a>);
<a name="l00754"></a>00754   xtensa_user_reggroup = <a class="code" href="reggroups_8c.html#a3cb3369b5063997a1382cfb8ad240ad6">reggroup_new</a> (<span class="stringliteral">&quot;user&quot;</span>, <a class="code" href="reggroups_8h.html#a7377a90943c0ba0d23c3b03a07583f22a9ef6d86366eea2f7b79d387752a38be1">USER_REGGROUP</a>);
<a name="l00755"></a>00755   xtensa_vectra_reggroup = <a class="code" href="reggroups_8c.html#a3cb3369b5063997a1382cfb8ad240ad6">reggroup_new</a> (<span class="stringliteral">&quot;vectra&quot;</span>, <a class="code" href="reggroups_8h.html#a7377a90943c0ba0d23c3b03a07583f22a9ef6d86366eea2f7b79d387752a38be1">USER_REGGROUP</a>);
<a name="l00756"></a>00756 
<a name="l00757"></a>00757   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="xtensa-tdep_8h.html#a8f5201eecef5bfdf9073e813a423e1c3">XTENSA_MAX_COPROCESSOR</a>; i++)
<a name="l00758"></a>00758     {
<a name="l00759"></a>00759       cpname[2] = <span class="charliteral">&#39;0&#39;</span> + i;
<a name="l00760"></a>00760       xtensa_cp[i] = <a class="code" href="reggroups_8c.html#a3cb3369b5063997a1382cfb8ad240ad6">reggroup_new</a> (cpname, <a class="code" href="reggroups_8h.html#a7377a90943c0ba0d23c3b03a07583f22a9ef6d86366eea2f7b79d387752a38be1">USER_REGGROUP</a>);
<a name="l00761"></a>00761     }
<a name="l00762"></a>00762 }
<a name="l00763"></a>00763 
<a name="l00764"></a>00764 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00765"></a>00765 xtensa_add_reggroups (<span class="keyword">struct</span> gdbarch *gdbarch)
<a name="l00766"></a>00766 {
<a name="l00767"></a>00767   <span class="keywordtype">int</span> i;
<a name="l00768"></a>00768 
<a name="l00769"></a>00769   <span class="comment">/* Predefined groups.  */</span>
<a name="l00770"></a>00770   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, <a class="code" href="reggroups_8c.html#a1c7760844f4c40a5fb70e84f76f39676">all_reggroup</a>);
<a name="l00771"></a>00771   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, <a class="code" href="reggroups_8c.html#a9be54927c9d0393a70b8a3f0bc740de3">save_reggroup</a>);
<a name="l00772"></a>00772   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, <a class="code" href="reggroups_8c.html#a627d3b74a917560e7d81d93c472e915c">restore_reggroup</a>);
<a name="l00773"></a>00773   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, <a class="code" href="reggroups_8c.html#a55cfcb5dfb32653c793fa6b402564068">system_reggroup</a>);
<a name="l00774"></a>00774   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, <a class="code" href="reggroups_8c.html#acef92c12b5ada70b62335d3de0752669">vector_reggroup</a>);
<a name="l00775"></a>00775   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, <a class="code" href="reggroups_8c.html#a2409cc2e19cc71ae02448af0ec0308fd">general_reggroup</a>);
<a name="l00776"></a>00776   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, <a class="code" href="reggroups_8c.html#ad0b48edad91dabaa07f672908185a7d4">float_reggroup</a>);
<a name="l00777"></a>00777 
<a name="l00778"></a>00778   <span class="comment">/* Xtensa-specific groups.  */</span>
<a name="l00779"></a>00779   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, xtensa_ar_reggroup);
<a name="l00780"></a>00780   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, xtensa_user_reggroup);
<a name="l00781"></a>00781   <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, xtensa_vectra_reggroup);
<a name="l00782"></a>00782 
<a name="l00783"></a>00783   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="xtensa-tdep_8h.html#a8f5201eecef5bfdf9073e813a423e1c3">XTENSA_MAX_COPROCESSOR</a>; i++)
<a name="l00784"></a>00784     <a class="code" href="reggroups_8c.html#ac7bf3ffcf189976292b76329691cdba4">reggroup_add</a> (gdbarch, xtensa_cp[i]);
<a name="l00785"></a>00785 }
<a name="l00786"></a>00786 
<a name="l00787"></a>00787 <span class="keyword">static</span> <span class="keywordtype">int</span> 
<a name="l00788"></a>00788 xtensa_coprocessor_register_group (<span class="keyword">struct</span> reggroup *group)
<a name="l00789"></a>00789 {
<a name="l00790"></a>00790   <span class="keywordtype">int</span> i;
<a name="l00791"></a>00791 
<a name="l00792"></a>00792   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="xtensa-tdep_8h.html#a8f5201eecef5bfdf9073e813a423e1c3">XTENSA_MAX_COPROCESSOR</a>; i++)
<a name="l00793"></a>00793     <span class="keywordflow">if</span> (group == xtensa_cp[i])
<a name="l00794"></a>00794       <span class="keywordflow">return</span> i;
<a name="l00795"></a>00795 
<a name="l00796"></a>00796   <span class="keywordflow">return</span> -1;
<a name="l00797"></a>00797 }
<a name="l00798"></a>00798 
<a name="l00799"></a><a class="code" href="xtensa-tdep_8c.html#a21f9f23d302b5cb2541502d37d9c2655">00799</a> <span class="preprocessor">#define SAVE_REST_FLAGS (XTENSA_REGISTER_FLAGS_READABLE \</span>
<a name="l00800"></a>00800 <span class="preprocessor">                        | XTENSA_REGISTER_FLAGS_WRITABLE \</span>
<a name="l00801"></a>00801 <span class="preprocessor">                        | XTENSA_REGISTER_FLAGS_VOLATILE)</span>
<a name="l00802"></a>00802 <span class="preprocessor"></span>
<a name="l00803"></a><a class="code" href="xtensa-tdep_8c.html#a0cec4dceb0b5c1f8c0b258b230327a65">00803</a> <span class="preprocessor">#define SAVE_REST_VALID (XTENSA_REGISTER_FLAGS_READABLE \</span>
<a name="l00804"></a>00804 <span class="preprocessor">                        | XTENSA_REGISTER_FLAGS_WRITABLE)</span>
<a name="l00805"></a>00805 <span class="preprocessor"></span>
<a name="l00806"></a>00806 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00807"></a>00807 xtensa_register_reggroup_p (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l00808"></a>00808                             <span class="keywordtype">int</span> regnum,
<a name="l00809"></a>00809                             <span class="keyword">struct</span> reggroup *group)
<a name="l00810"></a>00810 {
<a name="l00811"></a>00811   <a class="code" href="structxtensa__register__t.html">xtensa_register_t</a>* reg = &amp;<a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a19d2226ca2b5d41faacd7affdbcccf73">regmap</a>[<a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>];
<a name="l00812"></a>00812   <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1f">xtensa_register_type_t</a> type = reg-&gt;<a class="code" href="structxtensa__register__t.html#aa28456da96da2f1817305588c5231061">type</a>;
<a name="l00813"></a>00813   <a class="code" href="xtensa-tdep_8h.html#a9b1d6a0cdd895a8a9aecd511f05eba5e">xtensa_register_group_t</a> rg = reg-&gt;<a class="code" href="structxtensa__register__t.html#a83fa7db09e6a40046072b2773d1920ba">group</a>;
<a name="l00814"></a>00814   <span class="keywordtype">int</span> cp_number;
<a name="l00815"></a>00815 
<a name="l00816"></a>00816   <span class="keywordflow">if</span> (group == <a class="code" href="reggroups_8c.html#a9be54927c9d0393a70b8a3f0bc740de3">save_reggroup</a>)
<a name="l00817"></a>00817     <span class="comment">/* Every single register should be included into the list of registers</span>
<a name="l00818"></a>00818 <span class="comment">       to be watched for changes while using -data-list-changed-registers.  */</span>
<a name="l00819"></a>00819     <span class="keywordflow">return</span> 1;
<a name="l00820"></a>00820 
<a name="l00821"></a>00821   <span class="comment">/* First, skip registers that are not visible to this target</span>
<a name="l00822"></a>00822 <span class="comment">     (unknown and unmapped registers when not using ISS).  */</span>
<a name="l00823"></a>00823 
<a name="l00824"></a>00824   <span class="keywordflow">if</span> (type == <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1faa655a3275b82aff0344f944df61ccd6c">xtRegisterTypeUnmapped</a> || type == <a class="code" href="xtensa-tdep_8h.html#aab1938ed47abbaa57cbbc52a19b4ac1fa1aeaf74a4b74b62e6923d3de45111873">xtRegisterTypeUnknown</a>)
<a name="l00825"></a>00825     <span class="keywordflow">return</span> 0;
<a name="l00826"></a>00826   <span class="keywordflow">if</span> (group == <a class="code" href="reggroups_8c.html#a1c7760844f4c40a5fb70e84f76f39676">all_reggroup</a>)
<a name="l00827"></a>00827     <span class="keywordflow">return</span> 1;
<a name="l00828"></a>00828   <span class="keywordflow">if</span> (group == xtensa_ar_reggroup)
<a name="l00829"></a>00829     <span class="keywordflow">return</span> rg &amp; <a class="code" href="xtensa-tdep_8h.html#a9b1d6a0cdd895a8a9aecd511f05eba5ea97136aa9680632ba8c51d54f1b35bb13">xtRegisterGroupAddrReg</a>;
<a name="l00830"></a>00830   <span class="keywordflow">if</span> (group == xtensa_user_reggroup)
<a name="l00831"></a>00831     <span class="keywordflow">return</span> rg &amp; <a class="code" href="xtensa-tdep_8h.html#a9b1d6a0cdd895a8a9aecd511f05eba5ea278180e9cde8a28ffca184210ffadc5c">xtRegisterGroupUser</a>;
<a name="l00832"></a>00832   <span class="keywordflow">if</span> (group == <a class="code" href="reggroups_8c.html#ad0b48edad91dabaa07f672908185a7d4">float_reggroup</a>)
<a name="l00833"></a>00833     <span class="keywordflow">return</span> rg &amp; <a class="code" href="xtensa-tdep_8h.html#a9b1d6a0cdd895a8a9aecd511f05eba5ea49da8cb813ff49ceb08c012654f87c8c">xtRegisterGroupFloat</a>;
<a name="l00834"></a>00834   <span class="keywordflow">if</span> (group == <a class="code" href="reggroups_8c.html#a2409cc2e19cc71ae02448af0ec0308fd">general_reggroup</a>)
<a name="l00835"></a>00835     <span class="keywordflow">return</span> rg &amp; <a class="code" href="xtensa-tdep_8h.html#a9b1d6a0cdd895a8a9aecd511f05eba5eae9fb4ab1b31b3d5ed83bb0a6b17f384a">xtRegisterGroupGeneral</a>;
<a name="l00836"></a>00836   <span class="keywordflow">if</span> (group == <a class="code" href="reggroups_8c.html#a55cfcb5dfb32653c793fa6b402564068">system_reggroup</a>)
<a name="l00837"></a>00837     <span class="keywordflow">return</span> rg &amp; <a class="code" href="xtensa-tdep_8h.html#a9b1d6a0cdd895a8a9aecd511f05eba5ea489dc85480511023e18accf31e259ba4">xtRegisterGroupState</a>;
<a name="l00838"></a>00838   <span class="keywordflow">if</span> (group == <a class="code" href="reggroups_8c.html#acef92c12b5ada70b62335d3de0752669">vector_reggroup</a> || group == xtensa_vectra_reggroup)
<a name="l00839"></a>00839     <span class="keywordflow">return</span> rg &amp; <a class="code" href="xtensa-tdep_8h.html#a9b1d6a0cdd895a8a9aecd511f05eba5ea4f3022dacbb7abe83ccf1d55c6b7ee85">xtRegisterGroupVectra</a>;
<a name="l00840"></a>00840   <span class="keywordflow">if</span> (group == <a class="code" href="reggroups_8c.html#a627d3b74a917560e7d81d93c472e915c">restore_reggroup</a>)
<a name="l00841"></a>00841     <span class="keywordflow">return</span> (regnum &lt; <a class="code" href="gdbarch_8c.html#a69069435754d0b434c7043a21d247325">gdbarch_num_regs</a> (gdbarch)
<a name="l00842"></a>00842             &amp;&amp; (reg-&gt;<a class="code" href="structxtensa__register__t.html#a4979d750a9c1c637e9c78bfb6dbea291">flags</a> &amp; <a class="code" href="xtensa-tdep_8c.html#a21f9f23d302b5cb2541502d37d9c2655">SAVE_REST_FLAGS</a>) == <a class="code" href="xtensa-tdep_8c.html#a0cec4dceb0b5c1f8c0b258b230327a65">SAVE_REST_VALID</a>);
<a name="l00843"></a>00843   cp_number = xtensa_coprocessor_register_group (group);
<a name="l00844"></a>00844   <span class="keywordflow">if</span> (cp_number &gt;= 0)
<a name="l00845"></a>00845     <span class="keywordflow">return</span> rg &amp; (<a class="code" href="xtensa-tdep_8h.html#a9b1d6a0cdd895a8a9aecd511f05eba5ea8b8ec127551f0f3bc776cca51158e294">xtRegisterGroupCP0</a> &lt;&lt; cp_number);
<a name="l00846"></a>00846   <span class="keywordflow">else</span>
<a name="l00847"></a>00847     <span class="keywordflow">return</span> 1;
<a name="l00848"></a>00848 }
<a name="l00849"></a>00849 
<a name="l00850"></a>00850 
<a name="l00851"></a>00851 <span class="comment">/* Supply register REGNUM from the buffer specified by GREGS and LEN</span>
<a name="l00852"></a>00852 <span class="comment">   in the general-purpose register set REGSET to register cache</span>
<a name="l00853"></a>00853 <span class="comment">   REGCACHE.  If REGNUM is -1 do this for all registers in REGSET.  */</span>
<a name="l00854"></a>00854 
<a name="l00855"></a>00855 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00856"></a>00856 xtensa_supply_gregset (<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structregset.html">regset</a> *<a class="code" href="structregset.html">regset</a>,
<a name="l00857"></a>00857                        <span class="keyword">struct</span> regcache *rc,
<a name="l00858"></a>00858                        <span class="keywordtype">int</span> regnum,
<a name="l00859"></a>00859                        <span class="keyword">const</span> <span class="keywordtype">void</span> *gregs,
<a name="l00860"></a>00860                        <span class="keywordtype">size_t</span> <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>)
<a name="l00861"></a>00861 {
<a name="l00862"></a>00862   <span class="keyword">const</span> <a class="code" href="structxtensa__elf__gregset__t.html">xtensa_elf_gregset_t</a> *regs = gregs;
<a name="l00863"></a>00863   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="regcache_8c.html#ad4f6d0cdf256b1fa45d59a6d71b50659">get_regcache_arch</a> (rc);
<a name="l00864"></a>00864   <span class="keywordtype">int</span> i;
<a name="l00865"></a>00865 
<a name="l00866"></a>00866   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;xtensa_supply_gregset (..., regnum==%d, ...)\n&quot;</span>, regnum);
<a name="l00867"></a>00867 
<a name="l00868"></a>00868   <span class="keywordflow">if</span> (regnum == <a class="code" href="gdbarch_8c.html#a07a162ebafea1269eb8f341db44e53e7">gdbarch_pc_regnum</a> (gdbarch) || regnum == -1)
<a name="l00869"></a>00869     <a class="code" href="regcache_8c.html#a127ceeb6f30d3bab748c60570ac077a6">regcache_raw_supply</a> (rc, <a class="code" href="gdbarch_8c.html#a07a162ebafea1269eb8f341db44e53e7">gdbarch_pc_regnum</a> (gdbarch), (<span class="keywordtype">char</span> *) &amp;regs-&gt;<a class="code" href="structxtensa__elf__gregset__t.html#ab2a02260fd7910e171e26565b02d8591">pc</a>);
<a name="l00870"></a>00870   <span class="keywordflow">if</span> (regnum == <a class="code" href="gdbarch_8c.html#aa0e316e2d110495a985d9f566df348c3">gdbarch_ps_regnum</a> (gdbarch) || regnum == -1)
<a name="l00871"></a>00871     <a class="code" href="regcache_8c.html#a127ceeb6f30d3bab748c60570ac077a6">regcache_raw_supply</a> (rc, <a class="code" href="gdbarch_8c.html#aa0e316e2d110495a985d9f566df348c3">gdbarch_ps_regnum</a> (gdbarch), (<span class="keywordtype">char</span> *) &amp;regs-&gt;<a class="code" href="structxtensa__elf__gregset__t.html#a72eacc392ddb6b439115463c63e25f2f">ps</a>);
<a name="l00872"></a>00872   <span class="keywordflow">if</span> (regnum == <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;wb_regnum || regnum == -1)
<a name="l00873"></a>00873     <a class="code" href="regcache_8c.html#a127ceeb6f30d3bab748c60570ac077a6">regcache_raw_supply</a> (rc, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;wb_regnum,
<a name="l00874"></a>00874                          (<span class="keywordtype">char</span> *) &amp;regs-&gt;<a class="code" href="structxtensa__elf__gregset__t.html#ae4c6e43ef2868f5bc21d44f71acd21b1">windowbase</a>);
<a name="l00875"></a>00875   <span class="keywordflow">if</span> (regnum == <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;ws_regnum || regnum == -1)
<a name="l00876"></a>00876     <a class="code" href="regcache_8c.html#a127ceeb6f30d3bab748c60570ac077a6">regcache_raw_supply</a> (rc, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;ws_regnum,
<a name="l00877"></a>00877                          (<span class="keywordtype">char</span> *) &amp;regs-&gt;<a class="code" href="structxtensa__elf__gregset__t.html#ac3d6a1b96f34d293101c50a43b0c7fd3">windowstart</a>);
<a name="l00878"></a>00878   <span class="keywordflow">if</span> (regnum == <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;lbeg_regnum || regnum == -1)
<a name="l00879"></a>00879     <a class="code" href="regcache_8c.html#a127ceeb6f30d3bab748c60570ac077a6">regcache_raw_supply</a> (rc, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;lbeg_regnum,
<a name="l00880"></a>00880                          (<span class="keywordtype">char</span> *) &amp;regs-&gt;<a class="code" href="structxtensa__elf__gregset__t.html#abfe29c75c307c7c52d2683672f618043">lbeg</a>);
<a name="l00881"></a>00881   <span class="keywordflow">if</span> (regnum == <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;lend_regnum || regnum == -1)
<a name="l00882"></a>00882     <a class="code" href="regcache_8c.html#a127ceeb6f30d3bab748c60570ac077a6">regcache_raw_supply</a> (rc, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;lend_regnum,
<a name="l00883"></a>00883                          (<span class="keywordtype">char</span> *) &amp;regs-&gt;<a class="code" href="structxtensa__elf__gregset__t.html#ac93afed34eed266079c665c5125bb04b">lend</a>);
<a name="l00884"></a>00884   <span class="keywordflow">if</span> (regnum == <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;lcount_regnum || regnum == -1)
<a name="l00885"></a>00885     <a class="code" href="regcache_8c.html#a127ceeb6f30d3bab748c60570ac077a6">regcache_raw_supply</a> (rc, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;lcount_regnum,
<a name="l00886"></a>00886                          (<span class="keywordtype">char</span> *) &amp;regs-&gt;<a class="code" href="structxtensa__elf__gregset__t.html#a6b1e78ec249851b2879b2ed175b9301f">lcount</a>);
<a name="l00887"></a>00887   <span class="keywordflow">if</span> (regnum == <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;sar_regnum || regnum == -1)
<a name="l00888"></a>00888     <a class="code" href="regcache_8c.html#a127ceeb6f30d3bab748c60570ac077a6">regcache_raw_supply</a> (rc, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;sar_regnum,
<a name="l00889"></a>00889                          (<span class="keywordtype">char</span> *) &amp;regs-&gt;<a class="code" href="structxtensa__elf__gregset__t.html#ae42222e7cc10b3ccfde4adeca1c2f27a">sar</a>);
<a name="l00890"></a>00890   <span class="keywordflow">if</span> (regnum &gt;=<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;ar_base
<a name="l00891"></a>00891       &amp;&amp; regnum &lt; <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;ar_base
<a name="l00892"></a>00892                     + <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;num_aregs)
<a name="l00893"></a>00893     <a class="code" href="regcache_8c.html#a127ceeb6f30d3bab748c60570ac077a6">regcache_raw_supply</a> (rc, regnum,
<a name="l00894"></a>00894                          (<span class="keywordtype">char</span> *) &amp;regs-&gt;<a class="code" href="structxtensa__elf__gregset__t.html#a2dce281529b5e8cce233be4fe3b87dd3">ar</a>[regnum - <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a>
<a name="l00895"></a>00895                            (gdbarch)-&gt;ar_base]);
<a name="l00896"></a>00896   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (regnum == -1)
<a name="l00897"></a>00897     {
<a name="l00898"></a>00898       <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a4f769a0e5c51524a59b35f0841991552">num_aregs</a>; ++i)
<a name="l00899"></a>00899         <a class="code" href="regcache_8c.html#a127ceeb6f30d3bab748c60570ac077a6">regcache_raw_supply</a> (rc, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a73432cf260ddfd1984970794410c0b59">ar_base</a> + i,
<a name="l00900"></a>00900                              (<span class="keywordtype">char</span> *) &amp;regs-&gt;<a class="code" href="structxtensa__elf__gregset__t.html#a2dce281529b5e8cce233be4fe3b87dd3">ar</a>[i]);
<a name="l00901"></a>00901     }
<a name="l00902"></a>00902 }
<a name="l00903"></a>00903 
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 <span class="comment">/* Xtensa register set.  */</span>
<a name="l00906"></a>00906 
<a name="l00907"></a>00907 <span class="keyword">static</span> <span class="keyword">struct </span>regset
<a name="l00908"></a>00908 xtensa_gregset =
<a name="l00909"></a>00909 {
<a name="l00910"></a>00910   NULL,
<a name="l00911"></a>00911   xtensa_supply_gregset
<a name="l00912"></a>00912 };
<a name="l00913"></a>00913 
<a name="l00914"></a>00914 
<a name="l00915"></a>00915 <span class="comment">/* Return the appropriate register set for the core</span>
<a name="l00916"></a>00916 <span class="comment">   section identified by SECT_NAME and SECT_SIZE.  */</span>
<a name="l00917"></a>00917 
<a name="l00918"></a>00918 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>regset *
<a name="l00919"></a>00919 xtensa_regset_from_core_section (<span class="keyword">struct</span> gdbarch *core_arch,
<a name="l00920"></a>00920                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *sect_name,
<a name="l00921"></a>00921                                  <span class="keywordtype">size_t</span> sect_size)
<a name="l00922"></a>00922 {
<a name="l00923"></a>00923   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;xtensa_regset_from_core_section &quot;</span>
<a name="l00924"></a>00924               <span class="stringliteral">&quot;(..., sect_name==\&quot;%s\&quot;, sect_size==%x)\n&quot;</span>,
<a name="l00925"></a>00925               sect_name, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) sect_size);
<a name="l00926"></a>00926 
<a name="l00927"></a>00927   <span class="keywordflow">if</span> (strcmp (sect_name, <span class="stringliteral">&quot;.reg&quot;</span>) == 0
<a name="l00928"></a>00928       &amp;&amp; sect_size &gt;= <span class="keyword">sizeof</span>(<a class="code" href="structxtensa__elf__gregset__t.html">xtensa_elf_gregset_t</a>))
<a name="l00929"></a>00929     <span class="keywordflow">return</span> &amp;xtensa_gregset;
<a name="l00930"></a>00930 
<a name="l00931"></a>00931   <span class="keywordflow">return</span> NULL;
<a name="l00932"></a>00932 }
<a name="l00933"></a>00933 
<a name="l00934"></a>00934 
<a name="l00935"></a>00935 <span class="comment">/* Handling frames.  */</span>
<a name="l00936"></a>00936 
<a name="l00937"></a>00937 <span class="comment">/* Number of registers to save in case of Windowed ABI.  */</span>
<a name="l00938"></a><a class="code" href="xtensa-tdep_8c.html#a26463eb820061ed221e4aefbc1cf0fb9">00938</a> <span class="preprocessor">#define XTENSA_NUM_SAVED_AREGS          12</span>
<a name="l00939"></a>00939 <span class="preprocessor"></span>
<a name="l00940"></a>00940 <span class="comment">/* Frame cache part for Windowed ABI.  */</span>
<a name="l00941"></a>00941 <span class="keyword">typedef</span> <span class="keyword">struct </span>xtensa_windowed_frame_cache
<a name="l00942"></a>00942 {
<a name="l00943"></a>00943   <span class="keywordtype">int</span> wb;               <span class="comment">/* WINDOWBASE of the previous frame.  */</span>
<a name="l00944"></a>00944   <span class="keywordtype">int</span> callsize;         <span class="comment">/* Call size of this frame.  */</span>
<a name="l00945"></a>00945   <span class="keywordtype">int</span> ws;               <span class="comment">/* WINDOWSTART of the previous frame.  It keeps track of</span>
<a name="l00946"></a>00946 <span class="comment">                           life windows only.  If there is no bit set for the</span>
<a name="l00947"></a>00947 <span class="comment">                           window,  that means it had been already spilled</span>
<a name="l00948"></a>00948 <span class="comment">                           because of window overflow.  */</span>
<a name="l00949"></a>00949 
<a name="l00950"></a>00950    <span class="comment">/* Addresses of spilled A-registers.</span>
<a name="l00951"></a>00951 <span class="comment">      AREGS[i] == -1, if corresponding AR is alive.  */</span>
<a name="l00952"></a>00952   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> aregs[<a class="code" href="xtensa-tdep_8c.html#a26463eb820061ed221e4aefbc1cf0fb9">XTENSA_NUM_SAVED_AREGS</a>];
<a name="l00953"></a>00953 } <a class="code" href="xtensa-tdep_8c.html#afb5ed802c384876593ce773d54e74dad">xtensa_windowed_frame_cache_t</a>;
<a name="l00954"></a>00954 
<a name="l00955"></a>00955 <span class="comment">/* Call0 ABI Definitions.  */</span>
<a name="l00956"></a>00956 
<a name="l00957"></a><a class="code" href="xtensa-tdep_8c.html#a5bea1a2b0ec115ce00d86b1a409770a9">00957</a> <span class="preprocessor">#define C0_MAXOPDS  3   </span><span class="comment">/* Maximum number of operands for prologue</span>
<a name="l00958"></a><a class="code" href="xtensa-tdep_8c.html#a78bb729d39d6d29c761515a76d68eb68">00958</a> <span class="comment">                           analysis.  */</span>
<a name="l00959"></a><a class="code" href="xtensa-tdep_8c.html#abbc975d39626d96acec1be56f07ce84e">00959</a> <span class="preprocessor">#define C0_NREGS   16   </span><span class="comment">/* Number of A-registers to track.  */</span>
<a name="l00960"></a><a class="code" href="xtensa-tdep_8c.html#a90c61cc2de5068f3d0dadbca1611ca4d">00960</a> <span class="preprocessor">#define C0_CLESV   12   </span><span class="comment">/* Callee-saved registers are here and up.  */</span>
<a name="l00961"></a><a class="code" href="xtensa-tdep_8c.html#ac5288ff604dd5732048dd20612b640f4">00961</a> <span class="preprocessor">#define C0_SP       1   </span><span class="comment">/* Register used as SP.  */</span>
<a name="l00962"></a><a class="code" href="xtensa-tdep_8c.html#a359723d76f1ffe049fa67abb082647bd">00962</a> <span class="preprocessor">#define C0_FP      15   </span><span class="comment">/* Register used as FP.  */</span>
<a name="l00963"></a><a class="code" href="xtensa-tdep_8c.html#acd655972d03b0cd702f8c8f53b3d742c">00963</a> <span class="preprocessor">#define C0_RA       0   </span><span class="comment">/* Register used as return address.  */</span>
<a name="l00964"></a><a class="code" href="xtensa-tdep_8c.html#aa2679f345a1e4fcf60718d0e823bb9a6">00964</a> <span class="preprocessor">#define C0_ARGS     2   </span><span class="comment">/* Register used as first arg/retval.  */</span>
<a name="l00965"></a>00965 <span class="preprocessor">#define C0_NARGS    6   </span><span class="comment">/* Number of A-regs for args/retvals.  */</span>
<a name="l00966"></a>00966 
<a name="l00967"></a>00967 <span class="comment">/* Each element of xtensa_call0_frame_cache.c0_rt[] describes for each</span>
<a name="l00968"></a>00968 <span class="comment">   A-register where the current content of the reg came from (in terms</span>
<a name="l00969"></a>00969 <span class="comment">   of an original reg and a constant).  Negative values of c0_rt[n].fp_reg</span>
<a name="l00970"></a>00970 <span class="comment">   mean that the orignal content of the register was saved to the stack.</span>
<a name="l00971"></a>00971 <span class="comment">   c0_rt[n].fr.ofs is NOT the offset from the frame base because we don&#39;t </span>
<a name="l00972"></a>00972 <span class="comment">   know where SP will end up until the entire prologue has been analyzed.  */</span>
<a name="l00973"></a><a class="code" href="xtensa-tdep_8c.html#af48d45d73d45634d1597d4071a933c23">00973</a> 
<a name="l00974"></a><a class="code" href="xtensa-tdep_8c.html#a51694ea2494265ce611e70196f1e9009">00974</a> <span class="preprocessor">#define C0_CONST   -1   </span><span class="comment">/* fr_reg value if register contains a constant.  */</span>
<a name="l00975"></a><a class="code" href="xtensa-tdep_8c.html#a3e9badad6b26919da866065d6f3a3573">00975</a> <span class="preprocessor">#define C0_INEXP   -2   </span><span class="comment">/* fr_reg value if inexpressible as reg + offset.  */</span>
<a name="l00976"></a>00976 <span class="preprocessor">#define C0_NOSTK   -1   </span><span class="comment">/* to_stk value if register has not been stored.  */</span>
<a name="l00977"></a>00977 
<a name="l00978"></a>00978 <span class="keyword">extern</span> xtensa_isa <a class="code" href="xtensa-tdep_8c.html#ace7b7a905b769248df556d013661d2dc">xtensa_default_isa</a>;
<a name="l00979"></a>00979 
<a name="l00980"></a>00980 <span class="keyword">typedef</span> <span class="keyword">struct </span>xtensa_c0reg
<a name="l00981"></a>00981 {
<a name="l00982"></a>00982   <span class="keywordtype">int</span> fr_reg;  <span class="comment">/* original register from which register content</span>
<a name="l00983"></a>00983 <span class="comment">                  is derived, or C0_CONST, or C0_INEXP.  */</span>
<a name="l00984"></a>00984   <span class="keywordtype">int</span> fr_ofs;  <span class="comment">/* constant offset from reg, or immediate value.  */</span>
<a name="l00985"></a>00985   <span class="keywordtype">int</span> to_stk;  <span class="comment">/* offset from original SP to register (4-byte aligned),</span>
<a name="l00986"></a>00986 <span class="comment">                  or C0_NOSTK if register has not been saved.  */</span>
<a name="l00987"></a>00987 } <a class="code" href="xtensa-tdep_8c.html#aa24578348135491500f62ed2af882686">xtensa_c0reg_t</a>;
<a name="l00988"></a>00988 
<a name="l00989"></a>00989 <span class="comment">/* Frame cache part for Call0 ABI.  */</span>
<a name="l00990"></a>00990 <span class="keyword">typedef</span> <span class="keyword">struct </span>xtensa_call0_frame_cache
<a name="l00991"></a>00991 {
<a name="l00992"></a>00992   <span class="keywordtype">int</span> c0_frmsz;                    <span class="comment">/* Stack frame size.  */</span>
<a name="l00993"></a>00993   <span class="keywordtype">int</span> c0_hasfp;                    <span class="comment">/* Current frame uses frame pointer.  */</span>
<a name="l00994"></a>00994   <span class="keywordtype">int</span> <a class="code" href="frv-tdep_8h.html#ae6dceca96ec2c7a1b4aa211264a87ef6a10713f2eaf96807eb720c27bb013a2ff">fp_regnum</a>;                   <span class="comment">/* A-register used as FP.  */</span>
<a name="l00995"></a>00995   <span class="keywordtype">int</span> c0_fp;                       <span class="comment">/* Actual value of frame pointer.  */</span>
<a name="l00996"></a>00996   <span class="keywordtype">int</span> c0_fpalign;                  <span class="comment">/* Dinamic adjustment for the stack</span>
<a name="l00997"></a>00997 <span class="comment">                                      pointer. It&#39;s an AND mask. Zero,</span>
<a name="l00998"></a>00998 <span class="comment">                                      if alignment was not adjusted.  */</span>
<a name="l00999"></a>00999   <span class="keywordtype">int</span> c0_old_sp;                   <span class="comment">/* In case of dynamic adjustment, it is</span>
<a name="l01000"></a>01000 <span class="comment">                                      a register holding unaligned sp. </span>
<a name="l01001"></a>01001 <span class="comment">                                      C0_INEXP, when undefined.  */</span>
<a name="l01002"></a>01002   <span class="keywordtype">int</span> c0_sp_ofs;                   <span class="comment">/* If &quot;c0_old_sp&quot; was spilled it&#39;s a</span>
<a name="l01003"></a>01003 <span class="comment">                                      stack offset. C0_NOSTK otherwise.  */</span>
<a name="l01004"></a>01004                                            
<a name="l01005"></a>01005   <a class="code" href="xtensa-tdep_8c.html#aa24578348135491500f62ed2af882686">xtensa_c0reg_t</a> c0_rt[<a class="code" href="xtensa-tdep_8c.html#a78bb729d39d6d29c761515a76d68eb68">C0_NREGS</a>];  <span class="comment">/* Register tracking information.  */</span>
<a name="l01006"></a>01006 } <a class="code" href="xtensa-tdep_8c.html#afd4bc85ba695597923d680799150cac2">xtensa_call0_frame_cache_t</a>;
<a name="l01007"></a>01007 
<a name="l01008"></a>01008 <span class="keyword">typedef</span> <span class="keyword">struct </span>xtensa_frame_cache
<a name="l01009"></a>01009 {
<a name="l01010"></a>01010   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> base;       <span class="comment">/* Stack pointer of this frame.  */</span>
<a name="l01011"></a>01011   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc;         <span class="comment">/* PC of this frame at the function entry point.  */</span>
<a name="l01012"></a>01012   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ra;         <span class="comment">/* The raw return address of this frame.  */</span>
<a name="l01013"></a>01013   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="namespacecleanup__check.html#a2f9ce522b7667bef19a5777d12fa44d8">ps</a>;         <span class="comment">/* The PS register of the previous (older) frame.  */</span>
<a name="l01014"></a>01014   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> prev_sp;    <span class="comment">/* Stack Pointer of the previous (older) frame.  */</span>
<a name="l01015"></a>01015   <span class="keywordtype">int</span> call0;            <span class="comment">/* It&#39;s a call0 framework (else windowed).  */</span>
<a name="l01016"></a>01016   <span class="keyword">union</span>
<a name="l01017"></a>01017     {
<a name="l01018"></a>01018       <a class="code" href="xtensa-tdep_8c.html#afb5ed802c384876593ce773d54e74dad">xtensa_windowed_frame_cache_t</a>     wd;     <span class="comment">/* call0 == false.  */</span>
<a name="l01019"></a>01019       <a class="code" href="xtensa-tdep_8c.html#afd4bc85ba695597923d680799150cac2">xtensa_call0_frame_cache_t</a>        c0;     <span class="comment">/* call0 == true.  */</span>
<a name="l01020"></a>01020     };
<a name="l01021"></a>01021 } <a class="code" href="xtensa-tdep_8c.html#ac83c68c18f462e5e2661d376bd027d3e">xtensa_frame_cache_t</a>;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023 
<a name="l01024"></a>01024 <span class="keyword">static</span> <span class="keyword">struct </span>xtensa_frame_cache *
<a name="l01025"></a>01025 xtensa_alloc_frame_cache (<span class="keywordtype">int</span> windowed)
<a name="l01026"></a>01026 {
<a name="l01027"></a>01027   <a class="code" href="xtensa-tdep_8c.html#ac83c68c18f462e5e2661d376bd027d3e">xtensa_frame_cache_t</a> *cache;
<a name="l01028"></a>01028   <span class="keywordtype">int</span> i;
<a name="l01029"></a>01029 
<a name="l01030"></a>01030   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;xtensa_alloc_frame_cache ()\n&quot;</span>);
<a name="l01031"></a>01031 
<a name="l01032"></a>01032   cache = <a class="code" href="frame_8h.html#af9f5c3008a0d58374aa310c5c63af552">FRAME_OBSTACK_ZALLOC</a> (<a class="code" href="xtensa-tdep_8c.html#ac83c68c18f462e5e2661d376bd027d3e">xtensa_frame_cache_t</a>);
<a name="l01033"></a>01033 
<a name="l01034"></a>01034   cache-&gt;base = 0;
<a name="l01035"></a>01035   cache-&gt;pc = 0;
<a name="l01036"></a>01036   cache-&gt;ra = 0;
<a name="l01037"></a>01037   cache-&gt;ps = 0;
<a name="l01038"></a>01038   cache-&gt;prev_sp = 0;
<a name="l01039"></a>01039   cache-&gt;call0 = !windowed;
<a name="l01040"></a>01040   <span class="keywordflow">if</span> (cache-&gt;call0)
<a name="l01041"></a>01041     {
<a name="l01042"></a>01042       cache-&gt;c0.c0_frmsz  = -1;
<a name="l01043"></a>01043       cache-&gt;c0.c0_hasfp  =  0;
<a name="l01044"></a>01044       cache-&gt;c0.fp_regnum = -1;
<a name="l01045"></a>01045       cache-&gt;c0.c0_fp     = -1;
<a name="l01046"></a>01046       cache-&gt;c0.c0_fpalign =  0;
<a name="l01047"></a>01047       cache-&gt;c0.c0_old_sp  =  <a class="code" href="xtensa-tdep_8c.html#a51694ea2494265ce611e70196f1e9009">C0_INEXP</a>;
<a name="l01048"></a>01048       cache-&gt;c0.c0_sp_ofs  =  <a class="code" href="xtensa-tdep_8c.html#a3e9badad6b26919da866065d6f3a3573">C0_NOSTK</a>;
<a name="l01049"></a>01049 
<a name="l01050"></a>01050       <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="xtensa-tdep_8c.html#a78bb729d39d6d29c761515a76d68eb68">C0_NREGS</a>; i++)
<a name="l01051"></a>01051         {
<a name="l01052"></a>01052           cache-&gt;c0.c0_rt[i].fr_reg = i;
<a name="l01053"></a>01053           cache-&gt;c0.c0_rt[i].fr_ofs = 0;
<a name="l01054"></a>01054           cache-&gt;c0.c0_rt[i].to_stk = <a class="code" href="xtensa-tdep_8c.html#a3e9badad6b26919da866065d6f3a3573">C0_NOSTK</a>;
<a name="l01055"></a>01055         }
<a name="l01056"></a>01056     }
<a name="l01057"></a>01057   <span class="keywordflow">else</span>
<a name="l01058"></a>01058     {
<a name="l01059"></a>01059       cache-&gt;wd.wb = 0;
<a name="l01060"></a>01060       cache-&gt;wd.ws = 0;
<a name="l01061"></a>01061       cache-&gt;wd.callsize = -1;
<a name="l01062"></a>01062 
<a name="l01063"></a>01063       <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="xtensa-tdep_8c.html#a26463eb820061ed221e4aefbc1cf0fb9">XTENSA_NUM_SAVED_AREGS</a>; i++)
<a name="l01064"></a>01064         cache-&gt;wd.aregs[i] = -1;
<a name="l01065"></a>01065     }
<a name="l01066"></a>01066   <span class="keywordflow">return</span> cache;
<a name="l01067"></a>01067 }
<a name="l01068"></a>01068 
<a name="l01069"></a>01069 
<a name="l01070"></a>01070 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01071"></a>01071 xtensa_frame_align (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> address)
<a name="l01072"></a>01072 {
<a name="l01073"></a>01073   <span class="keywordflow">return</span> address &amp; ~15;
<a name="l01074"></a>01074 }
<a name="l01075"></a>01075 
<a name="l01076"></a>01076 
<a name="l01077"></a>01077 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01078"></a>01078 xtensa_unwind_pc (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> frame_info *next_frame)
<a name="l01079"></a>01079 {
<a name="l01080"></a>01080   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> buf[8];
<a name="l01081"></a>01081   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc;
<a name="l01082"></a>01082 
<a name="l01083"></a>01083   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;xtensa_unwind_pc (next_frame = %s)\n&quot;</span>, 
<a name="l01084"></a>01084                 <a class="code" href="utils_8c.html#ac166db325056a01e8babd984f8ba2b98">host_address_to_string</a> (next_frame));
<a name="l01085"></a>01085 
<a name="l01086"></a>01086   <a class="code" href="frame_8c.html#af11d8d673027d53c4420da4895abc230">frame_unwind_register</a> (next_frame, <a class="code" href="gdbarch_8c.html#a07a162ebafea1269eb8f341db44e53e7">gdbarch_pc_regnum</a> (gdbarch), buf);
<a name="l01087"></a>01087   pc = <a class="code" href="defs_8h.html#a8a619d8cb1c6d12c6354da6e663dbd95">extract_typed_address</a> (buf, <a class="code" href="structbuiltin__type.html">builtin_type</a> (gdbarch)-&gt;builtin_func_ptr);
<a name="l01088"></a>01088 
<a name="l01089"></a>01089   <a class="code" href="xtensa-tdep_8c.html#a9720f72e59ae110cdacf653d01c305cb">DEBUGINFO</a> (<span class="stringliteral">&quot;[xtensa_unwind_pc] pc = 0x%08x\n&quot;</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) pc);
<a name="l01090"></a>01090 
<a name="l01091"></a>01091   <span class="keywordflow">return</span> pc;
<a name="l01092"></a>01092 }
<a name="l01093"></a>01093 
<a name="l01094"></a>01094 
<a name="l01095"></a>01095 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structframe__id.html">frame_id</a>
<a name="l01096"></a>01096 xtensa_dummy_id (struct gdbarch *gdbarch, <span class="keyword">struct </span>frame_info *this_frame)
<a name="l01097"></a>01097 {
<a name="l01098"></a>01098   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc, fp;
<a name="l01099"></a>01099 
<a name="l01100"></a>01100   <span class="comment">/* THIS-FRAME is a dummy frame.  Return a frame ID of that frame.  */</span>
<a name="l01101"></a>01101 
<a name="l01102"></a>01102   pc = <a class="code" href="frame_8c.html#a27aafb00e05cba145dfba0e4bc7b1d70">get_frame_pc</a> (this_frame);
<a name="l01103"></a>01103   fp = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a>
<a name="l01104"></a>01104          (this_frame, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 1);
<a name="l01105"></a>01105 
<a name="l01106"></a>01106   <span class="comment">/* Make dummy frame ID unique by adding a constant.  */</span>
<a name="l01107"></a>01107   <span class="keywordflow">return</span> <a class="code" href="frame_8c.html#a7f32da6ddc275b4684c301448d891f5b">frame_id_build</a> (fp + <a class="code" href="xtensa-tdep_8c.html#acb8b2dd04a867b883f65bdf233b9b602">SP_ALIGNMENT</a>, pc);
<a name="l01108"></a>01108 }
<a name="l01109"></a>01109 
<a name="l01110"></a>01110 <span class="comment">/* Returns true,  if instruction to execute next is unique to Xtensa Window</span>
<a name="l01111"></a>01111 <span class="comment">   Interrupt Handlers.  It can only be one of L32E,  S32E,  RFWO,  or RFWU.  */</span>
<a name="l01112"></a>01112 
<a name="l01113"></a>01113 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01114"></a>01114 xtensa_window_interrupt_insn (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc)
<a name="l01115"></a>01115 {
<a name="l01116"></a>01116   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l01117"></a>01117   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> insn = <a class="code" href="corefile_8c.html#a7097ab90f56ed7bcceb190bab139621b">read_memory_integer</a> (pc, 4, byte_order);
<a name="l01118"></a>01118   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="ser-unix_8c.html#a45a5b7c00a796a23f01673cef1dbe0a9">code</a>;
<a name="l01119"></a>01119 
<a name="l01120"></a>01120   <span class="keywordflow">if</span> (byte_order == BFD_ENDIAN_BIG)
<a name="l01121"></a>01121     {
<a name="l01122"></a>01122       <span class="comment">/* Check, if this is L32E or S32E.  */</span>
<a name="l01123"></a>01123       code = insn &amp; 0xf000ff00;
<a name="l01124"></a>01124       <span class="keywordflow">if</span> ((code == 0x00009000) || (code == 0x00009400))
<a name="l01125"></a>01125         <span class="keywordflow">return</span> 1;
<a name="l01126"></a>01126       <span class="comment">/* Check, if this is RFWU or RFWO.  */</span>
<a name="l01127"></a>01127       code = insn &amp; 0xffffff00;
<a name="l01128"></a>01128       <span class="keywordflow">return</span> ((code == 0x00430000) || (code == 0x00530000));
<a name="l01129"></a>01129     }
<a name="l01130"></a>01130   <span class="keywordflow">else</span>
<a name="l01131"></a>01131     {
<a name="l01132"></a>01132       <span class="comment">/* Check, if this is L32E or S32E.  */</span>
<a name="l01133"></a>01133       code = insn &amp; 0x00ff000f;
<a name="l01134"></a>01134       <span class="keywordflow">if</span> ((code == 0x090000) || (code == 0x490000))
<a name="l01135"></a>01135         <span class="keywordflow">return</span> 1;
<a name="l01136"></a>01136       <span class="comment">/* Check, if this is RFWU or RFWO.  */</span>
<a name="l01137"></a>01137       code = insn &amp; 0x00ffffff;
<a name="l01138"></a>01138       <span class="keywordflow">return</span> ((code == 0x00003400) || (code == 0x00003500));
<a name="l01139"></a>01139     }
<a name="l01140"></a>01140 }
<a name="l01141"></a>01141 
<a name="l01142"></a>01142 <span class="comment">/* Returns the best guess about which register is a frame pointer</span>
<a name="l01143"></a>01143 <span class="comment">   for the function containing CURRENT_PC.  */</span>
<a name="l01144"></a><a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">01144</a> 
<a name="l01145"></a><a class="code" href="xtensa-tdep_8c.html#a1f53797feed61a873a510d9732de3349">01145</a> <span class="preprocessor">#define XTENSA_ISA_BSZ          32              </span><span class="comment">/* Instruction buffer size.  */</span>
<a name="l01146"></a>01146 <span class="preprocessor">#define XTENSA_ISA_BADPC        ((CORE_ADDR)0)  </span><span class="comment">/* Bad PC value.  */</span>
<a name="l01147"></a>01147 
<a name="l01148"></a>01148 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l01149"></a>01149 xtensa_scan_prologue (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> current_pc)
<a name="l01150"></a>01150 {
<a name="l01151"></a>01151 <span class="preprocessor">#define RETURN_FP goto done</span>
<a name="l01152"></a>01152 <span class="preprocessor"></span>
<a name="l01153"></a>01153   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="frv-tdep_8h.html#ae6dceca96ec2c7a1b4aa211264a87ef6a10713f2eaf96807eb720c27bb013a2ff">fp_regnum</a> = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a> + 1;
<a name="l01154"></a>01154   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_addr;
<a name="l01155"></a>01155   xtensa_isa isa;
<a name="l01156"></a>01156   xtensa_insnbuf ins, slot;
<a name="l01157"></a>01157   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> ibuf[<a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a>];
<a name="l01158"></a>01158   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ia, bt, ba;
<a name="l01159"></a>01159   xtensa_format ifmt;
<a name="l01160"></a>01160   <span class="keywordtype">int</span> ilen, islots, is;
<a name="l01161"></a>01161   xtensa_opcode opc;
<a name="l01162"></a>01162   <span class="keyword">const</span> <span class="keywordtype">char</span> *opcname;
<a name="l01163"></a>01163 
<a name="l01164"></a>01164   <a class="code" href="blockframe_8c.html#a2dae2257ad1417604d2c26f8b9071ca9">find_pc_partial_function</a> (current_pc, NULL, &amp;start_addr, NULL);
<a name="l01165"></a>01165   <span class="keywordflow">if</span> (start_addr == 0)
<a name="l01166"></a>01166     <span class="keywordflow">return</span> <a class="code" href="frv-tdep_8h.html#ae6dceca96ec2c7a1b4aa211264a87ef6a10713f2eaf96807eb720c27bb013a2ff">fp_regnum</a>;
<a name="l01167"></a>01167 
<a name="l01168"></a>01168   <span class="keywordflow">if</span> (!xtensa_default_isa)
<a name="l01169"></a>01169     xtensa_default_isa = xtensa_isa_init (0, 0);
<a name="l01170"></a>01170   isa = xtensa_default_isa;
<a name="l01171"></a>01171   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a> &gt;= xtensa_isa_maxlength (isa));
<a name="l01172"></a>01172   ins = xtensa_insnbuf_alloc (isa);
<a name="l01173"></a>01173   slot = xtensa_insnbuf_alloc (isa);
<a name="l01174"></a>01174   ba = 0;
<a name="l01175"></a>01175 
<a name="l01176"></a>01176   <span class="keywordflow">for</span> (ia = start_addr, bt = ia; ia &lt; current_pc ; ia += ilen)
<a name="l01177"></a>01177     {
<a name="l01178"></a>01178       <span class="keywordflow">if</span> (ia + xtensa_isa_maxlength (isa) &gt; bt)
<a name="l01179"></a>01179         {
<a name="l01180"></a>01180           ba = ia;
<a name="l01181"></a>01181           bt = (ba + <a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a>) &lt; current_pc
<a name="l01182"></a>01182             ? ba + <a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a> : current_pc;
<a name="l01183"></a>01183           <span class="keywordflow">if</span> (<a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (ba, ibuf, bt - ba) != 0)
<a name="l01184"></a>01184             <a class="code" href="xtensa-tdep_8c.html#a31c2f9f85dddba281732689b0a55ba75">RETURN_FP</a>;
<a name="l01185"></a>01185         }
<a name="l01186"></a>01186 
<a name="l01187"></a>01187       xtensa_insnbuf_from_chars (isa, ins, &amp;ibuf[ia-ba], 0);
<a name="l01188"></a>01188       ifmt = xtensa_format_decode (isa, ins);
<a name="l01189"></a>01189       <span class="keywordflow">if</span> (ifmt == XTENSA_UNDEFINED)
<a name="l01190"></a>01190         <a class="code" href="xtensa-tdep_8c.html#a31c2f9f85dddba281732689b0a55ba75">RETURN_FP</a>;
<a name="l01191"></a>01191       ilen = xtensa_format_length (isa, ifmt);
<a name="l01192"></a>01192       <span class="keywordflow">if</span> (ilen == XTENSA_UNDEFINED)
<a name="l01193"></a>01193         <a class="code" href="xtensa-tdep_8c.html#a31c2f9f85dddba281732689b0a55ba75">RETURN_FP</a>;
<a name="l01194"></a>01194       islots = xtensa_format_num_slots (isa, ifmt);
<a name="l01195"></a>01195       <span class="keywordflow">if</span> (islots == XTENSA_UNDEFINED)
<a name="l01196"></a>01196         <a class="code" href="xtensa-tdep_8c.html#a31c2f9f85dddba281732689b0a55ba75">RETURN_FP</a>;
<a name="l01197"></a>01197       
<a name="l01198"></a>01198       <span class="keywordflow">for</span> (is = 0; is &lt; islots; ++is)
<a name="l01199"></a>01199         {
<a name="l01200"></a>01200           <span class="keywordflow">if</span> (xtensa_format_get_slot (isa, ifmt, is, ins, slot))
<a name="l01201"></a>01201             <a class="code" href="xtensa-tdep_8c.html#a31c2f9f85dddba281732689b0a55ba75">RETURN_FP</a>;
<a name="l01202"></a>01202           
<a name="l01203"></a>01203           opc = xtensa_opcode_decode (isa, ifmt, is, slot);
<a name="l01204"></a>01204           <span class="keywordflow">if</span> (opc == XTENSA_UNDEFINED) 
<a name="l01205"></a>01205             <a class="code" href="xtensa-tdep_8c.html#a31c2f9f85dddba281732689b0a55ba75">RETURN_FP</a>;
<a name="l01206"></a>01206           
<a name="l01207"></a>01207           opcname = xtensa_opcode_name (isa, opc);
<a name="l01208"></a>01208 
<a name="l01209"></a>01209           <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;mov.n&quot;</span>) == 0
<a name="l01210"></a>01210               || strcasecmp (opcname, <span class="stringliteral">&quot;or&quot;</span>) == 0)
<a name="l01211"></a>01211             {
<a name="l01212"></a>01212               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> register_operand;
<a name="l01213"></a>01213 
<a name="l01214"></a>01214               <span class="comment">/* Possible candidate for setting frame pointer</span>
<a name="l01215"></a>01215 <span class="comment">                 from A1.  This is what we are looking for.  */</span>
<a name="l01216"></a>01216 
<a name="l01217"></a>01217               <span class="keywordflow">if</span> (xtensa_operand_get_field (isa, opc, 1, ifmt, 
<a name="l01218"></a>01218                                             is, slot, &amp;register_operand) != 0)
<a name="l01219"></a>01219                 <a class="code" href="xtensa-tdep_8c.html#a31c2f9f85dddba281732689b0a55ba75">RETURN_FP</a>;
<a name="l01220"></a>01220               <span class="keywordflow">if</span> (xtensa_operand_decode (isa, opc, 1, &amp;register_operand) != 0)
<a name="l01221"></a>01221                 <a class="code" href="xtensa-tdep_8c.html#a31c2f9f85dddba281732689b0a55ba75">RETURN_FP</a>;
<a name="l01222"></a>01222               <span class="keywordflow">if</span> (register_operand == 1)  <span class="comment">/* Mov{.n} FP A1.  */</span>
<a name="l01223"></a>01223                 {
<a name="l01224"></a>01224                   <span class="keywordflow">if</span> (xtensa_operand_get_field (isa, opc, 0, ifmt, is, slot, 
<a name="l01225"></a>01225                                                 &amp;register_operand) != 0)
<a name="l01226"></a>01226                     <a class="code" href="xtensa-tdep_8c.html#a31c2f9f85dddba281732689b0a55ba75">RETURN_FP</a>;
<a name="l01227"></a>01227                   <span class="keywordflow">if</span> (xtensa_operand_decode (isa, opc, 0,
<a name="l01228"></a>01228                                              &amp;register_operand) != 0)
<a name="l01229"></a>01229                     <a class="code" href="xtensa-tdep_8c.html#a31c2f9f85dddba281732689b0a55ba75">RETURN_FP</a>;
<a name="l01230"></a>01230 
<a name="l01231"></a>01231                   fp_regnum
<a name="l01232"></a>01232                     = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a> + register_operand;
<a name="l01233"></a>01233                   <a class="code" href="xtensa-tdep_8c.html#a31c2f9f85dddba281732689b0a55ba75">RETURN_FP</a>;
<a name="l01234"></a>01234                 }
<a name="l01235"></a>01235             }
<a name="l01236"></a>01236 
<a name="l01237"></a>01237           <span class="keywordflow">if</span> (
<a name="l01238"></a>01238               <span class="comment">/* We have problems decoding the memory.  */</span>
<a name="l01239"></a>01239               opcname == NULL 
<a name="l01240"></a>01240               || strcasecmp (opcname, <span class="stringliteral">&quot;ill&quot;</span>) == 0
<a name="l01241"></a>01241               || strcasecmp (opcname, <span class="stringliteral">&quot;ill.n&quot;</span>) == 0
<a name="l01242"></a>01242               <span class="comment">/* Hit planted breakpoint.  */</span>
<a name="l01243"></a>01243               || strcasecmp (opcname, <span class="stringliteral">&quot;break&quot;</span>) == 0
<a name="l01244"></a>01244               || strcasecmp (opcname, <span class="stringliteral">&quot;break.n&quot;</span>) == 0
<a name="l01245"></a>01245               <span class="comment">/* Flow control instructions finish prologue.  */</span>
<a name="l01246"></a>01246               || xtensa_opcode_is_branch (isa, opc) &gt; 0
<a name="l01247"></a>01247               || xtensa_opcode_is_jump   (isa, opc) &gt; 0
<a name="l01248"></a>01248               || xtensa_opcode_is_loop   (isa, opc) &gt; 0
<a name="l01249"></a>01249               || xtensa_opcode_is_call   (isa, opc) &gt; 0
<a name="l01250"></a>01250               || strcasecmp (opcname, <span class="stringliteral">&quot;simcall&quot;</span>) == 0
<a name="l01251"></a>01251               || strcasecmp (opcname, <span class="stringliteral">&quot;syscall&quot;</span>) == 0)
<a name="l01252"></a>01252             <span class="comment">/* Can not continue analysis.  */</span>
<a name="l01253"></a>01253             <a class="code" href="xtensa-tdep_8c.html#a31c2f9f85dddba281732689b0a55ba75">RETURN_FP</a>;
<a name="l01254"></a>01254         }
<a name="l01255"></a>01255     }
<a name="l01256"></a>01256 done:
<a name="l01257"></a>01257   xtensa_insnbuf_free(isa, slot);
<a name="l01258"></a>01258   xtensa_insnbuf_free(isa, ins);
<a name="l01259"></a>01259   <span class="keywordflow">return</span> <a class="code" href="frv-tdep_8h.html#ae6dceca96ec2c7a1b4aa211264a87ef6a10713f2eaf96807eb720c27bb013a2ff">fp_regnum</a>;
<a name="l01260"></a>01260 }
<a name="l01261"></a>01261 
<a name="l01262"></a>01262 <span class="comment">/* The key values to identify the frame using &quot;cache&quot; are </span>
<a name="l01263"></a>01263 <span class="comment"></span>
<a name="l01264"></a>01264 <span class="comment">        cache-&gt;base    = SP (or best guess about FP) of this frame;</span>
<a name="l01265"></a>01265 <span class="comment">        cache-&gt;pc      = entry-PC (entry point of the frame function);</span>
<a name="l01266"></a>01266 <span class="comment">        cache-&gt;prev_sp = SP of the previous frame.  */</span>
<a name="l01267"></a>01267 
<a name="l01268"></a>01268 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01269"></a>01269 call0_frame_cache (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01270"></a>01270                    <a class="code" href="xtensa-tdep_8c.html#ac83c68c18f462e5e2661d376bd027d3e">xtensa_frame_cache_t</a> *cache, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc);
<a name="l01271"></a>01271 
<a name="l01272"></a>01272 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01273"></a>01273 xtensa_window_interrupt_frame_cache (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01274"></a>01274                                      <a class="code" href="xtensa-tdep_8c.html#ac83c68c18f462e5e2661d376bd027d3e">xtensa_frame_cache_t</a> *cache,
<a name="l01275"></a>01275                                      <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc);
<a name="l01276"></a>01276 
<a name="l01277"></a>01277 <span class="keyword">static</span> <span class="keyword">struct </span>xtensa_frame_cache *
<a name="l01278"></a>01278 xtensa_frame_cache (<span class="keyword">struct</span> frame_info *this_frame, <span class="keywordtype">void</span> **this_cache)
<a name="l01279"></a>01279 {
<a name="l01280"></a>01280   <a class="code" href="xtensa-tdep_8c.html#ac83c68c18f462e5e2661d376bd027d3e">xtensa_frame_cache_t</a> *cache;
<a name="l01281"></a>01281   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ra, wb, ws, pc, <a class="code" href="windows-nat_8c.html#a8d40798874dab99986478ef00ff3e297">sp</a>, <a class="code" href="namespacecleanup__check.html#a2f9ce522b7667bef19a5777d12fa44d8">ps</a>;
<a name="l01282"></a>01282   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame);
<a name="l01283"></a>01283   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l01284"></a>01284   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="frv-tdep_8h.html#ae6dceca96ec2c7a1b4aa211264a87ef6a10713f2eaf96807eb720c27bb013a2ff">fp_regnum</a>;
<a name="l01285"></a>01285   <span class="keywordtype">int</span>  windowed, ps_regnum;
<a name="l01286"></a>01286 
<a name="l01287"></a>01287   <span class="keywordflow">if</span> (*this_cache)
<a name="l01288"></a>01288     <span class="keywordflow">return</span> *this_cache;
<a name="l01289"></a>01289 
<a name="l01290"></a>01290   pc = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, <a class="code" href="gdbarch_8c.html#a07a162ebafea1269eb8f341db44e53e7">gdbarch_pc_regnum</a> (gdbarch));
<a name="l01291"></a>01291   ps_regnum = <a class="code" href="gdbarch_8c.html#aa0e316e2d110495a985d9f566df348c3">gdbarch_ps_regnum</a> (gdbarch);
<a name="l01292"></a>01292   ps = (ps_regnum &gt;= 0
<a name="l01293"></a>01293         ? <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, ps_regnum) : <a class="code" href="xtensa-tdep_8c.html#a2bdfbd058994cb622a57096c3080d862">TX_PS</a>);
<a name="l01294"></a>01294 
<a name="l01295"></a>01295   windowed = windowing_enabled (gdbarch, ps);
<a name="l01296"></a>01296 
<a name="l01297"></a>01297   <span class="comment">/* Get pristine xtensa-frame.  */</span>
<a name="l01298"></a>01298   cache = xtensa_alloc_frame_cache (windowed);
<a name="l01299"></a>01299   *this_cache = cache;
<a name="l01300"></a>01300 
<a name="l01301"></a>01301   <span class="keywordflow">if</span> (windowed)
<a name="l01302"></a>01302     {
<a name="l01303"></a>01303       <span class="keywordtype">char</span> op1;
<a name="l01304"></a>01304 
<a name="l01305"></a>01305       <span class="comment">/* Get WINDOWBASE, WINDOWSTART, and PS registers.  */</span>
<a name="l01306"></a>01306       wb = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, 
<a name="l01307"></a>01307                                         <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;wb_regnum);
<a name="l01308"></a>01308       ws = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame,
<a name="l01309"></a>01309                                         <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;ws_regnum);
<a name="l01310"></a>01310 
<a name="l01311"></a>01311       op1 = <a class="code" href="corefile_8c.html#a7097ab90f56ed7bcceb190bab139621b">read_memory_integer</a> (pc, 1, byte_order);
<a name="l01312"></a>01312       <span class="keywordflow">if</span> (<a class="code" href="xtensa-tdep_8c.html#ac609afa31c32b6930458597eeac45022">XTENSA_IS_ENTRY</a> (gdbarch, op1))
<a name="l01313"></a>01313         {
<a name="l01314"></a>01314           <span class="keywordtype">int</span> callinc = <a class="code" href="xtensa-tdep_8c.html#a65bc09f1f02ffcf0cf1d239595adb769">CALLINC</a> (ps);
<a name="l01315"></a>01315           ra = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a>
<a name="l01316"></a>01316             (this_frame, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + callinc * 4);
<a name="l01317"></a>01317           
<a name="l01318"></a>01318           <span class="comment">/* ENTRY hasn&#39;t been executed yet, therefore callsize is still 0.  */</span>
<a name="l01319"></a>01319           cache-&gt;wd.callsize = 0;
<a name="l01320"></a>01320           cache-&gt;wd.wb = wb;
<a name="l01321"></a>01321           cache-&gt;wd.ws = ws;
<a name="l01322"></a>01322           cache-&gt;prev_sp = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a>
<a name="l01323"></a>01323                              (this_frame, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 1);
<a name="l01324"></a>01324 
<a name="l01325"></a>01325           <span class="comment">/* This only can be the outermost frame since we are</span>
<a name="l01326"></a>01326 <span class="comment">             just about to execute ENTRY.  SP hasn&#39;t been set yet.</span>
<a name="l01327"></a>01327 <span class="comment">             We can assume any frame size, because it does not</span>
<a name="l01328"></a>01328 <span class="comment">             matter, and, let&#39;s fake frame base in cache.  */</span>
<a name="l01329"></a>01329           cache-&gt;base = cache-&gt;prev_sp - 16;
<a name="l01330"></a>01330 
<a name="l01331"></a>01331           cache-&gt;pc = pc;
<a name="l01332"></a>01332           cache-&gt;ra = (cache-&gt;pc &amp; 0xc0000000) | (ra &amp; 0x3fffffff);
<a name="l01333"></a>01333           cache-&gt;ps = (ps &amp; ~<a class="code" href="xtensa-tdep_8c.html#ada609dee644016a6a0e7b5845c6d2b83">PS_CALLINC_MASK</a>)
<a name="l01334"></a>01334             | ((<a class="code" href="xtensa-tdep_8c.html#ab5b0d0abf0586f7a99e090450d41f8ef">WINSIZE</a>(ra)/4) &lt;&lt; <a class="code" href="xtensa-tdep_8c.html#a736852d6227dd569a6afbc983e4c3aa7">PS_CALLINC_SHIFT</a>);
<a name="l01335"></a>01335 
<a name="l01336"></a>01336           <span class="keywordflow">return</span> cache;
<a name="l01337"></a>01337         }
<a name="l01338"></a>01338       <span class="keywordflow">else</span>
<a name="l01339"></a>01339         {
<a name="l01340"></a>01340           fp_regnum = xtensa_scan_prologue (gdbarch, pc);
<a name="l01341"></a>01341           ra = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame,
<a name="l01342"></a>01342                                             <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base);
<a name="l01343"></a>01343           cache-&gt;wd.callsize = <a class="code" href="xtensa-tdep_8c.html#ab5b0d0abf0586f7a99e090450d41f8ef">WINSIZE</a> (ra);
<a name="l01344"></a>01344           cache-&gt;wd.wb = (wb - cache-&gt;wd.callsize / 4)
<a name="l01345"></a>01345                           &amp; (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a4f769a0e5c51524a59b35f0841991552">num_aregs</a> / 4 - 1);
<a name="l01346"></a>01346           cache-&gt;wd.ws = ws &amp; ~(1 &lt;&lt; wb);
<a name="l01347"></a>01347 
<a name="l01348"></a>01348           cache-&gt;pc = <a class="code" href="frame_8c.html#ac64c0ce600cc134b2256c0d507f57cde">get_frame_func</a> (this_frame);
<a name="l01349"></a>01349           cache-&gt;ra = (pc &amp; 0xc0000000) | (ra &amp; 0x3fffffff);
<a name="l01350"></a>01350           cache-&gt;ps = (ps &amp; ~<a class="code" href="xtensa-tdep_8c.html#ada609dee644016a6a0e7b5845c6d2b83">PS_CALLINC_MASK</a>)
<a name="l01351"></a>01351             | ((<a class="code" href="xtensa-tdep_8c.html#ab5b0d0abf0586f7a99e090450d41f8ef">WINSIZE</a>(ra)/4) &lt;&lt; <a class="code" href="xtensa-tdep_8c.html#a736852d6227dd569a6afbc983e4c3aa7">PS_CALLINC_SHIFT</a>);
<a name="l01352"></a>01352         }
<a name="l01353"></a>01353 
<a name="l01354"></a>01354       <span class="keywordflow">if</span> (cache-&gt;wd.ws == 0)
<a name="l01355"></a>01355         {
<a name="l01356"></a>01356           <span class="keywordtype">int</span> i;
<a name="l01357"></a>01357 
<a name="l01358"></a>01358           <span class="comment">/* Set A0...A3.  */</span>
<a name="l01359"></a>01359           sp = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a>
<a name="l01360"></a>01360             (this_frame, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 1) - 16;
<a name="l01361"></a>01361           
<a name="l01362"></a>01362           <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++, sp += 4)
<a name="l01363"></a>01363             {
<a name="l01364"></a>01364               cache-&gt;wd.aregs[i] = sp;
<a name="l01365"></a>01365             }
<a name="l01366"></a>01366 
<a name="l01367"></a>01367           <span class="keywordflow">if</span> (cache-&gt;wd.callsize &gt; 4)
<a name="l01368"></a>01368             {
<a name="l01369"></a>01369               <span class="comment">/* Set A4...A7/A11.  */</span>
<a name="l01370"></a>01370               <span class="comment">/* Get the SP of the frame previous to the previous one.</span>
<a name="l01371"></a>01371 <span class="comment">                 To achieve this, we have to dereference SP twice.  */</span>
<a name="l01372"></a>01372               sp = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) <a class="code" href="corefile_8c.html#a7097ab90f56ed7bcceb190bab139621b">read_memory_integer</a> (sp - 12, 4, byte_order);
<a name="l01373"></a>01373               sp = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) <a class="code" href="corefile_8c.html#a7097ab90f56ed7bcceb190bab139621b">read_memory_integer</a> (sp - 12, 4, byte_order);
<a name="l01374"></a>01374               sp -= cache-&gt;wd.callsize * 4;
<a name="l01375"></a>01375 
<a name="l01376"></a>01376               <span class="keywordflow">for</span> ( i = 4; i &lt; cache-&gt;wd.callsize; i++, sp += 4)
<a name="l01377"></a>01377                 {
<a name="l01378"></a>01378                   cache-&gt;wd.aregs[i] = sp;
<a name="l01379"></a>01379                 }
<a name="l01380"></a>01380             }
<a name="l01381"></a>01381         }
<a name="l01382"></a>01382 
<a name="l01383"></a>01383       <span class="keywordflow">if</span> ((cache-&gt;prev_sp == 0) &amp;&amp; ( ra != 0 ))
<a name="l01384"></a>01384         <span class="comment">/* If RA is equal to 0 this frame is an outermost frame.  Leave</span>
<a name="l01385"></a>01385 <span class="comment">           cache-&gt;prev_sp unchanged marking the boundary of the frame stack.  */</span>
<a name="l01386"></a>01386         {
<a name="l01387"></a>01387           <span class="keywordflow">if</span> ((cache-&gt;wd.ws &amp; (1 &lt;&lt; cache-&gt;wd.wb)) == 0)
<a name="l01388"></a>01388             {
<a name="l01389"></a>01389               <span class="comment">/* Register window overflow already happened.</span>
<a name="l01390"></a>01390 <span class="comment">                 We can read caller&#39;s SP from the proper spill loction.  */</span>
<a name="l01391"></a>01391               sp = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a>
<a name="l01392"></a>01392                 (this_frame, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 1);
<a name="l01393"></a>01393               cache-&gt;prev_sp = <a class="code" href="corefile_8c.html#a7097ab90f56ed7bcceb190bab139621b">read_memory_integer</a> (sp - 12, 4, byte_order);
<a name="l01394"></a>01394             }
<a name="l01395"></a>01395           <span class="keywordflow">else</span>
<a name="l01396"></a>01396             {
<a name="l01397"></a>01397               <span class="comment">/* Read caller&#39;s frame SP directly from the previous window.  */</span>
<a name="l01398"></a>01398               <span class="keywordtype">int</span> regnum = arreg_number
<a name="l01399"></a>01399                              (gdbarch, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 1,
<a name="l01400"></a>01400                               cache-&gt;wd.wb);
<a name="l01401"></a>01401 
<a name="l01402"></a>01402               cache-&gt;prev_sp = xtensa_read_register (regnum);
<a name="l01403"></a>01403             }
<a name="l01404"></a>01404         }
<a name="l01405"></a>01405     }
<a name="l01406"></a>01406   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (xtensa_window_interrupt_insn (gdbarch, pc))
<a name="l01407"></a>01407     {
<a name="l01408"></a>01408       <span class="comment">/* Execution stopped inside Xtensa Window Interrupt Handler.  */</span>
<a name="l01409"></a>01409 
<a name="l01410"></a>01410       xtensa_window_interrupt_frame_cache (this_frame, cache, pc);
<a name="l01411"></a>01411       <span class="comment">/* Everything was set already,  including cache-&gt;base.  */</span>
<a name="l01412"></a>01412       <span class="keywordflow">return</span> cache;
<a name="l01413"></a>01413     }
<a name="l01414"></a>01414   <span class="keywordflow">else</span>  <span class="comment">/* Call0 framework.  */</span>
<a name="l01415"></a>01415     {
<a name="l01416"></a>01416       call0_frame_cache (this_frame, cache, pc);  
<a name="l01417"></a>01417       fp_regnum = cache-&gt;c0.fp_regnum;
<a name="l01418"></a>01418     }
<a name="l01419"></a>01419 
<a name="l01420"></a>01420   cache-&gt;base = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, fp_regnum);
<a name="l01421"></a>01421 
<a name="l01422"></a>01422   <span class="keywordflow">return</span> cache;
<a name="l01423"></a>01423 }
<a name="l01424"></a>01424 
<a name="l01425"></a>01425 <span class="keyword">static</span> <span class="keywordtype">int</span> xtensa_session_once_reported = 1;
<a name="l01426"></a>01426 
<a name="l01427"></a>01427 <span class="comment">/* Report a problem with prologue analysis while doing backtracing.</span>
<a name="l01428"></a>01428 <span class="comment">   But, do it only once to avoid annoyng repeated messages.  */</span>
<a name="l01429"></a>01429 
<a name="l01430"></a>01430 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01431"></a>01431 warning_once (<span class="keywordtype">void</span>)
<a name="l01432"></a>01432 {
<a name="l01433"></a>01433   <span class="keywordflow">if</span> (xtensa_session_once_reported == 0)
<a name="l01434"></a>01434     <a class="code" href="utils_8c.html#a5fc201a4181499a6b4057a6caa15b5e2">warning</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l01435"></a>01435 <span class="stringliteral">\nUnrecognised function prologue. Stack trace cannot be resolved. \</span>
<a name="l01436"></a>01436 <span class="stringliteral">This message will not be repeated in this session.\n&quot;</span>));
<a name="l01437"></a>01437 
<a name="l01438"></a>01438   xtensa_session_once_reported = 1;
<a name="l01439"></a>01439 }
<a name="l01440"></a>01440 
<a name="l01441"></a>01441 
<a name="l01442"></a>01442 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01443"></a>01443 xtensa_frame_this_id (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01444"></a>01444                       <span class="keywordtype">void</span> **this_cache,
<a name="l01445"></a>01445                       <span class="keyword">struct</span> <a class="code" href="structframe__id.html">frame_id</a> *this_id)
<a name="l01446"></a>01446 {
<a name="l01447"></a>01447   <span class="keyword">struct </span>xtensa_frame_cache *cache =
<a name="l01448"></a>01448     xtensa_frame_cache (this_frame, this_cache);
<a name="l01449"></a>01449 
<a name="l01450"></a>01450   <span class="keywordflow">if</span> (cache-&gt;prev_sp == 0)
<a name="l01451"></a>01451     <span class="keywordflow">return</span>;
<a name="l01452"></a>01452 
<a name="l01453"></a>01453   (*this_id) = <a class="code" href="frame_8c.html#a7f32da6ddc275b4684c301448d891f5b">frame_id_build</a> (cache-&gt;prev_sp, cache-&gt;pc);
<a name="l01454"></a>01454 }
<a name="l01455"></a>01455 
<a name="l01456"></a>01456 <span class="keyword">static</span> <span class="keyword">struct </span>value *
<a name="l01457"></a>01457 xtensa_frame_prev_register (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l01458"></a>01458                             <span class="keywordtype">void</span> **this_cache,
<a name="l01459"></a>01459                             <span class="keywordtype">int</span> regnum)
<a name="l01460"></a>01460 {
<a name="l01461"></a>01461   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame);
<a name="l01462"></a>01462   <span class="keyword">struct </span>xtensa_frame_cache *cache;
<a name="l01463"></a>01463   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> saved_reg = 0;
<a name="l01464"></a>01464   <span class="keywordtype">int</span> done = 1;
<a name="l01465"></a>01465 
<a name="l01466"></a>01466   <span class="keywordflow">if</span> (*this_cache == NULL)
<a name="l01467"></a>01467     *this_cache = xtensa_frame_cache (this_frame, this_cache);
<a name="l01468"></a>01468   cache = *this_cache;
<a name="l01469"></a>01469 
<a name="l01470"></a>01470   <span class="keywordflow">if</span> (regnum ==<a class="code" href="gdbarch_8c.html#a07a162ebafea1269eb8f341db44e53e7">gdbarch_pc_regnum</a> (gdbarch))
<a name="l01471"></a>01471     saved_reg = cache-&gt;ra;
<a name="l01472"></a>01472   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (regnum == <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 1)
<a name="l01473"></a>01473     saved_reg = cache-&gt;prev_sp;
<a name="l01474"></a>01474   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!cache-&gt;call0)
<a name="l01475"></a>01475     {
<a name="l01476"></a>01476       <span class="keywordflow">if</span> (regnum == <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;ws_regnum)
<a name="l01477"></a>01477         saved_reg = cache-&gt;wd.ws;
<a name="l01478"></a>01478       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (regnum == <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;wb_regnum)
<a name="l01479"></a>01479         saved_reg = cache-&gt;wd.wb;
<a name="l01480"></a>01480       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (regnum == <a class="code" href="gdbarch_8c.html#aa0e316e2d110495a985d9f566df348c3">gdbarch_ps_regnum</a> (gdbarch))
<a name="l01481"></a>01481         saved_reg = cache-&gt;ps;
<a name="l01482"></a>01482       <span class="keywordflow">else</span>
<a name="l01483"></a>01483         done = 0;
<a name="l01484"></a>01484     }
<a name="l01485"></a>01485   <span class="keywordflow">else</span>
<a name="l01486"></a>01486     done = 0;
<a name="l01487"></a>01487 
<a name="l01488"></a>01488   <span class="keywordflow">if</span> (done)
<a name="l01489"></a>01489     <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#ac7df103c9cdd8847accaa5752e4f52ea">frame_unwind_got_constant</a> (this_frame, regnum, saved_reg);
<a name="l01490"></a>01490 
<a name="l01491"></a>01491   <span class="keywordflow">if</span> (!cache-&gt;call0) <span class="comment">/* Windowed ABI.  */</span>
<a name="l01492"></a>01492     {
<a name="l01493"></a>01493       <span class="comment">/* Convert A-register numbers to AR-register numbers,</span>
<a name="l01494"></a>01494 <span class="comment">         if we deal with A-register.  */</span>
<a name="l01495"></a>01495       <span class="keywordflow">if</span> (regnum &gt;= <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base
<a name="l01496"></a>01496           &amp;&amp; regnum &lt;= <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 15)
<a name="l01497"></a>01497         regnum = arreg_number (gdbarch, regnum, cache-&gt;wd.wb);
<a name="l01498"></a>01498 
<a name="l01499"></a>01499       <span class="comment">/* Check, if we deal with AR-register saved on stack.  */</span>
<a name="l01500"></a>01500       <span class="keywordflow">if</span> (regnum &gt;= <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;ar_base
<a name="l01501"></a>01501           &amp;&amp; regnum &lt;= (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;ar_base
<a name="l01502"></a>01502                          + <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;num_aregs))
<a name="l01503"></a>01503         {
<a name="l01504"></a>01504           <span class="keywordtype">int</span> areg = areg_number (gdbarch, regnum, cache-&gt;wd.wb);
<a name="l01505"></a>01505 
<a name="l01506"></a>01506           <span class="keywordflow">if</span> (areg &gt;= 0
<a name="l01507"></a>01507               &amp;&amp; areg &lt; <a class="code" href="xtensa-tdep_8c.html#a26463eb820061ed221e4aefbc1cf0fb9">XTENSA_NUM_SAVED_AREGS</a>
<a name="l01508"></a>01508               &amp;&amp; cache-&gt;wd.aregs[areg] != -1)
<a name="l01509"></a>01509             <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#ae7eed0715ca9ef71b626f80e3f026be9">frame_unwind_got_memory</a> (this_frame, regnum,
<a name="l01510"></a>01510                                             cache-&gt;wd.aregs[areg]);
<a name="l01511"></a>01511         }
<a name="l01512"></a>01512     }
<a name="l01513"></a>01513   <span class="keywordflow">else</span> <span class="comment">/* Call0 ABI.  */</span>
<a name="l01514"></a>01514     {
<a name="l01515"></a>01515       <span class="keywordtype">int</span> reg = (regnum &gt;= <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a73432cf260ddfd1984970794410c0b59">ar_base</a>
<a name="l01516"></a>01516                 &amp;&amp; regnum &lt;= (<a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a73432cf260ddfd1984970794410c0b59">ar_base</a>
<a name="l01517"></a>01517                                + <a class="code" href="xtensa-tdep_8c.html#a78bb729d39d6d29c761515a76d68eb68">C0_NREGS</a>))
<a name="l01518"></a>01518                   ? regnum - <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a73432cf260ddfd1984970794410c0b59">ar_base</a> : <a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>;
<a name="l01519"></a>01519 
<a name="l01520"></a>01520       <span class="keywordflow">if</span> (reg &lt; <a class="code" href="xtensa-tdep_8c.html#a78bb729d39d6d29c761515a76d68eb68">C0_NREGS</a>)
<a name="l01521"></a>01521         {
<a name="l01522"></a>01522           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> spe;
<a name="l01523"></a>01523           <span class="keywordtype">int</span> stkofs;
<a name="l01524"></a>01524 
<a name="l01525"></a>01525           <span class="comment">/* If register was saved in the prologue, retrieve it.  */</span>
<a name="l01526"></a>01526           stkofs = cache-&gt;c0.c0_rt[reg].to_stk;
<a name="l01527"></a>01527           <span class="keywordflow">if</span> (stkofs != <a class="code" href="xtensa-tdep_8c.html#a3e9badad6b26919da866065d6f3a3573">C0_NOSTK</a>)
<a name="l01528"></a>01528             {
<a name="l01529"></a>01529               <span class="comment">/* Determine SP on entry based on FP.  */</span>
<a name="l01530"></a>01530               spe = cache-&gt;c0.c0_fp
<a name="l01531"></a>01531                 - cache-&gt;c0.c0_rt[cache-&gt;c0.fp_regnum].fr_ofs;
<a name="l01532"></a>01532 
<a name="l01533"></a>01533               <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#ae7eed0715ca9ef71b626f80e3f026be9">frame_unwind_got_memory</a> (this_frame, regnum,
<a name="l01534"></a>01534                                               spe + stkofs);
<a name="l01535"></a>01535             }
<a name="l01536"></a>01536         }
<a name="l01537"></a>01537     }
<a name="l01538"></a>01538 
<a name="l01539"></a>01539   <span class="comment">/* All other registers have been either saved to</span>
<a name="l01540"></a>01540 <span class="comment">     the stack or are still alive in the processor.  */</span>
<a name="l01541"></a>01541 
<a name="l01542"></a>01542   <span class="keywordflow">return</span> <a class="code" href="frame-unwind_8c.html#a07784a5660795d4ca4bb82e05e0bc4f5">frame_unwind_got_register</a> (this_frame, regnum, regnum);
<a name="l01543"></a>01543 }
<a name="l01544"></a>01544 
<a name="l01545"></a>01545 
<a name="l01546"></a>01546 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structframe__unwind.html">frame_unwind</a>
<a name="l01547"></a>01547 xtensa_unwind =
<a name="l01548"></a>01548 {
<a name="l01549"></a>01549   <a class="code" href="frame_8h.html#a3ca2c0bc7578bf3d337e34b2c08a6c5faeb4f7fd6d9e397d1141feb133746637a">NORMAL_FRAME</a>,
<a name="l01550"></a>01550   <a class="code" href="frame-unwind_8c.html#aa950afe60921514574c6150f0821f05c">default_frame_unwind_stop_reason</a>,
<a name="l01551"></a>01551   xtensa_frame_this_id,
<a name="l01552"></a>01552   xtensa_frame_prev_register,
<a name="l01553"></a>01553   NULL,
<a name="l01554"></a>01554   <a class="code" href="frame-unwind_8c.html#ade64a9807fa508622581cc779b10ff9c">default_frame_sniffer</a>
<a name="l01555"></a>01555 };
<a name="l01556"></a>01556 
<a name="l01557"></a>01557 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01558"></a>01558 xtensa_frame_base_address (<span class="keyword">struct</span> frame_info *this_frame, <span class="keywordtype">void</span> **this_cache)
<a name="l01559"></a>01559 {
<a name="l01560"></a>01560   <span class="keyword">struct </span>xtensa_frame_cache *cache =
<a name="l01561"></a>01561     xtensa_frame_cache (this_frame, this_cache);
<a name="l01562"></a>01562 
<a name="l01563"></a>01563   <span class="keywordflow">return</span> cache-&gt;base;
<a name="l01564"></a>01564 }
<a name="l01565"></a>01565 
<a name="l01566"></a>01566 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structframe__base.html">frame_base</a>
<a name="l01567"></a>01567 xtensa_frame_base =
<a name="l01568"></a>01568 {
<a name="l01569"></a>01569   &amp;xtensa_unwind,
<a name="l01570"></a>01570   xtensa_frame_base_address,
<a name="l01571"></a>01571   xtensa_frame_base_address,
<a name="l01572"></a>01572   xtensa_frame_base_address
<a name="l01573"></a>01573 };
<a name="l01574"></a>01574 
<a name="l01575"></a>01575 
<a name="l01576"></a>01576 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01577"></a>01577 xtensa_extract_return_value (<span class="keyword">struct</span> type *type,
<a name="l01578"></a>01578                              <span class="keyword">struct</span> regcache *regcache,
<a name="l01579"></a>01579                              <span class="keywordtype">void</span> *dst)
<a name="l01580"></a>01580 {
<a name="l01581"></a>01581   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="regcache_8c.html#ad4f6d0cdf256b1fa45d59a6d71b50659">get_regcache_arch</a> (regcache);
<a name="l01582"></a>01582   bfd_byte *valbuf = dst;
<a name="l01583"></a>01583   <span class="keywordtype">int</span> len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type);
<a name="l01584"></a>01584   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> pc, wb;
<a name="l01585"></a>01585   <span class="keywordtype">int</span> callsize, areg;
<a name="l01586"></a>01586   <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a> = 0;
<a name="l01587"></a>01587 
<a name="l01588"></a>01588   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;xtensa_extract_return_value (...)\n&quot;</span>);
<a name="l01589"></a>01589 
<a name="l01590"></a>01590   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a>(len &gt; 0);
<a name="l01591"></a>01591 
<a name="l01592"></a>01592   <span class="keywordflow">if</span> (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;call_abi != <a class="code" href="xtensa-tdep_8h.html#aa494e78313efd646e55e129992eafbcbadd1a04285f03aa703b8634da6c2df921">CallAbiCall0Only</a>)
<a name="l01593"></a>01593     {
<a name="l01594"></a>01594       <span class="comment">/* First, we have to find the caller window in the register file.  */</span>
<a name="l01595"></a>01595       <a class="code" href="regcache_8c.html#a465c747dfdb94bb985d56e0374eb4481">regcache_raw_read_unsigned</a> (regcache, <a class="code" href="gdbarch_8c.html#a07a162ebafea1269eb8f341db44e53e7">gdbarch_pc_regnum</a> (gdbarch), &amp;pc);
<a name="l01596"></a>01596       callsize = extract_call_winsize (gdbarch, pc);
<a name="l01597"></a>01597 
<a name="l01598"></a>01598       <span class="comment">/* On Xtensa, we can return up to 4 words (or 2 for call12).  */</span>
<a name="l01599"></a>01599       <span class="keywordflow">if</span> (len &gt; (callsize &gt; 8 ? 8 : 16))
<a name="l01600"></a>01600         <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l01601"></a>01601                         <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;cannot extract return value of %d bytes long&quot;</span>),
<a name="l01602"></a>01602                         len);
<a name="l01603"></a>01603 
<a name="l01604"></a>01604       <span class="comment">/* Get the register offset of the return</span>
<a name="l01605"></a>01605 <span class="comment">         register (A2) in the caller window.  */</span>
<a name="l01606"></a>01606       <a class="code" href="regcache_8c.html#a465c747dfdb94bb985d56e0374eb4481">regcache_raw_read_unsigned</a>
<a name="l01607"></a>01607         (regcache, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;wb_regnum, &amp;wb);
<a name="l01608"></a>01608       areg = arreg_number (gdbarch,
<a name="l01609"></a>01609                           <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 2 + callsize, wb);
<a name="l01610"></a>01610     }
<a name="l01611"></a>01611   <span class="keywordflow">else</span>
<a name="l01612"></a>01612     {
<a name="l01613"></a>01613       <span class="comment">/* No windowing hardware - Call0 ABI.  */</span>
<a name="l01614"></a>01614       areg = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a> + <a class="code" href="xtensa-tdep_8c.html#acd655972d03b0cd702f8c8f53b3d742c">C0_ARGS</a>;
<a name="l01615"></a>01615     }
<a name="l01616"></a>01616 
<a name="l01617"></a>01617   <a class="code" href="xtensa-tdep_8c.html#a9720f72e59ae110cdacf653d01c305cb">DEBUGINFO</a> (<span class="stringliteral">&quot;[xtensa_extract_return_value] areg %d len %d\n&quot;</span>, areg, len);
<a name="l01618"></a>01618 
<a name="l01619"></a>01619   <span class="keywordflow">if</span> (len &lt; 4 &amp;&amp; <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch) == BFD_ENDIAN_BIG)
<a name="l01620"></a>01620     offset = 4 - <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l01621"></a>01621 
<a name="l01622"></a>01622   <span class="keywordflow">for</span> (; len &gt; 0; len -= 4, areg++, valbuf += 4)
<a name="l01623"></a>01623     {
<a name="l01624"></a>01624       <span class="keywordflow">if</span> (len &lt; 4)
<a name="l01625"></a>01625         <a class="code" href="regcache_8c.html#a2320f5763fd28b556c8c92f244b07da7">regcache_raw_read_part</a> (regcache, areg, offset, len, valbuf);
<a name="l01626"></a>01626       <span class="keywordflow">else</span>
<a name="l01627"></a>01627         <a class="code" href="regcache_8c.html#a995b366cfa6f89eaa36c6e88227f3462">regcache_raw_read</a> (regcache, areg, valbuf);
<a name="l01628"></a>01628     }
<a name="l01629"></a>01629 }
<a name="l01630"></a>01630 
<a name="l01631"></a>01631 
<a name="l01632"></a>01632 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01633"></a>01633 xtensa_store_return_value (<span class="keyword">struct</span> type *type,
<a name="l01634"></a>01634                            <span class="keyword">struct</span> regcache *regcache,
<a name="l01635"></a>01635                            <span class="keyword">const</span> <span class="keywordtype">void</span> *dst)
<a name="l01636"></a>01636 {
<a name="l01637"></a>01637   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="regcache_8c.html#ad4f6d0cdf256b1fa45d59a6d71b50659">get_regcache_arch</a> (regcache);
<a name="l01638"></a>01638   <span class="keyword">const</span> bfd_byte *valbuf = dst;
<a name="l01639"></a>01639   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> areg;
<a name="l01640"></a>01640   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> pc, wb;
<a name="l01641"></a>01641   <span class="keywordtype">int</span> callsize;
<a name="l01642"></a>01642   <span class="keywordtype">int</span> len = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type);
<a name="l01643"></a>01643   <span class="keywordtype">int</span> offset = 0;
<a name="l01644"></a>01644 
<a name="l01645"></a>01645   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;xtensa_store_return_value (...)\n&quot;</span>);
<a name="l01646"></a>01646 
<a name="l01647"></a>01647   <span class="keywordflow">if</span> (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;call_abi != <a class="code" href="xtensa-tdep_8h.html#aa494e78313efd646e55e129992eafbcbadd1a04285f03aa703b8634da6c2df921">CallAbiCall0Only</a>)
<a name="l01648"></a>01648     {
<a name="l01649"></a>01649       <a class="code" href="regcache_8c.html#a465c747dfdb94bb985d56e0374eb4481">regcache_raw_read_unsigned</a> 
<a name="l01650"></a>01650         (regcache, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;wb_regnum, &amp;wb);
<a name="l01651"></a>01651       <a class="code" href="regcache_8c.html#a465c747dfdb94bb985d56e0374eb4481">regcache_raw_read_unsigned</a> (regcache, <a class="code" href="gdbarch_8c.html#a07a162ebafea1269eb8f341db44e53e7">gdbarch_pc_regnum</a> (gdbarch), &amp;pc);
<a name="l01652"></a>01652       callsize = extract_call_winsize (gdbarch, pc);
<a name="l01653"></a>01653 
<a name="l01654"></a>01654       <span class="keywordflow">if</span> (len &gt; (callsize &gt; 8 ? 8 : 16))
<a name="l01655"></a>01655         <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l01656"></a>01656                         <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;unimplemented for this length: %d&quot;</span>),
<a name="l01657"></a>01657                         <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (type));
<a name="l01658"></a>01658       areg = arreg_number (gdbarch,
<a name="l01659"></a>01659                            <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 2 + callsize, wb);
<a name="l01660"></a>01660 
<a name="l01661"></a>01661       <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;[xtensa_store_return_value] callsize %d wb %d\n&quot;</span>,
<a name="l01662"></a>01662               callsize, (<span class="keywordtype">int</span>) wb);
<a name="l01663"></a>01663     }
<a name="l01664"></a>01664   <span class="keywordflow">else</span>
<a name="l01665"></a>01665     {
<a name="l01666"></a>01666       areg = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a> + <a class="code" href="xtensa-tdep_8c.html#acd655972d03b0cd702f8c8f53b3d742c">C0_ARGS</a>;
<a name="l01667"></a>01667     }
<a name="l01668"></a>01668 
<a name="l01669"></a>01669   <span class="keywordflow">if</span> (len &lt; 4 &amp;&amp; <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch) == BFD_ENDIAN_BIG)
<a name="l01670"></a>01670     offset = 4 - <a class="code" href="exec_8h.html#a00f945351279d3c8935f13d2b9f9b808">len</a>;
<a name="l01671"></a>01671 
<a name="l01672"></a>01672   <span class="keywordflow">for</span> (; len &gt; 0; len -= 4, areg++, valbuf += 4)
<a name="l01673"></a>01673     {
<a name="l01674"></a>01674       <span class="keywordflow">if</span> (len &lt; 4)
<a name="l01675"></a>01675         <a class="code" href="regcache_8c.html#a0eda92b8bcdd73455eab076beedc2d1f">regcache_raw_write_part</a> (regcache, areg, offset, len, valbuf);
<a name="l01676"></a>01676       <span class="keywordflow">else</span>
<a name="l01677"></a>01677         <a class="code" href="regcache_8c.html#a1102769bb633fd84087614a3fc5c6e20">regcache_raw_write</a> (regcache, areg, valbuf);
<a name="l01678"></a>01678     }
<a name="l01679"></a>01679 }
<a name="l01680"></a>01680 
<a name="l01681"></a>01681 
<a name="l01682"></a>01682 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5">return_value_convention</a>
<a name="l01683"></a>01683 xtensa_return_value (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l01684"></a>01684                      <span class="keyword">struct</span> value *<span class="keyword">function</span>,
<a name="l01685"></a>01685                      <span class="keyword">struct</span> type *valtype,
<a name="l01686"></a>01686                      <span class="keyword">struct</span> regcache *regcache,
<a name="l01687"></a>01687                      <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *readbuf,
<a name="l01688"></a>01688                      <span class="keyword">const</span> <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *writebuf)
<a name="l01689"></a>01689 {
<a name="l01690"></a>01690   <span class="comment">/* Structures up to 16 bytes are returned in registers.  */</span>
<a name="l01691"></a>01691 
<a name="l01692"></a>01692   <span class="keywordtype">int</span> <a class="code" href="arm-tdep_8h.html#aabb639d85dec2f973451bb1e7b6d1be8">struct_return</a> = ((<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (valtype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>
<a name="l01693"></a>01693                         || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (valtype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a8c3218d2f780665395d57dcd4d909191">TYPE_CODE_UNION</a>
<a name="l01694"></a>01694                         || <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (valtype) == <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a00c795b43d1a39f57d3e222385f14fc0">TYPE_CODE_ARRAY</a>)
<a name="l01695"></a>01695                        &amp;&amp; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (valtype) &gt; 16);
<a name="l01696"></a>01696 
<a name="l01697"></a>01697   <span class="keywordflow">if</span> (struct_return)
<a name="l01698"></a>01698     <span class="keywordflow">return</span> <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5a1fab6a0bfd44af88ba17a143673dc937">RETURN_VALUE_STRUCT_CONVENTION</a>;
<a name="l01699"></a>01699 
<a name="l01700"></a>01700   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;xtensa_return_value(...)\n&quot;</span>);
<a name="l01701"></a>01701 
<a name="l01702"></a>01702   <span class="keywordflow">if</span> (writebuf != NULL)
<a name="l01703"></a>01703     {
<a name="l01704"></a>01704       xtensa_store_return_value (valtype, regcache, writebuf);
<a name="l01705"></a>01705     }
<a name="l01706"></a>01706 
<a name="l01707"></a>01707   <span class="keywordflow">if</span> (readbuf != NULL)
<a name="l01708"></a>01708     {
<a name="l01709"></a>01709       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (!struct_return);
<a name="l01710"></a>01710       xtensa_extract_return_value (valtype, regcache, readbuf);
<a name="l01711"></a>01711     }
<a name="l01712"></a>01712   <span class="keywordflow">return</span> <a class="code" href="defs_8h.html#ad73ff2db888df8f297b907f7093082a5a0cd14b7546740080384acc0c7e5caf3b">RETURN_VALUE_REGISTER_CONVENTION</a>;
<a name="l01713"></a>01713 }
<a name="l01714"></a>01714 
<a name="l01715"></a>01715 
<a name="l01716"></a>01716 <span class="comment">/* DUMMY FRAME */</span>
<a name="l01717"></a>01717 
<a name="l01718"></a>01718 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l01719"></a>01719 xtensa_push_dummy_call (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l01720"></a>01720                         <span class="keyword">struct</span> value *<span class="keyword">function</span>,
<a name="l01721"></a>01721                         <span class="keyword">struct</span> regcache *regcache,
<a name="l01722"></a>01722                         <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> bp_addr,
<a name="l01723"></a>01723                         <span class="keywordtype">int</span> nargs,
<a name="l01724"></a>01724                         <span class="keyword">struct</span> value **args,
<a name="l01725"></a>01725                         <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> sp,
<a name="l01726"></a>01726                         <span class="keywordtype">int</span> struct_return,
<a name="l01727"></a>01727                         <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> struct_addr)
<a name="l01728"></a>01728 {
<a name="l01729"></a>01729   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l01730"></a>01730   <span class="keywordtype">int</span> i;
<a name="l01731"></a>01731   <span class="keywordtype">int</span> <a class="code" href="go32-nat_8c.html#a854352f53b148adc24983a58a1866d66">size</a>, onstack_size;
<a name="l01732"></a>01732   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *buf = (<a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> *) alloca (16);
<a name="l01733"></a>01733   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ra, <a class="code" href="namespacecleanup__check.html#a2f9ce522b7667bef19a5777d12fa44d8">ps</a>;
<a name="l01734"></a>01734   <span class="keyword">struct </span>argument_info
<a name="l01735"></a>01735   {
<a name="l01736"></a>01736     <span class="keyword">const</span> bfd_byte *contents;
<a name="l01737"></a>01737     <span class="keywordtype">int</span> length;
<a name="l01738"></a>01738     <span class="keywordtype">int</span> onstack;                <span class="comment">/* onstack == 0 =&gt; in reg */</span>
<a name="l01739"></a>01739     <span class="keywordtype">int</span> align;                  <span class="comment">/* alignment */</span>
<a name="l01740"></a>01740     <span class="keyword">union</span>
<a name="l01741"></a>01741     {
<a name="l01742"></a>01742       <span class="keywordtype">int</span> <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;               <span class="comment">/* stack offset if on stack.  */</span>
<a name="l01743"></a>01743       <span class="keywordtype">int</span> regno;                <span class="comment">/* regno if in register.  */</span>
<a name="l01744"></a>01744     } u;
<a name="l01745"></a>01745   };
<a name="l01746"></a>01746 
<a name="l01747"></a>01747   <span class="keyword">struct </span>argument_info *arg_info =
<a name="l01748"></a>01748     (<span class="keyword">struct </span>argument_info *) alloca (nargs * <span class="keyword">sizeof</span> (<span class="keyword">struct</span> argument_info));
<a name="l01749"></a>01749 
<a name="l01750"></a>01750   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> osp = sp;
<a name="l01751"></a>01751 
<a name="l01752"></a>01752   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;xtensa_push_dummy_call (...)\n&quot;</span>);
<a name="l01753"></a>01753 
<a name="l01754"></a>01754   <span class="keywordflow">if</span> (xtensa_debug_level &gt; 3)
<a name="l01755"></a>01755     {
<a name="l01756"></a>01756       <span class="keywordtype">int</span> i;
<a name="l01757"></a>01757       <a class="code" href="xtensa-tdep_8c.html#a9720f72e59ae110cdacf653d01c305cb">DEBUGINFO</a> (<span class="stringliteral">&quot;[xtensa_push_dummy_call] nargs = %d\n&quot;</span>, nargs);
<a name="l01758"></a>01758       <a class="code" href="xtensa-tdep_8c.html#a9720f72e59ae110cdacf653d01c305cb">DEBUGINFO</a> (<span class="stringliteral">&quot;[xtensa_push_dummy_call] sp=0x%x, struct_return=%d, &quot;</span>
<a name="l01759"></a>01759                  <span class="stringliteral">&quot;struct_addr=0x%x\n&quot;</span>,
<a name="l01760"></a>01760                  (<span class="keywordtype">int</span>) sp, (<span class="keywordtype">int</span>) struct_return, (<span class="keywordtype">int</span>) struct_addr);
<a name="l01761"></a>01761 
<a name="l01762"></a>01762       <span class="keywordflow">for</span> (i = 0; i &lt; nargs; i++)
<a name="l01763"></a>01763         {
<a name="l01764"></a>01764           <span class="keyword">struct </span>value *arg = args[i];
<a name="l01765"></a>01765           <span class="keyword">struct </span>type *arg_type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg));
<a name="l01766"></a>01766           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;%2d: %s %3d &quot;</span>, i,
<a name="l01767"></a>01767                               <a class="code" href="utils_8c.html#ac166db325056a01e8babd984f8ba2b98">host_address_to_string</a> (arg),
<a name="l01768"></a>01768                               <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (arg_type));
<a name="l01769"></a>01769           <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (arg_type))
<a name="l01770"></a>01770             {
<a name="l01771"></a>01771             <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>:
<a name="l01772"></a>01772               <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;int&quot;</span>);
<a name="l01773"></a>01773               <span class="keywordflow">break</span>;
<a name="l01774"></a>01774             <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l01775"></a>01775               <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;struct&quot;</span>);
<a name="l01776"></a>01776               <span class="keywordflow">break</span>;
<a name="l01777"></a>01777             <span class="keywordflow">default</span>:
<a name="l01778"></a>01778               <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot;%3d&quot;</span>, <a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (arg_type));
<a name="l01779"></a>01779               <span class="keywordflow">break</span>;
<a name="l01780"></a>01780             }
<a name="l01781"></a>01781           <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (<a class="code" href="main_8c.html#a097b10b28c07237b554c73fbf42a8e9e">gdb_stdlog</a>, <span class="stringliteral">&quot; %s\n&quot;</span>,
<a name="l01782"></a>01782                               <a class="code" href="utils_8c.html#ac166db325056a01e8babd984f8ba2b98">host_address_to_string</a> (<a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (arg)));
<a name="l01783"></a>01783         }
<a name="l01784"></a>01784     }
<a name="l01785"></a>01785 
<a name="l01786"></a>01786   <span class="comment">/* First loop: collect information.</span>
<a name="l01787"></a>01787 <span class="comment">     Cast into type_long.  (This shouldn&#39;t happen often for C because</span>
<a name="l01788"></a>01788 <span class="comment">     GDB already does this earlier.)  It&#39;s possible that GDB could</span>
<a name="l01789"></a>01789 <span class="comment">     do it all the time but it&#39;s harmless to leave this code here.  */</span>
<a name="l01790"></a>01790 
<a name="l01791"></a>01791   size = 0;
<a name="l01792"></a>01792   onstack_size = 0;
<a name="l01793"></a>01793   i = 0;
<a name="l01794"></a>01794 
<a name="l01795"></a>01795   <span class="keywordflow">if</span> (struct_return)
<a name="l01796"></a>01796     size = <a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">REGISTER_SIZE</a>;
<a name="l01797"></a>01797 
<a name="l01798"></a>01798   <span class="keywordflow">for</span> (i = 0; i &lt; nargs; i++)
<a name="l01799"></a>01799     {
<a name="l01800"></a>01800       <span class="keyword">struct </span>argument_info *info = &amp;arg_info[i];
<a name="l01801"></a>01801       <span class="keyword">struct </span>value *arg = args[i];
<a name="l01802"></a>01802       <span class="keyword">struct </span>type *arg_type = <a class="code" href="gdbtypes_8c.html#a0bf29d7521d8a8b8735b9a259e380386">check_typedef</a> (<a class="code" href="value_8c.html#a263a4c0bee0b0df41074b952d3c121d0">value_type</a> (arg));
<a name="l01803"></a>01803 
<a name="l01804"></a>01804       <span class="keywordflow">switch</span> (<a class="code" href="gdbtypes_8h.html#a9505f41c7012665947c6b4065ce190e1">TYPE_CODE</a> (arg_type))
<a name="l01805"></a>01805         {
<a name="l01806"></a>01806         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a7071a71840688811b992838bb09d0ddd">TYPE_CODE_INT</a>:
<a name="l01807"></a>01807         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462afbf0aa0241df408e1017ae7ff8e6798c">TYPE_CODE_BOOL</a>:
<a name="l01808"></a>01808         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462ae991dd7ea70631f3e1b67a1a75020b5f">TYPE_CODE_CHAR</a>:
<a name="l01809"></a>01809         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a31cf8189b076711e63dea04c1136bafe">TYPE_CODE_RANGE</a>:
<a name="l01810"></a>01810         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a1afbc1e8f69012b205070a3b5eac7217">TYPE_CODE_ENUM</a>:
<a name="l01811"></a>01811 
<a name="l01812"></a>01812           <span class="comment">/* Cast argument to long if necessary as the mask does it too.  */</span>
<a name="l01813"></a>01813           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (arg_type)
<a name="l01814"></a>01814               &lt; <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="structbuiltin__type.html">builtin_type</a> (gdbarch)-&gt;builtin_long))
<a name="l01815"></a>01815             {
<a name="l01816"></a>01816               arg_type = <a class="code" href="gdbtypes_8c.html#addd01ebc9ccdf2cacb33ab01e281ddb8">builtin_type</a> (gdbarch)-&gt;<a class="code" href="structbuiltin__type.html#a52238d85813719573b7876379b145307">builtin_long</a>;
<a name="l01817"></a>01817               arg = <a class="code" href="valops_8c.html#a458c471119ca0e007cecaa24fe6b1333">value_cast</a> (arg_type, arg);
<a name="l01818"></a>01818             }
<a name="l01819"></a>01819           <span class="comment">/* Aligment is equal to the type length for the basic types.  */</span>
<a name="l01820"></a>01820           info-&gt;align = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (arg_type);
<a name="l01821"></a>01821           <span class="keywordflow">break</span>;
<a name="l01822"></a>01822 
<a name="l01823"></a>01823         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462a98f3aa25f923ee0cd1d009e77b0a551a">TYPE_CODE_FLT</a>:
<a name="l01824"></a>01824 
<a name="l01825"></a>01825           <span class="comment">/* Align doubles correctly.  */</span>
<a name="l01826"></a>01826           <span class="keywordflow">if</span> (<a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (arg_type)
<a name="l01827"></a>01827               == <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="structbuiltin__type.html">builtin_type</a> (gdbarch)-&gt;builtin_double))
<a name="l01828"></a>01828             info-&gt;align = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="structbuiltin__type.html">builtin_type</a> (gdbarch)-&gt;builtin_double);
<a name="l01829"></a>01829           <span class="keywordflow">else</span>
<a name="l01830"></a>01830             info-&gt;align = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="structbuiltin__type.html">builtin_type</a> (gdbarch)-&gt;builtin_long);
<a name="l01831"></a>01831           <span class="keywordflow">break</span>;
<a name="l01832"></a>01832 
<a name="l01833"></a>01833         <span class="keywordflow">case</span> <a class="code" href="gdbtypes_8h.html#a90e2a0fddaa6afff6a0a489ff4da3462af3b3fc76f66c95e12946c0ef84409365">TYPE_CODE_STRUCT</a>:
<a name="l01834"></a>01834         <span class="keywordflow">default</span>:
<a name="l01835"></a>01835           info-&gt;align = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (<a class="code" href="structbuiltin__type.html">builtin_type</a> (gdbarch)-&gt;builtin_long);
<a name="l01836"></a>01836           <span class="keywordflow">break</span>;
<a name="l01837"></a>01837         }
<a name="l01838"></a>01838       info-&gt;length = <a class="code" href="gdbtypes_8h.html#aeac33f868e763780094aec8a2dcb9a1a">TYPE_LENGTH</a> (arg_type);
<a name="l01839"></a>01839       info-&gt;contents = <a class="code" href="value_8c.html#ad41a6de8fde15c01e1ffabb603c4f108">value_contents</a> (arg);
<a name="l01840"></a>01840 
<a name="l01841"></a>01841       <span class="comment">/* Align size and onstack_size.  */</span>
<a name="l01842"></a>01842       size = (size + info-&gt;align - 1) &amp; ~(info-&gt;align - 1);
<a name="l01843"></a>01843       onstack_size = (onstack_size + info-&gt;align - 1) &amp; ~(info-&gt;align - 1);
<a name="l01844"></a>01844 
<a name="l01845"></a>01845       <span class="keywordflow">if</span> (size + info-&gt;length &gt; <a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">REGISTER_SIZE</a> * <a class="code" href="xtensa-tdep_8c.html#a75e8630347d4e5ed6ba06f0377a9bca7">ARG_NOF</a> (gdbarch))
<a name="l01846"></a>01846         {
<a name="l01847"></a>01847           info-&gt;onstack = 1;
<a name="l01848"></a>01848           info-&gt;u.offset = onstack_size;
<a name="l01849"></a>01849           onstack_size += info-&gt;length;
<a name="l01850"></a>01850         }
<a name="l01851"></a>01851       <span class="keywordflow">else</span>
<a name="l01852"></a>01852         {
<a name="l01853"></a>01853           info-&gt;onstack = 0;
<a name="l01854"></a>01854           info-&gt;u.regno = <a class="code" href="xtensa-tdep_8c.html#a514cc1a3d9a73356d4cf25986b456337">ARG_1ST</a> (gdbarch) + size / <a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">REGISTER_SIZE</a>;
<a name="l01855"></a>01855         }
<a name="l01856"></a>01856       size += info-&gt;length;
<a name="l01857"></a>01857     }
<a name="l01858"></a>01858 
<a name="l01859"></a>01859   <span class="comment">/* Adjust the stack pointer and align it.  */</span>
<a name="l01860"></a>01860   sp = <a class="code" href="utils_8c.html#a2333cae8a4809e09f8e851c83838ecaf">align_down</a> (sp - onstack_size, <a class="code" href="xtensa-tdep_8c.html#acb8b2dd04a867b883f65bdf233b9b602">SP_ALIGNMENT</a>);
<a name="l01861"></a>01861 
<a name="l01862"></a>01862   <span class="comment">/* Simulate MOVSP, if Windowed ABI.  */</span>
<a name="l01863"></a>01863   <span class="keywordflow">if</span> ((<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;call_abi != <a class="code" href="xtensa-tdep_8h.html#aa494e78313efd646e55e129992eafbcbadd1a04285f03aa703b8634da6c2df921">CallAbiCall0Only</a>)
<a name="l01864"></a>01864       &amp;&amp; (sp != osp))
<a name="l01865"></a>01865     {
<a name="l01866"></a>01866       <a class="code" href="corefile_8c.html#a5e0189c6f21f1c9321b379877183b819">read_memory</a> (osp - 16, buf, 16);
<a name="l01867"></a>01867       <a class="code" href="corefile_8c.html#a05c568c157071d9349667fab589228e5">write_memory</a> (sp - 16, buf, 16);
<a name="l01868"></a>01868     }
<a name="l01869"></a>01869 
<a name="l01870"></a>01870   <span class="comment">/* Second Loop: Load arguments.  */</span>
<a name="l01871"></a>01871 
<a name="l01872"></a>01872   <span class="keywordflow">if</span> (struct_return)
<a name="l01873"></a>01873     {
<a name="l01874"></a>01874       <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (buf, <a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">REGISTER_SIZE</a>, byte_order, struct_addr);
<a name="l01875"></a>01875       <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (regcache, <a class="code" href="xtensa-tdep_8c.html#a514cc1a3d9a73356d4cf25986b456337">ARG_1ST</a> (gdbarch), buf);
<a name="l01876"></a>01876     }
<a name="l01877"></a>01877 
<a name="l01878"></a>01878   <span class="keywordflow">for</span> (i = 0; i &lt; nargs; i++)
<a name="l01879"></a>01879     {
<a name="l01880"></a>01880       <span class="keyword">struct </span>argument_info *info = &amp;arg_info[i];
<a name="l01881"></a>01881 
<a name="l01882"></a>01882       <span class="keywordflow">if</span> (info-&gt;onstack)
<a name="l01883"></a>01883         {
<a name="l01884"></a>01884           <span class="keywordtype">int</span> n = info-&gt;length;
<a name="l01885"></a>01885           <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> offset = sp + info-&gt;u.offset;
<a name="l01886"></a>01886 
<a name="l01887"></a>01887           <span class="comment">/* Odd-sized structs are aligned to the lower side of a memory</span>
<a name="l01888"></a>01888 <span class="comment">             word in big-endian mode and require a shift.  This only</span>
<a name="l01889"></a>01889 <span class="comment">             applies for structures smaller than one word.  */</span>
<a name="l01890"></a>01890 
<a name="l01891"></a>01891           <span class="keywordflow">if</span> (n &lt; <a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">REGISTER_SIZE</a>
<a name="l01892"></a>01892               &amp;&amp; <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch) == BFD_ENDIAN_BIG)
<a name="l01893"></a>01893             offset += (<a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">REGISTER_SIZE</a> - n);
<a name="l01894"></a>01894 
<a name="l01895"></a>01895           <a class="code" href="corefile_8c.html#a05c568c157071d9349667fab589228e5">write_memory</a> (offset, info-&gt;contents, info-&gt;length);
<a name="l01896"></a>01896 
<a name="l01897"></a>01897         }
<a name="l01898"></a>01898       <span class="keywordflow">else</span>
<a name="l01899"></a>01899         {
<a name="l01900"></a>01900           <span class="keywordtype">int</span> n = info-&gt;length;
<a name="l01901"></a>01901           <span class="keyword">const</span> bfd_byte *cp = info-&gt;contents;
<a name="l01902"></a>01902           <span class="keywordtype">int</span> r = info-&gt;u.regno;
<a name="l01903"></a>01903 
<a name="l01904"></a>01904           <span class="comment">/* Odd-sized structs are aligned to the lower side of registers in</span>
<a name="l01905"></a>01905 <span class="comment">             big-endian mode and require a shift.  The odd-sized leftover will</span>
<a name="l01906"></a>01906 <span class="comment">             be at the end.  Note that this is only true for structures smaller</span>
<a name="l01907"></a>01907 <span class="comment">             than REGISTER_SIZE; for larger odd-sized structures the excess</span>
<a name="l01908"></a>01908 <span class="comment">             will be left-aligned in the register on both endiannesses.  */</span>
<a name="l01909"></a>01909 
<a name="l01910"></a>01910           <span class="keywordflow">if</span> (n &lt; <a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">REGISTER_SIZE</a> &amp;&amp; byte_order == BFD_ENDIAN_BIG)
<a name="l01911"></a>01911             {
<a name="l01912"></a>01912               <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> v;
<a name="l01913"></a>01913               v = <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (cp, <a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">REGISTER_SIZE</a>, byte_order);
<a name="l01914"></a>01914               v = v &gt;&gt; ((<a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">REGISTER_SIZE</a> - n) * TARGET_CHAR_BIT);
<a name="l01915"></a>01915 
<a name="l01916"></a>01916               <a class="code" href="defs_8h.html#ad11c013c83c64d9d0ee2e4bdeb1fb62d">store_unsigned_integer</a> (buf, <a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">REGISTER_SIZE</a>, byte_order, v);
<a name="l01917"></a>01917               <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (regcache, r, buf);
<a name="l01918"></a>01918 
<a name="l01919"></a>01919               cp += <a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">REGISTER_SIZE</a>;
<a name="l01920"></a>01920               n -= <a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">REGISTER_SIZE</a>;
<a name="l01921"></a>01921               r++;
<a name="l01922"></a>01922             }
<a name="l01923"></a>01923           <span class="keywordflow">else</span>
<a name="l01924"></a>01924             <span class="keywordflow">while</span> (n &gt; 0)
<a name="l01925"></a>01925               {
<a name="l01926"></a>01926                 <a class="code" href="regcache_8c.html#a25a43a21da95fa740c8efca31cf61d56">regcache_cooked_write</a> (regcache, r, cp);
<a name="l01927"></a>01927 
<a name="l01928"></a>01928                 cp += <a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">REGISTER_SIZE</a>;
<a name="l01929"></a>01929                 n -= <a class="code" href="xtensa-tdep_8c.html#abe2f7b6344bb4d51dfea9c9f58609427">REGISTER_SIZE</a>;
<a name="l01930"></a>01930                 r++;
<a name="l01931"></a>01931               }
<a name="l01932"></a>01932         }
<a name="l01933"></a>01933     }
<a name="l01934"></a>01934 
<a name="l01935"></a>01935   <span class="comment">/* Set the return address of dummy frame to the dummy address.</span>
<a name="l01936"></a>01936 <span class="comment">     The return address for the current function (in A0) is</span>
<a name="l01937"></a>01937 <span class="comment">     saved in the dummy frame, so we can savely overwrite A0 here.  */</span>
<a name="l01938"></a>01938 
<a name="l01939"></a>01939   <span class="keywordflow">if</span> (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;call_abi != <a class="code" href="xtensa-tdep_8h.html#aa494e78313efd646e55e129992eafbcbadd1a04285f03aa703b8634da6c2df921">CallAbiCall0Only</a>)
<a name="l01940"></a>01940     {
<a name="l01941"></a>01941       <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> val;
<a name="l01942"></a>01942 
<a name="l01943"></a>01943       ra = (bp_addr &amp; 0x3fffffff) | 0x40000000;
<a name="l01944"></a>01944       <a class="code" href="regcache_8c.html#a465c747dfdb94bb985d56e0374eb4481">regcache_raw_read_unsigned</a> (regcache, <a class="code" href="gdbarch_8c.html#aa0e316e2d110495a985d9f566df348c3">gdbarch_ps_regnum</a> (gdbarch), &amp;val);
<a name="l01945"></a>01945       ps = (<span class="keywordtype">unsigned</span> <a class="code" href="namespacegdb_1_1printing.html#ae264c8b9a4ff02c4b077df5db5944977">long</a>) val &amp; ~0x00030000;
<a name="l01946"></a>01946       <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a>
<a name="l01947"></a>01947         (regcache, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 4, ra);
<a name="l01948"></a>01948       <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a> (regcache,
<a name="l01949"></a>01949                                       <a class="code" href="gdbarch_8c.html#aa0e316e2d110495a985d9f566df348c3">gdbarch_ps_regnum</a> (gdbarch),
<a name="l01950"></a>01950                                       ps | 0x00010000);
<a name="l01951"></a>01951 
<a name="l01952"></a>01952       <span class="comment">/* All the registers have been saved.  After executing</span>
<a name="l01953"></a>01953 <span class="comment">         dummy call, they all will be restored.  So it&#39;s safe</span>
<a name="l01954"></a>01954 <span class="comment">         to modify WINDOWSTART register to make it look like there</span>
<a name="l01955"></a>01955 <span class="comment">         is only one register window corresponding to WINDOWEBASE.  */</span>
<a name="l01956"></a>01956 
<a name="l01957"></a>01957       <a class="code" href="regcache_8c.html#a995b366cfa6f89eaa36c6e88227f3462">regcache_raw_read</a> (regcache, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;wb_regnum, buf);
<a name="l01958"></a>01958       <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a>
<a name="l01959"></a>01959         (regcache, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;ws_regnum,
<a name="l01960"></a>01960          1 &lt;&lt; <a class="code" href="defs_8h.html#a99aec65329508b4d449a4f881026f844">extract_unsigned_integer</a> (buf, 4, byte_order));
<a name="l01961"></a>01961     }
<a name="l01962"></a>01962   <span class="keywordflow">else</span>
<a name="l01963"></a>01963     {
<a name="l01964"></a>01964       <span class="comment">/* Simulate CALL0: write RA into A0 register.  */</span>
<a name="l01965"></a>01965       <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a>
<a name="l01966"></a>01966         (regcache, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base, bp_addr);
<a name="l01967"></a>01967     }
<a name="l01968"></a>01968 
<a name="l01969"></a>01969   <span class="comment">/* Set new stack pointer and return it.  */</span>
<a name="l01970"></a>01970   <a class="code" href="regcache_8c.html#ae5fb22bfd07bc89a855768ef6f910745">regcache_cooked_write_unsigned</a> (regcache,
<a name="l01971"></a>01971                                   <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 1, sp);
<a name="l01972"></a>01972   <span class="comment">/* Make dummy frame ID unique by adding a constant.  */</span>
<a name="l01973"></a>01973   <span class="keywordflow">return</span> sp + <a class="code" href="xtensa-tdep_8c.html#acb8b2dd04a867b883f65bdf233b9b602">SP_ALIGNMENT</a>;
<a name="l01974"></a>01974 }
<a name="l01975"></a>01975 
<a name="l01976"></a>01976 
<a name="l01977"></a>01977 <span class="comment">/* Return a breakpoint for the current location of PC.  We always use</span>
<a name="l01978"></a>01978 <span class="comment">   the density version if we have density instructions (regardless of the</span>
<a name="l01979"></a>01979 <span class="comment">   current instruction at PC), and use regular instructions otherwise.  */</span>
<a name="l01980"></a><a class="code" href="xtensa-tdep_8c.html#a2dc4afaf32417887969725e410dc3db4">01980</a> 
<a name="l01981"></a><a class="code" href="xtensa-tdep_8c.html#a48ea44caa7352e2d67256e9ccee2293b">01981</a> <span class="preprocessor">#define BIG_BREAKPOINT { 0x00, 0x04, 0x00 }</span>
<a name="l01982"></a><a class="code" href="xtensa-tdep_8c.html#a4da52cc1c919e34eee691b7962d4a60d">01982</a> <span class="preprocessor"></span><span class="preprocessor">#define LITTLE_BREAKPOINT { 0x00, 0x40, 0x00 }</span>
<a name="l01983"></a><a class="code" href="xtensa-tdep_8c.html#ae46977a10b3012bcd2e7ee745685ba0f">01983</a> <span class="preprocessor"></span><span class="preprocessor">#define DENSITY_BIG_BREAKPOINT { 0xd2, 0x0f }</span>
<a name="l01984"></a>01984 <span class="preprocessor"></span><span class="preprocessor">#define DENSITY_LITTLE_BREAKPOINT { 0x2d, 0xf0 }</span>
<a name="l01985"></a>01985 <span class="preprocessor"></span>
<a name="l01986"></a>01986 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *
<a name="l01987"></a>01987 xtensa_breakpoint_from_pc (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> *pcptr,
<a name="l01988"></a>01988                            <span class="keywordtype">int</span> *lenptr)
<a name="l01989"></a>01989 {
<a name="l01990"></a>01990   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> big_breakpoint[] = <a class="code" href="xtensa-tdep_8c.html#a2dc4afaf32417887969725e410dc3db4">BIG_BREAKPOINT</a>;
<a name="l01991"></a>01991   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> little_breakpoint[] = <a class="code" href="xtensa-tdep_8c.html#a48ea44caa7352e2d67256e9ccee2293b">LITTLE_BREAKPOINT</a>;
<a name="l01992"></a>01992   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> density_big_breakpoint[] = <a class="code" href="xtensa-tdep_8c.html#a4da52cc1c919e34eee691b7962d4a60d">DENSITY_BIG_BREAKPOINT</a>;
<a name="l01993"></a>01993   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> density_little_breakpoint[] = <a class="code" href="xtensa-tdep_8c.html#ae46977a10b3012bcd2e7ee745685ba0f">DENSITY_LITTLE_BREAKPOINT</a>;
<a name="l01994"></a>01994 
<a name="l01995"></a>01995   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;xtensa_breakpoint_from_pc (pc = 0x%08x)\n&quot;</span>, (<span class="keywordtype">int</span>) *pcptr);
<a name="l01996"></a>01996 
<a name="l01997"></a>01997   <span class="keywordflow">if</span> (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;isa_use_density_instructions)
<a name="l01998"></a>01998     {
<a name="l01999"></a>01999       <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch) == BFD_ENDIAN_BIG)
<a name="l02000"></a>02000         {
<a name="l02001"></a>02001           *lenptr = <span class="keyword">sizeof</span> (density_big_breakpoint);
<a name="l02002"></a>02002           <span class="keywordflow">return</span> density_big_breakpoint;
<a name="l02003"></a>02003         }
<a name="l02004"></a>02004       <span class="keywordflow">else</span>
<a name="l02005"></a>02005         {
<a name="l02006"></a>02006           *lenptr = <span class="keyword">sizeof</span> (density_little_breakpoint);
<a name="l02007"></a>02007           <span class="keywordflow">return</span> density_little_breakpoint;
<a name="l02008"></a>02008         }
<a name="l02009"></a>02009     }
<a name="l02010"></a>02010   <span class="keywordflow">else</span>
<a name="l02011"></a>02011     {
<a name="l02012"></a>02012       <span class="keywordflow">if</span> (<a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch) == BFD_ENDIAN_BIG)
<a name="l02013"></a>02013         {
<a name="l02014"></a>02014           *lenptr = <span class="keyword">sizeof</span> (big_breakpoint);
<a name="l02015"></a>02015           <span class="keywordflow">return</span> big_breakpoint;
<a name="l02016"></a>02016         }
<a name="l02017"></a>02017       <span class="keywordflow">else</span>
<a name="l02018"></a>02018         {
<a name="l02019"></a>02019           *lenptr = <span class="keyword">sizeof</span> (little_breakpoint);
<a name="l02020"></a>02020           <span class="keywordflow">return</span> little_breakpoint;
<a name="l02021"></a>02021         }
<a name="l02022"></a>02022     }
<a name="l02023"></a>02023 }
<a name="l02024"></a>02024 
<a name="l02025"></a>02025 <span class="comment">/* Call0 ABI support routines.  */</span>
<a name="l02026"></a>02026 
<a name="l02027"></a>02027 <span class="comment">/* Return true, if PC points to &quot;ret&quot; or &quot;ret.n&quot;.  */</span> 
<a name="l02028"></a>02028 
<a name="l02029"></a>02029 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02030"></a>02030 call0_ret (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_pc, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> finish_pc)
<a name="l02031"></a>02031 {
<a name="l02032"></a>02032 <span class="preprocessor">#define RETURN_RET goto done</span>
<a name="l02033"></a>02033 <span class="preprocessor"></span>  xtensa_isa isa;
<a name="l02034"></a>02034   xtensa_insnbuf ins, slot;
<a name="l02035"></a>02035   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> ibuf[<a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a>];
<a name="l02036"></a>02036   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ia, bt, ba;
<a name="l02037"></a>02037   xtensa_format ifmt;
<a name="l02038"></a>02038   <span class="keywordtype">int</span> ilen, islots, is;
<a name="l02039"></a>02039   xtensa_opcode opc;
<a name="l02040"></a>02040   <span class="keyword">const</span> <span class="keywordtype">char</span> *opcname;
<a name="l02041"></a>02041   <span class="keywordtype">int</span> found_ret = 0;
<a name="l02042"></a>02042 
<a name="l02043"></a>02043   isa = xtensa_default_isa;
<a name="l02044"></a>02044   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a> &gt;= xtensa_isa_maxlength (isa));
<a name="l02045"></a>02045   ins = xtensa_insnbuf_alloc (isa);
<a name="l02046"></a>02046   slot = xtensa_insnbuf_alloc (isa);
<a name="l02047"></a>02047   ba = 0;
<a name="l02048"></a>02048 
<a name="l02049"></a>02049   <span class="keywordflow">for</span> (ia = start_pc, bt = ia; ia &lt; finish_pc ; ia += ilen)
<a name="l02050"></a>02050     {
<a name="l02051"></a>02051       <span class="keywordflow">if</span> (ia + xtensa_isa_maxlength (isa) &gt; bt)
<a name="l02052"></a>02052         {
<a name="l02053"></a>02053           ba = ia;
<a name="l02054"></a>02054           bt = (ba + <a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a>) &lt; finish_pc
<a name="l02055"></a>02055             ? ba + <a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a> : finish_pc;
<a name="l02056"></a>02056           <span class="keywordflow">if</span> (<a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (ba, ibuf, bt - ba) != 0 )
<a name="l02057"></a>02057             RETURN_RET;
<a name="l02058"></a>02058         }
<a name="l02059"></a>02059 
<a name="l02060"></a>02060       xtensa_insnbuf_from_chars (isa, ins, &amp;ibuf[ia-ba], 0);
<a name="l02061"></a>02061       ifmt = xtensa_format_decode (isa, ins);
<a name="l02062"></a>02062       <span class="keywordflow">if</span> (ifmt == XTENSA_UNDEFINED)
<a name="l02063"></a>02063         <a class="code" href="xtensa-tdep_8c.html#ad907b4dcba93cf15ac43670e6e737f8d">RETURN_RET</a>;
<a name="l02064"></a>02064       ilen = xtensa_format_length (isa, ifmt);
<a name="l02065"></a>02065       <span class="keywordflow">if</span> (ilen == XTENSA_UNDEFINED)
<a name="l02066"></a>02066         <a class="code" href="xtensa-tdep_8c.html#ad907b4dcba93cf15ac43670e6e737f8d">RETURN_RET</a>;
<a name="l02067"></a>02067       islots = xtensa_format_num_slots (isa, ifmt);
<a name="l02068"></a>02068       <span class="keywordflow">if</span> (islots == XTENSA_UNDEFINED)
<a name="l02069"></a>02069         <a class="code" href="xtensa-tdep_8c.html#ad907b4dcba93cf15ac43670e6e737f8d">RETURN_RET</a>;
<a name="l02070"></a>02070       
<a name="l02071"></a>02071       <span class="keywordflow">for</span> (is = 0; is &lt; islots; ++is)
<a name="l02072"></a>02072         {
<a name="l02073"></a>02073           <span class="keywordflow">if</span> (xtensa_format_get_slot (isa, ifmt, is, ins, slot))
<a name="l02074"></a>02074             <a class="code" href="xtensa-tdep_8c.html#ad907b4dcba93cf15ac43670e6e737f8d">RETURN_RET</a>;
<a name="l02075"></a>02075           
<a name="l02076"></a>02076           opc = xtensa_opcode_decode (isa, ifmt, is, slot);
<a name="l02077"></a>02077           <span class="keywordflow">if</span> (opc == XTENSA_UNDEFINED) 
<a name="l02078"></a>02078             <a class="code" href="xtensa-tdep_8c.html#ad907b4dcba93cf15ac43670e6e737f8d">RETURN_RET</a>;
<a name="l02079"></a>02079           
<a name="l02080"></a>02080           opcname = xtensa_opcode_name (isa, opc);
<a name="l02081"></a>02081           
<a name="l02082"></a>02082           <span class="keywordflow">if</span> ((strcasecmp (opcname, <span class="stringliteral">&quot;ret.n&quot;</span>) == 0)
<a name="l02083"></a>02083               || (strcasecmp (opcname, <span class="stringliteral">&quot;ret&quot;</span>) == 0))
<a name="l02084"></a>02084             {
<a name="l02085"></a>02085               found_ret = 1;
<a name="l02086"></a>02086               <a class="code" href="xtensa-tdep_8c.html#ad907b4dcba93cf15ac43670e6e737f8d">RETURN_RET</a>;
<a name="l02087"></a>02087             }
<a name="l02088"></a>02088         }
<a name="l02089"></a>02089     }
<a name="l02090"></a>02090  done:
<a name="l02091"></a>02091   xtensa_insnbuf_free(isa, slot);
<a name="l02092"></a>02092   xtensa_insnbuf_free(isa, ins);
<a name="l02093"></a>02093   <span class="keywordflow">return</span> found_ret;
<a name="l02094"></a>02094 }
<a name="l02095"></a>02095 
<a name="l02096"></a>02096 <span class="comment">/* Call0 opcode class.  Opcodes are preclassified according to what they</span>
<a name="l02097"></a>02097 <span class="comment">   mean for Call0 prologue analysis, and their number of significant operands.</span>
<a name="l02098"></a>02098 <span class="comment">   The purpose of this is to simplify prologue analysis by separating </span>
<a name="l02099"></a>02099 <span class="comment">   instruction decoding (libisa) from the semantics of prologue analysis.  */</span>
<a name="l02100"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cc">02100</a> 
<a name="l02101"></a>02101 <span class="keyword">typedef</span> <span class="keyword">enum</span>
<a name="l02102"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccaa7d04c2c707bf238bb7b14a7588ace4d">02102</a> {
<a name="l02103"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca885e0de8061fad2b12f80c796ec63e7c">02103</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccaa7d04c2c707bf238bb7b14a7588ace4d">c0opc_illegal</a>,       <span class="comment">/* Unknown to libisa (invalid) or &#39;ill&#39; opcode.  */</span>
<a name="l02104"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca9682c422984bf01156435b30b2cf1a31">02104</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca885e0de8061fad2b12f80c796ec63e7c">c0opc_uninteresting</a>, <span class="comment">/* Not interesting for Call0 prologue analysis.  */</span>
<a name="l02105"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca7d451d49c245e3d222877e68fbc2d1d8">02105</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca9682c422984bf01156435b30b2cf1a31">c0opc_flow</a>,          <span class="comment">/* Flow control insn.  */</span>
<a name="l02106"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccad60e969c89418a848d5ad9dedb0c14a7">02106</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca7d451d49c245e3d222877e68fbc2d1d8">c0opc_entry</a>,         <span class="comment">/* ENTRY indicates non-Call0 prologue.  */</span>
<a name="l02107"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca1febe7b92779e3787b34a1c839964d76">02107</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccad60e969c89418a848d5ad9dedb0c14a7">c0opc_break</a>,         <span class="comment">/* Debugger software breakpoints.  */</span>
<a name="l02108"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca4dc99289360d5dfb47083f6654a875e4">02108</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca1febe7b92779e3787b34a1c839964d76">c0opc_add</a>,           <span class="comment">/* Adding two registers.  */</span>
<a name="l02109"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccacc1dc8b7dcc4570060ddfe6b7c8244ef">02109</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca4dc99289360d5dfb47083f6654a875e4">c0opc_addi</a>,          <span class="comment">/* Adding a register and an immediate.  */</span>
<a name="l02110"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca10eaf71a94942e5058746d26e5cde353">02110</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccacc1dc8b7dcc4570060ddfe6b7c8244ef">c0opc_and</a>,           <span class="comment">/* Bitwise &quot;and&quot;-ing two registers.  */</span>
<a name="l02111"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca687ae834ae9de7fefe1dfea0877af0e0">02111</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca10eaf71a94942e5058746d26e5cde353">c0opc_sub</a>,           <span class="comment">/* Subtracting a register from a register.  */</span>
<a name="l02112"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca3ed5a95a963b7dd79b0991b5aa0bf53f">02112</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca687ae834ae9de7fefe1dfea0877af0e0">c0opc_mov</a>,           <span class="comment">/* Moving a register to a register.  */</span>
<a name="l02113"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca700a97c98043eb0b8b99ef3d1c968af0">02113</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca3ed5a95a963b7dd79b0991b5aa0bf53f">c0opc_movi</a>,          <span class="comment">/* Moving an immediate to a register.  */</span>
<a name="l02114"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccad78c4ffa6ec78272e6e7a6121c40e136">02114</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca700a97c98043eb0b8b99ef3d1c968af0">c0opc_l32r</a>,          <span class="comment">/* Loading a literal.  */</span>
<a name="l02115"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca74af960868aaea13019fcbe69aecb08b">02115</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccad78c4ffa6ec78272e6e7a6121c40e136">c0opc_s32i</a>,          <span class="comment">/* Storing word at fixed offset from a base register.  */</span>
<a name="l02116"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca4d1fc811a76a6fdaf0d90e3770830f20">02116</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca74af960868aaea13019fcbe69aecb08b">c0opc_rwxsr</a>,         <span class="comment">/* RSR, WRS, or XSR instructions.  */</span>
<a name="l02117"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca12513f3f43a89449ad008aedd8a7a552">02117</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca4d1fc811a76a6fdaf0d90e3770830f20">c0opc_l32e</a>,          <span class="comment">/* L32E instruction.  */</span>
<a name="l02118"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccaf0f2224c6e1ee30d0521f96336bfd44c">02118</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca12513f3f43a89449ad008aedd8a7a552">c0opc_s32e</a>,          <span class="comment">/* S32E instruction.  */</span>
<a name="l02119"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca80378338aa55d415d9427bf5b3adabeb">02119</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccaf0f2224c6e1ee30d0521f96336bfd44c">c0opc_rfwo</a>,          <span class="comment">/* RFWO instruction.  */</span>
<a name="l02120"></a><a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccaecfcba76d48aa04f844db6a6897bb77b">02120</a>   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca80378338aa55d415d9427bf5b3adabeb">c0opc_rfwu</a>,          <span class="comment">/* RFWU instruction.  */</span>
<a name="l02121"></a>02121   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccaecfcba76d48aa04f844db6a6897bb77b">c0opc_NrOf</a>           <span class="comment">/* Number of opcode classifications.  */</span>
<a name="l02122"></a>02122 } <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cc">xtensa_insn_kind</a>;
<a name="l02123"></a>02123 
<a name="l02124"></a>02124 <span class="comment">/* Return true,  if OPCNAME is RSR,  WRS,  or XSR instruction.  */</span>
<a name="l02125"></a>02125 
<a name="l02126"></a>02126 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02127"></a>02127 rwx_special_register (<span class="keyword">const</span> <span class="keywordtype">char</span> *opcname)
<a name="l02128"></a>02128 {
<a name="l02129"></a>02129   <span class="keywordtype">char</span> ch = *opcname++;
<a name="l02130"></a>02130   
<a name="l02131"></a>02131   <span class="keywordflow">if</span> ((ch != <span class="charliteral">&#39;r&#39;</span>) &amp;&amp; (ch != <span class="charliteral">&#39;w&#39;</span>) &amp;&amp; (ch != <span class="charliteral">&#39;x&#39;</span>))
<a name="l02132"></a>02132     <span class="keywordflow">return</span> 0;
<a name="l02133"></a>02133   <span class="keywordflow">if</span> (*opcname++ != <span class="charliteral">&#39;s&#39;</span>)
<a name="l02134"></a>02134     <span class="keywordflow">return</span> 0;
<a name="l02135"></a>02135   <span class="keywordflow">if</span> (*opcname++ != <span class="charliteral">&#39;r&#39;</span>)
<a name="l02136"></a>02136     <span class="keywordflow">return</span> 0;
<a name="l02137"></a>02137   <span class="keywordflow">if</span> (*opcname++ != <span class="charliteral">&#39;.&#39;</span>)
<a name="l02138"></a>02138     <span class="keywordflow">return</span> 0;
<a name="l02139"></a>02139 
<a name="l02140"></a>02140   <span class="keywordflow">return</span> 1;
<a name="l02141"></a>02141 }
<a name="l02142"></a>02142 
<a name="l02143"></a>02143 <span class="comment">/* Classify an opcode based on what it means for Call0 prologue analysis.  */</span>
<a name="l02144"></a>02144 
<a name="l02145"></a>02145 <span class="keyword">static</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cc">xtensa_insn_kind</a>
<a name="l02146"></a>02146 call0_classify_opcode (xtensa_isa isa, xtensa_opcode opc)
<a name="l02147"></a>02147 {
<a name="l02148"></a>02148   <span class="keyword">const</span> <span class="keywordtype">char</span> *opcname;
<a name="l02149"></a>02149   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cc">xtensa_insn_kind</a> opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca885e0de8061fad2b12f80c796ec63e7c">c0opc_uninteresting</a>;
<a name="l02150"></a>02150 
<a name="l02151"></a>02151   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;call0_classify_opcode (..., opc = %d)\n&quot;</span>, opc);
<a name="l02152"></a>02152 
<a name="l02153"></a>02153   <span class="comment">/* Get opcode name and handle special classifications.  */</span>
<a name="l02154"></a>02154 
<a name="l02155"></a>02155   opcname = xtensa_opcode_name (isa, opc);
<a name="l02156"></a>02156 
<a name="l02157"></a>02157   <span class="keywordflow">if</span> (opcname == NULL 
<a name="l02158"></a>02158       || strcasecmp (opcname, <span class="stringliteral">&quot;ill&quot;</span>) == 0
<a name="l02159"></a>02159       || strcasecmp (opcname, <span class="stringliteral">&quot;ill.n&quot;</span>) == 0)
<a name="l02160"></a>02160     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccaa7d04c2c707bf238bb7b14a7588ace4d">c0opc_illegal</a>;
<a name="l02161"></a>02161   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;break&quot;</span>) == 0
<a name="l02162"></a>02162            || strcasecmp (opcname, <span class="stringliteral">&quot;break.n&quot;</span>) == 0)
<a name="l02163"></a>02163      opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccad60e969c89418a848d5ad9dedb0c14a7">c0opc_break</a>;
<a name="l02164"></a>02164   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;entry&quot;</span>) == 0)
<a name="l02165"></a>02165     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca7d451d49c245e3d222877e68fbc2d1d8">c0opc_entry</a>;
<a name="l02166"></a>02166   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;rfwo&quot;</span>) == 0)
<a name="l02167"></a>02167     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccaf0f2224c6e1ee30d0521f96336bfd44c">c0opc_rfwo</a>;
<a name="l02168"></a>02168   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;rfwu&quot;</span>) == 0)
<a name="l02169"></a>02169     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca80378338aa55d415d9427bf5b3adabeb">c0opc_rfwu</a>;
<a name="l02170"></a>02170   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (xtensa_opcode_is_branch (isa, opc) &gt; 0
<a name="l02171"></a>02171            || xtensa_opcode_is_jump   (isa, opc) &gt; 0
<a name="l02172"></a>02172            || xtensa_opcode_is_loop   (isa, opc) &gt; 0
<a name="l02173"></a>02173            || xtensa_opcode_is_call   (isa, opc) &gt; 0
<a name="l02174"></a>02174            || strcasecmp (opcname, <span class="stringliteral">&quot;simcall&quot;</span>) == 0
<a name="l02175"></a>02175            || strcasecmp (opcname, <span class="stringliteral">&quot;syscall&quot;</span>) == 0)
<a name="l02176"></a>02176     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca9682c422984bf01156435b30b2cf1a31">c0opc_flow</a>;
<a name="l02177"></a>02177 
<a name="l02178"></a>02178   <span class="comment">/* Also, classify specific opcodes that need to be tracked.  */</span>
<a name="l02179"></a>02179   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;add&quot;</span>) == 0 
<a name="l02180"></a>02180            || strcasecmp (opcname, <span class="stringliteral">&quot;add.n&quot;</span>) == 0)
<a name="l02181"></a>02181     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca1febe7b92779e3787b34a1c839964d76">c0opc_add</a>;
<a name="l02182"></a>02182   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;and&quot;</span>) == 0)
<a name="l02183"></a>02183     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccacc1dc8b7dcc4570060ddfe6b7c8244ef">c0opc_and</a>;
<a name="l02184"></a>02184   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;addi&quot;</span>) == 0 
<a name="l02185"></a>02185            || strcasecmp (opcname, <span class="stringliteral">&quot;addi.n&quot;</span>) == 0
<a name="l02186"></a>02186            || strcasecmp (opcname, <span class="stringliteral">&quot;addmi&quot;</span>) == 0)
<a name="l02187"></a>02187     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca4dc99289360d5dfb47083f6654a875e4">c0opc_addi</a>;
<a name="l02188"></a>02188   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;sub&quot;</span>) == 0)
<a name="l02189"></a>02189     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca10eaf71a94942e5058746d26e5cde353">c0opc_sub</a>;
<a name="l02190"></a>02190   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;mov.n&quot;</span>) == 0
<a name="l02191"></a>02191            || strcasecmp (opcname, <span class="stringliteral">&quot;or&quot;</span>) == 0) <span class="comment">/* Could be &#39;mov&#39; asm macro.  */</span>
<a name="l02192"></a>02192     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca687ae834ae9de7fefe1dfea0877af0e0">c0opc_mov</a>;
<a name="l02193"></a>02193   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;movi&quot;</span>) == 0 
<a name="l02194"></a>02194            || strcasecmp (opcname, <span class="stringliteral">&quot;movi.n&quot;</span>) == 0)
<a name="l02195"></a>02195     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca3ed5a95a963b7dd79b0991b5aa0bf53f">c0opc_movi</a>;
<a name="l02196"></a>02196   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;l32r&quot;</span>) == 0)
<a name="l02197"></a>02197     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca700a97c98043eb0b8b99ef3d1c968af0">c0opc_l32r</a>;
<a name="l02198"></a>02198   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;s32i&quot;</span>) == 0 
<a name="l02199"></a>02199            || strcasecmp (opcname, <span class="stringliteral">&quot;s32i.n&quot;</span>) == 0)
<a name="l02200"></a>02200     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccad78c4ffa6ec78272e6e7a6121c40e136">c0opc_s32i</a>;
<a name="l02201"></a>02201   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;l32e&quot;</span>) == 0)
<a name="l02202"></a>02202     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca4d1fc811a76a6fdaf0d90e3770830f20">c0opc_l32e</a>;
<a name="l02203"></a>02203   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp (opcname, <span class="stringliteral">&quot;s32e&quot;</span>) == 0)
<a name="l02204"></a>02204     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca12513f3f43a89449ad008aedd8a7a552">c0opc_s32e</a>;
<a name="l02205"></a>02205   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rwx_special_register (opcname))
<a name="l02206"></a>02206     opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca74af960868aaea13019fcbe69aecb08b">c0opc_rwxsr</a>;
<a name="l02207"></a>02207 
<a name="l02208"></a>02208   <span class="keywordflow">return</span> opclass;
<a name="l02209"></a>02209 }
<a name="l02210"></a>02210 
<a name="l02211"></a>02211 <span class="comment">/* Tracks register movement/mutation for a given operation, which may</span>
<a name="l02212"></a>02212 <span class="comment">   be within a bundle.  Updates the destination register tracking info</span>
<a name="l02213"></a>02213 <span class="comment">   accordingly.  The pc is needed only for pc-relative load instructions</span>
<a name="l02214"></a>02214 <span class="comment">   (eg. l32r).  The SP register number is needed to identify stores to</span>
<a name="l02215"></a>02215 <span class="comment">   the stack frame.  Returns 0, if analysis was succesfull, non-zero</span>
<a name="l02216"></a>02216 <span class="comment">   otherwise.  */</span>
<a name="l02217"></a>02217 
<a name="l02218"></a>02218 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l02219"></a>02219 call0_track_op (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="xtensa-tdep_8c.html#aa24578348135491500f62ed2af882686">xtensa_c0reg_t</a> dst[], <a class="code" href="xtensa-tdep_8c.html#aa24578348135491500f62ed2af882686">xtensa_c0reg_t</a> src[],
<a name="l02220"></a>02220                 <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cc">xtensa_insn_kind</a> opclass, <span class="keywordtype">int</span> nods, <span class="keywordtype">unsigned</span> odv[],
<a name="l02221"></a>02221                 <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc, <span class="keywordtype">int</span> spreg, <a class="code" href="xtensa-tdep_8c.html#ac83c68c18f462e5e2661d376bd027d3e">xtensa_frame_cache_t</a> *cache)
<a name="l02222"></a>02222 {
<a name="l02223"></a>02223   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l02224"></a>02224   <span class="keywordtype">unsigned</span> litbase, litaddr, litval;
<a name="l02225"></a>02225 
<a name="l02226"></a>02226   <span class="keywordflow">switch</span> (opclass)
<a name="l02227"></a>02227     {
<a name="l02228"></a>02228     <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca4dc99289360d5dfb47083f6654a875e4">c0opc_addi</a>:
<a name="l02229"></a>02229       <span class="comment">/* 3 operands: dst, src, imm.  */</span>
<a name="l02230"></a>02230       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (nods == 3);
<a name="l02231"></a>02231       dst[odv[0]].fr_reg = src[odv[1]].fr_reg;
<a name="l02232"></a>02232       dst[odv[0]].fr_ofs = src[odv[1]].fr_ofs + odv[2];
<a name="l02233"></a>02233       <span class="keywordflow">break</span>;
<a name="l02234"></a>02234     <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca1febe7b92779e3787b34a1c839964d76">c0opc_add</a>:
<a name="l02235"></a>02235       <span class="comment">/* 3 operands: dst, src1, src2.  */</span>
<a name="l02236"></a>02236       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (nods == 3); 
<a name="l02237"></a>02237       <span class="keywordflow">if</span>      (src[odv[1]].fr_reg == <a class="code" href="xtensa-tdep_8c.html#af48d45d73d45634d1597d4071a933c23">C0_CONST</a>)
<a name="l02238"></a>02238         {
<a name="l02239"></a>02239           dst[odv[0]].fr_reg = src[odv[2]].fr_reg;
<a name="l02240"></a>02240           dst[odv[0]].fr_ofs = src[odv[2]].fr_ofs + src[odv[1]].fr_ofs;
<a name="l02241"></a>02241         }
<a name="l02242"></a>02242       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (src[odv[2]].fr_reg == <a class="code" href="xtensa-tdep_8c.html#af48d45d73d45634d1597d4071a933c23">C0_CONST</a>)
<a name="l02243"></a>02243         {
<a name="l02244"></a>02244           dst[odv[0]].fr_reg = src[odv[1]].fr_reg;
<a name="l02245"></a>02245           dst[odv[0]].fr_ofs = src[odv[1]].fr_ofs + src[odv[2]].fr_ofs;
<a name="l02246"></a>02246         }
<a name="l02247"></a>02247       <span class="keywordflow">else</span> dst[odv[0]].fr_reg = <a class="code" href="xtensa-tdep_8c.html#a51694ea2494265ce611e70196f1e9009">C0_INEXP</a>;
<a name="l02248"></a>02248       <span class="keywordflow">break</span>;
<a name="l02249"></a>02249     <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccacc1dc8b7dcc4570060ddfe6b7c8244ef">c0opc_and</a>:
<a name="l02250"></a>02250       <span class="comment">/* 3 operands:  dst, src1, src2.  */</span>
<a name="l02251"></a>02251       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (nods == 3);
<a name="l02252"></a>02252       <span class="keywordflow">if</span> (cache-&gt;c0.c0_fpalign == 0)
<a name="l02253"></a>02253         {
<a name="l02254"></a>02254           <span class="comment">/* Handle dynamic stack alignment.  */</span>
<a name="l02255"></a>02255           <span class="keywordflow">if</span> ((src[odv[0]].fr_reg == spreg) &amp;&amp; (src[odv[1]].fr_reg == spreg))
<a name="l02256"></a>02256             {
<a name="l02257"></a>02257               <span class="keywordflow">if</span> (src[odv[2]].fr_reg == <a class="code" href="xtensa-tdep_8c.html#af48d45d73d45634d1597d4071a933c23">C0_CONST</a>)
<a name="l02258"></a>02258                 cache-&gt;c0.c0_fpalign = src[odv[2]].fr_ofs;
<a name="l02259"></a>02259               <span class="keywordflow">break</span>;
<a name="l02260"></a>02260             }
<a name="l02261"></a>02261           <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((src[odv[0]].fr_reg == spreg)
<a name="l02262"></a>02262                    &amp;&amp; (src[odv[2]].fr_reg == spreg))
<a name="l02263"></a>02263             {
<a name="l02264"></a>02264               <span class="keywordflow">if</span> (src[odv[1]].fr_reg == <a class="code" href="xtensa-tdep_8c.html#af48d45d73d45634d1597d4071a933c23">C0_CONST</a>)
<a name="l02265"></a>02265                 cache-&gt;c0.c0_fpalign = src[odv[1]].fr_ofs;
<a name="l02266"></a>02266               <span class="keywordflow">break</span>;
<a name="l02267"></a>02267             }
<a name="l02268"></a>02268           <span class="comment">/* else fall through.  */</span>
<a name="l02269"></a>02269         }
<a name="l02270"></a>02270       <span class="keywordflow">if</span>      (src[odv[1]].fr_reg == <a class="code" href="xtensa-tdep_8c.html#af48d45d73d45634d1597d4071a933c23">C0_CONST</a>)
<a name="l02271"></a>02271         {
<a name="l02272"></a>02272           dst[odv[0]].fr_reg = src[odv[2]].fr_reg;
<a name="l02273"></a>02273           dst[odv[0]].fr_ofs = src[odv[2]].fr_ofs &amp; src[odv[1]].fr_ofs;
<a name="l02274"></a>02274         }
<a name="l02275"></a>02275       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (src[odv[2]].fr_reg == <a class="code" href="xtensa-tdep_8c.html#af48d45d73d45634d1597d4071a933c23">C0_CONST</a>)
<a name="l02276"></a>02276         {
<a name="l02277"></a>02277           dst[odv[0]].fr_reg = src[odv[1]].fr_reg;
<a name="l02278"></a>02278           dst[odv[0]].fr_ofs = src[odv[1]].fr_ofs &amp; src[odv[2]].fr_ofs;
<a name="l02279"></a>02279         }
<a name="l02280"></a>02280       <span class="keywordflow">else</span> dst[odv[0]].fr_reg = <a class="code" href="xtensa-tdep_8c.html#a51694ea2494265ce611e70196f1e9009">C0_INEXP</a>;
<a name="l02281"></a>02281       <span class="keywordflow">break</span>;
<a name="l02282"></a>02282     <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca10eaf71a94942e5058746d26e5cde353">c0opc_sub</a>:
<a name="l02283"></a>02283       <span class="comment">/* 3 operands: dst, src1, src2.  */</span>
<a name="l02284"></a>02284       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (nods == 3);
<a name="l02285"></a>02285       <span class="keywordflow">if</span>      (src[odv[2]].fr_reg == <a class="code" href="xtensa-tdep_8c.html#af48d45d73d45634d1597d4071a933c23">C0_CONST</a>)
<a name="l02286"></a>02286         {
<a name="l02287"></a>02287           dst[odv[0]].fr_reg = src[odv[1]].fr_reg;
<a name="l02288"></a>02288           dst[odv[0]].fr_ofs = src[odv[1]].fr_ofs - src[odv[2]].fr_ofs;
<a name="l02289"></a>02289         }
<a name="l02290"></a>02290       <span class="keywordflow">else</span> dst[odv[0]].fr_reg = <a class="code" href="xtensa-tdep_8c.html#a51694ea2494265ce611e70196f1e9009">C0_INEXP</a>;
<a name="l02291"></a>02291       <span class="keywordflow">break</span>;
<a name="l02292"></a>02292     <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca687ae834ae9de7fefe1dfea0877af0e0">c0opc_mov</a>:
<a name="l02293"></a>02293       <span class="comment">/* 2 operands: dst, src [, src].  */</span>
<a name="l02294"></a>02294       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (nods == 2);
<a name="l02295"></a>02295       <span class="comment">/* First, check if it&#39;s a special case of saving unaligned SP</span>
<a name="l02296"></a>02296 <span class="comment">         to a spare register in case of dynamic stack adjustment.</span>
<a name="l02297"></a>02297 <span class="comment">         But, only do it one time.  The second time could be initializing</span>
<a name="l02298"></a>02298 <span class="comment">         frame pointer.  We don&#39;t want to overwrite the first one.  */</span>
<a name="l02299"></a>02299       <span class="keywordflow">if</span> ((odv[1] == spreg) &amp;&amp; (cache-&gt;c0.c0_old_sp == <a class="code" href="xtensa-tdep_8c.html#a51694ea2494265ce611e70196f1e9009">C0_INEXP</a>))
<a name="l02300"></a>02300         cache-&gt;c0.c0_old_sp = odv[0];
<a name="l02301"></a>02301 
<a name="l02302"></a>02302       dst[odv[0]].fr_reg = src[odv[1]].fr_reg;
<a name="l02303"></a>02303       dst[odv[0]].fr_ofs = src[odv[1]].fr_ofs;
<a name="l02304"></a>02304       <span class="keywordflow">break</span>;
<a name="l02305"></a>02305     <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca3ed5a95a963b7dd79b0991b5aa0bf53f">c0opc_movi</a>:
<a name="l02306"></a>02306       <span class="comment">/* 2 operands: dst, imm.  */</span>
<a name="l02307"></a>02307       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (nods == 2);
<a name="l02308"></a>02308       dst[odv[0]].fr_reg = <a class="code" href="xtensa-tdep_8c.html#af48d45d73d45634d1597d4071a933c23">C0_CONST</a>;
<a name="l02309"></a>02309       dst[odv[0]].fr_ofs = odv[1];
<a name="l02310"></a>02310       <span class="keywordflow">break</span>;
<a name="l02311"></a>02311     <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca700a97c98043eb0b8b99ef3d1c968af0">c0opc_l32r</a>:
<a name="l02312"></a>02312       <span class="comment">/* 2 operands: dst, literal offset.  */</span>
<a name="l02313"></a>02313       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (nods == 2);
<a name="l02314"></a>02314       <span class="comment">/* litbase = xtensa_get_litbase (pc);  can be also used.  */</span>
<a name="l02315"></a>02315       litbase = (<a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a0623d3dd80a969d0e7986fc4db27f9f2">litbase_regnum</a> == -1)
<a name="l02316"></a>02316         ? 0 : xtensa_read_register
<a name="l02317"></a>02317                 (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a0623d3dd80a969d0e7986fc4db27f9f2">litbase_regnum</a>);
<a name="l02318"></a>02318       litaddr = litbase &amp; 1
<a name="l02319"></a>02319                   ? (litbase &amp; ~1) + (<span class="keywordtype">signed</span>)odv[1]
<a name="l02320"></a>02320                   : (pc + 3  + (<span class="keywordtype">signed</span>)odv[1]) &amp; ~3;
<a name="l02321"></a>02321       litval = <a class="code" href="corefile_8c.html#a7097ab90f56ed7bcceb190bab139621b">read_memory_integer</a> (litaddr, 4, byte_order);
<a name="l02322"></a>02322       dst[odv[0]].fr_reg = <a class="code" href="xtensa-tdep_8c.html#af48d45d73d45634d1597d4071a933c23">C0_CONST</a>;
<a name="l02323"></a>02323       dst[odv[0]].fr_ofs = litval;
<a name="l02324"></a>02324       break;
<a name="l02325"></a>02325     case <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccad78c4ffa6ec78272e6e7a6121c40e136">c0opc_s32i</a>:
<a name="l02326"></a>02326       <span class="comment">/* 3 operands: value, base, offset.  */</span>
<a name="l02327"></a>02327       <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (nods == 3 &amp;&amp; spreg &gt;= 0 &amp;&amp; spreg &lt; <a class="code" href="xtensa-tdep_8c.html#a78bb729d39d6d29c761515a76d68eb68">C0_NREGS</a>);
<a name="l02328"></a>02328       <span class="comment">/* First, check if it&#39;s a spill for saved unaligned SP,</span>
<a name="l02329"></a>02329 <span class="comment">         when dynamic stack adjustment was applied to this frame.  */</span>
<a name="l02330"></a>02330       if ((cache-&gt;c0.c0_fpalign != 0)           <span class="comment">/* Dynamic stack adjustment.  */</span>
<a name="l02331"></a>02331           &amp;&amp; (odv[1] == spreg)                  <span class="comment">/* SP usage indicates spill.  */</span>
<a name="l02332"></a>02332           &amp;&amp; (odv[0] == cache-&gt;c0.c0_old_sp))   <span class="comment">/* Old SP register spilled.  */</span>
<a name="l02333"></a>02333         cache-&gt;c0.c0_sp_ofs = odv[2];
<a name="l02334"></a>02334 
<a name="l02335"></a>02335       if (src[odv[1]].fr_reg == spreg        <span class="comment">/* Store to stack frame.  */</span>
<a name="l02336"></a>02336           &amp;&amp; (src[odv[1]].fr_ofs &amp; 3) == 0   <span class="comment">/* Alignment preserved.  */</span>
<a name="l02337"></a>02337           &amp;&amp;  src[odv[0]].fr_reg &gt;= 0        <span class="comment">/* Value is from a register.  */</span>
<a name="l02338"></a>02338           &amp;&amp;  src[odv[0]].fr_ofs == 0        <span class="comment">/* Value hasn&#39;t been modified.  */</span>
<a name="l02339"></a>02339           &amp;&amp;  src[src[odv[0]].fr_reg].to_stk == <a class="code" href="xtensa-tdep_8c.html#a3e9badad6b26919da866065d6f3a3573">C0_NOSTK</a>) <span class="comment">/* First time.  */</span>
<a name="l02340"></a>02340         {
<a name="l02341"></a>02341           <span class="comment">/* ISA encoding guarantees alignment.  But, check it anyway.  */</span>
<a name="l02342"></a>02342           <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> ((odv[2] &amp; 3) == 0);
<a name="l02343"></a>02343           dst[src[odv[0]].fr_reg].to_stk = src[odv[1]].fr_ofs + odv[2];
<a name="l02344"></a>02344         }
<a name="l02345"></a>02345       <span class="keywordflow">break</span>;
<a name="l02346"></a>02346       <span class="comment">/* If we end up inside Window Overflow / Underflow interrupt handler</span>
<a name="l02347"></a>02347 <span class="comment">         report an error because these handlers should have been handled</span>
<a name="l02348"></a>02348 <span class="comment">         already in a different way.  */</span>
<a name="l02349"></a>02349     <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca4d1fc811a76a6fdaf0d90e3770830f20">c0opc_l32e</a>:
<a name="l02350"></a>02350     <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca12513f3f43a89449ad008aedd8a7a552">c0opc_s32e</a>:
<a name="l02351"></a>02351     <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccaf0f2224c6e1ee30d0521f96336bfd44c">c0opc_rfwo</a>:
<a name="l02352"></a>02352     <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca80378338aa55d415d9427bf5b3adabeb">c0opc_rfwu</a>:
<a name="l02353"></a>02353       <span class="keywordflow">return</span> 1;
<a name="l02354"></a>02354     <span class="keywordflow">default</span>:
<a name="l02355"></a>02355       <span class="keywordflow">return</span> 1;
<a name="l02356"></a>02356     }
<a name="l02357"></a>02357   <span class="keywordflow">return</span> 0;
<a name="l02358"></a>02358 }
<a name="l02359"></a>02359 
<a name="l02360"></a>02360 <span class="comment">/* Analyze prologue of the function at start address to determine if it uses</span>
<a name="l02361"></a>02361 <span class="comment">   the Call0 ABI, and if so track register moves and linear modifications</span>
<a name="l02362"></a>02362 <span class="comment">   in the prologue up to the PC or just beyond the prologue, whichever is</span>
<a name="l02363"></a>02363 <span class="comment">   first. An &#39;entry&#39; instruction indicates non-Call0 ABI and the end of the</span>
<a name="l02364"></a>02364 <span class="comment">   prologue. The prologue may overlap non-prologue instructions but is</span>
<a name="l02365"></a>02365 <span class="comment">   guaranteed to end by the first flow-control instruction (jump, branch,</span>
<a name="l02366"></a>02366 <span class="comment">   call or return).  Since an optimized function may move information around</span>
<a name="l02367"></a>02367 <span class="comment">   and change the stack frame arbitrarily during the prologue, the information</span>
<a name="l02368"></a>02368 <span class="comment">   is guaranteed valid only at the point in the function indicated by the PC.</span>
<a name="l02369"></a>02369 <span class="comment">   May be used to skip the prologue or identify the ABI, w/o tracking.</span>
<a name="l02370"></a>02370 <span class="comment"></span>
<a name="l02371"></a>02371 <span class="comment">   Returns:   Address of first instruction after prologue, or PC (whichever </span>
<a name="l02372"></a>02372 <span class="comment">              is first), or 0, if decoding failed (in libisa).</span>
<a name="l02373"></a>02373 <span class="comment">   Input args:</span>
<a name="l02374"></a>02374 <span class="comment">      start   Start address of function/prologue.</span>
<a name="l02375"></a>02375 <span class="comment">      pc      Program counter to stop at.  Use 0 to continue to end of prologue.</span>
<a name="l02376"></a>02376 <span class="comment">              If 0, avoids infinite run-on in corrupt code memory by bounding</span>
<a name="l02377"></a>02377 <span class="comment">              the scan to the end of the function if that can be determined.</span>
<a name="l02378"></a>02378 <span class="comment">      nregs   Number of general registers to track.</span>
<a name="l02379"></a>02379 <span class="comment">   InOut args:</span>
<a name="l02380"></a>02380 <span class="comment">      cache   Xtensa frame cache.</span>
<a name="l02381"></a>02381 <span class="comment"></span>
<a name="l02382"></a>02382 <span class="comment">      Note that these may produce useful results even if decoding fails</span>
<a name="l02383"></a>02383 <span class="comment">      because they begin with default assumptions that analysis may change.  */</span>
<a name="l02384"></a>02384 
<a name="l02385"></a>02385 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l02386"></a>02386 call0_analyze_prologue (<span class="keyword">struct</span> gdbarch *gdbarch,
<a name="l02387"></a>02387                         <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc,
<a name="l02388"></a>02388                         <span class="keywordtype">int</span> nregs, <a class="code" href="xtensa-tdep_8c.html#ac83c68c18f462e5e2661d376bd027d3e">xtensa_frame_cache_t</a> *cache)
<a name="l02389"></a>02389 {
<a name="l02390"></a>02390   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ia;             <span class="comment">/* Current insn address in prologue.  */</span>
<a name="l02391"></a>02391   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ba = 0;         <span class="comment">/* Current address at base of insn buffer.  */</span>
<a name="l02392"></a>02392   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> bt;             <span class="comment">/* Current address at top+1 of insn buffer.  */</span>
<a name="l02393"></a>02393   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> ibuf[<a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a>];<span class="comment">/* Instruction buffer for decoding prologue.  */</span>
<a name="l02394"></a>02394   xtensa_isa isa;           <span class="comment">/* libisa ISA handle.  */</span>
<a name="l02395"></a>02395   xtensa_insnbuf ins, slot; <span class="comment">/* libisa handle to decoded insn, slot.  */</span>
<a name="l02396"></a>02396   xtensa_format ifmt;       <span class="comment">/* libisa instruction format.  */</span>
<a name="l02397"></a>02397   <span class="keywordtype">int</span> ilen, islots, is;     <span class="comment">/* Instruction length, nbr slots, current slot.  */</span>
<a name="l02398"></a>02398   xtensa_opcode opc;        <span class="comment">/* Opcode in current slot.  */</span>
<a name="l02399"></a>02399   <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cc">xtensa_insn_kind</a> opclass; <span class="comment">/* Opcode class for Call0 prologue analysis.  */</span>
<a name="l02400"></a>02400   <span class="keywordtype">int</span> nods;                 <span class="comment">/* Opcode number of operands.  */</span>
<a name="l02401"></a>02401   <span class="keywordtype">unsigned</span> odv[<a class="code" href="xtensa-tdep_8c.html#a5bea1a2b0ec115ce00d86b1a409770a9">C0_MAXOPDS</a>]; <span class="comment">/* Operand values in order provided by libisa.  */</span>
<a name="l02402"></a>02402   <a class="code" href="xtensa-tdep_8c.html#aa24578348135491500f62ed2af882686">xtensa_c0reg_t</a> *rtmp;     <span class="comment">/* Register tracking info snapshot.  */</span>
<a name="l02403"></a>02403   <span class="keywordtype">int</span> j;                    <span class="comment">/* General loop counter.  */</span>
<a name="l02404"></a>02404   <span class="keywordtype">int</span> fail = 0;             <span class="comment">/* Set non-zero and exit, if decoding fails.  */</span>
<a name="l02405"></a>02405   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> body_pc;        <span class="comment">/* The PC for the first non-prologue insn.  */</span>
<a name="l02406"></a>02406   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> end_pc;         <span class="comment">/* The PC for the lust function insn.  */</span>
<a name="l02407"></a>02407 
<a name="l02408"></a>02408   <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a> prologue_sal;
<a name="l02409"></a>02409 
<a name="l02410"></a>02410   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;call0_analyze_prologue (start = 0x%08x, pc = 0x%08x, ...)\n&quot;</span>, 
<a name="l02411"></a>02411               (<span class="keywordtype">int</span>)start, (<span class="keywordtype">int</span>)pc);
<a name="l02412"></a>02412 
<a name="l02413"></a>02413   <span class="comment">/* Try to limit the scan to the end of the function if a non-zero pc</span>
<a name="l02414"></a>02414 <span class="comment">     arg was not supplied to avoid probing beyond the end of valid memory.</span>
<a name="l02415"></a>02415 <span class="comment">     If memory is full of garbage that classifies as c0opc_uninteresting.</span>
<a name="l02416"></a>02416 <span class="comment">     If this fails (eg. if no symbols) pc ends up 0 as it was.</span>
<a name="l02417"></a>02417 <span class="comment">     Intialize the Call0 frame and register tracking info.</span>
<a name="l02418"></a>02418 <span class="comment">     Assume it&#39;s Call0 until an &#39;entry&#39; instruction is encountered.</span>
<a name="l02419"></a>02419 <span class="comment">     Assume we may be in the prologue until we hit a flow control instr.  */</span>
<a name="l02420"></a>02420 
<a name="l02421"></a>02421   rtmp = NULL;
<a name="l02422"></a>02422   body_pc = UINT_MAX;
<a name="l02423"></a>02423   end_pc = 0;
<a name="l02424"></a>02424 
<a name="l02425"></a>02425   <span class="comment">/* Find out, if we have an information about the prologue from DWARF.  */</span>
<a name="l02426"></a>02426   prologue_sal = <a class="code" href="symtab_8c.html#ad9bbd85700e3d7fa50e7ba0e32f37846">find_pc_line</a> (start, 0);
<a name="l02427"></a>02427   <span class="keywordflow">if</span> (prologue_sal.line != 0) <span class="comment">/* Found debug info.  */</span>
<a name="l02428"></a>02428     body_pc = prologue_sal.end;
<a name="l02429"></a>02429 
<a name="l02430"></a>02430   <span class="comment">/* If we are going to analyze the prologue in general without knowing about</span>
<a name="l02431"></a>02431 <span class="comment">     the current PC, make the best assumtion for the end of the prologue.  */</span>
<a name="l02432"></a>02432   <span class="keywordflow">if</span> (pc == 0)
<a name="l02433"></a>02433     {
<a name="l02434"></a>02434       <a class="code" href="blockframe_8c.html#a2dae2257ad1417604d2c26f8b9071ca9">find_pc_partial_function</a> (start, 0, NULL, &amp;end_pc);
<a name="l02435"></a>02435       body_pc = <a class="code" href="environ_8c.html#ac6afabdc09a49a433ee19d8a9486056d">min</a> (end_pc, body_pc);
<a name="l02436"></a>02436     }
<a name="l02437"></a>02437   <span class="keywordflow">else</span>
<a name="l02438"></a>02438     body_pc = <a class="code" href="environ_8c.html#ac6afabdc09a49a433ee19d8a9486056d">min</a> (pc, body_pc);
<a name="l02439"></a>02439 
<a name="l02440"></a>02440   cache-&gt;call0 = 1;
<a name="l02441"></a>02441   rtmp = (<a class="code" href="xtensa-tdep_8c.html#aa24578348135491500f62ed2af882686">xtensa_c0reg_t</a>*) alloca(nregs * <span class="keyword">sizeof</span>(<a class="code" href="xtensa-tdep_8c.html#aa24578348135491500f62ed2af882686">xtensa_c0reg_t</a>));
<a name="l02442"></a>02442 
<a name="l02443"></a>02443   <span class="keywordflow">if</span> (!xtensa_default_isa)
<a name="l02444"></a>02444     xtensa_default_isa = xtensa_isa_init (0, 0);
<a name="l02445"></a>02445   isa = xtensa_default_isa;
<a name="l02446"></a>02446   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a> &gt;= xtensa_isa_maxlength (isa));
<a name="l02447"></a>02447   ins = xtensa_insnbuf_alloc (isa);
<a name="l02448"></a>02448   slot = xtensa_insnbuf_alloc (isa);
<a name="l02449"></a>02449 
<a name="l02450"></a>02450   <span class="keywordflow">for</span> (ia = start, bt = ia; ia &lt; body_pc ; ia += ilen)
<a name="l02451"></a>02451     {
<a name="l02452"></a>02452       <span class="comment">/* (Re)fill instruction buffer from memory if necessary, but do not</span>
<a name="l02453"></a>02453 <span class="comment">         read memory beyond PC to be sure we stay within text section</span>
<a name="l02454"></a>02454 <span class="comment">         (this protection only works if a non-zero pc is supplied).  */</span>
<a name="l02455"></a>02455 
<a name="l02456"></a>02456       <span class="keywordflow">if</span> (ia + xtensa_isa_maxlength (isa) &gt; bt)
<a name="l02457"></a>02457         {
<a name="l02458"></a>02458           ba = ia;
<a name="l02459"></a>02459           bt = (ba + <a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a>) &lt; body_pc ? ba + <a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a> : body_pc;
<a name="l02460"></a>02460           <span class="keywordflow">if</span> (<a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (ba, ibuf, bt - ba) != 0 )
<a name="l02461"></a>02461             <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unable to read target memory ...&quot;</span>));
<a name="l02462"></a>02462         }
<a name="l02463"></a>02463 
<a name="l02464"></a>02464       <span class="comment">/* Decode format information.  */</span>
<a name="l02465"></a>02465 
<a name="l02466"></a>02466       xtensa_insnbuf_from_chars (isa, ins, &amp;ibuf[ia-ba], 0);
<a name="l02467"></a>02467       ifmt = xtensa_format_decode (isa, ins);
<a name="l02468"></a>02468       <span class="keywordflow">if</span> (ifmt == XTENSA_UNDEFINED)
<a name="l02469"></a>02469         {
<a name="l02470"></a>02470           fail = 1;
<a name="l02471"></a>02471           <span class="keywordflow">goto</span> done;
<a name="l02472"></a>02472         }
<a name="l02473"></a>02473       ilen = xtensa_format_length (isa, ifmt);
<a name="l02474"></a>02474       <span class="keywordflow">if</span> (ilen == XTENSA_UNDEFINED)
<a name="l02475"></a>02475         {
<a name="l02476"></a>02476           fail = 1;
<a name="l02477"></a>02477           <span class="keywordflow">goto</span> done;
<a name="l02478"></a>02478         }
<a name="l02479"></a>02479       islots = xtensa_format_num_slots (isa, ifmt);
<a name="l02480"></a>02480       <span class="keywordflow">if</span> (islots == XTENSA_UNDEFINED)
<a name="l02481"></a>02481         {
<a name="l02482"></a>02482           fail = 1;
<a name="l02483"></a>02483           <span class="keywordflow">goto</span> done;
<a name="l02484"></a>02484         }
<a name="l02485"></a>02485 
<a name="l02486"></a>02486       <span class="comment">/* Analyze a bundle or a single instruction, using a snapshot of </span>
<a name="l02487"></a>02487 <span class="comment">         the register tracking info as input for the entire bundle so that</span>
<a name="l02488"></a>02488 <span class="comment">         register changes do not take effect within this bundle.  */</span>
<a name="l02489"></a>02489 
<a name="l02490"></a>02490       <span class="keywordflow">for</span> (j = 0; j &lt; nregs; ++j)
<a name="l02491"></a>02491         rtmp[j] = cache-&gt;c0.c0_rt[j];
<a name="l02492"></a>02492 
<a name="l02493"></a>02493       for (is = 0; is &lt; islots; ++is)
<a name="l02494"></a>02494         {
<a name="l02495"></a>02495           <span class="comment">/* Decode a slot and classify the opcode.  */</span>
<a name="l02496"></a>02496 
<a name="l02497"></a>02497           fail = xtensa_format_get_slot (isa, ifmt, is, ins, slot);
<a name="l02498"></a>02498           <span class="keywordflow">if</span> (fail)
<a name="l02499"></a>02499             <span class="keywordflow">goto</span> done;
<a name="l02500"></a>02500 
<a name="l02501"></a>02501           opc = xtensa_opcode_decode (isa, ifmt, is, slot);
<a name="l02502"></a>02502           <a class="code" href="xtensa-tdep_8c.html#a16ed05e44161b1f9925d14269a794219">DEBUGVERB</a> (<span class="stringliteral">&quot;[call0_analyze_prologue] instr addr = 0x%08x, opc = %d\n&quot;</span>, 
<a name="l02503"></a>02503                      (<span class="keywordtype">unsigned</span>)ia, opc);
<a name="l02504"></a>02504           <span class="keywordflow">if</span> (opc == XTENSA_UNDEFINED) 
<a name="l02505"></a>02505             opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccaa7d04c2c707bf238bb7b14a7588ace4d">c0opc_illegal</a>;
<a name="l02506"></a>02506           <span class="keywordflow">else</span>
<a name="l02507"></a>02507             opclass = call0_classify_opcode (isa, opc);
<a name="l02508"></a>02508 
<a name="l02509"></a>02509           <span class="comment">/* Decide whether to track this opcode, ignore it, or bail out.  */</span>
<a name="l02510"></a>02510 
<a name="l02511"></a>02511           <span class="keywordflow">switch</span> (opclass)
<a name="l02512"></a>02512             {
<a name="l02513"></a>02513             <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccaa7d04c2c707bf238bb7b14a7588ace4d">c0opc_illegal</a>:
<a name="l02514"></a>02514             <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccad60e969c89418a848d5ad9dedb0c14a7">c0opc_break</a>:
<a name="l02515"></a>02515               fail = 1;
<a name="l02516"></a>02516               <span class="keywordflow">goto</span> done;
<a name="l02517"></a>02517 
<a name="l02518"></a>02518             <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca885e0de8061fad2b12f80c796ec63e7c">c0opc_uninteresting</a>:
<a name="l02519"></a>02519               <span class="keywordflow">continue</span>;
<a name="l02520"></a>02520 
<a name="l02521"></a>02521             <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca9682c422984bf01156435b30b2cf1a31">c0opc_flow</a>:  <span class="comment">/* Flow control instructions stop analysis.  */</span>
<a name="l02522"></a>02522             <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca74af960868aaea13019fcbe69aecb08b">c0opc_rwxsr</a>: <span class="comment">/* RSR, WSR, XSR instructions stop analysis.  */</span>
<a name="l02523"></a>02523               <span class="keywordflow">goto</span> done;
<a name="l02524"></a>02524 
<a name="l02525"></a>02525             <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca7d451d49c245e3d222877e68fbc2d1d8">c0opc_entry</a>:
<a name="l02526"></a>02526               cache-&gt;call0 = 0;
<a name="l02527"></a>02527               ia += ilen;               <span class="comment">/* Skip over &#39;entry&#39; insn.  */</span>
<a name="l02528"></a>02528               <span class="keywordflow">goto</span> done;
<a name="l02529"></a>02529 
<a name="l02530"></a>02530             <span class="keywordflow">default</span>:
<a name="l02531"></a>02531               cache-&gt;call0 = 1;
<a name="l02532"></a>02532             }
<a name="l02533"></a>02533 
<a name="l02534"></a>02534           <span class="comment">/* Only expected opcodes should get this far.  */</span>
<a name="l02535"></a>02535 
<a name="l02536"></a>02536           <span class="comment">/* Extract and decode the operands.  */</span>
<a name="l02537"></a>02537           nods = xtensa_opcode_num_operands (isa, opc);
<a name="l02538"></a>02538           <span class="keywordflow">if</span> (nods == XTENSA_UNDEFINED)
<a name="l02539"></a>02539             {
<a name="l02540"></a>02540               fail = 1;
<a name="l02541"></a>02541               <span class="keywordflow">goto</span> done;
<a name="l02542"></a>02542             }
<a name="l02543"></a>02543 
<a name="l02544"></a>02544           <span class="keywordflow">for</span> (j = 0; j &lt; nods &amp;&amp; j &lt; <a class="code" href="xtensa-tdep_8c.html#a5bea1a2b0ec115ce00d86b1a409770a9">C0_MAXOPDS</a>; ++j)
<a name="l02545"></a>02545             {
<a name="l02546"></a>02546               fail = xtensa_operand_get_field (isa, opc, j, ifmt, 
<a name="l02547"></a>02547                                                is, slot, &amp;odv[j]);
<a name="l02548"></a>02548               <span class="keywordflow">if</span> (fail)
<a name="l02549"></a>02549                 <span class="keywordflow">goto</span> done;
<a name="l02550"></a>02550 
<a name="l02551"></a>02551               fail = xtensa_operand_decode (isa, opc, j, &amp;odv[j]);
<a name="l02552"></a>02552               <span class="keywordflow">if</span> (fail)
<a name="l02553"></a>02553                 <span class="keywordflow">goto</span> done;
<a name="l02554"></a>02554             }
<a name="l02555"></a>02555 
<a name="l02556"></a>02556           <span class="comment">/* Check operands to verify use of &#39;mov&#39; assembler macro.  */</span>
<a name="l02557"></a>02557           <span class="keywordflow">if</span> (opclass == <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca687ae834ae9de7fefe1dfea0877af0e0">c0opc_mov</a> &amp;&amp; nods == 3)
<a name="l02558"></a>02558             {
<a name="l02559"></a>02559               <span class="keywordflow">if</span> (odv[2] == odv[1])
<a name="l02560"></a>02560                 {
<a name="l02561"></a>02561                   nods = 2;
<a name="l02562"></a>02562                   <span class="keywordflow">if</span> ((odv[0] == 1) &amp;&amp; (odv[1] != 1))
<a name="l02563"></a>02563                     <span class="comment">/* OR  A1, An, An  , where n != 1.</span>
<a name="l02564"></a>02564 <span class="comment">                       This means we are inside epilogue already.  */</span>
<a name="l02565"></a>02565                     <span class="keywordflow">goto</span> done;
<a name="l02566"></a>02566                 }
<a name="l02567"></a>02567               <span class="keywordflow">else</span>
<a name="l02568"></a>02568                 {
<a name="l02569"></a>02569                   opclass = <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca885e0de8061fad2b12f80c796ec63e7c">c0opc_uninteresting</a>;
<a name="l02570"></a>02570                   <span class="keywordflow">continue</span>;
<a name="l02571"></a>02571                 }
<a name="l02572"></a>02572             }
<a name="l02573"></a>02573 
<a name="l02574"></a>02574           <span class="comment">/* Track register movement and modification for this operation.  */</span>
<a name="l02575"></a>02575           fail = call0_track_op (gdbarch, cache-&gt;c0.c0_rt, rtmp,
<a name="l02576"></a>02576                                  opclass, nods, odv, ia, 1, cache);
<a name="l02577"></a>02577           <span class="keywordflow">if</span> (fail)
<a name="l02578"></a>02578             <span class="keywordflow">goto</span> done;
<a name="l02579"></a>02579         }
<a name="l02580"></a>02580     }
<a name="l02581"></a>02581 done:
<a name="l02582"></a>02582   <a class="code" href="xtensa-tdep_8c.html#a16ed05e44161b1f9925d14269a794219">DEBUGVERB</a> (<span class="stringliteral">&quot;[call0_analyze_prologue] stopped at instr addr 0x%08x, %s\n&quot;</span>,
<a name="l02583"></a>02583              (<span class="keywordtype">unsigned</span>)ia, fail ? <span class="stringliteral">&quot;failed&quot;</span> : <span class="stringliteral">&quot;succeeded&quot;</span>);
<a name="l02584"></a>02584   xtensa_insnbuf_free(isa, slot);
<a name="l02585"></a>02585   xtensa_insnbuf_free(isa, ins);
<a name="l02586"></a>02586   <span class="keywordflow">return</span> fail ? <a class="code" href="xtensa-tdep_8c.html#a1f53797feed61a873a510d9732de3349">XTENSA_ISA_BADPC</a> : ia;
<a name="l02587"></a>02587 }
<a name="l02588"></a>02588 
<a name="l02589"></a>02589 <span class="comment">/* Initialize frame cache for the current frame in CALL0 ABI.  */</span>
<a name="l02590"></a>02590 
<a name="l02591"></a>02591 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02592"></a>02592 call0_frame_cache (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l02593"></a>02593                    <a class="code" href="xtensa-tdep_8c.html#ac83c68c18f462e5e2661d376bd027d3e">xtensa_frame_cache_t</a> *cache, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc)
<a name="l02594"></a>02594 {
<a name="l02595"></a>02595   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame);
<a name="l02596"></a>02596   <span class="keyword">enum</span> bfd_endian byte_order = <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch);
<a name="l02597"></a>02597   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_pc;           <span class="comment">/* The beginning of the function.  */</span>
<a name="l02598"></a>02598   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> body_pc=UINT_MAX;   <span class="comment">/* PC, where prologue analysis stopped.  */</span>
<a name="l02599"></a>02599   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> sp, fp, ra;
<a name="l02600"></a>02600   <span class="keywordtype">int</span> fp_regnum = <a class="code" href="xtensa-tdep_8c.html#a90c61cc2de5068f3d0dadbca1611ca4d">C0_SP</a>, c0_hasfp = 0, c0_frmsz = 0, prev_sp = 0, to_stk;
<a name="l02601"></a>02601  
<a name="l02602"></a>02602   sp = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a>
<a name="l02603"></a>02603     (this_frame, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 1);
<a name="l02604"></a>02604   fp = sp; <span class="comment">/* Assume FP == SP until proven otherwise.  */</span>
<a name="l02605"></a>02605 
<a name="l02606"></a>02606   <span class="comment">/* Find the beginning of the prologue of the function containing the PC</span>
<a name="l02607"></a>02607 <span class="comment">     and analyze it up to the PC or the end of the prologue.  */</span>
<a name="l02608"></a>02608 
<a name="l02609"></a>02609   <span class="keywordflow">if</span> (<a class="code" href="blockframe_8c.html#a2dae2257ad1417604d2c26f8b9071ca9">find_pc_partial_function</a> (pc, NULL, &amp;start_pc, NULL))
<a name="l02610"></a>02610     {
<a name="l02611"></a>02611       body_pc = call0_analyze_prologue (gdbarch, start_pc, pc, <a class="code" href="xtensa-tdep_8c.html#a78bb729d39d6d29c761515a76d68eb68">C0_NREGS</a>, cache);
<a name="l02612"></a>02612 
<a name="l02613"></a>02613       <span class="keywordflow">if</span> (body_pc == <a class="code" href="xtensa-tdep_8c.html#a1f53797feed61a873a510d9732de3349">XTENSA_ISA_BADPC</a>)
<a name="l02614"></a>02614         {
<a name="l02615"></a>02615           warning_once ();
<a name="l02616"></a>02616           ra = 0;
<a name="l02617"></a>02617           <span class="keywordflow">goto</span> finish_frame_analysis;
<a name="l02618"></a>02618         }
<a name="l02619"></a>02619     }
<a name="l02620"></a>02620   
<a name="l02621"></a>02621   <span class="comment">/* Get the frame information and FP (if used) at the current PC.</span>
<a name="l02622"></a>02622 <span class="comment">     If PC is in the prologue, the prologue analysis is more reliable</span>
<a name="l02623"></a>02623 <span class="comment">     than DWARF info.  We don&#39;t not know for sure, if PC is in the prologue,</span>
<a name="l02624"></a>02624 <span class="comment">     but we do know no calls have yet taken place, so we can almost</span>
<a name="l02625"></a>02625 <span class="comment">     certainly rely on the prologue analysis.  */</span>
<a name="l02626"></a>02626 
<a name="l02627"></a>02627   <span class="keywordflow">if</span> (body_pc &lt;= pc)
<a name="l02628"></a>02628     {
<a name="l02629"></a>02629       <span class="comment">/* Prologue analysis was successful up to the PC.</span>
<a name="l02630"></a>02630 <span class="comment">         It includes the cases when PC == START_PC.  */</span>
<a name="l02631"></a>02631       c0_hasfp = cache-&gt;c0.c0_rt[<a class="code" href="xtensa-tdep_8c.html#ac5288ff604dd5732048dd20612b640f4">C0_FP</a>].fr_reg == <a class="code" href="xtensa-tdep_8c.html#a90c61cc2de5068f3d0dadbca1611ca4d">C0_SP</a>;
<a name="l02632"></a>02632       <span class="comment">/* c0_hasfp == true means there is a frame pointer because</span>
<a name="l02633"></a>02633 <span class="comment">         we analyzed the prologue and found that cache-&gt;c0.c0_rt[C0_FP]</span>
<a name="l02634"></a>02634 <span class="comment">         was derived from SP.  Otherwise, it would be C0_FP.  */</span>
<a name="l02635"></a>02635       fp_regnum = c0_hasfp ? <a class="code" href="xtensa-tdep_8c.html#ac5288ff604dd5732048dd20612b640f4">C0_FP</a> : <a class="code" href="xtensa-tdep_8c.html#a90c61cc2de5068f3d0dadbca1611ca4d">C0_SP</a>;
<a name="l02636"></a>02636       c0_frmsz = - cache-&gt;c0.c0_rt[<a class="code" href="frv-tdep_8h.html#ae6dceca96ec2c7a1b4aa211264a87ef6a10713f2eaf96807eb720c27bb013a2ff">fp_regnum</a>].fr_ofs;
<a name="l02637"></a>02637       fp_regnum += <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a>;
<a name="l02638"></a>02638     }
<a name="l02639"></a>02639   <span class="keywordflow">else</span>  <span class="comment">/* No data from the prologue analysis.  */</span>
<a name="l02640"></a>02640     {
<a name="l02641"></a>02641       c0_hasfp = 0;
<a name="l02642"></a>02642       fp_regnum = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch)-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a> + <a class="code" href="xtensa-tdep_8c.html#a90c61cc2de5068f3d0dadbca1611ca4d">C0_SP</a>;
<a name="l02643"></a>02643       c0_frmsz = 0;
<a name="l02644"></a>02644       start_pc = pc;
<a name="l02645"></a>02645    }
<a name="l02646"></a>02646 
<a name="l02647"></a>02647   <span class="keywordflow">if</span> (cache-&gt;c0.c0_fpalign)
<a name="l02648"></a>02648     {
<a name="l02649"></a>02649       <span class="comment">/* This frame has a special prologue with a dynamic stack adjustment</span>
<a name="l02650"></a>02650 <span class="comment">         to force an alignment, which is bigger than standard 16 bytes.  */</span>
<a name="l02651"></a>02651 
<a name="l02652"></a>02652       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> unaligned_sp;
<a name="l02653"></a>02653 
<a name="l02654"></a>02654       <span class="keywordflow">if</span> (cache-&gt;c0.c0_old_sp == <a class="code" href="xtensa-tdep_8c.html#a51694ea2494265ce611e70196f1e9009">C0_INEXP</a>)
<a name="l02655"></a>02655         <span class="comment">/* This can&#39;t be.  Prologue code should be consistent.</span>
<a name="l02656"></a>02656 <span class="comment">           Unaligned stack pointer should be saved in a spare register.  */</span>
<a name="l02657"></a>02657         {
<a name="l02658"></a>02658           warning_once ();
<a name="l02659"></a>02659           ra = 0;
<a name="l02660"></a>02660           <span class="keywordflow">goto</span> finish_frame_analysis;
<a name="l02661"></a>02661         }
<a name="l02662"></a>02662 
<a name="l02663"></a>02663       <span class="keywordflow">if</span> (cache-&gt;c0.c0_sp_ofs == <a class="code" href="xtensa-tdep_8c.html#a3e9badad6b26919da866065d6f3a3573">C0_NOSTK</a>)
<a name="l02664"></a>02664         <span class="comment">/* Saved unaligned value of SP is kept in a register.  */</span>
<a name="l02665"></a>02665         unaligned_sp = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a>
<a name="l02666"></a>02666           (this_frame, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + cache-&gt;c0.c0_old_sp);
<a name="l02667"></a>02667       <span class="keywordflow">else</span>
<a name="l02668"></a>02668         <span class="comment">/* Get the value from stack.  */</span>
<a name="l02669"></a>02669         unaligned_sp = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>)
<a name="l02670"></a>02670           <a class="code" href="corefile_8c.html#a7097ab90f56ed7bcceb190bab139621b">read_memory_integer</a> (fp + cache-&gt;c0.c0_sp_ofs, 4, byte_order);
<a name="l02671"></a>02671 
<a name="l02672"></a>02672       prev_sp = unaligned_sp + c0_frmsz;
<a name="l02673"></a>02673     }
<a name="l02674"></a>02674   <span class="keywordflow">else</span>
<a name="l02675"></a>02675     prev_sp = fp + c0_frmsz;
<a name="l02676"></a>02676 
<a name="l02677"></a>02677   <span class="comment">/* Frame size from debug info or prologue tracking does not account for </span>
<a name="l02678"></a>02678 <span class="comment">     alloca() and other dynamic allocations.  Adjust frame size by FP - SP.  */</span>
<a name="l02679"></a>02679   <span class="keywordflow">if</span> (c0_hasfp)
<a name="l02680"></a>02680     {
<a name="l02681"></a>02681       fp = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, fp_regnum);
<a name="l02682"></a>02682 
<a name="l02683"></a>02683       <span class="comment">/* Update the stack frame size.  */</span>
<a name="l02684"></a>02684       c0_frmsz += fp - sp;
<a name="l02685"></a>02685     }
<a name="l02686"></a>02686 
<a name="l02687"></a>02687   <span class="comment">/* Get the return address (RA) from the stack if saved,</span>
<a name="l02688"></a>02688 <span class="comment">     or try to get it from a register.  */</span>
<a name="l02689"></a>02689 
<a name="l02690"></a>02690   to_stk = cache-&gt;c0.c0_rt[<a class="code" href="xtensa-tdep_8c.html#a359723d76f1ffe049fa67abb082647bd">C0_RA</a>].to_stk;
<a name="l02691"></a>02691   <span class="keywordflow">if</span> (to_stk != <a class="code" href="xtensa-tdep_8c.html#a3e9badad6b26919da866065d6f3a3573">C0_NOSTK</a>)
<a name="l02692"></a>02692     ra = (<a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>) 
<a name="l02693"></a>02693       <a class="code" href="corefile_8c.html#a7097ab90f56ed7bcceb190bab139621b">read_memory_integer</a> (sp + c0_frmsz + cache-&gt;c0.c0_rt[<a class="code" href="xtensa-tdep_8c.html#a359723d76f1ffe049fa67abb082647bd">C0_RA</a>].to_stk,
<a name="l02694"></a>02694                            4, byte_order);
<a name="l02695"></a>02695 
<a name="l02696"></a>02696   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cache-&gt;c0.c0_rt[<a class="code" href="xtensa-tdep_8c.html#a359723d76f1ffe049fa67abb082647bd">C0_RA</a>].fr_reg == <a class="code" href="xtensa-tdep_8c.html#af48d45d73d45634d1597d4071a933c23">C0_CONST</a>
<a name="l02697"></a>02697            &amp;&amp; cache-&gt;c0.c0_rt[<a class="code" href="xtensa-tdep_8c.html#a359723d76f1ffe049fa67abb082647bd">C0_RA</a>].fr_ofs == 0)
<a name="l02698"></a>02698     {
<a name="l02699"></a>02699       <span class="comment">/* Special case for terminating backtrace at a function that wants to</span>
<a name="l02700"></a>02700 <span class="comment">         be seen as the outermost one.  Such a function will clear it&#39;s RA (A0)</span>
<a name="l02701"></a>02701 <span class="comment">         register to 0 in the prologue instead of saving its original value.  */</span>
<a name="l02702"></a>02702       ra = 0;
<a name="l02703"></a>02703     }
<a name="l02704"></a>02704   <span class="keywordflow">else</span>
<a name="l02705"></a>02705     {
<a name="l02706"></a>02706       <span class="comment">/* RA was copied to another register or (before any function call) may</span>
<a name="l02707"></a>02707 <span class="comment">         still be in the original RA register.  This is not always reliable:</span>
<a name="l02708"></a>02708 <span class="comment">         even in a leaf function, register tracking stops after prologue, and</span>
<a name="l02709"></a>02709 <span class="comment">         even in prologue, non-prologue instructions (not tracked) may overwrite</span>
<a name="l02710"></a>02710 <span class="comment">         RA or any register it was copied to.  If likely in prologue or before</span>
<a name="l02711"></a>02711 <span class="comment">         any call, use retracking info and hope for the best (compiler should</span>
<a name="l02712"></a>02712 <span class="comment">         have saved RA in stack if not in a leaf function).  If not in prologue,</span>
<a name="l02713"></a>02713 <span class="comment">         too bad.  */</span>
<a name="l02714"></a>02714 
<a name="l02715"></a>02715       <span class="keywordtype">int</span> i;
<a name="l02716"></a>02716       <span class="keywordflow">for</span> (i = 0;
<a name="l02717"></a>02717            (i &lt; <a class="code" href="xtensa-tdep_8c.html#a78bb729d39d6d29c761515a76d68eb68">C0_NREGS</a>)
<a name="l02718"></a>02718            &amp;&amp; (i == <a class="code" href="xtensa-tdep_8c.html#a359723d76f1ffe049fa67abb082647bd">C0_RA</a> || cache-&gt;c0.c0_rt[i].fr_reg != <a class="code" href="xtensa-tdep_8c.html#a359723d76f1ffe049fa67abb082647bd">C0_RA</a>);
<a name="l02719"></a>02719            ++i);
<a name="l02720"></a>02720       <span class="keywordflow">if</span> (i &gt;= <a class="code" href="xtensa-tdep_8c.html#a78bb729d39d6d29c761515a76d68eb68">C0_NREGS</a> &amp;&amp; cache-&gt;c0.c0_rt[<a class="code" href="xtensa-tdep_8c.html#a359723d76f1ffe049fa67abb082647bd">C0_RA</a>].fr_reg == <a class="code" href="xtensa-tdep_8c.html#a359723d76f1ffe049fa67abb082647bd">C0_RA</a>)
<a name="l02721"></a>02721         i = <a class="code" href="xtensa-tdep_8c.html#a359723d76f1ffe049fa67abb082647bd">C0_RA</a>;
<a name="l02722"></a>02722       <span class="keywordflow">if</span> (i &lt; <a class="code" href="xtensa-tdep_8c.html#a78bb729d39d6d29c761515a76d68eb68">C0_NREGS</a>)
<a name="l02723"></a>02723         {
<a name="l02724"></a>02724           ra = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a>
<a name="l02725"></a>02725             (this_frame,
<a name="l02726"></a>02726              <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + cache-&gt;c0.c0_rt[i].fr_reg);
<a name="l02727"></a>02727         }
<a name="l02728"></a>02728       <span class="keywordflow">else</span> ra = 0;
<a name="l02729"></a>02729     }
<a name="l02730"></a>02730   
<a name="l02731"></a>02731  finish_frame_analysis:
<a name="l02732"></a>02732   cache-&gt;pc = start_pc;
<a name="l02733"></a>02733   cache-&gt;ra = ra;
<a name="l02734"></a>02734   <span class="comment">/* RA == 0 marks the outermost frame.  Do not go past it.  */</span>
<a name="l02735"></a>02735   cache-&gt;prev_sp = (ra != 0) ?  prev_sp : 0;
<a name="l02736"></a>02736   cache-&gt;c0.fp_regnum = <a class="code" href="frv-tdep_8h.html#ae6dceca96ec2c7a1b4aa211264a87ef6a10713f2eaf96807eb720c27bb013a2ff">fp_regnum</a>;
<a name="l02737"></a>02737   cache-&gt;c0.c0_frmsz = c0_frmsz;
<a name="l02738"></a>02738   cache-&gt;c0.c0_hasfp = c0_hasfp;
<a name="l02739"></a>02739   cache-&gt;c0.c0_fp = fp;
<a name="l02740"></a>02740 }
<a name="l02741"></a>02741 
<a name="l02742"></a>02742 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> a0_saved;
<a name="l02743"></a>02743 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> a7_saved;
<a name="l02744"></a>02744 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> a11_saved;
<a name="l02745"></a>02745 <span class="keyword">static</span> <span class="keywordtype">int</span> a0_was_saved;
<a name="l02746"></a>02746 <span class="keyword">static</span> <span class="keywordtype">int</span> a7_was_saved;
<a name="l02747"></a>02747 <span class="keyword">static</span> <span class="keywordtype">int</span> a11_was_saved;
<a name="l02748"></a>02748 
<a name="l02749"></a>02749 <span class="comment">/* Simulate L32E instruction:  AT &lt;-- ref (AS + offset).  */</span>
<a name="l02750"></a>02750 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02751"></a>02751 execute_l32e (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> at, <span class="keywordtype">int</span> as, <span class="keywordtype">int</span> offset, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> wb)
<a name="l02752"></a>02752 {
<a name="l02753"></a>02753   <span class="keywordtype">int</span> atreg = arreg_number (gdbarch, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + at, wb);
<a name="l02754"></a>02754   <span class="keywordtype">int</span> asreg = arreg_number (gdbarch, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + as, wb);
<a name="l02755"></a>02755   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr = xtensa_read_register (asreg) + <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l02756"></a>02756   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> spilled_value
<a name="l02757"></a>02757     = <a class="code" href="corefile_8c.html#a280cf81e766f60b30618ae3011f2cb07">read_memory_unsigned_integer</a> (addr, 4, <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch));
<a name="l02758"></a>02758 
<a name="l02759"></a>02759   <span class="keywordflow">if</span> ((at == 0) &amp;&amp; !a0_was_saved)
<a name="l02760"></a>02760     {
<a name="l02761"></a>02761       a0_saved = xtensa_read_register (atreg);
<a name="l02762"></a>02762       a0_was_saved = 1;
<a name="l02763"></a>02763     }
<a name="l02764"></a>02764   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((at == 7) &amp;&amp; !a7_was_saved)
<a name="l02765"></a>02765     {
<a name="l02766"></a>02766       a7_saved = xtensa_read_register (atreg);
<a name="l02767"></a>02767       a7_was_saved = 1;
<a name="l02768"></a>02768     }
<a name="l02769"></a>02769   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((at == 11) &amp;&amp; !a11_was_saved)
<a name="l02770"></a>02770     {
<a name="l02771"></a>02771       a11_saved = xtensa_read_register (atreg);
<a name="l02772"></a>02772       a11_was_saved = 1;
<a name="l02773"></a>02773     }
<a name="l02774"></a>02774 
<a name="l02775"></a>02775   xtensa_write_register (atreg, spilled_value);
<a name="l02776"></a>02776 }
<a name="l02777"></a>02777 
<a name="l02778"></a>02778 <span class="comment">/* Simulate S32E instruction:  AT --&gt; ref (AS + offset).  */</span>
<a name="l02779"></a>02779 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02780"></a>02780 execute_s32e (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keywordtype">int</span> at, <span class="keywordtype">int</span> as, <span class="keywordtype">int</span> offset, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> wb)
<a name="l02781"></a>02781 {
<a name="l02782"></a>02782   <span class="keywordtype">int</span> atreg = arreg_number (gdbarch, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + at, wb);
<a name="l02783"></a>02783   <span class="keywordtype">int</span> asreg = arreg_number (gdbarch, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + as, wb);
<a name="l02784"></a>02784   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> addr = xtensa_read_register (asreg) + <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l02785"></a>02785   <a class="code" href="defs_8h.html#a4df4af8771b1016a24976757026f4984">ULONGEST</a> spilled_value = xtensa_read_register (atreg);
<a name="l02786"></a>02786 
<a name="l02787"></a>02787   <a class="code" href="corefile_8c.html#a5d984a6b6854bdefc717e88447000790">write_memory_unsigned_integer</a> (addr, 4,
<a name="l02788"></a>02788                                  <a class="code" href="gdbarch_8c.html#abc300a3797421aa7342b288e1637483e">gdbarch_byte_order</a> (gdbarch),
<a name="l02789"></a>02789                                  spilled_value);
<a name="l02790"></a>02790 }
<a name="l02791"></a><a class="code" href="xtensa-tdep_8c.html#a3c738f7034256bbf86340c037de6602e">02791</a> 
<a name="l02792"></a>02792 <span class="preprocessor">#define XTENSA_MAX_WINDOW_INTERRUPT_HANDLER_LEN  200</span>
<a name="l02793"></a><a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6d">02793</a> <span class="preprocessor"></span>
<a name="l02794"></a>02794 <span class="keyword">typedef</span> <span class="keyword">enum</span>
<a name="l02795"></a><a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da2421f65021afae96017ed335dbfd6359">02795</a> {
<a name="l02796"></a><a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da2952ce5cc337e6ce95a459d6b628b1d7">02796</a>   <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da2421f65021afae96017ed335dbfd6359">xtWindowOverflow</a>,
<a name="l02797"></a><a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">02797</a>   <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da2952ce5cc337e6ce95a459d6b628b1d7">xtWindowUnderflow</a>,
<a name="l02798"></a>02798   <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>
<a name="l02799"></a>02799 } <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6d">xtensa_exception_handler_t</a>;
<a name="l02800"></a>02800 
<a name="l02801"></a>02801 <span class="comment">/* Execute instruction stream from current PC until hitting RFWU or RFWO.</span>
<a name="l02802"></a>02802 <span class="comment">   Return type of Xtensa Window Interrupt Handler on success.  */</span>
<a name="l02803"></a>02803 <span class="keyword">static</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6d">xtensa_exception_handler_t</a>
<a name="l02804"></a>02804 execute_code (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> current_pc, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> wb)
<a name="l02805"></a>02805 {
<a name="l02806"></a>02806   xtensa_isa isa;
<a name="l02807"></a>02807   xtensa_insnbuf ins, slot;
<a name="l02808"></a>02808   <a class="code" href="defs_8h.html#a336b399b3b83dbcc61f176c33f26b607">gdb_byte</a> ibuf[<a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a>];
<a name="l02809"></a>02809   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> ia, bt, ba;
<a name="l02810"></a>02810   xtensa_format ifmt;
<a name="l02811"></a>02811   <span class="keywordtype">int</span> ilen, islots, is;
<a name="l02812"></a>02812   xtensa_opcode opc;
<a name="l02813"></a>02813   <span class="keywordtype">int</span> insn_num = 0;
<a name="l02814"></a>02814   <span class="keywordtype">int</span> fail = 0;
<a name="l02815"></a>02815   void (*<a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a>) (<span class="keyword">struct </span>gdbarch *, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <a class="code" href="command_8h.html#a74f207b5aa4ba51c3a2ad59b219a423b">int</a>, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>);
<a name="l02816"></a>02816 
<a name="l02817"></a>02817   uint32_t at, as, <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>;
<a name="l02818"></a>02818 
<a name="l02819"></a>02819   <span class="comment">/* WindowUnderflow12 = true, when inside _WindowUnderflow12.  */</span> 
<a name="l02820"></a>02820   <span class="keywordtype">int</span> WindowUnderflow12 = (current_pc &amp; 0x1ff) &gt;= 0x140; 
<a name="l02821"></a>02821 
<a name="l02822"></a>02822   isa = xtensa_default_isa;
<a name="l02823"></a>02823   <a class="code" href="gdb__assert_8h.html#aeb007d3e990858c7ef8e40a7e512c1ff">gdb_assert</a> (<a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a> &gt;= xtensa_isa_maxlength (isa));
<a name="l02824"></a>02824   ins = xtensa_insnbuf_alloc (isa);
<a name="l02825"></a>02825   slot = xtensa_insnbuf_alloc (isa);
<a name="l02826"></a>02826   ba = 0;
<a name="l02827"></a>02827   ia = current_pc;
<a name="l02828"></a>02828   bt = ia;
<a name="l02829"></a>02829 
<a name="l02830"></a>02830   a0_was_saved = 0;
<a name="l02831"></a>02831   a7_was_saved = 0;
<a name="l02832"></a>02832   a11_was_saved = 0;
<a name="l02833"></a>02833 
<a name="l02834"></a>02834   <span class="keywordflow">while</span> (insn_num++ &lt; <a class="code" href="xtensa-tdep_8c.html#a3c738f7034256bbf86340c037de6602e">XTENSA_MAX_WINDOW_INTERRUPT_HANDLER_LEN</a>)
<a name="l02835"></a>02835     {
<a name="l02836"></a>02836       <span class="keywordflow">if</span> (ia + xtensa_isa_maxlength (isa) &gt; bt)
<a name="l02837"></a>02837         {
<a name="l02838"></a>02838           ba = ia;
<a name="l02839"></a>02839           bt = (ba + <a class="code" href="xtensa-tdep_8c.html#aaf952bb6ace05aa8325c95a929b27ae8">XTENSA_ISA_BSZ</a>);
<a name="l02840"></a>02840           <span class="keywordflow">if</span> (<a class="code" href="target_8c.html#ac579515fbccfb9e6b1a45766a71c1d4f">target_read_memory</a> (ba, ibuf, bt - ba) != 0)
<a name="l02841"></a>02841             <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02842"></a>02842         }
<a name="l02843"></a>02843       xtensa_insnbuf_from_chars (isa, ins, &amp;ibuf[ia-ba], 0);
<a name="l02844"></a>02844       ifmt = xtensa_format_decode (isa, ins);
<a name="l02845"></a>02845       <span class="keywordflow">if</span> (ifmt == XTENSA_UNDEFINED)
<a name="l02846"></a>02846         <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02847"></a>02847       ilen = xtensa_format_length (isa, ifmt);
<a name="l02848"></a>02848       <span class="keywordflow">if</span> (ilen == XTENSA_UNDEFINED)
<a name="l02849"></a>02849         <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02850"></a>02850       islots = xtensa_format_num_slots (isa, ifmt);
<a name="l02851"></a>02851       <span class="keywordflow">if</span> (islots == XTENSA_UNDEFINED)
<a name="l02852"></a>02852         <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02853"></a>02853       <span class="keywordflow">for</span> (is = 0; is &lt; islots; ++is)
<a name="l02854"></a>02854         {
<a name="l02855"></a>02855           <span class="keywordflow">if</span> (xtensa_format_get_slot (isa, ifmt, is, ins, slot))
<a name="l02856"></a>02856             <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02857"></a>02857           opc = xtensa_opcode_decode (isa, ifmt, is, slot);
<a name="l02858"></a>02858           <span class="keywordflow">if</span> (opc == XTENSA_UNDEFINED) 
<a name="l02859"></a>02859             <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02860"></a>02860           <span class="keywordflow">switch</span> (call0_classify_opcode (isa, opc))
<a name="l02861"></a>02861             {
<a name="l02862"></a>02862             <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccaa7d04c2c707bf238bb7b14a7588ace4d">c0opc_illegal</a>:
<a name="l02863"></a>02863             <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca9682c422984bf01156435b30b2cf1a31">c0opc_flow</a>:
<a name="l02864"></a>02864             <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca7d451d49c245e3d222877e68fbc2d1d8">c0opc_entry</a>:
<a name="l02865"></a>02865             <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccad60e969c89418a848d5ad9dedb0c14a7">c0opc_break</a>:
<a name="l02866"></a>02866               <span class="comment">/* We expect none of them here.  */</span>
<a name="l02867"></a>02867               <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02868"></a>02868             <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca4d1fc811a76a6fdaf0d90e3770830f20">c0opc_l32e</a>:
<a name="l02869"></a>02869               <a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a> = execute_l32e;
<a name="l02870"></a>02870               <span class="keywordflow">break</span>;
<a name="l02871"></a>02871             <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca12513f3f43a89449ad008aedd8a7a552">c0opc_s32e</a>:
<a name="l02872"></a>02872               <a class="code" href="remote-fileio_8c.html#a7e97efb32ba66c3f1141bdbb82529d20">func</a> = execute_s32e;
<a name="l02873"></a>02873               <span class="keywordflow">break</span>;
<a name="l02874"></a>02874             <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68ccaf0f2224c6e1ee30d0521f96336bfd44c">c0opc_rfwo</a>: <span class="comment">/* RFWO.  */</span>
<a name="l02875"></a>02875               <span class="comment">/* Here, we return from WindowOverflow handler and,</span>
<a name="l02876"></a>02876 <span class="comment">                 if we stopped at the very beginning, which means</span>
<a name="l02877"></a>02877 <span class="comment">                 A0 was saved, we have to restore it now.  */</span>
<a name="l02878"></a>02878               <span class="keywordflow">if</span> (a0_was_saved)
<a name="l02879"></a>02879                 {
<a name="l02880"></a>02880                   <span class="keywordtype">int</span> arreg = arreg_number (gdbarch,
<a name="l02881"></a>02881                                             <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base,
<a name="l02882"></a>02882                                             wb);
<a name="l02883"></a>02883                   xtensa_write_register (arreg, a0_saved);
<a name="l02884"></a>02884                 }
<a name="l02885"></a>02885               <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da2421f65021afae96017ed335dbfd6359">xtWindowOverflow</a>;
<a name="l02886"></a>02886             <span class="keywordflow">case</span> <a class="code" href="xtensa-tdep_8c.html#a74272d0962ad3674fb91f7984c2e68cca80378338aa55d415d9427bf5b3adabeb">c0opc_rfwu</a>: <span class="comment">/* RFWU.  */</span>
<a name="l02887"></a>02887               <span class="comment">/* Here, we return from WindowUnderflow handler.</span>
<a name="l02888"></a>02888 <span class="comment">                 Let&#39;s see if either A7 or A11 has to be restored.  */</span>
<a name="l02889"></a>02889               <span class="keywordflow">if</span> (WindowUnderflow12)
<a name="l02890"></a>02890                 {
<a name="l02891"></a>02891                   <span class="keywordflow">if</span> (a11_was_saved)
<a name="l02892"></a>02892                     {
<a name="l02893"></a>02893                       <span class="keywordtype">int</span> arreg = arreg_number (gdbarch,
<a name="l02894"></a>02894                                                 <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 11,
<a name="l02895"></a>02895                                                 wb);
<a name="l02896"></a>02896                       xtensa_write_register (arreg, a11_saved);
<a name="l02897"></a>02897                     }
<a name="l02898"></a>02898                 }
<a name="l02899"></a>02899               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (a7_was_saved)
<a name="l02900"></a>02900                 {
<a name="l02901"></a>02901                   <span class="keywordtype">int</span> arreg = arreg_number (gdbarch,
<a name="l02902"></a>02902                                             <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + 7,
<a name="l02903"></a>02903                                             wb);
<a name="l02904"></a>02904                   xtensa_write_register (arreg, a7_saved);
<a name="l02905"></a>02905                 }
<a name="l02906"></a>02906               <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da2952ce5cc337e6ce95a459d6b628b1d7">xtWindowUnderflow</a>;
<a name="l02907"></a>02907             <span class="keywordflow">default</span>: <span class="comment">/* Simply skip this insns.  */</span>
<a name="l02908"></a>02908               <span class="keywordflow">continue</span>;
<a name="l02909"></a>02909             }
<a name="l02910"></a>02910 
<a name="l02911"></a>02911           <span class="comment">/* Decode arguments for L32E / S32E and simulate their execution.  */</span>
<a name="l02912"></a>02912           <span class="keywordflow">if</span> ( xtensa_opcode_num_operands (isa, opc) != 3 )
<a name="l02913"></a>02913             <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02914"></a>02914           <span class="keywordflow">if</span> (xtensa_operand_get_field (isa, opc, 0, ifmt, is, slot, &amp;at))
<a name="l02915"></a>02915             <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02916"></a>02916           <span class="keywordflow">if</span> (xtensa_operand_decode (isa, opc, 0, &amp;at))
<a name="l02917"></a>02917             <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02918"></a>02918           <span class="keywordflow">if</span> (xtensa_operand_get_field (isa, opc, 1, ifmt, is, slot, &amp;as))
<a name="l02919"></a>02919             <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02920"></a>02920           <span class="keywordflow">if</span> (xtensa_operand_decode (isa, opc, 1, &amp;as))
<a name="l02921"></a>02921             <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02922"></a>02922           <span class="keywordflow">if</span> (xtensa_operand_get_field (isa, opc, 2, ifmt, is, slot, &amp;offset))
<a name="l02923"></a>02923             <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02924"></a>02924           <span class="keywordflow">if</span> (xtensa_operand_decode (isa, opc, 2, &amp;offset))
<a name="l02925"></a>02925             <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02926"></a>02926 
<a name="l02927"></a>02927           (*func) (gdbarch, at, as, <a class="code" href="common_2agent_8c.html#aed7ea92f45bd273dde380a45ddced592">offset</a>, wb);
<a name="l02928"></a>02928         }
<a name="l02929"></a>02929 
<a name="l02930"></a>02930       ia += ilen;
<a name="l02931"></a>02931     }
<a name="l02932"></a>02932   <span class="keywordflow">return</span> <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>;
<a name="l02933"></a>02933 }
<a name="l02934"></a>02934 
<a name="l02935"></a>02935 <span class="comment">/* Handle Window Overflow / Underflow exception frames.  */</span>
<a name="l02936"></a>02936 
<a name="l02937"></a>02937 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02938"></a>02938 xtensa_window_interrupt_frame_cache (<span class="keyword">struct</span> frame_info *this_frame,
<a name="l02939"></a>02939                                      <a class="code" href="xtensa-tdep_8c.html#ac83c68c18f462e5e2661d376bd027d3e">xtensa_frame_cache_t</a> *cache,
<a name="l02940"></a>02940                                      <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> pc)
<a name="l02941"></a>02941 {
<a name="l02942"></a>02942   <span class="keyword">struct </span>gdbarch *gdbarch = <a class="code" href="frame_8c.html#ab44507b5655da44e522ed5857835ede7">get_frame_arch</a> (this_frame);
<a name="l02943"></a>02943   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> <a class="code" href="namespacecleanup__check.html#a2f9ce522b7667bef19a5777d12fa44d8">ps</a>, wb, ws, ra;
<a name="l02944"></a>02944   <span class="keywordtype">int</span> epc1_regnum, i, <a class="code" href="aarch64-tdep_8c.html#a6b3d1ad0bca4067ccaef1366bea0db04">regnum</a>;
<a name="l02945"></a>02945   <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6d">xtensa_exception_handler_t</a> eh_type;
<a name="l02946"></a>02946 
<a name="l02947"></a>02947   <span class="comment">/* Read PS, WB, and WS from the hardware. Note that PS register</span>
<a name="l02948"></a>02948 <span class="comment">     must be present, if Windowed ABI is supported.  */</span>
<a name="l02949"></a>02949   ps = xtensa_read_register (<a class="code" href="gdbarch_8c.html#aa0e316e2d110495a985d9f566df348c3">gdbarch_ps_regnum</a> (gdbarch));
<a name="l02950"></a>02950   wb = xtensa_read_register (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;wb_regnum);
<a name="l02951"></a>02951   ws = xtensa_read_register (<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;ws_regnum);
<a name="l02952"></a>02952 
<a name="l02953"></a>02953   <span class="comment">/* Execute all the remaining instructions from Window Interrupt Handler</span>
<a name="l02954"></a>02954 <span class="comment">     by simulating them on the remote protocol level.  On return, set the</span>
<a name="l02955"></a>02955 <span class="comment">     type of Xtensa Window Interrupt Handler, or report an error.  */</span>
<a name="l02956"></a>02956   eh_type = execute_code (gdbarch, pc, wb);
<a name="l02957"></a>02957   <span class="keywordflow">if</span> (eh_type == <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da14dd9394dad1fb97856b24db0be31b7f">xtNoExceptionHandler</a>)
<a name="l02958"></a>02958     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l02959"></a>02959 <span class="stringliteral">Unable to decode Xtensa Window Interrupt Handler&#39;s code.&quot;</span>));
<a name="l02960"></a>02960 
<a name="l02961"></a>02961   cache-&gt;ps = ps ^ <a class="code" href="xtensa-tdep_8c.html#ad279722c56b67506ce58873638892617">PS_EXC</a>;      <span class="comment">/* Clear the exception bit in PS.  */</span>
<a name="l02962"></a>02962   cache-&gt;call0 = 0;             <span class="comment">/* It&#39;s Windowed ABI.  */</span>
<a name="l02963"></a>02963 
<a name="l02964"></a>02964   <span class="comment">/* All registers for the cached frame will be alive.  */</span>
<a name="l02965"></a>02965   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="xtensa-tdep_8c.html#a26463eb820061ed221e4aefbc1cf0fb9">XTENSA_NUM_SAVED_AREGS</a>; i++)
<a name="l02966"></a>02966     cache-&gt;wd.aregs[i] = -1;
<a name="l02967"></a>02967 
<a name="l02968"></a>02968   if (eh_type == <a class="code" href="xtensa-tdep_8c.html#a057edfe5a8aa93cdcc0d5150ab28fb6da2421f65021afae96017ed335dbfd6359">xtWindowOverflow</a>)
<a name="l02969"></a>02969     cache-&gt;wd.ws = ws ^ (1 &lt;&lt; wb);
<a name="l02970"></a>02970   <span class="keywordflow">else</span> <span class="comment">/* eh_type == xtWindowUnderflow.  */</span>
<a name="l02971"></a>02971     cache-&gt;wd.ws = ws | (1 &lt;&lt; wb);
<a name="l02972"></a>02972 
<a name="l02973"></a>02973   cache-&gt;wd.wb = (ps &amp; 0xf00) &gt;&gt; 8; <span class="comment">/* Set WB to OWB.  */</span>
<a name="l02974"></a>02974   regnum = arreg_number (gdbarch, <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base,
<a name="l02975"></a>02975                          cache-&gt;wd.wb);
<a name="l02976"></a>02976   ra = xtensa_read_register (regnum);
<a name="l02977"></a>02977   cache-&gt;wd.callsize = <a class="code" href="xtensa-tdep_8c.html#ab5b0d0abf0586f7a99e090450d41f8ef">WINSIZE</a> (ra);
<a name="l02978"></a>02978   cache-&gt;prev_sp = xtensa_read_register (regnum + 1);
<a name="l02979"></a>02979   <span class="comment">/* Set regnum to a frame pointer of the frame being cached.  */</span>
<a name="l02980"></a>02980   regnum = xtensa_scan_prologue (gdbarch, pc);
<a name="l02981"></a>02981   regnum = arreg_number (gdbarch,
<a name="l02982"></a>02982                          <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;a0_base + regnum,
<a name="l02983"></a>02983                          cache-&gt;wd.wb);
<a name="l02984"></a>02984   cache-&gt;base = <a class="code" href="frame_8c.html#affa785e8937e96fd727e46a2cfec94c4">get_frame_register_unsigned</a> (this_frame, regnum);
<a name="l02985"></a>02985 
<a name="l02986"></a>02986   <span class="comment">/* Read PC of interrupted function from EPC1 register.  */</span>
<a name="l02987"></a>02987   epc1_regnum = xtensa_find_register_by_name (gdbarch,<span class="stringliteral">&quot;epc1&quot;</span>);
<a name="l02988"></a>02988   <span class="keywordflow">if</span> (epc1_regnum &lt; 0)
<a name="l02989"></a>02989     <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a>(<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Unable to read Xtensa register EPC1&quot;</span>));
<a name="l02990"></a>02990   cache-&gt;ra = xtensa_read_register (epc1_regnum);
<a name="l02991"></a>02991   cache-&gt;pc = <a class="code" href="frame_8c.html#ac64c0ce600cc134b2256c0d507f57cde">get_frame_func</a> (this_frame);
<a name="l02992"></a>02992 }
<a name="l02993"></a>02993 
<a name="l02994"></a>02994 
<a name="l02995"></a>02995 <span class="comment">/* Skip function prologue.</span>
<a name="l02996"></a>02996 <span class="comment"></span>
<a name="l02997"></a>02997 <span class="comment">   Return the pc of the first instruction after prologue.  GDB calls this to</span>
<a name="l02998"></a>02998 <span class="comment">   find the address of the first line of the function or (if there is no line</span>
<a name="l02999"></a>02999 <span class="comment">   number information) to skip the prologue for planting breakpoints on </span>
<a name="l03000"></a>03000 <span class="comment">   function entries.  Use debug info (if present) or prologue analysis to skip </span>
<a name="l03001"></a>03001 <span class="comment">   the prologue to achieve reliable debugging behavior.  For windowed ABI, </span>
<a name="l03002"></a>03002 <span class="comment">   only the &#39;entry&#39; instruction is skipped.  It is not strictly necessary to </span>
<a name="l03003"></a>03003 <span class="comment">   skip the prologue (Call0) or &#39;entry&#39; (Windowed) because xt-gdb knows how to</span>
<a name="l03004"></a>03004 <span class="comment">   backtrace at any point in the prologue, however certain potential hazards </span>
<a name="l03005"></a>03005 <span class="comment">   are avoided and a more &quot;normal&quot; debugging experience is ensured by </span>
<a name="l03006"></a>03006 <span class="comment">   skipping the prologue (can be disabled by defining DONT_SKIP_PROLOG).</span>
<a name="l03007"></a>03007 <span class="comment">   For example, if we don&#39;t skip the prologue:</span>
<a name="l03008"></a>03008 <span class="comment">   - Some args may not yet have been saved to the stack where the debug</span>
<a name="l03009"></a>03009 <span class="comment">     info expects to find them (true anyway when only &#39;entry&#39; is skipped);</span>
<a name="l03010"></a>03010 <span class="comment">   - Software breakpoints (&#39;break&#39; instrs) may not have been unplanted </span>
<a name="l03011"></a>03011 <span class="comment">     when the prologue analysis is done on initializing the frame cache, </span>
<a name="l03012"></a>03012 <span class="comment">     and breaks in the prologue will throw off the analysis.</span>
<a name="l03013"></a>03013 <span class="comment"></span>
<a name="l03014"></a>03014 <span class="comment">   If we have debug info ( line-number info, in particular ) we simply skip</span>
<a name="l03015"></a>03015 <span class="comment">   the code associated with the first function line effectively skipping</span>
<a name="l03016"></a>03016 <span class="comment">   the prologue code.  It works even in cases like</span>
<a name="l03017"></a>03017 <span class="comment"></span>
<a name="l03018"></a>03018 <span class="comment">   int main()</span>
<a name="l03019"></a>03019 <span class="comment">   {    int local_var = 1;</span>
<a name="l03020"></a>03020 <span class="comment">        ....</span>
<a name="l03021"></a>03021 <span class="comment">   }</span>
<a name="l03022"></a>03022 <span class="comment"></span>
<a name="l03023"></a>03023 <span class="comment">   because, for this source code, both Xtensa compilers will generate two</span>
<a name="l03024"></a>03024 <span class="comment">   separate entries ( with the same line number ) in dwarf line-number</span>
<a name="l03025"></a>03025 <span class="comment">   section to make sure there is a boundary between the prologue code and</span>
<a name="l03026"></a>03026 <span class="comment">   the rest of the function.</span>
<a name="l03027"></a>03027 <span class="comment"></span>
<a name="l03028"></a>03028 <span class="comment">   If there is no debug info, we need to analyze the code.  */</span>
<a name="l03029"></a>03029 
<a name="l03030"></a>03030 <span class="comment">/* #define DONT_SKIP_PROLOGUE  */</span>
<a name="l03031"></a>03031 
<a name="l03032"></a>03032 <span class="keyword">static</span> <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a>
<a name="l03033"></a>03033 xtensa_skip_prologue (<span class="keyword">struct</span> gdbarch *gdbarch, <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> start_pc)
<a name="l03034"></a>03034 {
<a name="l03035"></a>03035   <span class="keyword">struct </span><a class="code" href="structsymtab__and__line.html">symtab_and_line</a> prologue_sal;
<a name="l03036"></a>03036   <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> body_pc;
<a name="l03037"></a>03037 
<a name="l03038"></a>03038   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;xtensa_skip_prologue (start_pc = 0x%08x)\n&quot;</span>, (<span class="keywordtype">int</span>) start_pc);
<a name="l03039"></a>03039 
<a name="l03040"></a>03040 <span class="preprocessor">#if DONT_SKIP_PROLOGUE</span>
<a name="l03041"></a>03041 <span class="preprocessor"></span>  <span class="keywordflow">return</span> start_pc;
<a name="l03042"></a>03042 <span class="preprocessor">#endif</span>
<a name="l03043"></a>03043 <span class="preprocessor"></span>
<a name="l03044"></a>03044  <span class="comment">/* Try to find first body line from debug info.  */</span>
<a name="l03045"></a>03045 
<a name="l03046"></a>03046   prologue_sal = <a class="code" href="symtab_8c.html#ad9bbd85700e3d7fa50e7ba0e32f37846">find_pc_line</a> (start_pc, 0);
<a name="l03047"></a>03047   <span class="keywordflow">if</span> (prologue_sal.line != 0) <span class="comment">/* Found debug info.  */</span>
<a name="l03048"></a>03048     {
<a name="l03049"></a>03049       <span class="comment">/* In Call0,  it is possible to have a function with only one instruction</span>
<a name="l03050"></a>03050 <span class="comment">         (&#39;ret&#39;) resulting from a one-line optimized function that does nothing.</span>
<a name="l03051"></a>03051 <span class="comment">         In that case,  prologue_sal.end may actually point to the start of the</span>
<a name="l03052"></a>03052 <span class="comment">         next function in the text section,  causing a breakpoint to be set at</span>
<a name="l03053"></a>03053 <span class="comment">         the wrong place.  Check,  if the end address is within a different</span>
<a name="l03054"></a>03054 <span class="comment">         function,  and if so return the start PC.  We know we have symbol</span>
<a name="l03055"></a>03055 <span class="comment">         information.  */</span>
<a name="l03056"></a>03056 
<a name="l03057"></a>03057       <a class="code" href="defs_8h.html#aba5d0eb4e938c80ae1112a4439aaf71a">CORE_ADDR</a> end_func;
<a name="l03058"></a>03058 
<a name="l03059"></a>03059       <span class="keywordflow">if</span> ((<a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> (gdbarch)-&gt;call_abi == <a class="code" href="xtensa-tdep_8h.html#aa494e78313efd646e55e129992eafbcbadd1a04285f03aa703b8634da6c2df921">CallAbiCall0Only</a>)
<a name="l03060"></a>03060           &amp;&amp; call0_ret (start_pc, prologue_sal.end))
<a name="l03061"></a>03061         <span class="keywordflow">return</span> start_pc;
<a name="l03062"></a>03062 
<a name="l03063"></a>03063       <a class="code" href="blockframe_8c.html#a2dae2257ad1417604d2c26f8b9071ca9">find_pc_partial_function</a> (prologue_sal.end, NULL, &amp;end_func, NULL);
<a name="l03064"></a>03064       <span class="keywordflow">if</span> (end_func != start_pc)
<a name="l03065"></a>03065         <span class="keywordflow">return</span> start_pc;
<a name="l03066"></a>03066 
<a name="l03067"></a>03067       <span class="keywordflow">return</span> prologue_sal.end;
<a name="l03068"></a>03068     }
<a name="l03069"></a>03069 
<a name="l03070"></a>03070   <span class="comment">/* No debug line info.  Analyze prologue for Call0 or simply skip ENTRY.  */</span>
<a name="l03071"></a>03071   body_pc = call0_analyze_prologue (gdbarch, start_pc, 0, 0,
<a name="l03072"></a>03072                                     xtensa_alloc_frame_cache (0));
<a name="l03073"></a>03073   <span class="keywordflow">return</span> body_pc != 0 ? body_pc : start_pc;
<a name="l03074"></a>03074 }
<a name="l03075"></a>03075 
<a name="l03076"></a>03076 <span class="comment">/* Verify the current configuration.  */</span>
<a name="l03077"></a>03077 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03078"></a>03078 xtensa_verify_config (<span class="keyword">struct</span> gdbarch *gdbarch)
<a name="l03079"></a>03079 {
<a name="l03080"></a>03080   <span class="keyword">struct </span>ui_file *<a class="code" href="namespacecleanup__check.html#acace5ba709b18673380db653eae117c9">log</a>;
<a name="l03081"></a>03081   <span class="keyword">struct </span>cleanup *cleanups;
<a name="l03082"></a>03082   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep;
<a name="l03083"></a>03083   <span class="keywordtype">long</span> length;
<a name="l03084"></a>03084   <span class="keywordtype">char</span> *buf;
<a name="l03085"></a>03085 
<a name="l03086"></a>03086   tdep = <a class="code" href="gdbarch_8c.html#acea996b7421706849bc20567695b5b31">gdbarch_tdep</a> (gdbarch);
<a name="l03087"></a>03087   log = <a class="code" href="ui-file_8c.html#a340771735f105582d314e191a399a45c">mem_fileopen</a> ();
<a name="l03088"></a>03088   cleanups = <a class="code" href="utils_8c.html#a94dc56baeb57791e114136764f7763aa">make_cleanup_ui_file_delete</a> (log);
<a name="l03089"></a>03089 
<a name="l03090"></a>03090   <span class="comment">/* Verify that we got a reasonable number of AREGS.  */</span>
<a name="l03091"></a>03091   <span class="keywordflow">if</span> ((tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4f769a0e5c51524a59b35f0841991552">num_aregs</a> &amp; -tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4f769a0e5c51524a59b35f0841991552">num_aregs</a>) != tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4f769a0e5c51524a59b35f0841991552">num_aregs</a>)
<a name="l03092"></a>03092     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (log, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l03093"></a>03093 <span class="stringliteral">\n\tnum_aregs: Number of AR registers (%d) is not a power of two!&quot;</span>),
<a name="l03094"></a>03094                         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a4f769a0e5c51524a59b35f0841991552">num_aregs</a>);
<a name="l03095"></a>03095 
<a name="l03096"></a>03096   <span class="comment">/* Verify that certain registers exist.  */</span>
<a name="l03097"></a>03097 
<a name="l03098"></a>03098   <span class="keywordflow">if</span> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#aaf14dc59eceddbc9a4512ae0ca551cb4">pc_regnum</a> == -1)
<a name="l03099"></a>03099     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (log, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\n\tpc_regnum: No PC register&quot;</span>));
<a name="l03100"></a>03100   <span class="keywordflow">if</span> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a35fde879308a1fd0d92b7122c5c09f9d">isa_use_exceptions</a> &amp;&amp; tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a1c9fe137c00696d7db049cc112dd2370">ps_regnum</a> == -1)
<a name="l03101"></a>03101     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (log, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\n\tps_regnum: No PS register&quot;</span>));
<a name="l03102"></a>03102 
<a name="l03103"></a>03103   <span class="keywordflow">if</span> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#afaaaa609bb630f00c9e50617fcb3e06a">isa_use_windowed_registers</a>)
<a name="l03104"></a>03104     {
<a name="l03105"></a>03105       <span class="keywordflow">if</span> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#afd31bf970a4eb0542d04eb05210a4525">wb_regnum</a> == -1)
<a name="l03106"></a>03106         <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (log, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\n\twb_regnum: No WB register&quot;</span>));
<a name="l03107"></a>03107       <span class="keywordflow">if</span> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a51d3be60216ff45c634db360c0cc0afb">ws_regnum</a> == -1)
<a name="l03108"></a>03108         <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (log, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\n\tws_regnum: No WS register&quot;</span>));
<a name="l03109"></a>03109       <span class="keywordflow">if</span> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a73432cf260ddfd1984970794410c0b59">ar_base</a> == -1)
<a name="l03110"></a>03110         <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (log, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\n\tar_base: No AR registers&quot;</span>));
<a name="l03111"></a>03111     }
<a name="l03112"></a>03112 
<a name="l03113"></a>03113   <span class="keywordflow">if</span> (tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a> == -1)
<a name="l03114"></a>03114     <a class="code" href="utils_8c.html#aa624d49eae7e3e3ee9124fde6c631392">fprintf_unfiltered</a> (log, <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\n\ta0_base: No Ax registers&quot;</span>));
<a name="l03115"></a>03115 
<a name="l03116"></a>03116   buf = <a class="code" href="ui-file_8c.html#a995485039ce5a1d994a1863cd76a5356">ui_file_xstrdup</a> (log, &amp;length);
<a name="l03117"></a>03117   <a class="code" href="cleanups_8c.html#a3d418f8af424aec399898c2d48b26224">make_cleanup</a> (<a class="code" href="common-utils_8c.html#a976e14808b9247ec952c262553f09f8f">xfree</a>, buf);
<a name="l03118"></a>03118   <span class="keywordflow">if</span> (length &gt; 0)
<a name="l03119"></a>03119     <a class="code" href="common-utils_8h.html#aa14285d9d3d4171016ef9cf09447e8bb">internal_error</a> (__FILE__, __LINE__,
<a name="l03120"></a>03120                     <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;the following are invalid: %s&quot;</span>), buf);
<a name="l03121"></a>03121   <a class="code" href="cleanups_8c.html#a8b313a4f1c613973ea444e5fa54976f8">do_cleanups</a> (cleanups);
<a name="l03122"></a>03122 }
<a name="l03123"></a>03123 
<a name="l03124"></a>03124 
<a name="l03125"></a>03125 <span class="comment">/* Derive specific register numbers from the array of registers.  */</span>
<a name="l03126"></a>03126 
<a name="l03127"></a>03127 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03128"></a>03128 xtensa_derive_tdep (<span class="keyword">struct</span> <a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep)
<a name="l03129"></a>03129 {
<a name="l03130"></a>03130   <a class="code" href="structxtensa__register__t.html">xtensa_register_t</a>* <a class="code" href="xtensa-config_8c.html#ab03c56e92d411e7d99155c4f540086f1">rmap</a>;
<a name="l03131"></a>03131   <span class="keywordtype">int</span> n, max_size = 4;
<a name="l03132"></a>03132 
<a name="l03133"></a>03133   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">num_regs</a> = 0;
<a name="l03134"></a>03134   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a8853e139514d84d5bdd8df33a3f67229">num_nopriv_regs</a> = 0;
<a name="l03135"></a>03135 
<a name="l03136"></a>03136 <span class="comment">/* Special registers 0..255 (core).  */</span>
<a name="l03137"></a>03137 <span class="preprocessor">#define XTENSA_DBREGN_SREG(n)  (0x0200+(n))</span>
<a name="l03138"></a>03138 <span class="preprocessor"></span>
<a name="l03139"></a>03139   <span class="keywordflow">for</span> (rmap = tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a19d2226ca2b5d41faacd7affdbcccf73">regmap</a>, n = 0; rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> != -1; n++, rmap++)
<a name="l03140"></a>03140     {
<a name="l03141"></a>03141       <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == 0x0020)
<a name="l03142"></a>03142         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#aaf14dc59eceddbc9a4512ae0ca551cb4">pc_regnum</a> = n;
<a name="l03143"></a>03143       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == 0x0100)
<a name="l03144"></a>03144         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a73432cf260ddfd1984970794410c0b59">ar_base</a> = n;
<a name="l03145"></a>03145       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == 0x0000)
<a name="l03146"></a>03146         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a> = n;
<a name="l03147"></a>03147       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == <a class="code" href="xtensa-tdep_8c.html#a8c2c5a723a228452e0113404cf66f05a">XTENSA_DBREGN_SREG</a>(72))
<a name="l03148"></a>03148         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#afd31bf970a4eb0542d04eb05210a4525">wb_regnum</a> = n;
<a name="l03149"></a>03149       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == <a class="code" href="xtensa-tdep_8c.html#a8c2c5a723a228452e0113404cf66f05a">XTENSA_DBREGN_SREG</a>(73))
<a name="l03150"></a>03150         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a51d3be60216ff45c634db360c0cc0afb">ws_regnum</a> = n;
<a name="l03151"></a>03151       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == <a class="code" href="xtensa-tdep_8c.html#a8c2c5a723a228452e0113404cf66f05a">XTENSA_DBREGN_SREG</a>(233))
<a name="l03152"></a>03152         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a9fd9fb7acb31364143ce98b121d8cf7b">debugcause_regnum</a> = n;
<a name="l03153"></a>03153       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == <a class="code" href="xtensa-tdep_8c.html#a8c2c5a723a228452e0113404cf66f05a">XTENSA_DBREGN_SREG</a>(232))
<a name="l03154"></a>03154         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a377aab05bb23c3477913d16dffa647df">exccause_regnum</a> = n;
<a name="l03155"></a>03155       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == <a class="code" href="xtensa-tdep_8c.html#a8c2c5a723a228452e0113404cf66f05a">XTENSA_DBREGN_SREG</a>(238))
<a name="l03156"></a>03156         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a8c76b417a6d4b43da295681e425b3182">excvaddr_regnum</a> = n;
<a name="l03157"></a>03157       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == <a class="code" href="xtensa-tdep_8c.html#a8c2c5a723a228452e0113404cf66f05a">XTENSA_DBREGN_SREG</a>(0))
<a name="l03158"></a>03158         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#afd0e7969117939be96f5728034387acc">lbeg_regnum</a> = n;
<a name="l03159"></a>03159       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == <a class="code" href="xtensa-tdep_8c.html#a8c2c5a723a228452e0113404cf66f05a">XTENSA_DBREGN_SREG</a>(1))
<a name="l03160"></a>03160         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a67718ac4d3bd87fb4ba405f0ad76df1d">lend_regnum</a> = n;
<a name="l03161"></a>03161       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == <a class="code" href="xtensa-tdep_8c.html#a8c2c5a723a228452e0113404cf66f05a">XTENSA_DBREGN_SREG</a>(2))
<a name="l03162"></a>03162         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a9f31455c1024516239665e6028e2e5c7">lcount_regnum</a> = n;
<a name="l03163"></a>03163       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == <a class="code" href="xtensa-tdep_8c.html#a8c2c5a723a228452e0113404cf66f05a">XTENSA_DBREGN_SREG</a>(3))
<a name="l03164"></a>03164         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ab8c838b77cd30602dc5d3e5586e9acdb">sar_regnum</a> = n;
<a name="l03165"></a>03165       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == <a class="code" href="xtensa-tdep_8c.html#a8c2c5a723a228452e0113404cf66f05a">XTENSA_DBREGN_SREG</a>(5))
<a name="l03166"></a>03166         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a0623d3dd80a969d0e7986fc4db27f9f2">litbase_regnum</a> = n;
<a name="l03167"></a>03167       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == <a class="code" href="xtensa-tdep_8c.html#a8c2c5a723a228452e0113404cf66f05a">XTENSA_DBREGN_SREG</a>(230))
<a name="l03168"></a>03168         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a1c9fe137c00696d7db049cc112dd2370">ps_regnum</a> = n;
<a name="l03169"></a>03169 <span class="preprocessor">#if 0</span>
<a name="l03170"></a>03170 <span class="preprocessor"></span>      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == <a class="code" href="xtensa-tdep_8c.html#a8c2c5a723a228452e0113404cf66f05a">XTENSA_DBREGN_SREG</a>(226))
<a name="l03171"></a>03171         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#ae3eaa6183ba9411dc223190925e98acc">interrupt_regnum</a> = n;
<a name="l03172"></a>03172       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == <a class="code" href="xtensa-tdep_8c.html#a8c2c5a723a228452e0113404cf66f05a">XTENSA_DBREGN_SREG</a>(227))
<a name="l03173"></a>03173         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a3ae20d96a61e35f5cd01ec4b40f6f703">interrupt2_regnum</a> = n;
<a name="l03174"></a>03174       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#aa24d2820f8214c1a3efac12e15507663">target_number</a> == <a class="code" href="xtensa-tdep_8c.html#a8c2c5a723a228452e0113404cf66f05a">XTENSA_DBREGN_SREG</a>(224))
<a name="l03175"></a>03175         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a788cb5ae2ed6f43c34373f378963e5bd">cpenable_regnum</a> = n;
<a name="l03176"></a>03176 <span class="preprocessor">#endif</span>
<a name="l03177"></a>03177 <span class="preprocessor"></span>
<a name="l03178"></a>03178       <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#a02349ab43200a457c2144728e7af4f22">byte_size</a> &gt; max_size)
<a name="l03179"></a>03179         max_size = rmap-&gt;<a class="code" href="structxtensa__register__t.html#a02349ab43200a457c2144728e7af4f22">byte_size</a>;
<a name="l03180"></a>03180       <span class="keywordflow">if</span> (rmap-&gt;<a class="code" href="structxtensa__register__t.html#ae651b2afab674bc8a4ad8be64c8b7e98">mask</a> != 0 &amp;&amp; tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">num_regs</a> == 0)
<a name="l03181"></a>03181         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">num_regs</a> = n;
<a name="l03182"></a>03182       <span class="comment">/* Find out out how to deal with priveleged registers.</span>
<a name="l03183"></a>03183 <span class="comment"></span>
<a name="l03184"></a>03184 <span class="comment">         if ((rmap-&gt;flags &amp; XTENSA_REGISTER_FLAGS_PRIVILEGED) != 0</span>
<a name="l03185"></a>03185 <span class="comment">              &amp;&amp; tdep-&gt;num_nopriv_regs == 0)</span>
<a name="l03186"></a>03186 <span class="comment">           tdep-&gt;num_nopriv_regs = n;</span>
<a name="l03187"></a>03187 <span class="comment">      */</span>
<a name="l03188"></a>03188       <span class="keywordflow">if</span> ((rmap-&gt;<a class="code" href="structxtensa__register__t.html#a4979d750a9c1c637e9c78bfb6dbea291">flags</a> &amp; <a class="code" href="xtensa-tdep_8h.html#afce353f01469379266480c1fb53ed982">XTENSA_REGISTER_FLAGS_PRIVILEGED</a>) != 0
<a name="l03189"></a>03189           &amp;&amp; tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">num_regs</a> == 0)
<a name="l03190"></a>03190         tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">num_regs</a> = n;
<a name="l03191"></a>03191     }
<a name="l03192"></a>03192 
<a name="l03193"></a>03193   <span class="comment">/* Number of pseudo registers.  */</span>
<a name="l03194"></a>03194   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6ff437cdade19a7a78dde8f54e067717">num_pseudo_regs</a> = n - tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">num_regs</a>;
<a name="l03195"></a>03195 
<a name="l03196"></a>03196   <span class="comment">/* Empirically determined maximum sizes.  */</span>
<a name="l03197"></a>03197   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a560e4433c77ea24740d95faffb50bdd9">max_register_raw_size</a> = max_size;
<a name="l03198"></a>03198   tdep-&gt;<a class="code" href="structgdbarch__tdep.html#acec66d91e9e91063fb804ec3ad2f2f1d">max_register_virtual_size</a> = max_size;
<a name="l03199"></a>03199 }
<a name="l03200"></a>03200 
<a name="l03201"></a>03201 <span class="comment">/* Module &quot;constructor&quot; function.  */</span>
<a name="l03202"></a>03202 
<a name="l03203"></a>03203 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> <a class="code" href="xtensa-tdep_8c.html#a490f4f8a54df33f31b6859ef523e4dc4">xtensa_tdep</a>;
<a name="l03204"></a>03204 
<a name="l03205"></a>03205 <span class="keyword">static</span> <span class="keyword">struct </span>gdbarch *
<a name="l03206"></a>03206 xtensa_gdbarch_init (<span class="keyword">struct</span> <a class="code" href="structgdbarch__info.html">gdbarch_info</a> info, <span class="keyword">struct</span> <a class="code" href="structgdbarch__list.html">gdbarch_list</a> *arches)
<a name="l03207"></a>03207 {
<a name="l03208"></a>03208   <span class="keyword">struct </span><a class="code" href="structgdbarch__tdep.html">gdbarch_tdep</a> *tdep;
<a name="l03209"></a>03209   <span class="keyword">struct </span>gdbarch *gdbarch;
<a name="l03210"></a>03210   <span class="keyword">struct </span>xtensa_abi_handler *abi_handler;
<a name="l03211"></a>03211 
<a name="l03212"></a>03212   <a class="code" href="xtensa-tdep_8c.html#a2c130cf25d323e07a306e9618f42b985">DEBUGTRACE</a> (<span class="stringliteral">&quot;gdbarch_init()\n&quot;</span>);
<a name="l03213"></a>03213 
<a name="l03214"></a>03214   <span class="comment">/* We have to set the byte order before we call gdbarch_alloc.  */</span>
<a name="l03215"></a>03215   info.<a class="code" href="structgdbarch__info.html#a3e00b4a4262051d8be65696b48662225">byte_order</a> = XCHAL_HAVE_BE ? BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;
<a name="l03216"></a>03216 
<a name="l03217"></a>03217   tdep = &amp;<a class="code" href="xtensa-tdep_8c.html#a490f4f8a54df33f31b6859ef523e4dc4">xtensa_tdep</a>;
<a name="l03218"></a>03218   gdbarch = <a class="code" href="gdbarch_8c.html#a9e0b0979fa2cb7439f41f66deda8dec5">gdbarch_alloc</a> (&amp;info, tdep);
<a name="l03219"></a>03219   xtensa_derive_tdep (tdep);
<a name="l03220"></a>03220 
<a name="l03221"></a>03221   <span class="comment">/* Verify our configuration.  */</span>
<a name="l03222"></a>03222   xtensa_verify_config (gdbarch);
<a name="l03223"></a>03223   xtensa_session_once_reported = 0;
<a name="l03224"></a>03224 
<a name="l03225"></a>03225   <span class="comment">/* Pseudo-Register read/write.  */</span>
<a name="l03226"></a>03226   <a class="code" href="gdbarch_8c.html#a99fd57c1a882cf61c413e64028937a1b">set_gdbarch_pseudo_register_read</a> (gdbarch, xtensa_pseudo_register_read);
<a name="l03227"></a>03227   <a class="code" href="gdbarch_8c.html#ae463eca1992acf69ff1bc28ed8ca3aea">set_gdbarch_pseudo_register_write</a> (gdbarch, xtensa_pseudo_register_write);
<a name="l03228"></a>03228 
<a name="l03229"></a>03229   <span class="comment">/* Set target information.  */</span>
<a name="l03230"></a>03230   <a class="code" href="gdbarch_8c.html#ad8417c5d66cf04d0587f58f82de94c48">set_gdbarch_num_regs</a> (gdbarch, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a083bd3bbf2c561bb72054acc63a1ee6e">num_regs</a>);
<a name="l03231"></a>03231   <a class="code" href="gdbarch_8c.html#aaf72e08f972ba348d5d28f6b6b8db638">set_gdbarch_num_pseudo_regs</a> (gdbarch, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a6ff437cdade19a7a78dde8f54e067717">num_pseudo_regs</a>);
<a name="l03232"></a>03232   <a class="code" href="gdbarch_8c.html#a81a92a88a67093d18e59fd5650fda352">set_gdbarch_sp_regnum</a> (gdbarch, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a47982a4f8d5ffdc30f7fe88447671843">a0_base</a> + 1);
<a name="l03233"></a>03233   <a class="code" href="gdbarch_8c.html#a8852f70e2afc74953a57521ed08a3381">set_gdbarch_pc_regnum</a> (gdbarch, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#aaf14dc59eceddbc9a4512ae0ca551cb4">pc_regnum</a>);
<a name="l03234"></a>03234   <a class="code" href="gdbarch_8c.html#a0f88447385153c3d9e0098e4bef9f469">set_gdbarch_ps_regnum</a> (gdbarch, tdep-&gt;<a class="code" href="structgdbarch__tdep.html#a1c9fe137c00696d7db049cc112dd2370">ps_regnum</a>);
<a name="l03235"></a>03235 
<a name="l03236"></a>03236   <span class="comment">/* Renumber registers for known formats (stabs and dwarf2).  */</span>
<a name="l03237"></a>03237   <a class="code" href="gdbarch_8c.html#abeb6b220ed850a9f2b4a992dfcae9a2b">set_gdbarch_stab_reg_to_regnum</a> (gdbarch, xtensa_reg_to_regnum);
<a name="l03238"></a>03238   <a class="code" href="gdbarch_8c.html#a43ca55f05fcf599681eb376bbc6c8ece">set_gdbarch_dwarf2_reg_to_regnum</a> (gdbarch, xtensa_reg_to_regnum);
<a name="l03239"></a>03239 
<a name="l03240"></a>03240   <span class="comment">/* We provide our own function to get register information.  */</span>
<a name="l03241"></a>03241   <a class="code" href="gdbarch_8c.html#a378ba40a6275393e204873c5bba602ad">set_gdbarch_register_name</a> (gdbarch, xtensa_register_name);
<a name="l03242"></a>03242   <a class="code" href="gdbarch_8c.html#a21919f6adfae80ed36e69e89cdfea531">set_gdbarch_register_type</a> (gdbarch, xtensa_register_type);
<a name="l03243"></a>03243 
<a name="l03244"></a>03244   <span class="comment">/* To call functions from GDB using dummy frame.  */</span>
<a name="l03245"></a>03245   <a class="code" href="gdbarch_8c.html#a853528dceff46211c1bb8c57b77dca31">set_gdbarch_push_dummy_call</a> (gdbarch, xtensa_push_dummy_call);
<a name="l03246"></a>03246 
<a name="l03247"></a>03247   <a class="code" href="gdbarch_8c.html#a5fad1810477fcfdccf7604c41fe299b8">set_gdbarch_believe_pcc_promotion</a> (gdbarch, 1);
<a name="l03248"></a>03248 
<a name="l03249"></a>03249   <a class="code" href="gdbarch_8c.html#ad9b13a9323cac027c4b805953b4fff63">set_gdbarch_return_value</a> (gdbarch, xtensa_return_value);
<a name="l03250"></a>03250 
<a name="l03251"></a>03251   <span class="comment">/* Advance PC across any prologue instructions to reach &quot;real&quot; code.  */</span>
<a name="l03252"></a>03252   <a class="code" href="gdbarch_8c.html#a841509ae0070f2f12aa9b3b7fd52b92f">set_gdbarch_skip_prologue</a> (gdbarch, xtensa_skip_prologue);
<a name="l03253"></a>03253 
<a name="l03254"></a>03254   <span class="comment">/* Stack grows downward.  */</span>
<a name="l03255"></a>03255   <a class="code" href="gdbarch_8c.html#ad66381ed135b13aa5635f0485211ca71">set_gdbarch_inner_than</a> (gdbarch, <a class="code" href="arch-utils_8c.html#aaceae1c07203f3091df647f813b9f20e">core_addr_lessthan</a>);
<a name="l03256"></a>03256 
<a name="l03257"></a>03257   <span class="comment">/* Set breakpoints.  */</span>
<a name="l03258"></a>03258   <a class="code" href="gdbarch_8c.html#ad738cdf37fa27f4cf3642107cadf61d3">set_gdbarch_breakpoint_from_pc</a> (gdbarch, xtensa_breakpoint_from_pc);
<a name="l03259"></a>03259 
<a name="l03260"></a>03260   <span class="comment">/* After breakpoint instruction or illegal instruction, pc still</span>
<a name="l03261"></a>03261 <span class="comment">     points at break instruction, so don&#39;t decrement.  */</span>
<a name="l03262"></a>03262   <a class="code" href="gdbarch_8c.html#a59e0f429a0c89806415bb5e1b7367bb8">set_gdbarch_decr_pc_after_break</a> (gdbarch, 0);
<a name="l03263"></a>03263 
<a name="l03264"></a>03264   <span class="comment">/* We don&#39;t skip args.  */</span>
<a name="l03265"></a>03265   <a class="code" href="gdbarch_8c.html#affeacd014397bbaf442f32de0cb4b86c">set_gdbarch_frame_args_skip</a> (gdbarch, 0);
<a name="l03266"></a>03266 
<a name="l03267"></a>03267   <a class="code" href="gdbarch_8c.html#a1974f5f26c09a4cd32165286c3769621">set_gdbarch_unwind_pc</a> (gdbarch, xtensa_unwind_pc);
<a name="l03268"></a>03268 
<a name="l03269"></a>03269   <a class="code" href="gdbarch_8c.html#aff48f6a8b2982831522fc7b3af596654">set_gdbarch_frame_align</a> (gdbarch, xtensa_frame_align);
<a name="l03270"></a>03270 
<a name="l03271"></a>03271   <a class="code" href="gdbarch_8c.html#a23da982924f904d22d0b58639a48bccf">set_gdbarch_dummy_id</a> (gdbarch, xtensa_dummy_id);
<a name="l03272"></a>03272 
<a name="l03273"></a>03273   <span class="comment">/* Frame handling.  */</span>
<a name="l03274"></a>03274   <a class="code" href="frame-base_8c.html#afc9e209b41e14278fb1ab72c1d3c6e5d">frame_base_set_default</a> (gdbarch, &amp;xtensa_frame_base);
<a name="l03275"></a>03275   <a class="code" href="frame-unwind_8c.html#afa4de8a130514bfd524d46f32e35a534">frame_unwind_append_unwinder</a> (gdbarch, &amp;xtensa_unwind);
<a name="l03276"></a>03276   <a class="code" href="dwarf2-frame_8c.html#ab2a0a14bba7f1db72907039eb3356975">dwarf2_append_unwinders</a> (gdbarch);
<a name="l03277"></a>03277 
<a name="l03278"></a>03278   <a class="code" href="gdbarch_8c.html#a0c9e9e391e44d476b74debefc407e9bb">set_gdbarch_print_insn</a> (gdbarch, print_insn_xtensa);
<a name="l03279"></a>03279 
<a name="l03280"></a>03280   <a class="code" href="gdbarch_8c.html#a6143b9e1e9c2f9cc83ab8a64424e9219">set_gdbarch_have_nonsteppable_watchpoint</a> (gdbarch, 1);
<a name="l03281"></a>03281 
<a name="l03282"></a>03282   xtensa_add_reggroups (gdbarch);
<a name="l03283"></a>03283   <a class="code" href="gdbarch_8c.html#a17301533b8e9f7002350ed0a2f4b5558">set_gdbarch_register_reggroup_p</a> (gdbarch, xtensa_register_reggroup_p);
<a name="l03284"></a>03284 
<a name="l03285"></a>03285   <a class="code" href="gdbarch_8c.html#ab33881224f11fe054d4f4dee5b0d6844">set_gdbarch_regset_from_core_section</a> (gdbarch,
<a name="l03286"></a>03286                                         xtensa_regset_from_core_section);
<a name="l03287"></a>03287 
<a name="l03288"></a>03288   <a class="code" href="solib-svr4_8c.html#a10d31439da2b63753298b3b83865465e">set_solib_svr4_fetch_link_map_offsets</a>
<a name="l03289"></a>03289     (gdbarch, <a class="code" href="solib-svr4_8c.html#aa94176d616f07f4d2fe239a370103c9f">svr4_ilp32_fetch_link_map_offsets</a>);
<a name="l03290"></a>03290 
<a name="l03291"></a>03291   <span class="keywordflow">return</span> gdbarch;
<a name="l03292"></a>03292 }
<a name="l03293"></a>03293 
<a name="l03294"></a>03294 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03295"></a>03295 xtensa_dump_tdep (<span class="keyword">struct</span> gdbarch *gdbarch, <span class="keyword">struct</span> ui_file *file)
<a name="l03296"></a>03296 {
<a name="l03297"></a>03297   <a class="code" href="utils_8c.html#a279e952362d12544d9bebc26660fec4b">error</a> (<a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;xtensa_dump_tdep(): not implemented&quot;</span>));
<a name="l03298"></a>03298 }
<a name="l03299"></a>03299 
<a name="l03300"></a>03300 <span class="comment">/* Provide a prototype to silence -Wmissing-prototypes.  */</span>
<a name="l03301"></a>03301 <span class="keyword">extern</span> <a class="code" href="defs_8h.html#a686ed07d4fdcdc366f2bc677216ca08d">initialize_file_ftype</a> <a class="code" href="xtensa-tdep_8c.html#a67d2cff92ad76b615d0f216b5a416cee">_initialize_xtensa_tdep</a>;
<a name="l03302"></a>03302 
<a name="l03303"></a><a class="code" href="xtensa-tdep_8c.html#a38ada094643e778bd510e89524eb9910">03303</a> <span class="keywordtype">void</span>
<a name="l03304"></a>03304 _initialize_xtensa_tdep (<span class="keywordtype">void</span>)
<a name="l03305"></a>03305 {
<a name="l03306"></a>03306   <span class="keyword">struct </span><a class="code" href="structcmd__list__element.html">cmd_list_element</a> *c;
<a name="l03307"></a>03307 
<a name="l03308"></a>03308   <a class="code" href="gdbarch_8c.html#a7583cf6ebd6f4484dec544d7d1af38a1">gdbarch_register</a> (bfd_arch_xtensa, xtensa_gdbarch_init, xtensa_dump_tdep);
<a name="l03309"></a>03309   xtensa_init_reggroups ();
<a name="l03310"></a>03310 
<a name="l03311"></a>03311   <a class="code" href="cli-decode_8c.html#ae32b914a6e0676efa41e6281007a75c1">add_setshow_zuinteger_cmd</a> (<span class="stringliteral">&quot;xtensa&quot;</span>,
<a name="l03312"></a>03312                              <a class="code" href="command_8h.html#ad71b5a938f3966cf81293bca79acef49a502c7b57c7172ac88ef735f68070bb59">class_maintenance</a>,
<a name="l03313"></a>03313                              &amp;xtensa_debug_level,
<a name="l03314"></a>03314                             <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Set Xtensa debugging.&quot;</span>),
<a name="l03315"></a>03315                             <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;Show Xtensa debugging.&quot;</span>), <a class="code" href="gdb__locale_8h.html#a32a3cf3d9dd914f5aeeca5423c157934">_</a>(<span class="stringliteral">&quot;\</span>
<a name="l03316"></a>03316 <span class="stringliteral">When non-zero, Xtensa-specific debugging is enabled. \</span>
<a name="l03317"></a>03317 <span class="stringliteral">Can be 1, 2, 3, or 4 indicating the level of debugging.&quot;</span>),
<a name="l03318"></a>03318                              NULL,
<a name="l03319"></a>03319                              NULL,
<a name="l03320"></a>03320                              &amp;<a class="code" href="cli-cmds_8c.html#ae5f16c782e4a29124f3175f4a6285244">setdebuglist</a>, &amp;<a class="code" href="cli-cmds_8c.html#a7e2eed475764f70df1e9c0f5d2476a11">showdebuglist</a>);
<a name="l03321"></a>03321 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2013 14:12:28 for GDB (API) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
